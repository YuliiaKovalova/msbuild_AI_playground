diff --git a/.github/ISSUE_TEMPLATE/01_bugreport.md b/.github/ISSUE_TEMPLATE/01_bugreport.md
new file mode 100644
index 00000000000..3d8e508c782
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/01_bugreport.md
@@ -0,0 +1,58 @@
+---
+name: üêû Bug Report
+about: Report a bug to help us improve MSBuild.
+title: ''
+labels: bug, untriaged
+---
+
+<!-- This is a template that helps us provide quicker feedback. Please use any relevant sections and delete anything you don't need. -->
+
+### Issue Description
+<!--
+* Please include a clear and concise description of the problem.
+-->
+
+### Steps to Reproduce
+<!--
+* Include as much of the following as possible:
+
+* A minimal sample project that reproduces the issue.
+* Your zipped project.
+* IDE / CLI steps to create the project and reproduce the behaviour.
+* Your command line invocation
+-->
+
+### Expected Behavior
+<!--
+* The expected output or behavior.
+-->
+
+### Actual Behavior
+<!--
+* The actual output or behavior.
+-->
+
+### Analysis
+<!--
+* If you have an idea where the problem might lie, let us know that here.
+* Please include any pointers to code, relevant changes, or related issues you know of.
+-->
+
+### Versions & Configurations
+<!--
+* In a Visual Studio developer command prompt, run `msbuild -version` and paste the output here.
+* If applicable, include the version of the tool that invokes MSBuild (Visual Studio, dotnet CLI, etc):
+
+* Post any other relevant configuration settings here.
+*   OS, architecture, etc.
+-->
+
+### Attach a binlog
+<!--
+* If providing us a project that reproduces the issue proves difficult, consider including a binlog.
+* Click [here](https://aka.ms/msbuild/binlog) for details on sharing binary logs.
+* Click [here](https://github.com/microsoft/msbuild/blob/master/documentation/wiki/Binary-Log.md) for more information on binary logs.
+    NOTE: Binlogs can contain sensitive information. Don't attach anything you don't want to be public.
+
+*   To view the contents of the binlogs yourself, you may wish to use a tool like https://msbuildlog.com/.
+-->
\ No newline at end of file
diff --git a/.github/ISSUE_TEMPLATE/02_performanceissue.md b/.github/ISSUE_TEMPLATE/02_performanceissue.md
new file mode 100644
index 00000000000..e3d875c8f91
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/02_performanceissue.md
@@ -0,0 +1,69 @@
+---
+name: üìâ Performance Issue
+about: Report a performance issue or regression.
+title: ''
+labels: performance, untriaged
+---
+
+<!-- This is a template that helps us provide quicker feedback. Please use any relevant sections and delete anything you don't need. -->
+
+### Issue Description
+<!--
+* Please include a clear and concise description of the problem.
+-->
+
+### Steps to Reproduce
+<!--
+Include as much of the following if possible:
+
+* A minimal sample project that reproduces the issue.
+* Your zipped project.
+* IDE / CLI steps to create the project and reproduce the behaviour.
+* Your command line invocation
+-->
+
+### Data
+<!--
+* Please include all information you've gathered about this performance issue. This includes:
+    - Timing
+    - Measurements
+    - ETW Traces
+    - Call stacks
+    - Dumps
+    - etc.
+* If possible please include text as text rather than images (so it shows up in searches).
+* If applicable please include before and after measurements.
+-->
+
+### Analysis
+<!--
+* If you have an idea where the problem might lie, let us know that here.
+* Please include any pointers to code, relevant changes, or related issues you know of.
+-->
+
+### Versions & Configurations
+<!--
+* In a Visual Studio developer command prompt, run `msbuild -version` and paste the output here.
+* If applicable, include the version of the tool that invokes MSBuild (Visual Studio, dotnet CLI, etc):
+
+Post any other relevant configuration settings here.
+* OS, architecture, etc.
+-->
+
+### Regression?
+<!--
+* Is this a regression from a previous build/release?
+* Please provide details on:
+*   What version of MSBuild or VS were you using before the regression?
+*   What version of MSBuild or VS are you on now that you discovered the regression?
+-->
+
+### Attach a binlog
+<!--
+* If providing us a project that reproduces the issue proves difficult, consider including a binlog.
+* Click [here](https://aka.ms/msbuild/binlog) for details on sharing binary logs.
+* Click [here](https://github.com/microsoft/msbuild/blob/master/documentation/wiki/Binary-Log.md) for more information on binary logs.
+    NOTE: Binlogs can contain sensitive information. Don't attach anything you don't want to be public.
+
+*   To view the contents of the binlogs yourself, you may wish to use a tool like https://msbuildlog.com/.
+-->
\ No newline at end of file
diff --git a/.github/ISSUE_TEMPLATE/03_mybuildisbroken.md b/.github/ISSUE_TEMPLATE/03_mybuildisbroken.md
new file mode 100644
index 00000000000..19dcf3094f1
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/03_mybuildisbroken.md
@@ -0,0 +1,47 @@
+---
+name: üòµ My Build is Broken
+about: Use this template for helping figure out what's wrong with your build.
+title: ''
+labels: untriaged
+---
+
+<!-- NOTE: The MSBuild team receives a lot of issues and we need to prioritize them accordingly. Please understand that we may not get to your issue for some time. -->
+<!-- This is a template that helps us provide quicker feedback. Please use any relevant sections and delete anything you don't need. -->
+
+<!--
+* Here are some useful links to help you figure out what's wrong.
+* Our wiki: https://github.com/microsoft/msbuild/blob/master/documentation/wiki/Home.md
+* General Help: https://github.com/microsoft/msbuild/blob/master/documentation/wiki/Something's-wrong-in-my-build.md
+* Tips & Tricks: https://github.com/microsoft/msbuild/blob/master/documentation/wiki/MSBuild-Tips-%26-Tricks.md
+-->
+
+### Issue Description
+<!--
+* Please include a clear and concise description of the problem.
+-->
+
+### Steps to Reproduce
+<!--
+* Include as much of the following if possible:
+
+* A minimal sample project that reproduces the issue.
+* Your zipped project.
+* IDE / CLI steps to create the project and reproduce the behaviour.
+* Your command line invocation
+-->
+
+### Expected Behavior
+<!--
+* Include what you are trying to do, and the expected output or behavior.
+-->
+
+### Actual Behavior
+<!--
+* Include the actual output or behavior.
+-->
+
+### Ask us questions
+<!--
+* We ask that you first browse the above links, as your question may already have been answered.
+* Be as detailed as you can with these questions.
+-->
\ No newline at end of file
diff --git a/.github/ISSUE_TEMPLATE/config.yml b/.github/ISSUE_TEMPLATE/config.yml
new file mode 100644
index 00000000000..63f52d67500
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/config.yml
@@ -0,0 +1,26 @@
+blank_issues_enabled: true
+contact_links:
+  - name: Issue with .NET (Core) SDK
+    url:  https://github.com/dotnet/sdk/issues/new/choose
+    about: Please open issues relating to the .NET Core SDK or .NET 5.0+ SDK in `dotnet/sdk`. If you're not sure whether a bug is more appropriate here or in the SDK, take your best guess and we can always move it.
+  - name: Issue with Project System
+    url:  https://github.com/dotnet/project-system/issues/new/choose
+    about: Please open issues relating to how Visual Studio interacts with MSBuild for C#/VB/F# projects in `dotnet/project-system`.
+  - name: Issue with Visual Studio
+    url:  https://developercommunity.visualstudio.com/spaces/8/index.html
+    about: Please open issues relating to Visual Studio using Visual Studio Feedback. If you're not sure whether the problem is with Visual Studio or MSBuild itself, please start with Visual Studio; we can move the bug here if necessary.
+  - name: Issue with Roslyn compiler
+    url:  https://github.com/dotnet/roslyn/issues/new/choose
+    about: Please open issues relating to the Roslyn C# and Visual Basic compiler or language features in `dotnet/roslyn`. These are often error code `CSxxxx` or `VBxxxx`.
+  - name: Issue with .NET runtime or core .NET libraries
+    url:  https://github.com/dotnet/runtime/issues/new/choose
+    about: Please open issues with the .NET runtime or core .NET libraries in the `dotnet/runtime` repo.
+  - name: Issue with Windows Forms
+    url:  https://github.com/dotnet/winforms/issues/new/choose
+    about: Please open issues relating to Windows Forms in `dotnet/winforms`, including build issues specific to forms.
+  - name: Issue with ASP.NET Core
+    url:  https://github.com/dotnet/aspnetcore/issues/new/choose
+    about: Please open issues relating to ASP.NET Core in `dotnet/aspnetcore`, including build issues specific to ASP.NET.
+  - name: Issue with WPF
+    url:  https://github.com/dotnet/wpf/issues/new/choose
+    about: Please open issues relating to WPF in `dotnet/wpf`, including build issues specific to WPF.
\ No newline at end of file
diff --git a/.github/PULL_REQUEST_TEMPLATE/pull_request_template.md b/.github/PULL_REQUEST_TEMPLATE/pull_request_template.md
new file mode 100644
index 00000000000..95898c21f51
--- /dev/null
+++ b/.github/PULL_REQUEST_TEMPLATE/pull_request_template.md
@@ -0,0 +1,5 @@
+Fixes #
+
+<!--
+Insert a brief description of your changes here.
+-->
\ No newline at end of file
diff --git a/.github/PULL_REQUEST_TEMPLATE/shiproom.md b/.github/PULL_REQUEST_TEMPLATE/shiproom.md
new file mode 100644
index 00000000000..2d711c93140
--- /dev/null
+++ b/.github/PULL_REQUEST_TEMPLATE/shiproom.md
@@ -0,0 +1,17 @@
+Fixes #
+
+Work item (Internal use): 
+
+### Summary
+
+
+### Customer Impact
+
+
+### Regression?
+
+
+### Testing
+
+
+### Risk
diff --git a/.github/issue_template.md b/.github/issue_template.md
deleted file mode 100644
index 7aedcdf41d2..00000000000
--- a/.github/issue_template.md
+++ /dev/null
@@ -1,46 +0,0 @@
-### Steps to reproduce
-
-Either include a project sample, attach a zipped project, or provide IDE / CLI steps to create the project and repro the behaviour. Example of a project sample:
-
-Project file
-```xml
-<Project>
-  <PropertyGroup>
-    <Extension>cs</Extension>
-  </PropertyGroup>
-  
-  <ItemGroup>
-    <I Include="**/*.$(Extension)"/>
-  </ItemGroup>
-  
-  <Target Name="Build">
-    <Message Text="I: %(I.Identity)"/>
-  </Target>
-</Project>
-```
-
-Directory contents:
-```
-/
-- a.cs
-- b.cs
-- dir/
-     - c.cs
-```
-
-Command line
-```
-msbuild /bl
-```
-### Expected behavior
-
-
-### Actual behavior
-
-
-### Environment data
-`msbuild /version` output:
-
-OS info:
-
-If applicable, version of the tool that invokes MSBuild (Visual Studio, dotnet CLI, etc):
diff --git a/.gitignore b/.gitignore
index cc15003e7c1..e902f62318d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -218,5 +218,7 @@ Samples/MultiprocessBuild/PortableTask.dll
 
 #Stage1 build folder for when doing bootstrap builds
 stage1/
+.tools
 
-.tools
\ No newline at end of file
+# ETL traces    
+*.etl.zip
\ No newline at end of file
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index c816e8f283d..a706deeb393 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -147,11 +147,11 @@ stages:
         ArtifactName: logs
       condition: succeededOrFailed()
 
-    - task: PublishBuildArtifacts@1
-      displayName: 'Publish Artifact: symbols'
+    - task: PublishPipelineArtifact@1
+      displayName: 'Publish Artifact: bin'
       inputs:
-        PathtoPublish: 'artifacts\bin'
-        ArtifactName: symbols
+        path: 'artifacts\bin'
+        artifactName: bin
       condition: succeededOrFailed()
 
     # Publishes setup VSIXes to a drop.
@@ -181,6 +181,15 @@ stages:
         ArtifactName: PackageArtifacts
       condition: succeeded()
 
+    # Publish "IntelliSense" XSD files to their own artifact
+    # so it can be consumed by the insertion-to-VS job
+    - task: PublishPipelineArtifact@1
+      displayName: 'Publish Artifact: xsd'
+      inputs:
+        path: 'artifacts\xsd'
+        artifactName: xsd
+      condition: succeeded()
+
     # Publish Asset Manifests for Build Asset Registry job
     - task: PublishBuildArtifacts@1
       displayName: Publish Asset Manifests
diff --git a/Directory.Build.props b/Directory.Build.props
index 1683a4c99e3..06f7144e812 100644
--- a/Directory.Build.props
+++ b/Directory.Build.props
@@ -51,7 +51,7 @@
         NU5125: Arcade uses licenseUrl when doing pack, which now causes NU5125 warning. This disables that warning until arcade can switch over.
     -->
 
-    <NoWarn>$(NoWarn);NU1603;NU5105;NU5125;1701;1702</NoWarn>
+    <NoWarn>$(NoWarn);NU1603;NU5105;NU5125;1701;1702;VSTHRD002;VSTHRD105;VSTHRD110;VSTHRD200</NoWarn>
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(Configuration)' == 'Debug-MONO'">
diff --git a/MSBuild.Dev.sln b/MSBuild.Dev.sln
index 8fc92510fca..395bc1d6691 100644
--- a/MSBuild.Dev.sln
+++ b/MSBuild.Dev.sln
@@ -5,8 +5,8 @@ VisualStudioVersion = 15.0.27004.2009
 MinimumVisualStudioVersion = 10.0.40219.1
 Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{4900B3B8-4310-4D5B-B1F7-2FDF9199765F}"
 	ProjectSection(SolutionItems) = preProject
-		..\NuGet.Config = ..\NuGet.Config
-		..\targets\xunit.runner.json = ..\targets\xunit.runner.json
+		NuGet.Config = NuGet.Config
+		src\Shared\UnitTests\xunit.runner.json = src\Shared\UnitTests\xunit.runner.json
 	EndProjectSection
 EndProject
 Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build", "src\Build\Microsoft.Build.csproj", "{69BE05E2-CBDA-4D27-9733-44E12B0F5627}"
diff --git a/MSBuild.sln b/MSBuild.sln
index 2dd92702cdb..105c979813e 100644
--- a/MSBuild.sln
+++ b/MSBuild.sln
@@ -5,8 +5,8 @@ VisualStudioVersion = 15.0.27004.2009
 MinimumVisualStudioVersion = 10.0.40219.1
 Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{4900B3B8-4310-4D5B-B1F7-2FDF9199765F}"
 	ProjectSection(SolutionItems) = preProject
-		..\NuGet.Config = ..\NuGet.Config
-		..\targets\xunit.runner.json = ..\targets\xunit.runner.json
+		NuGet.Config = NuGet.Config
+		src\Shared\UnitTests\xunit.runner.json = src\Shared\UnitTests\xunit.runner.json
 	EndProjectSection
 EndProject
 Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Samples", "Samples", "{760FF85D-8BEB-4992-8095-A9678F88FD47}"
diff --git a/NuGet.config b/NuGet.config
index 5e45df013f4..cda7383f71e 100644
--- a/NuGet.config
+++ b/NuGet.config
@@ -10,4 +10,5 @@
     <add key="roslyn-tools" value="https://dotnet.myget.org/F/roslyn-tools/api/v3/index.json" />
     <add key="dotnet-tools" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json" />
   </packageSources>
+  <disabledPackageSources />
 </configuration>
diff --git a/PerfViewData.etl.zip b/PerfViewData.etl.zip
deleted file mode 100644
index 823543440d2..00000000000
Binary files a/PerfViewData.etl.zip and /dev/null differ
diff --git a/README.md b/README.md
index c8331538f45..b81b6c6c627 100644
--- a/README.md
+++ b/README.md
@@ -6,13 +6,13 @@ For more information on MSBuild, see the [MSBuild documentation](https://docs.mi
 
 ### Build Status
 
-The current development branch is `master`. Changes in `master` will go into a future update of MSBuild, which will release with Visual Studio 16.7 and a corresponding version of the .NET Core SDK.
+The current development branch is `master`. Changes in `master` will go into a future update of MSBuild, which will release with Visual Studio 16.8 and a corresponding version of the .NET Core SDK.
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=master)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=master)
 
-We have forked for MSBuild 16.6 in the branch [`vs16.6`](https://github.com/Microsoft/msbuild/tree/vs16.6). Changes to that branch need special approval.
+We have forked for MSBuild 16.7 in the branch [`vs16.7`](https://github.com/Microsoft/msbuild/tree/vs16.7). Changes to that branch need special approval.
 
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.6)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=vs16.6)
+[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.7)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=vs16.7)
 
 MSBuild 16.4 builds from the branch [`vs16.4`](https://github.com/Microsoft/msbuild/tree/vs16.4). Only high-priority bugfixes will be considered for servicing 16.4.
 
@@ -24,11 +24,6 @@ MSBuild 16.0 builds from the branch [`vs16.0`](https://github.com/Microsoft/msbu
 
 MSBuild 15.9 builds from the branch [`vs15.9`](https://github.com/Microsoft/msbuild/tree/vs15.9). Only very-high-priority bugfixes will be considered for servicing 15.9.
 
-| Runtime\OS | Windows | Ubuntu 16.04 |Mac OS X|
-|:------|:------:|:------:|:------:|
-| **Full Framework** |[![Build Status](https://ci2.dot.net/buildStatus/icon?job=Microsoft_msbuild/vs15.9/innerloop_Windows_NT_Full)](https://ci2.dot.net/job/Microsoft_msbuild/job/vs15.9/job/innerloop_Windows_NT_Full)| N/A | N/A | N/A |
-|**.NET Core**|[![Build Status](https://ci2.dot.net/buildStatus/icon?job=Microsoft_msbuild/vs15.9/innerloop_Windows_NT_CoreCLR)](https://ci2.dot.net/job/Microsoft_msbuild/job/vs15.9/job/innerloop_Windows_NT_CoreCLR)|[![Build Status](https://ci2.dot.net/buildStatus/icon?job=Microsoft_msbuild/vs15.9/innerloop_Ubuntu16.04_CoreCLR)](https://ci2.dot.net/job/Microsoft_msbuild/job/vs15.9/job/innerloop_Ubuntu16.04_CoreCLR)|[![Build Status](https://ci2.dot.net/buildStatus/icon?job=Microsoft_msbuild/vs15.9/innerloop_OSX10.13_CoreCLR)](https://ci2.dot.net/job/Microsoft_msbuild/job/vs15.9/job/innerloop_OSX10.13_CoreCLR)|
-
 ## Building
 
 ### Building MSBuild with Visual Studio 2019 on Windows
@@ -42,7 +37,7 @@ To get started on **Visual Studio 2019**:
   - .NET Core cross-platform development
 2. Open a `Developer Command Prompt for VS 2019` prompt.
 3. Clone the source code: `git clone https://github.com/Microsoft/msbuild.git`
-  - You may have to [download git](https://git-scm.com/downloads) first.
+  - You may have to [download Git](https://git-scm.com/downloads) first.
 4. Run `.\build.cmd` from the root of the repo to build the code. This also restores packages needed to open the projects in Visual Studio.
 5. Open `MSBuild.sln` or `MSBuild.Dev.sln` in Visual Studio 2019.
 
@@ -69,7 +64,7 @@ Before you contribute, please read through the contributing and developer guides
 * [Contributing Guide](documentation/wiki/Contributing-Code.md)
 
 * **Developer Guide on:**
-   - [.Net Core](documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md)
+   - [.NET Core](documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md)
    - [Full Framework](documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md)
    - [Mono](documentation/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md)
 
diff --git a/documentation/ProjectReference-Protocol.md b/documentation/ProjectReference-Protocol.md
index a95842eb107..f464ca17374 100644
--- a/documentation/ProjectReference-Protocol.md
+++ b/documentation/ProjectReference-Protocol.md
@@ -54,9 +54,13 @@ These targets are all defined in `Microsoft.Common.targets` and are defined in M
 If implementing a project with an ‚Äúouter‚Äù (determine what properties to pass to the real build) and ‚Äúinner‚Äù (fully specified) build, only `GetTargetFrameworkProperties` is required in the ‚Äúouter‚Äù build. The other targets listed can be ‚Äúinner‚Äù build only.
 
 * `GetTargetFrameworks` tells referencing projects what options are available to the build.
-  * It returns an item with metadata `TargetFrameworks` indicating what TargetFrameworks are available in the project, as well as boolean metadata `HasSingleTargetFramework` and `IsRidAgnostic`.
+  * It returns an item with the following metadata:
+    * `TargetFrameworks` indicating what TargetFrameworks are available in the project
+    * `TargetFrameworkMonikers` and `TargetPlatformMonikers` indicating what framework / platform the `TargetFrameworks` map to.  This is to support implicitly setting the target platform version (for example inferring that `net5.0-windows` means the same as `net5.0-windows7.0`) as well as treating the `TargetFramework` values [as aliases](https://github.com/NuGet/Home/issues/5154)
+    * Boolean metadata for `HasSingleTargetFramework` and `IsRidAgnostic`.
+  * The `GetReferenceNearestTargetFrameworkTask` (provided by NuGet) is responsible for selecting the best matching `TargetFramework` of the referenced project
   * This target is _optional_. If not present, the reference will be built with no additional properties.
-  * **New** in MSBuild 15.5.
+  * **New** in MSBuild 15.5.  (`TargetFrameworkMonikers` and `TargetPlatformMonikers` metadata is new in MSBuild 16.8)
 * `GetTargetFrameworkProperties` determines what properties should be passed to the ‚Äúmain‚Äù target for a given `ReferringTargetFramework`.
   * **Deprecated** in MSBuild 15.5.
   * New for MSBuild 15/Visual Studio 2017. Supports the cross-targeting feature allowing a project to have multiple `TargetFrameworks`.
diff --git a/documentation/specs/assets/rar-lifetime.png b/documentation/specs/assets/rar-lifetime.png
new file mode 100644
index 00000000000..a02bd3d0d87
Binary files /dev/null and b/documentation/specs/assets/rar-lifetime.png differ
diff --git a/documentation/specs/rar-as-service.md b/documentation/specs/rar-as-service.md
new file mode 100644
index 00000000000..f04cfed6b41
--- /dev/null
+++ b/documentation/specs/rar-as-service.md
@@ -0,0 +1,216 @@
+# Resolve Assembly Reference as Service Design
+
+This document describes Resolve Assembly Reference as a Service
+
+# Background
+
+[MSBuild](https://docs.microsoft.com/visualstudio/msbuild/msbuild?view=vs-2019) is a universal build engine, used for building pretty much everything in the Microsoft world. It is available on command line (msbuild, [dotnet build](https://docs.microsoft.com/dotnet/core/tools/dotnet-build)), runs under the covers when building projects and solutions in Visual Studio, and is used as the local build engine in "higher-order" distributed build systems. Essentially all .NET applications use MSBuild as their primary build engine.
+
+RAR is the acronym behind ResolveAssemblyReference (an MSBuild task) and ResolveAssemblyReferences (an MSBuild target). RAR is used in all .NET builds. Quoting the official documentation, RAR "_Determines all assemblies that depend on the specified assemblies, including second and nth-order dependencies._"
+
+The RAR task has become very complex and slow over the years. It tends to rank high on the list of MSBuild's performance bottlenecks. There is an inherent cost to walking the assembly reference graph and computing the dependency closure, especially in terms of I/O operations. To address this, the task internally maintains caches, both in-memory and on disk. While it alleviates the problem somewhat, it is still a suboptimal solution because
+
+1. The task runs in build nodes which are generally created as separate processes, one per logical CPU, so the in-memory state is duplicated.
+2. Build nodes have limited lifetime and the in-memory state is lost when they die.
+3. No state exists when the task runs for the given project for the first time.
+
+    *NOTE:* This is tracked by issue [#5247](https://github.com/dotnet/msbuild/issues/5247).
+
+There was already an attempt to introduce RAR as a service to MSBuild ([#3914](https://github.com/dotnet/msbuild/pull/3914)). This PR was not completed mainly because of discontinued development of Bond, which is in that PR used as method of communication between nodes.
+
+# Design
+
+![](assets/rar-lifetime.png)
+
+_Figure 1 Rough diagram of lifetime of service_
+
+## Lifetime of service
+
+### Connect to RAR node
+
+Connecting to the RAR node will not require any discovery of processes on computer. The algorithm will follow these steps:
+
+1. Get expected node name, which will be based on the current setting of node. The name format is described in `Start new node`.
+2. Setup named pipe. The construction of named pipe may differ between platforms (usage of different API for construction of the pipe object).
+3. Try to connect to the node.
+
+If the connection is successful, we can use this connection for execution of RAR task. The node is guaranteed to have all required properties since they must be encoded in name of the RAR node.
+
+### Start new node
+
+This step will create new process which will act as RAR node. It will also pass necessary information to the node to know what its settings are (reusable, ...). Node will be another instance of the MSBuild.exe which will have set parameter **nodeMode** to some specific value (it should be `/nodeMode:3`). 
+
+We will use Mutex (as in [Roslyn](https://github.com/dotnet/roslyn/blob/838874b1b817db84ce146bef690cc95a39c213a5/src/Compilers/Server/VBCSCompiler/BuildServerController.cs#L143)) to ensure we don't create two RAR nodes at once. Its name must encode whether it is the user's only RAR node, including user name, administrator privileges, and some initial settings for the node. Such a name could be: `MSBuild.RAR.ostorc.7`, where **MSBuild.RAR** is its prefix, **ostorc** is the user who called MSBuild, and **7** represents encoded settings (flag enum).
+
+### Execute RAR task
+
+Execution should be the same as it is now.
+
+There is already some layer of separation between Task interface and actual execution method. We will leverage this, and put the decision logic if to run locally or not into the "wrapper" method and so we will not have to modify this and in server-side execution we will directly call the internal execution method.
+
+There is one big concern and that is how to handle multiple requests at once. As right now, RAR task is not prepared for multi-thread use.
+
+### Shutdown RAR node
+
+If the user does not want the node to be reused, we have the ensure that node will be killed after the build ends. This should be done after the main MSBuild node finishes building.
+
+The RAR node, also has to support accepting of already established commands for MSBuild nodes (for example Shutdown command). This will be done by creating two pipes inside node, one will be for communication about RAR commands and second one for the servicing communication.
+
+### Execute task in MSBuild node
+
+User opted out of using the RAR nodes so we will execute the RAR task in the MSBuild node (as it is right now).
+
+### Other
+
+The new RAR node will not count toward total maximum CPU count specified by _/maxCpuCount_ switch, since the RAR task is taxing on IO operations not so much on CPU time. If we took one node from each instance of MSBuild it would lead to drastic decrease in performance.
+
+The RAR task will be affected by the _/m_ switch. When we run in single node mode, it will implicitly say that we want to run the task inside current process. User would have to explicitly say that they want to use the RAR node.
+
+__NOTE:__ The behavior described above depend on fact that the feature is opt-out (is active by default). If not, the paragraph above is meaningless. This has to be yet decided/clarified.
+
+## Communication
+
+The communication between nodes should be done over [StreamJsonRpc](https://github.com/microsoft/vs-streamjsonrpc/). The API over which two node will transfer data has to reflect inputs and outputs of RAR task as described in [docs](https://docs.microsoft.com/visualstudio/msbuild/resolveassemblyreference-task?view=vs-2019).
+
+Note that, the following snippets are probably not final version of the API and are here to give rough idea, what must be transferred.
+
+### RAR Input
+
+This is direct representation of all RAR inputs.
+
+```csharp
+public sealed partial class ResolveAssemblyReferenceInput
+{
+
+    public ResolveAssemblyReferenceInput() { }
+
+    public string[] AllowedAssemblyExtensions { get { throw null; } set { } }
+
+    public string[] AllowedRelatedFileExtensions { get { throw null; } set { } }
+
+    public string AppConfigFile { get { throw null; } set { } }
+
+    public Microsoft.Build.Framework.ITaskItem[] Assemblies { get { throw null; } set { } }
+
+    public Microsoft.Build.Framework.ITaskItem[] AssemblyFiles { get { throw null; } set { } }
+
+    public bool AutoUnify { get { throw null; } set { } }
+
+    public string[] CandidateAssemblyFiles { get { throw null; } set { } }
+
+    public bool CopyLocalDependenciesWhenParentReferenceInGac { get { throw null; } set { } }
+
+    public bool DoNotCopyLocalIfInGac { get { throw null; } set { } }
+
+    public bool FindDependencies { get { throw null; } set { } }
+
+    public bool FindDependenciesOfExternallyResolvedReferences { get { throw null; } set { } }
+
+    public bool FindRelatedFiles { get { throw null; } set { } }
+
+    public bool FindSatellites { get { throw null; } set { } }
+
+    public bool FindSerializationAssemblies { get { throw null; } set { } }
+
+    public Microsoft.Build.Framework.ITaskItem[] FullFrameworkAssemblyTables { get { throw null; } set { } }
+
+    public string[] FullFrameworkFolders { get { throw null; } set { } }
+
+    public string[] FullTargetFrameworkSubsetNames { get { throw null; } set { } }
+
+    public bool IgnoreDefaultInstalledAssemblySubsetTables { get { throw null; } set { } }
+
+    public bool IgnoreDefaultInstalledAssemblyTables { get { throw null; } set { } }
+
+    public bool IgnoreTargetFrameworkAttributeVersionMismatch { get { throw null; } set { } }
+
+    public bool IgnoreVersionForFrameworkReferences { get { throw null; } set { } }
+
+    public Microsoft.Build.Framework.ITaskItem[] InstalledAssemblySubsetTables { get { throw null; } set { } }
+
+    public Microsoft.Build.Framework.ITaskItem[] InstalledAssemblyTables { get { throw null; } set { } }
+
+    public string[] LatestTargetFrameworkDirectories { get { throw null; } set { } }
+
+    public string ProfileName { get { throw null; } set { } }
+
+    public Microsoft.Build.Framework.ITaskItem[] ResolvedSDKReferences { get { throw null; } set { } }
+
+    public string[] SearchPaths { get { throw null; } set { } }
+
+    public bool Silent { get { throw null; } set { } }
+
+    public string StateFile { get { throw null; } set { } }
+
+    public bool SupportsBindingRedirectGeneration { get { throw null; } set { } }
+
+    public string TargetedRuntimeVersion { get { throw null; } set { } }
+
+    public string[] TargetFrameworkDirectories { get { throw null; } set { } }
+
+    public string TargetFrameworkMoniker { get { throw null; } set { } }
+
+    public string TargetFrameworkMonikerDisplayName { get { throw null; } set { } }
+
+    public string[] TargetFrameworkSubsets { get { throw null; } set { } }
+
+    public string TargetFrameworkVersion { get { throw null; } set { } }
+
+    public string TargetProcessorArchitecture { get { throw null; } set { } }
+
+    public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get { throw null; } set { } }
+
+    public string WarnOrErrorOnTargetArchitectureMismatch { get { throw null; } set { } }
+}
+```
+
+### RAR Output
+
+Output of RAR node has to also reflect RAR task.
+```csharp
+public sealed partial class ResolveAssemblyReferenceOutput
+{
+    public ResolveAssemblyReferenceOutput() { }
+
+    public Microsoft.Build.Framework.ITaskItem[] CopyLocalFiles { get { throw null; } }
+
+    public string DependsOnNETStandard { get { throw null; } }
+
+    public string DependsOnSystemRuntime { get { throw null; } }
+
+    public Microsoft.Build.Framework.ITaskItem[] FilesWritten { get { throw null; } }
+
+    public Microsoft.Build.Framework.ITaskItem[] RelatedFiles { get { throw null; } }
+
+    public Microsoft.Build.Framework.ITaskItem[] ResolvedDependencyFiles { get { throw null; } }
+
+    public Microsoft.Build.Framework.ITaskItem[] ResolvedFiles { get { throw null; } }
+
+    public Microsoft.Build.Framework.ITaskItem[] SatelliteFiles { get { throw null; } }
+
+    public Microsoft.Build.Framework.ITaskItem[] ScatterFiles { get { throw null; } }
+
+    public Microsoft.Build.Framework.ITaskItem[] SerializationAssemblyFiles { get { throw null; } }
+
+    public Microsoft.Build.Framework.ITaskItem[] SuggestedRedirects { get { throw null; }
+}
+```
+### Logging response
+
+Node also has to return logged data, preferably in stream which will be transferred during the RAR task execution to the client node. This should by done by using IProgress\<T> support in StreamJsonRPC. There is also support for async enumerable, but they must be pulled and are not pushed to the client (comparison can be found [here](https://github.com/microsoft/vs-streamjsonrpc/blob/master/doc/asyncenumerable.md#comparison-with-iprogresst)).
+
+### Concurrency
+
+One of the biggest challenges with RAR as service, is to make execution and caching of RAR task thread-safe, since in most cases there will be multiple clients request data from it at once.
+
+In the first phase of implementation the concurrency will be solved by serializing requests, but this will be replaced by optimal variant with no serializing.
+
+# Non-Goals
+
+- File watchers: using them would decrease required IO operations when checking disc changes
+- Aggressive precomputation of results
+- Improved caching of requests
+- Providing verbosity to RAR task:
+    As mentioned in original [PR](https://github.com/dotnet/msbuild/pull/3914), there should be some way to determine what thing we should log (by severity), and pass back to the original node.
+
+    Providing the verbosity level to the task should not probably be part of this project, but the RAR node should be able to accept the required verbosity on its input. This verbosity level should be introduced into the RAR task by [#2700](https://github.com/dotnet/msbuild/issues/2700).
diff --git a/documentation/wiki/MSBuild-Resources.md b/documentation/wiki/MSBuild-Resources.md
index dbdee2e0e6c..2e167a90ec4 100644
--- a/documentation/wiki/MSBuild-Resources.md
+++ b/documentation/wiki/MSBuild-Resources.md
@@ -19,7 +19,7 @@
    * Provides a large collection of MSBuild Tasks, MSBuild Loggers and MSBuild TaskFactories.
  * [MSBuilder](https://github.com/MobileEssentials/MSBuilder)
    * Reusable blocks of MSBuild helpers; MSBuilder's goal is to provide fine-grained nuget packages that can be installed when only a certain MSBuild extension (task, property, target) is needed.
- * [MSBuildExplorer](http://msbuildexplorer.com) ([GitHub](https://github.com/mikefourie/MSBuildExplorer))
+ * [MSBuildExplorer](https://github.com/mikefourie/MSBuildExplorer)
    * Use MSBuild Explorer to help you find your way around the make-up of your build file(s).
  * [MSBuild Sidekick](http://attrice.info/msbuild)
    * MSBuild Sidekick allows you to view, edit, build and debug Visual Studio projects and solution files as well as custom MSBuild projects.
diff --git a/documentation/wiki/Providing-Binary-Logs.md b/documentation/wiki/Providing-Binary-Logs.md
index e2aecf85c6b..b9423d5b271 100644
--- a/documentation/wiki/Providing-Binary-Logs.md
+++ b/documentation/wiki/Providing-Binary-Logs.md
@@ -9,3 +9,6 @@ However, you should be aware what type of information is captured in the binary
 You can create a binary log by passing the `-bl` parameter to MSBuild.  You can explore the contents of the generated .binlog file using [MSBuild Structured Log Viewer](http://msbuildlog.com/).
 
 [More details about binary logs](Binary-Log.md)
+
+## Capturing Binary Logs Through Visual Studio
+See [this guide](https://github.com/dotnet/project-system-tools) in the Project System Tools repo for capturing binlogs through Visual Studio.
diff --git a/eng/BootStrapMSBuild.targets b/eng/BootStrapMSBuild.targets
index a24609db358..5e1479fa0c9 100644
--- a/eng/BootStrapMSBuild.targets
+++ b/eng/BootStrapMSBuild.targets
@@ -52,8 +52,7 @@
          need to be in a specific location that does not mesh with NuGet. To resolve this, we include the default
          PackageReference assets but will remove them from the Reference ItemGroup before RAR runs and avoid the warnings -->
     <ItemGroup>
-        <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('Microsoft.Build.Utilities.v4.0'))' == 'True'" />
-        <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('Microsoft.Build.Framework'))' == 'True'" />
+        <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('Microsoft.Build'))' == 'True'" />
         <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('NuGet.'))' == 'True'" />
         <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('Newtonsoft.Json'))' == 'True'" />
         <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('NuGetSdkResolver'))' == 'True'" />
diff --git a/eng/Packages.props b/eng/Packages.props
index d3ac170588d..727964ed0b9 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -1,13 +1,14 @@
 <Project>
 
   <PropertyGroup>
-      <NuGetPackageVersion>5.4.0-rtm.6292</NuGetPackageVersion>
+      <NuGetPackageVersion>5.7.0-rtm.6710</NuGetPackageVersion>
       <NuGetBuildTasksVersion Condition="'$(NuGetBuildTasksVersion)' == ''">$(NuGetPackageVersion)</NuGetBuildTasksVersion>
       <NuGetCommandsVersion Condition="'$(NuGetCommandsVersion)' == ''">$(NuGetPackageVersion)</NuGetCommandsVersion>
       <NuGetProtocolVersion Condition="'$(NuGetProtocolVersion)' == ''">$(NuGetPackageVersion)</NuGetProtocolVersion>
   </PropertyGroup>
 
   <ItemGroup>
+    <PackageReference Update="jnm2.ReferenceAssemblies.net35" Version="1.0.1" />
     <PackageReference Update="LargeAddressAware" Version="1.0.3" />
     <PackageReference Update="Microsoft.Build.NuGetSdkResolver" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="Microsoft.CodeAnalysis.Build.Tasks" Version="3.0.0-beta1-61516-01" />
@@ -16,7 +17,7 @@
     <PackageReference Update="Microsoft.Net.Compilers.Toolset" Version="$(MicrosoftNetCompilersToolsetVersion)" />
     <PackageReference Update="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.15" />
     <PackageReference Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="1.16.30" />
-    <PackageReference Update="Microsoft.Win32.Registry" Version="4.3.0" />
+    <PackageReference Update="Microsoft.Win32.Registry" Version="4.6.0" />
     <PackageReference Update="NuGet.Build.Tasks" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="NuGet.Frameworks" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="PdbGit" Version="3.0.41" />
@@ -35,9 +36,12 @@
     <PackageReference Update="System.Reflection.TypeExtensions" Version="4.1.0" />
     <PackageReference Update="System.Resources.Extensions" Version="4.6.0" />
     <PackageReference Update="System.Resources.Writer" Version="4.0.0" />
+    <PackageReference Update="System.Runtime.InteropServices" Version="4.3.0" />
     <PackageReference Update="System.Runtime.InteropServices.RuntimeInformation" Version="4.3.0" />
     <PackageReference Update="System.Runtime.Loader" Version="4.0.0" />
     <PackageReference Update="System.Runtime.Serialization.Primitives" Version="4.1.1" />
+    <PackageReference Update="System.Security.Cryptography.Pkcs" Version="4.7.0" />
+    <PackageReference Update="System.Security.Cryptography.Xml" Version="4.7.0" />
     <PackageReference Update="System.Security.Permissions" Version="4.7.0" />
     <PackageReference Update="System.Security.Principal.Windows" Version="4.7.0" />
     <PackageReference Update="System.Text.Encoding.CodePages" Version="4.0.1" />
@@ -48,6 +52,8 @@
     <PackageReference Update="xunit.assert" Version="$(XUnitVersion)" />
     <PackageReference Update="xunit.console" Version="$(XUnitVersion)" />
     <PackageReference Update="xunit.core" Version="$(XUnitVersion)" />
+    <PackageReference Update="StreamJsonRpc" Version="2.4.48" />
+    <PackageReference Update="Newtonsoft.Json" Version="12.*" PrivateAssets="all" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true'">
diff --git a/eng/Signing.props b/eng/Signing.props
index 83946d7c6e5..13912cb79a5 100644
--- a/eng/Signing.props
+++ b/eng/Signing.props
@@ -1,5 +1,8 @@
 <Project>
     <ItemGroup>
+		<FileSignInfo Include="Nerdbank.Streams.dll" CertificateName="3PartySHA2" /> 
+		<FileSignInfo Include="MessagePack.dll" CertificateName="3PartySHA2" /> 
+		<FileSignInfo Include="MessagePack.Annotations.dll" CertificateName="3PartySHA2" /> 
 		<ItemsToSign Include="$(VisualStudioSetupOutputPath)DevDivPackages\*.nupkg" />
 	</ItemGroup>
 </Project>
\ No newline at end of file
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 5c670906e71..d8f4caae728 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,9 +1,9 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="1.0.0-beta.20302.3">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="1.0.0-beta.20427.6">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>9b71be0663493cd0e111b55536a2e1eeb272f54c</Sha>
+      <Sha>84cd401ce792220bdb17c5587f9b39265170c03f</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index e20df56fead..dc29455da17 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -15,7 +15,7 @@
     <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
   </PropertyGroup>
   <PropertyGroup>
-    <VersionPrefix>16.7.0</VersionPrefix>
+    <VersionPrefix>16.8.0</VersionPrefix>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
diff --git a/eng/common/SetupNugetSources.ps1 b/eng/common/SetupNugetSources.ps1
index a8b5280d9dd..6d88a1904ba 100644
--- a/eng/common/SetupNugetSources.ps1
+++ b/eng/common/SetupNugetSources.ps1
@@ -11,6 +11,8 @@
 # See example YAML call for this script below. Note the use of the variable `$(dn-bot-dnceng-artifact-feeds-rw)`
 # from the AzureDevOps-Artifact-Feeds-Pats variable group.
 #
+# Any disabledPackageSources entries which start with "darc-int" will be re-enabled as part of this script executing
+#
 #  - task: PowerShell@2
 #    displayName: Setup Private Feeds Credentials
 #    condition: eq(variables['Agent.OS'], 'Windows_NT')
@@ -94,6 +96,14 @@ function InsertMaestroPrivateFeedCredentials($Sources, $Creds, $Username, $Passw
     }
 }
 
+function EnablePrivatePackageSources($DisabledPackageSources) {
+    $maestroPrivateSources = $DisabledPackageSources.SelectNodes("add[contains(@key,'darc-int')]")
+    ForEach ($DisabledPackageSource in $maestroPrivateSources) {
+        Write-Host "`tEnsuring private source '$($DisabledPackageSource.key)' is enabled"
+        $DisabledPackageSource.SetAttribute("value", "false")
+    }
+}
+
 if (!(Test-Path $ConfigFile -PathType Leaf)) {
   Write-PipelineTelemetryError -Category 'Build' -Message "Eng/common/SetupNugetSources.ps1 returned a non-zero exit code. Couldn't find the NuGet config file: $ConfigFile"
   ExitWithExitCode 1
@@ -123,6 +133,13 @@ if ($creds -eq $null) {
     $doc.DocumentElement.AppendChild($creds) | Out-Null
 }
 
+# Check for disabledPackageSources; we'll enable any darc-int ones we find there
+$disabledSources = $doc.DocumentElement.SelectSingleNode("disabledPackageSources")
+if ($disabledSources -ne $null) {
+    Write-Host "Checking for any darc-int disabled package sources in the disabledPackageSources node"
+    EnablePrivatePackageSources -DisabledPackageSources $disabledSources
+}
+
 $userName = "dn-bot"
 
 # Insert credential nodes for Maestro's private feeds
diff --git a/eng/common/SetupNugetSources.sh b/eng/common/SetupNugetSources.sh
index 4ebb1e5a440..00e8f45b91f 100644
--- a/eng/common/SetupNugetSources.sh
+++ b/eng/common/SetupNugetSources.sh
@@ -13,6 +13,8 @@
 # See example YAML call for this script below. Note the use of the variable `$(dn-bot-dnceng-artifact-feeds-rw)`
 # from the AzureDevOps-Artifact-Feeds-Pats variable group.
 #
+# Any disabledPackageSources entries which start with "darc-int" will be re-enabled as part of this script executing.
+#
 #  - task: Bash@3
 #    displayName: Setup Private Feeds Credentials
 #    inputs:
@@ -63,7 +65,7 @@ if [ "$?" != "0" ]; then
     ConfigNodeHeader="<configuration>"
     PackageSourcesTemplate="${TB}<packageSources>${NL}${TB}</packageSources>"
 
-    sed -i.bak "s|$ConfigNodeHeader|$ConfigNodeHeader${NL}$PackageSourcesTemplate|" NuGet.config
+    sed -i.bak "s|$ConfigNodeHeader|$ConfigNodeHeader${NL}$PackageSourcesTemplate|" $ConfigFile
 fi
 
 # Ensure there is a <packageSourceCredentials>...</packageSourceCredentials> section. 
@@ -74,7 +76,7 @@ if [ "$?" != "0" ]; then
     PackageSourcesNodeFooter="</packageSources>"
     PackageSourceCredentialsTemplate="${TB}<packageSourceCredentials>${NL}${TB}</packageSourceCredentials>"
 
-    sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourcesNodeFooter${NL}$PackageSourceCredentialsTemplate|" NuGet.config
+    sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourcesNodeFooter${NL}$PackageSourceCredentialsTemplate|" $ConfigFile
 fi
 
 PackageSources=()
@@ -146,4 +148,21 @@ for FeedName in ${PackageSources[@]} ; do
 
         sed -i.bak "s|$PackageSourceCredentialsNodeFooter|$NewCredential${NL}$PackageSourceCredentialsNodeFooter|" $ConfigFile
     fi
-done
\ No newline at end of file
+done
+
+# Re-enable any entries in disabledPackageSources where the feed name contains darc-int
+grep -i "<disabledPackageSources>" $ConfigFile
+if [ "$?" == "0" ]; then
+    DisabledDarcIntSources=()
+    echo "Re-enabling any disabled \"darc-int\" package sources in $ConfigFile"
+    DisabledDarcIntSources+=$(grep -oh '"darc-int-[^"]*" value="true"' $ConfigFile  | tr -d '"')
+    for DisabledSourceName in ${DisabledDarcIntSources[@]} ; do
+        if [[ $DisabledSourceName == darc-int* ]]
+            then
+                OldDisableValue="add key=\"$DisabledSourceName\" value=\"true\""
+                NewDisableValue="add key=\"$DisabledSourceName\" value=\"false\""
+                sed -i.bak "s|$OldDisableValue|$NewDisableValue|" $ConfigFile
+                echo "Neutralized disablePackageSources entry for '$DisabledSourceName'"
+        fi
+    done
+fi
\ No newline at end of file
diff --git a/eng/common/darc-init.sh b/eng/common/darc-init.sh
index 242429bca65..06b65342528 100755
--- a/eng/common/darc-init.sh
+++ b/eng/common/darc-init.sh
@@ -2,8 +2,8 @@
 
 source="${BASH_SOURCE[0]}"
 darcVersion=''
-versionEndpoint="https://maestro-prod.westus2.cloudapp.azure.com/api/assets/darc-version?api-version=2019-01-16"
-verbosity=m
+versionEndpoint='https://maestro-prod.westus2.cloudapp.azure.com/api/assets/darc-version?api-version=2019-01-16'
+verbosity='minimal'
 
 while [[ $# > 0 ]]; do
   opt="$(echo "$1" | awk '{print tolower($0)}')"
@@ -20,6 +20,10 @@ while [[ $# > 0 ]]; do
       verbosity=$2
       shift
       ;;
+    --toolpath)
+      toolpath=$2
+      shift
+      ;;
     *)
       echo "Invalid argument: $1"
       usage
@@ -52,17 +56,27 @@ function InstallDarcCli {
   InitializeDotNetCli
   local dotnet_root=$_InitializeDotNetCli
 
-  local uninstall_command=`$dotnet_root/dotnet tool uninstall $darc_cli_package_name -g`
-  local tool_list=$($dotnet_root/dotnet tool list -g)
-  if [[ $tool_list = *$darc_cli_package_name* ]]; then
-    echo $($dotnet_root/dotnet tool uninstall $darc_cli_package_name -g)
+  if [ -z "$toolpath" ]; then
+    local tool_list=$($dotnet_root/dotnet tool list -g)
+    if [[ $tool_list = *$darc_cli_package_name* ]]; then
+      echo $($dotnet_root/dotnet tool uninstall $darc_cli_package_name -g)
+    fi
+  else
+    local tool_list=$($dotnet_root/dotnet tool list --tool-path "$toolpath")
+    if [[ $tool_list = *$darc_cli_package_name* ]]; then
+      echo $($dotnet_root/dotnet tool uninstall $darc_cli_package_name --tool-path "$toolpath")
+    fi
   fi
 
-  local arcadeServicesSource="https://dotnetfeed.blob.core.windows.net/dotnet-core/index.json"
+  local arcadeServicesSource="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json"
 
   echo "Installing Darc CLI version $darcVersion..."
   echo "You may need to restart your command shell if this is the first dotnet tool you have installed."
-  echo $($dotnet_root/dotnet tool install $darc_cli_package_name --version $darcVersion --add-source "$arcadeServicesSource" -v $verbosity -g)
+  if [ -z "$toolpath" ]; then
+    echo $($dotnet_root/dotnet tool install $darc_cli_package_name --version $darcVersion --add-source "$arcadeServicesSource" -v $verbosity -g)
+  else
+    echo $($dotnet_root/dotnet tool install $darc_cli_package_name --version $darcVersion --add-source "$arcadeServicesSource" -v $verbosity --tool-path "$toolpath")
+  fi
 }
 
 InstallDarcCli
diff --git a/eng/common/sdl/packages.config b/eng/common/sdl/packages.config
index 256ffbfb93a..968b39bef5f 100644
--- a/eng/common/sdl/packages.config
+++ b/eng/common/sdl/packages.config
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="utf-8"?>
 <packages>
-  <package id="Microsoft.Guardian.Cli" version="0.7.2"/>
+  <package id="Microsoft.Guardian.Cli.win10-x64" version="0.20.1"/>
 </packages>
diff --git a/eng/common/templates/job/execute-sdl.yml b/eng/common/templates/job/execute-sdl.yml
index 52e2ff021d7..bf09d2511c6 100644
--- a/eng/common/templates/job/execute-sdl.yml
+++ b/eng/common/templates/job/execute-sdl.yml
@@ -65,7 +65,7 @@ jobs:
       continueOnError: ${{ parameters.sdlContinueOnError }}
   - ${{ if eq(parameters.overrideParameters, '') }}:
     - powershell: eng/common/sdl/execute-all-sdl-tools.ps1
-        -GuardianPackageName Microsoft.Guardian.Cli.0.7.2
+        -GuardianPackageName Microsoft.Guardian.Cli.win10-x64.0.20.1
         -NugetPackageDirectory $(Build.SourcesDirectory)\.packages
         -AzureDevOpsAccessToken $(dn-bot-dotnet-build-rw-code-rw)
         ${{ parameters.additionalParameters }}
diff --git a/eng/common/templates/post-build/post-build.yml b/eng/common/templates/post-build/post-build.yml
index e1cff6e7029..2d51c1cdbf6 100644
--- a/eng/common/templates/post-build/post-build.yml
+++ b/eng/common/templates/post-build/post-build.yml
@@ -355,6 +355,18 @@ stages:
     shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
     symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
 
+- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+  parameters:
+    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+    stageName: 'VS16_8_Publishing'
+    channelName: 'VS 16.8'
+    channelId: 1154
+    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-transport/nuget/v3/index.json'
+    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
+    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
+
 - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
   parameters:
     artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
diff --git a/eng/common/tools.ps1 b/eng/common/tools.ps1
index bc228dfdf9f..f50507a06c1 100644
--- a/eng/common/tools.ps1
+++ b/eng/common/tools.ps1
@@ -329,7 +329,7 @@ function InitializeXCopyMSBuild([string]$packageVersion, [bool]$install) {
     Create-Directory $packageDir
     Write-Host "Downloading $packageName $packageVersion"
     $ProgressPreference = 'SilentlyContinue' # Don't display the console progress UI - it's a huge perf hit
-    Invoke-WebRequest "https://dotnet.myget.org/F/roslyn-tools/api/v2/package/$packageName/$packageVersion/" -OutFile $packagePath
+    Invoke-WebRequest "https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/flat2/$packageName/$packageVersion/$packageName.$packageVersion.nupkg" -OutFile $packagePath
     Unzip $packagePath $packageDir
   }
 
diff --git a/global.json b/global.json
index fc53c0de68f..7f00e869a27 100644
--- a/global.json
+++ b/global.json
@@ -12,6 +12,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "1.0.0-beta.20302.3"
+    "Microsoft.DotNet.Arcade.Sdk": "1.0.0-beta.20427.6"
   }
 }
diff --git a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
index 46cb6ff3e51..7a67734775b 100644
--- a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
@@ -16,11 +16,13 @@ protected BuildErrorEventArgs() { }
         public BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) { }
         public BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) { }
         public BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
+        public BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, System.DateTime eventTimestamp, params object[] messageArgs) { }
         public string Code { get { throw null; } }
         public int ColumnNumber { get { throw null; } }
         public int EndColumnNumber { get { throw null; } }
         public int EndLineNumber { get { throw null; } }
         public string File { get { throw null; } }
+        public string HelpLink { get { throw null; } }
         public int LineNumber { get { throw null; } }
         public string ProjectFile { get { throw null; } set { } }
         public string Subcategory { get { throw null; } }
@@ -118,11 +120,13 @@ protected BuildWarningEventArgs() { }
         public BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) { }
         public BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) { }
         public BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
+        public BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, System.DateTime eventTimestamp, params object[] messageArgs) { }
         public string Code { get { throw null; } }
         public int ColumnNumber { get { throw null; } }
         public int EndColumnNumber { get { throw null; } }
         public int EndLineNumber { get { throw null; } }
         public string File { get { throw null; } }
+        public string HelpLink { get { throw null; } }
         public int LineNumber { get { throw null; } }
         public string ProjectFile { get { throw null; } set { } }
         public string Subcategory { get { throw null; } }
@@ -487,6 +491,7 @@ public abstract partial class SdkResolverContext
     {
         protected SdkResolverContext() { }
         public virtual bool Interactive { get { throw null; } protected set { } }
+        public virtual bool IsRunningInVisualStudio { get { throw null; } protected set { } }
         public virtual Microsoft.Build.Framework.SdkLogger Logger { get { throw null; } protected set { } }
         public virtual System.Version MSBuildVersion { get { throw null; } protected set { } }
         public virtual string ProjectFilePath { get { throw null; } protected set { } }
@@ -509,6 +514,7 @@ public abstract partial class SdkResultFactory
         protected SdkResultFactory() { }
         public abstract Microsoft.Build.Framework.SdkResult IndicateFailure(System.Collections.Generic.IEnumerable<string> errors, System.Collections.Generic.IEnumerable<string> warnings=null);
         public virtual Microsoft.Build.Framework.SdkResult IndicateSuccess(System.Collections.Generic.IEnumerable<string> paths, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd=null, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd=null, System.Collections.Generic.IEnumerable<string> warnings=null) { throw null; }
+        public virtual Microsoft.Build.Framework.SdkResult IndicateSuccess(string path, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd, System.Collections.Generic.IEnumerable<string> warnings=null) { throw null; }
         public abstract Microsoft.Build.Framework.SdkResult IndicateSuccess(string path, string version, System.Collections.Generic.IEnumerable<string> warnings=null);
     }
     public partial class SdkResultItem
diff --git a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
index 2cc97a9b041..9e3004af4bb 100644
--- a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
@@ -16,11 +16,13 @@ protected BuildErrorEventArgs() { }
         public BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) { }
         public BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) { }
         public BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
+        public BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, System.DateTime eventTimestamp, params object[] messageArgs) { }
         public string Code { get { throw null; } }
         public int ColumnNumber { get { throw null; } }
         public int EndColumnNumber { get { throw null; } }
         public int EndLineNumber { get { throw null; } }
         public string File { get { throw null; } }
+        public string HelpLink { get { throw null; } }
         public int LineNumber { get { throw null; } }
         public string ProjectFile { get { throw null; } set { } }
         public string Subcategory { get { throw null; } }
@@ -118,11 +120,13 @@ protected BuildWarningEventArgs() { }
         public BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) { }
         public BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) { }
         public BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
+        public BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, System.DateTime eventTimestamp, params object[] messageArgs) { }
         public string Code { get { throw null; } }
         public int ColumnNumber { get { throw null; } }
         public int EndColumnNumber { get { throw null; } }
         public int EndLineNumber { get { throw null; } }
         public string File { get { throw null; } }
+        public string HelpLink { get { throw null; } }
         public int LineNumber { get { throw null; } }
         public string ProjectFile { get { throw null; } set { } }
         public string Subcategory { get { throw null; } }
@@ -486,6 +490,7 @@ public abstract partial class SdkResolverContext
     {
         protected SdkResolverContext() { }
         public virtual bool Interactive { get { throw null; } protected set { } }
+        public virtual bool IsRunningInVisualStudio { get { throw null; } protected set { } }
         public virtual Microsoft.Build.Framework.SdkLogger Logger { get { throw null; } protected set { } }
         public virtual System.Version MSBuildVersion { get { throw null; } protected set { } }
         public virtual string ProjectFilePath { get { throw null; } protected set { } }
@@ -508,6 +513,7 @@ public abstract partial class SdkResultFactory
         protected SdkResultFactory() { }
         public abstract Microsoft.Build.Framework.SdkResult IndicateFailure(System.Collections.Generic.IEnumerable<string> errors, System.Collections.Generic.IEnumerable<string> warnings=null);
         public virtual Microsoft.Build.Framework.SdkResult IndicateSuccess(System.Collections.Generic.IEnumerable<string> paths, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd=null, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd=null, System.Collections.Generic.IEnumerable<string> warnings=null) { throw null; }
+        public virtual Microsoft.Build.Framework.SdkResult IndicateSuccess(string path, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd, System.Collections.Generic.IEnumerable<string> warnings=null) { throw null; }
         public abstract Microsoft.Build.Framework.SdkResult IndicateSuccess(string path, string version, System.Collections.Generic.IEnumerable<string> warnings=null);
     }
     public partial class SdkResultItem
diff --git a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
index 504910a4ea2..a4b601bd068 100644
--- a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
@@ -277,6 +277,7 @@ public Error() { }
         public string Code { get { throw null; } set { } }
         public string File { get { throw null; } set { } }
         public string HelpKeyword { get { throw null; } set { } }
+        public string HelpLink { get { throw null; } set { } }
         public string Text { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
@@ -941,6 +942,7 @@ public ResolveAssemblyReference() { }
         public string TargetFrameworkVersion { get { throw null; } set { } }
         public string TargetProcessorArchitecture { get { throw null; } set { } }
         public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get { throw null; } set { } }
+        public bool UseResolveAssemblyReferenceService { get { throw null; } set { } }
         public string WarnOrErrorOnTargetArchitectureMismatch { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
@@ -1231,6 +1233,7 @@ public Warning() { }
         public string Code { get { throw null; } set { } }
         public string File { get { throw null; } set { } }
         public string HelpKeyword { get { throw null; } set { } }
+        public string HelpLink { get { throw null; } set { } }
         public string Text { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
diff --git a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
index a1d7750c4df..6c496dd317e 100644
--- a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
@@ -207,6 +207,7 @@ public Error() { }
         public string Code { get { throw null; } set { } }
         public string File { get { throw null; } set { } }
         public string HelpKeyword { get { throw null; } set { } }
+        public string HelpLink { get { throw null; } set { } }
         public string Text { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
@@ -312,6 +313,34 @@ public FormatVersion() { }
         public string Version { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
+    public sealed partial class GenerateApplicationManifest : Microsoft.Build.Tasks.GenerateManifestBase
+    {
+        public GenerateApplicationManifest() { }
+        public string ClrVersion { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem ConfigFile { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Dependencies { get { throw null; } set { } }
+        public string ErrorReportUrl { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] FileAssociations { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
+        public bool HostInBrowser { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem IconFile { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] IsolatedComReferences { get { throw null; } set { } }
+        public string ManifestType { get { throw null; } set { } }
+        public string OSVersion { get { throw null; } set { } }
+        public string Product { get { throw null; } set { } }
+        public string Publisher { get { throw null; } set { } }
+        public bool RequiresMinimumFramework35SP1 { get { throw null; } set { } }
+        public string SuiteName { get { throw null; } set { } }
+        public string SupportUrl { get { throw null; } set { } }
+        public string TargetFrameworkProfile { get { throw null; } set { } }
+        public string TargetFrameworkSubset { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem TrustInfoFile { get { throw null; } set { } }
+        public bool UseApplicationTrust { get { throw null; } set { } }
+        protected override System.Type GetObjectType() { throw null; }
+        protected override bool OnManifestLoaded(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
+        protected override bool OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
+        protected internal override bool ValidateInputs() { throw null; }
+    }
     public partial class GenerateBindingRedirects : Microsoft.Build.Tasks.TaskExtension
     {
         public GenerateBindingRedirects() { }
@@ -322,6 +351,57 @@ public GenerateBindingRedirects() { }
         public string TargetName { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
+    public sealed partial class GenerateDeploymentManifest : Microsoft.Build.Tasks.GenerateManifestBase
+    {
+        public GenerateDeploymentManifest() { }
+        public bool CreateDesktopShortcut { get { throw null; } set { } }
+        public string DeploymentUrl { get { throw null; } set { } }
+        public bool DisallowUrlActivation { get { throw null; } set { } }
+        public string ErrorReportUrl { get { throw null; } set { } }
+        public bool Install { get { throw null; } set { } }
+        public bool MapFileExtensions { get { throw null; } set { } }
+        public string MinimumRequiredVersion { get { throw null; } set { } }
+        public string Product { get { throw null; } set { } }
+        public string Publisher { get { throw null; } set { } }
+        public string SuiteName { get { throw null; } set { } }
+        public string SupportUrl { get { throw null; } set { } }
+        public bool TrustUrlParameters { get { throw null; } set { } }
+        public bool UpdateEnabled { get { throw null; } set { } }
+        public int UpdateInterval { get { throw null; } set { } }
+        public string UpdateMode { get { throw null; } set { } }
+        public string UpdateUnit { get { throw null; } set { } }
+        protected override System.Type GetObjectType() { throw null; }
+        protected override bool OnManifestLoaded(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
+        protected override bool OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
+        protected internal override bool ValidateInputs() { throw null; }
+    }
+    public abstract partial class GenerateManifestBase : Microsoft.Build.Utilities.Task
+    {
+        protected GenerateManifestBase() { }
+        public string AssemblyName { get { throw null; } set { } }
+        public string AssemblyVersion { get { throw null; } set { } }
+        public string Description { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem InputManifest { get { throw null; } set { } }
+        public int MaxTargetPath { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem OutputManifest { get { throw null; } set { } }
+        public string Platform { get { throw null; } set { } }
+        public string TargetCulture { get { throw null; } set { } }
+        public string TargetFrameworkMoniker { get { throw null; } set { } }
+        public string TargetFrameworkVersion { get { throw null; } set { } }
+        protected internal Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference AddAssemblyFromItem(Microsoft.Build.Framework.ITaskItem item) { throw null; }
+        protected internal Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference AddAssemblyNameFromItem(Microsoft.Build.Framework.ITaskItem item, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType referenceType) { throw null; }
+        protected internal Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference AddEntryPointFromItem(Microsoft.Build.Framework.ITaskItem item, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType referenceType) { throw null; }
+        protected internal Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference AddFileFromItem(Microsoft.Build.Framework.ITaskItem item) { throw null; }
+        public override bool Execute() { throw null; }
+        protected internal Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference FindFileFromItem(Microsoft.Build.Framework.ITaskItem item) { throw null; }
+        protected abstract System.Type GetObjectType();
+        protected abstract bool OnManifestLoaded(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest);
+        protected abstract bool OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest);
+        protected internal virtual bool ValidateInputs() { throw null; }
+        protected internal virtual bool ValidateOutput() { throw null; }
+    }
     [Microsoft.Build.Framework.RequiredRuntimeAttribute("v2.0")]
     public sealed partial class GenerateResource : Microsoft.Build.Tasks.TaskExtension
     {
@@ -599,6 +679,7 @@ public ResolveAssemblyReference() { }
         public string TargetFrameworkVersion { get { throw null; } set { } }
         public string TargetProcessorArchitecture { get { throw null; } set { } }
         public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get { throw null; } set { } }
+        public bool UseResolveAssemblyReferenceService { get { throw null; } set { } }
         public string WarnOrErrorOnTargetArchitectureMismatch { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
@@ -655,6 +736,30 @@ public ResolveKeySource() { }
         public bool SuppressAutoClosePasswordPrompt { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
+    public sealed partial class ResolveManifestFiles : Microsoft.Build.Tasks.TaskExtension
+    {
+        public ResolveManifestFiles() { }
+        public Microsoft.Build.Framework.ITaskItem DeploymentManifestEntryPoint { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] ExtraFiles { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] ManagedAssemblies { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] NativeAssemblies { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem[] OutputAssemblies { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem OutputDeploymentManifestEntryPoint { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem OutputEntryPoint { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem[] OutputFiles { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] PublishFiles { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] SatelliteAssemblies { get { throw null; } set { } }
+        public bool SigningManifests { get { throw null; } set { } }
+        public string TargetCulture { get { throw null; } set { } }
+        public string TargetFrameworkVersion { get { throw null; } set { } }
+        public override bool Execute() { throw null; }
+    }
     public partial class ResolveNonMSBuildProjectOutput : Microsoft.Build.Tasks.ResolveProjectBase
     {
         public ResolveNonMSBuildProjectOutput() { }
@@ -784,6 +889,7 @@ public Warning() { }
         public string Code { get { throw null; } set { } }
         public string File { get { throw null; } set { } }
         public string HelpKeyword { get { throw null; } set { } }
+        public string HelpLink { get { throw null; } set { } }
         public string Text { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
@@ -867,6 +973,1023 @@ public ZipDirectory() { }
         public override bool Execute() { throw null; }
     }
 }
+namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
+{
+    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("1D9FE38A-0226-4b95-9C6B-6DFFA2236270")]
+    public partial class BootstrapperBuilder : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder
+    {
+        public BootstrapperBuilder() { }
+        public BootstrapperBuilder(string visualStudioVersion) { }
+        public string Path { get { throw null; } set { } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection Products { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings settings) { throw null; }
+        public string[] GetOutputFolders(string[] productCodes, string culture, string fallbackCulture, Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation componentsLocation) { throw null; }
+        public static string XmlToConfigurationFile(System.Xml.XmlNode input) { throw null; }
+    }
+    public partial class BuildMessage : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage
+    {
+        internal BuildMessage() { }
+        public int HelpId { get { throw null; } }
+        public string HelpKeyword { get { throw null; } }
+        public string Message { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity Severity { get { throw null; } }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("936D32F9-1A68-4d5e-98EA-044AC9A1AADA")]
+    public enum BuildMessageSeverity
+    {
+        Error = 2,
+        Info = 0,
+        Warning = 1,
+    }
+    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("FAD7BA7C-CA00-41e0-A5EF-2DA9A74E58E6")]
+    public partial class BuildResults : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults
+    {
+        internal BuildResults() { }
+        public string[] ComponentFiles { get { throw null; } }
+        public string KeyFile { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[] Messages { get { throw null; } }
+        public bool Succeeded { get { throw null; } }
+    }
+    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("5D13802C-C830-4b41-8E7A-F69D9DD6A095")]
+    public partial class BuildSettings : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings
+    {
+        public BuildSettings() { }
+        public string ApplicationFile { get { throw null; } set { } }
+        public string ApplicationName { get { throw null; } set { } }
+        public bool ApplicationRequiresElevation { get { throw null; } set { } }
+        public string ApplicationUrl { get { throw null; } set { } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation ComponentsLocation { get { throw null; } set { } }
+        public string ComponentsUrl { get { throw null; } set { } }
+        public bool CopyComponents { get { throw null; } set { } }
+        public int FallbackLCID { get { throw null; } set { } }
+        public int LCID { get { throw null; } set { } }
+        public string OutputPath { get { throw null; } set { } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection ProductBuilders { get { throw null; } }
+        public string SupportUrl { get { throw null; } set { } }
+        public bool Validate { get { throw null; } set { } }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("12F49949-7B60-49CD-B6A0-2B5E4A638AAF")]
+    public enum ComponentsLocation
+    {
+        Absolute = 2,
+        HomeSite = 0,
+        Relative = 1,
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("1D202366-5EEA-4379-9255-6F8CDB8587C9")]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    public partial interface IBootstrapperBuilder
+    {
+        [System.Runtime.InteropServices.DispIdAttribute(1)]
+        string Path { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(4)]
+        Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection Products { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(5)]
+        Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings settings);
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("E3C981EA-99E6-4f48-8955-1AAFDFB5ACE4")]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    public partial interface IBuildMessage
+    {
+        [System.Runtime.InteropServices.DispIdAttribute(4)]
+        int HelpId { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(3)]
+        string HelpKeyword { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(2)]
+        string Message { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(1)]
+        Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity Severity { get; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("586B842C-D9C7-43b8-84E4-9CFC3AF9F13B")]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    public partial interface IBuildResults
+    {
+        [System.Runtime.InteropServices.DispIdAttribute(3)]
+        string[] ComponentFiles { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(2)]
+        string KeyFile { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(4)]
+        Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[] Messages { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(1)]
+        bool Succeeded { get; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("87EEBC69-0948-4ce6-A2DE-819162B87CC6")]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    public partial interface IBuildSettings
+    {
+        [System.Runtime.InteropServices.DispIdAttribute(2)]
+        string ApplicationFile { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(1)]
+        string ApplicationName { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(13)]
+        bool ApplicationRequiresElevation { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(3)]
+        string ApplicationUrl { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(11)]
+        Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation ComponentsLocation { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(4)]
+        string ComponentsUrl { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(5)]
+        bool CopyComponents { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(7)]
+        int FallbackLCID { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(6)]
+        int LCID { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(8)]
+        string OutputPath { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(9)]
+        Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection ProductBuilders { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(12)]
+        string SupportUrl { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(10)]
+        bool Validate { get; set; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("9E81BE3D-530F-4a10-8349-5D5947BA59AD")]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    public partial interface IProduct
+    {
+        [System.Runtime.InteropServices.DispIdAttribute(4)]
+        Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection Includes { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(2)]
+        string Name { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(1)]
+        Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder ProductBuilder { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(3)]
+        string ProductCode { get; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("0777432F-A60D-48b3-83DB-90326FE8C96E")]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    public partial interface IProductBuilder
+    {
+        [System.Runtime.InteropServices.DispIdAttribute(1)]
+        Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Product { get; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("0D593FC0-E3F1-4dad-A674-7EA4D327F79B")]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    public partial interface IProductBuilderCollection
+    {
+        [System.Runtime.InteropServices.DispIdAttribute(2)]
+        void Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder builder);
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("63F63663-8503-4875-814C-09168E595367")]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    public partial interface IProductCollection
+    {
+        [System.Runtime.InteropServices.DispIdAttribute(1)]
+        int Count { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(2)]
+        Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Item(int index);
+        [System.Runtime.InteropServices.DispIdAttribute(3)]
+        Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Product(string productCode);
+    }
+    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("532BF563-A85D-4088-8048-41F51AC5239F")]
+    public partial class Product : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct
+    {
+        public Product() { }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection Includes { get { throw null; } }
+        public string Name { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder ProductBuilder { get { throw null; } }
+        public string ProductCode { get { throw null; } }
+    }
+    public partial class ProductBuilder : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilder
+    {
+        internal ProductBuilder() { }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Product { get { throw null; } }
+    }
+    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("D25C0741-99CA-49f7-9460-95E5F25EEF43")]
+    public partial class ProductBuilderCollection : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection, System.Collections.IEnumerable
+    {
+        internal ProductBuilderCollection() { }
+        public void Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder builder) { }
+        public System.Collections.IEnumerator GetEnumerator() { throw null; }
+    }
+    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("EFFA164B-3E87-4195-88DB-8AC004DDFE2A")]
+    public partial class ProductCollection : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection, System.Collections.IEnumerable
+    {
+        internal ProductCollection() { }
+        public int Count { get { throw null; } }
+        public System.Collections.IEnumerator GetEnumerator() { throw null; }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Item(int index) { throw null; }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Product(string productCode) { throw null; }
+    }
+}
+namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
+{
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class ApplicationIdentity
+    {
+        public ApplicationIdentity(string url, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity deployManifestIdentity, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity applicationManifestIdentity) { }
+        public ApplicationIdentity(string url, string deployManifestPath, string applicationManifestPath) { }
+        public override string ToString() { throw null; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    [System.Xml.Serialization.XmlRootAttribute("ApplicationManifest")]
+    public sealed partial class ApplicationManifest : Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest
+    {
+        public ApplicationManifest() { }
+        public ApplicationManifest(string targetFrameworkVersion) { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string ConfigFile { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public override Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference EntryPoint { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string ErrorReportUrl { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection FileAssociations { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool HostInBrowser { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string IconFile { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool IsClickOnceManifest { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public int MaxTargetPath { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string OSDescription { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string OSSupportUrl { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string OSVersion { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Product { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Publisher { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string SuiteName { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string SupportUrl { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string TargetFrameworkVersion { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo TrustInfo { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool UseApplicationTrust { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("ConfigFile")]
+        public string XmlConfigFile { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlElementAttribute("EntryPointIdentity")]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity XmlEntryPointIdentity { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("EntryPointParameters")]
+        public string XmlEntryPointParameters { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("EntryPointPath")]
+        public string XmlEntryPointPath { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("ErrorReportUrl")]
+        public string XmlErrorReportUrl { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlArrayAttribute("FileAssociations")]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation[] XmlFileAssociations { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("HostInBrowser")]
+        public string XmlHostInBrowser { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("IconFile")]
+        public string XmlIconFile { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("IsClickOnceManifest")]
+        public string XmlIsClickOnceManifest { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("OSBuild")]
+        public string XmlOSBuild { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("OSDescription")]
+        public string XmlOSDescription { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("OSMajor")]
+        public string XmlOSMajor { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("OSMinor")]
+        public string XmlOSMinor { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("OSRevision")]
+        public string XmlOSRevision { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("OSSupportUrl")]
+        public string XmlOSSupportUrl { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Product")]
+        public string XmlProduct { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Publisher")]
+        public string XmlPublisher { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("SuiteName")]
+        public string XmlSuiteName { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("SupportUrl")]
+        public string XmlSupportUrl { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("UseApplicationTrust")]
+        public string XmlUseApplicationTrust { get { throw null; } set { } }
+        public override void Validate() { }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    [System.Xml.Serialization.XmlRootAttribute("AssemblyIdentity")]
+    public sealed partial class AssemblyIdentity
+    {
+        public AssemblyIdentity() { }
+        public AssemblyIdentity(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity identity) { }
+        public AssemblyIdentity(string name) { }
+        public AssemblyIdentity(string name, string version) { }
+        public AssemblyIdentity(string name, string version, string publicKeyToken, string culture) { }
+        public AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture) { }
+        public AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture, string type) { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Culture { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool IsFrameworkAssembly { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool IsNeutralPlatform { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool IsStrongName { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Name { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string ProcessorArchitecture { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string PublicKeyToken { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Type { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Version { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Culture")]
+        public string XmlCulture { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Name")]
+        public string XmlName { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("ProcessorArchitecture")]
+        public string XmlProcessorArchitecture { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("PublicKeyToken")]
+        public string XmlPublicKeyToken { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Type")]
+        public string XmlType { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Version")]
+        public string XmlVersion { get { throw null; } set { } }
+        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity FromAssemblyName(string assemblyName) { throw null; }
+        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity FromFile(string path) { throw null; }
+        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity FromManagedAssembly(string path) { throw null; }
+        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity FromManifest(string path) { throw null; }
+        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity FromNativeAssembly(string path) { throw null; }
+        public string GetFullName(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags flags) { throw null; }
+        public bool IsInFramework(string frameworkIdentifier, string frameworkVersion) { throw null; }
+        public override string ToString() { throw null; }
+        [System.FlagsAttribute]
+        public enum FullNameFlags
+        {
+            All = 3,
+            Default = 0,
+            ProcessorArchitecture = 1,
+            Type = 2,
+        }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    [System.Xml.Serialization.XmlRootAttribute("AssemblyManifest")]
+    public partial class AssemblyManifest : Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
+    {
+        public AssemblyManifest() { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[] ExternalProxyStubs { get { throw null; } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlArrayAttribute("ExternalProxyStubs")]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[] XmlExternalProxyStubs { get { throw null; } set { } }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class AssemblyReference : Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference
+    {
+        public AssemblyReference() { }
+        public AssemblyReference(string path) { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity AssemblyIdentity { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool IsPrerequisite { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType ReferenceType { get { throw null; } set { } }
+        protected internal override string SortName { get { throw null; } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlElementAttribute("AssemblyIdentity")]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity XmlAssemblyIdentity { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("IsNative")]
+        public string XmlIsNative { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("IsPrerequisite")]
+        public string XmlIsPrerequisite { get { throw null; } set { } }
+        public override string ToString() { throw null; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class AssemblyReferenceCollection : System.Collections.IEnumerable
+    {
+        internal AssemblyReferenceCollection() { }
+        public int Count { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference this[int index] { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference assembly) { throw null; }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference Add(string path) { throw null; }
+        public void Clear() { }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference Find(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity identity) { throw null; }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference Find(string name) { throw null; }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference FindTargetPath(string targetPath) { throw null; }
+        public System.Collections.IEnumerator GetEnumerator() { throw null; }
+        public void Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference assemblyReference) { }
+    }
+    public enum AssemblyReferenceType
+    {
+        ClickOnceManifest = 1,
+        ManagedAssembly = 2,
+        NativeAssembly = 3,
+        Unspecified = 0,
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public abstract partial class BaseReference
+    {
+        protected internal BaseReference() { }
+        protected internal BaseReference(string path) { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Group { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Hash { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool IsOptional { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string ResolvedPath { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public long Size { get { throw null; } set { } }
+        protected internal abstract string SortName { get; }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string SourcePath { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string TargetPath { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Group")]
+        public string XmlGroup { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Hash")]
+        public string XmlHash { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("HashAlg")]
+        public string XmlHashAlgorithm { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("IsOptional")]
+        public string XmlIsOptional { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Path")]
+        public string XmlPath { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Size")]
+        public string XmlSize { get { throw null; } set { } }
+        public override string ToString() { throw null; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public partial class ComClass
+    {
+        public ComClass() { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string ClsId { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Description { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string ProgId { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string ThreadingModel { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string TlbId { get { throw null; } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Clsid")]
+        public string XmlClsId { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Description")]
+        public string XmlDescription { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Progid")]
+        public string XmlProgId { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("ThreadingModel")]
+        public string XmlThreadingModel { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Tlbid")]
+        public string XmlTlbId { get { throw null; } set { } }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class CompatibleFramework
+    {
+        public CompatibleFramework() { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Profile { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string SupportedRuntime { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Version { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Profile")]
+        public string XmlProfile { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("SupportedRuntime")]
+        public string XmlSupportedRuntime { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Version")]
+        public string XmlVersion { get { throw null; } set { } }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class CompatibleFrameworkCollection : System.Collections.IEnumerable
+    {
+        internal CompatibleFrameworkCollection() { }
+        public int Count { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework this[int index] { get { throw null; } }
+        public void Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework compatibleFramework) { }
+        public void Clear() { }
+        public System.Collections.IEnumerator GetEnumerator() { throw null; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    [System.Xml.Serialization.XmlRootAttribute("DeployManifest")]
+    public sealed partial class DeployManifest : Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
+    {
+        public DeployManifest() { }
+        public DeployManifest(string targetFrameworkMoniker) { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection CompatibleFrameworks { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool CreateDesktopShortcut { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string DeploymentUrl { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool DisallowUrlActivation { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public override Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference EntryPoint { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string ErrorReportUrl { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool Install { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool MapFileExtensions { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string MinimumRequiredVersion { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Product { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Publisher { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string SuiteName { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string SupportUrl { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string TargetFrameworkMoniker { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool TrustUrlParameters { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool UpdateEnabled { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public int UpdateInterval { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode UpdateMode { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit UpdateUnit { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlArrayAttribute("CompatibleFrameworks")]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework[] XmlCompatibleFrameworks { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("CreateDesktopShortcut")]
+        public string XmlCreateDesktopShortcut { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("DeploymentUrl")]
+        public string XmlDeploymentUrl { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("DisallowUrlActivation")]
+        public string XmlDisallowUrlActivation { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("ErrorReportUrl")]
+        public string XmlErrorReportUrl { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Install")]
+        public string XmlInstall { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("MapFileExtensions")]
+        public string XmlMapFileExtensions { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("MinimumRequiredVersion")]
+        public string XmlMinimumRequiredVersion { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Product")]
+        public string XmlProduct { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Publisher")]
+        public string XmlPublisher { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("SuiteName")]
+        public string XmlSuiteName { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("SupportUrl")]
+        public string XmlSupportUrl { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("TrustUrlParameters")]
+        public string XmlTrustUrlParameters { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("UpdateEnabled")]
+        public string XmlUpdateEnabled { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("UpdateInterval")]
+        public string XmlUpdateInterval { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("UpdateMode")]
+        public string XmlUpdateMode { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("UpdateUnit")]
+        public string XmlUpdateUnit { get { throw null; } set { } }
+        public override void Validate() { }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class FileAssociation
+    {
+        public FileAssociation() { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string DefaultIcon { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Description { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Extension { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string ProgId { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("DefaultIcon")]
+        public string XmlDefaultIcon { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Description")]
+        public string XmlDescription { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Extension")]
+        public string XmlExtension { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Progid")]
+        public string XmlProgId { get { throw null; } set { } }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class FileAssociationCollection : System.Collections.IEnumerable
+    {
+        internal FileAssociationCollection() { }
+        public int Count { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation this[int index] { get { throw null; } }
+        public void Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation fileAssociation) { }
+        public void Clear() { }
+        public System.Collections.IEnumerator GetEnumerator() { throw null; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class FileReference : Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference
+    {
+        public FileReference() { }
+        public FileReference(string path) { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass[] ComClasses { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool IsDataFile { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[] ProxyStubs { get { throw null; } }
+        protected internal override string SortName { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[] TypeLibs { get { throw null; } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlArrayAttribute("ComClasses")]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass[] XmlComClasses { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlArrayAttribute("ProxyStubs")]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[] XmlProxyStubs { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlArrayAttribute("TypeLibs")]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[] XmlTypeLibs { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("WriteableType")]
+        public string XmlWriteableType { get { throw null; } set { } }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class FileReferenceCollection : System.Collections.IEnumerable
+    {
+        internal FileReferenceCollection() { }
+        public int Count { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference this[int index] { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) { throw null; }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference Add(string path) { throw null; }
+        public void Clear() { }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference FindTargetPath(string targetPath) { throw null; }
+        public System.Collections.IEnumerator GetEnumerator() { throw null; }
+        public void Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) { }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public abstract partial class Manifest
+    {
+        protected internal Manifest() { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity AssemblyIdentity { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection AssemblyReferences { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Description { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public virtual Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference EntryPoint { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection FileReferences { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public System.IO.Stream InputStream { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection OutputMessages { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool ReadOnly { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string SourcePath { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlElementAttribute("AssemblyIdentity")]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity XmlAssemblyIdentity { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlArrayAttribute("AssemblyReferences")]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference[] XmlAssemblyReferences { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Description")]
+        public string XmlDescription { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlArrayAttribute("FileReferences")]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference[] XmlFileReferences { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Schema")]
+        public string XmlSchema { get { throw null; } set { } }
+        public void ResolveFiles() { }
+        public void ResolveFiles(string[] searchPaths) { }
+        public override string ToString() { throw null; }
+        public void UpdateFileInfo() { }
+        public void UpdateFileInfo(string targetFrameworkVersion) { }
+        public virtual void Validate() { }
+        protected void ValidatePlatform() { }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public static partial class ManifestReader
+    {
+        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest ReadManifest(System.IO.Stream input, bool preserveStream) { throw null; }
+        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest ReadManifest(string path, bool preserveStream) { throw null; }
+        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest ReadManifest(string manifestType, System.IO.Stream input, bool preserveStream) { throw null; }
+        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest ReadManifest(string manifestType, string path, bool preserveStream) { throw null; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public static partial class ManifestWriter
+    {
+        public static void WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { }
+        public static void WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, System.IO.Stream output) { }
+        public static void WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, string path) { }
+        public static void WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, string path, string targetframeWorkVersion) { }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class OutputMessage
+    {
+        internal OutputMessage() { }
+        public string Name { get { throw null; } }
+        public string Text { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType Type { get { throw null; } }
+        public string[] GetArguments() { throw null; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class OutputMessageCollection : System.Collections.IEnumerable
+    {
+        internal OutputMessageCollection() { }
+        public int ErrorCount { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage this[int index] { get { throw null; } }
+        public int WarningCount { get { throw null; } }
+        public void Clear() { }
+        public System.Collections.IEnumerator GetEnumerator() { throw null; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public enum OutputMessageType
+    {
+        Error = 2,
+        Info = 0,
+        Warning = 1,
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public partial class ProxyStub
+    {
+        public ProxyStub() { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string BaseInterface { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string IID { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Name { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string NumMethods { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string TlbId { get { throw null; } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("BaseInterface")]
+        public string XmlBaseInterface { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Iid")]
+        public string XmlIID { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Name")]
+        public string XmlName { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("NumMethods")]
+        public string XmlNumMethods { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Tlbid")]
+        public string XmlTlbId { get { throw null; } set { } }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public static partial class SecurityUtilities
+    {
+        public static void SignFile(System.Security.Cryptography.X509Certificates.X509Certificate2 cert, System.Uri timestampUrl, string path) { }
+        public static void SignFile(string certPath, System.Security.SecureString certPassword, System.Uri timestampUrl, string path) { }
+        public static void SignFile(string certThumbprint, System.Uri timestampUrl, string path) { }
+        public static void SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion) { }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class TrustInfo
+    {
+        public TrustInfo() { }
+        public bool HasUnmanagedCodePermission { get { throw null; } }
+        public bool IsFullTrust { get { throw null; } }
+        public bool PreserveFullTrustPermissionSet { get { throw null; } set { } }
+        public string SameSiteAccess { get { throw null; } set { } }
+        public void Clear() { }
+        public void Read(System.IO.Stream input) { }
+        public void Read(string path) { }
+        public void ReadManifest(System.IO.Stream input) { }
+        public void ReadManifest(string path) { }
+        public override string ToString() { throw null; }
+        public void Write(System.IO.Stream output) { }
+        public void Write(string path) { }
+        public void WriteManifest(System.IO.Stream output) { }
+        public void WriteManifest(System.IO.Stream input, System.IO.Stream output) { }
+        public void WriteManifest(string path) { }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public partial class TypeLib
+    {
+        public TypeLib() { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Flags { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string HelpDirectory { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string ResourceId { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string TlbId { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Version { get { throw null; } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Flags")]
+        public string XmlFlags { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("HelpDir")]
+        public string XmlHelpDirectory { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("ResourceId")]
+        public string XmlResourceId { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Tlbid")]
+        public string XmlTlbId { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Version")]
+        public string XmlVersion { get { throw null; } set { } }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public enum UpdateMode
+    {
+        Background = 0,
+        Foreground = 1,
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public enum UpdateUnit
+    {
+        Days = 1,
+        Hours = 0,
+        Weeks = 2,
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public partial class WindowClass
+    {
+        public WindowClass() { }
+        public WindowClass(string name, bool versioned) { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Name { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool Versioned { get { throw null; } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Name")]
+        public string XmlName { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Versioned")]
+        public string XmlVersioned { get { throw null; } set { } }
+    }
+}
 namespace Microsoft.Build.Tasks.Hosting
 {
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
@@ -1045,3 +2168,12 @@ public partial interface IVbcHostObjectFreeThreaded
         bool Compile();
     }
 }
+namespace System.Deployment.Internal.CodeSigning
+{
+    public sealed partial class RSAPKCS1SHA256SignatureDescription : System.Security.Cryptography.SignatureDescription
+    {
+        public RSAPKCS1SHA256SignatureDescription() { }
+        public override System.Security.Cryptography.AsymmetricSignatureDeformatter CreateDeformatter(System.Security.Cryptography.AsymmetricAlgorithm key) { throw null; }
+        public override System.Security.Cryptography.AsymmetricSignatureFormatter CreateFormatter(System.Security.Cryptography.AsymmetricAlgorithm key) { throw null; }
+    }
+}
diff --git a/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs b/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
index 146d06ca8bc..40abd53b294 100644
--- a/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
+++ b/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
@@ -401,6 +401,7 @@ public void LogCommandLine(string commandLine) { }
         public void LogCriticalMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
         public void LogError(string message, params object[] messageArgs) { }
         public void LogError(string subcategory, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
+        public void LogError(string subcategory, string errorCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
         public void LogErrorFromException(System.Exception exception) { }
         public void LogErrorFromException(System.Exception exception, bool showStackTrace) { }
         public void LogErrorFromException(System.Exception exception, bool showStackTrace, bool showDetail, string file) { }
@@ -422,6 +423,7 @@ public void LogMessageFromResources(string messageResourceName, params object[]
         public void LogTelemetry(string eventName, System.Collections.Generic.IDictionary<string, string> properties) { }
         public void LogWarning(string message, params object[] messageArgs) { }
         public void LogWarning(string subcategory, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
+        public void LogWarning(string subcategory, string warningCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
         public void LogWarningFromException(System.Exception exception) { }
         public void LogWarningFromException(System.Exception exception, bool showStackTrace) { }
         public void LogWarningFromResources(string messageResourceName, params object[] messageArgs) { }
diff --git a/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs b/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
index fbc4b28ef38..e6cc6f3fa50 100644
--- a/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
+++ b/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
@@ -243,6 +243,7 @@ public void LogCommandLine(string commandLine) { }
         public void LogCriticalMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
         public void LogError(string message, params object[] messageArgs) { }
         public void LogError(string subcategory, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
+        public void LogError(string subcategory, string errorCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
         public void LogErrorFromException(System.Exception exception) { }
         public void LogErrorFromException(System.Exception exception, bool showStackTrace) { }
         public void LogErrorFromException(System.Exception exception, bool showStackTrace, bool showDetail, string file) { }
@@ -264,6 +265,7 @@ public void LogMessageFromResources(string messageResourceName, params object[]
         public void LogTelemetry(string eventName, System.Collections.Generic.IDictionary<string, string> properties) { }
         public void LogWarning(string message, params object[] messageArgs) { }
         public void LogWarning(string subcategory, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
+        public void LogWarning(string subcategory, string warningCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
         public void LogWarningFromException(System.Exception exception) { }
         public void LogWarningFromException(System.Exception exception, bool showStackTrace) { }
         public void LogWarningFromResources(string messageResourceName, params object[] messageArgs) { }
diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
index 835cbaf394f..870bbe7458a 100644
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/net/Microsoft.Build.cs
@@ -869,6 +869,7 @@ public partial class EvaluationContext
     {
         internal EvaluationContext() { }
         public static Microsoft.Build.Evaluation.Context.EvaluationContext Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy) { throw null; }
+        public static Microsoft.Build.Evaluation.Context.EvaluationContext Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem) { throw null; }
         public enum SharingPolicy
         {
             Isolated = 1,
@@ -1382,6 +1383,12 @@ internal ProjectTaskOutputPropertyInstance() { }
         public string TaskParameter { get { throw null; } }
         public override Microsoft.Build.Construction.ElementLocation TaskParameterLocation { get { throw null; } }
     }
+    public sealed partial class RarNode
+    {
+        public RarNode() { }
+        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(bool nodeReuse, bool lowPriority, out System.Exception shutdownException, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { shutdownException = default(System.Exception); throw null; }
+        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(out System.Exception shutdownException) { shutdownException = default(System.Exception); throw null; }
+    }
     public partial class RequestedProjectState
     {
         public RequestedProjectState() { }
@@ -1402,6 +1409,25 @@ public enum TargetResultCode : byte
         Success = (byte)1,
     }
 }
+namespace Microsoft.Build.FileSystem
+{
+    public abstract partial class MSBuildFileSystemBase
+    {
+        protected MSBuildFileSystemBase() { }
+        public abstract bool DirectoryExists(string path);
+        public abstract System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern="*", System.IO.SearchOption searchOption=(System.IO.SearchOption)(0));
+        public abstract System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern="*", System.IO.SearchOption searchOption=(System.IO.SearchOption)(0));
+        public abstract System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern="*", System.IO.SearchOption searchOption=(System.IO.SearchOption)(0));
+        public abstract bool FileExists(string path);
+        public abstract bool FileOrDirectoryExists(string path);
+        public abstract System.IO.FileAttributes GetAttributes(string path);
+        public abstract System.IO.Stream GetFileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
+        public abstract System.DateTime GetLastWriteTimeUtc(string path);
+        public abstract System.IO.TextReader ReadFile(string path);
+        public abstract byte[] ReadFileAllBytes(string path);
+        public abstract string ReadFileAllText(string path);
+    }
+}
 namespace Microsoft.Build.Globbing
 {
     public partial class CompositeGlob : Microsoft.Build.Globbing.IMSBuildGlob
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
index f659dab2bac..a47f5848144 100644
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
@@ -869,6 +869,7 @@ public partial class EvaluationContext
     {
         internal EvaluationContext() { }
         public static Microsoft.Build.Evaluation.Context.EvaluationContext Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy) { throw null; }
+        public static Microsoft.Build.Evaluation.Context.EvaluationContext Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem) { throw null; }
         public enum SharingPolicy
         {
             Isolated = 1,
@@ -1376,6 +1377,12 @@ internal ProjectTaskOutputPropertyInstance() { }
         public string TaskParameter { get { throw null; } }
         public override Microsoft.Build.Construction.ElementLocation TaskParameterLocation { get { throw null; } }
     }
+    public sealed partial class RarNode
+    {
+        public RarNode() { }
+        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(bool nodeReuse, bool lowPriority, out System.Exception shutdownException, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { shutdownException = default(System.Exception); throw null; }
+        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(out System.Exception shutdownException) { shutdownException = default(System.Exception); throw null; }
+    }
     public partial class RequestedProjectState
     {
         public RequestedProjectState() { }
@@ -1396,6 +1403,25 @@ public enum TargetResultCode : byte
         Success = (byte)1,
     }
 }
+namespace Microsoft.Build.FileSystem
+{
+    public abstract partial class MSBuildFileSystemBase
+    {
+        protected MSBuildFileSystemBase() { }
+        public abstract bool DirectoryExists(string path);
+        public abstract System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern="*", System.IO.SearchOption searchOption=(System.IO.SearchOption)(0));
+        public abstract System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern="*", System.IO.SearchOption searchOption=(System.IO.SearchOption)(0));
+        public abstract System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern="*", System.IO.SearchOption searchOption=(System.IO.SearchOption)(0));
+        public abstract bool FileExists(string path);
+        public abstract bool FileOrDirectoryExists(string path);
+        public abstract System.IO.FileAttributes GetAttributes(string path);
+        public abstract System.IO.Stream GetFileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
+        public abstract System.DateTime GetLastWriteTimeUtc(string path);
+        public abstract System.IO.TextReader ReadFile(string path);
+        public abstract byte[] ReadFileAllBytes(string path);
+        public abstract string ReadFileAllText(string path);
+    }
+}
 namespace Microsoft.Build.Globbing
 {
     public partial class CompositeGlob : Microsoft.Build.Globbing.IMSBuildGlob
diff --git a/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs b/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
index 392c88c6c77..8ebcf56507a 100644
--- a/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
@@ -890,7 +890,6 @@ public static IEnumerable<object[]> InsertMetadataElemenetAfterSiblingsTestData
                         <m>v</m>
                       </i>"
                 };
-
             }
         }
 
@@ -1014,7 +1013,6 @@ public static IEnumerable<object[]> InsertMetadataAttributeAfterSiblingsTestData
                         <b>value_b</b>
                       </i>"
                 };
-
             }
         }
 
@@ -3192,9 +3190,7 @@ private static string ComposeExpectedProjectString(string expectedItem)
 </Project>";
             expectedItem = AdjustSpacesForItem(expectedItem);
 
-            expected = ObjectModelHelpers.CleanupFileContents(string.Format(expected, expectedItem));
-
-            return expected;
+            return ObjectModelHelpers.CleanupFileContents(string.Format(expected, expectedItem));
         }
 
         /// <summary>
@@ -3261,18 +3257,17 @@ private static string AdjustSpacesForItem(string expectedItem)
             }
             else
             {
-                sb.AppendLine(itemSpace + splits[0]);
+                sb.Append(itemSpace).AppendLine(splits[0]);
 
                 for (var i = 1; i < splits.Length - 1; i++)
                 {
-                    sb.AppendLine(metadataSpace + splits[i]);
+                    sb.Append(metadataSpace).AppendLine(splits[i]);
                 }
 
-                sb.Append(itemSpace + splits[splits.Length -1]);
+                sb.Append(itemSpace).Append(splits[splits.Length - 1]);
             }
 
-            expectedItem = sb.ToString();
-            return expectedItem;
+            return sb.ToString();
         }
     }
 }
diff --git a/src/Build.OM.UnitTests/Construction/ElementLocationPublic_Tests.cs b/src/Build.OM.UnitTests/Construction/ElementLocationPublic_Tests.cs
index a07a5fb9a4c..28a8a1d6313 100644
--- a/src/Build.OM.UnitTests/Construction/ElementLocationPublic_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ElementLocationPublic_Tests.cs
@@ -16,6 +16,7 @@
 using System.Linq;
 using System.Reflection;
 using Xunit;
+using Shouldly;
 
 namespace Microsoft.Build.UnitTests.Construction
 {
@@ -125,6 +126,8 @@ public void LocationStringsMedley()
 
             string locations = project.Xml.Location.LocationString + "\r\n";
 
+            List<string> attributeLocations = new List<string>(2);
+
             foreach (var element in project.Xml.AllChildren)
             {
                 foreach (var property in element.GetType().GetProperties(BindingFlags.Public | BindingFlags.Instance))
@@ -133,9 +136,9 @@ public void LocationStringsMedley()
                     {
                         if (property.Name == "ParameterLocations")
                         {
-                            var values = new List<KeyValuePair<string, ElementLocation>>(((ICollection<KeyValuePair<string, ElementLocation>>)property.GetValue(element, null)));
+                            var values = new List<KeyValuePair<string, ElementLocation>>((ICollection<KeyValuePair<string, ElementLocation>>)property.GetValue(element, null));
 
-                            values.ForEach((value) => locations += value.Key + ":" + value.Value.LocationString + "\r\n");
+                            values.ForEach(value => attributeLocations.Add(value.Key + ":" + value.Value.LocationString));
                         }
                         else
                         {
@@ -194,8 +197,6 @@ public void LocationStringsMedley()
 c:\foo\bar.csproj (23,25)
 c:\foo\bar.csproj (24,32)
 c:\foo\bar.csproj (24,29)
-Text: (26,32)
-Importance: (26,66)
 c:\foo\bar.csproj (26,43)
 c:\foo\bar.csproj (26,25)
 c:\foo\bar.csproj (28,29)
@@ -204,6 +205,9 @@ public void LocationStringsMedley()
 ";
 
             Helpers.VerifyAssertLineByLine(expected, locations);
+
+            // attribute order depends on dictionary internals
+            attributeLocations.ShouldBe(new[] { "Text: (26,32)", "Importance: (26,66)" }, ignoreOrder: true);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
index 9e15aa96ecd..3f387d1481a 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
@@ -458,7 +458,6 @@ public void ReadInvalidUpdateWithIncludeAndExclude(string project)
         {
             Assert.Throws<InvalidProjectFileException>(() =>
             {
-
                 ProjectRootElement.Create(XmlReader.Create(new StringReader(project)));
             }
            );
diff --git a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
index 4f0e18bb982..86a44b3822f 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -532,7 +532,7 @@ public void ValidXmlXmlReaderCache()
         public void LoadCommonTargets()
         {
             ProjectCollection projectCollection = new ProjectCollection();
-            string toolsPath = projectCollection.Toolsets.Where(toolset => (string.Compare(toolset.ToolsVersion, ObjectModelHelpers.MSBuildDefaultToolsVersion, StringComparison.OrdinalIgnoreCase) == 0)).First().ToolsPath;
+            string toolsPath = projectCollection.Toolsets.Where(toolset => (string.Equals(toolset.ToolsVersion, ObjectModelHelpers.MSBuildDefaultToolsVersion, StringComparison.OrdinalIgnoreCase))).First().ToolsPath;
 
             string[] targets =
             {
@@ -905,7 +905,6 @@ public void ItemsEnumerator()
 
         public void SolutionCanNotBeOpened()
         {
-            
             Assert.Throws<InvalidProjectFileException>(() =>
             {
                 string solutionFile = null;
@@ -936,10 +935,7 @@ public void SolutionCanNotBeOpened()
                 }
                 finally
                 {
-                    if (security != null)
-                    {
-                        security.RemoveAccessRule(rule);
-                    }
+                    security?.RemoveAccessRule(rule);
 
                     File.Delete(solutionFile);
                     File.Delete(tempFileSentinel);
@@ -984,10 +980,7 @@ public void ProjectCanNotBeOpened()
                 }
                 finally
                 {
-                    if (security != null)
-                    {
-                        security.RemoveAccessRule(rule);
-                    }
+                    security?.RemoveAccessRule(rule);
 
                     File.Delete(projectFile);
                     Assert.False(File.Exists(projectFile));
@@ -1034,7 +1027,6 @@ public void SolutionCorrupt()
         [PlatformSpecific(TestPlatforms.Windows)]  //This test is platform specific for Windows
         public void ConcurrentProjectOpenAndCloseThroughProject()
         {
-
             int iterations = 500;
             string[] paths = ObjectModelHelpers.GetTempFiles(iterations);
 
@@ -1743,7 +1735,6 @@ private void AssertProjectFileAfterReload(
             bool reloadProjectFromMemory,
             Action<string, string, string> projectFileAssert)
         {
-
             using (var env = TestEnvironment.Create())
             {
                 var projectCollection = env.CreateProjectCollection().Collection;
@@ -1900,7 +1891,6 @@ private void AssertReload(
                 Assert.Equal(childrenCount, projectElement.AllChildren.Count());
             }
 
-
             if (xmlChanged)
             {
                 Assert.NotEqual(xml, projectElement.RawXml);
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index 1ee4bde1de2..c305a27ed6c 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -406,6 +406,34 @@ public void RecursiveDirWithSemicolonSeparatedInclude()
             }
         }
 
+        [Theory]
+        [InlineData(@"<i Condition='false' Include='\**\*.cs'/>")]
+        [InlineData(@"<i Condition='false' Include='/**/*.cs'/>")]
+        [InlineData(@"<i Condition='false' Include='/**\*.cs'/>")]
+        [InlineData(@"<i Condition='false' Include='\**/*.cs'/>")]
+        public void FullFileSystemScanGlobWithFalseCondition(string itemDefinition)
+        {
+            IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(itemDefinition, allItems: false, ignoreCondition: true);
+            items.ShouldBeEmpty();
+        }
+
+        [Theory]
+        [InlineData(@"<i Condition='false' Include='somedir\**\*.cs'/>")]
+        [InlineData(@"<i Condition='false' Include='somedir/**/*.cs'/>")]
+        [InlineData(@"<i Condition='false' Include='somedir/**\*.cs'/>")]
+        [InlineData(@"<i Condition='false' Include='somedir\**/*.cs'/>")]
+        public void PartialFileSystemScanGlobWithFalseCondition(string itemDefinition)
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFolder directory = env.CreateFolder(createFolder: true);
+                TransientTestFile file = env.CreateFile(directory, "a.cs", String.Empty);
+
+                IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(itemDefinition.Replace("somedir", directory.Path), allItems: false, ignoreCondition: true);
+                items.ShouldNotBeEmpty();
+            }
+        }
+
         /// <summary>
         /// Basic exclude case
         /// </summary>
@@ -900,7 +928,6 @@ public void ExcludeWithMissmatchingGlobCones(string includeString, string exclud
                 var testFiles = env.CreateTestProjectWithFiles(projectContents, files,relativePathFromRootToProject);
                 ObjectModelHelpers.AssertItems(expectedInclude, new Project(testFiles.ProjectFile, new Dictionary<string, string>(), MSBuildConstants.CurrentToolsVersion, projectCollection).Items.ToList());
             }
-
         }
 
         [Theory(Skip = "https://github.com/Microsoft/msbuild/issues/1576")]
@@ -921,7 +948,6 @@ public void ExcludingRelativeItemToCurrentDirectoryShouldWorkWithAboveTheConeInc
                 var testFiles = env.CreateTestProjectWithFiles(projectContents, files, relativePathFromRootToProject);
                 ObjectModelHelpers.AssertItems(expectedInclude, new Project(testFiles.ProjectFile, new Dictionary<string, string>(), MSBuildConstants.CurrentToolsVersion, projectCollection).Items.ToList());
             }
-
         }
 
         /// <summary>
@@ -959,7 +985,7 @@ public void CopyFromWithItemListExpressionClonesMetadata()
         /// Expression like @(x) should not clone metadata, even if the item type is different.
         /// It's obvious that it shouldn't clone it if the item type is the same.
         /// If it is different, it doesn't clone it for performance; even if the item definition metadata
-        /// changes later (this is design time), the inheritors of that item definition type 
+        /// changes later (this is design time), the inheritors of that item definition type
         /// (even those that have subsequently been transformed to a different itemtype) should see
         /// the changes, by design.
         /// Just to make sure we don't change that behavior, we test it here.
@@ -1342,7 +1368,7 @@ public void BuiltInMisqualifiedMetadataExpression()
         }
 
         /// <summary>
-        /// Metadata condition should work correctly with built-in metadata 
+        /// Metadata condition should work correctly with built-in metadata
         /// </summary>
         [Fact]
         public void BuiltInMetadataInMetadataCondition()
@@ -2080,7 +2106,7 @@ public void RemoveGlob()
                 );
 
             Assert.Equal(2, items.Count);
-            Assert.Equal(@"a.txt;b.cs", string.Join(";", items.Select(i => i.EvaluatedInclude))); ;
+            Assert.Equal(@"a.txt;b.cs", string.Join(";", items.Select(i => i.EvaluatedInclude))); 
         }
 
         [Fact]
@@ -2093,7 +2119,7 @@ public void RemoveItemReference()
                 );
 
             Assert.Equal(2, items.Count);
-            Assert.Equal(@"a;c", string.Join(";", items.Select(i => i.EvaluatedInclude))); ;
+            Assert.Equal(@"a;c", string.Join(";", items.Select(i => i.EvaluatedInclude))); 
         }
 
         [Theory]
@@ -2274,7 +2300,7 @@ public void RemoveWithItemReferenceOnIntrinsicMatchingMetadata()
         [Fact]
         public void RemoveWithPropertyReferenceInMatchOnMetadata()
         {
-            string content = 
+            string content =
                 @"<Project>
                     <PropertyGroup>
                         <Meta1>v0</Meta1>
@@ -2495,7 +2521,7 @@ public void UpdateShouldRespectCondition()
                               <i Update='c'>
                                   <m1 Condition='1 == 0'>from_false_metadata</m1>
                               </i>";
-            
+
             var project = ObjectModelHelpers.CreateInMemoryProject(ObjectModelHelpers.FormatProjectContentsWithItemGroupFragment(projectContents));
 
             var expectedInitial = new Dictionary<string, string>
@@ -2558,7 +2584,6 @@ public void UpdateWithConditionShouldNotApplyOnItemsIgnoringCondition()
             ObjectModelHelpers.AssertItemHasMetadata(expectedUpdateFromUnconditionedElement, itemsIgnoringCondition[3]);
         }
 
-
         [Fact]
         public void LastUpdateWins()
         {
@@ -3354,7 +3379,7 @@ private static List<ProjectItem> GetItemsFromFragmentWithGlobs(string itemGroupF
 
         /// <summary>
         /// Get the item of type "i" using the item Xml fragment provided.
-        /// If there is more than one, fail. 
+        /// If there is more than one, fail.
         /// </summary>
         private static ProjectItem GetOneItemFromFragment(string fragment)
         {
@@ -3366,7 +3391,7 @@ private static ProjectItem GetOneItemFromFragment(string fragment)
 
         /// <summary>
         /// Get the item of type "i" in the project provided.
-        /// If there is more than one, fail. 
+        /// If there is more than one, fail.
         /// </summary>
         private static ProjectItem GetOneItem(string content)
         {
diff --git a/src/Build.OM.UnitTests/Definition/Project_Tests.cs b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
index f85190f0854..642d7169b0a 100644
--- a/src/Build.OM.UnitTests/Definition/Project_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
@@ -2866,7 +2866,7 @@ public void GetItemProvenanceResultsShouldBeInItemElementOrder()
             var sb = new StringBuilder();
             for (int i = 0; i < itemElements; i++)
             {
-                sb.AppendLine($"<i_{i} Include=\"a\"/>");
+                sb.Append("<i_").Append(i).AppendLine(" Include=\"a\"/>");
                 expected.Add(($"i_{i}", Operation.Include, Provenance.StringLiteral, 1));
             }
 
diff --git a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
index 0b8fc55697a..e1ddcb897b8 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
@@ -14,6 +14,7 @@
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
+using System.Linq;
 
 namespace Microsoft.Build.UnitTests.OM.Instance
 {
@@ -342,6 +343,9 @@ public void ReadMetadata()
             ProjectItemInstance item = GetOneItem(content);
 
             var itemMetadata = Helpers.MakeList(item.Metadata);
+
+            itemMetadata = itemMetadata.OrderBy(pmi => pmi.Name).ToList();
+
             Assert.Equal(2, itemMetadata.Count);
             Assert.Equal("m1", itemMetadata[0].Name);
             Assert.Equal("m2", itemMetadata[1].Name);
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
index ec57b9901ab..b31ffbe17bb 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-
     using System;
     using System.Collections.Generic;
     using System.Runtime.CompilerServices;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
index 0c1bf733a7e..aa285e5e98f 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
@@ -57,7 +57,6 @@ public ElementLinkPair<CT> AppendNewLabeledChaildWithVerify<CT>(ObjectType where
         public ElementLinkPair<CT> AddNewChaildWithVerify<CT>(ObjectType where, string id, Func<T, string, CT> adder, Func<CT, string, bool> matcher)
             where CT : ProjectElement
         {
-
             var c1Where = adder(this.Get(where), id);
             Assert.NotNull(c1Where);
 
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
index fc833a00f64..14ecdd51296 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
@@ -241,11 +241,10 @@ private static void Verify(SdkReference view, SdkReference real, ValidationConte
             if (view == null && real == null) return;
             Assert.NotNull(view);
             Assert.NotNull(real);
-            
+
             Assert.Equal(real.Name, view.Name);
             Assert.Equal(real.Version, view.Version);
             Assert.Equal(real.MinimumVersion, view.MinimumVersion);
-
         }
 
         private static void Verify(SdkResult view, SdkResult real, ValidationContext context = null)
@@ -291,7 +290,7 @@ public static void Verify(ProjectPair pair, ValidationContext context = null)
             if (pair == null) return;
             var real = pair.Real;
             var view = pair.View;
-            context = context ?? new ValidationContext();
+            context ??= new ValidationContext();
             context.Pair = pair;
 
 
@@ -321,7 +320,6 @@ public static void Verify(ProjectPair pair, ValidationContext context = null)
                 Verify(view.ImportsIncludingDuplicates, real.ImportsIncludingDuplicates, Verify, context);
             }
 
-            
             Verify(view.AllEvaluatedProperties, real.AllEvaluatedProperties, Verify, context);
             Verify(view.AllEvaluatedItemDefinitionMetadata, real.AllEvaluatedItemDefinitionMetadata, Verify, context);
             Verify(view.AllEvaluatedItems, real.AllEvaluatedItems, Verify, context);
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs
index 80e5f60cdc0..25ef9caa625 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-
     using System;
     using System.Collections;
     using System.Collections.Generic;
@@ -41,7 +40,6 @@ public MyTestCollectionGroup()
         public MyTestCollectionGroup StdGroup { get; }
         public LinkedConstructionModify_Tests(MyTestCollectionGroup group)
         {
-
             this.StdGroup = group;
             group.Clear();
             this.StdGroup.Local.Importing = true;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs
index 7dc33150768..9be5ab30462 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs
@@ -3,7 +3,6 @@
 
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-
     using System;
     using System.Collections;
     using System.Collections.Generic;
@@ -109,7 +108,6 @@ public void ProjectExtensionsElementReadOnly()
             Assert.Equal(realXml["b"], viewXml["b"]);
             Assert.Equal("x", viewXml["a"]);
             Assert.Equal("y", viewXml["b"]);
-
         }
 
         [Fact]
@@ -285,7 +283,6 @@ public void ProjectTaskElementReadOnly()
         [Fact]
         public void ProjectUsingTaskElementReadOnly()
         {
-
             var preReal = this.StdGroup.RealXml;
             var preView = this.StdGroup.ViewXml;
 
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs
index ddea5990734..3c225aec6db 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-
     using System;
     using System.Collections;
     using System.Collections.Generic;
@@ -26,7 +25,6 @@ public MyTestCollectionGroup() : base(2, 1) { }
         public TestCollectionGroup StdGroup { get; }
         public LinkedEvaluationModify_Tests(MyTestCollectionGroup group)
         {
-
             this.StdGroup = group;
             group.Clear();
         }
@@ -105,7 +103,6 @@ public void ProjectModifyRenameAndSafeAs()
 
             // and finally just ensure that all is identical
             ViewValidation.Verify(viewProj, realProj);
-
         }
 
         [Fact]
@@ -130,7 +127,6 @@ public void ProjectItemModify()
             };
 
             /// test AddItems
-
             // add a new files in the view, ensure it is added correctly and also the real object will immediately reflect that add as well
             Assert.Null(pair.GetSingleItemWithVerify(ObjectType.View, "foo.cpp"));
             var fooView = pair.AddSingleItemWithVerify(ObjectType.View, "cpp", "foo.cpp");
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationReadOnly_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationReadOnly_Tests.cs
index 355b0426ff8..5792411a2a7 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationReadOnly_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationReadOnly_Tests.cs
@@ -3,7 +3,6 @@
 
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-
     using System;
     using System.Collections;
     using System.Collections.Generic;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs
index d541acdb12b..52face4ec61 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-
     using System;
     using System.Collections.Generic;
     using System.Collections.Immutable;
@@ -22,7 +21,6 @@ public MyTestCollectionGroup() : base(2, 4) { }
         public TestCollectionGroup StdGroup { get; }
         public LinkedProjectCollection_Tests(MyTestCollectionGroup group)
         {
-
             this.StdGroup = group;
             group.Clear();
         }
@@ -34,7 +32,7 @@ public void EnumerationBasic()
             var pcRemote = this.StdGroup.Remote[0];
 
             var proj1Path = this.StdGroup.StdProjectFiles[0];
-            var proj2Path = this.StdGroup.StdProjectFiles[1]; ;
+            var proj2Path = this.StdGroup.StdProjectFiles[1]; 
 
             var proj1 = pcLocal.LoadProject(proj1Path);
             var proj2 = pcRemote.LoadProject(proj2Path);
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs
index 04012fbb73a..c92fdd25470 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-
     using System;
     using System.Collections;
     using System.Collections.Generic;
@@ -80,14 +79,13 @@ public void ResetBeforeTests()
         public MyTestCollectionGroup StdGroup { get; }
         public LinkedSpecialCasesScenarios(MyTestCollectionGroup group)
         {
-
             this.StdGroup = group;
             group.ResetBeforeTests();
         }
 
         private ProjectPair GetNewInMemoryProject(string path, string content = null)
         {
-            content = content ?? TestCollectionGroup.SampleProjectFile;
+            content ??= TestCollectionGroup.SampleProjectFile;
             var tempPath = this.StdGroup.Disk.GetAbsolutePath(path);
             var newReal = this.StdGroup.Target.LoadInMemoryWithSettings(content, ProjectLoadSettings.IgnoreMissingImports);
             newReal.Xml.FullPath = tempPath;
@@ -110,11 +108,11 @@ private void CloneAndAddInternal(ProjectRootElement sourceProject)
             xmlPair.View.Save();
             Assert.False(xmlPair.View.HasUnsavedChanges);
 
-            sourceProject = sourceProject ?? xmlPair.View;
+            sourceProject ??= xmlPair.View;
 
 
             // var existingItemGroup1 = sourceProject.QuerySingleChildrenWithValidation<ProjectItemGroupElement>((ig) => ig.Label == "Group1");
-            var existingItemGroupList = sourceProject.AllChildren.OfType<ProjectItemGroupElement>().Where(((ig) => ig.Label == "Group1")).ToList();
+            var existingItemGroupList = sourceProject.AllChildren.OfType<ProjectItemGroupElement>().Where((ig) => ig.Label == "Group1").ToList();
             Assert.Single(existingItemGroupList);
             var existingItemGroup = existingItemGroupList[0];
 
@@ -164,9 +162,9 @@ private void CopyFromInternal(ProjectRootElement sourceProject)
             xmlPair.View.Save();
             Assert.False(xmlPair.View.HasUnsavedChanges);
 
-            sourceProject = sourceProject ?? xmlPair.View;
+            sourceProject ??= xmlPair.View;
 
-            var existingItemGroupList = sourceProject.AllChildren.OfType<ProjectItemGroupElement>().Where(((ig) => ig.Label == "Group1")).ToList();
+            var existingItemGroupList = sourceProject.AllChildren.OfType<ProjectItemGroupElement>().Where((ig) => ig.Label == "Group1").ToList();
             Assert.Single(existingItemGroupList);
             var existingItemGroup = existingItemGroupList[0];
             Assert.NotNull(existingItemGroup);
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs
index e8e654a68ec..0c53fd5bed8 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs
@@ -21,7 +21,6 @@ namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
     ///
     /// This approach with extension methods helps us put all implementation in one place, and only standard copy and pace "hookup" is needed for each classes.
     /// </summary>
-
     internal interface IProjectElementContainerLinkHelper
     {
         ProjectCollectionLinker Linker { get; }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementContainerLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementContainerLink.cs
index ca4450dd0be..8080dd5afc7 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementContainerLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementContainerLink.cs
@@ -101,5 +101,4 @@ public TemplateProjectElementContainerLink(MockProjectElementContainerLinkRemote
         public override void RemoveChild(ProjectElement child) => CImpl.RemoveChild(child);
         #endregion
     }
-
 }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectMetadataElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectMetadataElementLink.cs
index b0889847c6f..93a45d29468 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectMetadataElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectMetadataElementLink.cs
@@ -25,7 +25,6 @@ public override ProjectElement CreateLinkedObject(IImportHolder holder)
         // ProjectMetadataElementLink support
         public string Value { get => MetadataXml.Value; set => MetadataXml.Value = value; }
         public void ChangeName(string newName) { MetadataXml.Name = newName; }
-
     }
 
     internal class MockProjectMetadataElementLink : ProjectMetadataElementLink, ILinkMock, IProjectElementLinkHelper
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectPropertyElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectPropertyElementLink.cs
index b882f3fa9f4..8333d6cea58 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectPropertyElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectPropertyElementLink.cs
@@ -25,7 +25,6 @@ public override ProjectElement CreateLinkedObject(IImportHolder holder)
         // ProjectPropertyElementLink support
         public string Value { get => PropertyXml.Value; set => PropertyXml.Value = value; }
         public void ChangeName(string newName) { PropertyXml.Name = newName; }
-
     }
 
     internal class MockProjectPropertyElementLink : ProjectPropertyElementLink, ILinkMock, IProjectElementLinkHelper
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/ProjectElemetExportHelper.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/ProjectElemetExportHelper.cs
index 51f5cd16e8a..49138cbd4cd 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/ProjectElemetExportHelper.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/ProjectElemetExportHelper.cs
@@ -131,6 +131,5 @@ public static MockProjectElementLinkRemoter ExportElement(this ProjectCollection
 
             return factory(exporter, xml);
         }
-
     }
 }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
index 235477ca636..253ceac7972 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
@@ -24,7 +24,6 @@ public override Project CreateLinkedObject(IImportHolder holder)
 
 
         ///  ProjectLink remoting
-
         public MockProjectElementLinkRemoter Xml => this.OwningCollection.ExportElement(this.Source.Xml);
 
         public bool ThrowInsteadOfSplittingItemElement { get => this.Source.ThrowInsteadOfSplittingItemElement; set => this.Source.ThrowInsteadOfSplittingItemElement = value; }
diff --git a/src/Build.OM.UnitTests/TransientIO.cs b/src/Build.OM.UnitTests/TransientIO.cs
index 020a2e07060..a4baa8399ca 100644
--- a/src/Build.OM.UnitTests/TransientIO.cs
+++ b/src/Build.OM.UnitTests/TransientIO.cs
@@ -88,7 +88,6 @@ public TransientIO GetSubFolder(string path)
             var subFolder = this.GetRelativePath(path);
             if (!this.Children.TryGetValue(subFolder, out var result))
             {
-
                 result  = new TransientIO(this, subFolder);
                 this.Children.Add(subFolder, result);
             }
@@ -131,6 +130,5 @@ public void Dispose()
             this.Clear();
             // this object still can be used ...
         }
-
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
index c9e4fdd7302..93eeb2927b1 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
@@ -502,7 +502,7 @@ private void TestSkipIsolationConstraints(string glob, string referencePath, boo
 
             glob = $"$([MSBuild]::Escape('{glob}'))";
 
-            projectContents = projectContents ?? $@"
+            projectContents ??= $@"
 <Project>
     <ItemGroup>
         <{ItemTypeNames.GraphIsolationExemptReference} Include=`{glob};ShouldNotMatchAnything`/>
diff --git a/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs b/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
index 8bd5360d434..ba2a1b00f57 100644
--- a/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
@@ -67,7 +67,6 @@ public void CannotAddAfterAggregation()
                 });
                 e.Message.ShouldContain("Cannot add after aggregation");
             }
-
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs b/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs
index 4517bb7c85a..3531f223967 100644
--- a/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs
@@ -416,20 +416,20 @@ internal class EventHandlerHelper
             internal EventHandlerHelper(IEventSource source, Exception exceptionToThrow)
             {
                 _exceptionInHandlers = exceptionToThrow;
-                source.AnyEventRaised += new AnyEventHandler(Source_AnyEventRaised);
-                source.BuildFinished += new BuildFinishedEventHandler(Source_BuildFinished);
-                source.BuildStarted += new BuildStartedEventHandler(Source_BuildStarted);
-                source.CustomEventRaised += new CustomBuildEventHandler(Source_CustomEventRaised);
-                source.ErrorRaised += new BuildErrorEventHandler(Source_ErrorRaised);
-                source.MessageRaised += new BuildMessageEventHandler(Source_MessageRaised);
-                source.ProjectFinished += new ProjectFinishedEventHandler(Source_ProjectFinished);
-                source.ProjectStarted += new ProjectStartedEventHandler(Source_ProjectStarted);
-                source.StatusEventRaised += new BuildStatusEventHandler(Source_StatusEventRaised);
-                source.TargetFinished += new TargetFinishedEventHandler(Source_TargetFinished);
-                source.TargetStarted += new TargetStartedEventHandler(Source_TargetStarted);
-                source.TaskFinished += new TaskFinishedEventHandler(Source_TaskFinished);
-                source.TaskStarted += new TaskStartedEventHandler(Source_TaskStarted);
-                source.WarningRaised += new BuildWarningEventHandler(Source_WarningRaised);
+                source.AnyEventRaised += Source_AnyEventRaised;
+                source.BuildFinished += Source_BuildFinished;
+                source.BuildStarted += Source_BuildStarted;
+                source.CustomEventRaised += Source_CustomEventRaised;
+                source.ErrorRaised += Source_ErrorRaised;
+                source.MessageRaised += Source_MessageRaised;
+                source.ProjectFinished += Source_ProjectFinished;
+                source.ProjectStarted += Source_ProjectStarted;
+                source.StatusEventRaised += Source_StatusEventRaised;
+                source.TargetFinished += Source_TargetFinished;
+                source.TargetStarted += Source_TargetStarted;
+                source.TaskFinished += Source_TaskFinished;
+                source.TaskStarted += Source_TaskStarted;
+                source.WarningRaised += Source_WarningRaised;
             }
             #endregion
 
diff --git a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
index 2162e074edb..e29c9374f82 100644
--- a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
@@ -483,7 +483,7 @@ public void RegisterDuplicateForwardingLoggerLogger()
             int countForwardingLogger = 0;
             foreach (string loggerName in _initializedService.RegisteredLoggerTypeNames)
             {
-                if (String.Compare("Microsoft.Build.Logging.ConfigurableForwardingLogger", loggerName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals("Microsoft.Build.Logging.ConfigurableForwardingLogger", loggerName, StringComparison.OrdinalIgnoreCase))
                 {
                     countForwardingLogger++;
                 }
@@ -585,7 +585,7 @@ public void RegisterGoodDiscriptions()
             int countForwardingLogger = 0;
             foreach (string loggerName in _initializedService.RegisteredLoggerTypeNames)
             {
-                if (String.Compare("Microsoft.Build.Logging.ConfigurableForwardingLogger", loggerName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals("Microsoft.Build.Logging.ConfigurableForwardingLogger", loggerName, StringComparison.OrdinalIgnoreCase))
                 {
                     countForwardingLogger++;
                 }
@@ -597,7 +597,7 @@ public void RegisterGoodDiscriptions()
             countForwardingLogger = 0;
             foreach (string loggerName in _initializedService.RegisteredLoggerTypeNames)
             {
-                if (String.Compare("Microsoft.Build.BackEnd.Logging.CentralForwardingLogger", loggerName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals("Microsoft.Build.BackEnd.Logging.CentralForwardingLogger", loggerName, StringComparison.OrdinalIgnoreCase))
                 {
                     countForwardingLogger++;
                 }
@@ -1070,7 +1070,7 @@ private LoggerDescription CreateLoggerDescription(string loggerClassName, string
         {
             string eventsToForward = "CustomEvent";
 
-            if (forwardAllEvents == true)
+            if (forwardAllEvents)
             {
                 eventsToForward = "BuildStartedEvent;BuildFinishedEvent;ProjectStartedEvent;ProjectFinishedEvent;TargetStartedEvent;TargetFinishedEvent;TaskStartedEvent;TaskFinishedEvent;ErrorEvent;WarningEvent;HighMessageEvent;NormalMessageEvent;LowMessageEvent;CustomEvent;CommandLine";
             }
@@ -1343,7 +1343,7 @@ internal int BuildFinishedCount
             public void Initialize(IEventSource eventSource)
             {
                 eventSource.AnyEventRaised +=
-                        new AnyEventHandler(LoggerEventHandler);
+                         LoggerEventHandler;
             }
 
             /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
index 53f75663934..aebd6d881a2 100644
--- a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
@@ -239,8 +239,7 @@ public void LogFatalErrorNullException()
             string helpKeyword;
             string resourceName = "FatalTaskError";
             string parameters = "TaskName";
-            string message = null;
-
+            string message;
             GenerateMessageFromExceptionAndResource(null, resourceName, out errorCode, out helpKeyword, out message, parameters);
             ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.LogFatalError(s_buildEventContext, null, fileInfo, resourceName, parameters);
@@ -347,8 +346,7 @@ public void LogFatalTaskError()
             string helpKeyword;
             string resourceName = "FatalTaskError";
             string parameters = "TaskName";
-            string message = null;
-
+            string message;
             GenerateMessageFromExceptionAndResource(exception, resourceName, out errorCode, out helpKeyword, out message, parameters);
             ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.LogFatalTaskError(s_buildEventContext, exception, fileInfo, parameters);
@@ -1128,7 +1126,7 @@ public void LogTelemetryNullEventName()
                 service.LogTelemetry(
                     buildEventContext: null,
                     eventName: null,
-                    properties: new Dictionary<string, string>());;
+                    properties: new Dictionary<string, string>());
             });
 
             Assert.Contains("eventName is null", exception.Message);
@@ -1163,7 +1161,6 @@ private void TestLogTelemetry(BuildEventContext buildEventContext, string eventN
                 Properties = properties == null ? new Dictionary<string, string>() : new Dictionary<string, string>(properties),
             };
 
-
             TelemetryEventArgs actualEventArgs = (TelemetryEventArgs)service.ProcessedBuildEvent;
 
             Assert.Equal(expectedEventArgs.EventName, actualEventArgs.EventName);
@@ -1269,7 +1266,7 @@ private void TestLogWarning(string taskName, string subCategoryKey)
         /// <param name="success">Success value to test</param>
         private void TestProjectFinishedEvent(string projectFile, bool success)
         {
-            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword((success ? "ProjectFinishedSuccess" : "ProjectFinishedFailure"), Path.GetFileName(projectFile));
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(success ? "ProjectFinishedSuccess" : "ProjectFinishedFailure", Path.GetFileName(projectFile));
             MockHost componentHost = new MockHost();
             ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1, componentHost);
             try
@@ -1340,7 +1337,7 @@ private void TestTaskStartedEvent(string taskName, string projectFile, string pr
         /// <param name="succeeded">Succeeded value to test</param>
         private void TestTaskFinished(string taskName, string projectFile, string projectFileOfTask, bool succeeded)
         {
-            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword((succeeded ? "TaskFinishedSuccess" : "TaskFinishedFailure"), taskName);
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(succeeded ? "TaskFinishedSuccess" : "TaskFinishedFailure", taskName);
             ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.LogTaskFinished(s_buildEventContext, taskName, projectFile, projectFileOfTask, succeeded);
             VerifyTaskFinishedEvent(taskName, projectFile, projectFileOfTask, succeeded, message, service);
@@ -1360,7 +1357,7 @@ private void TestTaskFinished(string taskName, string projectFile, string projec
         /// <param name="succeeded">Succeeded value to test</param>
         private void TestTargetFinished(string targetName, string projectFile, string projectFileOfTarget, bool succeeded)
         {
-            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword((succeeded ? "TargetFinishedSuccess" : "TargetFinishedFailure"), targetName, Path.GetFileName(projectFile));
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(succeeded ? "TargetFinishedSuccess" : "TargetFinishedFailure", targetName, Path.GetFileName(projectFile));
             ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1);
             List<TaskItem> outputs = new List<TaskItem>();
             outputs.Add(new TaskItem("ItemInclude", projectFile));
@@ -1382,8 +1379,7 @@ private void TestTargetFinished(string targetName, string projectFile, string pr
         /// <param name="projectFileOfTarget">ProjectFileOfTarget to test</param>
         private void TestTargetStartedEvent(string targetName, string projectFile, string projectFileOfTarget)
         {
-            string message = String.Empty;
-
+            string message;
             if (String.Equals(projectFile, projectFileOfTarget, StringComparison.OrdinalIgnoreCase))
             {
                 message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("TargetStartedProjectEntry", targetName, projectFile);
@@ -1410,7 +1406,7 @@ private void TestTargetStartedEvent(string targetName, string projectFile, strin
         private void TestTargetStartedWithParentTargetEvent(string targetName, string projectFile, string projectFileOfTarget)
         {
             string parentTargetName = "MyParentTarget";
-            string message = String.Empty;
+            string message;
             if (String.Equals(projectFile, projectFileOfTarget, StringComparison.OrdinalIgnoreCase))
             {
                 message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("TargetStartedProjectDepends", targetName, projectFile, parentTargetName);
@@ -1436,7 +1432,7 @@ private void TestTargetStartedWithParentTargetEvent(string targetName, string pr
         /// </summary>
         private void LogProjectStartedTestHelper(string projectFile, string targetNames)
         {
-            string message = string.Empty;
+            string message;
             if (!String.IsNullOrEmpty(targetNames))
             {
                 message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStartedPrefixForTopLevelProjectWithTargetNames", Path.GetFileName(projectFile), targetNames);
diff --git a/src/Build.UnitTests/BackEnd/MockHost.cs b/src/Build.UnitTests/BackEnd/MockHost.cs
index ed2b547c0af..388a44f149a 100644
--- a/src/Build.UnitTests/BackEnd/MockHost.cs
+++ b/src/Build.UnitTests/BackEnd/MockHost.cs
@@ -163,32 +163,17 @@ internal IRequestBuilder RequestBuilder
         /// </summary>
         public IBuildComponent GetComponent(BuildComponentType type)
         {
-            switch (type)
+            return type switch
             {
-                case BuildComponentType.ConfigCache:
-                    return (IBuildComponent)_configCache;
-
-                case BuildComponentType.LoggingService:
-                    return (IBuildComponent)_loggingService;
-
-                case BuildComponentType.RequestEngine:
-                    return (IBuildComponent)_requestEngine;
-
-                case BuildComponentType.TargetBuilder:
-                    return (IBuildComponent)_targetBuilder;
-
-                case BuildComponentType.ResultsCache:
-                    return (IBuildComponent)_resultsCache;
-
-                case BuildComponentType.RequestBuilder:
-                    return (IBuildComponent)_requestBuilder;
-
-                case BuildComponentType.SdkResolverService:
-                    return (IBuildComponent)_sdkResolverService;
-
-                default:
-                    throw new ArgumentException("Unexpected type " + type);
-            }
+                BuildComponentType.ConfigCache => (IBuildComponent)_configCache,
+                BuildComponentType.LoggingService => (IBuildComponent)_loggingService,
+                BuildComponentType.RequestEngine => (IBuildComponent)_requestEngine,
+                BuildComponentType.TargetBuilder => (IBuildComponent)_targetBuilder,
+                BuildComponentType.ResultsCache => (IBuildComponent)_resultsCache,
+                BuildComponentType.RequestBuilder => (IBuildComponent)_requestBuilder,
+                BuildComponentType.SdkResolverService => (IBuildComponent)_sdkResolverService,
+                _ => throw new ArgumentException("Unexpected type " + type),
+            };
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/MockSdkResolverService.cs b/src/Build.UnitTests/BackEnd/MockSdkResolverService.cs
index f3cfd1a2cb6..c31322a43bf 100644
--- a/src/Build.UnitTests/BackEnd/MockSdkResolverService.cs
+++ b/src/Build.UnitTests/BackEnd/MockSdkResolverService.cs
@@ -19,7 +19,7 @@ public void ClearCaches()
         {
         }
 
-        public Build.BackEnd.SdkResolution.SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive)
+        public Build.BackEnd.SdkResolution.SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
         {
             return null;
         }
diff --git a/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs b/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs
index 5dd66b6e929..83e60f427af 100644
--- a/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs
+++ b/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs
@@ -92,7 +92,7 @@ public Task<WorkUnitResult> ExecuteTask(TargetLoggingContext targetLoggingContex
             }
 
             ProjectOnErrorInstance errorTask = task as ProjectOnErrorInstance;
-            if (null != errorTask)
+            if (errorTask != null)
             {
                 ErrorTasks.Add(errorTask);
             }
diff --git a/src/Build.UnitTests/BackEnd/OnError_Tests.cs b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
index 745a3e91b04..8e3442960f5 100644
--- a/src/Build.UnitTests/BackEnd/OnError_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
@@ -48,7 +48,7 @@ public void Basic()
             p.Build(new string[] { "Build" }, new ILogger[] { l });
 
             Assert.Equal(1, l.ErrorCount); // "Expected one error because 'Build' failed."
-            Assert.True((l.FullLog.IndexOf("CleanUp-was-called") != -1)); // "The CleanUp target should have been called."
+            Assert.True(l.FullLog.IndexOf("CleanUp-was-called") != -1); // "The CleanUp target should have been called."
         }
 
 #if FEATURE_TASK_GENERATERESOURCES
@@ -205,8 +205,8 @@ public void TwoExecuteTargets()
             p.Build(new string[] { "Build" }, new ILogger[] { l });
 
             Assert.Equal(1, l.ErrorCount); // "Expected one error because 'Build' failed."
-            Assert.True((l.FullLog.IndexOf("CleanUp-was-called") != -1)); // "The CleanUp target should have been called."
-            Assert.True((l.FullLog.IndexOf("CleanUp2-was-called") != -1)); // "The CleanUp2 target should have been called."
+            Assert.True(l.FullLog.IndexOf("CleanUp-was-called") != -1); // "The CleanUp target should have been called."
+            Assert.True(l.FullLog.IndexOf("CleanUp2-was-called") != -1); // "The CleanUp2 target should have been called."
         }
 
         /*
@@ -237,8 +237,8 @@ public void TwoOnErrorClauses()
             p.Build(new string[] { "Build" }, new ILogger[] { l });
 
             Assert.Equal(1, l.ErrorCount); // "Expected one error because 'Build' failed."
-            Assert.True((l.FullLog.IndexOf("CleanUp-was-called") != -1)); // "The CleanUp target should have been called."
-            Assert.True((l.FullLog.IndexOf("CleanUp2-was-called") != -1)); // "The CleanUp2 target should have been called."
+            Assert.True(l.FullLog.IndexOf("CleanUp-was-called") != -1); // "The CleanUp target should have been called."
+            Assert.True(l.FullLog.IndexOf("CleanUp2-was-called") != -1); // "The CleanUp2 target should have been called."
         }
 
         /*
@@ -269,8 +269,8 @@ public void DependentTarget()
             p.Build(new string[] { "Build" }, new ILogger[] { l });
 
             Assert.Equal(1, l.ErrorCount); // "Expected one error because 'Build' failed."
-            Assert.True((l.FullLog.IndexOf("CleanUp-was-called") != -1)); // "The CleanUp target should have been called."
-            Assert.True((l.FullLog.IndexOf("CleanUp2-was-called") != -1)); // "The CleanUp2 target should have been called."
+            Assert.True(l.FullLog.IndexOf("CleanUp-was-called") != -1); // "The CleanUp target should have been called."
+            Assert.True(l.FullLog.IndexOf("CleanUp2-was-called") != -1); // "The CleanUp2 target should have been called."
         }
 
         /*
@@ -300,8 +300,8 @@ public void ErrorInChildIsHandledInParent()
             p.Build(new string[] { "Build" }, new ILogger[] { l });
 
             Assert.Equal(1, l.ErrorCount); // "Expected one error because 'BuildStep1' failed."
-            Assert.True((l.FullLog.IndexOf("CleanUp-was-called") != -1)); // "The CleanUp target should have been called."
-            Assert.True((l.FullLog.IndexOf("Error-in-build-step-1") != -1)); // "The BuildStep1 target should have been called."
+            Assert.True(l.FullLog.IndexOf("CleanUp-was-called") != -1); // "The CleanUp target should have been called."
+            Assert.True(l.FullLog.IndexOf("Error-in-build-step-1") != -1); // "The BuildStep1 target should have been called."
         }
 
 
@@ -326,7 +326,7 @@ public void NonExistentExecuteTarget()
             p.Build(new string[] { "Build" }, new ILogger[] { l });
 
             Assert.Equal(2, l.ErrorCount); // "Expected at least one error because 'Build' failed and one error because 'CleanUp' didn't exist."
-            Assert.True((l.FullLog.IndexOf("CleanUp-was-called") == -1)); // "The CleanUp target should not have been called."
+            Assert.True(l.FullLog.IndexOf("CleanUp-was-called") == -1); // "The CleanUp target should not have been called."
         }
 
         /*
@@ -353,7 +353,7 @@ public void TrueCondition()
             p.Build(new string[] { "Build" }, new ILogger[] { l });
 
             Assert.Equal(1, l.ErrorCount); // "Expected one error because 'Build' failed."
-            Assert.True((l.FullLog.IndexOf("CleanUp-was-called") != -1)); // "The CleanUp target should have been called."
+            Assert.True(l.FullLog.IndexOf("CleanUp-was-called") != -1); // "The CleanUp target should have been called."
         }
 
         /*
@@ -381,7 +381,7 @@ public void FalseCondition()
             p.Build(new string[] { "Build" }, new ILogger[] { l });
 
             Assert.Equal(1, l.ErrorCount); // "Expected one error because 'Build' failed."
-            Assert.True((l.FullLog.IndexOf("CleanUp-was-called") == -1)); // "The CleanUp target should not have been called."
+            Assert.True(l.FullLog.IndexOf("CleanUp-was-called") == -1); // "The CleanUp target should not have been called."
         }
 
         /*
@@ -412,7 +412,7 @@ public void PropertiesInExecuteTargets()
             p.Build(new string[] { "Build" }, new ILogger[] { l });
 
             Assert.Equal(1, l.ErrorCount); // "Expected one error because 'Build' failed."
-            Assert.True((l.FullLog.IndexOf("CleanUp-was-called") != -1)); // "The CleanUp target should have been called."
+            Assert.True(l.FullLog.IndexOf("CleanUp-was-called") != -1); // "The CleanUp target should have been called."
         }
 
         /*
@@ -452,9 +452,9 @@ public void ErrorTargetsContinueAfterErrorsInErrorHandler()
             p.Build(new string[] { "Build" }, new ILogger[] { l });
 
             Assert.Equal(4, l.ErrorCount); // "Four build errors expect: One from CoreBuild and on each from the error handlers."
-            Assert.True((l.FullLog.IndexOf("CleanUp1-was-called") != -1)); // "The CleanUp1 target should have been called."
-            Assert.True((l.FullLog.IndexOf("CleanUp2-was-called") != -1)); // "The CleanUp2 target should have been called."
-            Assert.True((l.FullLog.IndexOf("CleanUp3-was-called") != -1)); // "The CleanUp3 target should have been called."
+            Assert.True(l.FullLog.IndexOf("CleanUp1-was-called") != -1); // "The CleanUp1 target should have been called."
+            Assert.True(l.FullLog.IndexOf("CleanUp2-was-called") != -1); // "The CleanUp2 target should have been called."
+            Assert.True(l.FullLog.IndexOf("CleanUp3-was-called") != -1); // "The CleanUp3 target should have been called."
         }
 
         /*
@@ -507,7 +507,7 @@ public void CommentsAroundOnError()
             p.Build(new string[] { "Build" }, new ILogger[] { l });
 
             Assert.Equal(1, l.ErrorCount); // "Expected one error because 'Build' failed."
-            Assert.True((l.FullLog.IndexOf("CleanUp-was-called") != -1)); // "The CleanUp target should have been called."
+            Assert.True(l.FullLog.IndexOf("CleanUp-was-called") != -1); // "The CleanUp target should have been called."
         }
 
         /*
@@ -604,10 +604,10 @@ public void PostBuildBasic()
             p.Build(new string[] { "Build" }, new ILogger[] { l });
 
             Assert.Equal(0, l.ErrorCount); // "Expected no error because 'Build' succeeded."
-            Assert.True((l.FullLog.IndexOf("ResGen-was-called") != -1)); // "The ResGen target should have been called."
-            Assert.True((l.FullLog.IndexOf("Compile-was-called") != -1)); // "The Compile target should have been called."
-            Assert.True((l.FullLog.IndexOf("GenerateSatellites-was-called") != -1)); // "The GenerateSatellites target should have been called."
-            Assert.True((l.FullLog.IndexOf("PostBuild-was-called") != -1)); // "The PostBuild target should have been called."
+            Assert.True(l.FullLog.IndexOf("ResGen-was-called") != -1); // "The ResGen target should have been called."
+            Assert.True(l.FullLog.IndexOf("Compile-was-called") != -1); // "The Compile target should have been called."
+            Assert.True(l.FullLog.IndexOf("GenerateSatellites-was-called") != -1); // "The GenerateSatellites target should have been called."
+            Assert.True(l.FullLog.IndexOf("PostBuild-was-called") != -1); // "The PostBuild target should have been called."
         }
 
         /*
@@ -628,11 +628,11 @@ public void PostBuildOnSuccessWhereCompileFailed()
             p.Build(new string[] { "Build" }, new ILogger[] { l });
 
             Assert.Equal(1, l.ErrorCount); // "Expected one error because 'Build' failed."
-            Assert.True((l.FullLog.IndexOf("ResGen-was-called") != -1)); // "The ResGen target should have been called."
-            Assert.True((l.FullLog.IndexOf("Compile-was-called") != -1)); // "The Compile target should have been called."
-            Assert.True((l.FullLog.IndexOf("Compile-step-failed") != -1)); // "The Compile target should have failed."
-            Assert.True((l.FullLog.IndexOf("GenerateSatellites-was-called") == -1)); // "The GenerateSatellites target should not have been called."
-            Assert.True((l.FullLog.IndexOf("PostBuild-was-called") == -1)); // "The PostBuild target should not have been called."
+            Assert.True(l.FullLog.IndexOf("ResGen-was-called") != -1); // "The ResGen target should have been called."
+            Assert.True(l.FullLog.IndexOf("Compile-was-called") != -1); // "The Compile target should have been called."
+            Assert.True(l.FullLog.IndexOf("Compile-step-failed") != -1); // "The Compile target should have failed."
+            Assert.True(l.FullLog.IndexOf("GenerateSatellites-was-called") == -1); // "The GenerateSatellites target should not have been called."
+            Assert.True(l.FullLog.IndexOf("PostBuild-was-called") == -1); // "The PostBuild target should not have been called."
         }
 
         /*
@@ -653,11 +653,11 @@ public void PostBuildOnSuccessWhereGenerateSatellitesFailed()
             p.Build(new string[] { "Build" }, new ILogger[] { l });
 
             Assert.Equal(1, l.ErrorCount); // "Expected one error because 'Build' failed."
-            Assert.True((l.FullLog.IndexOf("ResGen-was-called") != -1)); // "The ResGen target should have been called."
-            Assert.True((l.FullLog.IndexOf("Compile-was-called") != -1)); // "The Compile target should have been called."
-            Assert.True((l.FullLog.IndexOf("GenerateSatellites-was-called") != -1)); // "The GenerateSatellites target should have been called."
-            Assert.True((l.FullLog.IndexOf("GenerateSatellites-step-failed") != -1)); // "The GenerateSatellites target should have failed."
-            Assert.True((l.FullLog.IndexOf("PostBuild-was-called") == -1)); // "The PostBuild target should not have been called."
+            Assert.True(l.FullLog.IndexOf("ResGen-was-called") != -1); // "The ResGen target should have been called."
+            Assert.True(l.FullLog.IndexOf("Compile-was-called") != -1); // "The Compile target should have been called."
+            Assert.True(l.FullLog.IndexOf("GenerateSatellites-was-called") != -1); // "The GenerateSatellites target should have been called."
+            Assert.True(l.FullLog.IndexOf("GenerateSatellites-step-failed") != -1); // "The GenerateSatellites target should have failed."
+            Assert.True(l.FullLog.IndexOf("PostBuild-was-called") == -1); // "The PostBuild target should not have been called."
         }
 
         /*
@@ -678,11 +678,11 @@ public void PostBuildAlwaysWhereCompileFailed()
             p.Build(new string[] { "Build" }, new ILogger[] { l });
 
             Assert.Equal(1, l.ErrorCount); // "Expected one error because 'Build' failed."
-            Assert.True((l.FullLog.IndexOf("ResGen-was-called") != -1)); // "The ResGen target should have been called."
-            Assert.True((l.FullLog.IndexOf("Compile-was-called") != -1)); // "The Compile target should have been called."
-            Assert.True((l.FullLog.IndexOf("Compile-step-failed") != -1)); // "The Compile target should have failed."
-            Assert.True((l.FullLog.IndexOf("GenerateSatellites-was-called") == -1)); // "The GenerateSatellites target should not have been called."
-            Assert.True((l.FullLog.IndexOf("PostBuild-was-called") != -1)); // "The PostBuild target should have been called."
+            Assert.True(l.FullLog.IndexOf("ResGen-was-called") != -1); // "The ResGen target should have been called."
+            Assert.True(l.FullLog.IndexOf("Compile-was-called") != -1); // "The Compile target should have been called."
+            Assert.True(l.FullLog.IndexOf("Compile-step-failed") != -1); // "The Compile target should have failed."
+            Assert.True(l.FullLog.IndexOf("GenerateSatellites-was-called") == -1); // "The GenerateSatellites target should not have been called."
+            Assert.True(l.FullLog.IndexOf("PostBuild-was-called") != -1); // "The PostBuild target should have been called."
         }
 
         /*
@@ -703,11 +703,11 @@ public void PostBuildFinalOutputChangedWhereCompileFailed()
             p.Build(new string[] { "Build" }, new ILogger[] { l });
 
             Assert.Equal(1, l.ErrorCount); // "Expected one error because 'Build' failed."
-            Assert.True((l.FullLog.IndexOf("ResGen-was-called") != -1)); // "The ResGen target should have been called."
-            Assert.True((l.FullLog.IndexOf("Compile-was-called") != -1)); // "The Compile target should have been called."
-            Assert.True((l.FullLog.IndexOf("Compile-step-failed") != -1)); // "The Compile target should have failed."
-            Assert.True((l.FullLog.IndexOf("GenerateSatellites-was-called") == -1)); // "The GenerateSatellites target should not have been called."
-            Assert.True((l.FullLog.IndexOf("PostBuild-was-called") == -1)); // "The PostBuild target should not have been called."
+            Assert.True(l.FullLog.IndexOf("ResGen-was-called") != -1); // "The ResGen target should have been called."
+            Assert.True(l.FullLog.IndexOf("Compile-was-called") != -1); // "The Compile target should have been called."
+            Assert.True(l.FullLog.IndexOf("Compile-step-failed") != -1); // "The Compile target should have failed."
+            Assert.True(l.FullLog.IndexOf("GenerateSatellites-was-called") == -1); // "The GenerateSatellites target should not have been called."
+            Assert.True(l.FullLog.IndexOf("PostBuild-was-called") == -1); // "The PostBuild target should not have been called."
         }
 
         /*
@@ -728,11 +728,11 @@ public void PostBuildFinalOutputChangedWhereGenerateSatellitesFailed()
             p.Build(new string[] { "Build" }, new ILogger[] { l });
 
             Assert.Equal(1, l.ErrorCount); // "Expected one error because 'Build' failed."
-            Assert.True((l.FullLog.IndexOf("ResGen-was-called") != -1)); // "The ResGen target should have been called."
-            Assert.True((l.FullLog.IndexOf("Compile-was-called") != -1)); // "The Compile target should have been called."
-            Assert.True((l.FullLog.IndexOf("GenerateSatellites-was-called") != -1)); // "The GenerateSatellites target should have been called."
-            Assert.True((l.FullLog.IndexOf("GenerateSatellites-step-failed") != -1)); // "The GenerateSatellites target should have failed."
-            Assert.True((l.FullLog.IndexOf("PostBuild-was-called") != -1)); // "The PostBuild target should have been called."
+            Assert.True(l.FullLog.IndexOf("ResGen-was-called") != -1); // "The ResGen target should have been called."
+            Assert.True(l.FullLog.IndexOf("Compile-was-called") != -1); // "The Compile target should have been called."
+            Assert.True(l.FullLog.IndexOf("GenerateSatellites-was-called") != -1); // "The GenerateSatellites target should have been called."
+            Assert.True(l.FullLog.IndexOf("GenerateSatellites-step-failed") != -1); // "The GenerateSatellites target should have failed."
+            Assert.True(l.FullLog.IndexOf("PostBuild-was-called") != -1); // "The PostBuild target should have been called."
         }
 
 
diff --git a/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
index 54bc2fa1dfc..5e68ff11991 100644
--- a/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
@@ -261,8 +261,7 @@ private BuildRequestConfiguration CreateTestProject(int configId)
             string projectFile = GetTestProjectFile(configId);
             File.WriteAllText(projectFile, projectFileContents.Replace('`', '"'));
 
-            string defaultToolsVersion = null;
-            defaultToolsVersion = FrameworkLocationHelper.PathToDotNetFrameworkV20 == null
+            string defaultToolsVersion = FrameworkLocationHelper.PathToDotNetFrameworkV20 == null
                                       ? ObjectModelHelpers.MSBuildDefaultToolsVersion
                                       : "2.0";
 
@@ -374,7 +373,7 @@ public Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext, Buil
                 return Task<BuildResult>.FromResult(result);
             }
 
-            if (null != _newRequests)
+            if (_newRequests != null)
             {
                 string[] projectFiles = new string[_newRequests.Length];
                 PropertyDictionary<ProjectPropertyInstance>[] properties = new PropertyDictionary<ProjectPropertyInstance>[_newRequests.Length];
diff --git a/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs b/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
index ac5094dfb01..fd732589b22 100644
--- a/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
@@ -69,10 +69,7 @@ public Scheduler_Tests()
             // Since we're creating our own BuildManager, we need to make sure that the default
             // one has properly relinquished the inproc node
             NodeProviderInProc nodeProviderInProc = ((IBuildComponentHost)BuildManager.DefaultBuildManager).GetComponent(BuildComponentType.InProcNodeProvider) as NodeProviderInProc;
-            if (nodeProviderInProc != null)
-            {
-                nodeProviderInProc.Dispose();
-            }
+            nodeProviderInProc?.Dispose();
 
             _host = new MockHost();
             _scheduler = new Scheduler();
@@ -379,10 +376,7 @@ public void VerifyRequestOrderingDoesNotAffectNodeCreationCountWithInProcAndAnyR
             // Since we're creating our own BuildManager, we need to make sure that the default
             // one has properly relinquished the inproc node
             NodeProviderInProc nodeProviderInProc = ((IBuildComponentHost)BuildManager.DefaultBuildManager).GetComponent(BuildComponentType.InProcNodeProvider) as NodeProviderInProc;
-            if (nodeProviderInProc != null)
-            {
-                nodeProviderInProc.Dispose();
-            }
+            nodeProviderInProc?.Dispose();
 
             _host = new MockHost();
             _host.BuildParameters.MaxNodeCount = 3;
@@ -543,10 +537,7 @@ public void VerifyNoOverCreationOfNodesWithBuildLoop()
             // Since we're creating our own BuildManager, we need to make sure that the default
             // one has properly relinquished the inproc node
             NodeProviderInProc nodeProviderInProc = ((IBuildComponentHost)BuildManager.DefaultBuildManager).GetComponent(BuildComponentType.InProcNodeProvider) as NodeProviderInProc;
-            if (nodeProviderInProc != null)
-            {
-                nodeProviderInProc.Dispose();
-            }
+            nodeProviderInProc?.Dispose();
 
             _host = new MockHost();
             _host.BuildParameters.MaxNodeCount = 3;
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
index 59e288501ae..f3fd55dcde6 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
@@ -271,6 +271,73 @@ public void SdkResolverLoaderErrorsWhenManifestTargetMissing()
             }
         }
 
+        [Fact]
+        public void SdkResolverLoaderHonorsIncludeDefaultEnvVar()
+        {
+            using (var env = TestEnvironment.Create(_output))
+            {
+                var origIncludeDefault = Environment.GetEnvironmentVariable("MSBUILDINCLUDEDEFAULTSDKRESOLVER");
+                try
+                {
+                    var testRoot = env.CreateFolder().Path;
+                    Environment.SetEnvironmentVariable("MSBUILDINCLUDEDEFAULTSDKRESOLVER", "false");
+                    SdkResolverLoader loader = new MockSdkResolverLoader()
+                    {
+                        LoadResolversAction = (resolverPath, loggingContext, location, resolvers) => {
+                            resolvers.Add(new MockSdkResolverWithAssemblyPath(resolverPath));
+                        }
+                    };
+                    IList<SdkResolverBase> resolvers = loader.LoadResolvers(_loggingContext, new MockElementLocation("file"));
+
+                    resolvers.Count.ShouldBe(0);
+                }
+                finally
+                {
+                    Environment.SetEnvironmentVariable("MSBUILDINCLUDEDEFAULTSDKRESOLVER", origIncludeDefault);
+                }
+            }
+        }
+
+        [Fact]
+        public void SdkResolverLoaderHonorsAdditionalResolversFolder()
+        {
+            using (var env = TestEnvironment.Create(_output))
+            {
+                var origResolversFolder = Environment.GetEnvironmentVariable("MSBUILDADDITIONALSDKRESOLVERSFOLDER");
+                try
+                {
+                    var testRoot = env.CreateFolder().Path;
+                    var additionalRoot = env.CreateFolder().Path;
+
+                    var resolver1 = "Resolver1";
+                    var resolver1Path = Path.Combine(additionalRoot, resolver1, $"{resolver1}.dll");
+                    Directory.CreateDirectory(Path.Combine(testRoot, resolver1));
+                    File.WriteAllText(Path.Combine(testRoot, resolver1, $"{resolver1}.dll"), string.Empty);
+                    Directory.CreateDirectory(Path.Combine(additionalRoot, resolver1));
+                    File.WriteAllText(resolver1Path, string.Empty);
+                    var resolver2 = "Resolver2";
+                    var resolver2Path = Path.Combine(testRoot, resolver2, $"{resolver2}.dll");
+                    Directory.CreateDirectory(Path.Combine(testRoot, resolver2));
+                    File.WriteAllText(resolver2Path, string.Empty);
+                    var resolver3 = "Resolver3";
+                    var resolver3Path = Path.Combine(additionalRoot, resolver3, $"{resolver3}.dll");
+                    Directory.CreateDirectory(Path.Combine(additionalRoot, resolver3));
+                    File.WriteAllText(resolver3Path, string.Empty);
+
+                    Environment.SetEnvironmentVariable("MSBUILDADDITIONALSDKRESOLVERSFOLDER", additionalRoot);
+
+                    SdkResolverLoader loader = new SdkResolverLoader();
+                    IList<string> resolvers = loader.FindPotentialSdkResolvers(testRoot, new MockElementLocation("file"));
+
+                    resolvers.ShouldBeSameIgnoringOrder(new[] { resolver1Path, resolver2Path, resolver3Path });
+                }
+                finally
+                {
+                    Environment.SetEnvironmentVariable("MSBUILDADDITIONALSDKRESOLVERSFOLDER", origResolversFolder);
+                }
+            }
+        }
+
         private class MockSdkResolverThatDoesNotLoad : SdkResolverBase
         {
             public const string ExpectedMessage = "A8BB8B3131D3475D881ACD3AF8D75BD6";
@@ -306,6 +373,25 @@ public override SdkResultBase Resolve(SdkReference sdkReference, SdkResolverCont
             }
         }
 
+        private class MockSdkResolverWithAssemblyPath : SdkResolverBase
+        {
+            public string AssemblyPath;
+
+            public MockSdkResolverWithAssemblyPath(string assemblyPath = "")
+            {
+                AssemblyPath = assemblyPath;
+            }
+
+            public override string Name => nameof(MockSdkResolverWithAssemblyPath);
+
+            public override int Priority => 0;
+
+            public override SdkResultBase Resolve(SdkReference sdkReference, SdkResolverContextBase resolverContext, SdkResultFactoryBase factory)
+            {
+                throw new NotImplementedException();
+            }
+        }
+
         private class MockSdkResolverLoader : SdkResolverLoader
         {
             public Func<string, LoggingContext, ElementLocation, Assembly> LoadResolverAssemblyFunc { get; set; }
@@ -314,6 +400,8 @@ private class MockSdkResolverLoader : SdkResolverLoader
 
             public Func<Assembly, IEnumerable<Type>> GetResolverTypesFunc { get; set; }
 
+            public Action<string, LoggingContext, ElementLocation, List<SdkResolver>> LoadResolversAction { get; set; }
+
             protected override Assembly LoadResolverAssembly(string resolverPath, LoggingContext loggingContext, ElementLocation location)
             {
                 if (LoadResolverAssemblyFunc != null)
@@ -343,6 +431,16 @@ internal override IList<string> FindPotentialSdkResolvers(string rootFolder, Ele
 
                 return base.FindPotentialSdkResolvers(rootFolder, location);
             }
+
+            protected override void LoadResolvers(string resolverPath, LoggingContext loggingContext, ElementLocation location, List<SdkResolver> resolvers)
+            {
+                if (LoadResolversAction != null)
+                {
+                    LoadResolversAction(resolverPath, loggingContext, location, resolvers);
+                    return;
+                }
+                base.LoadResolvers(resolverPath, loggingContext, location, resolvers);
+            }
         }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
index b6fa324c806..30be949c391 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
@@ -44,7 +44,7 @@ public void AssertAllResolverErrorsLoggedWhenSdkNotResolved()
 
             SdkReference sdk = new SdkReference("notfound", "referencedVersion", "minimumVersion");
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
 
             result.Success.ShouldBeFalse();
             result.ShouldNotBeNull();
@@ -77,7 +77,7 @@ public void AssertResolutionWarnsIfResolvedVersionIsDifferentFromReferencedVersi
                             ))
                 });
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
 
             result.Path.ShouldBe("path");
 
@@ -92,7 +92,7 @@ public void AssertErrorLoggedWhenResolverThrows()
 
             SdkReference sdk = new SdkReference("1sdkName", "version1", "minimumVersion");
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
 
             result.Path.ShouldBe("resolverpath1");
             _logger.Warnings.Select(i => i.Message).ShouldBe(new [] { "The SDK resolver \"MockSdkResolverThrows\" failed to run. EXMESSAGE" });
@@ -105,7 +105,7 @@ public void AssertFirstResolverCanResolve()
 
             SdkReference sdk = new SdkReference("1sdkName", "referencedVersion", "minimumVersion");
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
 
             result.Path.ShouldBe("resolverpath1");
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver1 running");
@@ -120,7 +120,7 @@ public void AssertFirstResolverErrorsSupressedWhenResolved()
             // be logged because MockSdkResolver2 will succeed.
             SdkReference sdk = new SdkReference("2sdkName", "version2", "minimumVersion");
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
 
             result.Path.ShouldBe("resolverpath2");
 
@@ -143,10 +143,10 @@ public void AssertResolverHasStatePreserved()
             SdkReference sdk = new SdkReference("othersdk", "1.0", "minimumVersion");
 
             // First call should not know state
-            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false).Path.ShouldBe("resolverpath");
+            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false).Path.ShouldBe("resolverpath");
 
             // Second call should have received state
-            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false).Path.ShouldBe(MockSdkResolverWithState.Expected);
+            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false).Path.ShouldBe(MockSdkResolverWithState.Expected);
         }
 
         [Fact]
@@ -159,10 +159,10 @@ public void AssertResolverStateNotPreserved()
             SdkReference sdk = new SdkReference("othersdk", "1.0", "minimumVersion");
 
             // First call should not know state
-            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false).Path.ShouldBe("resolverpath");
+            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false).Path.ShouldBe("resolverpath");
 
             // Second call should have received state
-            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false).Path.ShouldBe("resolverpath");
+            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false).Path.ShouldBe("resolverpath");
         }
 
         [Theory]
@@ -203,13 +203,13 @@ public void CachingWrapperShouldWarnWhenMultipleVersionsAreReferenced()
                     resolver
                 });
 
-            var result = service.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false);
+            var result = service.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
             resolver.ResolvedCalls.Count.ShouldBe(1);
             result.Path.ShouldBe("path");
             result.Version.ShouldBe("1.0.0");
             _logger.WarningCount.ShouldBe(0);
 
-            result = service.ResolveSdk(BuildEventContext.InvalidSubmissionId, new SdkReference("foo", "2.0.0", null), _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false);
+            result = service.ResolveSdk(BuildEventContext.InvalidSubmissionId, new SdkReference("foo", "2.0.0", null), _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
             resolver.ResolvedCalls.Count.ShouldBe(1);
             result.Path.ShouldBe("path");
             result.Version.ShouldBe("1.0.0");
@@ -285,7 +285,7 @@ public void SdkResolverCanReturnNoPaths(bool includePropertiesAndItems)
 
             SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
 
             result.Success.ShouldBeTrue();
             result.Path.ShouldBeNull();
@@ -322,7 +322,7 @@ public void SdkResultCanReturnPropertiesAndItems()
 
             SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
 
             result.Success.ShouldBeTrue();
             result.Path.ShouldBe(expectedPath);
@@ -369,7 +369,7 @@ public void SdkResultCanReturnMultiplePaths(bool includePropertiesAndItems)
 
             SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
 
             result.Success.ShouldBeTrue();
 
@@ -395,10 +395,8 @@ public void AssertResolutionWarnsIfResolvedVersionIsDifferentFromReferencedVersi
             var expectedPath2 = "Second/Path/To/Return/From/Resolver";
 
             var sdk = new SdkReference("foo", "1.0", null);
-
-            Dictionary<string, string> propertiesToAdd = null;
-            Dictionary<string, SdkResultItem> itemsToAdd = null;
-            
+            Dictionary<string, string> propertiesToAdd;
+            Dictionary<string, SdkResultItem> itemsToAdd;
             CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
 
             var resolver = new SdkUtilities.ConfigurableMockSdkResolver(
@@ -417,7 +415,7 @@ public void AssertResolutionWarnsIfResolvedVersionIsDifferentFromReferencedVersi
 
             SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
 
             result.Success.ShouldBeTrue();
 
@@ -465,7 +463,7 @@ public void CachingWrapperShouldOnlyResolveOnce()
             Parallel.For(
                 0,
                 10,
-                _ => service.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false));
+                _ => service.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false));
 
             var result = resolver.ResolvedCalls.ShouldHaveSingleItem();
 
@@ -502,11 +500,42 @@ public void InteractiveIsSetForResolverContext()
                 "sln",
                 "projectPath",
                 // Pass along interactive and expect it to be received in the SdkResolverContext
-                interactive: true);
+                interactive: true,
+                false);
 
             interactive.ShouldBeTrue();
         }
 
+        [Fact]
+        public void IsRunningInVisualStudioIsSetForResolverContext()
+        {
+            bool isRunningInVisualStudio = false;
+
+            var service = new CachingSdkResolverService();
+            service.InitializeForTests(
+                resolvers: new List<SdkResolver>
+                {
+                    new SdkUtilities.ConfigurableMockSdkResolver((sdkRference, resolverContext, factory) =>
+                    {
+                        isRunningInVisualStudio = resolverContext.IsRunningInVisualStudio;
+                        return null;
+                    })
+                });
+
+            var result = service.ResolveSdk(
+                BuildEventContext.InvalidSubmissionId,
+                new SdkReference("foo", "1.0.0", null),
+                _loggingContext,
+                new MockElementLocation("file"),
+                "sln",
+                "projectPath",
+                false,
+                // Pass along isRunningInVisualStudio and expect it to be received in the SdkResolverContext
+                isRunningInVisualStudio: true);
+
+            isRunningInVisualStudio.ShouldBeTrue();
+        }
+
         private class MockLoaderStrategy : SdkResolverLoader
         {
             private readonly bool _includeErrorResolver;
diff --git a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
index f8597385549..1804b8157ca 100644
--- a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
@@ -922,6 +922,26 @@ public void TestAfterTargetsWithTransitiveFailure()
             result.ResultsByTarget["Build"].AfterTargetsHaveFailed.ShouldBe(true);
         }
 
+        /// <summary>
+        /// Test a project that has a cycle in AfterTargets
+        /// </summary>
+        [Fact]
+        public void TestAfterTargetsWithCycleDoesNotHang()
+        {
+            string projectBody = @"
+<Target Name='Build' AfterTargets='After2' />
+
+<Target Name='After1' AfterTargets='Build' />
+
+<Target Name='After2' AfterTargets='After1' />
+";
+
+            BuildResult result = BuildSimpleProject(projectBody, new string[] { "Build" }, failTaskNumber: int.MaxValue /* no task failure needed here */);
+            result.ResultsByTarget["Build"].ResultCode.ShouldBe(TargetResultCode.Success);
+            result.ResultsByTarget["Build"].AfterTargetsHaveFailed.ShouldBe(false);
+        }
+
+
         /// <summary>
         /// Test after target on a skipped target
         /// </summary>
@@ -1690,32 +1710,17 @@ public BuildParameters BuildParameters
             /// <returns>The component</returns>
             public IBuildComponent GetComponent(BuildComponentType type)
             {
-                switch (type)
+                return type switch
                 {
-                    case BuildComponentType.ConfigCache:
-                        return (IBuildComponent)_configCache;
-
-                    case BuildComponentType.LoggingService:
-                        return (IBuildComponent)_loggingService;
-
-                    case BuildComponentType.ResultsCache:
-                        return (IBuildComponent)_resultsCache;
-
-                    case BuildComponentType.RequestBuilder:
-                        return (IBuildComponent)_requestBuilder;
-
-                    case BuildComponentType.TaskBuilder:
-                        return (IBuildComponent)_taskBuilder;
-
-                    case BuildComponentType.TargetBuilder:
-                        return (IBuildComponent)_targetBuilder;
-
-                    case BuildComponentType.SdkResolverService:
-                        return (IBuildComponent)_sdkResolverService;
-
-                    default:
-                        throw new ArgumentException("Unexpected type " + type);
-                }
+                    BuildComponentType.ConfigCache => (IBuildComponent)_configCache,
+                    BuildComponentType.LoggingService => (IBuildComponent)_loggingService,
+                    BuildComponentType.ResultsCache => (IBuildComponent)_resultsCache,
+                    BuildComponentType.RequestBuilder => (IBuildComponent)_requestBuilder,
+                    BuildComponentType.TaskBuilder => (IBuildComponent)_taskBuilder,
+                    BuildComponentType.TargetBuilder => (IBuildComponent)_targetBuilder,
+                    BuildComponentType.SdkResolverService => (IBuildComponent)_sdkResolverService,
+                    _ => throw new ArgumentException("Unexpected type " + type),
+                };
             }
 
             /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
index 7eedce9361e..54c1888e2dd 100644
--- a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
@@ -836,10 +836,7 @@ public void AfterTargetsShouldReportFailedBuild()
             // Since we're creating our own BuildManager, we need to make sure that the default 
             // one has properly relinquished the inproc node
             NodeProviderInProc nodeProviderInProc = ((IBuildComponentHost)BuildManager.DefaultBuildManager).GetComponent(BuildComponentType.InProcNodeProvider) as NodeProviderInProc;
-            if (nodeProviderInProc != null)
-            {
-                nodeProviderInProc.Dispose();
-            }
+            nodeProviderInProc?.Dispose();
 
             string content = @"
 <Project ToolsVersion='msbuilddefaulttoolsversion' DefaultTargets='Build' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
@@ -897,10 +894,7 @@ public void AfterTargetsShouldReportFailedBuild()
                 {
                     NodeProviderInProc inProcNodeProvider = ((IBuildComponentHost)manager).GetComponent(BuildComponentType.InProcNodeProvider) as NodeProviderInProc;
 
-                    if (inProcNodeProvider != null)
-                    {
-                        inProcNodeProvider.Dispose();
-                    }
+                    inProcNodeProvider?.Dispose();
                 }
             }
         }
@@ -1306,29 +1300,16 @@ public BuildParameters BuildParameters
             /// <returns>The component</returns>
             public IBuildComponent GetComponent(BuildComponentType type)
             {
-                switch (type)
+                return type switch
                 {
-                    case BuildComponentType.ConfigCache:
-                        return (IBuildComponent)_configCache;
-
-                    case BuildComponentType.LoggingService:
-                        return (IBuildComponent)_loggingService;
-
-                    case BuildComponentType.ResultsCache:
-                        return (IBuildComponent)_resultsCache;
-
-                    case BuildComponentType.RequestBuilder:
-                        return (IBuildComponent)_requestBuilder;
-
-                    case BuildComponentType.TaskBuilder:
-                        return (IBuildComponent)_taskBuilder;
-
-                    case BuildComponentType.SdkResolverService:
-                        return (IBuildComponent)_sdkResolverService;
-
-                    default:
-                        throw new ArgumentException("Unexpected type " + type);
-                }
+                    BuildComponentType.ConfigCache => (IBuildComponent)_configCache,
+                    BuildComponentType.LoggingService => (IBuildComponent)_loggingService,
+                    BuildComponentType.ResultsCache => (IBuildComponent)_resultsCache,
+                    BuildComponentType.RequestBuilder => (IBuildComponent)_requestBuilder,
+                    BuildComponentType.TaskBuilder => (IBuildComponent)_taskBuilder,
+                    BuildComponentType.SdkResolverService => (IBuildComponent)_sdkResolverService,
+                    _ => throw new ArgumentException("Unexpected type " + type),
+                };
             }
 
             /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
index 6a9e26fbc0e..34522d98c12 100644
--- a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
@@ -1003,8 +1003,8 @@ private void SimpleSymlinkInputCheck(DateTime symlinkWriteTime, DateTime targetW
 
                     long symlinkWriteTimeTicks = symlinkWriteTime.ToFileTimeUtc();
 
-                    if (SetFileTime(handle, ref symlinkWriteTimeTicks, ref symlinkWriteTimeTicks,
-                            ref symlinkWriteTimeTicks) != true)
+                    if (!SetFileTime(handle, ref symlinkWriteTimeTicks, ref symlinkWriteTimeTicks,
+                            ref symlinkWriteTimeTicks))
                     {
                         Marshal.ThrowExceptionForHR(Marshal.GetHRForLastWin32Error());
                     }
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index 99dbc5198e6..69cf99fe2bd 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -325,7 +325,7 @@ public void MSBuildLastTaskResult()
         }
 
         /// <summary>
-        /// Verifies that we can add "recursivedir" built-in metadata as target outputs. 
+        /// Verifies that we can add "recursivedir" built-in metadata as target outputs.
         /// This is to support wildcards in CreateItem. Allowing anything
         /// else could let the item get corrupt (inconsistent values for Filename and FullPath, for example)
         /// </summary>
@@ -408,7 +408,7 @@ public void OtherBuiltInMetadataErrors2()
         }
 
         /// <summary>
-        /// Verify that properties can be passed in to a task and out as items, despite the 
+        /// Verify that properties can be passed in to a task and out as items, despite the
         /// built-in metadata restrictions.
         /// </summary>
         [Fact]
@@ -468,7 +468,7 @@ public void IllegalFileCharsInItemsOutOfTask()
         }
 
         /// <summary>
-        /// If an item being output from a task has null metadata, we shouldn't crash. 
+        /// If an item being output from a task has null metadata, we shouldn't crash.
         /// </summary>
         [Fact]
         [Trait("Category", "mono-osx-failing")]
@@ -493,7 +493,7 @@ public void NullMetadataOnOutputItems()
         }
 
         /// <summary>
-        /// If an item being output from a task has null metadata, we shouldn't crash. 
+        /// If an item being output from a task has null metadata, we shouldn't crash.
         /// </summary>
         [Fact]
         [Trait("Category", "mono-osx-failing")]
@@ -551,7 +551,7 @@ public void SameAssemblyFromDifferentRelativePathsSharesAssemblyLoadContext()
 
 #if FEATURE_CODETASKFACTORY
         /// <summary>
-        /// If an item being output from a task has null metadata, we shouldn't crash. 
+        /// If an item being output from a task has null metadata, we shouldn't crash.
         /// </summary>
         [Fact]
         public void NullMetadataOnOutputItems_InlineTask()
@@ -591,7 +591,7 @@ public void NullMetadataOnOutputItems_InlineTask()
         }
 
         /// <summary>
-        /// If an item being output from a task has null metadata, we shouldn't crash. 
+        /// If an item being output from a task has null metadata, we shouldn't crash.
         /// </summary>
         [Fact]
         [Trait("Category", "non-mono-tests")]
@@ -633,9 +633,9 @@ public void NullMetadataOnLegacyOutputItems_InlineTask()
 #endif
 
         /// <summary>
-        /// Validates that the defining project metadata is set (or not set) as expected in 
-        /// various task output-related operations, using a task built against the current 
-        /// version of MSBuild.  
+        /// Validates that the defining project metadata is set (or not set) as expected in
+        /// various task output-related operations, using a task built against the current
+        /// version of MSBuild.
         /// </summary>
         [Fact]
         public void ValidateDefiningProjectMetadataOnTaskOutputs()
@@ -645,9 +645,9 @@ public void ValidateDefiningProjectMetadataOnTaskOutputs()
         }
 
         /// <summary>
-        /// Validates that the defining project metadata is set (or not set) as expected in 
-        /// various task output-related operations, using a task built against V4 MSBuild, 
-        /// which didn't support the defining project metadata.  
+        /// Validates that the defining project metadata is set (or not set) as expected in
+        /// various task output-related operations, using a task built against V4 MSBuild,
+        /// which didn't support the defining project metadata.
         /// </summary>
         [Fact]
         [Trait("Category", "mono-osx-failing")]
@@ -786,7 +786,7 @@ Task IRequestBuilderCallback.BlockOnTargetInProgress(int blockingRequestId, stri
  *********************************************************************************/
 
         /// <summary>
-        /// Helper method for validating the setting of defining project metadata on items 
+        /// Helper method for validating the setting of defining project metadata on items
         /// coming from task outputs
         /// </summary>
         private void ValidateDefiningProjectMetadataOnTaskOutputsHelper(string customTaskPath)
@@ -859,7 +859,7 @@ private void TestSTATask(bool requireSTA, bool failTask, bool throwException)
             MockLogger logger = new MockLogger();
             logger.AllowTaskCrashes = throwException;
 
-            string taskAssemblyName = null;
+            string taskAssemblyName;
             Project project = CreateSTATestProject(requireSTA, failTask, throwException, out taskAssemblyName);
 
             List<ILogger> loggers = new List<ILogger>();
@@ -1116,7 +1116,7 @@ private class MockHost : MockLoggingService, IBuildComponentHost, IBuildComponen
 
             /// <summary>
             /// Constructor
-            /// 
+            ///
             /// UNDONE: Refactor this, and the other MockHosts, to use a common base implementation.  The duplication of the
             /// logging implementation alone is unfortunate.
             /// </summary>
@@ -1194,29 +1194,16 @@ LegacyThreadingData IBuildComponentHost.LegacyThreadingData
             /// <returns>The component</returns>
             public IBuildComponent GetComponent(BuildComponentType type)
             {
-                switch (type)
+                return type switch
                 {
-                    case BuildComponentType.ConfigCache:
-                        return (IBuildComponent)_configCache;
-
-                    case BuildComponentType.LoggingService:
-                        return (IBuildComponent)_loggingService;
-
-                    case BuildComponentType.ResultsCache:
-                        return (IBuildComponent)_resultsCache;
-
-                    case BuildComponentType.RequestBuilder:
-                        return (IBuildComponent)_requestBuilder;
-
-                    case BuildComponentType.TargetBuilder:
-                        return (IBuildComponent)_targetBuilder;
-
-                    case BuildComponentType.SdkResolverService:
-                        return (IBuildComponent)_sdkResolverService;
-
-                    default:
-                        throw new ArgumentException("Unexpected type " + type);
-                }
+                    BuildComponentType.ConfigCache => (IBuildComponent)_configCache,
+                    BuildComponentType.LoggingService => (IBuildComponent)_loggingService,
+                    BuildComponentType.ResultsCache => (IBuildComponent)_resultsCache,
+                    BuildComponentType.RequestBuilder => (IBuildComponent)_requestBuilder,
+                    BuildComponentType.TargetBuilder => (IBuildComponent)_targetBuilder,
+                    BuildComponentType.SdkResolverService => (IBuildComponent)_sdkResolverService,
+                    _ => throw new ArgumentException("Unexpected type " + type),
+                };
             }
 
             /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
index e997a7cdea5..8660f8d86fc 100644
--- a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
@@ -1132,12 +1132,12 @@ public bool BuildProjectFile(string projectFileName, string[] targetNames, IDict
         /// </summary>
         private static bool IsTaskFactoryClass(Type type, object unused)
         {
-            return (type.GetTypeInfo().IsClass &&
+            return type.GetTypeInfo().IsClass &&
                 !type.GetTypeInfo().IsAbstract &&
 #if FEATURE_TYPE_GETINTERFACE
-                (type.GetInterface("Microsoft.Build.Framework.ITaskFactory") != null));
+                (type.GetInterface("Microsoft.Build.Framework.ITaskFactory") != null);
 #else
-                type.GetInterfaces().Any(interfaceType => interfaceType.FullName == "Microsoft.Build.Framework.ITaskFactory"));
+                type.GetInterfaces().Any(interfaceType => interfaceType.FullName == "Microsoft.Build.Framework.ITaskFactory");
 #endif
         }
 
diff --git a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
index 3b383fe1a3f..5183dfd69b1 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
@@ -49,6 +49,5 @@ public void TaskNodesDieAfterBuild()
                 }
             }
         }
-
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/TaskHostTaskCancelled_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostTaskCancelled_Tests.cs
index bcc19f07353..39dc2e3ceb2 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostTaskCancelled_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostTaskCancelled_Tests.cs
@@ -8,6 +8,7 @@
 
 using Microsoft.Build.BackEnd;
 using Xunit;
+using Shouldly;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
@@ -35,8 +36,7 @@ public void TestTranslation()
 
             ((ITranslatable)cancelled).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostTaskCancelled.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
-
-            TaskHostTaskCancelled deserializedCancelled = packet as TaskHostTaskCancelled;
+            packet.ShouldBeOfType<TaskHostTaskCancelled>();
         }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
index ff501e2f2b8..058e83a79dd 100644
--- a/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
@@ -1134,11 +1134,11 @@ public string Parameters
             /// </summary>
             public void Initialize(IEventSource eventSource)
             {
-                eventSource.ErrorRaised += new BuildErrorEventHandler(MyCustomErrorHandler);
-                eventSource.WarningRaised += new BuildWarningEventHandler(MyCustomWarningHandler);
-                eventSource.MessageRaised += new BuildMessageEventHandler(MyCustomMessageHandler);
-                eventSource.CustomEventRaised += new CustomBuildEventHandler(MyCustomBuildHandler);
-                eventSource.AnyEventRaised += new AnyEventHandler(EventSource_AnyEventRaised);
+                eventSource.ErrorRaised += MyCustomErrorHandler;
+                eventSource.WarningRaised += MyCustomWarningHandler;
+                eventSource.MessageRaised += MyCustomMessageHandler;
+                eventSource.CustomEventRaised += MyCustomBuildHandler;
+                eventSource.AnyEventRaised += EventSource_AnyEventRaised;
             }
 
             /// <summary>
@@ -1155,7 +1155,7 @@ internal void EventSource_AnyEventRaised(object sender, BuildEventArgs e)
             {
                 if (e.Message != null)
                 {
-                    Console.Out.WriteLine("AnyEvent:" + e.Message.ToString());
+                    Console.Out.WriteLine("AnyEvent:" + e.Message);
                 }
             }
 
@@ -1168,7 +1168,7 @@ internal void MyCustomErrorHandler(object s, BuildErrorEventArgs e)
                 _lastError = e;
                 if (e.Message != null)
                 {
-                    Console.Out.WriteLine("CustomError:" + e.Message.ToString());
+                    Console.Out.WriteLine("CustomError:" + e.Message);
                 }
             }
 
@@ -1181,7 +1181,7 @@ internal void MyCustomWarningHandler(object s, BuildWarningEventArgs e)
                 _lastWarning = e;
                 if (e.Message != null)
                 {
-                    Console.Out.WriteLine("CustomWarning:" + e.Message.ToString());
+                    Console.Out.WriteLine("CustomWarning:" + e.Message);
                 }
             }
 
@@ -1194,7 +1194,7 @@ internal void MyCustomMessageHandler(object s, BuildMessageEventArgs e)
                 _lastMessage = e;
                 if (e.Message != null)
                 {
-                    Console.Out.WriteLine("CustomMessage:" + e.Message.ToString());
+                    Console.Out.WriteLine("CustomMessage:" + e.Message);
                 }
             }
 
@@ -1207,7 +1207,7 @@ internal void MyCustomBuildHandler(object s, CustomBuildEventArgs e)
                 _lastCustom = e;
                 if (e.Message != null)
                 {
-                    Console.Out.WriteLine("CustomEvent:" + e.Message.ToString());
+                    Console.Out.WriteLine("CustomEvent:" + e.Message);
                 }
             }
         }
diff --git a/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs b/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
index ea5f9abdd9b..5373b76cf12 100644
--- a/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
@@ -2007,7 +2007,7 @@ private void RetrieveAndValidateRegisteredTaskRecord
                                                             string expectedArchitecture
                                                         )
         {
-            bool retrievedFromCache = false;
+            bool retrievedFromCache;
             var record = registry.GetTaskRegistrationRecord(TestTaskName, null, taskParameters, exactMatchRequired, _targetLoggingContext, _elementLocation, out retrievedFromCache);
 
             if (shouldBeRetrieved)
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 765ddad0dff..ca2de8f8f3b 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -73,7 +73,7 @@ public void RoundtripProjectStartedEventArgs()
             Roundtrip(args,
                 e => ToString(e.BuildEventContext),
                 e => ToString(e.GlobalProperties),
-                e => ToString(e.Items.OfType<DictionaryEntry>().ToDictionary(d => d.Key.ToString(), d => ((ITaskItem)d.Value).ItemSpec.ToString())),
+                e => ToString(e.Items.OfType<DictionaryEntry>().ToDictionary(d => d.Key.ToString(), d => ((ITaskItem)d.Value).ItemSpec)),
                 e => e.Message,
                 e => ToString(e.ParentProjectBuildEventContext),
                 e => e.ProjectFile,
diff --git a/src/Build.UnitTests/ConsoleLogger_Tests.cs b/src/Build.UnitTests/ConsoleLogger_Tests.cs
index 4a07b09e5d9..f043c989285 100644
--- a/src/Build.UnitTests/ConsoleLogger_Tests.cs
+++ b/src/Build.UnitTests/ConsoleLogger_Tests.cs
@@ -20,6 +20,7 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using Microsoft.Build.Execution;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -184,6 +185,134 @@ public void TestTargetAfterProjectStarted()
             sc.ToString().ShouldContain("XXX:");
         }
 
+        [Fact]
+        public void WarningMessage()
+        {
+            using var env = TestEnvironment.Create(_output);
+
+            var pc = env.CreateProjectCollection();
+
+            var project = env.CreateTestProjectWithFiles(@"
+         <Project>
+            <ItemGroup>
+                <P Include='$(MSBuildThisFileFullPath)' AdditionalProperties='Number=1' />
+                <P Include='$(MSBuildThisFileFullPath)' AdditionalProperties='Number=2' />
+
+                <ProjectConfigurationDescription Include='Number=$(Number)' />
+            </ItemGroup>
+            <Target Name='Spawn'>
+                <MSBuild Projects='@(P)' BuildInParallel='true' Targets='Inner' />
+            </Target>
+            <Target Name='Inner'>
+                <Warning Text='Hello from project $(Number)'
+                         File='source_of_warning' />
+            </Target>
+        </Project>");
+
+            SimulatedConsole sc = new SimulatedConsole();
+            ConsoleLogger logger = new ConsoleLogger(LoggerVerbosity.Minimal, sc.Write, null, null);
+            logger.Parameters = "EnableMPLogging;ShowProjectFile";
+
+            pc.Collection.RegisterLogger(logger);
+            var p = pc.Collection.LoadProject(project.ProjectFile);
+
+            BuildManager.DefaultBuildManager.Build(
+                new BuildParameters(pc.Collection),
+                new BuildRequestData(p.CreateProjectInstance(), new[] { "Spawn" }));
+
+            p.Build().ShouldBeTrue();
+            sc.ToString().ShouldContain("source_of_warning : warning : Hello from project 1 [" + project.ProjectFile + ":: Number=1]");
+            sc.ToString().ShouldContain("source_of_warning : warning : Hello from project 2 [" + project.ProjectFile + ":: Number=2]");
+        }
+
+        [Fact]
+        public void ErrorMessage()
+        {
+            using var env = TestEnvironment.Create(_output);
+
+            var pc = env.CreateProjectCollection();
+
+            var project = env.CreateTestProjectWithFiles(@"
+         <Project>
+            <ItemGroup>
+                <P Include='$(MSBuildThisFileFullPath)' AdditionalProperties='Number=1' />
+                <P Include='$(MSBuildThisFileFullPath)' AdditionalProperties='Number=2' />
+
+                <ProjectConfigurationDescription Include='Number=$(Number)' />
+            </ItemGroup>
+            <Target Name='Spawn'>
+                <MSBuild Projects='@(P)' BuildInParallel='true' Targets='Inner' />
+            </Target>
+            <Target Name='Inner'>
+                <Error Text='Hello from project $(Number)'
+                         File='source_of_error' />
+            </Target>
+        </Project>");
+
+            SimulatedConsole sc = new SimulatedConsole();
+            ConsoleLogger logger = new ConsoleLogger(LoggerVerbosity.Minimal, sc.Write, null, null);
+            logger.Parameters = "EnableMPLogging;ShowProjectFile";
+
+            pc.Collection.RegisterLogger(logger);
+
+
+            var p = pc.Collection.LoadProject(project.ProjectFile);
+
+            BuildManager.DefaultBuildManager.Build(
+                new BuildParameters(pc.Collection),
+                new BuildRequestData(p.CreateProjectInstance(), new[] { "Spawn" }));
+
+            p.Build().ShouldBeFalse();
+            sc.ToString().ShouldContain("source_of_error : error : Hello from project 1 [" + project.ProjectFile + ":: Number=1]");
+            sc.ToString().ShouldContain("source_of_error : error : Hello from project 2 [" + project.ProjectFile + ":: Number=2]");
+        }
+
+        [Fact]
+        public void ErrorMessageWithMultiplePropertiesInMessage()
+        {
+            using var env = TestEnvironment.Create(_output);
+
+            var pc = env.CreateProjectCollection();
+
+            var project = env.CreateTestProjectWithFiles(@"
+         <Project>
+            <PropertyGroup>
+            <TargetFramework>netcoreapp2.1</TargetFramework>
+            </PropertyGroup>
+            <ItemGroup>
+                <P Include='$(MSBuildThisFileFullPath)' AdditionalProperties='Number=1' />
+                <P Include='$(MSBuildThisFileFullPath)' AdditionalProperties='Number=2' />
+    
+                <ProjectConfigurationDescription Include='Number=$(Number)' />
+                <ProjectConfigurationDescription Include='TargetFramework=$(TargetFramework)' />
+            </ItemGroup>
+            <Target Name='Spawn'>
+                <MSBuild Projects='@(P)' BuildInParallel='true' Targets='Inner' />
+            </Target>
+            <Target Name='Inner'>
+                <Error Text='Hello from project $(Number)'
+                         File='source_of_error' />
+            </Target>
+        </Project>");
+
+            SimulatedConsole sc = new SimulatedConsole();
+            ConsoleLogger logger = new ConsoleLogger(LoggerVerbosity.Minimal, sc.Write, null, null);
+            logger.Parameters = "EnableMPLogging;ShowProjectFile";
+
+            pc.Collection.RegisterLogger(logger);
+
+
+            var p = pc.Collection.LoadProject(project.ProjectFile);
+
+            BuildManager.DefaultBuildManager.Build(
+                new BuildParameters(pc.Collection),
+                new BuildRequestData(p.CreateProjectInstance(), new[] { "Spawn" }));
+
+            p.Build().ShouldBeFalse();
+            sc.ToString().ShouldContain("source_of_error : error : Hello from project 1 [" + project.ProjectFile + ":: Number=1 TargetFramework=netcoreapp2.1]");
+            sc.ToString().ShouldContain("source_of_error : error : Hello from project 2 [" + project.ProjectFile + ":: Number=2 TargetFramework=netcoreapp2.1]");
+        }
+
         [Fact]
         [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "Minimal path validation in Core allows expanding path containing quoted slashes.")]
         [SkipOnTargetFramework(TargetFrameworkMonikers.Mono, "Minimal path validation in Mono allows expanding path containing quoted slashes.")]
@@ -205,7 +334,6 @@ public void TestItemsWithUnexpandableMetadata()
 </Project>", logger);
 
             sc.ToString().ShouldContain("\"a\\b\\%(Filename).c\"");
-
         }
 
         /// <summary>
@@ -1294,10 +1422,9 @@ private void WriteAndValidateProperties(BaseConsoleLogger cl, SimulatedConsole s
             properties.Add("prop1", "val1");
             properties.Add("prop2", "val2");
             properties.Add("pro(p3)", "va%3b%253b%3bl3");
-            string prop1 = string.Empty;
-            string prop2 = string.Empty;
-            string prop3 = string.Empty;
-
+            string prop1;
+            string prop2;
+            string prop3;
             if (cl is SerialConsoleLogger)
             {
                 var propertyList = ((SerialConsoleLogger)cl).ExtractPropertyList(properties);
@@ -1496,7 +1623,7 @@ private void WriteEnvironment(BaseConsoleLogger cl, SimulatedConsole sc, bool ex
             // Being careful not to make locale assumptions here, eg about sorting
             foreach (KeyValuePair<string, string> kvp in _environment)
             {
-                string message = String.Empty;
+                string message;
                 if (cl is ParallelConsoleLogger)
                 {
                     message = String.Format(CultureInfo.CurrentCulture, "{0} = {1}", kvp.Key, kvp.Value);
@@ -1537,12 +1664,12 @@ private void WriteAndValidateItems(BaseConsoleLogger cl, SimulatedConsole sc, bo
 
             items.Add("type(3)", taskItem3);
 
-            string item1type = string.Empty;
-            string item2type = string.Empty;
-            string item3type = string.Empty;
-            string item1spec = string.Empty;
-            string item2spec = string.Empty;
-            string item3spec = string.Empty;
+            string item1type;
+            string item2type;
+            string item3type;
+            string item1spec;
+            string item2spec;
+            string item3spec;
             string item3metadatum = string.Empty;
 
             if (cl is SerialConsoleLogger)
diff --git a/src/Build.UnitTests/Construction/ElementLocation_Tests.cs b/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
index dd48d7391e5..505ba979d77 100644
--- a/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
+++ b/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
@@ -493,9 +493,7 @@ private string GetLocations(string content, bool readOnly)
                     }
                 }
 
-                locations = locations.Replace(file, "c:\\foo\\bar.csproj");
-
-                return locations;
+                return locations.Replace(file, "c:\\foo\\bar.csproj");
             }
             finally
             {
diff --git a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
index e9dc6951439..888c728e8b5 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
@@ -699,9 +699,9 @@ public void MalformedEtpProjFile()
                    "someproj.etp", String.Empty);
                 foreach (string warningString in solution.SolutionParserWarnings)
                 {
-                    Console.WriteLine(warningString.ToString());
+                    Console.WriteLine(warningString);
                 }
-                Assert.Contains(errCode, solution.SolutionParserErrorCodes[0].ToString());
+                Assert.Contains(errCode, solution.SolutionParserErrorCodes[0]);
             }
             // Delete the files created during the test
             finally
@@ -732,7 +732,7 @@ public void MissingEtpProjFile()
             string errCode, ignoredKeyword;
             ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out errCode, out ignoredKeyword, "Shared.ProjectFileCouldNotBeLoaded",
                   "someproj.etp", String.Empty);
-            Assert.Contains(errCode, solution.SolutionParserErrorCodes[0].ToString());
+            Assert.Contains(errCode, solution.SolutionParserErrorCodes[0]);
         }
 
         /// <summary>
@@ -1971,5 +1971,337 @@ public void ParseProjectConfigurationsInSolutionConfigurations2()
             Assert.Equal("Debug", solution.GetDefaultConfigurationName()); // "Default solution configuration"
             Assert.Equal(".NET", solution.GetDefaultPlatformName()); // "Default solution platform"
         }
+
+        [Fact]
+        public void ParseSolutionFileContainingProjectsWithParentSlnFolder()
+        {
+            string solutionFileContents = @"
+                Microsoft Visual Studio Solution File, Format Version 9.00
+                # Visual Studio 2005
+                Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'MySlnFolder', 'MySlnFolder', '{E0F97730-25D2-418A-A7BD-02CAFDC6E470}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project.Named.With.Dots', 'MyPhysicalFolder\Folder1\Project.Named.With.Dots.csproj', '{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With_Dots', 'MyPhysicalFolder\Folder2\Project_Named_With_Dots.csproj', '{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}'
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Any CPU = Debug|Any CPU
+                        Release|Any CPU = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		        {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		        {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.Build.0 = Release|Any CPU
+		        {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		        {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.Build.0 = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                    GlobalSection(NestedProjects) = preSolution
+                        {FC2889D9-6050-4D2E-B022-979CCFEEAAAC} = {E0F97730-25D2-418A-A7BD-02CAFDC6E470}
+                        {ED30D4A3-1214-410B-82BB-B61E5A9D05CA} = {E0F97730-25D2-418A-A7BD-02CAFDC6E470}
+                    EndGlobalSection
+                EndGlobal
+                ";
+
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+
+            ProjectInSolution project1 = (ProjectInSolution)solution.ProjectsByGuid["{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}"];
+            ProjectInSolution project2 = (ProjectInSolution)solution.ProjectsByGuid["{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}"];
+
+            project2.GetUniqueProjectName().ShouldNotBe(project1.GetUniqueProjectName());
+            project1.GetUniqueProjectName().ShouldBe(@"MySlnFolder\Project_Named_With_Dots");
+            project2.GetUniqueProjectName().ShouldBe(@"MySlnFolder\Project_Named_With_Dots_ED30D4A3-1214-410B-82BB-B61E5A9D05CA");
+            project1.GetOriginalProjectName().ShouldBe(@"MySlnFolder\Project.Named.With.Dots");
+            project2.GetOriginalProjectName().ShouldBe(@"MySlnFolder\Project_Named_With_Dots");
+        }
+
+        [Theory]
+        [InlineData(@"
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                # Visual Studio 15
+                VisualStudioVersion = 15.0.27130.2010
+                MinimumVisualStudioVersion = 10.0.40219.1
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project.Named.With.Dots', 'Project.Named.With.Dots.csproj', '{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With_Dots', 'Project_Named_With_Dots.csproj', '{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}'
+                EndProject
+                Global
+	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		                Release|Any CPU = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.Build.0 = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(SolutionProperties) = preSolution
+		                HideSolutionNode = FALSE
+	                EndGlobalSection
+	                GlobalSection(ExtensibilityGlobals) = postSolution
+		                SolutionGuid = {C038ED6B-BFC1-4E50-AE2E-7993F6883D7F}
+	                EndGlobalSection
+                EndGlobal
+                ")]
+        [InlineData(@"
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                # Visual Studio 15
+                VisualStudioVersion = 15.0.27130.2010
+                MinimumVisualStudioVersion = 10.0.40219.1
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With_Dots', 'Project_Named_With_Dots.csproj', '{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project.Named.With.Dots', 'Project.Named.With.Dots.csproj', '{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}'
+                EndProject
+                Global
+	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		                Release|Any CPU = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.Build.0 = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(SolutionProperties) = preSolution
+		                HideSolutionNode = FALSE
+	                EndGlobalSection
+	                GlobalSection(ExtensibilityGlobals) = postSolution
+		                SolutionGuid = {C038ED6B-BFC1-4E50-AE2E-7993F6883D7F}
+	                EndGlobalSection
+                EndGlobal
+                ")]
+        public void ParseSolutionFileContainingProjectsWithSimilarNames_TwoProjects(string solutionFileContents)
+        {
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+
+            ProjectInSolution project1 = (ProjectInSolution)solution.ProjectsByGuid["{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}"];
+            ProjectInSolution project2 = (ProjectInSolution)solution.ProjectsByGuid["{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}"];
+
+            project2.GetUniqueProjectName().ShouldNotBe(project1.GetUniqueProjectName());
+            project1.GetUniqueProjectName().ShouldBe("Project_Named_With_Dots_FC2889D9-6050-4D2E-B022-979CCFEEAAAC");
+            project2.GetUniqueProjectName().ShouldBe("Project_Named_With_Dots");
+            project1.GetOriginalProjectName().ShouldBe("Project.Named.With.Dots");
+            project2.GetOriginalProjectName().ShouldBe("Project_Named_With_Dots");
+        }
+
+        [Theory]
+        [InlineData(@"
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                # Visual Studio 15
+                VisualStudioVersion = 15.0.27130.2010
+                MinimumVisualStudioVersion = 10.0.40219.1
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With_Dots', 'Project_Named_With_Dots.csproj', '{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With.Dots', 'Project_Named_With.Dots.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project.Named.With.Dots', 'Project.Named.With.Dots.csproj', '{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}'
+                EndProject
+                Global
+	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		                Release|Any CPU = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.Build.0 = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(SolutionProperties) = preSolution
+		                HideSolutionNode = FALSE
+	                EndGlobalSection
+	                GlobalSection(ExtensibilityGlobals) = postSolution
+		                SolutionGuid = {C038ED6B-BFC1-4E50-AE2E-7993F6883D7F}
+	                EndGlobalSection
+                EndGlobal
+                ")]
+        [InlineData(@"
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                # Visual Studio 15
+                VisualStudioVersion = 15.0.27130.2010
+                MinimumVisualStudioVersion = 10.0.40219.1
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project.Named.With.Dots', 'Project.Named.With.Dots.csproj', '{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With_Dots', 'Project_Named_With_Dots.csproj', '{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With.Dots', 'Project_Named_With.Dots.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
+                EndProject
+                Global
+	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		                Release|Any CPU = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(SolutionProperties) = preSolution
+		                HideSolutionNode = FALSE
+	                EndGlobalSection
+	                GlobalSection(ExtensibilityGlobals) = postSolution
+		                SolutionGuid = {C038ED6B-BFC1-4E50-AE2E-7993F6883D7F}
+	                EndGlobalSection
+                EndGlobal
+                ")]
+        public void ParseSolutionFileContainingProjectsWithSimilarNames_ThreeProjects(string solutionFileContents)
+        {
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+
+            ProjectInSolution project1 = (ProjectInSolution)solution.ProjectsByGuid["{6185CC21-BE89-448A-B3C0-D1C27112E595}"];
+            ProjectInSolution project2 = (ProjectInSolution)solution.ProjectsByGuid["{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}"];
+            ProjectInSolution project3 = (ProjectInSolution)solution.ProjectsByGuid["{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}"];
+
+            project2.GetUniqueProjectName().ShouldNotBe(project1.GetUniqueProjectName());
+            project3.GetUniqueProjectName().ShouldNotBe(project2.GetUniqueProjectName());
+            project3.GetUniqueProjectName().ShouldNotBe(project1.GetUniqueProjectName());
+
+            project1.GetUniqueProjectName().ShouldBe("Project_Named_With_Dots_6185CC21-BE89-448A-B3C0-D1C27112E595");
+            project2.GetUniqueProjectName().ShouldBe("Project_Named_With_Dots_FC2889D9-6050-4D2E-B022-979CCFEEAAAC");
+            project3.GetUniqueProjectName().ShouldBe("Project_Named_With_Dots");
+
+            project1.GetOriginalProjectName().ShouldBe("Project_Named_With.Dots");
+            project2.GetOriginalProjectName().ShouldBe("Project.Named.With.Dots");
+            project3.GetOriginalProjectName().ShouldBe("Project_Named_With_Dots");
+        }
+
+        [Fact]
+        public void ParseSolutionFileContainingProjectsWithSimilarNames_ThreeProjects_OneNormalizedDuplicated()
+        {
+            string solutionFileContents =
+                @"
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                # Visual Studio 15
+                VisualStudioVersion = 15.0.27130.2010
+                MinimumVisualStudioVersion = 10.0.40219.1
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project.Named.With.Dots', 'Project.Named.With.Dots.csproj', '{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With_Dots', 'Project_Named_With_Dots.csproj', '{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project.Named.With.Dots', 'Project.Named.With.Dots.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
+                EndProject
+                Global
+	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		                Release|Any CPU = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(SolutionProperties) = preSolution
+		                HideSolutionNode = FALSE
+	                EndGlobalSection
+	                GlobalSection(ExtensibilityGlobals) = postSolution
+		                SolutionGuid = {C038ED6B-BFC1-4E50-AE2E-7993F6883D7F}
+	                EndGlobalSection
+                EndGlobal
+                ";
+
+            Action parseSolution = () => ParseSolutionHelper(solutionFileContents);
+            var exception = Assert.Throws<InvalidProjectFileException>(parseSolution);
+
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, "SolutionParseDuplicateProject", "Project.Named.With.Dots");
+
+            exception.Message.ShouldStartWith(message);
+        }
+
+        [Fact]
+        public void ParseSolutionFileContainingProjectsWithSimilarNames_ThreeProjects_OneDuplicated()
+        {
+            string solutionFileContents =
+                @"
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                # Visual Studio 15
+                VisualStudioVersion = 15.0.27130.2010
+                MinimumVisualStudioVersion = 10.0.40219.1
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project.Named.With.Dots', 'Project.Named.With.Dots.csproj', '{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With_Dots', 'Project_Named_With_Dots.csproj', '{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With_Dots', 'Project_Named_With_Dots.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
+                EndProject
+                Global
+	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		                Release|Any CPU = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(SolutionProperties) = preSolution
+		                HideSolutionNode = FALSE
+	                EndGlobalSection
+	                GlobalSection(ExtensibilityGlobals) = postSolution
+		                SolutionGuid = {C038ED6B-BFC1-4E50-AE2E-7993F6883D7F}
+	                EndGlobalSection
+                EndGlobal
+                ";
+
+            Action parseSolution = () => ParseSolutionHelper(solutionFileContents);
+            var exception = Assert.Throws<InvalidProjectFileException>(parseSolution);
+
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, "SolutionParseDuplicateProject", "Project_Named_With_Dots");
+
+            exception.Message.ShouldStartWith(message);
+        }
+
+        [Fact]
+        public void ParseSolutionFileContainingProjectsWithSimilarNames_FourProjects_OneDuplicated()
+        {
+            string solutionFileContents =
+                @"
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                # Visual Studio 15
+                VisualStudioVersion = 15.0.27130.2010
+                MinimumVisualStudioVersion = 10.0.40219.1
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project.Named.With.Dots', 'Project.Named.With.Dots.csproj', '{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With_Dots', 'Project_Named_With_Dots.csproj', '{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With.Dots', 'Project_Named_With.Dots.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With_Dots', 'Project_Named_With_Dots.csproj', '{AD0F3D02-9925-4D57-9DAF-E0A9D936ABDB}'
+                EndProject
+                Global
+	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		                Release|Any CPU = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(SolutionProperties) = preSolution
+		                HideSolutionNode = FALSE
+	                EndGlobalSection
+	                GlobalSection(ExtensibilityGlobals) = postSolution
+		                SolutionGuid = {C038ED6B-BFC1-4E50-AE2E-7993F6883D7F}
+	                EndGlobalSection
+                EndGlobal
+                ";
+
+            Action parseSolution = () => ParseSolutionHelper(solutionFileContents);
+            var exception = Assert.Throws<InvalidProjectFileException>(parseSolution);
+
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, "SolutionParseDuplicateProject", "Project_Named_With_Dots");
+
+            exception.Message.ShouldStartWith(message);
+        }
     }
 }
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index c6f15a9b190..6444f966f98 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -203,9 +203,8 @@ public void AddNewErrorWarningMessageElement()
             Project project = new Project(projectXml);
 
             project.Build(logger);
-
-            string code = null;
-            string keyword = null;
+            string code;
+            string keyword;
             string text = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out code, out keyword, "SolutionParseUnknownProjectType", "proj1.csproj");
 
             // check the error event
@@ -215,9 +214,6 @@ public void AddNewErrorWarningMessageElement()
             Assert.Equal(text, warning.Message);
             Assert.Equal(code, warning.Code);
             Assert.Equal(keyword, warning.HelpKeyword);
-
-            code = null;
-            keyword = null;
             text = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out code, out keyword, "SolutionInvalidSolutionConfiguration");
 
             // check the warning event
@@ -227,9 +223,6 @@ public void AddNewErrorWarningMessageElement()
             Assert.Equal(text, error.Message);
             Assert.Equal(code, error.Code);
             Assert.Equal(keyword, error.HelpKeyword);
-
-            code = null;
-            keyword = null;
             text = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out code, out keyword, "SolutionVenusProjectNoClean");
 
             // check the message event
@@ -417,7 +410,6 @@ public void SolutionBasedSubToolsetVersionOverriddenByEnvironment()
             Assert.Equal("ABC", instances[0].GetPropertyValue("VisualStudioVersion"));
         }
 
-
         /// <summary>
         /// Test to make sure that even if the solution version corresponds to an existing sub-toolset version
         /// </summary>
@@ -501,7 +493,6 @@ public void SolutionPassesSubToolsetToChildProjects2()
                     EndGlobal
                 ";
 
-
             string solutionFileContentsDev11 = solutionFilePreambleV11 + solutionBodySingleProjectContents;
             string solutionFileContentsDev12 = solutionFilePreambleV12 + solutionBodySingleProjectContents;
 
@@ -620,7 +611,6 @@ public void SolutionDoesntPassSubToolsetToChildProjects()
                 List<ILogger> loggers = new List<ILogger>(1);
                 loggers.Add(logger);
 
-
                 instances[0].Build(loggers);
                 logger.AssertLogContains(String.Format(".[{0}].", ObjectModelHelpers.MSBuildDefaultToolsVersion));
             }
@@ -630,7 +620,6 @@ public void SolutionDoesntPassSubToolsetToChildProjects()
             }
         }
 
-
         /// <summary>
         /// Verify that we throw the appropriate error if the solution declares a dependency 
         /// on a project that doesn't exist.
@@ -1156,8 +1145,6 @@ public void Regress751742_SkipNonexistentProjects()
             }
         }
 
-
-
         /// <summary>
         /// Test that the in memory project created from a solution file exposes an MSBuild property which,
         /// if set when building a solution, will be specified as the ToolsVersion on the MSBuild task when
@@ -1206,7 +1193,7 @@ public void ToolsVersionOverrideShouldBeSpecifiedOnMSBuildTaskInvocations()
                 {
                     foreach (ProjectTaskInstance childNode in target.Tasks)
                     {
-                        if (0 == String.Compare(childNode.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                        if (String.Equals(childNode.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
                         {
                             string projectsParameter = childNode.GetParameter("Projects");
                             if (projectsParameter != "@(ProjectReference)")
@@ -1323,8 +1310,6 @@ public void ToolsVersionOverrideCausesToolsetRedirect()
                     EndGlobalSection
                 EndGlobal
                 ";
-
-            ProjectInstance[] instances = null;
             SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
             bool caughtException = false;
 
@@ -1332,7 +1317,7 @@ public void ToolsVersionOverrideCausesToolsetRedirect()
             {
                 // SolutionProjectGenerator.Generate() is used at build-time, and creates evaluation- and 
                 // execution-model projects; as such it will throw if fed an explicitly invalid toolsversion
-                instances = SolutionProjectGenerator.Generate(solution, null, "invalid", _buildEventContext, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, "invalid", _buildEventContext, CreateMockLoggingService());
             }
             catch (InvalidProjectFileException)
             {
@@ -1375,56 +1360,56 @@ public void TestDisambiguateProjectTargetName()
 
             ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
 
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase) == 0));
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase) == 0));
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase) == 0));
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase) == 0));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase)));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase)));
 
-            ProjectTargetInstance buildTarget = instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase) == 0).First().Value;
-            ProjectTargetInstance cleanTarget = instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase) == 0).First().Value;
-            ProjectTargetInstance rebuildTarget = instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase) == 0).First().Value;
-            ProjectTargetInstance publishTarget = instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase) == 0).First().Value;
+            ProjectTargetInstance buildTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)).First().Value;
+            ProjectTargetInstance cleanTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase)).First().Value;
+            ProjectTargetInstance rebuildTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)).First().Value;
+            ProjectTargetInstance publishTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase)).First().Value;
 
             // Check that the appropriate target is being passed to the child projects
             Assert.Null(buildTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Targets"));
 
             Assert.Equal("Clean", cleanTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Targets"));
 
             Assert.Equal("Rebuild", rebuildTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Targets"));
 
             Assert.Equal("Publish", publishTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Targets"));
 
             // Check that the child projects in question are the members of the "ProjectReference" item group
             Assert.Equal("@(ProjectReference)", buildTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Projects"));
 
             Assert.Equal("@(ProjectReference->Reverse())", cleanTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Projects"));
 
             Assert.Equal("@(ProjectReference)", rebuildTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Projects"));
 
             Assert.Equal("@(ProjectReference)", publishTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Projects"));
 
             // We should have only the four standard targets plus the two validation targets (ValidateSolutionConfiguration and ValidateToolsVersions).
@@ -1707,7 +1692,6 @@ public void TestPredictSolutionConfigurationName()
             Assert.Null(SolutionProjectGenerator.PredictActiveSolutionConfigurationName(solution, globalProperties));
         }
 
-
         /// <summary>
         /// Verifies that the SolutionProjectGenerator will correctly escape project file paths
         /// </summary>
@@ -1737,9 +1721,7 @@ public void SolutionGeneratorEscapingProjectFilePaths()
                 EndGlobal
                 ";
 
-            SolutionFile solution = null;
-
-            solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
 
             // Creating a ProjectRootElement shouldn't affect the ProjectCollection at all
             Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
@@ -1958,10 +1940,7 @@ public void BadFrameworkMonkierExpectBuildToFail()
                 // Since we're creating our own BuildManager, we need to make sure that the default 
                 // one has properly relinquished the inproc node
                 NodeProviderInProc nodeProviderInProc = ((IBuildComponentHost)BuildManager.DefaultBuildManager).GetComponent(BuildComponentType.InProcNodeProvider) as NodeProviderInProc;
-                if (nodeProviderInProc != null)
-                {
-                    nodeProviderInProc.Dispose();
-                }
+                nodeProviderInProc?.Dispose();
 
                 File.WriteAllText(projectFilePath, solutionFileContents.Replace('\'', '"'));
                 MockLogger logger = new MockLogger(output);
@@ -1972,7 +1951,6 @@ public void BadFrameworkMonkierExpectBuildToFail()
                 parameters.ShutdownInProcNodeOnBuildFinish = true;
                 buildManager = new BuildManager();
 
-
                 Dictionary<string, string> globalProperties = new Dictionary<string, string>();
                 globalProperties["Configuration"] = "Release";
 
@@ -2050,10 +2028,7 @@ public void BadFrameworkMonkierExpectBuildToFail2()
                 // Since we're creating our own BuildManager, we need to make sure that the default 
                 // one has properly relinquished the inproc node
                 NodeProviderInProc nodeProviderInProc = ((IBuildComponentHost)BuildManager.DefaultBuildManager).GetComponent(BuildComponentType.InProcNodeProvider) as NodeProviderInProc;
-                if (nodeProviderInProc != null)
-                {
-                    nodeProviderInProc.Dispose();
-                }
+                nodeProviderInProc?.Dispose();
 
                 File.WriteAllText(projectFilePath, solutionFileContents.Replace('\'', '"'));
                 MockLogger logger = new MockLogger(output);
@@ -2064,7 +2039,6 @@ public void BadFrameworkMonkierExpectBuildToFail2()
                 parameters.ShutdownInProcNodeOnBuildFinish = true;
                 buildManager = new BuildManager();
 
-
                 Dictionary<string, string> globalProperties = new Dictionary<string, string>();
                 globalProperties["Configuration"] = "Release";
 
@@ -2194,26 +2168,26 @@ public void CustomTargetNamesAreInInMetaproj()
 
             ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "One" });
 
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "One", StringComparison.OrdinalIgnoreCase) == 0));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "One", StringComparison.OrdinalIgnoreCase)));
 
             instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Two", "Three", "Four" });
 
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Two", StringComparison.OrdinalIgnoreCase) == 0));
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Three", StringComparison.OrdinalIgnoreCase) == 0));
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Four", StringComparison.OrdinalIgnoreCase) == 0));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Two", StringComparison.OrdinalIgnoreCase)));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Three", StringComparison.OrdinalIgnoreCase)));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Four", StringComparison.OrdinalIgnoreCase)));
 
             instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Build" });
 
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase) == 0));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)));
 
             instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Five", "Rebuild" });
 
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Five", StringComparison.OrdinalIgnoreCase) == 0));
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase) == 0));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Five", StringComparison.OrdinalIgnoreCase)));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)));
 
             instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "My_Project:Six" });
 
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Six", StringComparison.OrdinalIgnoreCase) == 0));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Six", StringComparison.OrdinalIgnoreCase)));
         }
 
         /// <summary>
@@ -2282,7 +2256,6 @@ public void IllegalUserTargetNamesDoNotThrow(bool forceCaseDifference)
                 Assert.Equal(12, instances[0].TargetsCount);
             }
 
-
             instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, CreateMockLoggingService(), new[] { "Foo" });
 
             Assert.Single(instances);
diff --git a/src/Build.UnitTests/Definition/ItemDefinitionGroup_Tests.cs b/src/Build.UnitTests/Definition/ItemDefinitionGroup_Tests.cs
index 11f9aeb37d4..f8632d98b9e 100644
--- a/src/Build.UnitTests/Definition/ItemDefinitionGroup_Tests.cs
+++ b/src/Build.UnitTests/Definition/ItemDefinitionGroup_Tests.cs
@@ -587,13 +587,12 @@ public void ItemDefinitionMetadataCopiedToTaskItem()
             Assert.True(p.ItemDefinitions.ContainsKey("ItemA"));
 
             ProjectInstance pi = p.CreateProjectInstance();
-            ITaskItem noMetaItem = null;
             ITaskItem withMetaItem;
 
             List<ProjectItemDefinitionInstance> itemdefs = new List<ProjectItemDefinitionInstance>();
             itemdefs.Add(pi.ItemDefinitions["ItemA"]);
 
-            noMetaItem = new TaskItem("NoMetaItem", pi.FullPath);
+            ITaskItem noMetaItem = new TaskItem("NoMetaItem", pi.FullPath);
             withMetaItem = new TaskItem("WithMetaItem", "WithMetaItem", null, itemdefs, ".", false, pi.FullPath);
 
             // Copy the metadata on the item with no metadata onto the item with metadata
@@ -623,13 +622,12 @@ public void ItemDefinitionMetadataCopiedToTaskItem2()
             Assert.True(p.ItemDefinitions.ContainsKey("ItemA"));
 
             ProjectInstance pi = p.CreateProjectInstance();
-            ITaskItem noMetaItem = null;
             ITaskItem withMetaItem;
 
             List<ProjectItemDefinitionInstance> itemdefs = new List<ProjectItemDefinitionInstance>();
             itemdefs.Add(pi.ItemDefinitions["ItemA"]);
 
-            noMetaItem = new TaskItem("NoMetaItem", pi.FullPath);
+            ITaskItem noMetaItem = new TaskItem("NoMetaItem", pi.FullPath);
             noMetaItem.SetMetadata("MetaA", "NEWMETA_A");
 
             withMetaItem = new TaskItem("WithMetaItem", "WithMetaItem", null, itemdefs, ".", false, pi.FullPath);
@@ -665,13 +663,12 @@ public void ItemDefinitionMetadataCopiedToTaskItem3()
             Assert.True(p.ItemDefinitions.ContainsKey("ItemA"));
 
             ProjectInstance pi = p.CreateProjectInstance();
-            ITaskItem noMetaItem = null;
             ITaskItem withMetaItem = null;
 
             List<ProjectItemDefinitionInstance> itemdefs = new List<ProjectItemDefinitionInstance>();
             itemdefs.Add(pi.ItemDefinitions["ItemA"]);
 
-            noMetaItem = new TaskItem("NoMetaItem", pi.FullPath);
+            ITaskItem noMetaItem = new TaskItem("NoMetaItem", pi.FullPath);
 
             // No the ideal way to get the first item, but there is no other way since GetItems returns an IEnumerable :(
             foreach (ProjectItemInstance item in pi.GetItems("ItemA"))
diff --git a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
index 9271584b5ff..b9329dad3ba 100644
--- a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
+++ b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
@@ -86,6 +86,51 @@ public void SharedContextShouldGetReusedWhereasIsolatedContextShouldNot(Evaluati
             }
         }
 
+        [Fact]
+        public void PassedInFileSystemShouldBeReusedInSharedContext()
+        {
+            var projectFiles = new[]
+            {
+                _env.CreateFile("1.proj", @"<Project> <PropertyGroup Condition=`Exists('1.file')`></PropertyGroup> </Project>".Cleanup()).Path,
+                _env.CreateFile("2.proj", @"<Project> <PropertyGroup Condition=`Exists('2.file')`></PropertyGroup> </Project>".Cleanup()).Path
+            };
+
+            var projectCollection = _env.CreateProjectCollection().Collection;
+            var fileSystem = new Helpers.LoggingFileSystem();
+            var evaluationContext = EvaluationContext.Create(EvaluationContext.SharingPolicy.Shared, fileSystem);
+
+            foreach (var projectFile in projectFiles)
+            {
+                Project.FromFile(
+                    projectFile,
+                    new ProjectOptions
+                    {
+                        ProjectCollection = projectCollection,
+                        EvaluationContext = evaluationContext
+                    }
+                );
+            }
+
+            fileSystem.ExistenceChecks.OrderBy(kvp => kvp.Key)
+                .ShouldBe(
+                    new Dictionary<string, int>
+                    {
+                        {Path.Combine(_env.DefaultTestDirectory.Path, "1.file"), 1},
+                        {Path.Combine(_env.DefaultTestDirectory.Path, "2.file"), 1}
+                    }.OrderBy(kvp => kvp.Key));
+
+            fileSystem.DirectoryEntryExistsCalls.ShouldBe(2);
+        }
+
+        [Fact]
+        public void IsolatedContextShouldNotSupportBeingPassedAFileSystem()
+        {
+            _env.DoNotLaunchDebugger();
+
+            var fileSystem = new Helpers.LoggingFileSystem();
+            Should.Throw<ArgumentException>(() => EvaluationContext.Create(EvaluationContext.SharingPolicy.Isolated, fileSystem));
+        }
+
         [Theory]
         [InlineData(EvaluationContext.SharingPolicy.Shared)]
         [InlineData(EvaluationContext.SharingPolicy.Isolated)]
diff --git a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
index 36d885c22fd..a72bcd7ad80 100644
--- a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
@@ -266,7 +266,6 @@ public void VerifyTasksFilesAreInSortedOrder()
                 Assert.Equal(foundFiles[i], sortedTasksExpectedPaths[i]);
             }
 
-
             Assert.Equal(sortedOverrideExpectedPaths.Count, foundoverrideFiles.Length);
             for (int i = 0; i < foundoverrideFiles.Length; i++)
             {
@@ -464,10 +463,8 @@ public void CustomToolsVersionIsHonored()
                 Toolset source = p.GetToolset("Current");
                 Toolset potato = new Toolset("potato", source.ToolsPath, ProjectCollection.GlobalProjectCollection, source.ToolsPath);
                 p.AddToolset(potato);
-
-                bool success = false;
                 Project project = p.LoadProject(projectPath, "potato");
-                success = project.Build(mockLogger);
+                bool success = project.Build(mockLogger);
 
                 Assert.True(success);
                 mockLogger.AssertLogContains("[potato]");
@@ -490,15 +487,13 @@ public void ToolsVersionFallbackIfCurrentToolsVersionDoesNotExist()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
-
-            bool success = false;
             Project project = new Project(XmlReader.Create(new StringReader(@"<Project ToolsVersion='4.0' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <Target Name='Foo'>
                     </Target>
                    </Project>")), null /* no global properties */, null /* don't explicitly set the toolsversion */, p);
 
             Assert.Equal("4.0", project.ToolsVersion);
-            success = project.Build(mockLogger);
+            bool success = project.Build(mockLogger);
 
             Assert.True(success);
             mockLogger.AssertLogContains("\"4.0\"");
@@ -637,8 +632,6 @@ public void ToolsVersionFallbackIfCurrentToolsVersionDoesNotExist_CreateProjectI
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
-
-            bool success = false;
             Project project = new Project(XmlReader.Create(new StringReader(@"<Project ToolsVersion='4.0' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <Target Name='Foo'>
                     </Target>
@@ -646,7 +639,7 @@ public void ToolsVersionFallbackIfCurrentToolsVersionDoesNotExist_CreateProjectI
 
             ProjectInstance pi = project.CreateProjectInstance();
             Assert.Equal("4.0", pi.ToolsVersion);
-            success = pi.Build(new ILogger[] { mockLogger });
+            bool success = pi.Build(new ILogger[] { mockLogger });
 
             Assert.True(success);
             mockLogger.AssertLogContains("\"4.0\"");
@@ -791,8 +784,6 @@ public void ToolsVersionFallbackIfCurrentToolsVersionDoesNotExist_ProjectInstanc
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
-
-            bool success = false;
             Project project = new Project(XmlReader.Create(new StringReader(@"<Project ToolsVersion='4.0' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <Target Name='Foo'>
                     </Target>
@@ -800,7 +791,7 @@ public void ToolsVersionFallbackIfCurrentToolsVersionDoesNotExist_ProjectInstanc
 
             ProjectInstance pi = new ProjectInstance(project.Xml, null /* no global properties */, null /* don't explicitly set the toolsversion */, p);
             Assert.Equal("4.0", pi.ToolsVersion);
-            success = pi.Build(new ILogger[] { mockLogger });
+            bool success = pi.Build(new ILogger[] { mockLogger });
 
             Assert.True(success);
             mockLogger.AssertLogContains("\"4.0\"");
@@ -942,7 +933,7 @@ private string[] getFiles(string path, string pattern)
             matches.RemoveAll(
                 delegate (string candidate)
                 {
-                    bool sameFolder = (0 == String.Compare(Path.GetDirectoryName(candidate),
+                    bool sameFolder = (String.Equals(Path.GetDirectoryName(candidate),
                                                            pathWithoutTrailingSlash,
                                                            StringComparison.OrdinalIgnoreCase));
                     return !sameFolder || !Regex.IsMatch(Path.GetFileName(candidate), finalPattern);
diff --git a/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
index 4c57586b987..db0593111e7 100644
--- a/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
@@ -572,9 +572,9 @@ public void ExtensionPathsTest_Basic1()
 
             var reader = GetStandardConfigurationReader();
             Dictionary<string, Toolset> toolsets = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
-            reader.ReadToolsets(toolsets, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
+            reader.ReadToolsets(toolsets, new PropertyDictionary<ProjectPropertyInstance>(),
+                                new PropertyDictionary<ProjectPropertyInstance>(), true,
+                                out string msbuildOverrideTasksPath, out string defaultOverrideToolsVersion);
 
             Dictionary<string, ProjectImportPathMatch> pathsTable = toolsets["2.0"].ImportPropertySearchPathsTable;
             if (NativeMethodsShared.IsWindows)
diff --git a/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
index d64528ff758..70f0f3e7b6f 100644
--- a/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
@@ -115,8 +115,8 @@ public void GetToolsetDataFromConfiguration_SectionNotRegisteredInConfigFile()
             ToolsetReader reader = GetStandardConfigurationReader();
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Null(msbuildOverrideTasksPath);
@@ -159,8 +159,8 @@ public void GetToolsetDataFromConfiguration_Basic()
             ToolsetReader reader = GetStandardConfigurationReader();
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Equal("c:\\Cat", msbuildOverrideTasksPath);
@@ -202,8 +202,8 @@ public void RelativePathInValue()
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
             PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
             pg.Set(ProjectPropertyInstance.Create("DotDotSlash", @".." + Path.DirectorySeparatorChar));
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), pg, true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             string expected1 = Path.GetFullPath(Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, "..", "foo"));
@@ -242,8 +242,8 @@ public void InvalidRelativePath()
 
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             // Don't crash (consistent with invalid absolute path)
@@ -389,8 +389,8 @@ public void GetToolsetDataFromConfiguration_DefaultAttributeNotSpecified()
             ToolsetReader reader = GetStandardConfigurationReader();
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Null(defaultToolsVersion);
@@ -422,9 +422,10 @@ public void GetToolsetDataFromConfiguration_DefaultToolsetUndefined()
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
 
+
             // Should not throw
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
         }
 
@@ -445,9 +446,8 @@ public void GetToolsetDataFromConfiguration_MSBuildToolsetsNodeNotPresent()
             ToolsetReader reader = GetStandardConfigurationReader();
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Null(defaultToolsVersion);
@@ -471,9 +471,8 @@ public void GetToolsetDataFromConfiguration_EmptyMSBuildToolsetsNode()
             ToolsetReader reader = GetStandardConfigurationReader();
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Null(defaultToolsVersion);
@@ -498,9 +497,10 @@ public void GetToolsetDataFromConfiguration_OnlyDefaultSpecified()
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
 
+
             // Should not throw
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Empty(values);
@@ -531,9 +531,8 @@ public void GetToolsetDataFromConfiguration_OneToolsVersionNode()
             ToolsetReader reader = GetStandardConfigurationReader();
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Equal("2.0", defaultToolsVersion);
@@ -730,9 +729,10 @@ public void BlankPropertyValueInConfigFile()
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
 
+
             //this should not throw ...
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
         }
 #endif
@@ -918,7 +918,7 @@ public void GetToolsetDataFromConfiguration_PropertyValueIsEmptyString1()
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
 
             string msbuildOverrideTasksPath;
-            string defaultOverrideToolsVersion = null;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Empty(values);
@@ -948,7 +948,7 @@ public void GetToolsetDataFromConfiguration_PropertyValueIsEmptyString2()
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
 
             string msbuildOverrideTasksPath;
-            string defaultOverrideToolsVersion = null;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Single(values);
@@ -980,8 +980,8 @@ public void GetToolsetDataFromConfiguration_XmlEscapedCharacters()
             ToolsetReader reader = GetStandardConfigurationReader();
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Equal("2>.0", defaultToolsVersion);
diff --git a/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
index fbb71bc7e42..e365cb9265f 100644
--- a/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
@@ -82,10 +82,10 @@ public void ReadRegistry_DeletedKey()
             DeleteTestRegistryKey();
 
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
 
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
             Assert.Empty(values);
         }
@@ -103,9 +103,8 @@ public void DefaultValuesInRegistryCreatedBySetup()
             ToolsetReader reader = new ToolsetRegistryReader(new ProjectCollection().EnvironmentProperties, new PropertyDictionary<ProjectPropertyInstance>());  //we don't use the test registry key because we want to verify the install
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             // Check the values in the data
@@ -124,9 +123,10 @@ public void DefaultValueInRegistryDoesNotExist()
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
 
+
             // Should not throw
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Null(defaultToolsVersion);
@@ -139,9 +139,9 @@ public void DefaultValueInRegistryDoesNotExist()
         public void ReadRegistry_NoSubkeyNoValues()
         {
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Empty(values);
@@ -159,9 +159,9 @@ public void ReadRegistry_NoSubkeysOnlyValues()
             _toolsVersionsRegistryKey.SetValue("Name2", "Value2");
 
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Empty(values);
@@ -180,10 +180,9 @@ public void ReadRegistry_OnlyOneSubkey()
             key1.SetValue("msbuildtoolspath", xdir);
 
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
-
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Null(defaultToolsVersion);
@@ -208,10 +207,9 @@ public void ReadRegistry_Basic()
             key2.SetValue("msbuildtoolspath", ydir);
 
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
-
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Equal(2, values.Count);
@@ -279,10 +277,9 @@ public void ReadRegistry_HasSubToolsets()
             subKey3.SetValue("name5a", "value5a");
 
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
-
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Equal(2, values.Count);
@@ -328,10 +325,9 @@ public void ReadRegistry_IgnoreSubToolsetSubKeys()
             subSubKey1.SetValue("name2b", "value2b");
 
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
-
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Single(values);
@@ -363,10 +359,9 @@ public void ReadRegistry_SubToolsetOverridesBaseToolsetEntries()
             subKey1.SetValue("name2", "");
 
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
-
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Single(values);
@@ -404,10 +399,9 @@ public void ReadRegistry_UnselectedSubToolsetIsIgnored()
             subKey1.SetValue("name2", "");
 
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
-
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Single(values);
@@ -428,10 +422,9 @@ public void GetDefaultToolsVersionFromRegistry_Basic()
             key1.SetValue("msbuildtoolspath", "c:\\xxx");
 
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
-
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Equal("tv1", defaultToolsVersion);
@@ -444,10 +437,9 @@ public void GetDefaultToolsVersionFromRegistry_Basic()
         public void GetDefaultToolsVersionFromRegistry_DefaultValueNotSet()
         {
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
-
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Null(defaultToolsVersion);
@@ -492,9 +484,8 @@ public void GetOverrideTasksPathFromRegistry_Basic()
 
             ToolsetReader reader = GetStandardRegistryReader();
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Equal("c:\\Foo", msbuildOverrideTasksPath);
@@ -508,9 +499,8 @@ public void GetOverrideTasksPathFromRegistry_ValueNotSet()
         {
             ToolsetReader reader = GetStandardRegistryReader();
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Null(msbuildOverrideTasksPath);
@@ -544,9 +534,8 @@ public void GetDefaultOverrideToolsVersionFromRegistry_Basic()
 
             ToolsetReader reader = GetStandardRegistryReader();
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Equal("Current", defaultOverrideToolsVersion);
@@ -560,9 +549,8 @@ public void GetDefaultOverrideToolsVersionFromRegistry_ValueNotSet()
         {
             ToolsetReader reader = GetStandardRegistryReader();
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Null(defaultOverrideToolsVersion);
@@ -599,11 +587,10 @@ public void ReadToolsets_NoBinPathOrToolsPath()
             key3.SetValue("name3", "value3");
 
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
-
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
 
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             //should not throw
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
diff --git a/src/Build.UnitTests/EndToEndCondition_Tests.cs b/src/Build.UnitTests/EndToEndCondition_Tests.cs
index 36c2a3380aa..488441d6817 100644
--- a/src/Build.UnitTests/EndToEndCondition_Tests.cs
+++ b/src/Build.UnitTests/EndToEndCondition_Tests.cs
@@ -72,6 +72,5 @@ public void FalseComparisonsInvolvingMSBuildToolsVersion(string condition)
 
             result.OverallResult.ShouldBe(BuildResultCode.Success);
         }
-
     }
 }
diff --git a/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs b/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs
index 3aeffe5ff37..c05f8d2b76e 100644
--- a/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs
@@ -81,7 +81,7 @@ private static void AssertLoggingEvents(
                 var projectFile = env.CreateFile().Path;
                 File.WriteAllText(projectFile, projectContents);
 
-                firstEvaluationLogger = firstEvaluationLogger ?? new MockLogger();
+                firstEvaluationLogger ??= new MockLogger();
                 collection.RegisterLogger(firstEvaluationLogger);
 
                 var project = new Project(projectFile, null, null, collection);
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 3d16f82ecf3..1e92f0e887f 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -2463,7 +2463,7 @@ public void MSBuildExtensionsPath64Default()
 
             if (!string.IsNullOrEmpty(expected))
             {
-                expected = expected + @"\MSBuild";
+                expected += @"\MSBuild";
             }
 
             Project project = new Project();
@@ -4538,7 +4538,6 @@ public void VerifyPropertyTrackingLoggingDefault()
                         .AllBuildEvents
                         .OfType<PropertyInitialValueSetEventArgs>()
                         .ShouldBeEmpty();
-
                 });
         }
 
@@ -4568,7 +4567,6 @@ public void VerifyPropertyTrackingLoggingPropertyReassignment()
                         .AllBuildEvents
                         .OfType<PropertyInitialValueSetEventArgs>()
                         .ShouldBeEmpty();
-
                 });
         }
 
@@ -4916,7 +4914,6 @@ private void CreateTargetsFileWithMessage(string path, string targetName, string
         /// </summary>
         private void VerifyImportTargetRelativePath(string directory, string directory2, string[] imports)
         {
-            string file0 = null;
             string file1 = null;
             string file2 = null;
             string file3 = null;
@@ -4929,7 +4926,7 @@ private void VerifyImportTargetRelativePath(string directory, string directory2,
                     FileUtilities.DeleteWithoutTrailingBackslash(directory);
                 }
 
-                file0 = Path.Combine(directory, "my.proj");
+                string file0 = Path.Combine(directory, "my.proj");
                 file1 = Path.Combine(directory, "1.targets");
                 file2 = Path.Combine(directory2, "2.targets");
                 file3 = Path.Combine(directory2, "3.cpp.targets");
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 2009a9b3f55..536996904e0 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -1489,6 +1489,65 @@ public void ExpandAllIntoStringLeaveEscapedComplex()
                 expander.ExpandIntoStringLeaveEscaped(xmlattribute.Value, ExpanderOptions.ExpandAll, MockElementLocation.Instance));
         }
 
+        /// <summary>
+        /// Exercises ExpandIntoStringAndUnescape and ExpanderOptions.Truncate
+        /// </summary>
+        [Fact]
+        public void ExpandAllIntoStringTruncated()
+        {
+            ProjectInstance project = ProjectHelpers.CreateEmptyProjectInstance();
+            var manySpaces = "".PadLeft(2000);
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            pg.Set(ProjectPropertyInstance.Create("ManySpacesProperty", manySpaces));
+            var itemMetadataTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
+            {
+                { "ManySpacesMetadata", manySpaces }
+            };
+            var itemMetadata = new StringMetadataTable(itemMetadataTable);
+            var projectItemGroups = new ItemDictionary<ProjectItemInstance>();
+            var itemGroup = new List<ProjectItemInstance>();
+            for (int i = 0; i < 50; i++)
+            {
+                var item = new ProjectItemInstance(project, "ManyItems", $"ThisIsAFairlyLongFileName_{i}.bmp", project.FullPath);
+                item.SetMetadata("Foo", $"ThisIsAFairlyLongMetadataValue_{i}");
+                itemGroup.Add(item);
+            }
+            var lookup = new Lookup(projectItemGroups, pg);
+            lookup.EnterScope("x");
+            lookup.PopulateWithItems("ManySpacesItem", new []
+            {
+                new ProjectItemInstance (project, "ManySpacesItem", "Foo", project.FullPath),
+                new ProjectItemInstance (project, "ManySpacesItem", manySpaces, project.FullPath),
+                new ProjectItemInstance (project, "ManySpacesItem", "Bar", project.FullPath),
+            });
+            lookup.PopulateWithItems("Exactly1024", new[]
+            {
+                new ProjectItemInstance (project, "Exactly1024", "".PadLeft(1024), project.FullPath),
+                new ProjectItemInstance (project, "Exactly1024", "Foo", project.FullPath),
+            });
+            lookup.PopulateWithItems("ManyItems", itemGroup);
+
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(lookup, lookup, itemMetadata, FileSystems.Default);
+
+            XmlAttribute xmlattribute = (new XmlDocument()).CreateAttribute("dummy");
+            xmlattribute.Value = "'%(ManySpacesMetadata)' != '' and '$(ManySpacesProperty)' != '' and '@(ManySpacesItem)' != '' and '@(Exactly1024)' != '' and '@(ManyItems)' != '' and '@(ManyItems->'%(Foo)')' != '' and '@(ManyItems->'%(Nonexistent)')' != ''";
+
+            var expected =
+                $"'{"",1021}...' != '' and " +
+                $"'{"",1021}...' != '' and " +
+                $"'Foo;{"",1017}...' != '' and " +
+                $"'{"",1024};...' != '' and " +
+                "'ThisIsAFairlyLongFileName_0.bmp;ThisIsAFairlyLongFileName_1.bmp;ThisIsAFairlyLongFileName_2.bmp;...' != '' and " +
+                "'ThisIsAFairlyLongMetadataValue_0;ThisIsAFairlyLongMetadataValue_1;ThisIsAFairlyLongMetadataValue_2;...' != '' and " +
+                $"';;;...' != ''";
+            // NOTE: semicolons in the last part are *weird* because they don't actually mean anything and you get logging like
+            //     Target "Build" skipped, due to false condition; ( '@(I->'%(nonexistent)')' == '' ) was evaluated as ( ';' == '' ).
+            // but that goes back to MSBuild 4.something so I'm codifying it in this test. If you're here because you cleaned it up
+            // and want to fix the test my current opinion is that's fine.
+
+            Assert.Equal(expected, expander.ExpandIntoStringAndUnescape(xmlattribute.Value, ExpanderOptions.ExpandAll | ExpanderOptions.Truncate, MockElementLocation.Instance));
+        }
+
         /// <summary>
         /// Exercises ExpandAllIntoString with a string that does not need expanding.
         /// In this case the expanded string should be reference identical to the passed in string.
@@ -2865,6 +2924,7 @@ public void PropertyFunctionVersionComparisons(string a, string b, int expectedS
         [InlineData("net45", ".NETFramework", "4.5")]
         [InlineData("netcoreapp3.1", ".NETCoreApp", "3.1")]
         [InlineData("netstandard2.1", ".NETStandard", "2.1")]
+        [InlineData("net5.0-ios12.0", ".NETCoreApp", "5.0")]
         [InlineData("foo", "Unsupported", "0.0")]
         public void PropertyFunctionTargetFrameworkParsing(string tfm, string expectedIdentifier, string expectedVersion)
         {
@@ -2875,8 +2935,53 @@ public void PropertyFunctionTargetFrameworkParsing(string tfm, string expectedId
             AssertSuccess(expander, expectedVersion, $"$([MSBuild]::GetTargetFrameworkVersion('{tfm}'))");
         }
 
+        [Theory]
+        [InlineData("net45", 2, "4.5")]
+        [InlineData("net45", 3, "4.5.0")]
+        [InlineData("net472", 3, "4.7.2")]
+        [InlineData("net472", 2, "4.7.2")]
+        public void PropertyFunctionTargetFrameworkVersionMultipartParsing(string tfm, int versionPartCount, string expectedVersion)
+        {
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+
+            AssertSuccess(expander, expectedVersion, $"$([MSBuild]::GetTargetFrameworkVersion('{tfm}', {versionPartCount}))");
+        }
+
+        [Theory]
+        [InlineData("net5.0-windows10.1.2.3", 4, "10.1.2.3")]
+        [InlineData("net5.0-windows10.1.2.3", 2, "10.1.2.3")]
+        [InlineData("net5.0-windows10.0.0.3", 2, "10.0.0.3")]
+        [InlineData("net5.0-windows0.0.0.3", 2, "0.0.0.3")]
+        public void PropertyFunctionTargetPlatformVersionMultipartParsing(string tfm, int versionPartCount, string expectedVersion)
+        {
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+
+            AssertSuccess(expander, expectedVersion, $"$([MSBuild]::GetTargetPlatformVersion('{tfm}', {versionPartCount}))");
+        }
+
+        [Theory]
+        [InlineData("net5.0-ios12.0", "ios", "12.0")]
+        [InlineData("net5.1-android1.1", "android", "1.1")]
+        [InlineData("net6.0-windows99.99", "windows", "99.99")]
+        [InlineData("net5.0-ios", "ios", "0.0")]
+        [InlineData("foo", "", "0.0")]
+        public void PropertyFunctionTargetPlatformParsing(string tfm, string expectedIdentifier, string expectedVersion)
+        {
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+
+            AssertSuccess(expander, expectedIdentifier, $"$([MSBuild]::GetTargetPlatformIdentifier('{tfm}'))");
+            AssertSuccess(expander, expectedVersion, $"$([MSBuild]::GetTargetPlatformVersion('{tfm}'))");
+        }
+
         [Theory]
         [InlineData("net5.0", "net5.0", true)]
+        [InlineData("net5.0-windows10.0", "net5.0-windows10.0", true)]
+        [InlineData("net5.0-ios", "net5.0-andriod", false)]
+        [InlineData("net5.0-ios12.0", "net5.0-ios11.0", true)]
+        [InlineData("net5.0-ios11.0", "net5.0-ios12.0", false)]
         [InlineData("net45", "net46", false)]
         [InlineData("net46", "net45", true)]
         [InlineData("netcoreapp3.1", "netcoreapp1.0", true)]
@@ -3775,7 +3880,7 @@ public void Medley()
                     caughtException = true;
                 }
                 Assert.True(
-                        (success == false || caughtException == true),
+                        !success || caughtException,
                         "FAILURE: Expected '" + errorTests[i] + "' to not parse or not be evaluated but it evaluated to '" + result + "'"
                     );
             }
@@ -3892,7 +3997,7 @@ public void PropertyFunctionIntrinsicFunctionGetVsInstallRoot()
         {
             string vsInstallRoot = EscapingUtilities.Escape(IntrinsicFunctions.GetVsInstallRoot());
 
-            vsInstallRoot = (vsInstallRoot == null) ? "" : vsInstallRoot;
+            vsInstallRoot ??= "";
 
             TestPropertyFunction("$([Microsoft.Build.Evaluation.IntrinsicFunctions]::GetVsInstallRoot())", "X", "_", vsInstallRoot);
         }
diff --git a/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs b/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
index 2903374e8e0..920b2b13a58 100644
--- a/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
@@ -442,7 +442,7 @@ private void VerifySplitSemiColonSeparatedList(string input, params string[] exp
             var actual = ExpressionShredder.SplitSemiColonSeparatedList(input);
             Console.WriteLine(input);
 
-            if (null == expected)
+            if (expected == null)
             {
                 // passing "null" means you expect an empty array back
                 expected = new string[] { };
@@ -481,7 +481,7 @@ private static void VerifyAgainstCanonicalResults(string test, HashSet<string> a
             {
                 foreach (string result in actual)
                 {
-                    if (expected == null || !expected.Contains(result))
+                    if (expected?.Contains(result) != true)
                     {
                         messages.Add("Found <" + result + "> in <" + test + "> but it wasn't expected");
                     }
@@ -492,7 +492,7 @@ private static void VerifyAgainstCanonicalResults(string test, HashSet<string> a
             {
                 foreach (string expect in expected)
                 {
-                    if (actual == null || !actual.Contains(expect))
+                    if (actual?.Contains(expect) != true)
                     {
                         messages.Add("Did not find <" + expect + "> in <" + test + ">");
                     }
@@ -530,7 +530,7 @@ private static void VerifyAgainstCanonicalResults(string test, IDictionary actua
             {
                 foreach (DictionaryEntry result in actual)
                 {
-                    if (expected == null || !expected.Contains(result.Key))
+                    if (expected?.Contains(result.Key) != true)
                     {
                         messages.Add("Found <" + result.Key + "> in <" + test + "> but it wasn't expected");
                     }
@@ -541,7 +541,7 @@ private static void VerifyAgainstCanonicalResults(string test, IDictionary actua
             {
                 foreach (DictionaryEntry expect in expected)
                 {
-                    if (actual == null || !actual.Contains(expect.Key))
+                    if (actual?.Contains(expect.Key) != true)
                     {
                         messages.Add("Did not find <" + expect.Key + "> in <" + test + ">");
                     }
@@ -668,7 +668,6 @@ public void ExtractItemVectorExpressionsSingleExpression2()
             List<ExpressionShredder.ItemExpressionCapture> expressions;
             ExpressionShredder.ItemExpressionCapture capture;
 
-
             expression = "@(Foo, ';')";
             expressions = ExpressionShredder.GetReferencedItemExpressions(expression);
             capture = expressions[0];
@@ -686,7 +685,6 @@ public void ExtractItemVectorExpressionsSingleExpression3()
             List<ExpressionShredder.ItemExpressionCapture> expressions;
             ExpressionShredder.ItemExpressionCapture capture;
 
-
             expression = "@(Foo->'%(Fullpath)')";
             expressions = ExpressionShredder.GetReferencedItemExpressions(expression);
             capture = expressions[0];
@@ -723,7 +721,6 @@ public void ExtractItemVectorExpressionsSingleExpression5()
             List<ExpressionShredder.ItemExpressionCapture> expressions;
             ExpressionShredder.ItemExpressionCapture capture;
 
-
             expression = "@(Foo->Bar(a,b))";
             expressions = ExpressionShredder.GetReferencedItemExpressions(expression);
             capture = expressions[0];
@@ -1092,7 +1089,6 @@ public void ExtractItemVectorExpressionsMultipleExpression4()
             Assert.Equal("\"()\", $(Boo), `)(\"`", capture.Captures[1].FunctionArguments);
         }
 
-
         [Fact]
         public void ExtractItemVectorExpressionsMultipleExpression5()
         {
diff --git a/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs b/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs
index cc00152c075..b4a4a32270a 100644
--- a/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs
@@ -537,7 +537,7 @@ public void LongIncludeChain()
             StringBuilder content = new StringBuilder();
             for (int i = 0; i < INCLUDE_COUNT; i++)
             {
-                content.AppendLine($"<i Include='ItemValue{i}' />");
+                content.Append("<i Include='ItemValue").Append(i).AppendLine("' />");
             }
 
             IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(content.ToString());
diff --git a/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs b/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
index f9aa33d6321..f0564b0dcba 100644
--- a/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
@@ -76,7 +76,7 @@ public void FragmentGlobsWorkAfterStateIsPartiallyInitializedByOtherOperations()
 
         private ProjectInstanceItemSpec CreateItemSpecFrom(string itemSpec, ProjectInstanceExpander expander, IElementLocation location = null)
         {
-            location = location ?? MockElementLocation.Instance;
+            location ??= MockElementLocation.Instance;
 
             return new ProjectInstanceItemSpec(itemSpec, expander, location, Path.GetDirectoryName(location.File));
         }
diff --git a/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
index 659ce98e4bc..ed3030d0aa9 100644
--- a/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
@@ -6,17 +6,20 @@
 using System.IO;
 using System.Linq;
 using System.Reflection;
+using System.Text;
 using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Definition;
-using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Unittest;
 using Shouldly;
 using Xunit;
-using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
+using SdkResolverContext = Microsoft.Build.Framework.SdkResolverContext;
+using SdkResult = Microsoft.Build.Framework.SdkResult;
+using SdkResultFactory = Microsoft.Build.Framework.SdkResultFactory;
+using SdkReferencePropertyExpansionMode = Microsoft.Build.Utilities.EscapeHatches.SdkReferencePropertyExpansionMode;
 
 namespace Microsoft.Build.UnitTests.OM.Construction
 {
@@ -70,6 +73,11 @@ public class ProjectSdkImplicitImport_Tests : IDisposable
         private string _sdkPropsContent = "<Project><PropertyGroup><InitialImportProperty>Hello</InitialImportProperty></PropertyGroup></Project>";
         private string _sdkTargetsContent = "<Project><PropertyGroup><FinalImportProperty>World</FinalImportProperty></PropertyGroup></Project>";
         private string _projectInnerContents = @"<PropertyGroup><UsedToTestIfImplicitImportsAreInTheCorrectLocation>null</UsedToTestIfImplicitImportsAreInTheCorrectLocation></PropertyGroup>";
+        private const string SdkNamePropertyName = "MyTestSdkName";
+        private const string SdkNameProperty = "$(" + SdkNamePropertyName + ")";
+        private const string SdkVersionPropertyName = "MyTestSdkVersion";
+        private const string SdkVersionProperty = "$(" + SdkVersionPropertyName + ")";
+        private const string SdkExpectedVersion = "42.42.42-local";
 
         public ProjectSdkImplicitImport_Tests()
         {
@@ -230,7 +238,6 @@ public void ProjectWithSdkImportsIsCloneable(string projectFormatString)
             ProjectRootElement project = ProjectRootElement.Create(XmlReader.Create(new StringReader(content)));
 
             project.DeepClone();
-
         }
 
         [Theory]
@@ -267,7 +274,6 @@ public void ProjectWithSdkImportsIsRemoveable(string projectFormatString)
             clone.DeepCopyFrom(project);
 
             clone.RemoveAllChildren();
-
         }
 
         /// <summary>
@@ -534,6 +540,257 @@ public void ImplicitImportsShouldHaveParsedSdkInfo(
             }
         }
 
+        internal class SdkPropertiesAreExpandedDataTemplate
+        {
+            public SdkPropertiesAreExpandedDataTemplate(string template, bool expectedMinimumVersionIsNull)
+            {
+                Template = template ?? throw new ArgumentNullException(nameof(template));
+                ExpectedMinimumVersion = expectedMinimumVersionIsNull ? null : string.Empty;
+            }
+
+            public string Template { get; }
+            public string ExpectedMinimumVersion { get; }
+
+            public override string ToString()
+            {
+                return Template switch
+                {
+                    ProjectTemplateSdkAsAttributeWithVersion => nameof(ProjectTemplateSdkAsAttributeWithVersion),
+                    ProjectTemplateSdkAsElementWithVersion => nameof(ProjectTemplateSdkAsElementWithVersion),
+                    ProjectTemplateSdkAsExplicitImportWithVersion => nameof(ProjectTemplateSdkAsExplicitImportWithVersion),
+                    _ => "<unknown>"
+                };
+            }
+        }
+
+        internal class SdkPropertiesAreExpandedCase
+        {
+            public SdkPropertiesAreExpandedCase(SdkReferencePropertyExpansionMode? mode,
+                SdkPropertiesAreExpandedDataTemplate template, bool setName, bool setVersion, bool expectedSuccess)
+            {
+                Mode = mode;
+                Template = template ?? throw new ArgumentNullException(nameof(template));
+                ExpectedSuccess = expectedSuccess;
+                SetNameProperty = setName;
+                SetVersionProperty = setVersion;
+            }
+
+            public SdkReferencePropertyExpansionMode? Mode { get; }
+            public SdkPropertiesAreExpandedDataTemplate Template { get; }
+            public string TemplateName { get; set; } = SdkName;
+            public string TemplateVersion { get; set; } = SdkExpectedVersion;
+            public bool SetNameProperty { get; }
+            public bool SetVersionProperty { get; }
+            public bool ExpectedSuccess { get; }
+
+            public override string ToString()
+            {
+                var result = new StringBuilder(256);
+                if (Mode.HasValue)
+                    result.Append(Mode);
+                else
+                    result.Append($"{nameof(Mode)}: <null>");
+
+                result.Append($", {Template}, {nameof(TemplateName)}: {TemplateName}, {nameof(TemplateVersion)}: {TemplateVersion}");
+
+                if (SetNameProperty)
+                    result.Append(", SetName");
+                if (SetVersionProperty)
+                    result.Append(", SetVersion");
+                if (ExpectedSuccess)
+                    result.Append(", ExpectedSuccess");
+
+                return result.ToString();
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(SdkPropertiesAreExpandedData))]
+        internal void SdkPropertiesAreExpanded(SdkPropertiesAreExpandedCase data)
+        {
+            _env.SetEnvironmentVariable("MSBuildSDKsPath", _testSdkRoot);
+            _env.SetEnvironmentVariable("MSBUILD_SDKREFERENCE_PROPERTY_EXPANSION_MODE", data.Mode.ToString());
+
+            File.WriteAllText(_sdkPropsPath, _sdkPropsContent);
+            File.WriteAllText(_sdkTargetsPath, _sdkTargetsContent);
+
+            var projectContents = string.Format(
+                data.Template.Template,
+                data.TemplateName,
+                _projectInnerContents,
+                data.TemplateVersion,
+                null
+            );
+
+            var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(
+                new MockExpandedSdkResolver(_testSdkDirectory)
+            );
+
+            void AddProperty(string name, string value) =>
+                (projectOptions.GlobalProperties ??= new Dictionary<string, string>()).Add(name, value);
+
+            if (data.SetNameProperty)
+                AddProperty(SdkNamePropertyName, SdkName);
+
+            if (data.SetVersionProperty)
+                AddProperty(SdkVersionPropertyName, SdkExpectedVersion);
+
+            using var xmlReader = XmlReader.Create(new StringReader(projectContents));
+
+            if (!data.ExpectedSuccess)
+                projectOptions.LoadSettings |= ProjectLoadSettings.IgnoreMissingImports;
+
+            var project = Project.FromXmlReader(xmlReader, projectOptions);
+
+            if (data.ExpectedSuccess)
+            {
+                var expectedSdkPath = Path.GetDirectoryName(_sdkPropsPath);
+
+                // self-consistency check
+                expectedSdkPath.ShouldBe(Path.GetDirectoryName(_sdkTargetsPath));
+
+                var expectedSdkReferenceRaw = new SdkReference(
+                    data.TemplateName,
+                    data.TemplateVersion,
+                    data.Template.ExpectedMinimumVersion
+                );
+
+                var expectedSdkReference = new SdkReference(
+                    SdkName,
+                    SdkExpectedVersion,
+                    data.Template.ExpectedMinimumVersion
+                );
+
+                project.Imports.Count.ShouldBe(2);
+
+                foreach (var import in project.Imports)
+                {
+                    import.ImportingElement.SdkReference.ShouldBe(expectedSdkReferenceRaw);
+                    import.SdkResult.Success.ShouldBeTrue();
+                    import.SdkResult.SdkReference.ShouldBe(expectedSdkReference);
+                    import.SdkResult.Path.ShouldBe(expectedSdkPath);
+                    import.SdkResult.Version.ShouldBe(expectedSdkReference.Version);
+                }
+            }
+            else
+            {
+                project.Imports.Count.ShouldBe(0);
+            }
+        }
+
+        public static IEnumerable<object[]> SdkPropertiesAreExpandedData
+        {
+            get
+            {
+                static IEnumerable<SdkReferencePropertyExpansionMode?> Modes()
+                {
+                    yield return null;
+                    yield return SdkReferencePropertyExpansionMode.NoExpansion;
+                    yield return SdkReferencePropertyExpansionMode.DefaultExpand;
+                    yield return SdkReferencePropertyExpansionMode.ExpandUnescape;
+                    yield return SdkReferencePropertyExpansionMode.ExpandLeaveEscaped;
+                }
+
+                static IEnumerable<(SdkPropertiesAreExpandedDataTemplate, bool setName, bool setVersion)> Templates()
+                {
+                    var templates = new[]
+                    {
+                        new SdkPropertiesAreExpandedDataTemplate(
+                            ProjectTemplateSdkAsAttributeWithVersion, true
+                        ),
+                        new SdkPropertiesAreExpandedDataTemplate(
+                            ProjectTemplateSdkAsElementWithVersion, false
+                        ),
+                        new SdkPropertiesAreExpandedDataTemplate(
+                            ProjectTemplateSdkAsExplicitImportWithVersion, false
+                        )
+                    };
+
+                    foreach (var template in templates)
+                    {
+                        yield return (template, false, false);
+                        yield return (template, false, true);
+                        yield return (template, true, false);
+                        yield return (template, true, true);
+                    }
+                }
+
+                foreach (var mode in Modes())
+                {
+                    var shouldExpand = mode != SdkReferencePropertyExpansionMode.NoExpansion;
+
+                    foreach (var (template, setName, setVersion) in Templates())
+                    {
+                        yield return new object[]
+                        {
+                            new SdkPropertiesAreExpandedCase(mode, template, setName, setVersion, true)
+                        };
+
+                        yield return new object[]
+                        {
+                            new SdkPropertiesAreExpandedCase(
+                                mode, template, setName, setVersion, shouldExpand && setName
+                            )
+                            {
+                                TemplateName = SdkNameProperty
+                            }
+                        };
+
+                        yield return new object[]
+                        {
+                            new SdkPropertiesAreExpandedCase(
+                                mode, template, setName, setVersion, shouldExpand && setVersion
+                            )
+                            {
+                                TemplateVersion = SdkVersionProperty
+                            }
+                        };
+
+                        yield return new object[]
+                        {
+                            new SdkPropertiesAreExpandedCase(
+                                mode, template, setName, setVersion, shouldExpand && setName && setVersion
+                            )
+                            {
+                                TemplateName = SdkNameProperty,
+                                TemplateVersion = SdkVersionProperty
+                            }
+                        };
+                    }
+                }
+            }
+        }
+
+        private sealed class MockExpandedSdkResolver : SdkResolver
+        {
+            private const string ResolverName = nameof(MockExpandedSdkResolver);
+            private const string ErrorName = ResolverName + "/Error/" + nameof(SdkReference.Name);
+            private const string ErrorVersion = ResolverName + "/Error/" + nameof(SdkReference.Version);
+
+            public MockExpandedSdkResolver(string resolvedPath)
+            {
+                ResolvedPath = resolvedPath;
+            }
+
+            public override string Name => ResolverName;
+
+            public override int Priority => 1;
+
+            public string ResolvedPath { get; }
+
+            public override SdkResult Resolve(SdkReference sdk, SdkResolverContext resolverContext,
+                                              SdkResultFactory factory)
+            {
+                return sdk.Name switch
+                {
+                    SdkName when sdk.Version == SdkExpectedVersion =>
+                    factory.IndicateSuccess(ResolvedPath, SdkExpectedVersion),
+                    SdkName => factory.IndicateFailure(new[] {ErrorVersion}),
+                    _ => factory.IndicateFailure(new[] {ErrorName})
+                };
+            }
+        }
+
         public void Dispose()
         {
             _env.Dispose();
diff --git a/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs b/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
index ee2a51e78b8..b210813cc7f 100644
--- a/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
@@ -140,9 +140,11 @@ public void SdkResolverCanReturnNoPaths(bool includePropertiesAndItems)
         }
 
         [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void SdkResolverCanReturnSinglePath(bool includePropertiesAndItems)
+        [InlineData(true, true)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        [InlineData(false, false)]
+        public void SdkResolverCanReturnSinglePath(bool includePropertiesAndItems, bool useSinglePathResult)
         {
             Dictionary<string, string> propertiesToAdd = null;
             Dictionary<string, SdkResultItem> itemsToAdd = null;
@@ -152,16 +154,23 @@ public void SdkResolverCanReturnSinglePath(bool includePropertiesAndItems)
                 CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
             }
 
-            var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(new SdkUtilities.ConfigurableMockSdkResolver(
+            var sdkResult = useSinglePathResult ?
                 new Build.BackEnd.SdkResolution.SdkResult(
-                        new SdkReference("TestPropsAndItemsFromResolverSdk", null, null),
-                        new[] { Path.Combine(_testFolder, "Sdk") },
-                        version: null,
-                        propertiesToAdd,
-                        itemsToAdd,
-                        warnings: null
-                    ))
-                );
+                    new SdkReference("TestPropsAndItemsFromResolverSdk", null, null),
+                    Path.Combine(_testFolder, "Sdk"),
+                    version: null,
+                    warnings: null,
+                    propertiesToAdd,
+                    itemsToAdd) :
+                new Build.BackEnd.SdkResolution.SdkResult(
+                    new SdkReference("TestPropsAndItemsFromResolverSdk", null, null),
+                    new[] { Path.Combine(_testFolder, "Sdk") },
+                    version: null,
+                    propertiesToAdd,
+                    itemsToAdd,
+                    warnings: null);
+
+            var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(new SdkUtilities.ConfigurableMockSdkResolver(sdkResult));
 
             string projectContent = @"
                     <Project>
@@ -339,9 +348,8 @@ public void SdkResolverCanReturnMultiplePaths(bool includePropertiesAndItems)
         [Fact]
         public void SdkResolverCanReturnTheSamePropertiesAndItemsMultipleTimes()
         {
-            Dictionary<string, string> propertiesToAdd = null;
-            Dictionary<string, SdkResultItem> itemsToAdd = null;
-
+            Dictionary<string, string> propertiesToAdd;
+            Dictionary<string, SdkResultItem> itemsToAdd;
             CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
 
             var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(new SdkUtilities.ConfigurableMockSdkResolver(
@@ -459,7 +467,6 @@ public void SdkResolverCanReturnSpecialCharacters()
 
             _logger.ErrorCount.ShouldBe(0);
             _logger.WarningCount.ShouldBe(0);
-
         }
 
         public void Dispose()
diff --git a/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs b/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs
index dec5777d189..6c0dd4d9db9 100644
--- a/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs
+++ b/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs
@@ -413,7 +413,6 @@ public void Dispose()
             {
                 if (File.Exists(file)) File.Delete(file);
             }
-
         }
 
         /// <summary>
@@ -426,8 +425,7 @@ public void Dispose()
         public void EvaluateAVarietyOfTrueExpressions(string expression)
         {
             Parser p = new Parser();
-            GenericExpressionNode tree;
-            tree = p.Parse(expression, ParserOptions.AllowAll, ElementLocation.EmptyLocation);
+            GenericExpressionNode tree = p.Parse(expression, ParserOptions.AllowAll, ElementLocation.EmptyLocation);
             ConditionEvaluator.IConditionEvaluationState state =
                 new ConditionEvaluator.ConditionEvaluationState<ProjectPropertyInstance, ProjectItemInstance>
                     (
@@ -453,8 +451,7 @@ public void EvaluateAVarietyOfTrueExpressions(string expression)
         public void EvaluateAVarietyOfFalseExpressions(string expression)
         {
             Parser p = new Parser();
-            GenericExpressionNode tree;
-            tree = p.Parse(expression, ParserOptions.AllowAll, ElementLocation.EmptyLocation);
+            GenericExpressionNode tree = p.Parse(expression, ParserOptions.AllowAll, ElementLocation.EmptyLocation);
             ConditionEvaluator.IConditionEvaluationState state =
                 new ConditionEvaluator.ConditionEvaluationState<ProjectPropertyInstance, ProjectItemInstance>
                     (
diff --git a/src/Build.UnitTests/ExpressionTree_Tests.cs b/src/Build.UnitTests/ExpressionTree_Tests.cs
index 35545538cc8..f19b64a26af 100644
--- a/src/Build.UnitTests/ExpressionTree_Tests.cs
+++ b/src/Build.UnitTests/ExpressionTree_Tests.cs
@@ -344,15 +344,12 @@ public void ConditionedPropertyUpdateTests()
                                        ElementLocation.EmptyLocation,
                                        FileSystems.Default
                                    );
-
-            List<string> properties = null;
-
             AssertParseEvaluate(p, "'0' == '1'", expander, false, state);
             Assert.Empty(conditionedProperties);
 
             AssertParseEvaluate(p, "$(foo) == foo", expander, false, state);
             Assert.Single(conditionedProperties);
-            properties = conditionedProperties["foo"];
+            List<string> properties = conditionedProperties["foo"];
             Assert.Single(properties);
 
             AssertParseEvaluate(p, "'$(foo)' != 'bar'", expander, true, state);
diff --git a/src/Build.UnitTests/FileLogger_Tests.cs b/src/Build.UnitTests/FileLogger_Tests.cs
index 7358498e544..e06c154ba57 100644
--- a/src/Build.UnitTests/FileLogger_Tests.cs
+++ b/src/Build.UnitTests/FileLogger_Tests.cs
@@ -13,8 +13,6 @@
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 
-
-
 using EventSourceSink = Microsoft.Build.BackEnd.Logging.EventSourceSink;
 using Project = Microsoft.Build.Evaluation.Project;
 using Xunit;
@@ -66,13 +64,12 @@ public void BasicNoExistingFile()
                 SetUpFileLoggerAndLogMessage("logfile=" + log, new BuildMessageEventArgs("message here", null, null, MessageImportance.High));
                 VerifyFileContent(log, "message here");
 
-
                 byte[] content = ReadRawBytes(log);
                 Assert.Equal((byte)109, content[0]); // 'm'
             }
             finally
             {
-                if (null != log) File.Delete(log);
+                if (log != null) File.Delete(log);
             }
         }
 
@@ -95,7 +92,7 @@ public void InvalidFile()
                 }
                 finally
                 {
-                    if (null != log) File.Delete(log);
+                    if (log != null) File.Delete(log);
                 }
             }
            );
@@ -124,7 +121,7 @@ public void SpecificVerbosity()
             }
             finally
             {
-                if (null != log) File.Delete(log);
+                if (log != null) File.Delete(log);
             }
         }
 
@@ -197,7 +194,7 @@ public void InvalidEncoding()
                 }
                 finally
                 {
-                    if (null != log) File.Delete(log);
+                    if (log != null) File.Delete(log);
                 }
             }
            );
@@ -223,7 +220,7 @@ public void ValidEncoding()
             }
             finally
             {
-                if (null != log) File.Delete(log);
+                if (log != null) File.Delete(log);
             }
         }
 
@@ -248,7 +245,7 @@ public void ValidEncoding2()
             }
             finally
             {
-                if (null != log) File.Delete(log);
+                if (log != null) File.Delete(log);
             }
         }
 
@@ -290,7 +287,7 @@ public void BasicExistingFileNoAppend()
             }
             finally
             {
-                if (null != log) File.Delete(log);
+                if (log != null) File.Delete(log);
             }
         }
 
@@ -311,7 +308,7 @@ public void BasicExistingFileAppend()
             }
             finally
             {
-                if (null != log) File.Delete(log);
+                if (log != null) File.Delete(log);
             }
         }
 
diff --git a/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs b/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs
index e839f35708a..e44014ce596 100644
--- a/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs
+++ b/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs
@@ -355,7 +355,6 @@ public void UncPatternTrailingSlash()
 
             FileUtilitiesRegex.IsUncPattern(winDirectory).ShouldBe(false);
             FileUtilitiesRegex.IsUncPattern(unixDirectory).ShouldBe(false);
-
         }
 
         [Fact]
@@ -366,7 +365,6 @@ public void StartWithUncPatternTrailingSlash_LegacyRegex()
 
             StartsWithUncPattern.IsMatch(winDirectory).ShouldBeTrue();
             StartsWithUncPattern.IsMatch(unixDirectory).ShouldBeTrue();
-
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs b/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
index 00dfd1bb588..c4f8ab84bea 100644
--- a/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
+++ b/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
@@ -148,6 +148,17 @@ public void GlobParsingShouldInitializePartialStateOnIllegalFileSpec()
             Assert.False(glob.IsMatch($"b/.../c/d.cs"));
         }
 
+        [Fact]
+        public void GlobParsingShouldDeduplicateRegexes()
+        {
+            var globRoot = NativeMethodsShared.IsWindows ? @"c:\a" : "/a";
+            var fileSpec = $"b/**/*.cs";
+            var glob1 = MSBuildGlob.Parse(globRoot, fileSpec);
+            var glob2 = MSBuildGlob.Parse(globRoot, fileSpec);
+
+            Assert.Same(glob1.TestOnlyRegex, glob2.TestOnlyRegex);
+        }
+
         [Fact]
         public void GlobIsNotUnescaped()
         {
diff --git a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
index 6ae0368da58..8ffc859accd 100644
--- a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
+++ b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
@@ -204,7 +204,7 @@ public void GraphConstructionCanLoadEntryPointsFromSolution(
             AssertSolutionBasedGraph(edges, currentSolutionConfiguration, solutionConfigurations);
         }
 
-        [Theory]
+        [Theory(Skip = "hangs in CI, can't repro locally: https://github.com/dotnet/msbuild/issues/5453")]
         [MemberData(nameof(GraphsWithUniformSolutionConfigurations))]
         public void SolutionBasedGraphCanMatchProjectSpecificConfigurations(
             Dictionary<int, int[]> edges,
diff --git a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
index 4cde1fc90bc..844c88dc8a8 100644
--- a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
+++ b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
@@ -77,7 +77,7 @@ public static void AssertOuterBuildAsNonRoot(
 
         public static void AssertNonMultitargetingNode(ProjectGraphNode node, Dictionary<string, string> additionalGlobalProperties = null)
         {
-            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();
+            additionalGlobalProperties ??= new Dictionary<string, string>();
 
             IsNotMultitargeting(node).ShouldBeTrue();
             node.ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(EmptyGlobalProperties.AddRange(additionalGlobalProperties));
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 45734a1188c..a52d2eace20 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -289,7 +289,7 @@ public void ConstructWithCycle()
                 var proj3 = CreateProjectFile(env, 3, new[] { 1 });
                 var projectsInCycle = new List<string> {entryProject.Path, proj3.Path, proj2.Path, entryProject.Path};
                 string expectedErrorMessage = GraphBuilder.FormatCircularDependencyError(projectsInCycle);
-                Should.Throw<CircularDependencyException>(() => new ProjectGraph(entryProject.Path)).Message.ShouldContain(expectedErrorMessage.ToString());
+                Should.Throw<CircularDependencyException>(() => new ProjectGraph(entryProject.Path)).Message.ShouldContain(expectedErrorMessage);
             }
         }
 
@@ -323,7 +323,7 @@ public void ConstructBigGraphWithCycle()
                 CreateProjectFile(env, 10);
                 var projectsInCycle = new List<string> {proj2.Path, proj3.Path, proj7.Path, proj6.Path, proj2.Path };
                 var errorMessage = GraphBuilder.FormatCircularDependencyError(projectsInCycle);
-                Should.Throw<CircularDependencyException>(() => new ProjectGraph(entryProject.Path)).Message.ShouldContain(errorMessage.ToString());
+                Should.Throw<CircularDependencyException>(() => new ProjectGraph(entryProject.Path)).Message.ShouldContain(errorMessage);
             }
         }
 
@@ -1516,7 +1516,7 @@ private static void AssertOuterBuildAsRoot(
             Dictionary<string, string> additionalGlobalProperties = null,
             int expectedInnerBuildCount = 2)
         {
-            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();
+            additionalGlobalProperties ??= new Dictionary<string, string>();
 
             AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);
 
diff --git a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
index aab69e7f57c..b5c742d2791 100644
--- a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
+++ b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
@@ -422,7 +422,7 @@ public void MissingResultFromCacheShouldErrorDueToIsolatedBuildCacheEnforcement(
             // (current node, expected output dictionary) -> actual expected output for current node
             Func<ProjectGraphNode, ExpectedNodeBuildOutput, string[]> expectedOutputProducer = null)
         {
-            expectedOutputProducer = expectedOutputProducer ?? ((node, expectedOutputs) => expectedOutputs[node]);
+            expectedOutputProducer ??= ((node, expectedOutputs) => expectedOutputs[node]);
 
             var results = new Dictionary<string, (BuildResult Result, MockLogger Logger)>(topoSortedNodes.Count);
 
@@ -526,8 +526,8 @@ internal static TransientTestFile CreateProjectFileWithBuildTargetAndItems(
                         </MSBuild>
                     </Target>");
 
-            sb.Append($@"<ItemGroup>
-                            <i Include='{projectNumber}'/>
+            sb.Append(@"<ItemGroup>
+                            <i Include='").Append(projectNumber).Append(@"'/>
                         </ItemGroup>");
 
             return CreateProjectFile(
diff --git a/src/Build.UnitTests/Instance/HostServices_Tests.cs b/src/Build.UnitTests/Instance/HostServices_Tests.cs
index 2a5495dc0ee..0bd541928cd 100644
--- a/src/Build.UnitTests/Instance/HostServices_Tests.cs
+++ b/src/Build.UnitTests/Instance/HostServices_Tests.cs
@@ -271,7 +271,6 @@ public void TestNonContradictoryAffinityAllowed()
         /// <summary>
         /// Test which ensures that setting a host object for a project with an out-of-proc affinity throws.
         /// </summary>
-
         [Fact]
         public void TestContraditcoryHostObjectCausesException_OutOfProc()
         {
diff --git a/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
index 6743baf1a8d..6b294012cbb 100644
--- a/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
@@ -285,7 +285,6 @@ public void UsingExplicitToolsVersionShouldBeFalseWhenNoToolsetIsReferencedInPro
                 );
 
             projectInstance.UsingDifferentToolsVersionFromProjectFile.ShouldBeFalse();
-
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/Instance/ProjectTaskInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectTaskInstance_Internal_Tests.cs
index 103589548de..808c0edc4a7 100644
--- a/src/Build.UnitTests/Instance/ProjectTaskInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectTaskInstance_Internal_Tests.cs
@@ -66,7 +66,7 @@ public void ProjectTaskInstanceCanSerializeViaTranslator(
             IDictionary<string, (string, MockElementLocation)> parameters,
             List<ProjectTaskInstanceChild> outputs)
         {
-            parameters = parameters ?? new Dictionary<string, (string, MockElementLocation)>();
+            parameters ??= new Dictionary<string, (string, MockElementLocation)>();
 
             var parametersCopy = new Dictionary<string, (string, ElementLocation)>(parameters.Count);
             foreach (var param in parameters)
diff --git a/src/Build.UnitTests/LoggerDescription_Tests.cs b/src/Build.UnitTests/LoggerDescription_Tests.cs
index 212f1eb7a07..1c22bf1362e 100644
--- a/src/Build.UnitTests/LoggerDescription_Tests.cs
+++ b/src/Build.UnitTests/LoggerDescription_Tests.cs
@@ -17,38 +17,30 @@ public class LoggerDescription_Tests
         [Fact]
         public void LoggerDescriptionCustomSerialization()
         {
-            string className = "Class";
-            string loggerAssemblyName = "Class";
-            string loggerFileAssembly = null;
-            string loggerSwitchParameters = "Class";
-            LoggerVerbosity verbosity = LoggerVerbosity.Detailed;
+            const string className = "Class";
+            const string loggerAssemblyName = "Class";
+            const string loggerFileAssembly = null;
+            const string loggerSwitchParameters = "Class";
+            const LoggerVerbosity verbosity = LoggerVerbosity.Detailed;
 
             LoggerDescription description = new LoggerDescription(className, loggerAssemblyName, loggerFileAssembly, loggerSwitchParameters, verbosity);
-            MemoryStream stream = new MemoryStream();
-            BinaryWriter writer = new BinaryWriter(stream);
-            BinaryReader reader = new BinaryReader(stream);
-            try
-            {
-                stream.Position = 0;
-                description.WriteToStream(writer);
-                long streamWriteEndPosition = stream.Position;
-                stream.Position = 0;
-                LoggerDescription description2 = new LoggerDescription();
-                description2.CreateFromStream(reader);
-                long streamReadEndPosition = stream.Position;
-                Assert.Equal(streamWriteEndPosition, streamReadEndPosition); // "Stream end positions should be equal"
+            using MemoryStream stream = new MemoryStream();
+            using BinaryWriter writer = new BinaryWriter(stream);
+            using BinaryReader reader = new BinaryReader(stream);
 
-                Assert.Equal(description.Verbosity, description2.Verbosity); // "Expected Verbosity to Match"
-                Assert.Equal(description.LoggerId, description2.LoggerId); // "Expected Verbosity to Match"
-                Assert.Equal(0, string.Compare(description.LoggerSwitchParameters, description2.LoggerSwitchParameters, StringComparison.OrdinalIgnoreCase)); // "Expected LoggerSwitchParameters to Match"
-                Assert.Equal(0, string.Compare(description.Name, description2.Name, StringComparison.OrdinalIgnoreCase)); // "Expected Name to Match"
-            }
-            finally
-            {
-                reader.Dispose();
-                writer = null;
-                stream = null;
-            }
+            stream.Position = 0;
+            description.WriteToStream(writer);
+            long streamWriteEndPosition = stream.Position;
+            stream.Position = 0;
+            LoggerDescription description2 = new LoggerDescription();
+            description2.CreateFromStream(reader);
+            long streamReadEndPosition = stream.Position;
+            Assert.Equal(streamWriteEndPosition, streamReadEndPosition); // "Stream end positions should be equal"
+
+            Assert.Equal(description.Verbosity, description2.Verbosity); // "Expected Verbosity to Match"
+            Assert.Equal(description.LoggerId, description2.LoggerId); // "Expected Verbosity to Match"
+            Assert.Equal(0, string.Compare(description.LoggerSwitchParameters, description2.LoggerSwitchParameters, StringComparison.OrdinalIgnoreCase)); // "Expected LoggerSwitchParameters to Match"
+            Assert.Equal(0, string.Compare(description.Name, description2.Name, StringComparison.OrdinalIgnoreCase)); // "Expected Name to Match"
         }
     }
 }
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index c36a51b66b8..fdeaf730a1b 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -28,8 +28,7 @@
     <ProjectReference Include="..\MSBuild\MSBuild.csproj" />
     <ProjectReference Include="..\MSBuildTaskHost\MSBuildTaskHost.csproj"
                       Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MonoBuild)' != 'true'"
-                      ReferenceOutputAssembly="false"
-                      OutputItemType="Content" />
+                      Aliases="MSBuildTaskHost" />
     <ProjectReference Include="..\Tasks\Microsoft.Build.Tasks.csproj" />
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
     <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
@@ -117,6 +116,9 @@
     <Compile Include="..\Shared\UnitTests\TestData\GlobbingTestData.cs">
       <Link>TestData\GlobbingTestData.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\UnitTests\ImmutableDictionary_Tests.cs" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MSBuildRuntimeType)' == 'Full' and '$(MonoBuild)' != 'true'">
+      <Link>ImmutableDictionary_Tests.cs</Link>
+    </Compile>
 
     <None Include="..\Shared\UnitTests\App.config">
       <Link>App.config</Link>
diff --git a/src/Build.UnitTests/Parser_Tests.cs b/src/Build.UnitTests/Parser_Tests.cs
index 39109849f2f..7a27e3463d2 100644
--- a/src/Build.UnitTests/Parser_Tests.cs
+++ b/src/Build.UnitTests/Parser_Tests.cs
@@ -26,9 +26,7 @@ public void SimpleParseTest()
         {
             Console.WriteLine("SimpleParseTest()");
             Parser p = new Parser();
-            GenericExpressionNode tree;
-
-            tree = p.Parse("$(foo)", ParserOptions.AllowAll, _elementLocation);
+            GenericExpressionNode tree = p.Parse("$(foo)", ParserOptions.AllowAll, _elementLocation);
 
 
             tree = p.Parse("$(foo)=='hello'", ParserOptions.AllowAll, _elementLocation);
@@ -77,9 +75,7 @@ public void ComplexParseTest()
         {
             Console.WriteLine("ComplexParseTest()");
             Parser p = new Parser();
-            GenericExpressionNode tree;
-
-            tree = p.Parse("$(foo)", ParserOptions.AllowAll, _elementLocation);
+            GenericExpressionNode tree = p.Parse("$(foo)", ParserOptions.AllowAll, _elementLocation);
 
 
             tree = p.Parse("($(foo) or $(bar)) and $(baz)", ParserOptions.AllowAll, _elementLocation);
@@ -107,8 +103,7 @@ public void NotParseTest()
         {
             Console.WriteLine("NegationParseTest()");
             Parser p = new Parser();
-            GenericExpressionNode tree;
-            tree = p.Parse("!true", ParserOptions.AllowAll, _elementLocation);
+            GenericExpressionNode tree = p.Parse("!true", ParserOptions.AllowAll, _elementLocation);
 
             tree = p.Parse("!(true)", ParserOptions.AllowAll, _elementLocation);
 
@@ -125,8 +120,7 @@ public void FunctionCallParseTest()
         {
             Console.WriteLine("FunctionCallParseTest()");
             Parser p = new Parser();
-            GenericExpressionNode tree;
-            tree = p.Parse("SimpleFunctionCall()", ParserOptions.AllowAll, _elementLocation);
+            GenericExpressionNode tree = p.Parse("SimpleFunctionCall()", ParserOptions.AllowAll, _elementLocation);
 
             tree = p.Parse("SimpleFunctionCall( 1234 )", ParserOptions.AllowAll, _elementLocation);
             tree = p.Parse("SimpleFunctionCall( true )", ParserOptions.AllowAll, _elementLocation);
@@ -141,9 +135,7 @@ public void ItemListParseTest()
             Console.WriteLine("FunctionCallParseTest()");
             Parser p = new Parser();
             GenericExpressionNode tree;
-            bool fExceptionCaught;
-
-            fExceptionCaught = false;
+            bool fExceptionCaught = false;
             try
             {
                 tree = p.Parse("@(foo) == 'a.cs;b.cs'", ParserOptions.AllowProperties, _elementLocation);
@@ -222,9 +214,7 @@ public void ItemFuncParseTest()
             Console.WriteLine("ItemFuncParseTest()");
 
             Parser p = new Parser();
-            GenericExpressionNode tree;
-
-            tree = p.Parse("@(item->foo('ab'))", 
+            GenericExpressionNode tree = p.Parse("@(item->foo('ab'))", 
                 ParserOptions.AllowProperties | ParserOptions.AllowItemLists, _elementLocation);
             Assert.IsType<StringExpressionNode>(tree);
             Assert.Equal("@(item->foo('ab'))", tree.GetUnexpandedValue(null));
@@ -244,9 +234,7 @@ public void MetadataParseTest()
             Console.WriteLine("FunctionCallParseTest()");
             Parser p = new Parser();
             GenericExpressionNode tree;
-            bool fExceptionCaught;
-
-            fExceptionCaught = false;
+            bool fExceptionCaught = false;
             try
             {
                 tree = p.Parse("%(foo) == 'a.cs;b.cs'", ParserOptions.AllowProperties | ParserOptions.AllowItemLists, _elementLocation);
diff --git a/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs b/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs
index fbb708842c8..d1c62096ca6 100644
--- a/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs
+++ b/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs
@@ -62,7 +62,6 @@ public static IEnumerable<object[]> GetProfilerResults()
                 {EvaluationLocation.CreateLocationForGlob(null, EvaluationPass.InitialProperties, "1", "myFile", 42, "glob description"),
                 new ProfiledLocation(TimeSpan.MaxValue, TimeSpan.MinValue, 2)}
             }) };
-
         }
     }
 }
diff --git a/src/Build.UnitTests/Scanner_Tests.cs b/src/Build.UnitTests/Scanner_Tests.cs
index a01cb72e605..204f5171d21 100644
--- a/src/Build.UnitTests/Scanner_Tests.cs
+++ b/src/Build.UnitTests/Scanner_Tests.cs
@@ -79,9 +79,7 @@ private void AdvanceToScannerError(Scanner lexer)
         [Fact]
         public void SingleEquals()
         {
-            Scanner lexer;
-
-            lexer = new Scanner("a=b", ParserOptions.AllowProperties);
+            Scanner lexer = new Scanner("a=b", ParserOptions.AllowProperties);
             AdvanceToScannerError(lexer);
             Assert.Equal("IllFormedEqualsInCondition", lexer.GetErrorResource());
             Assert.Equal("b", lexer.UnexpectedlyFound);
@@ -93,9 +91,7 @@ public void SingleEquals()
         [Fact]
         public void IllFormedProperty()
         {
-            Scanner lexer;
-
-            lexer = new Scanner("$(", ParserOptions.AllowProperties);
+            Scanner lexer = new Scanner("$(", ParserOptions.AllowProperties);
             AdvanceToScannerError(lexer);
             Assert.Equal("IllFormedPropertyCloseParenthesisInCondition", lexer.GetErrorResource());
 
@@ -110,9 +106,7 @@ public void IllFormedProperty()
         [Fact]
         public void IllFormedItemList()
         {
-            Scanner lexer;
-
-            lexer = new Scanner("@(", ParserOptions.AllowAll);
+            Scanner lexer = new Scanner("@(", ParserOptions.AllowAll);
             AdvanceToScannerError(lexer);
             Assert.Equal("IllFormedItemListCloseParenthesisInCondition", lexer.GetErrorResource());
             Assert.Null(lexer.UnexpectedlyFound);
@@ -150,9 +144,7 @@ public void IllFormedItemList()
         [Fact]
         public void IllFormedQuotedString()
         {
-            Scanner lexer;
-
-            lexer = new Scanner("false or 'abc", ParserOptions.AllowAll);
+            Scanner lexer = new Scanner("false or 'abc", ParserOptions.AllowAll);
             AdvanceToScannerError(lexer);
             Assert.Equal("IllFormedQuotedStringInCondition", lexer.GetErrorResource());
             Assert.Null(lexer.UnexpectedlyFound);
@@ -168,9 +160,7 @@ public void IllFormedQuotedString()
         [Fact]
         public void NumericSingleTokenTests()
         {
-            Scanner lexer;
-
-            lexer = new Scanner("1234", ParserOptions.AllowAll);
+            Scanner lexer = new Scanner("1234", ParserOptions.AllowAll);
             Assert.True(lexer.Advance());
             Assert.True(lexer.IsNext(Token.TokenType.Numeric));
             Assert.Equal(0, String.Compare("1234", lexer.IsNextString()));
@@ -295,9 +285,7 @@ public void SimpleSingleTokenTests()
         [Fact]
         public void StringEdgeTests()
         {
-            Scanner lexer;
-
-            lexer = new Scanner("@(Foo, ' ')", ParserOptions.AllowAll);
+            Scanner lexer = new Scanner("@(Foo, ' ')", ParserOptions.AllowAll);
             Assert.True(lexer.Advance() && lexer.IsNext(Token.TokenType.ItemList));
             Assert.True(lexer.Advance() && lexer.IsNext(Token.TokenType.EndOfInput));
 
@@ -321,9 +309,7 @@ public void StringEdgeTests()
         [Fact]
         public void FunctionTests()
         {
-            Scanner lexer;
-
-            lexer = new Scanner("Foo()", ParserOptions.AllowAll);
+            Scanner lexer = new Scanner("Foo()", ParserOptions.AllowAll);
             Assert.True(lexer.Advance() && lexer.IsNext(Token.TokenType.Function));
             Assert.Equal(0, String.Compare("Foo", lexer.IsNextString()));
             Assert.True(lexer.Advance() && lexer.IsNext(Token.TokenType.LeftParenthesis));
@@ -405,9 +391,7 @@ public void FunctionTests()
         [Fact]
         public void ComplexTests1()
         {
-            Scanner lexer;
-
-            lexer = new Scanner("'String with a $(Property) inside'", ParserOptions.AllowAll);
+            Scanner lexer = new Scanner("'String with a $(Property) inside'", ParserOptions.AllowAll);
             Assert.True(lexer.Advance() && lexer.IsNext(Token.TokenType.String));
             Assert.Equal(0, String.Compare("String with a $(Property) inside", lexer.IsNextString()));
 
@@ -523,9 +507,7 @@ public void WhitespaceTests()
         [Fact]
         public void ItemListTests()
         {
-            Scanner lexer;
-
-            lexer = new Scanner("@(foo)", ParserOptions.AllowProperties);
+            Scanner lexer = new Scanner("@(foo)", ParserOptions.AllowProperties);
             Assert.False(lexer.Advance());
             Assert.Equal(0, String.Compare(lexer.GetErrorResource(), "ItemListNotAllowedInThisConditional"));
 
@@ -545,9 +527,7 @@ public void ItemListTests()
         [Fact]
         public void NegativeTests()
         {
-            Scanner lexer;
-
-            lexer = new Scanner("'$(DEBUG) == true", ParserOptions.AllowAll);
+            Scanner lexer = new Scanner("'$(DEBUG) == true", ParserOptions.AllowAll);
             Assert.False(lexer.Advance());
         }
     }
diff --git a/src/Build.UnitTests/SolutionFileBuilder.cs b/src/Build.UnitTests/SolutionFileBuilder.cs
index 3b87e2044a5..2aa973078bd 100644
--- a/src/Build.UnitTests/SolutionFileBuilder.cs
+++ b/src/Build.UnitTests/SolutionFileBuilder.cs
@@ -112,7 +112,7 @@ public string BuildSolution()
                     Guid.NewGuid()
                         .ToString("B")));
 
-            if (SolutionDependencies != null && SolutionDependencies.Length > 0)
+            if (SolutionDependencies?.Length > 0)
             {
                 foreach (var (parent, dependency) in SolutionDependencies)
                 {
@@ -123,7 +123,7 @@ public string BuildSolution()
                 }
             }
 
-            if (SolutionDependenciesProjectNameToGuids!= null && SolutionDependenciesProjectNameToGuids.Length > 0)
+            if (SolutionDependenciesProjectNameToGuids?.Length > 0)
             {
                 foreach (var (parent, dependencyGuids) in SolutionDependenciesProjectNameToGuids)
                 {
@@ -132,7 +132,7 @@ public string BuildSolution()
                 }
             }
 
-            ProjectConfigurations = ProjectConfigurations ?? projectInfos.ToDictionary(
+            ProjectConfigurations ??= projectInfos.ToDictionary(
                 p => p.Key,
                 p => SolutionConfigurationPlatforms.ToDictionary(
                     sc => sc,
@@ -153,27 +153,27 @@ public string BuildSolution()
 
             foreach (var project in projectInfos.Values)
             {
-                sb.AppendLine($@"
-Project(""{project.ProjectTypeGuid}"") = ""{project.Name}"", ""{project.Path}"", ""{project.Guid}""");
+                sb.Append(@"
+Project(""").Append(project.ProjectTypeGuid).Append(@""") = """).Append(project.Name).Append(@""", """).Append(project.Path).Append(@""", """).Append(project.Guid).AppendLine(@"""");
 
                 if (project.Dependencies.Count > 0 || project.DependencyGuids.Count > 0)
                 {
-                    sb.AppendLine($"\tProjectSection(ProjectDependencies) = postProject");
+                    sb.AppendLine("\tProjectSection(ProjectDependencies) = postProject");
 
                     foreach (var dependency in project.Dependencies)
                     {
-                        sb.AppendLine($"\t\t{dependency.Guid} = {dependency.Guid}");
+                        sb.Append("\t\t").Append(dependency.Guid).Append(" = ").AppendLine(dependency.Guid);
                     }
 
                     foreach (var dependencyGuid in project.DependencyGuids)
                     {
-                        sb.AppendLine($"\t\t{dependencyGuid} = {dependencyGuid}");
+                        sb.Append("\t\t").Append(dependencyGuid).Append(" = ").AppendLine(dependencyGuid);
                     }
 
-                    sb.AppendLine($"\tEndProjectSection");
+                    sb.AppendLine("\tEndProjectSection");
                 }
 
-                sb.AppendLine($@"
+                sb.AppendLine(@"
 EndProject");
             }
 
@@ -183,7 +183,7 @@ public string BuildSolution()
 
             foreach (var solutionConfigurationPlatform in SolutionConfigurationPlatforms)
             {
-                sb.AppendLine($"\t\t{solutionConfigurationPlatform.FullName} = {solutionConfigurationPlatform.FullName}");
+                sb.Append("\t\t").Append(solutionConfigurationPlatform.FullName).Append(" = ").AppendLine(solutionConfigurationPlatform.FullName);
             }
 
             sb.AppendLine("\tEndGlobalSection");
@@ -196,8 +196,8 @@ public string BuildSolution()
                 {
                     var solutionConfiguration = configurationMapping.Key;
                     var projectConfiguration = configurationMapping.Value;
-                    sb.AppendLine($"\t\t{project.Value.Guid}.{solutionConfiguration.FullName}.ActiveCfg = {projectConfiguration.FullName}");
-                    sb.AppendLine($"\t\t{project.Value.Guid}.{solutionConfiguration.FullName}.Build.0 = {projectConfiguration.FullName}");
+                    sb.Append("\t\t").Append(project.Value.Guid).Append('.').Append(solutionConfiguration.FullName).Append(".ActiveCfg = ").AppendLine(projectConfiguration.FullName);
+                    sb.Append("\t\t").Append(project.Value.Guid).Append('.').Append(solutionConfiguration.FullName).Append(".Build.0 = ").AppendLine(projectConfiguration.FullName);
                 }
             }
 
diff --git a/src/Build.UnitTests/TargetsFile_Test.cs b/src/Build.UnitTests/TargetsFile_Test.cs
index 3719fff74ce..3efd05703f6 100644
--- a/src/Build.UnitTests/TargetsFile_Test.cs
+++ b/src/Build.UnitTests/TargetsFile_Test.cs
@@ -919,13 +919,12 @@ public void NoLinkMetadataSynthesisWhenDefinedInProject()
         [Fact]
         public void SynthesizeLinkMetadataForItemsOnWhitelist()
         {
-            string[] files = null;
             string outputPath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString("N"));
             string directoryToDelete = null;
 
             try
             {
-                files = Helpers.CreateFiles("class1.cs", "File1.txt", "Content1.foo", "a.proj");
+                string[] files = Helpers.CreateFiles("class1.cs", "File1.txt", "Content1.foo", "a.proj");
 
                 directoryToDelete = Path.GetDirectoryName(files[0]);
                 string subProjectDirectory = Path.Combine(Path.GetDirectoryName(files[0]), "SubFolder");
@@ -998,13 +997,12 @@ public void SynthesizeLinkMetadataForItemsOnWhitelist()
         [Fact]
         public void DontSynthesizeLinkMetadataIfPropertyNotSet()
         {
-            string[] files = null;
             string outputPath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString("N"));
             string directoryToDelete = null;
 
             try
             {
-                files = Helpers.CreateFiles("class1.cs", "File1.txt", "Content1.foo", "a.proj");
+                string[] files = Helpers.CreateFiles("class1.cs", "File1.txt", "Content1.foo", "a.proj");
 
                 directoryToDelete = Path.GetDirectoryName(files[0]);
                 string subProjectDirectory = Path.Combine(Path.GetDirectoryName(files[0]), "SubFolder");
diff --git a/src/Build.UnitTests/Utilities_Tests.cs b/src/Build.UnitTests/Utilities_Tests.cs
index f6c62d77ccd..2219cc6bb72 100644
--- a/src/Build.UnitTests/Utilities_Tests.cs
+++ b/src/Build.UnitTests/Utilities_Tests.cs
@@ -64,26 +64,6 @@ public void GetTextFromTextNodeWithXmlComment7()
             // Should get XML; note space after x added
             Assert.Equal("<!-- bar; baz; --><!-- bar --><x />", xmlContents);
         }
-
-        [Fact]
-        public void HandshakesDiffer()
-        {
-            int numHandshakeOptions = (int)Math.Pow(2, Enum.GetNames(typeof(HandshakeOptions)).Length - 1);
-            Dictionary<long, int> handshakes = new Dictionary<long, int>();
-            for (int i = 0; i < numHandshakeOptions; i++)
-            {
-                long nextKey = CommunicationsUtilities.GetHostHandshake((HandshakeOptions)i);
-                if (handshakes.TryGetValue(nextKey, out int collision))
-                {
-                    _output.WriteLine("There was a collision between {0} and {1}.", collision, i);
-                }
-                else
-                {
-                    handshakes.Add(nextKey, i);
-                }
-            }
-            handshakes.Count.ShouldBe(numHandshakeOptions, "two or more combinations of handshake options hashed to the same value");
-        }
     }
 
     public class UtilitiesTestReadOnlyLoad : UtilitiesTest
diff --git a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
index 6cde0e901df..9f5b6fa7f06 100644
--- a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
+++ b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
@@ -276,7 +276,6 @@ private string GetTestProject(bool? treatAllWarningsAsErrors = null, string warn
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ShouldCauseBuildFailure()
         {
-
             using (TestEnvironment env = TestEnvironment.Create(_output))
             {
                 TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
@@ -296,7 +295,6 @@ public void TaskReturnsFailureButDoesNotLogError_ShouldCauseBuildFailure()
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_WarnAndContinue()
         {
-
             using (TestEnvironment env = TestEnvironment.Create(_output))
             {
                 TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
@@ -319,7 +317,6 @@ public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_WarnAndContinue
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_True()
         {
-
             using (TestEnvironment env = TestEnvironment.Create(_output))
             {
                 TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
@@ -340,7 +337,6 @@ public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_True()
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_ErrorAndStop()
         {
-
             using (TestEnvironment env = TestEnvironment.Create(_output))
             {
                 TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
@@ -361,7 +357,6 @@ public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_ErrorAndStop()
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_False()
         {
-
             using (TestEnvironment env = TestEnvironment.Create(_output))
             {
                 TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 144ded7db93..a78e25f2103 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -816,10 +816,7 @@ public void EndBuild()
                     Reset();
                     _buildManagerState = BuildManagerState.Idle;
 
-                    if (_threadException != null)
-                    {
-                        _threadException.Throw();
-                    }
+                    _threadException?.Throw();
 
                     if (BuildParameters.DumpOpportunisticInternStats)
                     {
@@ -894,7 +891,7 @@ public GraphBuildResult Build(BuildParameters parameters, GraphBuildRequestData
         /// </summary>
         public void ShutdownAllNodes()
         {
-            if (null == _nodeManager)
+            if (_nodeManager == null)
             {
                 _nodeManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.NodeManager) as INodeManager;
             }
@@ -1294,7 +1291,7 @@ private void HandleExecuteSubmissionException(BuildSubmission submission, Except
         {
             if (ex is InvalidProjectFileException projectException)
             {
-                if (projectException.HasBeenLogged != true)
+                if (!projectException.HasBeenLogged)
                 {
                     BuildEventContext buildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
                     ((IBuildComponentHost)this).LoggingService.LogInvalidProjectFileError(buildEventContext, projectException);
@@ -1321,7 +1318,7 @@ private void HandleExecuteSubmissionException(GraphBuildSubmission submission, E
         {
             if (ex is InvalidProjectFileException projectException)
             {
-                if (projectException.HasBeenLogged != true)
+                if (!projectException.HasBeenLogged)
                 {
                     BuildEventContext buildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
                     ((IBuildComponentHost)this).LoggingService.LogInvalidProjectFileError(buildEventContext, projectException);
@@ -1373,7 +1370,7 @@ private void IssueBuildSubmissionToScheduler(BuildSubmission submission, bool al
                 InvalidProjectFileException projectException = ex as InvalidProjectFileException;
                 if (projectException != null)
                 {
-                    if (projectException.HasBeenLogged != true)
+                    if (!projectException.HasBeenLogged)
                     {
                         BuildEventContext projectBuildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
                         ((IBuildComponentHost)this).LoggingService.LogInvalidProjectFileError(projectBuildEventContext, projectException);
@@ -1529,7 +1526,7 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                     foreach (var innerException in aggregateException.InnerExceptions)
                     {
                         var projectException = (InvalidProjectFileException) innerException;
-                        if (projectException.HasBeenLogged != true)
+                        if (!projectException.HasBeenLogged)
                         {
                             BuildEventContext projectBuildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
                             ((IBuildComponentHost)this).LoggingService.LogInvalidProjectFileError(projectBuildEventContext, projectException);
@@ -1974,7 +1971,7 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)
                         {
                             NodeInfo createdNode = _nodeManager.CreateNode(GetNodeConfiguration(), response.RequiredNodeType);
 
-                            if (null != createdNode)
+                            if (createdNode != null)
                             {
                                 _noNodesActiveEvent.Reset();
                                 _activeNodes.Add(createdNode.NodeId);
@@ -2021,6 +2018,26 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)
             }
         }
 
+        internal bool CreateRarNode()
+        {
+            // If the _buildParametrs is not set, we are in OutOfProc mode, so continue
+            // Else check if users specified that he want to use multiple nodes, if so use RARaaS
+            if (_buildParameters?.MaxNodeCount == 1)
+                return false;
+
+            string nodeLocation = _buildParameters?.NodeExeLocation ?? BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
+            if (string.IsNullOrEmpty(nodeLocation))
+            {
+                // Couldn't find a path to MSBuild.exe; can't create a new node.
+                return false;
+            }
+
+            bool nodeReuse = _buildParameters?.EnableNodeReuse ?? true;
+            bool lowPriority = _buildParameters?.LowPriority ?? false;
+            string commandLineArgs = $"/nologo /nodemode:3 /nodeReuse:{nodeReuse} /low:{lowPriority}";
+            return NodeProviderOutOfProcBase.LaunchNode(nodeLocation, commandLineArgs) != -1;
+        }
+
         /// <summary>
         /// Completes a submission using the specified overall results.
         /// </summary>
@@ -2145,7 +2162,7 @@ private void CheckAllSubmissionsComplete(BuildRequestDataFlags? flags)
         /// </summary>
         private NodeConfiguration GetNodeConfiguration()
         {
-            if (null == _nodeConfiguration)
+            if (_nodeConfiguration == null)
             {
                 // Get the remote loggers
                 ILoggingService loggingService = ((IBuildComponentHost)this).GetComponent(BuildComponentType.LoggingService) as ILoggingService;
@@ -2367,7 +2384,7 @@ private static I ExpectPacketType<I>(INodePacket packet, NodePacketType expected
         /// </summary>
         private void SetOverallResultIfWarningsAsErrors(BuildResult result)
         {
-            if (result != null && result.OverallResult == BuildResultCode.Success)
+            if (result?.OverallResult == BuildResultCode.Success)
             {
                 ILoggingService loggingService = ((IBuildComponentHost)this).LoggingService;
 
diff --git a/src/Build/BackEnd/BuildManager/BuildRequestData.cs b/src/Build/BackEnd/BuildManager/BuildRequestData.cs
index 01423363653..4123d7e0922 100644
--- a/src/Build/BackEnd/BuildManager/BuildRequestData.cs
+++ b/src/Build/BackEnd/BuildManager/BuildRequestData.cs
@@ -291,7 +291,7 @@ public ProjectInstance ProjectInstance
         /// Whether the tools version used originated from an explicit specification,
         /// for example from an MSBuild task or /tv switch.
         /// </summary>
-        internal bool ExplicitToolsVersionSpecified => (ExplicitlySpecifiedToolsVersion != null);
+        internal bool ExplicitToolsVersionSpecified => ExplicitlySpecifiedToolsVersion != null;
 
         /// <summary>
         /// Returns the global properties as a dictionary.
diff --git a/src/Build/BackEnd/BuildManager/BuildSubmission.cs b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
index d6a02bd3650..3a53fbbf3ee 100644
--- a/src/Build/BackEnd/BuildManager/BuildSubmission.cs
+++ b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
@@ -200,7 +200,7 @@ private void CheckForCompletion()
                 {
                     _completionEvent.Set();
 
-                    if (null != _completionCallback)
+                    if (_completionCallback != null)
                     {
                         void Callback(object state)
                         {
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index 2cf6ea5f8ed..bd5d8815eb6 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -615,7 +615,7 @@ private void BuildRequestEntry_StateChanged(BuildRequestEntry entry, BuildReques
         private void RaiseRequestComplete(BuildRequest request, BuildResult result)
         {
             RequestCompleteDelegate requestComplete = OnRequestComplete;
-            if (null != requestComplete)
+            if (requestComplete != null)
             {
                 TraceEngine("RRC: Reporting result for request {0}({1}) (nr {2}).", request.GlobalRequestId, request.ConfigurationId, request.NodeRequestId);
                 requestComplete(request, result);
@@ -718,7 +718,7 @@ private void EvaluateRequestStates()
 
                     // This request is ready to be built
                     case BuildRequestEntryState.Ready:
-                        if (null == firstReadyEntry)
+                        if (firstReadyEntry == null)
                         {
                             firstReadyEntry = currentEntry;
                         }
@@ -747,9 +747,9 @@ private void EvaluateRequestStates()
             }
 
             // Update current engine status and start the next request, if applicable.
-            if (null == activeEntry)
+            if (activeEntry == null)
             {
-                if (null != firstReadyEntry)
+                if (firstReadyEntry != null)
                 {
                     // We are now active because we have an entry which is building.
                     ChangeStatus(BuildRequestEngineStatus.Active);
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
index 8446b48cae0..c8301762adc 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
@@ -192,7 +192,7 @@ public void WaitForConfiguration(BuildRequestConfiguration configuration)
         {
             ErrorUtilities.VerifyThrow(configuration.WasGeneratedByNode, "Configuration has already been resolved.");
 
-            _unresolvedConfigurationsToIssue = _unresolvedConfigurationsToIssue ?? new List<BuildRequestConfiguration>();
+            _unresolvedConfigurationsToIssue ??= new List<BuildRequestConfiguration>();
             _unresolvedConfigurationsToIssue.Add(configuration);
         }
 
@@ -230,7 +230,7 @@ public bool ResolveConfigurationRequest(int unresolvedConfigId, int configId)
         {
             lock (GlobalLock)
             {
-                if (_unresolvedConfigurations == null || !_unresolvedConfigurations.ContainsKey(unresolvedConfigId))
+                if (_unresolvedConfigurations?.ContainsKey(unresolvedConfigId) != true)
                 {
                     return false;
                 }
@@ -249,7 +249,7 @@ public bool ResolveConfigurationRequest(int unresolvedConfigId, int configId)
                     WaitForResult(request, false);
                 }
 
-                return (_unresolvedConfigurations == null);
+                return _unresolvedConfigurations == null;
             }
         }
 
@@ -369,7 +369,7 @@ public void ReportResult(BuildResult result)
                 if (addResults)
                 {
                     // Update the local results record
-                    _outstandingResults = _outstandingResults ?? new Dictionary<int, BuildResult>();
+                    _outstandingResults ??= new Dictionary<int, BuildResult>();
                     ErrorUtilities.VerifyThrow(!_outstandingResults.ContainsKey(result.NodeRequestId), "Request already contains results.");
                     _outstandingResults.Add(result.NodeRequestId, result);
                 }
@@ -508,7 +508,7 @@ private void WaitForResult(BuildRequest newRequest, bool addToIssueList)
 
                 if (newRequest.IsConfigurationResolved)
                 {
-                    _outstandingRequests = _outstandingRequests ?? new Dictionary<int, BuildRequest>();
+                    _outstandingRequests ??= new Dictionary<int, BuildRequest>();
 
                     ErrorUtilities.VerifyThrow(!_outstandingRequests.ContainsKey(newRequest.NodeRequestId), "Already waiting for local request {0}", newRequest.NodeRequestId);
                     _outstandingRequests.Add(newRequest.NodeRequestId, newRequest);
@@ -516,7 +516,7 @@ private void WaitForResult(BuildRequest newRequest, bool addToIssueList)
                 else
                 {
                     ErrorUtilities.VerifyThrow(addToIssueList, "Requests with unresolved configurations should always be added to the issue list.");
-                    _unresolvedConfigurations = _unresolvedConfigurations ?? new Dictionary<int, List<BuildRequest>>();
+                    _unresolvedConfigurations ??= new Dictionary<int, List<BuildRequest>>();
 
                     if (!_unresolvedConfigurations.ContainsKey(newRequest.ConfigurationId))
                     {
@@ -528,7 +528,7 @@ private void WaitForResult(BuildRequest newRequest, bool addToIssueList)
 
                 if (addToIssueList)
                 {
-                    _requestsToIssue = _requestsToIssue ?? new List<BuildRequest>();
+                    _requestsToIssue ??= new List<BuildRequest>();
                     _requestsToIssue.Add(newRequest);
                 }
 
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs b/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs
index dfc0b880b02..c7422949516 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs
@@ -24,6 +24,7 @@ internal class FullyQualifiedBuildRequest
         /// <param name="config">The configuration to use for the request.</param>
         /// <param name="targets">The set of targets to build.</param>
         /// <param name="resultsNeeded">Whether or not to wait for the results of this request.</param>
+        /// <param name="skipStaticGraphIsolationConstraints">Whether to skip the constraints of static graph isolation.</param>
         /// <param name="flags">Flags specified for the build request.</param>
         public FullyQualifiedBuildRequest(
             BuildRequestConfiguration config,
@@ -73,12 +74,12 @@ public FullyQualifiedBuildRequest(
         /// <returns>True if the objects are equivalent, false otherwise.</returns>
         public static bool operator ==(FullyQualifiedBuildRequest left, FullyQualifiedBuildRequest right)
         {
-            if (ReferenceEquals(left, null))
+            if (left is null)
             {
-                return ReferenceEquals(right, null);
+                return right is null;
             }
 
-            return !ReferenceEquals(right, null) && left.InternalEquals(right);
+            return !(right is null) && left.InternalEquals(right);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Caching/ConfigCache.cs b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
index 2645a3feba6..541abf197e4 100644
--- a/src/Build/BackEnd/Components/Caching/ConfigCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
@@ -72,7 +72,7 @@ public BuildRequestConfiguration this[int configId]
         /// <param name="config">The configuration to add.</param>
         public void AddConfiguration(BuildRequestConfiguration config)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(config, "config");
+            ErrorUtilities.VerifyThrowArgumentNull(config, nameof(config));
             ErrorUtilities.VerifyThrow(config.ConfigurationId != 0, "Invalid configuration ID");
 
             lock (_lockObject)
@@ -106,7 +106,7 @@ public void RemoveConfiguration(int configId)
         /// <returns>A matching configuration if one exists, null otherwise.</returns>
         public BuildRequestConfiguration GetMatchingConfiguration(BuildRequestConfiguration config)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(config, "config");
+            ErrorUtilities.VerifyThrowArgumentNull(config, nameof(config));
             return GetMatchingConfiguration(new ConfigurationMetadata(config));
         }
 
@@ -117,7 +117,7 @@ public BuildRequestConfiguration GetMatchingConfiguration(BuildRequestConfigurat
         /// <returns>A matching configuration if one exists, null otherwise.</returns>
         public BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata configMetadata)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(configMetadata, "configMetadata");
+            ErrorUtilities.VerifyThrowArgumentNull(configMetadata, nameof(configMetadata));
             lock (_lockObject)
             {
                 int configId;
@@ -207,8 +207,7 @@ public void ClearConfigurations()
         /// <returns>Set if configurations which have been cleared.</returns>
         public List<int> ClearNonExplicitlyLoadedConfigurations()
         {
-            List<int> configurationIdsCleared = null;
-            configurationIdsCleared = new List<int>();
+            List<int> configurationIdsCleared = new List<int>();
 
             Dictionary<int, BuildRequestConfiguration> configurationsToKeep = new Dictionary<int, BuildRequestConfiguration>();
             Dictionary<ConfigurationMetadata, int> configurationIdsByMetadataToKeep = new Dictionary<ConfigurationMetadata, int>();
@@ -328,7 +327,7 @@ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
         /// <param name="host">The build component host.</param>
         public void InitializeComponent(IBuildComponentHost host)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index 64db389a8ed..9ba79433501 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -230,10 +230,7 @@ public void ClearResultsForConfiguration(int configurationId)
                 BuildResult removedResult;
                 _resultsByConfiguration.TryRemove(configurationId, out removedResult);
 
-                if (removedResult != null)
-                {
-                    removedResult.ClearCachedFiles();
-                }
+                removedResult?.ClearCachedFiles();
             }
         }
 
@@ -277,7 +274,7 @@ public void WriteResultsToDisk()
         /// <param name="host">The component host.</param>
         public void InitializeComponent(IBuildComponentHost host)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
         }
 
         /// <summary>
@@ -315,7 +312,7 @@ private static bool CheckResults(BuildResult result, List<string> targets, HashS
             {
                 if (!result.HasResultsForTarget(target) || (result[target].ResultCode == TargetResultCode.Skipped && !skippedResultsAreOK))
                 {
-                    if (null != targetsMissingResults)
+                    if (targetsMissingResults != null)
                     {
                         targetsMissingResults.Add(target);
                         returnValue = false;
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
index 45b9dc30bf0..a8f9f39b37d 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
@@ -100,7 +100,7 @@ internal class NodeEndpointInProc : INodeEndpoint
         /// <param name="host">The component host.</param>
         private NodeEndpointInProc(EndpointMode commMode, IBuildComponentHost host)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
 
             _status = LinkStatus.Inactive;
             _mode = commMode;
@@ -161,7 +161,7 @@ public LinkStatus LinkStatus
         /// <param name="factory">Unused</param>
         public void Listen(INodePacketFactory factory)
         {
-            ErrorUtilities.VerifyThrowInternalNull(factory, "factory");
+            ErrorUtilities.VerifyThrowInternalNull(factory, nameof(factory));
             _packetFactory = factory;
 
             // Initialize our thread in async mode so we are ready when the Node-side endpoint "connects".
@@ -179,7 +179,7 @@ public void Listen(INodePacketFactory factory)
         /// <param name="factory">Unused</param>
         public void Connect(INodePacketFactory factory)
         {
-            ErrorUtilities.VerifyThrowInternalNull(factory, "factory");
+            ErrorUtilities.VerifyThrowInternalNull(factory, nameof(factory));
             _packetFactory = factory;
 
             // Set up asynchronous packet pump, if necessary.
@@ -252,7 +252,7 @@ internal static EndpointPair CreateInProcEndpoints(EndpointMode mode, IBuildComp
         /// <param name="newStatus">The new status of the endpoint link.</param>
         private void RaiseLinkStatusChanged(LinkStatus newStatus)
         {
-            if (null != OnLinkStatusChanged)
+            if (OnLinkStatusChanged != null)
             {
                 LinkStatusChangedDelegate linkStatusDelegate = OnLinkStatusChanged;
                 linkStatusDelegate(this, newStatus);
@@ -324,10 +324,10 @@ private void ChangeLinkStatus(LinkStatus newStatus)
         /// <param name="packet">The packet to be transmitted.</param>
         private void EnqueuePacket(INodePacket packet)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(packet, "packet");
+            ErrorUtilities.VerifyThrowArgumentNull(packet, nameof(packet));
             ErrorUtilities.VerifyThrow(_mode == EndpointMode.Asynchronous, "EndPoint mode is synchronous, should be asynchronous");
-            ErrorUtilities.VerifyThrow(null != _packetQueue, "packetQueue is null");
-            ErrorUtilities.VerifyThrow(null != _packetAvailable, "packetAvailable is null");
+            ErrorUtilities.VerifyThrow(_packetQueue != null, "packetQueue is null");
+            ErrorUtilities.VerifyThrow(_packetAvailable != null, "packetAvailable is null");
 
             _packetQueue.Enqueue(packet);
             _packetAvailable.Set();
@@ -340,10 +340,10 @@ private void InitializeAsyncPacketThread()
         {
             lock (_asyncDataMonitor)
             {
-                ErrorUtilities.VerifyThrow(null == _packetPump, "packetPump != null");
-                ErrorUtilities.VerifyThrow(null == _packetAvailable, "packetAvailable != null");
-                ErrorUtilities.VerifyThrow(null == _terminatePacketPump, "terminatePacketPump != null");
-                ErrorUtilities.VerifyThrow(null == _packetQueue, "packetQueue != null");
+                ErrorUtilities.VerifyThrow(_packetPump == null, "packetPump != null");
+                ErrorUtilities.VerifyThrow(_packetAvailable == null, "packetAvailable != null");
+                ErrorUtilities.VerifyThrow(_terminatePacketPump == null, "terminatePacketPump != null");
+                ErrorUtilities.VerifyThrow(_packetQueue == null, "packetQueue != null");
 
 #if FEATURE_THREAD_CULTURE
                 _packetPump = new Thread(PacketPumpProc);
@@ -377,10 +377,10 @@ private void TerminateAsyncPacketThread()
         {
             lock (_asyncDataMonitor)
             {
-                ErrorUtilities.VerifyThrow(null != _packetPump, "packetPump == null");
-                ErrorUtilities.VerifyThrow(null != _packetAvailable, "packetAvailable == null");
-                ErrorUtilities.VerifyThrow(null != _terminatePacketPump, "terminatePacketPump == null");
-                ErrorUtilities.VerifyThrow(null != _packetQueue, "packetQueue == null");
+                ErrorUtilities.VerifyThrow(_packetPump != null, "packetPump == null");
+                ErrorUtilities.VerifyThrow(_packetAvailable != null, "packetAvailable == null");
+                ErrorUtilities.VerifyThrow(_terminatePacketPump != null, "terminatePacketPump == null");
+                ErrorUtilities.VerifyThrow(_packetQueue != null, "packetQueue == null");
 
                 _terminatePacketPump.Set();
                 if (!_packetPump.Join((int)new TimeSpan(0, 0, BuildParameters.EndpointShutdownTimeout).TotalMilliseconds))
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
index a30017ca426..221e575ac3d 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
@@ -1,6 +1,7 @@
 Ôªø// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.BackEnd
@@ -31,13 +32,14 @@ internal class NodeEndpointOutOfProc : NodeEndpointOutOfProcBase
         /// <param name="pipeName">The name of the pipe to which we should connect.</param>
         /// <param name="host">The component host.</param>
         /// <param name="enableReuse">Whether this node may be reused for a later build.</param>
+        /// <param name="lowPriority">Whether this node is low priority.</param>
         internal NodeEndpointOutOfProc(
             string pipeName, 
             IBuildComponentHost host,
             bool enableReuse,
             bool lowPriority)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
             _componentHost = host;
             _enableReuse = enableReuse;
             _lowPriority = lowPriority;
@@ -50,17 +52,13 @@ internal NodeEndpointOutOfProc(
         /// <summary>
         /// Returns the host handshake for this node endpoint
         /// </summary>
-        protected override long GetHostHandshake()
+        protected override Handshake GetHandshake()
         {
-            return NodeProviderOutOfProc.GetHostHandshake(_enableReuse, _lowPriority);
-        }
-
-        /// <summary>
-        /// Returns the client handshake for this node endpoint
-        /// </summary>
-        protected override long GetClientHandshake()
-        {
-            return NodeProviderOutOfProc.GetClientHandshake(_enableReuse, _lowPriority);
+            return new Handshake(CommunicationsUtilities.GetHandshakeOptions(
+                taskHost: false,
+                is64Bit: EnvironmentUtilities.Is64BitProcess,
+                nodeReuse: _enableReuse,
+                lowPriority: _lowPriority));
         }
 
         #region Structs
diff --git a/src/Build/BackEnd/Components/Communications/NodeInfo.cs b/src/Build/BackEnd/Components/Communications/NodeInfo.cs
index b621994a31f..d94cccba51c 100644
--- a/src/Build/BackEnd/Components/Communications/NodeInfo.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeInfo.cs
@@ -87,19 +87,13 @@ public bool HasConfiguration(int configId)
         /// </summary>
         internal bool CanServiceRequestWithAffinity(NodeAffinity nodeAffinity)
         {
-            switch (nodeAffinity)
+            return nodeAffinity switch
             {
-                case NodeAffinity.Any:
-                    return true;
-
-                case NodeAffinity.InProc:
-                    return _providerType == NodeProviderType.InProc;
-
-                case NodeAffinity.OutOfProc:
-                    return _providerType != NodeProviderType.InProc;
-            }
-
-            return true;
+                NodeAffinity.Any => true,
+                NodeAffinity.InProc => _providerType == NodeProviderType.InProc,
+                NodeAffinity.OutOfProc => _providerType != NodeProviderType.InProc,
+                _ => true,
+            };
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/Communications/NodeManager.cs b/src/Build/BackEnd/Components/Communications/NodeManager.cs
index e0c45681ff0..79358a223fb 100644
--- a/src/Build/BackEnd/Components/Communications/NodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeManager.cs
@@ -132,7 +132,7 @@ public NodeInfo CreateNode(NodeConfiguration configuration, NodeAffinity nodeAff
         public void SendData(int node, INodePacket packet)
         {
             // Look up the node provider for this node in the mapping.
-            INodeProvider provider = null;
+            INodeProvider provider;
             if (!_nodeIdToProvider.TryGetValue(node, out provider))
             {
                 ErrorUtilities.ThrowInternalError("Node {0} does not have a provider.", node);
@@ -156,16 +156,8 @@ public void ShutdownConnectedNodes(bool enableReuse)
             }
 
             _nodesShutdown = true;
-
-            if (null != _inProcNodeProvider)
-            {
-                _inProcNodeProvider.ShutdownConnectedNodes(enableReuse);
-            }
-
-            if (null != _outOfProcNodeProvider)
-            {
-                _outOfProcNodeProvider.ShutdownConnectedNodes(enableReuse);
-            }
+            _inProcNodeProvider?.ShutdownConnectedNodes(enableReuse);
+            _outOfProcNodeProvider?.ShutdownConnectedNodes(enableReuse);
         }
 
         /// <summary>
@@ -174,10 +166,7 @@ public void ShutdownConnectedNodes(bool enableReuse)
         public void ShutdownAllNodes()
         {
             // don't worry about inProc
-            if (null != _outOfProcNodeProvider)
-            {
-                _outOfProcNodeProvider.ShutdownAllNodes();
-            }
+            _outOfProcNodeProvider?.ShutdownAllNodes();
         }
 
         #endregion
@@ -325,7 +314,7 @@ private void RemoveNodeFromMapping(int nodeId)
         private int AttemptCreateNode(INodeProvider nodeProvider, NodeConfiguration nodeConfiguration)
         {
             // If no provider was passed in, we obviously can't create a node.
-            if (null == nodeProvider)
+            if (nodeProvider == null)
             {
                 ErrorUtilities.ThrowInternalError("No node provider provided.");
                 return InvalidNodeId;
@@ -338,8 +327,7 @@ private int AttemptCreateNode(INodeProvider nodeProvider, NodeConfiguration node
             }
 
             // Assign a global ID to the node we are about to create.
-            int nodeId = InvalidNodeId;
-
+            int nodeId;
             if (nodeProvider is NodeProviderInProc)
             {
                 nodeId = _inprocNodeId;
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
index 8bfc4cd604e..0081265b99c 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
@@ -151,9 +151,9 @@ public void ShutdownComponent()
         public void SendData(int nodeId, INodePacket packet)
         {
             ErrorUtilities.VerifyThrowArgumentOutOfRange(nodeId == _inProcNodeId, "node");
-            ErrorUtilities.VerifyThrowArgumentNull(packet, "packet");
+            ErrorUtilities.VerifyThrowArgumentNull(packet, nameof(packet));
 
-            if (null == _inProcNode)
+            if (_inProcNode == null)
             {
                 return;
             }
@@ -167,7 +167,7 @@ public void SendData(int nodeId, INodePacket packet)
         /// <param name="enableReuse">Flag indicating if the nodes should prepare for reuse.</param>
         public void ShutdownConnectedNodes(bool enableReuse)
         {
-            if (null != _inProcNode)
+            if (_inProcNode != null)
             {
                 _inProcNodeEndpoint.SendData(new NodeBuildComplete(enableReuse));
             }
@@ -333,8 +333,8 @@ static internal IBuildComponent CreateComponent(BuildComponentType type)
         /// </summary>
         private bool InstantiateNode(INodePacketFactory factory)
         {
-            ErrorUtilities.VerifyThrow(null == _inProcNode, "In Proc node already instantiated.");
-            ErrorUtilities.VerifyThrow(null == _inProcNodeEndpoint, "In Proc node endpoint already instantiated.");
+            ErrorUtilities.VerifyThrow(_inProcNode == null, "In Proc node already instantiated.");
+            ErrorUtilities.VerifyThrow(_inProcNodeEndpoint == null, "In Proc node endpoint already instantiated.");
 
             NodeEndpointInProc.EndpointPair endpoints = NodeEndpointInProc.CreateInProcEndpoints(NodeEndpointInProc.EndpointMode.Synchronous, _componentHost);
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
index 63ca1cadc74..50ca0c90a01 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
@@ -63,19 +63,11 @@ public int AvailableNodes
         /// </summary>
         /// <param name="enableNodeReuse">Is reuse of build nodes allowed?</param>
         /// <param name="enableLowPriority">Is the build running at low priority?</param>
-        internal static long GetHostHandshake(bool enableNodeReuse, bool enableLowPriority)
+        /// <param name="specialNode">/Indicates if node can not accept standard MSBuild work</param>
+        internal static Handshake GetHandshake(bool enableNodeReuse, bool enableLowPriority, bool specialNode)
         {
             CommunicationsUtilities.Trace("MSBUILDNODEHANDSHAKESALT=\"{0}\", msbuildDirectory=\"{1}\", enableNodeReuse={2}, enableLowPriority={3}", Traits.MSBuildNodeHandshakeSalt, BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32, enableNodeReuse, enableLowPriority);
-            return CommunicationsUtilities.GetHostHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableNodeReuse, lowPriority: enableLowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
-        }
-
-        /// <summary>
-        /// Magic number sent by the client to the host during the handshake.
-        /// Munged version of the host handshake.
-        /// </summary>
-        internal static long GetClientHandshake(bool enableNodeReuse, bool enableLowPriority)
-        {
-            return CommunicationsUtilities.GetClientHandshake(CommunicationsUtilities.GetHandshakeOptions(false, nodeReuse: enableNodeReuse, lowPriority: enableLowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
+            return new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableNodeReuse, lowPriority: enableLowPriority, specialNode: specialNode, is64Bit: EnvironmentUtilities.Is64BitProcess));
         }
 
         /// <summary>
@@ -83,7 +75,7 @@ internal static long GetClientHandshake(bool enableNodeReuse, bool enableLowPrio
         /// </summary>
         public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration configuration)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(factory, "factory");
+            ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
 
             if (_nodeContexts.Count == ComponentHost.BuildParameters.MaxNodeCount)
             {
@@ -100,10 +92,10 @@ public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration
             // Make it here.
             CommunicationsUtilities.Trace("Starting to acquire a new or existing node to establish node ID {0}...", nodeId);
 
-            long hostHandShake = NodeProviderOutOfProc.GetHostHandshake(ComponentHost.BuildParameters.EnableNodeReuse, ComponentHost.BuildParameters.LowPriority);
-            NodeContext context = GetNode(null, commandLineArgs, nodeId, factory, hostHandShake, NodeProviderOutOfProc.GetClientHandshake(ComponentHost.BuildParameters.EnableNodeReuse, ComponentHost.BuildParameters.LowPriority), NodeContextTerminated);
+            Handshake hostHandshake = new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: ComponentHost.BuildParameters.EnableNodeReuse, lowPriority: ComponentHost.BuildParameters.LowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
+            NodeContext context = GetNode(null, commandLineArgs, nodeId, factory, hostHandshake, NodeContextTerminated);
 
-            if (null != context)
+            if (context != null)
             {
                 _nodeContexts[nodeId] = context;
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 3b69a13427a..8a681683154 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -8,18 +8,19 @@
 using System.IO.Pipes;
 using System.Diagnostics;
 using System.Threading;
+using System.Threading.Tasks;
 using System.Runtime.InteropServices;
 using System.Security.Principal;
 
-using Microsoft.Build.Shared;
+using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Internal;
-
-using BackendNativeMethods = Microsoft.Build.BackEnd.NativeMethods;
-using System.Threading.Tasks;
+using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
+using BackendNativeMethods = Microsoft.Build.BackEnd.NativeMethods;
+
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
@@ -75,7 +76,7 @@ protected IBuildComponentHost ComponentHost
         /// <param name="packet">The packet to send.</param>
         protected void SendData(NodeContext context, INodePacket packet)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(packet, "packet");
+            ErrorUtilities.VerifyThrowArgumentNull(packet, nameof(packet));
             context.SendData(packet);
         }
 
@@ -91,19 +92,14 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool
 
             foreach (NodeContext nodeContext in contextsToShutDown)
             {
-                if (null != nodeContext)
-                {
-                    nodeContext.SendData(new NodeBuildComplete(enableReuse));
-                }
+                nodeContext?.SendData(new NodeBuildComplete(enableReuse));
             }
         }
 
         /// <summary>
         /// Shuts down all of the managed nodes permanently.
         /// </summary>
-        /// <param name="hostHandshake">host handshake key</param>
-        /// <param name="hostHandshakeWithLowPriority">host handshake key with low priority added</param>
-        /// <param name="clientHandshake">client handshake key</param>
+        /// <param name="nodeReuse">Whether to reuse the node</param>
         /// <param name="terminateNode">Delegate used to tell the node provider that a context has terminated</param>
         protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate terminateNode)
         {
@@ -125,15 +121,18 @@ protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate ter
                 int timeout = 30;
 
                 // Attempt to connect to the process with the handshake without low priority.
-                Stream nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHostHandshake(nodeReuse, false), NodeProviderOutOfProc.GetClientHandshake(nodeReuse, false));
+                Stream nodeStream = NamedPipeUtil.TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHandshake(nodeReuse, enableLowPriority: false, specialNode: false));
 
-                if (null == nodeStream)
-                {
-                    // If we couldn't connect attempt to connect to the process with the handshake including low priority.
-                    nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHostHandshake(nodeReuse, true), NodeProviderOutOfProc.GetClientHandshake(nodeReuse, true));
-                }
+                // If we couldn't connect attempt to connect to the process with the handshake including low priority.
+                nodeStream ??= NamedPipeUtil.TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHandshake(nodeReuse, enableLowPriority: true, specialNode: false));
+
+                // Attempt to connect to the non-worker process
+                // Attempt to connect to the process with the handshake without low priority.
+                nodeStream ??= NamedPipeUtil.TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHandshake(nodeReuse, enableLowPriority: false, specialNode: true));
+                // If we couldn't connect attempt to connect to the process with the handshake including low priority.
+                nodeStream ??= NamedPipeUtil.TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHandshake(nodeReuse, enableLowPriority: true, specialNode: true));
 
-                if (null != nodeStream)
+                if (nodeStream != null)
                 {
                     // If we're able to connect to such a process, send a packet requesting its termination
                     CommunicationsUtilities.Trace("Shutting down node with pid = {0}", nodeProcess.Id);
@@ -148,7 +147,7 @@ protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate ter
         /// Finds or creates a child process which can act as a node.
         /// </summary>
         /// <returns>The pipe stream representing the node.</returns>
-        protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, int nodeId, INodePacketFactory factory, long hostHandshake, long clientHandshake, NodeContextTerminateDelegate terminateNode)
+        protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, int nodeId, INodePacketFactory factory, Handshake hostHandshake, NodeContextTerminateDelegate terminateNode)
         {
 #if DEBUG
             if (Execution.BuildManager.WaitForDebugger)
@@ -188,7 +187,7 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
                     }
 
                     // Get the full context of this inspection so that we can always skip this process when we have the same taskhost context
-                    string nodeLookupKey = GetProcessesToIgnoreKey(hostHandshake, clientHandshake, nodeProcess.Id);
+                    string nodeLookupKey = GetProcessesToIgnoreKey(hostHandshake, nodeProcess.Id);
                     if (_processesToIgnore.Contains(nodeLookupKey))
                     {
                         continue;
@@ -198,7 +197,7 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
                     _processesToIgnore.Add(nodeLookupKey);
 
                     // Attempt to connect to each process in turn.
-                    Stream nodeStream = TryConnectToProcess(nodeProcess.Id, 0 /* poll, don't wait for connections */, hostHandshake, clientHandshake);
+                    Stream nodeStream = NamedPipeUtil.TryConnectToProcess(nodeProcess.Id, 0 /* poll, don't wait for connections */, hostHandshake);
                     if (nodeStream != null)
                     {
                         // Connection successful, use this node.
@@ -242,14 +241,14 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
 
                 // Create the node process
                 int msbuildProcessId = LaunchNode(msbuildLocation, commandLineArgs);
-                _processesToIgnore.Add(GetProcessesToIgnoreKey(hostHandshake, clientHandshake, msbuildProcessId));
+                _processesToIgnore.Add(GetProcessesToIgnoreKey(hostHandshake, msbuildProcessId));
 
                 // Note, when running under IMAGEFILEEXECUTIONOPTIONS registry key to debug, the process ID
                 // gotten back from CreateProcess is that of the debugger, which causes this to try to connect
                 // to the debugger process. Instead, use MSBUILDDEBUGONSTART=1
 
                 // Now try to connect to it.
-                Stream nodeStream = TryConnectToProcess(msbuildProcessId, TimeoutForNewNodeCreation, hostHandshake, clientHandshake);
+                Stream nodeStream = NamedPipeUtil.TryConnectToProcess(msbuildProcessId, TimeoutForNewNodeCreation, hostHandshake);
                 if (nodeStream != null)
                 {
                     // Connection successful, use this node.
@@ -292,111 +291,18 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
         /// Generate a string from task host context and the remote process to be used as key to lookup processes we have already
         /// attempted to connect to or are already connected to
         /// </summary>
-        private string GetProcessesToIgnoreKey(long hostHandshake, long clientHandshake, int nodeProcessId)
-        {
-            return hostHandshake.ToString(CultureInfo.InvariantCulture) + "|" + clientHandshake.ToString(CultureInfo.InvariantCulture) + "|" + nodeProcessId.ToString(CultureInfo.InvariantCulture);
-        }
-
-#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-        //  This code needs to be in a separate method so that we don't try (and fail) to load the Windows-only APIs when JIT-ing the code
-        //  on non-Windows operating systems
-        private void ValidateRemotePipeSecurityOnWindows(NamedPipeClientStream nodeStream)
+        private string GetProcessesToIgnoreKey(Handshake hostHandshake, int nodeProcessId)
         {
-            SecurityIdentifier identifier = WindowsIdentity.GetCurrent().Owner;
-#if FEATURE_PIPE_SECURITY
-            PipeSecurity remoteSecurity = nodeStream.GetAccessControl();
-#else
-            var remoteSecurity = new PipeSecurity(nodeStream.SafePipeHandle, System.Security.AccessControl.AccessControlSections.Access |
-                System.Security.AccessControl.AccessControlSections.Owner | System.Security.AccessControl.AccessControlSections.Group);
-#endif
-            IdentityReference remoteOwner = remoteSecurity.GetOwner(typeof(SecurityIdentifier));
-            if (remoteOwner != identifier)
-            {
-                CommunicationsUtilities.Trace("The remote pipe owner {0} does not match {1}", remoteOwner.Value, identifier.Value);
-                throw new UnauthorizedAccessException();
-            }
-        }
-#endif
-
-        /// <summary>
-        /// Attempts to connect to the specified process.
-        /// </summary>
-        private Stream TryConnectToProcess(int nodeProcessId, int timeout, long hostHandshake, long clientHandshake)
-        {
-            // Try and connect to the process.
-            string pipeName = NamedPipeUtil.GetPipeNameOrPath("MSBuild" + nodeProcessId);
-
-            NamedPipeClientStream nodeStream = new NamedPipeClientStream(".", pipeName, PipeDirection.InOut, PipeOptions.Asynchronous
-#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-                                                                         | PipeOptions.CurrentUserOnly
-#endif
-                                                                         );
-            CommunicationsUtilities.Trace("Attempting connect to PID {0} with pipe {1} with timeout {2} ms", nodeProcessId, pipeName, timeout);
-
-            try
-            {
-                nodeStream.Connect(timeout);
-
-#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-                if (NativeMethodsShared.IsWindows && !NativeMethodsShared.IsMono)
-                {
-                    // Verify that the owner of the pipe is us.  This prevents a security hole where a remote node has
-                    // been faked up with ACLs that would let us attach to it.  It could then issue fake build requests back to
-                    // us, potentially causing us to execute builds that do harmful or unexpected things.  The pipe owner can
-                    // only be set to the user's own SID by a normal, unprivileged process.  The conditions where a faked up
-                    // remote node could set the owner to something else would also let it change owners on other objects, so
-                    // this would be a security flaw upstream of us.
-                    ValidateRemotePipeSecurityOnWindows(nodeStream);
-
-                }
-#endif
-
-                CommunicationsUtilities.Trace("Writing handshake to pipe {0}", pipeName);
-                nodeStream.WriteLongForHandshake(hostHandshake);
-
-                CommunicationsUtilities.Trace("Reading handshake from pipe {0}", pipeName);
-#if NETCOREAPP2_1 || MONO
-                long handshake = nodeStream.ReadLongForHandshake(timeout);
-#else
-                long handshake = nodeStream.ReadLongForHandshake();
-#endif
-
-                if (handshake != clientHandshake)
-                {
-                    CommunicationsUtilities.Trace("Handshake failed. Received {0} from client not {1}. Probably the client is a different MSBuild build.", handshake, clientHandshake);
-                    throw new InvalidOperationException();
-                }
-
-                // We got a connection.
-                CommunicationsUtilities.Trace("Successfully connected to pipe {0}...!", pipeName);
-                return nodeStream;
-            }
-            catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
-            {
-                // Can be:
-                // UnauthorizedAccessException -- Couldn't connect, might not be a node.
-                // IOException -- Couldn't connect, already in use.
-                // TimeoutException -- Couldn't connect, might not be a node.
-                // InvalidOperationException ‚Äì Couldn‚Äôt connect, probably a different build
-                CommunicationsUtilities.Trace("Failed to connect to pipe {0}. {1}", pipeName, e.Message.TrimEnd());
-
-                // If we don't close any stream, we might hang up the child
-                if (nodeStream != null)
-                {
-                    nodeStream.Dispose();
-                }
-            }
-
-            return null;
+            return hostHandshake.ToString() + "|" + nodeProcessId.ToString(CultureInfo.InvariantCulture);
         }
 
         /// <summary>
         /// Creates a new MSBuild process
         /// </summary>
-        private int LaunchNode(string msbuildLocation, string commandLineArgs)
+        internal static int LaunchNode(string msbuildLocation, string commandLineArgs)
         {
             // Should always have been set already.
-            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, "msbuildLocation");
+            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));
 
             if (!FileSystems.Default.FileExists(msbuildLocation))
             {
@@ -429,12 +335,12 @@ private int LaunchNode(string msbuildLocation, string commandLineArgs)
                     startInfo.hStdInput = BackendNativeMethods.InvalidHandle;
                     startInfo.hStdOutput = BackendNativeMethods.InvalidHandle;
                     startInfo.dwFlags = BackendNativeMethods.STARTFUSESTDHANDLES;
-                    creationFlags = creationFlags | BackendNativeMethods.CREATENOWINDOW;
+                    creationFlags |= BackendNativeMethods.CREATENOWINDOW;
                 }
             }
             else
             {
-                creationFlags = creationFlags | BackendNativeMethods.CREATE_NEW_CONSOLE;
+                creationFlags |= BackendNativeMethods.CREATE_NEW_CONSOLE;
             }
 
             BackendNativeMethods.SECURITY_ATTRIBUTES processSecurityAttributes = new BackendNativeMethods.SECURITY_ATTRIBUTES();
@@ -458,7 +364,6 @@ private int LaunchNode(string msbuildLocation, string commandLineArgs)
 
             if (!NativeMethodsShared.IsWindows)
             {
-
                 ProcessStartInfo processStartInfo = new ProcessStartInfo();
                 processStartInfo.FileName = exeName;
                 processStartInfo.Arguments = commandLineArgs;
@@ -829,7 +734,7 @@ private bool ProcessHeaderBytesRead(int bytesRead)
                     try
                     {
                         Process childProcess = Process.GetProcessById(_processId);
-                        if (childProcess == null || childProcess.HasExited)
+                        if (childProcess?.HasExited != false)
                         {
                             CommunicationsUtilities.Trace(_nodeId, "   Child Process {0} has exited.", _processId);
                         }
@@ -887,6 +792,7 @@ private void HeaderReadComplete(IAsyncResult result)
                 }
 
                 int packetLength = BitConverter.ToInt32(_headerByte, 1);
+                MSBuildEventSource.Log.PacketReadSize(packetLength);
 
                 byte[] packetData;
                 if (packetLength < _smallReadBuffer.Length)
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index 44a2de9a749..ef746ed27d7 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -200,16 +200,7 @@ public void ShutdownConnectedNodes(bool enableReuse)
         /// </summary>
         public void ShutdownAllNodes()
         {
-            bool nodeReuse = ComponentHost.BuildParameters.EnableNodeReuse;
-
-            // To avoid issues with mismatched priorities not shutting
-            // down all the nodes on exit, we will attempt to shutdown
-            // all matching notes with and without the priroity bit set.
-            // So precompute both versions of the handshake now.
-            long hostHandshake = NodeProviderOutOfProc.GetHostHandshake(nodeReuse, enableLowPriority: false);
-            long hostHandshakeWithLow = NodeProviderOutOfProc.GetHostHandshake(nodeReuse, enableLowPriority: true);
-
-            ShutdownAllNodes(nodeReuse, NodeContextTerminated);
+            ShutdownAllNodes(ComponentHost.BuildParameters.EnableNodeReuse, NodeContextTerminated);
         }
         #endregion
 
@@ -462,10 +453,9 @@ internal static string GetMSBuildLocationFromHostContext(HandshakeOptions hostCo
         /// </summary>
         internal bool AcquireAndSetUpHost(HandshakeOptions hostContext, INodePacketFactory factory, INodePacketHandler handler, TaskHostConfiguration configuration)
         {
-            NodeContext context = null;
-            bool nodeCreationSucceeded = false;
-
-            if (!(_nodeContexts.TryGetValue(hostContext, out context)))
+            NodeContext context;
+            bool nodeCreationSucceeded;
+            if (!_nodeContexts.TryGetValue(hostContext, out context))
             {
                 nodeCreationSucceeded = CreateNode(hostContext, factory, handler, configuration);
             }
@@ -505,7 +495,7 @@ internal void DisconnectFromHost(HandshakeOptions hostContext)
         /// </summary>
         internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factory, INodePacketHandler handler, TaskHostConfiguration configuration)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(factory, "factory");
+            ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
             ErrorUtilities.VerifyThrow(!_nodeIdToPacketFactory.ContainsKey((int)hostContext), "We should not already have a factory for this context!  Did we forget to call DisconnectFromHost somewhere?");
 
             if (AvailableNodes == 0)
@@ -535,12 +525,11 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor
                                         commandLineArgs,
                                         (int)hostContext,
                                         this,
-                                        CommunicationsUtilities.GetHostHandshake(hostContext),
-                                        CommunicationsUtilities.GetClientHandshake(hostContext),
+                                        new Handshake(hostContext),
                                         NodeContextTerminated
                                     );
 
-            if (null != context)
+            if (context != null)
             {
                 _nodeContexts[hostContext] = context;
 
diff --git a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
index 835e24a7c6a..949c39b4720 100644
--- a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
@@ -73,11 +73,7 @@ public void SendData(int node, INodePacket packet)
         public void ShutdownConnectedNodes(bool enableReuse)
         {
             ErrorUtilities.VerifyThrow(!_componentShutdown, "We should never be calling ShutdownNodes after ShutdownComponent has been called");
-
-            if (null != _outOfProcTaskHostNodeProvider)
-            {
-                _outOfProcTaskHostNodeProvider.ShutdownConnectedNodes(enableReuse);
-            }
+            _outOfProcTaskHostNodeProvider?.ShutdownConnectedNodes(enableReuse);
         }
 
         /// <summary>
@@ -85,10 +81,7 @@ public void ShutdownConnectedNodes(bool enableReuse)
         /// </summary>
         public void ShutdownAllNodes()
         {
-            if (null != _outOfProcTaskHostNodeProvider)
-            {
-                _outOfProcTaskHostNodeProvider.ShutdownAllNodes();
-            }
+            _outOfProcTaskHostNodeProvider?.ShutdownAllNodes();
         }
         #endregion
 
diff --git a/src/Build/BackEnd/Components/IBuildComponentHost.cs b/src/Build/BackEnd/Components/IBuildComponentHost.cs
index 6e18d9ec4ef..4e57c5f2ae1 100644
--- a/src/Build/BackEnd/Components/IBuildComponentHost.cs
+++ b/src/Build/BackEnd/Components/IBuildComponentHost.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.BackEnd
     internal delegate IBuildComponent BuildComponentFactoryDelegate(BuildComponentType type);
 
     /// <summary>
-    /// An enumeration of all component types recognized by the system    
+    /// An enumeration of all component types recognized by the system
     /// </summary>
     internal enum BuildComponentType
     {
@@ -95,7 +95,7 @@ internal enum BuildComponentType
         RequestBuilder,
 
         /// <summary>
-        /// The component responsible for building targets.        
+        /// The component responsible for building targets.
         /// </summary>
         TargetBuilder,
 
diff --git a/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs b/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs
index 835fd726971..7bfc4b0670c 100644
--- a/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs
+++ b/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs
@@ -81,7 +81,7 @@ public void Initialize(IEventSource eventSource, int nodeCount)
         public void Initialize(IEventSource eventSource)
         {
             ErrorUtilities.VerifyThrow(eventSource != null, "eventSource is null");
-            eventSource.AnyEventRaised += new AnyEventHandler(EventSource_AnyEventRaised);
+            eventSource.AnyEventRaised += EventSource_AnyEventRaised;
 
             IEventSource2 eventSource2 = eventSource as IEventSource2;
             if (eventSource2 != null)
@@ -114,10 +114,7 @@ private void EventSource_AnyEventRaised(object sender, BuildEventArgs buildEvent
             // If no central logger was registered with the system
             // there will not be a build event redirector as there is 
             // nowhere to forward the events to.
-            if (BuildEventRedirector != null)
-            {
-                BuildEventRedirector.ForwardEvent(buildEvent);
-            }
+            BuildEventRedirector?.ForwardEvent(buildEvent);
         }
 
         #endregion
diff --git a/src/Build/BackEnd/Components/Logging/ForwardingLoggerRecord.cs b/src/Build/BackEnd/Components/Logging/ForwardingLoggerRecord.cs
index 3e38bab3cb8..a44a9aec7b8 100644
--- a/src/Build/BackEnd/Components/Logging/ForwardingLoggerRecord.cs
+++ b/src/Build/BackEnd/Components/Logging/ForwardingLoggerRecord.cs
@@ -23,7 +23,7 @@ public class ForwardingLoggerRecord
         public ForwardingLoggerRecord(ILogger centralLogger, LoggerDescription forwardingLoggerDescription)
         {
             // The logging service allows a null central logger, so we don't check for it here.
-            ErrorUtilities.VerifyThrowArgumentNull(forwardingLoggerDescription, "forwardingLoggerDescription");
+            ErrorUtilities.VerifyThrowArgumentNull(forwardingLoggerDescription, nameof(forwardingLoggerDescription));
 
             this.CentralLogger = centralLogger;
             this.ForwardingLoggerDescription = forwardingLoggerDescription;
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index 04b7ac6c238..02fdef8be56 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -202,14 +202,14 @@ bool IncludeTaskInputs
         /// <summary>
         /// Adds a set of warning codes to treat as low importance messages for the specified project instance ID.
         /// </summary>
-        /// <param name="projectInstanceId">A <see cref="BuildEventContext.ProjectInstanceId"/> to associate with the list of warning codes.</param>
+        /// <param name="buildEventContext">A <see cref="BuildEventContext"/> to associate with the list of warning codes.</param>
         /// <param name="codes">The list of warning codes to treat as low importance messsages.</param>
         void AddWarningsAsMessages(BuildEventContext buildEventContext, ISet<string> codes);
 
         /// <summary>
         /// Adds a set of warning codes to treat as errors for the specified project instance ID.
         /// </summary>
-        /// <param name="projectInstanceId">A <see cref="BuildEventContext.ProjectInstanceId"/> to associate with the list of warning codes.</param>
+        /// <param name="buildEventContext">A <see cref="BuildEventContext"/> to associate with the list of warning codes.</param>
         /// <param name="codes">The list of warning codes to treat as errors.</param>
         void AddWarningsAsErrors(BuildEventContext buildEventContext, ISet<string> codes);
 
diff --git a/src/Build/BackEnd/Components/Logging/LoggingContext.cs b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
index 2ba4ef2be8c..f32379d29c4 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
@@ -37,8 +37,8 @@ internal class LoggingContext
         /// <param name="eventContext">The event context</param>
         public LoggingContext(ILoggingService loggingService, BuildEventContext eventContext)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(loggingService, "loggingService");
-            ErrorUtilities.VerifyThrowArgumentNull(eventContext, "eventContext");
+            ErrorUtilities.VerifyThrowArgumentNull(loggingService, nameof(loggingService));
+            ErrorUtilities.VerifyThrowArgumentNull(eventContext, nameof(eventContext));
 
             _loggingService = loggingService;
             _eventContext = eventContext;
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 2c56e6ead22..f426366b7b1 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -121,7 +121,7 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         private bool _onlyLogCriticalEvents;
 
         /// <summary>
-        /// Contains a dictionary of loggerId's and the sink which the logger (of the given Id) is expecting to consume its messages 
+        /// Contains a dictionary of loggerId's and the sink which the logger (of the given Id) is expecting to consume its messages
         /// </summary>
         private Dictionary<int, IBuildEventSink> _eventSinkDictionary;
 
@@ -137,7 +137,7 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         private List<LoggerDescription> _loggerDescriptions;
 
         /// <summary>
-        /// The event source to which filters will listen to to get the build events which are logged to the logging service through the 
+        /// The event source to which filters will listen to get the build events which are logged to the logging service through the
         /// logging helper methods. Ie LogMessage and LogMessageEvent
         /// </summary>
         private EventSourceSink _filterEventSource;
@@ -245,7 +245,7 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
 
         /// <summary>
         /// By default our logMode is Asynchronous. We do this
-        /// because we are hoping it will make the system 
+        /// because we are hoping it will make the system
         /// more responsive when there are a large number of logging messages
         /// </summary>
         private LoggerMode _logMode = LoggerMode.Asynchronous;
@@ -444,7 +444,7 @@ public int MaxCPUCount
 
         /// <summary>
         /// The list of descriptions which describe how to create forwarding loggers on a node.
-        /// This is used by the node provider to get a list of registered descriptions so that 
+        /// This is used by the node provider to get a list of registered descriptions so that
         /// they can be transmitted to child nodes.
         /// </summary>
         public ICollection<LoggerDescription> LoggerDescriptions => _loggerDescriptions;
@@ -455,7 +455,7 @@ public int MaxCPUCount
         public ICollection<ILogger> Loggers => _loggers;
 
         /// <summary>
-        /// What type of logging mode is the logger running under. 
+        /// What type of logging mode is the logger running under.
         /// Is it Synchronous or Asynchronous
         /// </summary>
         public LoggerMode LoggingMode => _logMode;
@@ -483,7 +483,7 @@ public ISet<string> WarningsAsMessages
         /// </summary>
         public bool IncludeEvaluationMetaprojects
         {
-            get => (_includeEvaluationMetaprojects = _includeEvaluationMetaprojects ?? _eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeEvaluationMetaprojects)).Value;
+            get => _includeEvaluationMetaprojects ??= _eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeEvaluationMetaprojects);
             set => _includeEvaluationMetaprojects = value;
         }
 
@@ -492,7 +492,7 @@ public bool IncludeEvaluationMetaprojects
         /// </summary>
         public bool IncludeEvaluationProfile
         {
-            get => (_includeEvaluationProfile = _includeEvaluationProfile ??_eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeEvaluationProfiles)).Value;
+            get => _includeEvaluationProfile ??= _eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeEvaluationProfiles);
             set => _includeEvaluationProfile = value;
         }
 
@@ -501,7 +501,7 @@ public bool IncludeEvaluationProfile
         /// </summary>
         public bool IncludeTaskInputs
         {
-            get => (_includeTaskInputs = _includeTaskInputs ?? _eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeTaskInputs)).Value;
+            get => _includeTaskInputs ??= _eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeTaskInputs);
             set => _includeTaskInputs = value;
         }
 
@@ -519,7 +519,7 @@ public bool HasBuildSubmissionLoggedErrors(int submissionId)
             }
 
             // Determine if any of the event sinks have logged an error with this submission ID
-            return _buildSubmissionIdsThatHaveLoggedErrors != null && _buildSubmissionIdsThatHaveLoggedErrors.Contains(submissionId);
+            return _buildSubmissionIdsThatHaveLoggedErrors?.Contains(submissionId) == true;
         }
 
         public void AddWarningsAsErrors(BuildEventContext buildEventContext, ISet<string> codes)
@@ -723,10 +723,7 @@ public void ShutdownComponent()
                     }
 
                     // 3. Null out sinks and the filter event source so that no more events can get to the central loggers
-                    if (_filterEventSource != null)
-                    {
-                        _filterEventSource.ShutDown();
-                    }
+                    _filterEventSource?.ShutDown();
 
                     foreach (IBuildEventSink sink in _eventSinkDictionary.Values)
                     {
@@ -779,7 +776,7 @@ public void PacketReceived(int node, INodePacket packet)
             // PERF: Not using VerifyThrow to avoid allocations for enum.ToString (boxing of NodePacketType) in the non-error case.
             if (packet.Type != NodePacketType.LogMessage)
             {
-                ErrorUtilities.ThrowInternalError("Expected packet type \"{0}\" but instead got packet type \"{1}\".", NodePacketType.LogMessage.ToString(), packet.Type.ToString());
+                ErrorUtilities.ThrowInternalError("Expected packet type \"{0}\" but instead got packet type \"{1}\".", nameof(NodePacketType.LogMessage), packet.Type.ToString());
             }
 
             LogMessagePacket loggingPacket = (LogMessagePacket)packet;
@@ -873,11 +870,11 @@ public void UnregisterAllLoggers()
         }
 
         /// <summary>
-        /// Register a distributed logger. This involves creating a new eventsource sink 
-        /// and associating this with the central logger. In addition the sinkId needs 
-        /// to be put in the loggerDescription so that nodes know what they need to 
+        /// Register a distributed logger. This involves creating a new eventsource sink
+        /// and associating this with the central logger. In addition the sinkId needs
+        /// to be put in the loggerDescription so that nodes know what they need to
         /// tag onto the event so that the message goes to the correct logger.
-        /// 
+        ///
         /// The central logger is initialized before the distributed logger
         /// </summary>
         /// <param name="centralLogger">Central logger to receive messages from the forwarding logger, This logger cannot have been registered before</param>
@@ -1000,7 +997,7 @@ public void InitializeNodeLoggers(ICollection<LoggerDescription> descriptions, I
         /// <summary>
         /// Will Log a build Event. Will also take into account OnlyLogCriticalEvents when determining
         /// if to drop the event or to log it.
-        /// 
+        ///
         /// Only the following events will be logged if OnlyLogCriticalEvents is true:
         /// CustomEventArgs
         /// BuildErrorEventArgs
@@ -1056,7 +1053,7 @@ public void LogBuildEvent(BuildEventArgs buildEvent)
 
         /// <summary>
         /// This method will becalled from multiple threads in asynchronous mode.
-        /// 
+        ///
         /// Determine where to send the buildevent either to the filters or to a specific sink.
         /// When in Asynchronous mode the event should to into the logging queue (as long as we are initialized).
         /// In Synchronous mode the event should be routed to the correct sink or logger right away
@@ -1109,7 +1106,7 @@ internal void WaitForThreadToProcessEvents()
         /// </summary>
         internal void InjectNonSerializedData(LogMessagePacket loggingPacket)
         {
-            if (loggingPacket != null && loggingPacket.NodeBuildEvent != null && _componentHost != null)
+            if (loggingPacket?.NodeBuildEvent != null && _componentHost != null)
             {
                 var projectStartedEventArgs = loggingPacket.NodeBuildEvent.Value.Value as ProjectStartedEventArgs;
                 if (projectStartedEventArgs != null && _configCache.Value != null)
@@ -1128,8 +1125,8 @@ internal void InjectNonSerializedData(LogMessagePacket loggingPacket)
         private static int GetWarningsAsErrorOrMessageKey(BuildEventContext buildEventContext)
         {
             var hash = 17;
-            hash = hash * 31 + buildEventContext.ProjectInstanceId;
-            hash = hash * 31 + buildEventContext.ProjectContextId;
+            hash = (hash * 31) + buildEventContext.ProjectInstanceId;
+            hash = (hash * 31) + buildEventContext.ProjectContextId;
             return hash;
         }
 
@@ -1196,10 +1193,7 @@ private void ShutdownLogger(ILogger logger)
         {
             try
             {
-                if (logger != null)
-                {
-                    logger.Shutdown();
-                }
+                logger?.Shutdown();
             }
             catch (LoggerException)
             {
@@ -1372,7 +1366,7 @@ private void RouteBuildEvent(object loggingEvent)
         }
 
         /// <summary>
-        /// Route the build event to the correct filter or sink depending on what the sinId is in the build event. 
+        /// Route the build event to the correct filter or sink depending on what the sinId is in the build event.
         /// </summary>
         private void RouteBuildEvent(KeyValuePair<int, BuildEventArgs> nodeEvent)
         {
@@ -1463,7 +1457,7 @@ private void InitializeLogger(ILogger logger, IEventSource sourceForLogger)
             try
             {
                 INodeLogger nodeLogger = logger as INodeLogger;
-                if (null != nodeLogger)
+                if (nodeLogger != null)
                 {
                     nodeLogger.Initialize(sourceForLogger, _maxCPUCount);
                 }
@@ -1491,10 +1485,10 @@ private void InitializeLogger(ILogger logger, IEventSource sourceForLogger)
         }
 
         /// <summary>
-        /// When an exception is raised in the logging thread, we do not want the application to terminate right away. 
+        /// When an exception is raised in the logging thread, we do not want the application to terminate right away.
         /// Whidbey and orcas msbuild have the logger exceptions occurring on the engine thread so that the host can
         /// catch and deal with these exceptions as they may occur somewhat frequently due to user generated loggers.
-        /// This method will raise the exception on a delegate to which the engine is registered to. This delegate will 
+        /// This method will raise the exception on a delegate to which the engine is registered to. This delegate will
         /// send the exception to the engine so that it can be raised on the engine thread.
         /// </summary>
         /// <param name="ex">Exception to raise to event handlers</param>
@@ -1563,7 +1557,7 @@ private bool ShouldTreatWarningAsMessage(BuildWarningEventArgs warningEvent)
         {
             // This only applies if the user specified /nowarn at the command-line or added the warning code through the object model
             //
-            if (WarningsAsMessages != null && WarningsAsMessages.Contains(warningEvent.Code))
+            if (WarningsAsMessages?.Contains(warningEvent.Code) == true)
             {
                 return true;
             }
@@ -1574,7 +1568,7 @@ private bool ShouldTreatWarningAsMessage(BuildWarningEventArgs warningEvent)
             {
                 if (_warningsAsMessagesByProject.TryGetValue(GetWarningsAsErrorOrMessageKey(warningEvent), out ISet<string> codesByProject))
                 {
-                    return codesByProject != null && codesByProject.Contains(warningEvent.Code);
+                    return codesByProject?.Contains(warningEvent.Code) == true;
                 }
             }
 
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index d1bf9031adb..4ab21db60f0 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -447,7 +447,7 @@ public void LogBuildStarted()
 
                 IDictionary<string, string> environmentProperties = null;
 
-                if (_componentHost != null && _componentHost.BuildParameters != null)
+                if (_componentHost?.BuildParameters != null)
                 {
                     environmentProperties = _componentHost.BuildParameters.BuildProcessEnvironment;
                 }
@@ -619,7 +619,7 @@ public void LogProjectFinished(BuildEventContext projectBuildEventContext, strin
             {
                 ErrorUtilities.VerifyThrow(projectBuildEventContext != null, "projectBuildEventContext");
 
-                string message = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword((success ? "ProjectFinishedSuccess" : "ProjectFinishedFailure"), Path.GetFileName(projectFile));
+                string message = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(success ? "ProjectFinishedSuccess" : "ProjectFinishedFailure", Path.GetFileName(projectFile));
 
                 ProjectFinishedEventArgs buildEvent = new ProjectFinishedEventArgs
                     (
@@ -730,7 +730,7 @@ public void LogTargetFinished(BuildEventContext targetBuildEventContext, string
                 {
                     ErrorUtilities.VerifyThrow(targetBuildEventContext != null, "targetBuildEventContext is null");
 
-                    string message = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword((success ? "TargetFinishedSuccess" : "TargetFinishedFailure"), targetName, Path.GetFileName(projectFile));
+                    string message = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(success ? "TargetFinishedSuccess" : "TargetFinishedFailure", targetName, Path.GetFileName(projectFile));
 
                     TargetFinishedEventArgs buildEvent = new TargetFinishedEventArgs
                         (
@@ -836,7 +836,7 @@ public void LogTaskFinished(BuildEventContext taskBuildEventContext, string task
                 if (!OnlyLogCriticalEvents)
                 {
                     ErrorUtilities.VerifyThrow(taskBuildEventContext != null, "taskBuildEventContext is null");
-                    string message = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword((success ? "TaskFinishedSuccess" : "TaskFinishedFailure"), taskName);
+                    string message = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(success ? "TaskFinishedSuccess" : "TaskFinishedFailure", taskName);
 
                     TaskFinishedEventArgs buildEvent = new TaskFinishedEventArgs
                         (
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index 883059b0406..409c75b14be 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -101,7 +101,7 @@ private ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, int submiss
                 items = new ProjectItemInstanceEnumeratorProxy(projectItemsEnumerator);
             }
 
-            if (projectProperties != null && propertiesToSerialize != null && propertiesToSerialize.Length > 0 && !LoggingService.SerializeAllProperties)
+            if (projectProperties != null && propertiesToSerialize?.Length > 0 && !LoggingService.SerializeAllProperties)
             {
                 PropertyDictionary<ProjectPropertyInstance> projectPropertiesToSerialize = new PropertyDictionary<ProjectPropertyInstance>();
                 foreach (string propertyToGet in propertiesToSerialize)
@@ -171,7 +171,7 @@ internal TargetLoggingContext LogTargetBatchStarted(string projectFullPath, Proj
         /// </summary>
         /// <remarks>
         /// This class is designed to be passed to loggers.
-        /// The expense of copying items is only incurred if and when 
+        /// The expense of copying items is only incurred if and when
         /// a logger chooses to enumerate over it.
         /// The type of the items enumerated over is imposed by backwards compatibility for ProjectStartedEvent.
         /// </remarks>
@@ -221,7 +221,7 @@ IEnumerator IEnumerable.GetEnumerator()
         /// </summary>
         /// <remarks>
         /// This class is designed to be passed to loggers.
-        /// The expense of copying items is only incurred if and when 
+        /// The expense of copying items is only incurred if and when
         /// a logger chooses to enumerate over it.
         /// The type of the items enumerated over is imposed by backwards compatibility for ProjectStartedEvent.
         /// </remarks>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
index eac4bf5351c..3e676950ea5 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
@@ -127,12 +127,12 @@ ElementLocation elementLocation
             Dictionary<string, MetadataReference> consumedMetadataReferences = pair.Metadata;
 
             List<ItemBucket> buckets = null;
-            if (consumedMetadataReferences != null && consumedMetadataReferences.Count > 0)
+            if (consumedMetadataReferences?.Count > 0)
             {
                 // Add any item types that we were explicitly told to assume.
                 if (implicitBatchableItemType != null)
                 {
-                    consumedItemReferences = consumedItemReferences ?? new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
+                    consumedItemReferences ??= new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
                     consumedItemReferences.Add(implicitBatchableItemType);
                 }
 
@@ -232,7 +232,7 @@ ElementLocation elementLocation
                     // in the tag anywhere.  Adding it to this list allows us (down below in this
                     // method) to check that every item in this list has a value for each 
                     // unqualified metadata reference.
-                    consumedItemReferenceNames = consumedItemReferenceNames ?? new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
+                    consumedItemReferenceNames ??= new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
                     consumedItemReferenceNames.Add(consumedMetadataReference.ItemName);
                 }
             }
@@ -335,7 +335,7 @@ ElementLocation elementLocation
 
                         // If we didn't find a bucket that matches this item, create a new one, adding
                         // this item to the bucket.
-                        if (null == matchingBucket)
+                        if (matchingBucket == null)
                         {
                             matchingBucket = new ItemBucket(itemListsToBeBatched.Keys, itemMetadataValues, lookup, buckets.Count);
 
@@ -395,7 +395,7 @@ ElementLocation elementLocation
 
                 if (
                         (metadataItemName != null) &&
-                        (0 != String.Compare(item.ItemType, metadataItemName, StringComparison.OrdinalIgnoreCase))
+                        (!String.Equals(item.ItemType, metadataItemName, StringComparison.OrdinalIgnoreCase))
                     )
                 {
                     itemMetadataValues[metadataQualifiedName] = String.Empty;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs
index 38b986e050f..c278aa84730 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs
@@ -28,6 +28,7 @@ namespace Microsoft.Build.BackEnd
     /// <param name="issuingEntry">The build request entry which is being blocked.</param>
     /// <param name="blockingGlobalRequestId">The request on which we are blocked.</param>
     /// <param name="blockingTarget">The target on which we are blocked.</param>
+    /// <param name="partialBuildResult">The partial build result on which we are blocked.</param>
     internal delegate void BuildRequestBlockedDelegate(BuildRequestEntry issuingEntry, int blockingGlobalRequestId, string blockingTarget, BuildResult partialBuildResult);
 
     /// <summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index f528cadbfaf..31318d664b1 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -159,7 +159,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
         {
             // First, collect up the appropriate metadata collections.  We need the one from the item definition, if any, and
             // the one we are using for this batching bucket.
-            ProjectItemDefinitionInstance itemDefinition = null;
+            ProjectItemDefinitionInstance itemDefinition;
             Project.ItemDefinitions.TryGetValue(child.ItemType, out itemDefinition);
 
             // The NestedMetadataTable will handle the aggregation of the different metadata collections
@@ -215,7 +215,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                 LoggingContext.BuildEventContext,
                 FileSystems.Default);
 
-            if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents && itemsToAdd != null && itemsToAdd.Count > 0)
+            if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents && itemsToAdd?.Count > 0)
             {
                 var itemGroupText = ItemGroupLoggingHelper.GetParameterText(
                     ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix,
@@ -235,6 +235,8 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
         /// </summary>
         /// <param name="child">The item specification to evaluate and remove.</param>
         /// <param name="bucket">The batching bucket.</param>
+        /// <param name="matchOnMetadata">Metadata matching.</param>
+        /// <param name="matchingOptions">Options matching.</param>
         private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, HashSet<string> matchOnMetadata, MatchOnMetadataOptions matchingOptions)
         {
             ICollection<ProjectItemInstance> group = bucket.Lookup.GetItems(child.ItemType);
@@ -244,8 +246,7 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
                 return;
             }
 
-            List<ProjectItemInstance> itemsToRemove = null;
-
+            List<ProjectItemInstance> itemsToRemove;
             if (matchOnMetadata == null)
             {
                 itemsToRemove = FindItemsMatchingSpecification(group, child.Remove, child.RemoveLocation, bucket.Expander);
@@ -679,7 +680,7 @@ public string GetEscapedValue(string specifiedItemType, string name)
             public string GetEscapedValueIfPresent(string specifiedItemType, string name)
             {
                 string value = null;
-                if (null == specifiedItemType || specifiedItemType == _itemType)
+                if (specifiedItemType == null || specifiedItemType == _itemType)
                 {
                     // Look in the addTable
                     if (_addTable.TryGetValue(name, out value))
@@ -689,17 +690,17 @@ public string GetEscapedValueIfPresent(string specifiedItemType, string name)
                 }
 
                 // Look in the bucket table
-                if (null != _bucketTable)
+                if (_bucketTable != null)
                 {
                     value = _bucketTable.GetEscapedValueIfPresent(specifiedItemType, name);
-                    if (null != value)
+                    if (value != null)
                     {
                         return value;
                     }
                 }
 
                 // Look in the item definition table
-                if (null != _itemDefinitionTable)
+                if (_itemDefinitionTable != null)
                 {
                     value = _itemDefinitionTable.GetEscapedValueIfPresent(specifiedItemType, name);
                 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
index d9639592e03..1c13820a921 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
@@ -236,7 +236,7 @@ public async Task<bool> ExecuteInternal()
             }
 
             // We have been asked to unescape all escaped characters before processing
-            if (TargetAndPropertyListSeparators != null && TargetAndPropertyListSeparators.Length > 0)
+            if (TargetAndPropertyListSeparators?.Length > 0)
             {
                 ExpandAllTargetsAndProperties();
             }
@@ -484,7 +484,7 @@ bool runEachTargetSeparately
             // of the RunEachTargetSeparately parameter, we each just call the engine to run all 
             // the targets together, or we call the engine separately for each target.
             var targetLists = new List<string[]>();
-            if ((runEachTargetSeparately) && (targets != null) && (targets.Length > 0))
+            if (runEachTargetSeparately && targets?.Length > 0)
             {
                 // Separate target invocations for each individual target.
                 foreach (string targetName in targets)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
index da88294d849..4d0e7f95812 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
@@ -89,8 +89,8 @@ internal class Lookup : IPropertyProvider<ProjectPropertyInstance>, IItemProvide
         /// </summary>
         internal Lookup(ItemDictionary<ProjectItemInstance> projectItems, PropertyDictionary<ProjectPropertyInstance> properties)
         {
-            ErrorUtilities.VerifyThrowInternalNull(projectItems, "projectItems");
-            ErrorUtilities.VerifyThrowInternalNull(properties, "properties");
+            ErrorUtilities.VerifyThrowInternalNull(projectItems, nameof(projectItems));
+            ErrorUtilities.VerifyThrowInternalNull(properties, nameof(properties));
 
             Lookup.Scope scope = new Lookup.Scope(this, "Lookup()", projectItems, properties);
             _lookupScopes.AddFirst(scope);
@@ -378,13 +378,13 @@ private void MergeScopeIntoLastScope()
             // adds to the world
             if (PrimaryAddTable != null)
             {
-                SecondaryTable = SecondaryTable ?? new ItemDictionary<ProjectItemInstance>();
+                SecondaryTable ??= new ItemDictionary<ProjectItemInstance>();
                 SecondaryTable.ImportItems(PrimaryAddTable);
             }
 
             if (PrimaryRemoveTable != null)
             {
-                SecondaryTable = SecondaryTable ?? new ItemDictionary<ProjectItemInstance>();
+                SecondaryTable ??= new ItemDictionary<ProjectItemInstance>();
                 SecondaryTable.RemoveItems(PrimaryRemoveTable);
             }
 
@@ -392,14 +392,14 @@ private void MergeScopeIntoLastScope()
             {
                 foreach (KeyValuePair<string, Dictionary<ProjectItemInstance, MetadataModifications>> entry in PrimaryModifyTable)
                 {
-                    SecondaryTable = SecondaryTable ?? new ItemDictionary<ProjectItemInstance>();
+                    SecondaryTable ??= new ItemDictionary<ProjectItemInstance>();
                     ApplyModificationsToTable(SecondaryTable, entry.Key, entry.Value);
                 }
             }
 
             if (PrimaryPropertySets != null)
             {
-                SecondaryProperties = SecondaryProperties ?? new PropertyDictionary<ProjectPropertyInstance>(PrimaryPropertySets.Count);
+                SecondaryProperties ??= new PropertyDictionary<ProjectPropertyInstance>(PrimaryPropertySets.Count);
                 SecondaryProperties.ImportProperties(PrimaryPropertySets);
             }
         }
@@ -450,7 +450,7 @@ public ProjectPropertyInstance GetProperty(string name, int startIndex, int endI
         /// </summary>
         public ProjectPropertyInstance GetProperty(string name)
         {
-            ErrorUtilities.VerifyThrowInternalLength(name, "name");
+            ErrorUtilities.VerifyThrowInternalLength(name, nameof(name));
 
             return GetProperty(name, 0, name.Length - 1);
         }
@@ -479,7 +479,7 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
                     ICollection<ProjectItemInstance> adds = scope.Adds[itemType];
                     if (adds.Count != 0)
                     {
-                        allAdds = allAdds ?? new List<ProjectItemInstance>(adds.Count);
+                        allAdds ??= new List<ProjectItemInstance>(adds.Count);
                         allAdds.AddRange(adds);
                     }
                 }
@@ -490,7 +490,7 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
                     ICollection<ProjectItemInstance> removes = scope.Removes[itemType];
                     if (removes.Count != 0)
                     {
-                        allRemoves = allRemoves ?? new List<ProjectItemInstance>(removes.Count);
+                        allRemoves ??= new List<ProjectItemInstance>(removes.Count);
                         allRemoves.AddRange(removes);
                     }
                 }
@@ -503,7 +503,7 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
                     {
                         if (modifies.Count != 0)
                         {
-                            allModifies = allModifies ?? new Dictionary<ProjectItemInstance, MetadataModifications>(modifies.Count);
+                            allModifies ??= new Dictionary<ProjectItemInstance, MetadataModifications>(modifies.Count);
 
                             // We already have some modifies for this type
                             foreach (KeyValuePair<ProjectItemInstance, MetadataModifications> modify in modifies)
@@ -538,7 +538,7 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
             {
                 // We can just hand out this group verbatim -
                 // that avoids any importing
-                groupFound = groupFound ?? Array.Empty<ProjectItemInstance>();
+                groupFound ??= Array.Empty<ProjectItemInstance>();
 
                 return groupFound;
             }
@@ -593,7 +593,7 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
         /// </summary>
         internal void PopulateWithItems(string itemType, ICollection<ProjectItemInstance> group)
         {
-            PrimaryTable = PrimaryTable ?? new ItemDictionary<ProjectItemInstance>();
+            PrimaryTable ??= new ItemDictionary<ProjectItemInstance>();
             ICollection<ProjectItemInstance> existing = PrimaryTable[itemType];
             ErrorUtilities.VerifyThrow(existing.Count == 0, "Cannot add an itemgroup of this type.");
 
@@ -613,7 +613,7 @@ internal void PopulateWithItems(string itemType, ICollection<ProjectItemInstance
         /// </summary>
         internal void PopulateWithItem(ProjectItemInstance item)
         {
-            PrimaryTable = PrimaryTable ?? new ItemDictionary<ProjectItemInstance>();
+            PrimaryTable ??= new ItemDictionary<ProjectItemInstance>();
             PrimaryTable.Add(item);
         }
 
@@ -626,7 +626,7 @@ internal void SetProperty(ProjectPropertyInstance property)
             MustNotBeOuterScope();
 
             // Put in the set table
-            PrimaryPropertySets = PrimaryPropertySets ?? new PropertyDictionary<ProjectPropertyInstance>();
+            PrimaryPropertySets ??= new PropertyDictionary<ProjectPropertyInstance>();
             PrimaryPropertySets.Set(property);
         }
 
@@ -651,7 +651,7 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst
             }
 
             // Put them in the add table
-            PrimaryAddTable = PrimaryAddTable ?? new ItemDictionary<ProjectItemInstance>();
+            PrimaryAddTable ??= new ItemDictionary<ProjectItemInstance>();
             IEnumerable<ProjectItemInstance> itemsToAdd = group;
             if (doNotAddDuplicates)
             {
@@ -662,7 +662,7 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst
                 var existingItems = GetItems(itemType);
                 if (existingItems.Count > 0)
                 {
-                    itemsToAdd = itemsToAdd.Where(item => !(existingItems.Contains(item, ProjectItemInstance.EqualityComparer)));
+                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));
                 }
             }
 
@@ -684,7 +684,7 @@ internal void AddNewItem(ProjectItemInstance item)
 #endif
 
             // Put in the add table
-            PrimaryAddTable = PrimaryAddTable ?? new ItemDictionary<ProjectItemInstance>();
+            PrimaryAddTable ??= new ItemDictionary<ProjectItemInstance>();
             PrimaryAddTable.Add(item);
         }
 
@@ -710,7 +710,7 @@ internal void RemoveItem(ProjectItemInstance item)
             item = RetrieveOriginalFromCloneTable(item);
 
             // Put in the remove table
-            PrimaryRemoveTable = PrimaryRemoveTable ?? new ItemDictionary<ProjectItemInstance>();
+            PrimaryRemoveTable ??= new ItemDictionary<ProjectItemInstance>();
             PrimaryRemoveTable.Add(item);
 
             // No need to remove this item from the primary add table if it's 
@@ -753,7 +753,7 @@ internal void ModifyItems(string itemType, ICollection<ProjectItemInstance> grou
 
             // We don't need to check whether the item is in the add table vs. the main table; either
             // way the modification will be applied.
-            PrimaryModifyTable = PrimaryModifyTable ?? new ItemTypeToItemsMetadataUpdateDictionary(MSBuildNameIgnoreCaseComparer.Default);
+            PrimaryModifyTable ??= new ItemTypeToItemsMetadataUpdateDictionary(MSBuildNameIgnoreCaseComparer.Default);
             Dictionary<ProjectItemInstance, MetadataModifications> modifiesOfType;
             if (!PrimaryModifyTable.TryGetValue(itemType, out modifiesOfType))
             {
@@ -790,7 +790,7 @@ private void ApplyModifies(ItemDictionary<ProjectItemInstance> result, Dictionar
             // FUTURE - don't need to clone here for non intrinsic tasks, but at present, they don't do modifies
 
             // Store the clone, in case we're asked to modify or remove it later (we will record it against the real item)
-            _cloneTable = _cloneTable ?? new Dictionary<ProjectItemInstance, ProjectItemInstance>();
+            _cloneTable ??= new Dictionary<ProjectItemInstance, ProjectItemInstance>();
 
             foreach (var modify in allModifies)
             {
@@ -930,7 +930,7 @@ private void MergeModificationsIntoModificationTable(Dictionary<ProjectItemInsta
         /// </summary>
         private void MustNotBeInTable(ItemDictionary<ProjectItemInstance> table, ProjectItemInstance item)
         {
-            if (table != null && table.ItemTypes.Contains(item.ItemType))
+            if (table?.ItemTypes.Contains(item.ItemType) == true)
             {
                 ICollection<ProjectItemInstance> tableOfItemsOfSameType = table[item.ItemType];
                 if (tableOfItemsOfSameType != null)
@@ -945,7 +945,7 @@ private void MustNotBeInTable(ItemDictionary<ProjectItemInstance> table, Project
         /// </summary>
         private void MustNotBeInTable(ItemTypeToItemsMetadataUpdateDictionary table, ProjectItemInstance item)
         {
-            if (table != null && table.ContainsKey(item.ItemType))
+            if (table?.ContainsKey(item.ItemType) == true)
             {
                 ItemsMetadataUpdateDictionary tableOfItemsOfSameType = table[item.ItemType];
                 if (tableOfItemsOfSameType != null)
@@ -1140,7 +1140,7 @@ public MetadataModification this[string metadataName]
             {
                 get
                 {
-                    MetadataModification modification = null;
+                    MetadataModification modification;
                     if (!_modifications.TryGetValue(metadataName, out modification))
                     {
                         if (_keepOnlySpecified)
@@ -1271,7 +1271,7 @@ public bool Remove
             /// </summary>
             public bool KeepValue
             {
-                get { return (_remove == false && _newValue == null); }
+                get { return !_remove && _newValue == null; }
             }
 
             /// <summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index c34edb8c8e7..00512fc9c9b 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -170,7 +170,7 @@ internal bool HasActiveBuildRequest
             {
                 VerifyIsNotZombie();
 
-                return (_requestTask != null && !_requestTask.IsCompleted) || (_componentHost.LegacyThreadingData.MainThreadSubmissionId != -1);
+                return (_requestTask?.IsCompleted == false) || (_componentHost.LegacyThreadingData.MainThreadSubmissionId != -1);
             }
         }
 
@@ -181,9 +181,9 @@ internal bool HasActiveBuildRequest
         /// <param name="entry">The entry to build.</param>
         public void BuildRequest(NodeLoggingContext loggingContext, BuildRequestEntry entry)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(loggingContext, "loggingContext");
-            ErrorUtilities.VerifyThrowArgumentNull(entry, "entry");
-            ErrorUtilities.VerifyThrow(null != _componentHost, "Host not set.");
+            ErrorUtilities.VerifyThrowArgumentNull(loggingContext, nameof(loggingContext));
+            ErrorUtilities.VerifyThrowArgumentNull(entry, nameof(entry));
+            ErrorUtilities.VerifyThrow(_componentHost != null, "Host not set.");
             ErrorUtilities.VerifyThrow(_targetBuilder == null, "targetBuilder not null");
             ErrorUtilities.VerifyThrow(_nodeLoggingContext == null, "nodeLoggingContext not null");
             ErrorUtilities.VerifyThrow(_requestEntry == null, "requestEntry not null");
@@ -213,7 +213,7 @@ public void ContinueRequest()
             VerifyEntryInReadyState();
 
             _continueResults = _requestEntry.Continue();
-            ErrorUtilities.VerifyThrow((_blockType == BlockType.BlockedOnTargetInProgress || _blockType == BlockType.Yielded) || (_continueResults != null), "Unexpected null results for request {0} (nr {1})", _requestEntry.Request.GlobalRequestId, _requestEntry.Request.NodeRequestId);
+            ErrorUtilities.VerifyThrow(_blockType == BlockType.BlockedOnTargetInProgress || _blockType == BlockType.Yielded || (_continueResults != null), "Unexpected null results for request {0} (nr {1})", _requestEntry.Request.GlobalRequestId, _requestEntry.Request.NodeRequestId);
 
             // Setting the continue event will wake up the build thread, which is suspended in StartNewBuildRequests.
             _continueEvent.Set();
@@ -308,10 +308,10 @@ public void WaitForCancelCompletion()
         public async Task<BuildResult[]> BuildProjects(string[] projectFiles, PropertyDictionary<ProjectPropertyInstance>[] properties, string[] toolsVersions, string[] targets, bool waitForResults, bool skipNonexistentTargets = false)
         {
             VerifyIsNotZombie();
-            ErrorUtilities.VerifyThrowArgumentNull(projectFiles, "projectFiles");
-            ErrorUtilities.VerifyThrowArgumentNull(properties, "properties");
-            ErrorUtilities.VerifyThrowArgumentNull(targets, "targets");
-            ErrorUtilities.VerifyThrowArgumentNull(toolsVersions, "toolsVersions");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFiles, nameof(projectFiles));
+            ErrorUtilities.VerifyThrowArgumentNull(properties, nameof(properties));
+            ErrorUtilities.VerifyThrowArgumentNull(targets, nameof(targets));
+            ErrorUtilities.VerifyThrowArgumentNull(toolsVersions, nameof(toolsVersions));
             ErrorUtilities.VerifyThrow(_componentHost != null, "No host object set");
             ErrorUtilities.VerifyThrow(projectFiles.Length == properties.Length, "Properties and project counts not the same");
             ErrorUtilities.VerifyThrow(projectFiles.Length == toolsVersions.Length, "Tools versions and project counts not the same");
@@ -469,7 +469,7 @@ public void ExitMSBuildCallbackState()
         /// <param name="host">The component host.</param>
         public void InitializeComponent(IBuildComponentHost host)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
             ErrorUtilities.VerifyThrow(_componentHost == null, "RequestBuilder already initialized.");
             _componentHost = host;
         }
@@ -582,7 +582,7 @@ private void StartBuilderThread()
                         // to null between the null check and asking the LegacyThreadingData for the Task.
                         IBuildComponentHost componentHostSnapshot = _componentHost;
 
-                        if (componentHostSnapshot != null && componentHostSnapshot.LegacyThreadingData != null)
+                        if (componentHostSnapshot?.LegacyThreadingData != null)
                         {
                             return componentHostSnapshot.LegacyThreadingData.GetLegacyThreadInactiveTask(_requestEntry.Request.SubmissionId);
                         }
@@ -726,7 +726,7 @@ private async Task BuildAndReport()
             }
             catch (InvalidProjectFileException ex)
             {
-                if (null != _projectLoggingContext)
+                if (_projectLoggingContext != null)
                 {
                     _projectLoggingContext.LogInvalidProjectFileError(ex);
                 }
@@ -764,7 +764,7 @@ private async Task BuildAndReport()
             {
                 _blockType = BlockType.Unblocked;
 
-                if (null != thrownException)
+                if (thrownException != null)
                 {
                     ErrorUtilities.VerifyThrow(result == null, "Result already set when exception was thrown.");
                     result = new BuildResult(_requestEntry.Request, thrownException);
@@ -781,7 +781,7 @@ private async Task BuildAndReport()
         /// </summary>
         private void ReportResultAndCleanUp(BuildResult result)
         {
-            if (null != _projectLoggingContext)
+            if (_projectLoggingContext != null)
             {
                 try
                 {
@@ -916,8 +916,7 @@ private async Task<BuildResult[]> StartNewBuildRequests(FullyQualifiedBuildReque
         /// </summary>
         private BuildResult[] GetResultsForContinuation(FullyQualifiedBuildRequest[] requests, bool isContinue)
         {
-            IDictionary<int, BuildResult> results;
-            results = _continueResults;
+            IDictionary<int, BuildResult> results = _continueResults;
             _continueResults = null;
             if (results == null)
             {
@@ -990,7 +989,7 @@ private void RaiseOnBlockedRequest(int blockingGlobalRequestId, string blockingT
         /// This method is called to reset the current directory to the one appropriate for this project.  It should be called any time
         /// the project is resumed.
         /// If the directory does not exist, does nothing.
-        /// This is because if the project has not been saved, this directory may not exist, yet it is often useful to still be able to build the project. 
+        /// This is because if the project has not been saved, this directory may not exist, yet it is often useful to still be able to build the project.
         /// No errors are masked by doing this: errors loading the project from disk are reported at load time, if necessary.
         /// </summary>
         private void SetProjectCurrentDirectory()
@@ -1293,7 +1292,7 @@ private ISet<string> ParseWarningCodes(string warnings)
             {
                 return null;
             }
-            
+
             return new HashSet<string>(ExpressionShredder.SplitSemiColonSeparatedList(warnings), StringComparer.OrdinalIgnoreCase);
         }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index fef4a4d0676..834d87e57b2 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -26,11 +26,11 @@ namespace Microsoft.Build.BackEnd
     /// pushed onto the stack.  The main loop for the Target Builder simply evaluates the top item on the stack to determine
     /// which action to take.  These actions comprise the target state machine, as represented by the states of the
     /// TargetEntry object.
-    /// 
+    ///
     /// When a target completes, all of its outputs are available in the Lookup contained in the TargetEntry.  In fact, everything that it changed
     /// in the global state is available by virtue of its Lookup being merged with the current Target's lookup.
-    /// 
-    /// For CallTarget tasks, this behavior is not the same.  Rather the Lookup from a CallTarget call does not get merged until the calling 
+    ///
+    /// For CallTarget tasks, this behavior is not the same.  Rather the Lookup from a CallTarget call does not get merged until the calling
     /// Target has completed.  This is considered erroneous behavior and 'normal' version of CallTarget will be implemented which does not exhibit
     /// this.
     /// </remarks>
@@ -100,10 +100,10 @@ internal class TargetBuilder : ITargetBuilder, ITargetBuilderCallback, IBuildCom
         public async Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext, BuildRequestEntry entry, IRequestBuilderCallback callback, string[] targetNames, Lookup baseLookup, CancellationToken cancellationToken)
         {
             ErrorUtilities.VerifyThrowArgumentNull(loggingContext, "projectLoggingContext");
-            ErrorUtilities.VerifyThrowArgumentNull(entry, "entry");
+            ErrorUtilities.VerifyThrowArgumentNull(entry, nameof(entry));
             ErrorUtilities.VerifyThrowArgumentNull(callback, "requestBuilderCallback");
-            ErrorUtilities.VerifyThrowArgumentNull(targetNames, "targetNames");
-            ErrorUtilities.VerifyThrowArgumentNull(baseLookup, "baseLookup");
+            ErrorUtilities.VerifyThrowArgumentNull(targetNames, nameof(targetNames));
+            ErrorUtilities.VerifyThrowArgumentNull(baseLookup, nameof(baseLookup));
             ErrorUtilities.VerifyThrow(targetNames.Length > 0, "List of targets must be non-empty");
             ErrorUtilities.VerifyThrow(_componentHost != null, "InitializeComponent must be called before building targets.");
 
@@ -201,7 +201,6 @@ public async Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext
             return resultsToReport;
         }
 
-
         #region IBuildComponent Members
 
         /// <summary>
@@ -210,7 +209,7 @@ public async Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext
         /// <param name="host">The component host.</param>
         public void InitializeComponent(IBuildComponentHost host)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
             _componentHost = host;
         }
 
@@ -440,7 +439,7 @@ private async Task ProcessTargetStack(ITaskBuilder taskBuilder)
                             }
 
                             // And if we have dependencies to run, push them now.
-                            if (null != dependencies)
+                            if (dependencies != null)
                             {
                                 await PushTargets(dependencies, currentTargetEntry, currentTargetEntry.Lookup, false, false, TargetBuiltReason.DependsOn);
                             }
@@ -589,9 +588,9 @@ private bool CheckSkipTarget(ref bool stopProcessingStack, TargetEntry currentTa
         }
 
         /// <summary>
-        /// When a target build fails, we don't just stop building that target; we also pop all of the other dependency targets of its 
-        /// parent target off the stack. Extract that logic into a standalone method so that it can be used when dealing with targets that 
-        /// are skipped-unsuccessful as well as first-time failures. 
+        /// When a target build fails, we don't just stop building that target; we also pop all of the other dependency targets of its
+        /// parent target off the stack. Extract that logic into a standalone method so that it can be used when dealing with targets that
+        /// are skipped-unsuccessful as well as first-time failures.
         /// </summary>
         private void PopDependencyTargetsOnTargetFailure(TargetEntry topEntry, TargetResult targetResult, ref bool stopProcessingStack)
         {
@@ -778,6 +777,10 @@ private void ComputeAfterTargetFailures(string[] targetNames)
                     var targetsToCheckForAfterTargets = new Queue<string>();
                     targetsToCheckForAfterTargets.Enqueue(targetName);
 
+                    // Set of targets already processed, to break cycles of AfterTargets.
+                    // Initialized lazily when needed below.
+                    HashSet<string> targetsChecked = null;
+
                     while (targetsToCheckForAfterTargets?.Count > 0)
                     {
                         string targetToCheck = targetsToCheckForAfterTargets.Dequeue();
@@ -794,8 +797,16 @@ private void ComputeAfterTargetFailures(string[] targetNames)
                                 break;
                             }
 
-                            // We haven't seen this target yet, add it to the list to check.
-                            targetsToCheckForAfterTargets.Enqueue(afterTarget.TargetName);
+                            targetsChecked ??= new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default)
+                                {
+                                    targetName
+                                };
+
+                            // If we haven't seen this target yet, add it to the list to check.
+                            if (targetsChecked.Add(afterTarget.TargetName))
+                            {
+                                targetsToCheckForAfterTargets.Enqueue(afterTarget.TargetName);
+                            }
                         }
                     }
                 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index a8a180adb6e..98acfa7cee3 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -32,7 +32,7 @@ internal enum TargetEntryState
     {
         /// <summary>
         /// The target's dependencies need to be evaluated and pushed onto the target stack.
-        /// 
+        ///
         /// Transitions:
         /// Execution, ErrorExecution
         /// </summary>
@@ -40,7 +40,7 @@ internal enum TargetEntryState
 
         /// <summary>
         /// The target is ready to execute its tasks, batched as needed.
-        /// 
+        ///
         /// Transitions:
         /// ErrorExecution, Completed
         /// </summary>
@@ -48,7 +48,7 @@ internal enum TargetEntryState
 
         /// <summary>
         /// The target is ready to provide error tasks.
-        /// 
+        ///
         /// Transitions:
         /// None
         /// </summary>
@@ -56,7 +56,7 @@ internal enum TargetEntryState
 
         /// <summary>
         /// The target has finished building.  All of the results are in the Lookup.
-        /// 
+        ///
         /// Transitions:
         /// None
         /// </summary>
@@ -163,11 +163,11 @@ internal class TargetEntry : IEquatable<TargetEntry>
         /// <param name="stopProcessingOnCompletion">True if the target builder should stop processing the current target stack when this target is complete.</param>
         internal TargetEntry(BuildRequestEntry requestEntry, ITargetBuilderCallback targetBuilderCallback, TargetSpecification targetSpecification, Lookup baseLookup, TargetEntry parentTarget, TargetBuiltReason buildReason, IBuildComponentHost host, bool stopProcessingOnCompletion)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(requestEntry, "requestEntry");
-            ErrorUtilities.VerifyThrowArgumentNull(targetBuilderCallback, "targetBuilderCallback");
+            ErrorUtilities.VerifyThrowArgumentNull(requestEntry, nameof(requestEntry));
+            ErrorUtilities.VerifyThrowArgumentNull(targetBuilderCallback, nameof(targetBuilderCallback));
             ErrorUtilities.VerifyThrowArgumentNull(targetSpecification, "targetName");
             ErrorUtilities.VerifyThrowArgumentNull(baseLookup, "lookup");
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
 
             _requestEntry = requestEntry;
             _targetBuilderCallback = targetBuilderCallback;
@@ -243,7 +243,7 @@ internal TargetResult Result
         }
 
         /// <summary>
-        /// Retrieves the Lookup this target was initialized with, including any modifications which have 
+        /// Retrieves the Lookup this target was initialized with, including any modifications which have
         /// been made to it while running.
         /// </summary>
         internal Lookup Lookup
@@ -362,7 +362,7 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
                 if (!projectLoggingContext.LoggingService.OnlyLogCriticalEvents)
                 {
                     // Expand the expression for the Log.  Since we know the condition evaluated to false, leave unexpandable properties in the condition so as not to cause an error
-                    string expanded = _expander.ExpandIntoStringAndUnescape(_target.Condition, ExpanderOptions.ExpandPropertiesAndItems | ExpanderOptions.LeavePropertiesUnexpandedOnError, _target.ConditionLocation);
+                    string expanded = _expander.ExpandIntoStringAndUnescape(_target.Condition, ExpanderOptions.ExpandPropertiesAndItems | ExpanderOptions.LeavePropertiesUnexpandedOnError | ExpanderOptions.Truncate, _target.ConditionLocation);
 
                     // By design: Not building dependencies. This is what NAnt does too.
                     // NOTE: In the original code, this was logged from the target logging context.  However, the target
@@ -432,7 +432,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                 string projectFullPath = requestEntry.RequestConfiguration.ProjectFullPath;
 
                 string parentTargetName = null;
-                if (ParentEntry != null && ParentEntry.Target != null)
+                if (ParentEntry?.Target != null)
                 {
                     parentTargetName = ParentEntry.Target.Name;
                 }
@@ -531,7 +531,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                                 entryForInference = null;
                                 entryForExecution.LeaveScope();
                                 entryForExecution = null;
-                                targetSuccess = (bucketResult != null) && (bucketResult.ResultCode == WorkUnitResultCode.Success);
+                                targetSuccess = (bucketResult?.ResultCode == WorkUnitResultCode.Success);
                                 break;
 
                             case DependencyAnalysisResult.SkipNoInputs:
@@ -546,17 +546,8 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                         // Make sure the Invalid Project error gets logged *before* TargetFinished.  Otherwise,
                         // the log is confusing.
                         targetLoggingContext.LogInvalidProjectFileError(e);
-
-                        if (null != entryForInference)
-                        {
-                            entryForInference.LeaveScope();
-                        }
-
-                        if (null != entryForExecution)
-                        {
-                            entryForExecution.LeaveScope();
-                        }
-
+                        entryForInference?.LeaveScope();
+                        entryForExecution?.LeaveScope();
                         aggregateResult = aggregateResult.AggregateResult(new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, null));
                     }
                     finally
@@ -653,11 +644,11 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                 }
                 finally
                 {
-                    if (targetLoggingContext != null)
-                    {
+                       
+                    
                         // log the last target finished since we now have the target outputs. 
-                        targetLoggingContext.LogTargetBatchFinished(projectFullPath, targetSuccess, targetOutputItems != null && targetOutputItems.Count > 0 ? targetOutputItems : null);
-                    }
+                        targetLoggingContext?.LogTargetBatchFinished(projectFullPath, targetSuccess, targetOutputItems?.Count > 0 ? targetOutputItems : null);
+                    
                 }
 
                 _targetResult = new TargetResult(targetOutputItems.ToArray(), aggregateResult);
@@ -724,7 +715,7 @@ internal List<TargetSpecification> GetErrorTargets(ProjectLoggingContext project
 
             // If this target never executed (for instance, because one of its dependencies errored) then we need to
             // create a result for this target to report when it gets to the Completed state.
-            if (null == _targetResult)
+            if (_targetResult == null)
             {
                 _targetResult = new TargetResult(Array.Empty<TaskItem>(), new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, null));
             }
@@ -753,7 +744,7 @@ internal TargetResult GatherResults()
         /// <param name="lookup">The lookup to enter with.</param>
         internal void EnterLegacyCallTargetScope(Lookup lookup)
         {
-            if (null == _legacyCallTargetScopes)
+            if (_legacyCallTargetScopes == null)
             {
                 _legacyCallTargetScopes = new Stack<Lookup.Scope>();
             }
@@ -789,7 +780,7 @@ internal void MarkForStop()
         /// </summary>
         internal void LeaveLegacyCallTargetScopes()
         {
-            if (null != _legacyCallTargetScopes)
+            if (_legacyCallTargetScopes != null)
             {
                 while (_legacyCallTargetScopes.Count != 0)
                 {
@@ -859,7 +850,7 @@ private async Task<WorkUnitResult> ProcessBucket(ITaskBuilder taskBuilder, Targe
         }
 
         /// <summary>
-        /// Gets the task execution mode based 
+        /// Gets the task execution mode based
         /// </summary>
         /// <param name="analysis">The result of the up-to-date check.</param>
         /// <returns>The mode to be used to execute tasks.</returns>
@@ -880,7 +871,7 @@ private TaskExecutionMode GetTaskExecutionMode(DependencyAnalysisResult analysis
             if ((analysis == DependencyAnalysisResult.FullBuild) ||
                 (analysis == DependencyAnalysisResult.IncrementalBuild))
             {
-                executionMode = executionMode | TaskExecutionMode.ExecuteTaskAndGatherOutputs;
+                executionMode |= TaskExecutionMode.ExecuteTaskAndGatherOutputs;
             }
 
             return executionMode;
@@ -898,7 +889,7 @@ private void VerifyState(TargetEntryState actual, TargetEntryState expected)
 
         /// <summary>
         /// Gets the list of parameters which are batchable for a target
-        /// PERF: (Refactor) This used to be a method on the target, and it would 
+        /// PERF: (Refactor) This used to be a method on the target, and it would
         /// cache its values so this would only be computed once for each
         /// target.  We should consider doing something similar for perf reasons.
         /// </summary>
@@ -917,7 +908,7 @@ private List<string> GetBatchableParametersForTarget()
                 batchableTargetParameters.Add(_target.Outputs);
             }
 
-            if (_target.Returns != null && _target.Returns.Length > 0)
+            if (!string.IsNullOrEmpty(_target.Returns))
             {
                 batchableTargetParameters.Add(_target.Returns);
             }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
index 44bac11a478..a2efa711584 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
@@ -26,8 +26,8 @@ internal class TargetSpecification : ITranslatable
         /// <param name="referenceLocation">The location from which it was referred.</param>
         internal TargetSpecification(string targetName, ElementLocation referenceLocation)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(targetName, "targetName");
-            ErrorUtilities.VerifyThrowArgumentNull(referenceLocation, "referenceLocation");
+            ErrorUtilities.VerifyThrowArgumentLength(targetName, nameof(targetName));
+            ErrorUtilities.VerifyThrowArgumentNull(referenceLocation, nameof(referenceLocation));
 
             this._targetName = targetName;
             this._referenceLocation = referenceLocation;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
index c141a8cf4a4..dd967758bb7 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
@@ -153,24 +153,13 @@ out ItemDictionary<ProjectItemInstance> upToDateTargetInputs
             }
             else
             {
-                ItemVectorPartitionCollection itemVectorsInTargetInputs;
-                ItemVectorPartitionCollection itemVectorTransformsInTargetInputs;
-                Dictionary<string, string> discreteItemsInTargetInputs; // UNDONE: (Refactor) Change to HashSet
-
-                ItemVectorPartitionCollection itemVectorsInTargetOutputs;
-                Dictionary<string, string> discreteItemsInTargetOutputs; // UNDONE: (Refactor) Change to HashSet
-                List<string> targetOutputItemSpecs;
-
                 ParseTargetInputOutputSpecifications(bucket,
-                    out itemVectorsInTargetInputs,
-                    out itemVectorTransformsInTargetInputs,
-                    out discreteItemsInTargetInputs,
-                    out itemVectorsInTargetOutputs,
-                    out discreteItemsInTargetOutputs,
-                    out targetOutputItemSpecs);
-
-                List<string> itemVectorsReferencedInBothTargetInputsAndOutputs = null;
-                List<string> itemVectorsReferencedOnlyInTargetInputs = null;
+                    out ItemVectorPartitionCollection itemVectorsInTargetInputs,
+                    out ItemVectorPartitionCollection itemVectorTransformsInTargetInputs,
+                    out Dictionary<string, string> discreteItemsInTargetInputs,
+                    out ItemVectorPartitionCollection itemVectorsInTargetOutputs,
+                    out Dictionary<string, string> discreteItemsInTargetOutputs,
+                    out List<string> targetOutputItemSpecs);
                 List<string> itemVectorsReferencedOnlyInTargetOutputs = null;
 
                 // if the target has no outputs because the output specification evaluated to empty
@@ -189,8 +178,8 @@ out ItemDictionary<ProjectItemInstance> upToDateTargetInputs
                     // depending on the transform expression, there might be no relation between the results of the transforms; as
                     // a result, input items that are item vector transforms are treated as discrete items
                     DiffHashtables(itemVectorsInTargetInputs, itemVectorsInTargetOutputs,
-                        out itemVectorsReferencedInBothTargetInputsAndOutputs,
-                        out itemVectorsReferencedOnlyInTargetInputs,
+                        out List<string> itemVectorsReferencedInBothTargetInputsAndOutputs,
+                        out List<string> itemVectorsReferencedOnlyInTargetInputs,
                         out itemVectorsReferencedOnlyInTargetOutputs);
 
                     // if there are no item vectors only referenced by output items...
@@ -235,7 +224,7 @@ out ItemDictionary<ProjectItemInstance> upToDateTargetInputs
                 // 1) they do not reference any item vector
                 // 2) they reference item vectors that are not referenced by any input item
                 if ((discreteItemsInTargetOutputs.Count > 0) ||
-                    ((itemVectorsReferencedOnlyInTargetOutputs != null) && (itemVectorsReferencedOnlyInTargetOutputs.Count > 0)))
+                    ((itemVectorsReferencedOnlyInTargetOutputs?.Count > 0)))
                 {
                     result = PerformDependencyAnalysisIfDiscreteOutputs(
                                 itemVectorsInTargetInputs, itemVectorTransformsInTargetInputs, discreteItemsInTargetInputs,
@@ -460,7 +449,6 @@ private DependencyAnalysisResult PerformDependencyAnalysisIfNoInputs()
                 _loggingService.LogComment(_buildEventContext, MessageImportance.Low, "BuildTargetCompletely", _targetToAnalyze.Name);
                 _loggingService.LogComment(_buildEventContext, MessageImportance.Low, "BuildTargetCompletelyNoInputsSpecified");
 
-
                 // otherwise, do a full build
                 result = DependencyAnalysisResult.FullBuild;
             }
@@ -556,8 +544,7 @@ List<string> targetOutputItemSpecs
                 }
 
                 // if any output item is out-of-date w.r.t. any discrete input item, do a full build
-                DependencyAnalysisLogDetail dependencyAnalysisDetailEntry;
-                bool someOutOfDate = IsAnyOutOfDate(out dependencyAnalysisDetailEntry, _project.Directory, inputs, outputs);
+                bool someOutOfDate = IsAnyOutOfDate(out DependencyAnalysisLogDetail dependencyAnalysisDetailEntry, _project.Directory, inputs, outputs);
 
                 if (someOutOfDate)
                 {
@@ -656,8 +643,7 @@ out ItemDictionary<ProjectItemInstance> upToDateTargetInputs
                             else
                             {
                                 // if any input is newer than any output, do a full build
-                                DependencyAnalysisLogDetail dependencyAnalysisDetailEntry;
-                                bool someOutOfDate = IsAnyOutOfDate(out dependencyAnalysisDetailEntry, _project.Directory, upToDateInputItems, outputItems);
+                                bool someOutOfDate = IsAnyOutOfDate(out DependencyAnalysisLogDetail dependencyAnalysisDetailEntry, _project.Directory, upToDateInputItems, outputItems);
 
                                 if (someOutOfDate)
                                 {
@@ -742,8 +728,6 @@ private DependencyAnalysisResult PerformDependencyAnalysisIfDiscreteOutputs
             List<string> targetOutputItemSpecs
         )
         {
-            DependencyAnalysisResult result = DependencyAnalysisResult.SkipUpToDate;
-
             List<string> targetInputItemSpecs = GetItemSpecsFromItemVectors(itemVectorsInTargetInputs);
             targetInputItemSpecs.AddRange(GetItemSpecsFromItemVectors(itemVectorTransformsInTargetInputs));
             targetInputItemSpecs.AddRange(discreteItemsInTargetInputs.Values);
@@ -762,9 +746,9 @@ List<string> targetOutputItemSpecs
             }
 
             // if any input is newer than any output, do a full build
-            DependencyAnalysisLogDetail dependencyAnalysisDetailEntry;
-            bool someOutOfDate = IsAnyOutOfDate(out dependencyAnalysisDetailEntry, _project.Directory, inputs, outputs);
+            bool someOutOfDate = IsAnyOutOfDate(out DependencyAnalysisLogDetail dependencyAnalysisDetailEntry, _project.Directory, inputs, outputs);
 
+            DependencyAnalysisResult result;
             if (someOutOfDate)
             {
                 _dependencyAnalysisDetail.Add(dependencyAnalysisDetailEntry);
@@ -820,8 +804,7 @@ ElementLocation elementLocation
                 ProjectItemInstanceFactory itemFactory = new ProjectItemInstanceFactory(
                     _project /* no item type specified; use item type of vector itself */);
 
-                bool isTransformExpression;
-                IList<ProjectItemInstance> itemVectorContents = bucket.Expander.ExpandSingleItemVectorExpressionIntoItems(item, itemFactory, ExpanderOptions.ExpandItems, true /* include null entries from transforms */, out isTransformExpression, elementLocation);
+                IList<ProjectItemInstance> itemVectorContents = bucket.Expander.ExpandSingleItemVectorExpressionIntoItems(item, itemFactory, ExpanderOptions.ExpandItems, true /* include null entries from transforms */, out bool isTransformExpression, elementLocation);
 
                 if (itemVectorContents != null)
                 {
@@ -829,11 +812,11 @@ ElementLocation elementLocation
 
                     if (itemVectorContents.Count > 0)
                     {
-                        ItemVectorPartitionCollection itemVectorCollection = null;
 
                         // Expander set the item type it found
                         string itemVectorType = itemFactory.ItemType;
 
+                        ItemVectorPartitionCollection itemVectorCollection;
                         if (itemVectorTransforms == null || !isTransformExpression)
                         {
                             // We either don't want transforms separated out, or this was not a transform.
@@ -1074,7 +1057,6 @@ internal static bool IsAnyOutOfDate<T>(out DependencyAnalysisLogDetail dependenc
             return false;
         }
 
-
         /// <summary>
         /// Record the unique input and output files so that the "up to date" message
         /// can list them in the log later.
@@ -1127,11 +1109,9 @@ private void RecordUniqueInputsAndOutputs<T>(IList<T> inputs, IList<T> outputs)
         /// <returns>true, if "input" is newer than "output"</returns>
         private bool IsOutOfDate(string input, string output, string inputItemName, string outputItemName)
         {
-            bool inputDoesNotExist;
-            bool outputDoesNotExist;
             input = EscapingUtilities.UnescapeAll(FileUtilities.FixFilePath(input));
             output = EscapingUtilities.UnescapeAll(FileUtilities.FixFilePath(output));
-            bool outOfDate = (CompareLastWriteTimes(input, output, out inputDoesNotExist, out outputDoesNotExist) == 1) || inputDoesNotExist;
+            bool outOfDate = (CompareLastWriteTimes(input, output, out bool inputDoesNotExist, out bool outputDoesNotExist) == 1) || inputDoesNotExist;
 
             // Only if we are not logging just critical events should we be gathering full details
             if (!_loggingService.OnlyLogCriticalEvents)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 23a6fc8d5aa..d3431b4bf8c 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -48,7 +48,7 @@ internal enum ContinueOnError
 
     /// <summary>
     /// The TaskBuilder is one of two components related to building tasks, the other being the TaskExecutionHost.  The TaskBuilder is
-    /// responsible for all parts dealing with the XML/task declaration.  It determines if the task is intrinsic or extrinsic, 
+    /// responsible for all parts dealing with the XML/task declaration.  It determines if the task is intrinsic or extrinsic,
     /// looks up the task in the task registry, determines the task parameters and requests them to be set, and requests outputs
     /// when task execution has been completed.  It is not responsible for reflection over the task instance or anything which
     /// requires dealing with the task instance directly - those actions are handled by the TaskExecutionHost.
@@ -77,7 +77,7 @@ internal class TaskBuilder : ITaskBuilder, IBuildComponent
 
         /// <summary>
         /// The task instance for extrinsic tasks
-        /// </summary> 
+        /// </summary>
         private ProjectTaskInstance _taskNode;
 
         /// <summary>
@@ -87,7 +87,7 @@ internal class TaskBuilder : ITaskBuilder, IBuildComponent
 
         /// <summary>
         /// indicates whether to ignore task execution failures
-        /// </summary> 
+        /// </summary>
         private ContinueOnError _continueOnError;
 
         /// <summary>
@@ -135,7 +135,7 @@ internal TaskBuilder()
         /// <param name="cancellationToken">The <see cref="CancellationToken"/> to use when executing the task.</param>
         /// <returns>The result of running the task batch.</returns>
         /// <remarks>
-        /// The ExecuteTask method takes a task as specified by XML and executes it.  This procedure is comprised 
+        /// The ExecuteTask method takes a task as specified by XML and executes it.  This procedure is comprised
         /// of the following steps:
         /// 1. Loading the Task from its containing assembly by looking it up in the task registry
         /// 2. Determining if the task is batched.  If it is, create the batches and execute each as if it were a non-batched task
@@ -205,10 +205,7 @@ public void ShutdownComponent()
                 _componentHost = null;
 
                 IDisposable disposable = _taskExecutionHost as IDisposable;
-                if (disposable != null)
-                {
-                    disposable.Dispose();
-                }
+                disposable?.Dispose();
 
                 _taskExecutionHost = null;
             }
@@ -284,12 +281,12 @@ private List<string> CreateListOfParameterValues()
         }
 
         /// <summary>
-        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it. 
+        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it.
         /// </summary>
         /// <returns>true, if successful</returns>
         private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lookup)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(lookup, "lookup");
+            ErrorUtilities.VerifyThrowArgumentNull(lookup, nameof(lookup));
 
             WorkUnitResult taskResult = new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, null);
             TaskHost taskHost = null;
@@ -334,7 +331,7 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
                         break;
                     }
                 }
-                
+
                 taskResult = aggregateResult;
             }
             finally
@@ -342,10 +339,7 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
                 _taskExecutionHost.CleanupForTask();
 
 #if FEATURE_APPDOMAIN
-                if (taskHost != null)
-                {
-                    taskHost.MarkAsInactive();
-                }
+                taskHost?.MarkAsInactive();
 #endif
 
                 // Now all task batches are done, apply all item adds to the outer 
@@ -366,7 +360,7 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
         /// <summary>
         /// Execute a single bucket
         /// </summary>
-        /// <returns>true if execution succeeded</returns>        
+        /// <returns>true if execution succeeded</returns>
         private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket bucket, TaskExecutionMode howToExecuteTask, Dictionary<string, string> lookupHash)
         {
             // On Intrinsic tasks, we do not allow batchable params, therefore metadata is excluded.
@@ -388,9 +382,7 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
             if (!condition)
             {
                 LogSkippedTask(bucket, howToExecuteTask);
-                taskResult = new WorkUnitResult(WorkUnitResultCode.Skipped, WorkUnitActionCode.Continue, null);
-
-                return taskResult;
+                return new WorkUnitResult(WorkUnitResultCode.Skipped, WorkUnitActionCode.Continue, null);
             }
 
             // Some tests do not provide an actual taskNode; checking if _taskNode == null prevents those tests from failing.
@@ -430,7 +422,7 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                         try
                         {
                             if (
-                                ((requirements.Value & TaskRequirements.RequireSTAThread) == TaskRequirements.RequireSTAThread)
+                                (requirements.Value & TaskRequirements.RequireSTAThread) == TaskRequirements.RequireSTAThread
 #if FEATURE_APARTMENT_STATE
                                 && (Thread.CurrentThread.GetApartmentState() != ApartmentState.STA)
 #endif
@@ -518,7 +510,7 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
         }
 
         /// <summary>
-        /// Returns the set of parameters that can contribute to a task's identity, and their values for this particular task.  
+        /// Returns the set of parameters that can contribute to a task's identity, and their values for this particular task.
         /// </summary>
         private IDictionary<string, string> GatherTaskIdentityParameters(Expander<ProjectPropertyInstance, ProjectItemInstance> expander)
         {
@@ -545,14 +537,13 @@ private IDictionary<string, string> GatherTaskIdentityParameters(Expander<Projec
             return taskIdentityParameters;
         }
 
-
 #if FEATURE_APARTMENT_STATE
         /// <summary>
         /// Executes the task using an STA thread.
         /// </summary>
         /// <comment>
-        /// STA thread launching also being used in XMakeCommandLine\OutOfProcTaskAppDomainWrapperBase.cs, InstantiateAndExecuteTaskInSTAThread method.  
-        /// Any bug fixes made to this code, please ensure that you also fix that code.  
+        /// STA thread launching also being used in XMakeCommandLine\OutOfProcTaskAppDomainWrapperBase.cs, InstantiateAndExecuteTaskInSTAThread method.
+        /// Any bug fixes made to this code, please ensure that you also fix that code.
         /// </comment>
         [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Exception is caught and rethrown in the correct thread.")]
         private WorkUnitResult ExecuteTaskInSTAThread(ItemBucket bucket, TaskLoggingContext taskLoggingContext, IDictionary<string, string> taskIdentityParameters, TaskHost taskHost, TaskExecutionMode howToExecuteTask)
@@ -597,10 +588,7 @@ private WorkUnitResult ExecuteTaskInSTAThread(ItemBucket bucket, TaskLoggingCont
                 taskRunnerFinished = null;
             }
 
-            if (exceptionFromExecution != null)
-            {
-                exceptionFromExecution.Throw();
-            }
+            exceptionFromExecution?.Throw();
 
             return taskResult;
         }
@@ -619,7 +607,7 @@ private void LogSkippedTask(ItemBucket bucket, TaskExecutionMode howToExecuteTas
                     if (!_targetLoggingContext.LoggingService.OnlyLogCriticalEvents)
                     {
                         // Expand the expression for the Log.  Since we know the condition evaluated to false, leave unexpandable properties in the condition so as not to cause an error
-                        string expanded = bucket.Expander.ExpandIntoStringAndUnescape(_targetChildInstance.Condition, ExpanderOptions.ExpandAll | ExpanderOptions.LeavePropertiesUnexpandedOnError, _targetChildInstance.ConditionLocation);
+                        string expanded = bucket.Expander.ExpandIntoStringAndUnescape(_targetChildInstance.Condition, ExpanderOptions.ExpandAll | ExpanderOptions.LeavePropertiesUnexpandedOnError | ExpanderOptions.Truncate, _targetChildInstance.ConditionLocation);
 
                         // Whilst we are within the processing of the task, we haven't actually started executing it, so
                         // our skip task message needs to be in the context of the target. However any errors should be reported
@@ -873,7 +861,7 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                         _continueOnError = ContinueOnError.ErrorAndStop;
 
                         // Rethrow wrapped in order to avoid losing the callstack
-                        throw new BuildAbortedException(taskException.Message, ((BuildAbortedException)taskException));
+                        throw new BuildAbortedException(taskException.Message, (BuildAbortedException)taskException);
                     }
                     else if (type == typeof(CircularDependencyException))
                     {
@@ -1191,7 +1179,7 @@ ItemBucket bucket
         {
             string taskParameterAttribute = _taskNode.GetParameter(taskParameterName);
 
-            if (null != taskParameterAttribute)
+            if (taskParameterAttribute != null)
             {
                 ProjectTaskOutputItemInstance taskItemInstance = taskOutputSpecification as ProjectTaskOutputItemInstance;
                 if (taskItemInstance != null)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 81e53c7ba6b..074df8881d9 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -5,6 +5,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Globalization;
+using System.IO.Pipes;
 #if FEATURE_APPDOMAIN
 using System.Runtime.Remoting.Lifetime;
 using System.Runtime.Remoting;
@@ -23,6 +24,7 @@
 using Microsoft.Build.BackEnd.Components.Caching;
 using System.Reflection;
 using Microsoft.Build.Eventing;
+using Microsoft.Build.Internal;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -34,10 +36,10 @@ internal class TaskHost :
 #if FEATURE_APPDOMAIN
         MarshalByRefObject,
 #endif
-        IBuildEngine7
+        IBuildEngine7, IRarBuildEngine
     {
         /// <summary>
-        /// True if the "secret" environment variable MSBUILDNOINPROCNODE is set. 
+        /// True if the "secret" environment variable MSBUILDNOINPROCNODE is set.
         /// </summary>
         private static bool s_onlyUseOutOfProcNodes = Environment.GetEnvironmentVariable("MSBUILDNOINPROCNODE") == "1";
 
@@ -114,9 +116,9 @@ internal class TaskHost :
         /// <param name="targetBuilderCallback">An <see cref="ITargetBuilderCallback"/> to use to invoke targets and build projects.</param>
         public TaskHost(IBuildComponentHost host, BuildRequestEntry requestEntry, ElementLocation taskLocation, ITargetBuilderCallback targetBuilderCallback)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
-            ErrorUtilities.VerifyThrowArgumentNull(requestEntry, "requestEntry");
-            ErrorUtilities.VerifyThrowInternalNull(taskLocation, "taskLocation");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
+            ErrorUtilities.VerifyThrowArgumentNull(requestEntry, nameof(requestEntry));
+            ErrorUtilities.VerifyThrowInternalNull(taskLocation, nameof(taskLocation));
 
             _host = host;
             _requestEntry = requestEntry;
@@ -131,7 +133,7 @@ public TaskHost(IBuildComponentHost host, BuildRequestEntry requestEntry, Elemen
         /// Returns true in the multiproc case
         /// </summary>
         /// <comment>
-        /// If MSBUILDNOINPROCNODE is set, then even if there's only one node in the buildparameters, it will be an out-of-proc node.  
+        /// If MSBUILDNOINPROCNODE is set, then even if there's only one node in the buildparameters, it will be an out-of-proc node.
         /// </comment>
         public bool IsRunningMultipleNodes
         {
@@ -320,7 +322,7 @@ public bool BuildProjectFilesInParallel(string[] projectFileNames, string[] targ
         #region IBuildEngine3 Members
 
         /// <summary>
-        /// Builds multiple project files in parallel. 
+        /// Builds multiple project files in parallel.
         /// Thread safe.
         /// </summary>
         /// <param name="projectFileNames">The list of projects to build</param>
@@ -388,7 +390,7 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
         {
             lock (_callbackMonitor)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+                ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
                 if (!_activeProxy)
                 {
@@ -459,7 +461,7 @@ public void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e)
         {
             lock (_callbackMonitor)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+                ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
                 if (!_activeProxy)
                 {
@@ -500,7 +502,7 @@ public void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e)
         {
             lock (_callbackMonitor)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+                ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
                 if (!_activeProxy)
                 {
@@ -541,7 +543,7 @@ public void LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e)
         {
             lock (_callbackMonitor)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+                ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
                 if (!_activeProxy)
                 {
@@ -632,7 +634,7 @@ public void LogTelemetry(string eventName, IDictionary<string, string> propertie
         {
             lock (_callbackMonitor)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(eventName, "eventName");
+                ErrorUtilities.VerifyThrowArgumentNull(eventName, nameof(eventName));
 
                 if (!_activeProxy)
                 {
@@ -683,8 +685,8 @@ public IReadOnlyDictionary<string, string> GetGlobalProperties()
         /// </summary>
         public async Task<BuildEngineResult> InternalBuildProjects(string[] projectFileNames, string[] targetNames, IDictionary[] globalProperties, IList<String>[] undefineProperties, string[] toolsVersion, bool returnTargetOutputs, bool skipNonexistentTargets = false)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFileNames, "projectFileNames");
-            ErrorUtilities.VerifyThrowArgumentNull(globalProperties, "globalProperties");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFileNames, nameof(projectFileNames));
+            ErrorUtilities.VerifyThrowArgumentNull(globalProperties, nameof(globalProperties));
             VerifyActiveProxy();
 
             BuildEngineResult result;
@@ -726,7 +728,7 @@ public async Task<BuildEngineResult> InternalBuildProjects(string[] projectFileN
 #if FEATURE_APPDOMAIN
         /// <inheritdoc />
         /// <summary>
-        /// InitializeLifetimeService is called when the remote object is activated. 
+        /// InitializeLifetimeService is called when the remote object is activated.
         /// This method will determine how long the lifetime for the object will be.
         /// </summary>
         /// <returns>The lease object to control this object's lifetime.</returns>
@@ -811,10 +813,7 @@ internal void MarkAsInactive()
                 {
                     ILease lease = (ILease)RemotingServices.GetLifetimeService(this);
 
-                    if (lease != null)
-                    {
-                        lease.Unregister(_sponsor);
-                    }
+                    lease?.Unregister(_sponsor);
 
                     _sponsor.Close();
                     _sponsor = null;
@@ -851,8 +850,8 @@ internal bool IsEventSerializable(BuildEventArgs e)
         /// <returns>A Task returning a structure containing the result of the build, success or failure and the list of target outputs per project</returns>
         private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[] projectFileNames, string[] targetNames, IDictionary[] globalProperties, IList<String>[] undefineProperties, string[] toolsVersion, bool returnTargetOutputs, bool skipNonexistentTargets = false)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFileNames, "projectFileNames");
-            ErrorUtilities.VerifyThrowArgumentNull(globalProperties, "globalProperties");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFileNames, nameof(projectFileNames));
+            ErrorUtilities.VerifyThrowArgumentNull(globalProperties, nameof(globalProperties));
             VerifyActiveProxy();
 
             List<IDictionary<string, ITaskItem[]>> targetOutputsPerProject = null;
@@ -934,10 +933,7 @@ private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[]
                     // Now walk through the results, and report that subset which was asked for.
                     for (int i = 0; i < results.Length; i++)
                     {
-                        if (targetOutputsPerProject != null)
-                        {
-                            targetOutputsPerProject.Add(new Dictionary<string, ITaskItem[]>(StringComparer.OrdinalIgnoreCase));
-                        }
+                        targetOutputsPerProject?.Add(new Dictionary<string, ITaskItem[]>(StringComparer.OrdinalIgnoreCase));
 
                         foreach (KeyValuePair<string, TargetResult> resultEntry in results[i].ResultsByTarget)
                         {
@@ -972,7 +968,7 @@ private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[]
                         }
                     }
 
-                    ErrorUtilities.VerifyThrow(results.Length == projectFileNames.Length || overallSuccess == false, "The number of results returned {0} cannot be less than the number of project files {1} unless one of the results indicated failure.", results.Length, projectFileNames.Length);
+                    ErrorUtilities.VerifyThrow(results.Length == projectFileNames.Length || !overallSuccess, "The number of results returned {0} cannot be less than the number of project files {1} unless one of the results indicated failure.", results.Length, projectFileNames.Length);
                 }
 
                 BuildRequestsSucceeded = overallSuccess;
@@ -987,7 +983,36 @@ private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[]
         /// </summary>
         private void VerifyActiveProxy()
         {
-            ErrorUtilities.VerifyThrow(_activeProxy == true, "Attempted to use an inactive task host.");
+            ErrorUtilities.VerifyThrow(_activeProxy, "Attempted to use an inactive task host.");
+        }
+
+        /// <summary>
+        /// Initialize new RAR node
+        /// </summary>
+        bool IRarBuildEngine.CreateRarNode()
+        {
+            return BuildManager.DefaultBuildManager.CreateRarNode();
+        }
+
+        /// <summary>
+        /// Provides RAR node name for current configuration
+        /// </summary>
+        string IRarBuildEngine.GetRarPipeName()
+        {
+            BuildParameters parameters = _host.BuildParameters;
+            return CommunicationsUtilities.GetRarPipeName(parameters.EnableNodeReuse, parameters.LowPriority);
+        }
+
+        /// <summary>
+        /// Constructs <seealso cref="NamedPipeClientStream"/>
+        /// </summary>
+        NamedPipeClientStream IRarBuildEngine.GetRarClientStream(string pipeName, int timeout)
+        {
+            BuildParameters parameters = _host.BuildParameters;
+            Handshake handshake = NodeProviderOutOfProc.GetHandshake(enableNodeReuse: parameters.EnableNodeReuse,
+                                                         enableLowPriority: parameters.LowPriority, specialNode: true);
+
+            return NamedPipeUtil.TryConnectToProcess(pipeName, timeout, handshake);
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
index 3bd3b5969da..b9dc833cdf9 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
@@ -125,8 +125,8 @@ internal class SchedulableRequest
         /// </summary>
         public SchedulableRequest(SchedulingData collection, BuildRequest request, SchedulableRequest parent)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(collection, "collection");
-            ErrorUtilities.VerifyThrowArgumentNull(request, "request");
+            ErrorUtilities.VerifyThrowArgumentNull(collection, nameof(collection));
+            ErrorUtilities.VerifyThrowArgumentNull(request, nameof(request));
             ErrorUtilities.VerifyThrow((parent == null) || (parent._schedulingData == collection), "Parent request does not belong to the same collection.");
 
             _schedulingData = collection;
@@ -305,7 +305,7 @@ public TimeSpan GetTimeSpentInState(SchedulableRequestState desiredState)
         public void Yield(string[] activeTargets)
         {
             VerifyState(SchedulableRequestState.Executing);
-            ErrorUtilities.VerifyThrowArgumentNull(activeTargets, "activeTargets");
+            ErrorUtilities.VerifyThrowArgumentNull(activeTargets, nameof(activeTargets));
             _activeTargetsWhenBlocked = activeTargets;
             ChangeToState(SchedulableRequestState.Yielding);
         }
@@ -325,12 +325,12 @@ public void Reacquire()
         /// </summary>
         /// <param name="blockingRequest">The request which is blocking this one.</param>
         /// <param name="activeTargets">The list of targets this request was currently building at the time it became blocked.</param>
-        /// <param name="blockerBlockingTarget">Target that we are blocked on which is being built by <paramref name="blockingRequest"/></param>
+        /// <param name="blockingTarget">Target that we are blocked on which is being built by <paramref name="blockingRequest"/></param>
         public void BlockByRequest(SchedulableRequest blockingRequest, string[] activeTargets, string blockingTarget = null)
         {
             VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Blocked, SchedulableRequestState.Executing });
-            ErrorUtilities.VerifyThrowArgumentNull(blockingRequest, "blockingRequest");
-            ErrorUtilities.VerifyThrowArgumentNull(activeTargets, "activeTargets");
+            ErrorUtilities.VerifyThrowArgumentNull(blockingRequest, nameof(blockingRequest));
+            ErrorUtilities.VerifyThrowArgumentNull(activeTargets, nameof(activeTargets));
             ErrorUtilities.VerifyThrow(BlockingTarget == null, "Cannot block again if we're already blocked on a target");
 
             // Note that the blocking request will typically be our parent UNLESS it is a request we blocked on because it was executing a target we wanted to execute.
@@ -366,7 +366,7 @@ public void BlockByRequest(SchedulableRequest blockingRequest, string[] activeTa
         public void UnblockWithPartialResultForBlockingTarget(BuildResult result)
         {
             VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Blocked, SchedulableRequestState.Unscheduled });
-            ErrorUtilities.VerifyThrowArgumentNull(result, "result");
+            ErrorUtilities.VerifyThrowArgumentNull(result, nameof(result));
 
             BlockingRequestKey key = new BlockingRequestKey(result);
             DisconnectRequestWeAreBlockedBy(key);
@@ -379,7 +379,7 @@ public void UnblockWithPartialResultForBlockingTarget(BuildResult result)
         public void UnblockWithResult(BuildResult result)
         {
             VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Blocked, SchedulableRequestState.Unscheduled });
-            ErrorUtilities.VerifyThrowArgumentNull(result, "result");
+            ErrorUtilities.VerifyThrowArgumentNull(result, nameof(result));
 
             BlockingRequestKey key = new BlockingRequestKey(result);
             DisconnectRequestWeAreBlockedBy(key);
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index d34a2df0426..4dc54d08360 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -33,9 +33,9 @@ internal class Scheduler : IScheduler
         internal const int InvalidNodeId = -1;
 
         /// <summary>
-        /// ID used to indicate that the results for a particular configuration may at one point 
-        /// have resided on this node, but currently do not and will need to be transferred back 
-        /// in order to be used.  
+        /// ID used to indicate that the results for a particular configuration may at one point
+        /// have resided on this node, but currently do not and will need to be transferred back
+        /// in order to be used.
         /// </summary>
         internal const int ResultsTransferredId = -2;
 
@@ -50,8 +50,8 @@ internal class Scheduler : IScheduler
         internal const int VirtualNode = 0;
 
         /// <summary>
-        /// If MSBUILDCUSTOMSCHEDULER = CustomSchedulerForSQL, the default multiplier for the amount by which 
-        /// the count of configurations on any one node can exceed the average configuration count is 1.1 -- 
+        /// If MSBUILDCUSTOMSCHEDULER = CustomSchedulerForSQL, the default multiplier for the amount by which
+        /// the count of configurations on any one node can exceed the average configuration count is 1.1 --
         /// + 10%.
         /// </summary>
         private const double DefaultCustomSchedulerForSQLConfigurationLimitMultiplier = 1.1;
@@ -81,13 +81,13 @@ internal class Scheduler : IScheduler
         private Dictionary<int, NodeInfo> _availableNodes;
 
         /// <summary>
-        /// The number of inproc nodes that can be created without hitting the 
+        /// The number of inproc nodes that can be created without hitting the
         /// node limit.
         /// </summary>
         private int _currentInProcNodeCount = 0;
 
         /// <summary>
-        /// The number of out-of-proc nodes that can be created without hitting the 
+        /// The number of out-of-proc nodes that can be created without hitting the
         /// node limit.
         /// </summary>
         private int _currentOutOfProcNodeCount = 0;
@@ -135,9 +135,9 @@ internal class Scheduler : IScheduler
         private string _debugDumpPath;
 
         /// <summary>
-        /// If MSBUILDCUSTOMSCHEDULER = CustomSchedulerForSQL, the user may also choose to set 
-        /// MSBUILDCUSTOMSCHEDULERFORSQLCONFIGURATIONLIMITMULTIPLIER to the value by which they want 
-        /// the max configuration count for any one node to exceed the average configuration count.  
+        /// If MSBUILDCUSTOMSCHEDULER = CustomSchedulerForSQL, the user may also choose to set
+        /// MSBUILDCUSTOMSCHEDULERFORSQLCONFIGURATIONLIMITMULTIPLIER to the value by which they want
+        /// the max configuration count for any one node to exceed the average configuration count.
         /// If that env var is not set, or is set to an invalid value (negative, less than 1, non-numeric)
         /// then we use the default value instead.
         /// </summary>
@@ -162,8 +162,6 @@ public Scheduler()
             _forceAffinityOutOfProc = Environment.GetEnvironmentVariable("MSBUILDNOINPROCNODE") == "1";
             _debugDumpPath = Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
             _schedulingUnlimitedVariable = Environment.GetEnvironmentVariable("MSBUILDSCHEDULINGUNLIMITED");
-            string strNodeLimitOffset = null;
-
             _nodeLimitOffset = 0;
 
             if (!String.IsNullOrEmpty(_schedulingUnlimitedVariable))
@@ -174,8 +172,7 @@ public Scheduler()
             {
                 _schedulingUnlimited = false;
 
-                strNodeLimitOffset = Environment.GetEnvironmentVariable("MSBUILDNODELIMITOFFSET");
-
+                string strNodeLimitOffset = Environment.GetEnvironmentVariable("MSBUILDNODELIMITOFFSET");
                 if (!String.IsNullOrEmpty(strNodeLimitOffset))
                 {
                     _nodeLimitOffset = Int16.Parse(strNodeLimitOffset, CultureInfo.InvariantCulture);
@@ -198,8 +195,8 @@ public Scheduler()
         #region Delegates
 
         /// <summary>
-        /// In the circumstance where we want to specify the scheduling algorithm via the secret environment variable 
-        /// MSBUILDCUSTOMSCHEDULING, the scheduling algorithm used will be assigned to a delegate of this type. 
+        /// In the circumstance where we want to specify the scheduling algorithm via the secret environment variable
+        /// MSBUILDCUSTOMSCHEDULING, the scheduling algorithm used will be assigned to a delegate of this type.
         /// </summary>
         internal delegate void AssignUnscheduledRequestsDelegate(List<ScheduleResponse> responses, HashSet<int> idleNodes);
 
@@ -603,8 +600,6 @@ private void ScheduleUnassignedRequests(List<ScheduleResponse> responses)
 
             // Resume any work available which has already been assigned to specific nodes.
             ResumeRequiredWork(responses);
-
-            int nodesFreeToDoWorkPriorToScheduling = 0;
             HashSet<int> idleNodes = new HashSet<int>();
             foreach (int availableNodeId in _availableNodes.Keys)
             {
@@ -614,7 +609,7 @@ private void ScheduleUnassignedRequests(List<ScheduleResponse> responses)
                 }
             }
 
-            nodesFreeToDoWorkPriorToScheduling = idleNodes.Count;
+            int nodesFreeToDoWorkPriorToScheduling = idleNodes.Count;
 
             // Assign requests to any nodes which are currently idle.
             if (idleNodes.Count > 0 && _schedulingData.UnscheduledRequestsCount > 0)
@@ -742,8 +737,8 @@ private void AssignUnscheduledRequestsToNodes(List<ScheduleResponse> responses,
         }
 
         /// <summary>
-        /// Reads in the scheduling plan if one exists and has not previously been read; returns true if the scheduling plan 
-        /// both exists and is valid, or false otherwise. 
+        /// Reads in the scheduling plan if one exists and has not previously been read; returns true if the scheduling plan
+        /// both exists and is valid, or false otherwise.
         /// </summary>
         private bool GetSchedulingPlanAndAlgorithm()
         {
@@ -1164,13 +1159,13 @@ private void AssignUnscheduledRequestsFIFO(List<ScheduleResponse> responses, Has
         }
 
         /// <summary>
-        /// Custom scheduler for the SQL folks to solve a performance problem with their builds where they end up with a few long-running 
-        /// requests on all but one node, and then a very large number of short-running requests on that one node -- which is by design for 
-        /// our current scheduler, but makes it so that later in the build, when these configurations are re-entered with new requests, the 
-        /// build becomes essentially serial because so many of the configurations are tied to that one node.  
-        /// 
-        /// Fixes that problem by intentionally choosing to refrain from assigning new configurations to idle nodes if those idle nodes already 
-        /// have more than their fair share of the existing configurations assigned to them. 
+        /// Custom scheduler for the SQL folks to solve a performance problem with their builds where they end up with a few long-running
+        /// requests on all but one node, and then a very large number of short-running requests on that one node -- which is by design for
+        /// our current scheduler, but makes it so that later in the build, when these configurations are re-entered with new requests, the
+        /// build becomes essentially serial because so many of the configurations are tied to that one node.
+        ///
+        /// Fixes that problem by intentionally choosing to refrain from assigning new configurations to idle nodes if those idle nodes already
+        /// have more than their fair share of the existing configurations assigned to them.
         /// </summary>
         private void AssignUnscheduledRequestsUsingCustomSchedulerForSQL(List<ScheduleResponse> responses, HashSet<int> idleNodes)
         {
@@ -1247,8 +1242,8 @@ private void AssignUnscheduledRequestsUsingCustomSchedulerForSQL(List<ScheduleRe
         /// </summary>
         private void AssignUnscheduledRequestToNode(SchedulableRequest request, int nodeId, List<ScheduleResponse> responses)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(request, "request");
-            ErrorUtilities.VerifyThrowArgumentNull(responses, "responses");
+            ErrorUtilities.VerifyThrowArgumentNull(request, nameof(request));
+            ErrorUtilities.VerifyThrowArgumentNull(responses, nameof(responses));
             ErrorUtilities.VerifyThrow(nodeId != InvalidNodeId, "Invalid node id specified.");
 
             // Currently we cannot move certain kinds of traversals (notably solution metaprojects) to other nodes because 
@@ -1287,21 +1282,12 @@ private bool AtSchedulingLimit()
                 return false;
             }
 
-            int limit = 0;
-            switch (_componentHost.BuildParameters.MaxNodeCount)
+            int limit = _componentHost.BuildParameters.MaxNodeCount switch
             {
-                case 1:
-                    limit = 1;
-                    break;
-
-                case 2:
-                    limit = _componentHost.BuildParameters.MaxNodeCount + 1 + _nodeLimitOffset;
-                    break;
-
-                default:
-                    limit = _componentHost.BuildParameters.MaxNodeCount + 2 + _nodeLimitOffset;
-                    break;
-            }
+                1 => 1,
+                2 => _componentHost.BuildParameters.MaxNodeCount + 1 + _nodeLimitOffset,
+                _ => _componentHost.BuildParameters.MaxNodeCount + 2 + _nodeLimitOffset,
+            };
 
             // We're at our limit of schedulable requests if: 
             // (1) MaxNodeCount requests are currently executing
@@ -1328,14 +1314,14 @@ private bool CanScheduleRequestToNode(SchedulableRequest request, int nodeId)
 
         /// <summary>
         /// Adds CreateNode responses to satisfy all the affinities in the list of requests, with the following constraints:
-        /// 
+        ///
         /// a) Issue no more than one response to create an inproc node, and aggressively issues as many requests for an out-of-proc node
-        ///    as there are requests to assign to them. 
-        ///    
+        ///    as there are requests to assign to them.
+        ///
         /// b) Don't exceed the max node count, *unless* there isn't even one node of the necessary affinity yet. (That means that even if there's a max
-        ///    node count of e.g., 3, and we have already created 3 out of proc nodes, we will still create an inproc node if affinity requires it; if 
+        ///    node count of e.g., 3, and we have already created 3 out of proc nodes, we will still create an inproc node if affinity requires it; if
         ///    we didn't, the build would jam.)
-        ///    
+        ///
         /// Returns true if there is a pending response to create a new node.
         /// </summary>
         private bool CreateNewNodeIfPossible(List<ScheduleResponse> responses, IEnumerable<SchedulableRequest> requests)
@@ -1486,8 +1472,8 @@ private void MarkRequestAborted(SchedulableRequest request)
         /// </summary>
         private void HandleRequestBlockedOnInProgressTarget(SchedulableRequest blockedRequest, BuildRequestBlocker blocker)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(blockedRequest, "blockedRequest");
-            ErrorUtilities.VerifyThrowArgumentNull(blocker, "blocker");
+            ErrorUtilities.VerifyThrowArgumentNull(blockedRequest, nameof(blockedRequest));
+            ErrorUtilities.VerifyThrowArgumentNull(blocker, nameof(blocker));
 
             // We are blocked on an in-progress request building a target whose results we need.
             SchedulableRequest blockingRequest = _schedulingData.GetScheduledRequest(blocker.BlockingRequestId);
@@ -1545,8 +1531,8 @@ private void HandleRequestBlockedOnResultsTransfer(SchedulableRequest parentRequ
         /// </summary>
         private void HandleRequestBlockedByNewRequests(SchedulableRequest parentRequest, BuildRequestBlocker blocker, List<ScheduleResponse> responses)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(blocker, "blocker");
-            ErrorUtilities.VerifyThrowArgumentNull(responses, "responses");
+            ErrorUtilities.VerifyThrowArgumentNull(blocker, nameof(blocker));
+            ErrorUtilities.VerifyThrowArgumentNull(responses, nameof(responses));
 
             // The request is waiting on new requests.
             bool abortRequestBatch = false;
@@ -1566,7 +1552,7 @@ private void HandleRequestBlockedByNewRequests(SchedulableRequest parentRequest,
                 // directly here.  We COULD simply report these as blocking the parent request and let the scheduler pick them up later when the parent
                 // comes back up as schedulable, but we prefer to send the results back immediately so this request can (potentially) continue uninterrupted.
                 ScheduleResponse response = TrySatisfyRequestFromCache(nodeForResults, request, skippedResultsDoNotCauseCacheMiss: _componentHost.BuildParameters.SkippedResultsDoNotCauseCacheMiss());
-                if (null != response)
+                if (response != null)
                 {
                     TraceScheduler("Request {0} (node request {1}) satisfied from the cache.", request.GlobalRequestId, request.NodeRequestId);
 
@@ -1659,10 +1645,7 @@ private void HandleRequestBlockedByNewRequests(SchedulableRequest parentRequest,
                         BuildRequest requestToAdd = requestsToAdd.Pop();
                         SchedulableRequest blockingRequest = _schedulingData.CreateRequest(requestToAdd, parentRequest);
 
-                        if (parentRequest != null)
-                        {
-                            parentRequest.BlockByRequest(blockingRequest, blocker.TargetsInProgress);
-                        }
+                        parentRequest?.BlockByRequest(blockingRequest, blocker.TargetsInProgress);
                     }
                 }
             }
@@ -1688,7 +1671,7 @@ private void ResumeReadyRequestIfAny(int nodeId, List<ScheduleResponse> response
         }
 
         /// <summary>
-        /// Attempts to get results from the cache for this request.  If results are available, reports them to the 
+        /// Attempts to get results from the cache for this request.  If results are available, reports them to the
         /// correct node.  If that action causes the parent to become ready and its node is idle, the parent is
         /// resumed.
         /// </summary>
@@ -1976,8 +1959,8 @@ private NodeAffinity GetNodeAffinityForRequest(BuildRequest request)
         }
 
         /// <summary>
-        /// Iterates through the set of available nodes and checks whether any of them is 
-        /// capable of servicing this request or any of the requests that it is blocked 
+        /// Iterates through the set of available nodes and checks whether any of them is
+        /// capable of servicing this request or any of the requests that it is blocked
         /// by (regardless of whether they are currently available to do so).
         /// </summary>
         private bool RequestOrAnyItIsBlockedByCanBeServiced(SchedulableRequest request)
@@ -2016,7 +1999,7 @@ private bool RequestOrAnyItIsBlockedByCanBeServiced(SchedulableRequest request)
         /// assigns a new request id.
         /// </summary>
         /// <remarks>
-        /// UNDONE: (Performance) This algorithm should be modified so we don't have to iterate over all of the 
+        /// UNDONE: (Performance) This algorithm should be modified so we don't have to iterate over all of the
         /// requests to find a matching one.  A HashSet with proper equality semantics and a good hash code for the BuildRequest
         /// would speed this considerably, especially for large numbers of projects in a build.
         /// </remarks>
@@ -2092,7 +2075,7 @@ private void WriteNodeUtilizationGraph(ILoggingService loggingService, BuildEven
                 currentWork[i] = invalidWorkId;
                 previousWork[i] = invalidWorkId;
                 runningRequests[i] = new HashSet<int>();
-                nodeIndices.Append(String.Format(CultureInfo.InvariantCulture, "{0,-5}   ", indexToAvailableNodeId[i]));
+                nodeIndices.AppendFormat(CultureInfo.InvariantCulture, "{0,-5}   ", indexToAvailableNodeId[i]);
             }
 
             loggingService.LogComment(context, MessageImportance.Normal, "NodeUtilizationHeader", nodeIndices.ToString());
@@ -2217,7 +2200,7 @@ private void WriteNodeUtilizationGraphLine(ILoggingService loggingService, Build
                 }
                 else
                 {
-                    stringBuilder.Append(String.Format(CultureInfo.InvariantCulture, "{0,-5}   ", currentWork[i]));
+                    stringBuilder.AppendFormat(CultureInfo.InvariantCulture, "{0,-5}   ", currentWork[i]);
                     haveNonIdleNode = true;
                 }
             }
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
index 9f2a99bd830..9f026e15fb0 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
@@ -500,7 +500,7 @@ public bool IsNodeWorking(int nodeId)
                 return false;
             }
 
-            return (request != null);
+            return request != null;
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
index 4354a13cecb..7eca22fd71a 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
@@ -660,7 +660,7 @@ public double TotalPlanTime
             {
                 // Count our time, plus the amount of time all of our children take.  Multiply this by the total number
                 // of referrers to weight us higher the more configurations depend on us.
-                get { return (AccumulatedTime + AccumulatedTimeOfReferences); }
+                get { return AccumulatedTime + AccumulatedTimeOfReferences; }
             }
 
             /// <summary>
diff --git a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
index a0da588d799..3f541b05568 100644
--- a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
@@ -12,7 +12,6 @@
 
 namespace Microsoft.Build.BackEnd.SdkResolution
 {
-
     internal sealed class CachingSdkResolverService: SdkResolverService
     {
         /// <summary>
@@ -34,13 +33,13 @@ public override void ClearCaches()
             _cache.Clear();
         }
 
-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive)
+        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
         {
             SdkResult result;
 
             if (Traits.Instance.EscapeHatches.DisableSdkResolutionCache)
             {
-                result = base.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive);
+                result = base.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
             }
             else
             {
@@ -53,7 +52,7 @@ public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, Logging
                  */
                 Lazy<SdkResult> resultLazy = cached.GetOrAdd(
                     sdk.Name,
-                    key => new Lazy<SdkResult>(() => base.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive)));
+                    key => new Lazy<SdkResult>(() => base.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio)));
 
                 // Get the lazy value which will block all waiting threads until the SDK is resolved at least once while subsequent calls get cached results.
                 result = resultLazy.Value;
diff --git a/src/Build/BackEnd/Components/SdkResolution/HostedSdkResolverServiceBase.cs b/src/Build/BackEnd/Components/SdkResolution/HostedSdkResolverServiceBase.cs
index ee567903f54..fc2d03a2079 100644
--- a/src/Build/BackEnd/Components/SdkResolution/HostedSdkResolverServiceBase.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/HostedSdkResolverServiceBase.cs
@@ -47,7 +47,7 @@ public virtual void InitializeComponent(IBuildComponentHost host)
         public abstract void PacketReceived(int node, INodePacket packet);
 
         /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
-        public abstract SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive);
+        public abstract SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio);
 
         /// <inheritdoc cref="IBuildComponent.ShutdownComponent"/>
         public virtual void ShutdownComponent()
diff --git a/src/Build/BackEnd/Components/SdkResolution/ISdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/ISdkResolverService.cs
index b36a25189e2..2aeed6fe132 100644
--- a/src/Build/BackEnd/Components/SdkResolution/ISdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/ISdkResolverService.cs
@@ -39,7 +39,8 @@ internal interface ISdkResolverService
         /// <param name="solutionPath">The full path to the solution file, if any, that is resolving the SDK.</param>
         /// <param name="projectPath">The full path to the project file that is resolving the SDK.</param>
         /// <param name="interactive">Indicates whether or not the resolver is allowed to be interactive.</param>
+        /// <param name="isRunningInVisualStudio">Indicates whether or not the resolver is running in Visual Studio.</param>
         /// <returns>An <see cref="SdkResult"/> containing information about the resolved SDK. If no resolver was able to resolve it, then <see cref="Framework.SdkResult.Success"/> == false. </returns>
-        SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive);
+        SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio);
     }
 }
diff --git a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
index 37c708c8d14..0c52dddff33 100644
--- a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
@@ -87,14 +87,14 @@ public override void PacketReceived(int node, INodePacket packet)
         }
 
         /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive)
+        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
         {
             ErrorUtilities.VerifyThrowInternalNull(sdk, nameof(sdk));
             ErrorUtilities.VerifyThrowInternalNull(loggingContext, nameof(loggingContext));
             ErrorUtilities.VerifyThrowInternalNull(sdkReferenceLocation, nameof(sdkReferenceLocation));
             ErrorUtilities.VerifyThrowInternalLength(projectPath, nameof(projectPath));
 
-            return _cachedSdkResolver.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive);
+            return _cachedSdkResolver.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
         }
 
         /// <summary>
@@ -121,7 +121,6 @@ private void HandleRequest(int node, SdkResolverRequest request)
 
                         // Create the thread which processes requests
                         _requestHandler = Task.Factory.StartNew(RequestHandlerPumpProc, TaskCreationOptions.LongRunning);
-                        
                     }
                 }
             }
@@ -161,7 +160,7 @@ private void ProcessRequests()
                         ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;
 
                         // This call is usually cached so is very fast but can take longer for a new SDK that is downloaded.  Other queued threads for different SDKs will complete sooner and continue on which unblocks evaluations
-                        response = ResolveSdk(request.SubmissionId, sdkReference, new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath), request.ElementLocation, request.SolutionPath, request.ProjectPath, request.Interactive);
+                        response = ResolveSdk(request.SubmissionId, sdkReference, new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath), request.ElementLocation, request.SolutionPath, request.ProjectPath, request.Interactive, request.IsRunningInVisualStudio);
                     }
                     catch (Exception e)
                     {
diff --git a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
index 3d1813a7727..6ae4a89268e 100644
--- a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
@@ -61,14 +61,14 @@ public override void PacketReceived(int node, INodePacket packet)
         }
 
         /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive)
+        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
         {
             // Get a cached response if possible, otherwise send the request
             var sdkResult = _responseCache.GetOrAdd(
                 sdk.Name,
                 key =>
                 {
-                    var result = RequestSdkPathFromMainNode(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive);
+                    var result = RequestSdkPathFromMainNode(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
                     return result;
                 });
 
@@ -103,13 +103,13 @@ private void HandleResponse(SdkResult response)
             _responseReceivedEvent.Set();
         }
 
-        private SdkResult RequestSdkPathFromMainNode(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive)
+        private SdkResult RequestSdkPathFromMainNode(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
         {
             // Clear out the last response for good measure
             _lastResponse = null;
 
             // Create the SdkResolverRequest packet to send
-            INodePacket packet = SdkResolverRequest.Create(submissionId, sdk, loggingContext.BuildEventContext, sdkReferenceLocation, solutionPath, projectPath, interactive);
+            INodePacket packet = SdkResolverRequest.Create(submissionId, sdk, loggingContext.BuildEventContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
 
             SendPacket(packet);
 
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverContext.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverContext.cs
index 5ed8a6aaf4c..438557c97ed 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverContext.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverContext.cs
@@ -12,13 +12,14 @@ namespace Microsoft.Build.BackEnd.SdkResolution
     /// </summary>
     internal sealed class SdkResolverContext : SdkResolverContextBase
     {
-        public SdkResolverContext(Framework.SdkLogger logger, string projectFilePath, string solutionPath, Version msBuildVersion, bool interactive)
+        public SdkResolverContext(Framework.SdkLogger logger, string projectFilePath, string solutionPath, Version msBuildVersion, bool interactive, bool isRunningInVisualStudio)
         {
             Logger = logger;
             ProjectFilePath = projectFilePath;
             SolutionFilePath = solutionPath;
             MSBuildVersion = msBuildVersion;
             Interactive = interactive;
+            IsRunningInVisualStudio = isRunningInVisualStudio;
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
index c3a86600cde..e0d472eea6e 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
@@ -20,11 +20,16 @@ internal class SdkResolverLoader
         private readonly CoreClrAssemblyLoader _loader = new CoreClrAssemblyLoader();
 #endif
 
+        private readonly string IncludeDefaultResolver = Environment.GetEnvironmentVariable("MSBUILDINCLUDEDEFAULTSDKRESOLVER");
+
+        private readonly string AdditionalResolversFolder = Environment.GetEnvironmentVariable("MSBUILDADDITIONALSDKRESOLVERSFOLDER");
+
         internal virtual IList<SdkResolver> LoadResolvers(LoggingContext loggingContext,
             ElementLocation location)
         {
-            // Always add the default resolver
-            var resolvers = new List<SdkResolver> {new DefaultSdkResolver()};
+            var resolvers = !String.Equals(IncludeDefaultResolver, "false", StringComparison.OrdinalIgnoreCase) ? 
+                new List<SdkResolver> {new DefaultSdkResolver()}
+                : new List<SdkResolver>();
 
             var potentialResolvers = FindPotentialSdkResolvers(
                 Path.Combine(BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32, "SdkResolvers"), location);
@@ -47,17 +52,20 @@ internal virtual IList<SdkResolver> LoadResolvers(LoggingContext loggingContext,
         ///     Root\SdkResolver\(ResolverName)\(ResolverName).dll.
         /// </summary>
         /// <param name="rootFolder"></param>
+        /// <param name="location"></param>
         /// <returns></returns>
         internal virtual IList<string> FindPotentialSdkResolvers(string rootFolder, ElementLocation location)
         {
             var assembliesList = new List<string>();
 
-            if (string.IsNullOrEmpty(rootFolder) || !FileUtilities.DirectoryExistsNoThrow(rootFolder))
+            if ((string.IsNullOrEmpty(rootFolder) || !FileUtilities.DirectoryExistsNoThrow(rootFolder)) && AdditionalResolversFolder == null)
             {
                 return assembliesList;
             }
 
-            foreach (var subfolder in new DirectoryInfo(rootFolder).GetDirectories())
+            DirectoryInfo[] subfolders = GetSubfolders(rootFolder, AdditionalResolversFolder);
+
+            foreach (var subfolder in subfolders)
             {
                 var assembly = Path.Combine(subfolder.FullName, $"{subfolder.Name}.dll");
                 var manifest = Path.Combine(subfolder.FullName, $"{subfolder.Name}.xml");
@@ -77,6 +85,44 @@ internal virtual IList<string> FindPotentialSdkResolvers(string rootFolder, Elem
             return assembliesList;
         }
 
+        private DirectoryInfo[] GetSubfolders(string rootFolder, string additionalResolversFolder)
+        {
+            DirectoryInfo[] subfolders = null;
+            if (!string.IsNullOrEmpty(rootFolder) && FileUtilities.DirectoryExistsNoThrow(rootFolder))
+            {
+                subfolders = new DirectoryInfo(rootFolder).GetDirectories();
+            }
+
+            if (additionalResolversFolder != null)
+            {
+                var resolversDirInfo = new DirectoryInfo(additionalResolversFolder);
+                if (resolversDirInfo.Exists)
+                {
+                    HashSet<DirectoryInfo> overrideFolders = resolversDirInfo.GetDirectories().ToHashSet(new DirInfoNameComparer());
+                    if (subfolders != null)
+                    {
+                        overrideFolders.UnionWith(subfolders);
+                    }
+                    return overrideFolders.ToArray();
+                }
+            }
+
+            return subfolders;
+        }
+
+        private class DirInfoNameComparer : IEqualityComparer<DirectoryInfo>
+        {
+            public bool Equals(DirectoryInfo first, DirectoryInfo second)
+            {
+                return string.Equals(first.Name, second.Name, StringComparison.OrdinalIgnoreCase);
+            }
+
+            public int GetHashCode(DirectoryInfo value)
+            {
+                return value.Name.GetHashCode();
+            }
+        }
+
         private bool TryAddAssemblyFromManifest(string pathToManifest, string manifestFolder, List<string> assembliesList, ElementLocation location)
         {
             if (!string.IsNullOrEmpty(pathToManifest) && !FileUtilities.FileExistsNoThrow(pathToManifest)) return false;
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
index 9afca3f4c4c..dd0ca202dc1 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
@@ -31,20 +31,13 @@ internal static SdkResolverManifest Load(string filePath)
             {
                 while (reader.Read())
                 {
-                    switch (reader.NodeType)
+                    if (reader.NodeType == XmlNodeType.Element && reader.Name == "SdkResolver")
                     {
-                        case XmlNodeType.Element:
-                            switch (reader.Name)
-                            {
-                                case "SdkResolver":
-                                    return ParseSdkResolverElement(reader);
-
-                                default:
-                                    throw new XmlException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnrecognizedElement", reader.Name));
-                            }
-
-                        default:
-                            throw new XmlException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnrecognizedElement", reader.Name));
+                        return ParseSdkResolverElement(reader);
+                    }
+                    else
+                    {
+                        throw new XmlException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnrecognizedElement", reader.Name));
                     }
                 }
             }
@@ -62,15 +55,11 @@ private static SdkResolverManifest ParseSdkResolverElement(XmlReader reader)
                 {
                     case XmlNodeType.Element:
                         {
-                            switch (reader.Name)
+                            manifest.Path = reader.Name switch
                             {
-                                case "Path":
-                                    manifest.Path = reader.ReadElementContentAsString();
-                                    break;
-
-                                default:
-                                    throw new XmlException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnrecognizedElement", reader.Name));
-                            }
+                                "Path" => reader.ReadElementContentAsString(),
+                                _ => throw new XmlException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnrecognizedElement", reader.Name)),
+                            };
                         }
                         break;
 
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverRequest.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverRequest.cs
index f10400f322a..a89cd605234 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverRequest.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverRequest.cs
@@ -21,13 +21,14 @@ internal sealed class SdkResolverRequest : INodePacket
         private int _submissionId;
         private string _version;
         private bool _interactive;
+        private bool _isRunningInVisualStudio;
 
         public SdkResolverRequest(ITranslator translator)
         {
             Translate(translator);
         }
 
-        private SdkResolverRequest(int submissionId, string name, string version, string minimumVersion, BuildEventContext buildEventContext, ElementLocation elementLocation, string solutionPath, string projectPath, bool interactive)
+        private SdkResolverRequest(int submissionId, string name, string version, string minimumVersion, BuildEventContext buildEventContext, ElementLocation elementLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
         {
             _buildEventContext = buildEventContext;
             _submissionId = submissionId;
@@ -38,6 +39,7 @@ private SdkResolverRequest(int submissionId, string name, string version, string
             _solutionPath = solutionPath;
             _version = version;
             _interactive = interactive;
+            _isRunningInVisualStudio = isRunningInVisualStudio;
         }
 
         public BuildEventContext BuildEventContext => _buildEventContext;
@@ -46,6 +48,8 @@ private SdkResolverRequest(int submissionId, string name, string version, string
 
         public bool Interactive => _interactive;
 
+        public bool IsRunningInVisualStudio => _isRunningInVisualStudio;
+
         public string MinimumVersion => _minimumVersion;
 
         public string Name => _name;
@@ -62,9 +66,9 @@ private SdkResolverRequest(int submissionId, string name, string version, string
 
         public string Version => _version;
 
-        public static SdkResolverRequest Create(int submissionId, SdkReference sdkReference, BuildEventContext buildEventContext, ElementLocation elementLocation, string solutionPath, string projectPath, bool interactive)
+        public static SdkResolverRequest Create(int submissionId, SdkReference sdkReference, BuildEventContext buildEventContext, ElementLocation elementLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
         {
-            return new SdkResolverRequest(submissionId, sdkReference.Name, sdkReference.Version, sdkReference.MinimumVersion, buildEventContext, elementLocation, solutionPath, projectPath, interactive);
+            return new SdkResolverRequest(submissionId, sdkReference.Name, sdkReference.Version, sdkReference.MinimumVersion, buildEventContext, elementLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
         }
 
         public static INodePacket FactoryForDeserialization(ITranslator translator)
@@ -83,6 +87,7 @@ public void Translate(ITranslator translator)
             translator.Translate(ref _submissionId);
             translator.Translate(ref _version);
             translator.Translate(ref _interactive);
+            translator.Translate(ref _isRunningInVisualStudio);
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index 158555f4f41..1ca540e9788 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -87,7 +87,7 @@ public virtual void ClearCaches()
         }
 
         /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
-        public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive)
+        public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
         {
             // Lazy initialize the SDK resolvers
             if (_resolvers == null)
@@ -104,7 +104,7 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
 
             foreach (SdkResolver sdkResolver in _resolvers)
             {
-                SdkResolverContext context = new SdkResolverContext(buildEngineLogger, projectPath, solutionPath, ProjectCollection.Version, interactive)
+                SdkResolverContext context = new SdkResolverContext(buildEngineLogger, projectPath, solutionPath, ProjectCollection.Version, interactive, isRunningInVisualStudio)
                 {
                     State = GetResolverState(submissionId, sdkResolver)
                 };
@@ -117,7 +117,7 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
                 {
                     result = (SdkResult)sdkResolver.Resolve(sdk, context, resultFactory);
                 }
-                catch (Exception e) when (e is FileNotFoundException || e is FileLoadException && sdkResolver.GetType().GetTypeInfo().Name.Equals("NuGetSdkResolver", StringComparison.Ordinal))
+                catch (Exception e) when (e is FileNotFoundException || (e is FileLoadException && sdkResolver.GetType().GetTypeInfo().Name.Equals("NuGetSdkResolver", StringComparison.Ordinal)))
                 {
                     // Since we explicitly add the NuGetSdkResolver, we special case this.  The NuGetSdkResolver has special logic
                     // to load NuGet assemblies at runtime which could fail if the user is not running installed MSBuild.  Rather
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
index 3ab79ea3fbc..6f9778a9eb8 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
@@ -29,18 +29,20 @@ public SdkResult(SdkReference sdkReference, IEnumerable<string> errors, IEnumera
             Warnings = warnings;
         }
 
-        public SdkResult(SdkReference sdkReference, string path, string version, IEnumerable<string> warnings)
+        public SdkResult(SdkReference sdkReference, string path, string version, IEnumerable<string> warnings,
+            IDictionary<string, string> propertiesToAdd = null, IDictionary<string, SdkResultItem> itemsToAdd = null)
         {
             Success = true;
             SdkReference = sdkReference;
             Path = path;
             Version = version;
             Warnings = warnings;
+            PropertiesToAdd = propertiesToAdd;
+            ItemsToAdd = itemsToAdd;
         }
 
         public SdkResult()
         {
-
         }
 
         public SdkResult(SdkReference sdkReference, IEnumerable<string> paths, string version, IDictionary<string, string> propertiesToAdd,
@@ -152,32 +154,32 @@ public override bool Equals(object obj)
         public override int GetHashCode()
         {
             int hashCode = -1043047289;
-            hashCode = hashCode * -1521134295 + _success.GetHashCode();
-            hashCode = hashCode * -1521134295 + StringComparer.OrdinalIgnoreCase.GetHashCode(_path);
-            hashCode = hashCode * -1521134295 + StringComparer.OrdinalIgnoreCase.GetHashCode(_version);
-            hashCode = hashCode * -1521134295 + EqualityComparer<SdkReference>.Default.GetHashCode(_sdkReference);
+            hashCode = (hashCode * -1521134295) + _success.GetHashCode();
+            hashCode = (hashCode * -1521134295) + StringComparer.OrdinalIgnoreCase.GetHashCode(_path);
+            hashCode = (hashCode * -1521134295) + StringComparer.OrdinalIgnoreCase.GetHashCode(_version);
+            hashCode = (hashCode * -1521134295) + EqualityComparer<SdkReference>.Default.GetHashCode(_sdkReference);
 
             if (_additionalPaths != null)
             {
                 foreach (var additionalPath in _additionalPaths)
                 {
-                    hashCode = hashCode * -1521134295 + StringComparer.OrdinalIgnoreCase.GetHashCode(additionalPath);
+                    hashCode = (hashCode * -1521134295) + StringComparer.OrdinalIgnoreCase.GetHashCode(additionalPath);
                 }
             }
             if (_propertiesToAdd != null)
             {
                 foreach (var propertyToAdd in _propertiesToAdd)
                 {
-                    hashCode = hashCode * -1521134295 + propertyToAdd.Key.GetHashCode();
-                    hashCode = hashCode * -1521134295 + propertyToAdd.Value.GetHashCode();
+                    hashCode = (hashCode * -1521134295) + propertyToAdd.Key.GetHashCode();
+                    hashCode = (hashCode * -1521134295) + propertyToAdd.Value.GetHashCode();
                 }
             }
             if (_itemsToAdd != null)
             {
                 foreach (var itemToAdd in _itemsToAdd)
                 {
-                    hashCode = hashCode * -1521134295 + itemToAdd.Key.GetHashCode();
-                    hashCode = hashCode * -1521134295 + itemToAdd.Value.GetHashCode();
+                    hashCode = (hashCode * -1521134295) + itemToAdd.Key.GetHashCode();
+                    hashCode = (hashCode * -1521134295) + itemToAdd.Value.GetHashCode();
                 }
             }
 
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResultFactory.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResultFactory.cs
index 7e4f0d898b6..9744bc0bbb2 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResultFactory.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResultFactory.cs
@@ -32,6 +32,15 @@ public override SdkResultBase IndicateSuccess(string path, string version, IEnum
             return new SdkResult(_sdkReference, path, version, warnings);
         }
 
+        public override SdkResultBase IndicateSuccess(string path,
+                                                      string version,
+                                                      IDictionary<string, string> propertiesToAdd,
+                                                      IDictionary<string, SdkResultItem> itemsToAdd,
+                                                      IEnumerable<string> warnings = null)
+        {
+            return new SdkResult(_sdkReference, path, version, warnings, propertiesToAdd, itemsToAdd);
+        }
+
         public override SdkResultBase IndicateSuccess(IEnumerable<string> paths,
                                                       string version,
                                                       IDictionary<string, string> propertiesToAdd = null,
diff --git a/src/Build/BackEnd/Node/InProcNode.cs b/src/Build/BackEnd/Node/InProcNode.cs
index 580187c97f4..0a5db6abbb2 100644
--- a/src/Build/BackEnd/Node/InProcNode.cs
+++ b/src/Build/BackEnd/Node/InProcNode.cs
@@ -287,7 +287,7 @@ private NodeEngineShutdownReason HandleShutdown(out Exception exception)
             try
             {
                 // Clean up the engine
-                if (null != _buildRequestEngine && _buildRequestEngine.Status != BuildRequestEngineStatus.Uninitialized)
+                if (_buildRequestEngine != null && _buildRequestEngine.Status != BuildRequestEngineStatus.Uninitialized)
                 {
                     _buildRequestEngine.CleanupForBuild();
                 }
@@ -338,7 +338,7 @@ private NodeEngineShutdownReason HandleShutdown(out Exception exception)
 
             exception = _shutdownException;
 
-            if (null != _loggingContext)
+            if (_loggingContext != null)
             {
                 _loggingContext.LoggingService.OnLoggingThreadException -= OnLoggingThreadException;
                 _loggingContext = null;
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index d7bddbdc133..0ae529953d0 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -140,10 +140,6 @@ public OutOfProcNode()
         {
             s_isOutOfProcNode = true;
 
-#if FEATURE_APPDOMAIN_UNHANDLED_EXCEPTION
-            AppDomain.CurrentDomain.UnhandledException += ExceptionHandling.UnhandledExceptionHandler;
-#endif
-
             _debugCommunications = (Environment.GetEnvironmentVariable("MSBUILDDEBUGCOMM") == "1");
 
             _receivedPackets = new ConcurrentQueue<INodePacket>();
@@ -165,7 +161,7 @@ public OutOfProcNode()
             ((IBuildComponentHost) this).RegisterFactory(BuildComponentType.SdkResolverService, sdkResolverServiceFactory.CreateInstance);
 
             _sdkResolverService = (this as IBuildComponentHost).GetComponent(BuildComponentType.SdkResolverService) as ISdkResolverService;
-            
+
             if (s_projectRootElementCacheBase == null)
             {
                 s_projectRootElementCacheBase = new ProjectRootElementCache(true /* automatically reload any changes from disk */);
@@ -428,7 +424,7 @@ private NodeEngineShutdownReason HandleShutdown(out Exception exception)
             CommunicationsUtilities.Trace("Shutting down with reason: {0}, and exception: {1}.", _shutdownReason, _shutdownException);
 
             // Clean up the engine
-            if (null != _buildRequestEngine && _buildRequestEngine.Status != BuildRequestEngineStatus.Uninitialized)
+            if (_buildRequestEngine != null && _buildRequestEngine.Status != BuildRequestEngineStatus.Uninitialized)
             {
                 _buildRequestEngine.CleanupForBuild();
 
@@ -479,7 +475,7 @@ private NodeEngineShutdownReason HandleShutdown(out Exception exception)
             try
             {
                 // Shut down logging, which will cause all queued logging messages to be sent.
-                if (null != _loggingContext && null != _loggingService)
+                if (_loggingContext != null && _loggingService != null)
                 {
                     _loggingContext.LogBuildFinished(true);
                     ((IBuildComponent)_loggingService).ShutdownComponent();
@@ -488,7 +484,7 @@ private NodeEngineShutdownReason HandleShutdown(out Exception exception)
             finally
             {
                 // Shut down logging, which will cause all queued logging messages to be sent.
-                if (null != _loggingContext && null != _loggingService)
+                if (_loggingContext != null && _loggingService != null)
                 {
                     _loggingContext.LoggingService.OnLoggingThreadException -= OnLoggingThreadException;
                     _loggingContext = null;
@@ -733,7 +729,7 @@ private void HandleNodeConfiguration(NodeConfiguration configuration)
             try
             {
                 // If there are no node loggers to initialize dont do anything
-                if (configuration.LoggerDescriptions != null && configuration.LoggerDescriptions.Length > 0)
+                if (configuration.LoggerDescriptions?.Length > 0)
                 {
                     _loggingService.InitializeNodeLoggers(configuration.LoggerDescriptions, sink, configuration.NodeId);
                 }
diff --git a/src/Build/BackEnd/Node/RarNode.cs b/src/Build/BackEnd/Node/RarNode.cs
new file mode 100644
index 00000000000..888c24215d8
--- /dev/null
+++ b/src/Build/BackEnd/Node/RarNode.cs
@@ -0,0 +1,160 @@
+Ôªø// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.CodeDom;
+using System.Diagnostics;
+using System.IO;
+using System.IO.Pipes;
+using System.Reflection;
+using System.Threading;
+using System.Threading.Tasks;
+
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Execution
+{
+    public sealed class RarNode : INode
+    {
+        /// <summary>
+        /// The amount of time to wait for the client to connect to the host.
+        /// </summary>
+        private const int ClientConnectTimeout = 60000;
+
+        /// <summary>
+        /// Fully qualified name of RarController, used for providing <see cref="IRarController" /> instance to <see cref="RarNode" />
+        /// </summary>
+        private const string RarControllerName = "Microsoft.Build.Tasks.ResolveAssemblyReferences.Server.RarController, Microsoft.Build.Tasks.Core";
+
+
+        /// <summary>
+        /// Timeout for node shutdown
+        /// </summary>
+        private static readonly TimeSpan NodeShutdownTimeout = TimeSpan.FromHours(1);
+
+        public NodeEngineShutdownReason Run(bool nodeReuse, bool lowPriority, out Exception shutdownException, CancellationToken cancellationToken = default)
+        {
+            shutdownException = null;
+            using CancellationTokenSource cts = new CancellationTokenSource();
+            string pipeName = CommunicationsUtilities.GetRarPipeName(nodeReuse, lowPriority);
+            Handshake handshake = NodeProviderOutOfProc.GetHandshake(enableNodeReuse: nodeReuse,
+                                                                     enableLowPriority: lowPriority, specialNode: true);
+
+            IRarController controller = GetController(pipeName, handshake);
+
+            Task<int> rarTask = controller.StartAsync(cts.Token);
+
+            Task<NodeEngineShutdownReason> msBuildShutdown = RunShutdownCheckAsync(handshake, cts.Token);
+
+            // Timeout for node, limits lifetime of node to 1 hour
+            cts.CancelAfter(NodeShutdownTimeout);
+            int index;
+            try
+            {
+                // Wait for any of these tasks to finish:
+                // - rarTask can timeout (default is 15 minutes)
+                // - msBuildShutdown ends when it receives command to shutdown
+                // - node lifetime expires
+                index = Task.WaitAny(new Task[] { msBuildShutdown, rarTask }, cts.Token);
+            }
+            catch (OperationCanceledException e)
+            {
+                shutdownException = e;
+                return NodeEngineShutdownReason.Error;
+            }
+
+            cts.Cancel();
+
+            if (index == 0)
+            {
+                // We know that the task completed, so we can get Result without waiting for it.
+                return msBuildShutdown.Result;
+            }
+            else
+            {
+                // RAR task can only exit with connection error or timeout
+                return NodeEngineShutdownReason.ConnectionFailed;
+            }
+        }
+
+        private static IRarController GetController(string pipeName, Handshake handshake)
+        {
+            Type rarControllerType = Type.GetType(RarControllerName);
+
+            Func<string, int?, int?, int, bool, NamedPipeServerStream> streamFactory = NamedPipeUtil.CreateNamedPipeServer;
+            Func<Handshake, NamedPipeServerStream, int, bool> validateCallback = NamedPipeUtil.ValidateHandshake;
+            IRarController controller = Activator.CreateInstance(rarControllerType, pipeName, handshake, streamFactory, validateCallback, null) as IRarController;
+
+            ErrorUtilities.VerifyThrow(controller != null, ResourceUtilities.GetResourceString("RarControllerReflectionError"), RarControllerName);
+            return controller;
+        }
+
+        public NodeEngineShutdownReason Run(out Exception shutdownException)
+        {
+            return Run(false, false, out shutdownException);
+        }
+
+        private async Task<NodeEngineShutdownReason> RunShutdownCheckAsync(Handshake handshake, CancellationToken cancellationToken = default)
+        {
+            string pipeName = NamedPipeUtil.GetPipeNameOrPath("MSBuild" + Process.GetCurrentProcess().Id);
+
+            static async Task<int> ReadAsync(Stream stream, byte[] buffer, int bytesToRead)
+            {
+                int totalBytesRead = 0;
+                while (totalBytesRead < bytesToRead)
+                {
+                    int bytesRead = await stream.ReadAsync(buffer, totalBytesRead, bytesToRead - totalBytesRead);
+                    if (bytesRead == 0)
+                    {
+                        return totalBytesRead;
+                    }
+                    totalBytesRead += bytesRead;
+                }
+                return totalBytesRead;
+            }
+
+            // Most common path in this while loop in long run will be over the continue statement.
+            // This is happening because the MSBuild when starting new nodes is trying in some cases to reuse nodes (see nodeReuse switch).
+            // It is done by listing the MSBuild processes and then connecting to them and validating the handshake.
+            // In most cases for this loop it will fail, which will lead to hitting the continue statement.
+            // If we get over that, the MSBuild should send NodeBuildComplete packet, which will indicate that the engine is requesting to shutdown this node.
+            while (true)
+            {
+                if (cancellationToken.IsCancellationRequested)
+                    return NodeEngineShutdownReason.BuildComplete;
+
+                using NamedPipeServerStream serverStream = NamedPipeUtil.CreateNamedPipeServer(pipeName, maxNumberOfServerInstances: NamedPipeServerStream.MaxAllowedServerInstances);
+                await serverStream.WaitForConnectionAsync(cancellationToken).ConfigureAwait(false);
+
+                bool connected = NamedPipeUtil.ValidateHandshake(handshake, serverStream, ClientConnectTimeout);
+                if (!connected)
+                    continue;
+
+                // Header consists of:
+                // 1 byte - Packet type
+                // 4 bytes - packet length
+                byte[] header = new byte[5];
+                int bytesRead = await ReadAsync(serverStream, header, header.Length).ConfigureAwait(false);
+                if (bytesRead != header.Length)
+                {
+                    continue;
+                }
+
+                NodePacketType packetType = (NodePacketType)Enum.ToObject(typeof(NodePacketType), header[0]);
+                // Packet type sent by Shutdown
+                if (packetType == NodePacketType.NodeBuildComplete)
+                {
+                    // Body of NodeBuildComplete contains only one boolean (= 1 byte)
+                    byte[] packetBody = new byte[sizeof(bool)];
+                    await serverStream.ReadAsync(packetBody, 0, packetBody.Length, cancellationToken).ConfigureAwait(false);
+                    bool nodeReuse = Convert.ToBoolean(packetBody[0]);
+
+                    return nodeReuse ? NodeEngineShutdownReason.BuildCompleteReuse : NodeEngineShutdownReason.BuildComplete;
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Shared/BuildRequest.cs b/src/Build/BackEnd/Shared/BuildRequest.cs
index ab48153c24a..3d72ed52c91 100644
--- a/src/Build/BackEnd/Shared/BuildRequest.cs
+++ b/src/Build/BackEnd/Shared/BuildRequest.cs
@@ -115,7 +115,7 @@ public BuildRequest(
             bool skipStaticGraphIsolationConstraints = false)
         {
             ErrorUtilities.VerifyThrowArgumentNull(escapedTargets, "targets");
-            ErrorUtilities.VerifyThrowArgumentNull(parentBuildEventContext, "parentBuildEventContext");
+            ErrorUtilities.VerifyThrowArgumentNull(parentBuildEventContext, nameof(parentBuildEventContext));
 
             _submissionId = submissionId;
             _configurationId = configurationId;
@@ -293,7 +293,6 @@ public RequestedProjectState RequestedProjectState
             set => _requestedProjectState = value;
         }
 
-
         /// <summary>
         /// The route for host-aware tasks back to the host
         /// </summary>
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index 301a9246a07..9c3356354c8 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -263,7 +263,7 @@ internal BuildRequestConfiguration()
 
         /// <summary>
         /// When reset caches is false we need to only keep around the configurations which are being asked for during the design time build.
-        /// Other configurations need to be cleared. If this configuration is marked as ExplicitlyLoadedConfiguration then it should not be cleared when 
+        /// Other configurations need to be cleared. If this configuration is marked as ExplicitlyLoadedConfiguration then it should not be cleared when
         /// Reset Caches is false.
         /// </summary>
         public bool ExplicitlyLoaded { get; set; }
@@ -276,7 +276,7 @@ internal BuildRequestConfiguration()
         /// <summary>
         /// Flag indicating whether or not the configuration has been loaded before.
         /// </summary>
-        public bool IsLoaded => _project != null && _project.IsLoaded;
+        public bool IsLoaded => _project?.IsLoaded == true;
 
         /// <summary>
         /// Flag indicating if the configuration is cached or not.
@@ -555,9 +555,9 @@ internal int ResultsNodeId
         /// <returns>True if the objects are equivalent, false otherwise.</returns>
         public static bool operator ==(BuildRequestConfiguration left, BuildRequestConfiguration right)
         {
-            if (ReferenceEquals(left, null))
+            if (left is null)
             {
-                if (ReferenceEquals(right, null))
+                if (right is null)
                 {
                     return true;
                 }
@@ -568,7 +568,7 @@ internal int ResultsNodeId
             }
             else
             {
-                if (ReferenceEquals(right, null))
+                if (right is null)
                 {
                     return false;
                 }
@@ -748,7 +748,7 @@ public override string ToString()
         /// <returns>True if they contain the same data, false otherwise</returns>
         public override bool Equals(object obj)
         {
-            if (ReferenceEquals(obj, null))
+            if (obj is null)
             {
                 return false;
             }
@@ -770,7 +770,7 @@ public override bool Equals(object obj)
         /// <returns>True if equal, false otherwise.</returns>
         public bool Equals(BuildRequestConfiguration other)
         {
-            if (ReferenceEquals(other, null))
+            if (other is null)
             {
                 return false;
             }
diff --git a/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs b/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs
index ffb073df4f4..74f3a81a22a 100644
--- a/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs
@@ -44,7 +44,7 @@ internal BuildRequestUnblocker(ITranslator translator)
         /// </summary>
         internal BuildRequestUnblocker(int globalRequestIdToResume)
         {
-            ErrorUtilities.VerifyThrowArgumentOutOfRange(globalRequestIdToResume != BuildRequest.InvalidGlobalRequestId, "globalRequestIdToResume");
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(globalRequestIdToResume != BuildRequest.InvalidGlobalRequestId, nameof(globalRequestIdToResume));
             _blockedGlobalRequestId = globalRequestIdToResume;
         }
 
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index 465f2b21122..b5bf9d3706d 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -334,7 +334,7 @@ public BuildResultCode OverallResult
         {
             get
             {
-                if (null != _requestException || _circularDependency || !_baseOverallResult)
+                if (_requestException != null || _circularDependency || !_baseOverallResult)
                 {
                     return BuildResultCode.Failure;
                 }
@@ -502,7 +502,7 @@ public void MergeResults(BuildResult results)
             }
 
             // If there is an exception and we did not previously have one, add it in.
-            _requestException = _requestException ?? results.Exception;
+            _requestException ??= results.Exception;
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Shared/ConfigurationMetadata.cs b/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
index e67a10c96cb..ef92495c45a 100644
--- a/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
+++ b/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
@@ -119,7 +119,7 @@ public static ConfigurationMetadata FactoryForDeserialization(ITranslator transl
         /// <returns>True if they contain the same data, false otherwise</returns>
         public override bool Equals(object obj)
         {
-            if (ReferenceEquals(obj, null))
+            if (obj is null)
             {
                 return false;
             }
@@ -141,7 +141,7 @@ public override bool Equals(object obj)
         /// <returns>True if equal, false otherwise.</returns>
         public bool Equals(ConfigurationMetadata other)
         {
-            if (ReferenceEquals(other, null))
+            if (other is null)
             {
                 return false;
             }
diff --git a/src/Build/BackEnd/Shared/TargetResult.cs b/src/Build/BackEnd/Shared/TargetResult.cs
index a22c5e63346..3eb907062e7 100644
--- a/src/Build/BackEnd/Shared/TargetResult.cs
+++ b/src/Build/BackEnd/Shared/TargetResult.cs
@@ -5,14 +5,12 @@
 using System.Diagnostics;
 using System.IO;
 using System.Globalization;
-using System.IO.Compression;
 using Microsoft.Build.BackEnd;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
-using System.Diagnostics.CodeAnalysis;
 using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.Collections;
 
 namespace Microsoft.Build.Execution
 {
@@ -39,7 +37,7 @@ public class TargetResult : ITargetResult, ITranslatable
         /// <summary>
         /// The store of items in this result.
         /// </summary>
-        private ItemsStore _itemsStore;
+        private TaskItem[] _items;
 
         /// <summary>
         /// The context under which these results have been cached.
@@ -55,7 +53,7 @@ internal TargetResult(TaskItem[] items, WorkUnitResult result)
         {
             ErrorUtilities.VerifyThrowArgumentNull(items, nameof(items));
             ErrorUtilities.VerifyThrowArgumentNull(result, nameof(result));
-            _itemsStore = new ItemsStore(items);
+            _items = items;
             _result = result;
         }
 
@@ -71,7 +69,8 @@ private TargetResult(ITranslator translator)
         /// Returns the exception which aborted this target, if any.
         /// </summary>
         /// <value>The exception which aborted this target, if any.</value>
-        public Exception Exception {
+        public Exception Exception
+        {
             [DebuggerStepThrough]
             get => _result.Exception;
         }
@@ -90,10 +89,7 @@ public ITaskItem[] Items
                 {
                     RetrieveItemsFromCache();
 
-                    // NOTE: If the items in the ItemsStore were compressed, this will decompress them.  If the only purpose to
-                    // getting these items is to check the length, then that is inefficient and we should come up with a better
-                    // way of getting the count (such as another interface method which delegates to the ItemsStore itself.
-                    return _itemsStore.Items;
+                    return _items;
                 }
             }
         }
@@ -217,13 +213,13 @@ internal void CacheItems(int configId, string targetName)
         {
             lock (_result)
             {
-                if (_itemsStore == null)
+                if (_items == null)
                 {
                     // Already cached.
                     return;
                 }
 
-                if (_itemsStore.ItemsCount == 0)
+                if (_items.Length == 0)
                 {
                     // Nothing to cache.
                     return;
@@ -237,8 +233,8 @@ internal void CacheItems(int configId, string targetName)
                 {
                     try
                     {
-                        translator.Translate(ref _itemsStore, ItemsStore.FactoryForDeserialization);
-                        _itemsStore = null;
+                        TranslateItems(translator);
+                        _items = null;
                         _cacheInfo = new CacheInfo(configId, targetName);
                     }
                     finally
@@ -257,7 +253,7 @@ private void InternalTranslate(ITranslator translator)
             translator.Translate(ref _result, WorkUnitResult.FactoryForDeserialization);
             translator.Translate(ref _targetFailureDoesntCauseBuildFailure);
             translator.Translate(ref _afterTargetsHaveFailed);
-            translator.Translate(ref _itemsStore, ItemsStore.FactoryForDeserialization);
+            TranslateItems(translator);
         }
 
         /// <summary>
@@ -267,13 +263,13 @@ private void RetrieveItemsFromCache()
         {
             lock (_result)
             {
-                if (_itemsStore == null)
+                if (_items == null)
                 {
                     ITranslator translator = GetResultsCacheTranslator(_cacheInfo.ConfigId, _cacheInfo.TargetName, TranslationDirection.ReadFromStream);
 
                     try
                     {
-                        translator.Translate(ref _itemsStore, ItemsStore.FactoryForDeserialization);
+                        TranslateItems(translator);
                         _cacheInfo = new CacheInfo();
                     }
                     finally
@@ -284,6 +280,55 @@ private void RetrieveItemsFromCache()
             }
         }
 
+        private void TranslateItems(ITranslator translator)
+        {
+            var itemsCount = _items?.Length ?? 0;
+            translator.Translate(ref itemsCount);
+
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                // We will just calculate a very rough starting buffer size for the memory stream based on the number of items and a
+                // rough guess for an average number of bytes needed to store them.  This doesn't have to be accurate, just
+                // big enough to avoid unnecessary buffer reallocations in most cases.
+                var defaultBufferCapacity = _items.Length * 128;
+                
+                using var itemsStream = new MemoryStream(defaultBufferCapacity);
+                var itemTranslator = BinaryTranslator.GetWriteTranslator(itemsStream);
+
+                // When creating the interner, we use the number of items as the initial size of the collections since the
+                // number of strings will be of the order of the number of items in the collection.  This assumes basically
+                // one unique string per item (frequently a path related to the item) with most of the rest of the metadata
+                // being the same (and thus interning.)  This is a hueristic meant to get us in the ballpark to avoid 
+                // too many reallocations when growing the collections.
+                var interner = new LookasideStringInterner(StringComparer.Ordinal, _items.Length);
+                foreach (TaskItem t in _items)
+                {
+                    t.TranslateWithInterning(itemTranslator, interner);
+                }
+
+                interner.Translate(translator);
+                var buffer = itemsStream.GetBuffer();
+                var bufferSize = (int)itemsStream.Length;
+                translator.Translate(ref buffer, ref bufferSize);
+            }
+            else
+            {
+                var interner = new LookasideStringInterner(translator);
+
+                byte[] buffer = null;
+                translator.Translate(ref buffer);
+                ErrorUtilities.VerifyThrow(buffer != null, "Unexpected null items buffer during translation.");
+
+                using MemoryStream itemsStream = new MemoryStream(buffer, 0, buffer.Length, writable: false, publiclyVisible: true);
+                var itemTranslator = BinaryTranslator.GetReadTranslator(itemsStream, null);
+                _items = new TaskItem[itemsCount];
+                for (int i = 0; i < _items.Length; i++)
+                {
+                    _items[i] = TaskItem.FactoryForDeserialization(itemTranslator, interner);
+                }
+            }
+        }
+
         /// <summary>
         /// Gets the translator for this configuration.
         /// </summary>
@@ -331,238 +376,5 @@ public CacheInfo(int configId, string targetName)
             /// </summary>
             public string TargetName { get; }
         }
-
-        /// <summary>
-        /// The store of items for the target result.  This class is responsible for the serialization of the items collection, which is 
-        /// useful to keep separate as it is where we spend most of our time serializing for large projects, and these are the bits
-        /// we throw out of memory when the cache gets collected.
-        /// </summary>
-        private class ItemsStore : ITranslatable
-        {
-            /// <summary>
-            /// The default compression threshold.
-            /// </summary>
-            private const int DefaultCompressionThreshold = 32;
-
-            /// <summary>
-            /// The count of items we will store before we start using compression.
-            /// </summary>
-            /// <remarks>
-            /// This value was determined empirically by looking at how many items tend to be transmitted for "normal" projects versus the ones
-            /// which benefit from this technique.
-            /// </remarks>
-            private static readonly int s_compressionThreshold;
-
-            /// <summary>
-            /// The compressed set of items, if any.
-            /// </summary>
-            private byte[] _compressedItems;
-
-            /// <summary>
-            /// The count of items, stored here so that we don't have to decompress the items if we are
-            /// only looking at the count.
-            /// </summary>
-            private int _itemsCount;
-
-            /// <summary>
-            /// The items produced by this target.
-            /// </summary>
-            private TaskItem[] _uncompressedItems;
-
-            /// <summary>
-            /// Static constructor.
-            /// </summary>
-            static ItemsStore()
-            {
-                if (Int32.TryParse(Environment.GetEnvironmentVariable("MSBUILDTARGETRESULTCOMPRESSIONTHRESHOLD"), out ItemsStore.s_compressionThreshold))
-                {
-                    if (s_compressionThreshold < 0)
-                    {
-                        s_compressionThreshold = 0;
-                    }
-                }
-                else
-                {
-                    s_compressionThreshold = DefaultCompressionThreshold;
-                }
-            }
-
-            /// <summary>
-            /// Constructor
-            /// </summary>
-            public ItemsStore(TaskItem[] items)
-            {
-                ErrorUtilities.VerifyThrowArgumentNull(items, "items");
-                _uncompressedItems = items;
-                _itemsCount = items.Length;
-            }
-
-            /// <summary>
-            /// Constructor for serialization.
-            /// </summary>
-            private ItemsStore(ITranslator translator)
-            {
-                Translate(translator);
-            }
-
-            /// <summary>
-            /// Gets the count of items.
-            /// </summary>
-            public int ItemsCount => _itemsCount;
-
-            /// <summary>
-            /// Retrieves the items.
-            /// </summary>
-            /// <remarks>
-            /// It's important not to call this method merely to get a count of the items held in the collection.
-            /// Instead use ItemsCount (above) for that.
-            /// </remarks>
-            public TaskItem[] Items
-            {
-                get
-                {
-                    if (_uncompressedItems == null)
-                    {
-                        DecompressItems();
-                    }
-
-                    return _uncompressedItems;
-                }
-            }
-
-            /*
-            /// <summary>
-            /// Throws out the deserialized items.
-            /// </summary>
-            /// <remarks>
-            /// Not presently used, but could be used for a multi-stage caching mechanism which first throws out decompressed items,
-            /// then if more space is needed, starts throwing out the compressed ones.
-            /// </remarks>
-            public void ReleaseItems()
-            {
-                if (_compressedItems == null)
-                {
-                    CompressItems();
-                }
-            }
-            */
-
-            /// <summary>
-            /// Translates an items store.
-            /// </summary>
-            public void Translate(ITranslator translator)
-            {
-                if (_compressedItems == null && translator.Mode == TranslationDirection.WriteToStream)
-                {
-                    CompressItemsIfNecessary();
-                }
-
-                // Note we only translate the serialized buffer (which contains the compressed and interned
-                // representation of the items.)  If the actual items are needed (for instance on child nodes)
-                // then the Items accessor will reconstitute them at the point they are needed.
-                ErrorUtilities.VerifyThrow((translator.Mode == TranslationDirection.ReadFromStream) || ((_compressedItems == null) ^ (_uncompressedItems == null)), "One of the compressed or uncompressed items arrays should be null.");
-                translator.Translate(ref _itemsCount);
-                translator.Translate(ref _compressedItems);
-                translator.TranslateArray(ref _uncompressedItems, TaskItem.FactoryForDeserialization);
-            }
-
-            /// <summary>
-            /// Factory for the serializer.
-            /// </summary>
-            internal static ItemsStore FactoryForDeserialization(ITranslator translator)
-            {
-                return new ItemsStore(translator);
-            }
-
-            /// <summary>
-            /// Compresses the items, but only if we have reached the threshold where it makes sense to do so.
-            /// </summary>
-            private void CompressItemsIfNecessary()
-            {
-                if (_itemsCount > s_compressionThreshold)
-                {
-                    CompressItems();
-                }
-            }
-
-            /// <summary>
-            /// Decompresses the items.
-            /// </summary>
-            private void DecompressItems()
-            {
-                ErrorUtilities.VerifyThrow(_uncompressedItems == null, "Items already decompressed.");
-                using (MemoryStream serializedStream = new MemoryStream(_compressedItems, 0, _compressedItems.Length, writable: false, publiclyVisible: true))
-                {
-                    using (DeflateStream inflateStream = new DeflateStream(serializedStream, CompressionMode.Decompress))
-                    {
-                        ITranslator serializedBufferTranslator = BinaryTranslator.GetReadTranslator(inflateStream, null);
-                        LookasideStringInterner interner = new LookasideStringInterner(serializedBufferTranslator);
-
-                        byte[] buffer = null;
-                        serializedBufferTranslator.Translate(ref buffer);
-                        ErrorUtilities.VerifyThrow(buffer != null, "Unexpected null items buffer during decompression.");
-
-                        using (MemoryStream itemsStream = new MemoryStream(buffer, 0, buffer.Length, writable: false, publiclyVisible: true))
-                        {
-                            ITranslator itemTranslator = BinaryTranslator.GetReadTranslator(itemsStream, null);
-                            _uncompressedItems = new TaskItem[_itemsCount];
-                            for (int i = 0; i < _uncompressedItems.Length; i++)
-                            {
-                                _uncompressedItems[i] = TaskItem.FactoryForDeserialization(itemTranslator, interner);
-                            }
-                        }
-                    }
-                }
-
-                _compressedItems = null;
-            }
-
-            /// <summary>
-            /// Compresses the items.
-            /// </summary>
-            private void CompressItems()
-            {
-                ErrorUtilities.VerifyThrow(_compressedItems == null, "Items already compressed.");
-
-                // We will just calculate a very rough starting buffer size for the memory stream based on the number of items and a
-                // rough guess for an average number of bytes needed to store them compressed.  This doesn't have to be accurate, just
-                // big enough to avoid unnecessary buffer reallocations in most cases.
-                int defaultCompressedBufferCapacity = _uncompressedItems.Length * 64;
-                using (var serializedStream = new MemoryStream(defaultCompressedBufferCapacity))
-                {
-                    using (var deflateStream = new DeflateStream(serializedStream, CompressionMode.Compress))
-                    {
-                        ITranslator serializedBufferTranslator = BinaryTranslator.GetWriteTranslator(deflateStream);
-
-                        // Again, a rough calculation of buffer size, this time for an uncompressed buffer.  We assume compression 
-                        // will give us 2:1, as it's all text.
-                        int defaultUncompressedBufferCapacity = defaultCompressedBufferCapacity * 2;
-                        using (var itemsStream = new MemoryStream(defaultUncompressedBufferCapacity))
-                        {
-                            ITranslator itemTranslator = BinaryTranslator.GetWriteTranslator(itemsStream);
-
-                            // When creating the interner, we use the number of items as the initial size of the collections since the
-                            // number of strings will be of the order of the number of items in the collection.  This assumes basically
-                            // one unique string per item (frequently a path related to the item) with most of the rest of the metadata
-                            // being the same (and thus interning.)  This is a hueristic meant to get us in the ballpark to avoid 
-                            // too many reallocations when growing the collections.
-                            LookasideStringInterner interner = new LookasideStringInterner(StringComparer.Ordinal, _uncompressedItems.Length);
-                            foreach (TaskItem t in _uncompressedItems)
-                            {
-                                t.TranslateWithInterning(itemTranslator, interner);
-                            }
-
-                            interner.Translate(serializedBufferTranslator);
-                            byte[] buffer = itemsStream.ToArray();
-                            serializedBufferTranslator.Translate(ref buffer);
-                        }
-                    }
-
-                    _compressedItems = serializedStream.ToArray();
-                }
-
-                _uncompressedItems = null;
-            }
-        }
     }
 }
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 81183622bb9..2a98b2fdf32 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -257,12 +257,12 @@ void ITaskExecutionHost.InitializeForTask(IBuildEngine2 buildEngine, TargetLoggi
 
             if (_taskFactoryWrapper.TaskFactoryLoadedType.HasSTAThreadAttribute())
             {
-                requirements = requirements | TaskRequirements.RequireSTAThread;
+                requirements |= TaskRequirements.RequireSTAThread;
             }
 
             if (_taskFactoryWrapper.TaskFactoryLoadedType.HasLoadInSeparateAppDomainAttribute())
             {
-                requirements = requirements | TaskRequirements.RequireSeparateAppDomain;
+                requirements |= TaskRequirements.RequireSeparateAppDomain;
 
                 // we're going to be remoting across the appdomain boundary, so
                 // create the list that we'll use to disconnect the taskitems once we're done
@@ -294,7 +294,7 @@ bool ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, It
             // here. Instead, NDP will try to Load (not LoadFrom!) the task assembly into our AppDomain, and since
             // we originally used LoadFrom, it will fail miserably not knowing where to find it.
             // We need to temporarily subscribe to the AppDomain.AssemblyResolve event to fix it.
-            if (null == _resolver)
+            if (_resolver == null)
             {
                 _resolver = new TaskEngineAssemblyResolver();
                 _resolver.Initialize(_taskFactoryWrapper.TaskFactoryLoadedType.Assembly.AssemblyFile);
@@ -865,19 +865,19 @@ private TaskFactoryWrapper FindTaskInRegistry(IDictionary<string, string> taskId
             if (!_intrinsicTasks.TryGetValue(_taskName, out TaskFactoryWrapper returnClass))
             {
                 returnClass = _projectInstance.TaskRegistry.GetRegisteredTask(_taskName, null, taskIdentityParameters, true /* exact match */, _targetLoggingContext, _taskLocation);
-                if (null == returnClass)
+                if (returnClass == null)
                 {
                     returnClass = _projectInstance.TaskRegistry.GetRegisteredTask(_taskName, null, taskIdentityParameters, false /* fuzzy match */, _targetLoggingContext, _taskLocation);
 
-                    if (null == returnClass)
+                    if (returnClass == null)
                     {
                         returnClass = _projectInstance.TaskRegistry.GetRegisteredTask(_taskName, null, null, true /* exact match */, _targetLoggingContext, _taskLocation);
 
-                        if (null == returnClass)
+                        if (returnClass == null)
                         {
                             returnClass = _projectInstance.TaskRegistry.GetRegisteredTask(_taskName, null, null, false /* fuzzy match */, _targetLoggingContext, _taskLocation);
 
-                            if (null == returnClass)
+                            if (returnClass == null)
                             {
                                 _targetLoggingContext.LogError
                                     (
@@ -1480,7 +1480,7 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
                         // if individual items in the array are null, ignore them
                         if (output != null)
                         {
-                            joinedOutputs = joinedOutputs ?? new StringBuilder();
+                            joinedOutputs ??= new StringBuilder();
 
                             if (joinedOutputs.Length > 0)
                             {
@@ -1556,7 +1556,7 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
                         // if individual outputs in the array are null, ignore them
                         if (output != null)
                         {
-                            joinedOutputs = joinedOutputs ?? new StringBuilder();
+                            joinedOutputs ??= new StringBuilder();
 
                             if (joinedOutputs.Length > 0)
                             {
diff --git a/src/Build/Collections/CopyOnWritePropertyDictionary.cs b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
index b42d9044410..67ab4344b9a 100644
--- a/src/Build/Collections/CopyOnWritePropertyDictionary.cs
+++ b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
@@ -251,7 +251,7 @@ IEnumerator IEnumerable.GetEnumerator()
         /// <returns>True if they are equivalent, false otherwise.</returns>
         public bool Equals(CopyOnWritePropertyDictionary<T> other)
         {
-            if (null == other)
+            if (other == null)
             {
                 return false;
             }
@@ -318,7 +318,7 @@ bool IDictionary<string, T>.TryGetValue(string key, out T value)
         {
             value = this[key];
 
-            return (value != null);
+            return value != null;
         }
 
         #endregion
diff --git a/src/Build/Collections/LookasideStringInterner.cs b/src/Build/Collections/LookasideStringInterner.cs
index a71f382b43f..01f8a0928ab 100644
--- a/src/Build/Collections/LookasideStringInterner.cs
+++ b/src/Build/Collections/LookasideStringInterner.cs
@@ -11,9 +11,9 @@ namespace Microsoft.Build.Collections
     /// A simple string interner designed for IPC.
     /// </summary>
     /// <remarks>
-    /// This interner works by providing a way to convert strings to integer IDs.  When used as a form of compression, 
+    /// This interner works by providing a way to convert strings to integer IDs.  When used as a form of compression,
     /// clients will intern their strings and record the set of IDs returned, then transmit those IDs instead of the
-    /// original strings.  The interner itself is also transmitted ahead of time, with the IDs, allowing 
+    /// original strings.  The interner itself is also transmitted ahead of time, with the IDs, allowing
     /// reconstruction of the original strings.  This ensures each string is transmitted exactly once.
     /// </remarks>
     internal class LookasideStringInterner : ITranslatable
@@ -52,7 +52,7 @@ public LookasideStringInterner(StringComparer comparer, int defaultCollectionSiz
         /// Constructor to be used during deserialization.
         /// </summary>
         /// <remarks>
-        /// Intern cannot be used on this interner if it came from serialization, since we do 
+        /// Intern cannot be used on this interner if it came from serialization, since we do
         /// not reconstruct the interning dictionary.
         /// </remarks>
         public LookasideStringInterner(ITranslator translator)
@@ -98,17 +98,12 @@ public int Intern(string str)
         /// <returns>The corresponding string.</returns>
         public string GetString(int index)
         {
-            switch (index)
+            return index switch
             {
-                case NullStringIndex:
-                    return null;
-
-                case EmptyStringIndex:
-                    return String.Empty;
-
-                default:
-                    return _strings[index];
-            }
+                NullStringIndex => null,
+                EmptyStringIndex => String.Empty,
+                _ => _strings[index],
+            };
         }
 
         /// <summary>
diff --git a/src/Build/Collections/PropertyDictionary.cs b/src/Build/Collections/PropertyDictionary.cs
index 86aa1e507d1..e3c17b24fae 100644
--- a/src/Build/Collections/PropertyDictionary.cs
+++ b/src/Build/Collections/PropertyDictionary.cs
@@ -264,7 +264,7 @@ IEnumerator IEnumerable.GetEnumerator()
         /// <returns>True if they are equivalent, false otherwise.</returns>
         public bool Equals(PropertyDictionary<T> other)
         {
-            if (null == other)
+            if (other == null)
             {
                 return false;
             }
@@ -284,7 +284,7 @@ public bool Equals(PropertyDictionary<T> other)
                 foreach (T leftProp in this)
                 {
                     T rightProp = other[leftProp.Key];
-                    if (rightProp == null || !rightProp.Equals(leftProp))
+                    if (rightProp?.Equals(leftProp) != true)
                     {
                         return false;
                     }
@@ -356,7 +356,7 @@ bool IDictionary<string, T>.TryGetValue(string key, out T value)
         {
             value = this[key];
 
-            return (value != null);
+            return value != null;
         }
 
         #endregion
diff --git a/src/Build/Collections/ReadOnlyConvertingDictionary.cs b/src/Build/Collections/ReadOnlyConvertingDictionary.cs
index 9b5766c94bd..33bfb114787 100644
--- a/src/Build/Collections/ReadOnlyConvertingDictionary.cs
+++ b/src/Build/Collections/ReadOnlyConvertingDictionary.cs
@@ -32,8 +32,8 @@ internal class ReadOnlyConvertingDictionary<K, V, N> : IDictionary<K, N>
         /// </summary>
         internal ReadOnlyConvertingDictionary(IDictionary<K, V> backing, Func<V, N> converter)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(backing, "backing");
-            ErrorUtilities.VerifyThrowArgumentNull(converter, "converter");
+            ErrorUtilities.VerifyThrowArgumentNull(backing, nameof(backing));
+            ErrorUtilities.VerifyThrowArgumentNull(converter, nameof(converter));
 
             _backing = backing;
             _converter = converter;
diff --git a/src/Build/Collections/RetrievableEntryHashSet/BitHelper.cs b/src/Build/Collections/RetrievableEntryHashSet/BitHelper.cs
index 5c1952b144a..bcef8af6fa0 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/BitHelper.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/BitHelper.cs
@@ -118,7 +118,7 @@ internal bool IsMarked(int bitPosition)
                 int bitArrayIndex = bitPosition / IntSize;
                 if (bitArrayIndex < _length && bitArrayIndex >= 0)
                 {
-                    return ((_arrayPtr[bitArrayIndex] & (MarkedBitFlag << (bitPosition % IntSize))) != 0);
+                    return (_arrayPtr[bitArrayIndex] & (MarkedBitFlag << (bitPosition % IntSize))) != 0;
                 }
                 return false;
             }
@@ -127,7 +127,7 @@ internal bool IsMarked(int bitPosition)
                 int bitArrayIndex = bitPosition / IntSize;
                 if (bitArrayIndex < _length && bitArrayIndex >= 0)
                 {
-                    return ((_array[bitArrayIndex] & (MarkedBitFlag << (bitPosition % IntSize))) != 0);
+                    return (_array[bitArrayIndex] & (MarkedBitFlag << (bitPosition % IntSize))) != 0;
                 }
                 return false;
             }
@@ -141,7 +141,7 @@ internal bool IsMarked(int bitPosition)
         /// <returns></returns>
         internal static int ToIntArrayLength(int n)
         {
-            return n > 0 ? ((n - 1) / IntSize + 1) : 0;
+            return n > 0 ? (((n - 1) / IntSize) + 1) : 0;
         }
     }
 }
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs b/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs
index 9a035b9570c..5db12d82c2e 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs
@@ -46,7 +46,7 @@ internal static bool IsPrime(int candidate)
                 }
                 return true;
             }
-            return (candidate == 2);
+            return candidate == 2;
         }
 
 #if !SILVERLIGHT
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
index 2ad4638c0a8..92adb2e2a31 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
@@ -170,7 +170,7 @@ public RetrievableEntryHashSet(IEnumerable<T> collection, IEqualityComparer<stri
         {
             if (collection == null)
             {
-                throw new ArgumentNullException("collection");
+                throw new ArgumentNullException(nameof(collection));
             }
 
             Contract.EndContractBlock();
@@ -285,18 +285,18 @@ public void Clear()
         // Convenience
         internal bool Contains(string key)
         {
-            return (Get(key) != null);
+            return Get(key) != null;
         }
 
         bool ICollection<KeyValuePair<string, T>>.Contains(KeyValuePair<string, T> entry)
         {
             Debug.Assert(String.Equals(entry.Key, entry.Value.Key, StringComparison.Ordinal));
-            return (Get(entry.Value.Key) != null);
+            return Get(entry.Value.Key) != null;
         }
 
         public bool ContainsKey(string key)
         {
-            return (Get(key) != null);
+            return Get(key) != null;
         }
 
         T IDictionary<string, T>.this[string name]
@@ -312,14 +312,14 @@ T IDictionary<string, T>.this[string name]
         /// <returns>true if item contained; false if not</returns>
         public bool Contains(T item)
         {
-            return (Get(item.Key) != null);
+            return Get(item.Key) != null;
         }
 
         // Convenience to minimise change to callers used to dictionaries
         public bool TryGetValue(string key, out T item)
         {
             item = Get(key);
-            return (item != null);
+            return item != null;
         }
 
         /// <summary>
@@ -342,10 +342,10 @@ public T Get(string key)
         public T Get(string key, int index, int length)
         {
             if (length < 0)
-                throw new ArgumentOutOfRangeException("length");
+                throw new ArgumentOutOfRangeException(nameof(length));
 
             if (index < 0 || index > (key == null ? 0 : key.Length) - length)
-                throw new ArgumentOutOfRangeException("index");
+                throw new ArgumentOutOfRangeException(nameof(index));
 
             if (_constrainedComparer == null)
                 throw new InvalidOperationException("Cannot do a constrained lookup on this collection.");
@@ -517,7 +517,7 @@ public virtual void GetObjectData(SerializationInfo info, StreamingContext conte
         {
             if (info == null)
             {
-                throw new ArgumentNullException("info");
+                throw new ArgumentNullException(nameof(info));
             }
 
             // need to serialize version to avoid problems with serializing while enumerating
@@ -619,7 +619,7 @@ public void UnionWith(IEnumerable<T> other)
         {
             if (other == null)
             {
-                throw new ArgumentNullException("other");
+                throw new ArgumentNullException(nameof(other));
             }
             Contract.EndContractBlock();
 
@@ -1005,20 +1005,20 @@ public void CopyTo(T[] array, int arrayIndex, int count)
         {
             if (array == null)
             {
-                throw new ArgumentNullException("array");
+                throw new ArgumentNullException(nameof(array));
             }
             Contract.EndContractBlock();
 
             // check array index valid index into array
             if (arrayIndex < 0)
             {
-                throw new ArgumentOutOfRangeException("arrayIndex");
+                throw new ArgumentOutOfRangeException(nameof(arrayIndex));
             }
 
             // also throw if count less than 0
             if (count < 0)
             {
-                throw new ArgumentOutOfRangeException("count");
+                throw new ArgumentOutOfRangeException(nameof(count));
             }
 
             // will array, starting at arrayIndex, be able to hold elements? Note: not
diff --git a/src/Build/Collections/WeakValueDictionary.cs b/src/Build/Collections/WeakValueDictionary.cs
index 7051dcef8bd..6193363093d 100644
--- a/src/Build/Collections/WeakValueDictionary.cs
+++ b/src/Build/Collections/WeakValueDictionary.cs
@@ -206,7 +206,7 @@ public int Scavenge()
 
                 if (!entry.Value.TryGetTarget(out _))
                 {
-                    remove = remove ?? new List<K>();
+                    remove ??= new List<K>();
                     remove.Add(entry.Key);
                 }
             }
diff --git a/src/Build/Construction/ProjectElement.cs b/src/Build/Construction/ProjectElement.cs
index 44c8458b111..129e9ae3f35 100644
--- a/src/Build/Construction/ProjectElement.cs
+++ b/src/Build/Construction/ProjectElement.cs
@@ -392,7 +392,6 @@ public virtual void CopyFrom(ProjectElement element)
             }
             else
             {
-
                 // Copy over the attributes from the template element.
                 foreach (XmlAttribute attribute in element.XmlElement.Attributes)
                 {
diff --git a/src/Build/Construction/ProjectElementContainer.cs b/src/Build/Construction/ProjectElementContainer.cs
index 2c74f13933f..b55ba655ff4 100644
--- a/src/Build/Construction/ProjectElementContainer.cs
+++ b/src/Build/Construction/ProjectElementContainer.cs
@@ -481,7 +481,7 @@ internal void AddToXml(ProjectElement child)
                 // Therefore, we need to traverse both directions to find the first sibling of the same type as the one being added.
                 // If none is found, then the node being added is inserted as the only node of its kind
 
-                bool SiblingIsExplicitElement(ProjectElement _) => _.ExpressedAsAttribute == false;
+                bool SiblingIsExplicitElement(ProjectElement _) => !_.ExpressedAsAttribute;
 
                 if (TrySearchLeftSiblings(child.PreviousSibling, SiblingIsExplicitElement, out ProjectElement referenceSibling))
                 {
@@ -491,8 +491,7 @@ internal void AddToXml(ProjectElement child)
                     {
                         //  Try to match the surrounding formatting by checking the whitespace that precedes the node we inserted
                         //  after, and inserting the same whitespace between the previous node and the one we added
-                        if (referenceSibling.XmlElement.PreviousSibling != null &&
-                            referenceSibling.XmlElement.PreviousSibling.NodeType == XmlNodeType.Whitespace)
+                        if (referenceSibling.XmlElement.PreviousSibling?.NodeType == XmlNodeType.Whitespace)
                         {
                             var newWhitespaceNode = XmlDocument.CreateWhitespace(referenceSibling.XmlElement.PreviousSibling.Value);
                             XmlElement.InsertAfter(newWhitespaceNode, referenceSibling.XmlElement);
@@ -508,8 +507,7 @@ internal void AddToXml(ProjectElement child)
                     {
                         //  Try to match the surrounding formatting by checking the whitespace that precedes where we inserted
                         //  the new node, and inserting the same whitespace between the node we added and the one after it.
-                        if (child.XmlElement.PreviousSibling != null &&
-                            child.XmlElement.PreviousSibling.NodeType == XmlNodeType.Whitespace)
+                        if (child.XmlElement.PreviousSibling?.NodeType == XmlNodeType.Whitespace)
                         {
                             var newWhitespaceNode = XmlDocument.CreateWhitespace(child.XmlElement.PreviousSibling.Value);
                             XmlElement.InsertBefore(newWhitespaceNode, referenceSibling.XmlElement);
@@ -579,7 +577,7 @@ internal void RemoveFromXml(ProjectElement child)
                 {
                     //  If we are trying to preserve formatting of the file, then also remove any whitespace
                     //  that came before the node we removed.
-                    if (previousSibling != null && previousSibling.NodeType == XmlNodeType.Whitespace)
+                    if (previousSibling?.NodeType == XmlNodeType.Whitespace)
                     {
                         XmlElement.RemoveChild(previousSibling);
                     }
diff --git a/src/Build/Construction/ProjectExtensionsElement.cs b/src/Build/Construction/ProjectExtensionsElement.cs
index 10483bb6349..26bb1f9d0f0 100644
--- a/src/Build/Construction/ProjectExtensionsElement.cs
+++ b/src/Build/Construction/ProjectExtensionsElement.cs
@@ -114,7 +114,7 @@ public string this[string name]
 
             set
             {
-                ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+                ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
                 ErrorUtilities.VerifyThrowArgumentNull(value, "value");
 
                 if (Link != null)
diff --git a/src/Build/Construction/ProjectOutputElement.cs b/src/Build/Construction/ProjectOutputElement.cs
index d8e5afe3116..42ef062218a 100644
--- a/src/Build/Construction/ProjectOutputElement.cs
+++ b/src/Build/Construction/ProjectOutputElement.cs
@@ -140,7 +140,7 @@ internal static ProjectOutputElement CreateDisconnected(string taskParameter, st
         {
             ErrorUtilities.VerifyThrowArgument
                 (
-                (String.IsNullOrEmpty(itemType) ^ String.IsNullOrEmpty(propertyName)),
+                String.IsNullOrEmpty(itemType) ^ String.IsNullOrEmpty(propertyName),
                 "OM_EitherAttributeButNotBoth",
                 XMakeElements.output,
                 XMakeAttributes.propertyName,
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index 287b965ab35..9d86a4731dd 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -142,7 +142,6 @@ public class ProjectRootElement : ProjectElementContainer
         /// </summary>
         private string _dirtyParameter = String.Empty;
 
-
         internal ProjectRootElementLink RootLink => (ProjectRootElementLink)Link;
 
         /// <summary>
@@ -748,7 +747,6 @@ public static ProjectRootElement Create(ProjectCollection projectCollection, New
             return Create(projectCollection.ProjectRootElementCache, projectFileOptions);
         }
 
-
         /// <summary>
         /// Initialize an in-memory, empty ProjectRootElement instance that can be saved later.
         /// Uses the global project collection.
@@ -983,8 +981,8 @@ public ProjectItemElement AddItem(string itemType, string include)
         /// </remarks>
         public ProjectItemElement AddItem(string itemType, string include, IEnumerable<KeyValuePair<string, string>> metadata)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(itemType, "itemType");
-            ErrorUtilities.VerifyThrowArgumentLength(include, "include");
+            ErrorUtilities.VerifyThrowArgumentLength(itemType, nameof(itemType));
+            ErrorUtilities.VerifyThrowArgumentLength(include, nameof(include));
 
             ProjectItemGroupElement itemGroupToAddTo = null;
 
@@ -1005,7 +1003,7 @@ public ProjectItemElement AddItem(string itemType, string include, IEnumerable<K
                     itemGroupToAddTo = itemGroup;
                 }
 
-                if (itemGroupToAddTo != null && itemGroupToAddTo.Count > 0)
+                if (itemGroupToAddTo?.Count > 0)
                 {
                     break;
                 }
@@ -2033,6 +2031,7 @@ bool preserveFormatting
         /// </summary>
         /// <param name="fullPath">The full path to the document to load.</param>
         /// <param name="preserveFormatting"><code>true</code> to preserve the formatting of the document, otherwise <code>false</code>.</param>
+        /// <param name="loadAsReadOnly">Whether to load the file in read-only mode.</param>
         private XmlDocumentWithLocation LoadDocument(string fullPath, bool preserveFormatting, bool loadAsReadOnly)
         {
             ErrorUtilities.VerifyThrowInternalRooted(fullPath);
diff --git a/src/Build/Construction/ProjectTargetElement.cs b/src/Build/Construction/ProjectTargetElement.cs
index c1b1f309d1a..3b167544c55 100644
--- a/src/Build/Construction/ProjectTargetElement.cs
+++ b/src/Build/Construction/ProjectTargetElement.cs
@@ -88,7 +88,7 @@ public string Name
                 // No thread-safety lock required here because many reader threads would set the same value to the field.
                 if (_name != null) return _name;
                 string unescapedValue = EscapingUtilities.UnescapeAll(GetAttributeValue(XMakeAttributes.name));
-                return (_name = unescapedValue);
+                return _name = unescapedValue;
             }
 
             set
@@ -114,7 +114,7 @@ public string Name
         }
 
         /// <summary>
-        /// Gets or sets the Inputs value. 
+        /// Gets or sets the Inputs value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -134,7 +134,7 @@ public string Inputs
         }
 
         /// <summary>
-        /// Gets or sets the Outputs value. 
+        /// Gets or sets the Outputs value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -154,7 +154,7 @@ public string Outputs
         }
 
         /// <summary>
-        /// Gets or sets the TrimDuplicateOutputs value. 
+        /// Gets or sets the TrimDuplicateOutputs value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -182,7 +182,7 @@ public string KeepDuplicateOutputs
         }
 
         /// <summary>
-        /// Gets or sets the DependsOnTargets value. 
+        /// Gets or sets the DependsOnTargets value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -202,7 +202,7 @@ public string DependsOnTargets
         }
 
         /// <summary>
-        /// Gets or sets the BeforeTargets value. 
+        /// Gets or sets the BeforeTargets value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -222,7 +222,7 @@ public string BeforeTargets
         }
 
         /// <summary>
-        /// Gets or sets the AfterTargets value. 
+        /// Gets or sets the AfterTargets value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -242,10 +242,10 @@ public string AfterTargets
         }
 
         /// <summary>
-        /// Gets or sets the Returns value. 
-        /// Returns null if the attribute is not present -- empty string is an allowable 
-        /// value for both getting and setting. 
-        /// Removes the attribute only if the value is set to null. 
+        /// Gets or sets the Returns value.
+        /// Returns null if the attribute is not present -- empty string is an allowable
+        /// value for both getting and setting.
+        /// Removes the attribute only if the value is set to null.
         /// </summary>
         public string Returns
         {
diff --git a/src/Build/Construction/ProjectTaskElement.cs b/src/Build/Construction/ProjectTaskElement.cs
index f09324cbbc0..424aa432fdf 100644
--- a/src/Build/Construction/ProjectTaskElement.cs
+++ b/src/Build/Construction/ProjectTaskElement.cs
@@ -48,7 +48,7 @@ internal ProjectTaskElement(ProjectTaskElementLink link)
         internal ProjectTaskElement(XmlElementWithLocation xmlElement, ProjectTargetElement parent, ProjectRootElement containingProject)
             : base(xmlElement, parent, containingProject)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
         }
 
         /// <summary>
@@ -60,7 +60,7 @@ private ProjectTaskElement(XmlElementWithLocation xmlElement, ProjectRootElement
         }
 
         /// <summary>
-        /// Gets or sets the continue on error value. 
+        /// Gets or sets the continue on error value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -80,7 +80,7 @@ public string ContinueOnError
         }
 
         /// <summary>
-        /// Gets or sets the runtime value for the task. 
+        /// Gets or sets the runtime value for the task.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -100,7 +100,7 @@ public string MSBuildRuntime
         }
 
         /// <summary>
-        /// Gets or sets the architecture value for the task. 
+        /// Gets or sets the architecture value for the task.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -226,8 +226,8 @@ public IEnumerable<KeyValuePair<string, ElementLocation>> ParameterLocations
         }
 
         /// <summary>
-        /// Convenience method to add an Output Item to this task. 
-        /// Adds after the last child. 
+        /// Convenience method to add an Output Item to this task.
+        /// Adds after the last child.
         /// </summary>
         public ProjectOutputElement AddOutputItem(string taskParameter, string itemType)
         {
@@ -238,8 +238,8 @@ public ProjectOutputElement AddOutputItem(string taskParameter, string itemType)
         }
 
         /// <summary>
-        /// Convenience method to add a conditioned Output Item to this task. 
-        /// Adds after the last child. 
+        /// Convenience method to add a conditioned Output Item to this task.
+        /// Adds after the last child.
         /// </summary>
         public ProjectOutputElement AddOutputItem(string taskParameter, string itemType, string condition)
         {
@@ -256,8 +256,8 @@ public ProjectOutputElement AddOutputItem(string taskParameter, string itemType,
         }
 
         /// <summary>
-        /// Convenience method to add an Output Property to this task. 
-        /// Adds after the last child. 
+        /// Convenience method to add an Output Property to this task.
+        /// Adds after the last child.
         /// </summary>
         public ProjectOutputElement AddOutputProperty(string taskParameter, string propertyName)
         {
@@ -268,8 +268,8 @@ public ProjectOutputElement AddOutputProperty(string taskParameter, string prope
         }
 
         /// <summary>
-        /// Convenience method to add a conditioned Output Property to this task. 
-        /// Adds after the last child. 
+        /// Convenience method to add a conditioned Output Property to this task.
+        /// Adds after the last child.
         /// </summary>
         public ProjectOutputElement AddOutputProperty(string taskParameter, string propertyName, string condition)
         {
@@ -377,7 +377,7 @@ public void RemoveAllParameters()
                 {
                     if (!XMakeAttributes.IsSpecialTaskAttribute(attribute.Name))
                     {
-                        toRemove = toRemove ?? new List<XmlAttribute>();
+                        toRemove ??= new List<XmlAttribute>();
                         toRemove.Add(attribute);
                     }
                 }
diff --git a/src/Build/Construction/ProjectUsingTaskElement.cs b/src/Build/Construction/ProjectUsingTaskElement.cs
index 815551f3b1f..b873d63a284 100644
--- a/src/Build/Construction/ProjectUsingTaskElement.cs
+++ b/src/Build/Construction/ProjectUsingTaskElement.cs
@@ -214,7 +214,7 @@ public ProjectUsingTaskBodyElement AddUsingTaskBody(string evaluate, string task
         internal static ProjectUsingTaskElement CreateDisconnected(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture, ProjectRootElement containingProject)
         {
             ErrorUtilities.VerifyThrowArgument(
-                (String.IsNullOrEmpty(assemblyFile) ^ String.IsNullOrEmpty(assemblyName)),
+                String.IsNullOrEmpty(assemblyFile) ^ String.IsNullOrEmpty(assemblyName),
                 "OM_EitherAttributeButNotBoth",
                 XMakeElements.usingTask,
                 XMakeAttributes.assemblyFile,
diff --git a/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs b/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs
index 89173d16092..0700c134ddb 100644
--- a/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs
@@ -10,7 +10,6 @@ namespace Microsoft.Build.Construction
     /// </summary>
     public sealed class ProjectConfigurationInSolution
     {
-
         /// <summary>
         /// Constructor
         /// </summary>
@@ -52,7 +51,7 @@ internal ProjectConfigurationInSolution(string configurationName, string platfor
         /// </summary>
         private static string RemoveSpaceFromAnyCpuPlatform(string platformName)
         {
-            if (string.Compare(platformName, "Any CPU", StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(platformName, "Any CPU", StringComparison.OrdinalIgnoreCase))
             {
                 return "AnyCPU";
             }
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index 2c6235654ee..462b055cbc2 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -96,7 +96,8 @@ public sealed class ProjectInSolution
         private string _relativePath;         // Relative from .SLN file.  For example, "WindowsApplication1\WindowsApplication1.csproj"
         private readonly List<string> _dependencies;     // A list of strings representing the Guids of the dependent projects.
         private IReadOnlyList<string> _dependenciesAsReadonly;
-        private string _uniqueProjectName;    // For example, "MySlnFolder\MySubSlnFolder\WindowsApplication1"
+        private string _uniqueProjectName;    // For example, "MySlnFolder\MySubSlnFolder\Windows_Application1"
+        private string _originalProjectName;    // For example, "MySlnFolder\MySubSlnFolder\Windows.Application1"
 
         /// <summary>
         /// The project configuration in given solution configuration
@@ -282,14 +283,14 @@ internal bool CanBeMSBuildProjectFile(out string errorMessage)
                     }
                 }
 
-                if (mainProjectElement != null && mainProjectElement.LocalName == "Project")
+                if (mainProjectElement?.LocalName == "Project")
                 {
                     // MSBuild supports project files with an empty (supported in Visual Studio 2017) or the default MSBuild
                     // namespace.
                     bool emptyNamespace = string.IsNullOrEmpty(mainProjectElement.NamespaceURI);
-                    bool defaultNamespace = String.Compare(mainProjectElement.NamespaceURI,
+                    bool defaultNamespace = String.Equals(mainProjectElement.NamespaceURI,
                                                 XMakeAttributes.defaultXmlNamespace,
-                                                StringComparison.OrdinalIgnoreCase) == 0;
+                                                StringComparison.OrdinalIgnoreCase);
                     bool projectElementInvalid = ElementContainsInvalidNamespaceDefitions(mainProjectElement);
 
                     // If the MSBuild namespace is declared, it is very likely an MSBuild project that should be built.
@@ -345,7 +346,7 @@ internal bool CanBeMSBuildProjectFile(out string errorMessage)
         }
 
         /// <summary>
-        /// Find the unique name for this project, e.g. SolutionFolder\SubSolutionFolder\ProjectName
+        /// Find the unique name for this project, e.g. SolutionFolder\SubSolutionFolder\Project_Name
         /// </summary>
         internal string GetUniqueProjectName()
         {
@@ -383,6 +384,55 @@ internal string GetUniqueProjectName()
             return _uniqueProjectName;
         }
 
+        /// <summary>
+        /// Gets the original project name with the parent project as it is declared in the solution file, e.g. SolutionFolder\SubSolutionFolder\Project.Name
+        /// </summary>
+        internal string GetOriginalProjectName()
+        {
+            if (_originalProjectName == null)
+            {
+                // EtpSubProject and Venus projects have names that are already unique.  No need to prepend the SLN folder.
+                if ((ProjectType == SolutionProjectType.WebProject) || (ProjectType == SolutionProjectType.EtpSubProject))
+                {
+                    _originalProjectName = ProjectName;
+                }
+                else
+                {
+                    // This is "normal" project, which in this context means anything non-Venus and non-EtpSubProject.
+
+                    // If this project has a parent SLN folder, first get the full project name for the SLN folder,
+                    // and tack on trailing backslash.
+                    string projectName = String.Empty;
+
+                    if (ParentProjectGuid != null)
+                    {
+                        if (!ParentSolution.ProjectsByGuid.TryGetValue(ParentProjectGuid, out ProjectInSolution parent))
+                        {
+                            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(parent != null, "SubCategoryForSolutionParsingErrors",
+                                new BuildEventFileInfo(ParentSolution.FullPath), "SolutionParseNestedProjectError");
+                        }
+
+                        projectName = parent.GetOriginalProjectName() + "\\";
+                    }
+
+                    // Now tack on our own project name, and cache it in the ProjectInSolution object for future quick access.
+                    _originalProjectName = projectName + ProjectName;
+                }
+            }
+
+            return _originalProjectName;
+        }
+
+        internal string GetProjectGuidWithoutCurlyBrackets()
+        {
+            if (string.IsNullOrEmpty(ProjectGuid))
+            {
+                return null;
+            }
+
+            return ProjectGuid.Trim(new char[] { '{', '}' });
+        }
+
         /// <summary>
         /// Changes the unique name of the project.
         /// </summary>
@@ -434,7 +484,7 @@ internal static string DisambiguateProjectTargetName(string uniqueProjectName)
             // entry point targets
             foreach (string projectName in projectNamesToDisambiguate)
             {
-                if (String.Compare(uniqueProjectName, projectName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(uniqueProjectName, projectName, StringComparison.OrdinalIgnoreCase))
                 {
                     // Prepend "Solution:" so that the collision is resolved, but the
                     // log of the solution project still looks reasonable.
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 5d3e7d5f5f8..177903a4e72 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -211,9 +211,12 @@ internal string FullPath
             }
         }
 
-        internal string SolutionFileDirectory { get;
+        internal string SolutionFileDirectory
+        {
+            get;
             // This setter is only used by the unit tests
-            set; }
+            set;
+        }
 
         /// <summary>
         /// For unit-testing only.
@@ -232,7 +235,7 @@ internal string FullPath
 
         internal bool ProjectShouldBuild(string projectFile)
         {
-            return _solutionFilter == null || _solutionFilter.Contains(projectFile);
+            return _solutionFilter?.Contains(projectFile) != false;
         }
 
         /// <summary>
@@ -255,7 +258,7 @@ public static SolutionFile Parse(string solutionFile)
         /// <returns>Whether the project is expected to be buildable</returns>
         internal static bool IsBuildableProject(ProjectInSolution project)
         {
-            return (project.ProjectType != SolutionProjectType.SolutionFolder && project.ProjectConfigurations.Count > 0);
+            return project.ProjectType != SolutionProjectType.SolutionFolder && project.ProjectConfigurations.Count > 0;
         }
 
         /// <summary>
@@ -437,8 +440,7 @@ private string ReadLine()
             string line = SolutionReader.ReadLine();
             _currentLineNumber++;
 
-            line = line?.Trim();
-            return line;
+            return line?.Trim();
         }
 
         /// <summary>
@@ -566,7 +568,8 @@ internal void ParseSolution()
             }
 
             // Cache the unique name of each project, and check that we don't have any duplicates.
-            var projectsByUniqueName = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+            var projectsByUniqueName = new Dictionary<string, ProjectInSolution>(StringComparer.OrdinalIgnoreCase);
+            var projectsByOriginalName = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
             foreach (ProjectInSolution proj in _projectsInOrder)
             {
@@ -601,15 +604,47 @@ internal void ParseSolution()
                     }
                 }
 
-                // Update the hash table with this unique name
-                bool didntAlreadyExist = projectsByUniqueName.Add(uniqueName);
+                // Detect collision caused by unique name's normalization
+                if (projectsByUniqueName.ContainsKey(uniqueName))
+                {
+                    // Did normalization occur in the current project?
+                    if (uniqueName != proj.ProjectName)
+                    {
+                        // Generates a new unique name
+                        string tempUniqueName = $"{uniqueName}_{proj.GetProjectGuidWithoutCurlyBrackets()}";
+                        proj.UpdateUniqueProjectName(tempUniqueName);
+                        uniqueName = tempUniqueName;
+                    }
+                    // Did normalization occur in a previous project?
+                    else if (uniqueName != projectsByUniqueName[uniqueName].ProjectName)
+                    {
+                        var projTemp = projectsByUniqueName[uniqueName];
+
+                        // Generates a new unique name
+                        string tempUniqueName = $"{uniqueName}_{projTemp.GetProjectGuidWithoutCurlyBrackets()}";
+                        projTemp.UpdateUniqueProjectName(tempUniqueName);
+
+                        projectsByUniqueName.Remove(uniqueName);
+                        projectsByUniqueName.Add(tempUniqueName, projTemp);
+                    }
+                }
+
+                bool uniqueNameExists = projectsByUniqueName.ContainsKey(uniqueName);
+
+                // Add the unique name (if it does not exist) to the hash table 
+                if (!uniqueNameExists)
+                {
+                    projectsByUniqueName.Add(uniqueName, proj);
+                }
+
+                bool didntAlreadyExist = !uniqueNameExists && projectsByOriginalName.Add(proj.GetOriginalProjectName());
+
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
                     didntAlreadyExist,
                     "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(FullPath),
                     "SolutionParseDuplicateProject",
-                    uniqueName);
-
+                    uniqueNameExists ? uniqueName : proj.ProjectName);
             }
         } // ParseSolutionFile()
 
@@ -757,7 +792,7 @@ private void ParseProject(string firstLine)
                     // We have a ProjectDependencies section.  Each subsequent line should identify
                     // a dependency.
                     line = ReadLine();
-                    while ((line != null) && (!line.StartsWith("EndProjectSection", StringComparison.Ordinal)))
+                    while ((line?.StartsWith("EndProjectSection", StringComparison.Ordinal) == false))
                     {
                         // This should be a dependency.  The GUID identifying the parent project should
                         // be both the property name and the property value.
@@ -777,7 +812,7 @@ private void ParseProject(string firstLine)
                     // projects, and contains properties that we'll need in order to call the 
                     // AspNetCompiler task.
                     line = ReadLine();
-                    while ((line != null) && (!line.StartsWith("EndProjectSection", StringComparison.Ordinal)))
+                    while ((line?.StartsWith("EndProjectSection", StringComparison.Ordinal) == false))
                     {
                         Match match = s_crackPropertyLine.Value.Match(line);
                         ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(match.Success, "SubCategoryForSolutionParsingErrors",
@@ -1131,7 +1166,7 @@ string propertyValue
             else
             {
                 // ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;" 
-                if (string.Compare(propertyName, "ProjectReferences", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(propertyName, "ProjectReferences", StringComparison.OrdinalIgnoreCase))
                 {
                     string[] projectReferenceEntries = propertyValue.Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
 
@@ -1159,7 +1194,7 @@ string propertyValue
                         }
                     }
                 }
-                else if (String.Compare(propertyName, "TargetFrameworkMoniker", StringComparison.OrdinalIgnoreCase) == 0)
+                else if (String.Equals(propertyName, "TargetFrameworkMoniker", StringComparison.OrdinalIgnoreCase))
                 {
                     //Website project need to back support 3.5 msbuild parser for the Blend (it is not move to .Net4.0 yet.)
                     //However, 3.5 version of Solution parser can't handle a equal sign in the value.  
@@ -1223,29 +1258,29 @@ ProjectInSolution proj
             ValidateProjectRelativePath(proj);
 
             // Figure out what type of project this is.
-            if ((String.Compare(projectTypeGuid, vbProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, csProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, cpsProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, cpsCsProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, cpsVbProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, cpsFsProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, fsProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, dbProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, vjProjectGuid, StringComparison.OrdinalIgnoreCase) == 0))
+            if ((String.Equals(projectTypeGuid, vbProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, csProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, cpsProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, cpsCsProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, cpsVbProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, cpsFsProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, fsProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, dbProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, vjProjectGuid, StringComparison.OrdinalIgnoreCase)))
             {
                 proj.ProjectType = SolutionProjectType.KnownToBeMSBuildFormat;
             }
-            else if (String.Compare(projectTypeGuid, sharedProjectGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, sharedProjectGuid, StringComparison.OrdinalIgnoreCase))
             {
                 proj.ProjectType = SolutionProjectType.SharedProject;
             }
-            else if (String.Compare(projectTypeGuid, solutionFolderGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, solutionFolderGuid, StringComparison.OrdinalIgnoreCase))
             {
                 proj.ProjectType = SolutionProjectType.SolutionFolder;
             }
             // MSBuild format VC projects have the same project type guid as old style VC projects.
             // If it's not an old-style VC project, we'll assume it's MSBuild format
-            else if (String.Compare(projectTypeGuid, vcProjectGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, vcProjectGuid, StringComparison.OrdinalIgnoreCase))
             {
                 if (String.Equals(proj.Extension, ".vcproj", StringComparison.OrdinalIgnoreCase))
                 {
@@ -1261,12 +1296,12 @@ ProjectInSolution proj
                     proj.ProjectType = SolutionProjectType.KnownToBeMSBuildFormat;
                 }
             }
-            else if (String.Compare(projectTypeGuid, webProjectGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, webProjectGuid, StringComparison.OrdinalIgnoreCase))
             {
                 proj.ProjectType = SolutionProjectType.WebProject;
                 ContainsWebProjects = true;
             }
-            else if (String.Compare(projectTypeGuid, wdProjectGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, wdProjectGuid, StringComparison.OrdinalIgnoreCase))
             {
                 proj.ProjectType = SolutionProjectType.WebDeploymentProject;
                 ContainsWebDeploymentProjects = true;
@@ -1352,7 +1387,7 @@ internal void ParseSolutionConfigurations()
                 string fullConfigurationName = configurationNames[0].Trim();
 
                 //Fixing bug 555577: Solution file can have description information, in which case we ignore.
-                if (0 == String.Compare(fullConfigurationName, "DESCRIPTION", StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(fullConfigurationName, "DESCRIPTION", StringComparison.OrdinalIgnoreCase))
                 {
                     continue;
                 }
@@ -1493,7 +1528,7 @@ public string GetDefaultConfigurationName()
             // Pick the Debug configuration as default if present
             foreach (SolutionConfigurationInSolution solutionConfiguration in SolutionConfigurations)
             {
-                if (string.Compare(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase))
                 {
                     _defaultConfigurationName = solutionConfiguration.ConfigurationName;
                     break;
@@ -1526,13 +1561,13 @@ public string GetDefaultPlatformName()
             // Pick the Mixed Platforms platform as default if present
             foreach (SolutionConfigurationInSolution solutionConfiguration in SolutionConfigurations)
             {
-                if (string.Compare(solutionConfiguration.PlatformName, "Mixed Platforms", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(solutionConfiguration.PlatformName, "Mixed Platforms", StringComparison.OrdinalIgnoreCase))
                 {
                     _defaultPlatformName = solutionConfiguration.PlatformName;
                     break;
                 }
                 // We would like this to be chosen if Mixed platforms does not exist.
-                else if (string.Compare(solutionConfiguration.PlatformName, "Any CPU", StringComparison.OrdinalIgnoreCase) == 0)
+                else if (string.Equals(solutionConfiguration.PlatformName, "Any CPU", StringComparison.OrdinalIgnoreCase))
                 {
                     _defaultPlatformName = solutionConfiguration.PlatformName;
                 }
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index b1f32e3a5d0..e935b5cc18d 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -101,7 +101,7 @@ internal class SolutionProjectGenerator
         private readonly SolutionFile _solutionFile;
 
         /// <summary>
-        /// The global properties passed under which the project should be opened. 
+        /// The global properties passed under which the project should be opened.
         /// </summary>
         private readonly IDictionary<string, string> _globalProperties;
 
@@ -111,7 +111,7 @@ internal class SolutionProjectGenerator
         private readonly string _toolsVersionOverride;
 
         /// <summary>
-        /// The context of this build (used for logging purposes). 
+        /// The context of this build (used for logging purposes).
         /// </summary>
         private readonly BuildEventContext _projectBuildEventContext;
 
@@ -168,7 +168,7 @@ private SolutionProjectGenerator(
         }
 
         /// <summary>
-        /// This method generates an MSBuild project file from the list of projects and project dependencies 
+        /// This method generates an MSBuild project file from the list of projects and project dependencies
         /// that have been collected from the solution file.
         /// </summary>
         /// <param name="solution">The parser which contains the solution file.</param>
@@ -321,7 +321,7 @@ params object[] args
         /// <summary>
         /// Normally the active solution configuration/platform is determined when we build the solution
         /// wrapper project, not when we create it. However, we need to know them to scan project references
-        /// for the right project configuration/platform. It's unlikely that references would be conditional, 
+        /// for the right project configuration/platform. It's unlikely that references would be conditional,
         /// but still possible and we want to get that case right.
         /// </summary>
         internal static string PredictActiveSolutionConfigurationName(SolutionFile solutionFile, IDictionary<string, string> globalProperties)
@@ -376,7 +376,7 @@ private static string DetermineWrapperProjectToolsVersion(string toolsVersionOve
 
 #if FEATURE_ASPNET_COMPILER
         /// <summary>
-        /// Add a call to the ResolveAssemblyReference task to crack the pre-resolved referenced 
+        /// Add a call to the ResolveAssemblyReference task to crack the pre-resolved referenced
         /// assemblies for the complete list of dependencies, PDBs, satellites, etc.  The invoke
         /// the Copy task to copy all these files (or at least the ones that RAR determined should
         /// be copied local) into the web project's bin directory.
@@ -439,10 +439,10 @@ string conditionDescribingValidConfigurations
         }
 
         /// <summary>
-        /// This code handles the *.REFRESH files that are in the "bin" subdirectory of 
-        /// a web project.  These .REFRESH files are just text files that contain absolute or 
-        /// relative paths to the referenced assemblies.  The goal of these tasks is to 
-        /// search all *.REFRESH files and extract fully-qualified absolute paths for 
+        /// This code handles the *.REFRESH files that are in the "bin" subdirectory of
+        /// a web project.  These .REFRESH files are just text files that contain absolute or
+        /// relative paths to the referenced assemblies.  The goal of these tasks is to
+        /// search all *.REFRESH files and extract fully-qualified absolute paths for
         /// each of the references.
         /// </summary>
         private static void AddTasksToResolveAutoRefreshFileReferences
@@ -681,7 +681,7 @@ private ProjectInstance[] Generate()
             // Validate against our minimum for upgradable projects
             ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
                 (
-                (_solutionFile.Version >= SolutionFile.slnFileMinVersion),
+                _solutionFile.Version >= SolutionFile.slnFileMinVersion,
                 "SubCategoryForSolutionParsingErrors",
                 new BuildEventFileInfo(_solutionFile.FullPath),
                 "SolutionParseUpgradeNeeded"
@@ -853,7 +853,6 @@ private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersio
             ProjectImportElement importAfter = traversalProject.CreateImportElement(@"$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\SolutionFile\ImportAfter\*");
             importAfter.Condition = @"'$(ImportByWildcardBeforeSolution)' != 'false' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\SolutionFile\ImportAfter')"; // Avoids wildcard perf problem
 
-
             /* The code below adds the following XML:
 
             - TOP -
@@ -995,7 +994,7 @@ private void EmitMetaproject(ProjectRootElement metaproject, string path)
             {
                 metaproject.Save(path);
             }
-            if (_loggingService.IncludeEvaluationMetaprojects == true)
+            if (_loggingService.IncludeEvaluationMetaprojects)
             {
                 var xml = new StringBuilder();
                 using (var writer = new StringWriter(xml))
@@ -1141,35 +1140,35 @@ private bool CanBuildDirectly(ProjectInstance traversalProject, ProjectInSolutio
         }
 
         /// <summary>
-        /// Produces a set of targets which allows the MSBuild scheduler to schedule projects in the order automatically by 
+        /// Produces a set of targets which allows the MSBuild scheduler to schedule projects in the order automatically by
         /// following their dependencies without enforcing build levels.
         /// </summary>
         /// <remarks>
         /// We want MSBuild to be able to parallelize the builds of these projects where possible and still honor references.
         /// Since the project files referenced by the solution do not (necessarily) themselves contain actual project references
         /// to the projects they depend on, we need to synthesize this relationship ourselves.  This is done by creating a target
-        /// which first invokes the project's dependencies, then invokes the actual project itself.  However, invoking the 
-        /// dependencies must also invoke their dependencies and so on down the line.  
-        /// 
+        /// which first invokes the project's dependencies, then invokes the actual project itself.  However, invoking the
+        /// dependencies must also invoke their dependencies and so on down the line.
+        ///
         /// Additionally, we do not wish to create a separate MSBuild project to contain this target yet we want to parallelize
         /// calls to these targets.  The way to do this is to pass in different global properties to the same project in the same
         /// MSBuild call.  MSBuild easily allows this using the AdditionalProperties metadata which can be specified on an Item.
-        /// 
+        ///
         /// Assuming the solution project we are generating is called "foo.proj", we can accomplish this parallelism as follows:
         /// <ItemGroup>
         ///     <ProjectReference Include="Project0"/>
         ///     <ProjectReference Include="Project1"/>
         ///     <ProjectReference Include="Project2"/>
         /// </ItemGroup>
-        /// 
+        ///
         /// We now have expressed the top level reference to all projects as @(SolutionReference) and each project's
         /// set of references as @(PROJECTNAMEReference).  We construct our target as:
-        /// 
+        ///
         /// <Target Name="Build">
         ///     <MSBuild Projects="@(ProjectReference)" Targets="Build" />
         ///     <MSBuild Projects="actualProjectName" Targets="Build" />
         /// </Target>
-        /// 
+        ///
         /// The first MSBuild call re-invokes the solution project instructing it to build the reference projects for the
         /// current project.  The second MSBuild call invokes the actual project itself.  Because all reference projects have
         /// the same additional properties, MSBuild will only build the first one it comes across and the rest will be
@@ -1421,7 +1420,7 @@ private void AddMetaprojectTargetForWebProject(ProjectInstance traversalProject,
 
                     // Update our big condition string to include this configuration.
                     conditionDescribingValidConfigurations.Append(" or ");
-                    conditionDescribingValidConfigurations.Append(String.Format(CultureInfo.InvariantCulture, "('$(AspNetConfiguration)' == '{0}')", EscapingUtilities.Escape(configurationName)));
+                    conditionDescribingValidConfigurations.AppendFormat(CultureInfo.InvariantCulture, "('$(AspNetConfiguration)' == '{0}')", EscapingUtilities.Escape(configurationName));
                 }
 
                 StringBuilder referenceItemName = new StringBuilder(GenerateSafePropertyName(project, "References"));
@@ -1740,7 +1739,7 @@ string solutionFile
 
         /// <summary>
         /// When adding a target to build a web project, we want to put a Condition on the Target node that
-        /// effectively says "Only build this target if the web project is active (marked for building) in the 
+        /// effectively says "Only build this target if the web project is active (marked for building) in the
         /// current solution configuration.
         /// </summary>
         private string ComputeTargetConditionForWebProject(ProjectInSolution project)
@@ -1764,8 +1763,8 @@ private string ComputeTargetConditionForWebProject(ProjectInSolution project)
                         condition.Append(")");
                     }
                 }
-                else if (String.Compare(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase) == 0 ||
-                         String.Compare(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase) == 0)
+                else if (String.Equals(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase) ||
+                         String.Equals(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase))
                 {
                     // we don't have a project configuration that matches the solution configuration but
                     // the solution configuration is called "Release" or "Debug" which are standard AspNetConfigurations
@@ -2105,7 +2104,7 @@ private string DetermineChildProjectToolsVersion(string wrapperProjectToolsVersi
         /// <summary>
         /// Normally the active solution configuration/platform is determined when we build the solution
         /// wrapper project, not when we create it. However, we need to know them to scan project references
-        /// for the right project configuration/platform. It's unlikely that references would be conditional, 
+        /// for the right project configuration/platform. It's unlikely that references would be conditional,
         /// but still possible and we want to get that case right.
         /// </summary>
         private string PredictActiveSolutionConfigurationName()
@@ -2115,7 +2114,7 @@ private string PredictActiveSolutionConfigurationName()
 
         /// <summary>
         /// Loads each MSBuild project in this solution and looks for its project-to-project references so that
-        /// we know what build order we should use when building the solution. 
+        /// we know what build order we should use when building the solution.
         /// </summary>
         private void ScanProjectDependencies(string childProjectToolsVersion, string fullSolutionConfigurationName)
         {
@@ -2255,12 +2254,12 @@ private void AddPropertyGroupForSolutionConfiguration(ProjectRootElement travers
         /// <summary>
         /// Creates the default Venus configuration property based on the selected solution configuration.
         /// Unfortunately, Venus projects only expose one project configuration in the IDE (Debug) although
-        /// they allow building Debug and Release from command line. This means that if we wanted to use 
+        /// they allow building Debug and Release from command line. This means that if we wanted to use
         /// the project configuration from the active solution configuration for Venus projects, we'd always
         /// end up with Debug and there'd be no way to build the Release configuration. To work around this,
         /// we use a special mechanism for choosing ASP.NET project configuration: we set it to Release if
-        /// we're building a Release solution configuration, and to Debug if we're building a Debug solution 
-        /// configuration. The property is also settable from the command line, in which case it takes 
+        /// we're building a Release solution configuration, and to Debug if we're building a Debug solution
+        /// configuration. The property is also settable from the command line, in which case it takes
         /// precedence over this algorithm.
         /// </summary>
         private static void AddVenusConfigurationDefaults(ProjectRootElement traversalProject)
@@ -2312,7 +2311,7 @@ private void AddGlobalProperties(ProjectRootElement traversalProject)
 
         /// <summary>
         /// Special hack for web projects. It can happen that there is no Release configuration for solutions
-        /// containing web projects, yet we still want to be able to build the Release configuration for 
+        /// containing web projects, yet we still want to be able to build the Release configuration for
         /// those projects. Since the ASP.NET project configuration defaults to the solution configuration,
         /// we allow Release even if it doesn't actually exist in the solution.
         /// </summary>
@@ -2323,7 +2322,7 @@ private void AddFakeReleaseSolutionConfigurationIfNecessary()
                 bool solutionHasReleaseConfiguration = false;
                 foreach (SolutionConfigurationInSolution solutionConfiguration in _solutionFile.SolutionConfigurations)
                 {
-                    if (string.Compare(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase) == 0)
+                    if (string.Equals(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase))
                     {
                         solutionHasReleaseConfiguration = true;
                         break;
diff --git a/src/Build/Definition/BuiltInMetadata.cs b/src/Build/Definition/BuiltInMetadata.cs
index 70175de8f36..9e603570edd 100644
--- a/src/Build/Definition/BuiltInMetadata.cs
+++ b/src/Build/Definition/BuiltInMetadata.cs
@@ -76,8 +76,7 @@ internal static string GetMetadataValueEscaped(string currentDirectory, string e
             // This is an assert, not a VerifyThrow, because the caller should already have done this check, and it's slow/hot.
             Debug.Assert(FileUtilities.ItemSpecModifiers.IsItemSpecModifier(name));
 
-            string value = null;
-
+            string value;
             if (String.Equals(name, FileUtilities.ItemSpecModifiers.RecursiveDir, StringComparison.OrdinalIgnoreCase))
             {
                 value = GetRecursiveDirValue(evaluatedIncludeBeforeWildcardExpansionEscaped, evaluatedIncludeEscaped);
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 02bba78e5d9..62efc814b55 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -90,9 +90,9 @@ public class Project : ILinkableObject
         /// - <see cref="ProjectItem.RemoveMetadata"/>
         /// - <see cref="ProjectItem.SetMetadataValue(string,string)"/>
         /// - <see cref="ProjectItem.SetMetadataValue(string,string, bool)"/>
-        /// 
+        ///
         /// When this property is set to true, the previous item operations throw an <exception cref="InvalidOperationException"></exception>
-        /// instead of expanding the item element. 
+        /// instead of expanding the item element.
         /// </summary>
         public bool ThrowInsteadOfSplittingItemElement
         {
@@ -390,7 +390,7 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         }
 
         /// <summary>
-        /// Construct over an existing project file, evaluating with the specified global properties and 
+        /// Construct over an existing project file, evaluating with the specified global properties and
         /// using the tools version provided, either or both of which may be null.
         /// Project is added to the global project collection.
         /// Throws InvalidProjectFileException if the evaluation fails.
@@ -407,7 +407,7 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         }
 
         /// <summary>
-        /// Construct over an existing project file, evaluating with the specified global properties and 
+        /// Construct over an existing project file, evaluating with the specified global properties and
         /// using the tools version provided, either or both of which may be null.
         /// Project is added to the global project collection.
         /// Throws InvalidProjectFileException if the evaluation fails.
@@ -425,7 +425,7 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         }
 
         /// <summary>
-        /// Construct over an existing project file, evaluating with the specified global properties and 
+        /// Construct over an existing project file, evaluating with the specified global properties and
         /// using the tools version provided, either or both of which may be null.
         /// Project is added to the global project collection.
         /// Throws InvalidProjectFileException if the evaluation fails.
@@ -572,7 +572,7 @@ private enum BuildEnabledSetting
         /// <summary>
         /// Whether this project is dirty such that it needs reevaluation.
         /// This may be because its underlying XML has changed (either through this project or another)
-        /// either the XML of the main project or an imported file; 
+        /// either the XML of the main project or an imported file;
         /// or because its toolset may have changed.
         /// </summary>
         public bool IsDirty => implementation.IsDirty;
@@ -583,8 +583,8 @@ private enum BuildEnabledSetting
         /// </summary>
         /// <remarks>
         /// This is the publicly exposed getter, that translates into a read-only dead IDictionary&lt;string, string&gt;.
-        /// 
-        /// In order to easily tell when we're dirtied, setting and removing global properties is done with 
+        ///
+        /// In order to easily tell when we're dirtied, setting and removing global properties is done with
         /// <see cref="SetGlobalProperty">SetGlobalProperty</see> and <see cref="RemoveGlobalProperty">RemoveGlobalProperty</see>.
         /// </remarks>
         public IDictionary<string, string> GlobalProperties => implementation.GlobalProperties;
@@ -594,7 +594,7 @@ private enum BuildEnabledSetting
         /// This is an ordered collection.
         /// </summary>
         /// <comments>
-        /// data.ItemTypes is a KeyCollection, so it doesn't need any 
+        /// data.ItemTypes is a KeyCollection, so it doesn't need any
         /// additional read-only protection
         /// </comments>
         public ICollection<string> ItemTypes => implementation.ItemTypes;
@@ -608,17 +608,17 @@ private enum BuildEnabledSetting
         /// <summary>
         /// Collection of possible values implied for properties contained in the conditions found on properties,
         /// property groups, imports, and whens.
-        /// 
+        ///
         /// For example, if the following conditions existed on properties in a project:
-        /// 
+        ///
         /// Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'"
         /// Condition="'$(Configuration)' == 'Release'"
-        /// 
+        ///
         /// the table would be populated with
-        /// 
+        ///
         /// { "Configuration", { "Debug", "Release" }}
         /// { "Platform", { "x86" }}
-        /// 
+        ///
         /// This is used by Visual Studio to determine the configurations defined in the project.
         /// </summary>
         public IDictionary<string, List<string>> ConditionedProperties => implementation.ConditionedProperties;
@@ -639,7 +639,7 @@ private enum BuildEnabledSetting
         /// Items in this project, ordered within groups of item types,
         /// including items whose conditions evaluated to false, or that were
         /// contained within item groups who themselves had conditioned evaluated to false.
-        /// This is useful for hosts that wish to display all items, even if they might not be part 
+        /// This is useful for hosts that wish to display all items, even if they might not be part
         /// of the build in the current configuration.
         /// </summary>
         [SuppressMessage("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods", Justification = "This is a reasonable choice. API review approved")]
@@ -672,7 +672,7 @@ private enum BuildEnabledSetting
         /// <summary>
         /// Properties encountered during evaluation. These are read during the first evaluation pass.
         /// Unlike those returned by the Properties property, these are ordered, and includes any properties that
-        /// were subsequently overridden by others with the same name. It does not include any 
+        /// were subsequently overridden by others with the same name. It does not include any
         /// properties whose conditions did not evaluate to true.
         /// It does not include any properties added since the last evaluation.
         /// </summary>
@@ -681,7 +681,7 @@ private enum BuildEnabledSetting
         /// <summary>
         /// Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
         /// Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
-        /// were subsequently overridden by others with the same name and item type. It does not include any 
+        /// were subsequently overridden by others with the same name and item type. It does not include any
         /// elements whose conditions did not evaluate to true.
         /// It does not include any item definition metadata added since the last evaluation.
         /// </summary>
@@ -689,7 +689,7 @@ private enum BuildEnabledSetting
 
         /// <summary>
         /// Items encountered during evaluation. These are read during the third evaluation pass.
-        /// Unlike those returned by the Items property, these are ordered with respect to all other items 
+        /// Unlike those returned by the Items property, these are ordered with respect to all other items
         /// encountered during evaluation, not just ordered with respect to items of the same item type.
         /// In some applications, like the F# language, this complete mutual ordering is significant, and such hosts
         /// can use this property.
@@ -712,7 +712,7 @@ private enum BuildEnabledSetting
 
         /// <summary>
         /// The sub-toolset version that, combined with the ToolsVersion, was used to determine
-        /// the toolset properties for this project.  
+        /// the toolset properties for this project.
         /// </summary>
         public string SubToolsetVersion => implementation.SubToolsetVersion;
 
@@ -737,7 +737,7 @@ public string FullPath
 
         /// <summary>
         /// Whether ReevaluateIfNecessary is temporarily disabled.
-        /// This is useful when the host expects to make a number of reads and writes 
+        /// This is useful when the host expects to make a number of reads and writes
         /// to the project, and wants to temporarily sacrifice correctness for performance.
         /// </summary>
         public bool SkipEvaluation
@@ -767,10 +767,10 @@ public bool DisableMarkDirty
         /// control which projects it allows to run targets/tasks.  By default, for a newly
         /// created project, we will use whatever setting is in the parent project collection.
         /// When build is disabled, the Build method on this class will fail. However if
-        /// the host has already created a ProjectInstance, it can still build it. (It is 
+        /// the host has already created a ProjectInstance, it can still build it. (It is
         /// free to put a similar check around where it does this.)
         /// </summary>
-        public bool IsBuildEnabled 
+        public bool IsBuildEnabled
         {
             [DebuggerStepThrough]
             get => implementation.IsBuildEnabled;
@@ -794,19 +794,19 @@ public bool IsBuildEnabled
         /// The ID of the last evaluation for this Project.
         /// A project is always evaluated upon construction and can subsequently get evaluated multiple times via
         /// <see cref="Project.ReevaluateIfNecessary()" />
-        /// 
+        ///
         /// It is an arbitrary number that changes when this project reevaluates.
         /// Hosts don't know whether an evaluation actually happened in an interval, but they can compare this number to
         /// their previously stored value to find out, and if so perhaps decide to update their own state.
         /// Note that the number may not increase monotonically.
-        /// 
+        ///
         /// This number corresponds to the <seealso cref="BuildEventContext.EvaluationId"/> and can be used to connect
         /// evaluation logging events back to the Project instance.
         /// </summary>
         public int LastEvaluationId => implementation.LastEvaluationId;
 
         /// <summary>
-        /// List of names of the properties that, while global, are still treated as overridable 
+        /// List of names of the properties that, while global, are still treated as overridable
         /// </summary>
         internal ISet<string> GlobalPropertiesToTreatAsLocal => implementationInternal.GlobalPropertiesToTreatAsLocal;
 
@@ -840,21 +840,21 @@ public static string GetEvaluatedItemIncludeEscaped(ProjectItemDefinition item)
         /// Finds all the globs specified in item includes.
         /// </summary>
         /// <example>
-        /// 
+        ///
         /// <code>
         ///<P>*.txt</P>
-        /// 
+        ///
         ///<Bar Include="bar"/> (both outside and inside project cone)
         ///<Zar Include="C:\**\*.foo"/> (both outside and inside project cone)
         ///<Foo Include="*.a;*.b" Exclude="3.a"/>
         ///<Foo Remove="2.a" />
         ///<Foo Include="**\*.b" Exclude="1.b;**\obj\*.b;**\bar\*.b"/>
-        ///<Foo Include="$(P)"/> 
+        ///<Foo Include="$(P)"/>
         ///<Foo Include="*.a;@(Bar);3.a"/> (If Bar has globs, they will have been included when querying Bar ProjectItems for globs)
         ///<Foo Include="*.cs" Exclude="@(Bar)"/>
         ///</code>
-        /// 
-        ///Example result: 
+        ///
+        ///Example result:
         ///[
         ///GlobResult(glob: "C:\**\*.foo", exclude: []),
         ///GlobResult(glob: ["*.a", "*.b"], exclude=["3.a"], remove=["2.a"]),
@@ -867,13 +867,13 @@ public static string GetEvaluatedItemIncludeEscaped(ProjectItemDefinition item)
         /// <remarks>
         /// <see cref="GlobResult.MsBuildGlob"/> is a <see cref="IMSBuildGlob"/> that combines all globs in the include element and ignores
         /// all the fragments in the exclude attribute and all the fragments in all Remove elements that apply to the include element.
-        /// 
+        ///
         /// Users can construct a composite glob that incorporates all the globs in the Project:
         /// <code>
         /// var uberGlob = new CompositeGlob(project.GetAllGlobs().Select(r => r.MSBuildGlob).ToArray());
         /// uberGlob.IsMatch("foo.cs");
         /// </code>
-        /// 
+        ///
         /// </remarks>
         /// <returns>
         /// List of <see cref="GlobResult"/>.
@@ -907,6 +907,7 @@ public List<GlobResult> GetAllGlobs(string itemType)
         /// <summary>
         /// See <see cref="GetAllGlobs(string)"/>
         /// </summary>
+        /// <param name="itemType">type of the item</param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
         ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -922,7 +923,7 @@ public List<GlobResult> GetAllGlobs(string itemType, EvaluationContext evaluatio
         /// - elements that would update the string (not yet implemented)
         /// - elements that would remove the string (not yet implemented)
         /// </summary>
-        /// 
+        ///
         /// <example>
         /// The following snippet shows what <c>GetItemProvenance("a.cs")</c> returns for various item elements
         /// <code>
@@ -935,28 +936,28 @@ public List<GlobResult> GetAllGlobs(string itemType, EvaluationContext evaluatio
         ///     <P>a.cs;*.cs;@(A)</P>
         /// </PropertyGroup>
         /// </code>
-        /// 
+        ///
         /// </example>
-        /// 
+        ///
         /// <remarks>
         /// This method and its overloads are useful for clients that need to inspect all the item elements
         /// that might refer to a specific item instance. For example, Visual Studio uses it to inspect
         /// projects with globs. Upon a file system or IDE file artifact change, VS calls this method to find all the items
         /// that might refer to the detected file change (e.g. 'which item elements refer to "Program.cs"?').
         /// It uses such information to know which elements it should edit to reflect the user or file system changes.
-        /// 
+        ///
         /// Literal string matching tries to first match the strings. If the check fails, it then tries to match
         /// the strings as if they represented files: it normalizes both strings as files relative to the current project directory
         ///
         /// GetItemProvenance suffers from some sources of inaccuracy:
         /// - it is performed after evaluation, thus is insensitive to item data flow when item references are present
         /// (it sees items as they are at the end of evaluation)
-        /// 
+        ///
         /// This API and its return types are prone to change.
         /// </remarks>
-        /// 
+        ///
         /// <param name="itemToMatch">The string to perform matching against</param>
-        /// 
+        ///
         /// <returns>
         /// A list of <see cref="ProvenanceResult"/>, sorted in project evaluation order.
         /// </returns>
@@ -968,6 +969,7 @@ public List<ProvenanceResult> GetItemProvenance(string itemToMatch)
         /// <summary>
         /// See <see cref="GetItemProvenance(string)"/>
         /// </summary>
+        /// <param name="itemToMatch">The string to perform matching against</param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
         ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -990,6 +992,8 @@ public List<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemT
         /// <summary>
         /// See <see cref="GetItemProvenance(string, string)"/>
         /// </summary>
+        /// <param name="itemToMatch">The string to perform matching against</param>
+        /// <param name="itemType">The type of the item to perform matching against</param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
         ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -1002,7 +1006,7 @@ public List<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemT
         /// <summary>
         /// Overload of <see cref="GetItemProvenance(string)"/>
         /// </summary>
-        /// <param name="item"> 
+        /// <param name="item">
         /// The ProjectItem object that indicates: the itemspec to match and the item type to constrain the search in.
         /// The search is also constrained on item elements appearing before the item element that produced this <paramref name="item"/>.
         /// The element that produced this <paramref name="item"/> is included in the results.
@@ -1015,6 +1019,11 @@ public List<ProvenanceResult> GetItemProvenance(ProjectItem item)
         /// <summary>
         /// See <see cref="GetItemProvenance(ProjectItem)"/>
         /// </summary>
+        /// <param name="item">
+        /// The ProjectItem object that indicates: the itemspec to match and the item type to constrain the search in.
+        /// The search is also constrained on item elements appearing before the item element that produced this <paramref name="item"/>.
+        /// The element that produced this <paramref name="item"/> is included in the results.
+        /// </param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
         ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -1025,7 +1034,7 @@ public List<ProvenanceResult> GetItemProvenance(ProjectItem item, EvaluationCont
         }
 
         /// <summary>
-        /// Gets the escaped value of the provided metadatum. 
+        /// Gets the escaped value of the provided metadatum.
         /// </summary>
         public static string GetMetadataValueEscaped(ProjectMetadata metadatum)
         {
@@ -1035,7 +1044,7 @@ public static string GetMetadataValueEscaped(ProjectMetadata metadatum)
         }
 
         /// <summary>
-        /// Gets the escaped value of the metadatum with the provided name on the provided item. 
+        /// Gets the escaped value of the metadatum with the provided name on the provided item.
         /// </summary>
         [SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "IItem is an internal interface; this is less confusing to outside customers. ")]
         public static string GetMetadataValueEscaped(ProjectItem item, string name)
@@ -1046,7 +1055,7 @@ public static string GetMetadataValueEscaped(ProjectItem item, string name)
         }
 
         /// <summary>
-        /// Gets the escaped value of the metadatum with the provided name on the provided item definition. 
+        /// Gets the escaped value of the metadatum with the provided name on the provided item definition.
         /// </summary>
         public static string GetMetadataValueEscaped(ProjectItemDefinition item, string name)
         {
@@ -1068,7 +1077,7 @@ public static string GetPropertyValueEscaped(ProjectProperty property)
 
         /// <summary>
         /// Returns an iterator over the "logical project". The logical project is defined as
-        /// the unevaluated project obtained from the single MSBuild file that is the result 
+        /// the unevaluated project obtained from the single MSBuild file that is the result
         /// of inlining the text of all imports of the original MSBuild project manifest file.
         /// </summary>
         public IEnumerable<ProjectElement> GetLogicalProject()
@@ -1087,7 +1096,7 @@ public ProjectProperty GetProperty(string name)
         }
 
         /// <summary>
-        /// Get the unescaped value of a property in this project, or 
+        /// Get the unescaped value of a property in this project, or
         /// an empty string if it does not exist.
         /// </summary>
         /// <remarks>
@@ -1196,7 +1205,7 @@ public IList<ProjectItem> AddItemFast(string itemType, string unevaluatedInclude
         /// Use AddItem or RemoveItem to modify items in this project.
         /// </summary>
         /// <comments>
-        /// data.GetItems returns a read-only collection, so no need to re-wrap it here. 
+        /// data.GetItems returns a read-only collection, so no need to re-wrap it here.
         /// </comments>
         public ICollection<ProjectItem> GetItems(string itemType)
         {
@@ -1209,7 +1218,7 @@ public ICollection<ProjectItem> GetItems(string itemType)
         /// This is a read-only list: use AddItem or RemoveItem to modify items in this project.
         /// </summary>
         /// <comments>
-        /// ItemDictionary[] returns a read only collection, so no need to wrap it. 
+        /// ItemDictionary[] returns a read only collection, so no need to wrap it.
         /// </comments>
         public ICollection<ProjectItem> GetItemsIgnoringCondition(string itemType)
         {
@@ -1309,6 +1318,7 @@ public string ExpandString(string unexpandedValue)
         /// This instance can be used to build independently.
         /// Before creating the instance, this will reevaluate the project if necessary, so it will not be dirty.
         /// </summary>
+        /// <returns>the created project instance</returns>
         public ProjectInstance CreateProjectInstance()
         {
             return CreateProjectInstance(ProjectInstanceSettings.None, null);
@@ -1318,9 +1328,11 @@ public ProjectInstance CreateProjectInstance()
         /// Returns an instance based on this project, but completely disconnected.
         /// This instance can be used to build independently.
         /// Before creating the instance, this will reevaluate the project if necessary, so it will not be dirty.
-        /// The instance is immutable; none of the objects that form it can be modified. This makes it safe to 
+        /// The instance is immutable; none of the objects that form it can be modified. This makes it safe to
         /// access concurrently from multiple threads.
         /// </summary>
+        /// <param name="settings">The project instance creation settings</param>
+        /// <returns>the created project instance</returns>
         public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings)
         {
             return CreateProjectInstance(settings, null);
@@ -1329,8 +1341,9 @@ public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings)
         /// <summary>
         /// See <see cref="CreateProjectInstance(ProjectInstanceSettings)"/>
         /// </summary>
+        /// <param name="settings">The project instance creation settings</param>
         /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
-        /// <returns></returns>
+        /// <returns>the created project instance</returns>
         public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings, EvaluationContext evaluationContext)
         {
             return implementation.CreateProjectInstance(settings, evaluationContext);
@@ -1414,7 +1427,7 @@ public void Save(TextWriter writer)
         }
 
         /// <summary>
-        /// Saves a "logical" or "preprocessed" project file, that includes all the imported 
+        /// Saves a "logical" or "preprocessed" project file, that includes all the imported
         /// files as if they formed a single file.
         /// </summary>
         public void SaveLogicalProject(TextWriter writer)
@@ -1551,6 +1564,9 @@ public bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<Fo
         /// <summary>
         /// See <see cref="Build(string[], IEnumerable&lt;ILogger&gt;, IEnumerable&lt;ForwardingLoggerRecord&gt;)"/>
         /// </summary>
+        /// <param name="targets"></param>
+        /// <param name="loggers"></param>
+        /// <param name="remoteLoggers"></param>
         /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
         public bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers, EvaluationContext evaluationContext)
         {
@@ -1576,10 +1592,10 @@ internal bool UsesProjectRootElement(ProjectRootElement xmlRootElement)
         /// A ProjectItemElement could have resulted in several items if it contains wildcards or item or property expressions.
         /// Before any edit to a ProjectItem (remove, rename, set metadata, or remove metadata) this must be called to make
         /// sure that the edit does not affect any other ProjectItems originating in the same ProjectItemElement.
-        /// 
+        ///
         /// For example, an item xml with an include of "@(x)" could evaluate to items "a", "b", and "c". If "b" is removed, then the original
         /// item xml must be removed and replaced with three, then the one corresponding to "b" can be removed.
-        /// 
+        ///
         /// This is an unsophisticated approach; the best that can be said is that the result will likely be correct, if not ideal.
         /// For example, perhaps the user would rather remove the item from the original list "x" instead of expanding the list.
         /// Or, perhaps the user would rather the property in "$(p)\a;$(p)\b" not be expanded when "$(p)\b" is removed.
@@ -1622,7 +1638,7 @@ internal bool ItemElementRequiresSplitting(ProjectItemElement itemElement)
         }
 
         /// <summary>
-        /// Examines the provided ProjectItemElement to see if it has a wildcard that would match the 
+        /// Examines the provided ProjectItemElement to see if it has a wildcard that would match the
         /// item we wish to add, and does not have a condition or an exclude.
         /// Works conservatively - if there is anything that might cause doubt, considers the candidate to not be suitable.
         /// Returns true if it is suitable, otherwise false.
@@ -1637,7 +1653,7 @@ internal bool IsSuitableExistingItemXml(ProjectItemElement candidateExistingItem
 
         /// <summary>
         /// Before an item changes its item type, it must be removed from
-        /// our datastructures, which key off item type. 
+        /// our datastructures, which key off item type.
         /// This should be called ONLY by ProjectItems, in this situation.
         /// </summary>
         internal void RemoveItemBeforeItemTypeChange(ProjectItem item)
@@ -1718,7 +1734,7 @@ internal void VerifyThrowInvalidOperationNotZombie()
         /// <summary>
         /// Verify that the provided object location is in the same file as the project.
         /// If it is not, throws an InvalidOperationException indicating that imported evaluated objects should not be modified.
-        /// This prevents, for example, accidentally updating something like the OutputPath property, that you want be in the 
+        /// This prevents, for example, accidentally updating something like the OutputPath property, that you want be in the
         /// main project, but for some reason was actually read in from an imported targets file.
         /// </summary>
         internal void VerifyThrowInvalidOperationNotImported(ProjectRootElement otherXml)
@@ -1727,11 +1743,9 @@ internal void VerifyThrowInvalidOperationNotImported(ProjectRootElement otherXml
             ErrorUtilities.VerifyThrowInvalidOperation(ReferenceEquals(Xml, otherXml), "OM_CannotModifyEvaluatedObjectInImportedFile", otherXml.Location.File);
         }
 
-
         /// <summary>
         /// Internal project evaluation implementation
         /// </summary>
-        /// <remarks>
         private class ProjectImpl : ProjectLink, IProjectLinkInternal
         {
             /// <summary>
@@ -1783,14 +1797,13 @@ private class ProjectImpl : ProjectLink, IProjectLinkInternal
             private RenameHandlerDelegate _renameHandler;
 
             /// <summary>
-            /// 
+            ///
             /// </summary>
             /// <param name="owner">The owning project object</param>
             /// <param name="xml">ProjectRootElement to use</param>
             /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
             /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
             /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
-            /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
             /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
             /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
             public ProjectImpl(Project owner, ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
@@ -1815,7 +1828,6 @@ public ProjectImpl(Project owner, ProjectRootElement xml, IDictionary<string, st
             /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
             /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
             /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
-            /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
             /// <param name="loadSettings">The load settings for this project.</param>
             /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
             public ProjectImpl(Project owner, XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
@@ -1839,7 +1851,7 @@ public ProjectImpl(Project owner, XmlReader xmlReader, IDictionary<string, strin
             }
 
             /// <summary>
-            /// Construct over an existing project file, evaluating with the specified global properties and 
+            /// Construct over an existing project file, evaluating with the specified global properties and
             /// using the tools version provided, either or both of which may be null.
             /// Project is added to the global project collection.
             /// Throws InvalidProjectFileException if the evaluation fails.
@@ -1851,7 +1863,6 @@ public ProjectImpl(Project owner, XmlReader xmlReader, IDictionary<string, strin
             /// <param name="globalProperties">The global properties. May be null.</param>
             /// <param name="toolsVersion">The tools version. May be null.</param>
             /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
-            /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
             /// <param name="loadSettings">The load settings for this project.</param>
             /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
             public ProjectImpl(Project owner, string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
@@ -1904,9 +1915,9 @@ public ProjectImpl(Project owner, string projectFile, IDictionary<string, string
             /// - <see cref="ProjectItem.RemoveMetadata"/>
             /// - <see cref="ProjectItem.SetMetadataValue(string,string)"/>
             /// - <see cref="ProjectItem.SetMetadataValue(string,string, bool)"/>
-            /// 
+            ///
             /// When this property is set to true, the previous item operations throw an <exception cref="InvalidOperationException"></exception>
-            /// instead of expanding the item element. 
+            /// instead of expanding the item element.
             /// </summary>
             public override bool ThrowInsteadOfSplittingItemElement { get; set; }
 
@@ -1955,7 +1966,7 @@ public bool IsZombified
             /// <summary>
             /// Whether this project is dirty such that it needs reevaluation.
             /// This may be because its underlying XML has changed (either through this project or another)
-            /// either the XML of the main project or an imported file; 
+            /// either the XML of the main project or an imported file;
             /// or because its toolset may have changed.
             /// </summary>
             public override bool IsDirty
@@ -2005,7 +2016,7 @@ public override bool IsDirty
 
                                 if (reason != null)
                                 {
-                                    Trace.WriteLine(String.Format(CultureInfo.InvariantCulture, "MSBUILD: Is dirty because {0} [{1} - {2}] [PC Hash {3}]", reason, FullPath, (import.ImportedProject.FullPath == FullPath ? String.Empty : import.ImportedProject.FullPath), ProjectCollection.GetHashCode()));
+                                    Trace.WriteLine(String.Format(CultureInfo.InvariantCulture, "MSBUILD: Is dirty because {0} [{1} - {2}] [PC Hash {3}]", reason, FullPath, import.ImportedProject.FullPath == FullPath ? String.Empty : import.ImportedProject.FullPath, ProjectCollection.GetHashCode()));
                                 }
                             }
 
@@ -2023,8 +2034,8 @@ public override bool IsDirty
             /// </summary>
             /// <remarks>
             /// This is the publicly exposed getter, that translates into a read-only dead IDictionary&lt;string, string&gt;.
-            /// 
-            /// In order to easily tell when we're dirtied, setting and removing global properties is done with 
+            ///
+            /// In order to easily tell when we're dirtied, setting and removing global properties is done with
             /// <see cref="SetGlobalProperty">SetGlobalProperty</see> and <see cref="RemoveGlobalProperty">RemoveGlobalProperty</see>.
             /// </remarks>
             public override IDictionary<string, string> GlobalProperties
@@ -2052,7 +2063,7 @@ public override IDictionary<string, string> GlobalProperties
             /// This is an ordered collection.
             /// </summary>
             /// <comments>
-            /// data.ItemTypes is a KeyCollection, so it doesn't need any 
+            /// data.ItemTypes is a KeyCollection, so it doesn't need any
             /// additional read-only protection
             /// </comments>
             public override ICollection<string> ItemTypes => _data.ItemTypes;
@@ -2066,17 +2077,17 @@ public override IDictionary<string, string> GlobalProperties
             /// <summary>
             /// Collection of possible values implied for properties contained in the conditions found on properties,
             /// property groups, imports, and whens.
-            /// 
+            ///
             /// For example, if the following conditions existed on properties in a project:
-            /// 
+            ///
             /// Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'"
             /// Condition="'$(Configuration)' == 'Release'"
-            /// 
+            ///
             /// the table would be populated with
-            /// 
+            ///
             /// { "Configuration", { "Debug", "Release" }}
             /// { "Platform", { "x86" }}
-            /// 
+            ///
             /// This is used by Visual Studio to determine the configurations defined in the project.
             /// </summary>
             public override IDictionary<string, List<string>> ConditionedProperties
@@ -2109,7 +2120,7 @@ public override IDictionary<string, List<string>> ConditionedProperties
             /// Items in this project, ordered within groups of item types,
             /// including items whose conditions evaluated to false, or that were
             /// contained within item groups who themselves had conditioned evaluated to false.
-            /// This is useful for hosts that wish to display all items, even if they might not be part 
+            /// This is useful for hosts that wish to display all items, even if they might not be part
             /// of the build in the current configuration.
             /// </summary>
             [SuppressMessage("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods", Justification = "This is a reasonable choice. API review approved")]
@@ -2200,7 +2211,7 @@ public override IDictionary<string, ProjectTargetInstance> Targets
             /// <summary>
             /// Properties encountered during evaluation. These are read during the first evaluation pass.
             /// Unlike those returned by the Properties property, these are ordered, and includes any properties that
-            /// were subsequently overridden by others with the same name. It does not include any 
+            /// were subsequently overridden by others with the same name. It does not include any
             /// properties whose conditions did not evaluate to true.
             /// It does not include any properties added since the last evaluation.
             /// </summary>
@@ -2222,7 +2233,7 @@ public override ICollection<ProjectProperty> AllEvaluatedProperties
             /// <summary>
             /// Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
             /// Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
-            /// were subsequently overridden by others with the same name and item type. It does not include any 
+            /// were subsequently overridden by others with the same name and item type. It does not include any
             /// elements whose conditions did not evaluate to true.
             /// It does not include any item definition metadata added since the last evaluation.
             /// </summary>
@@ -2243,7 +2254,7 @@ public override ICollection<ProjectMetadata> AllEvaluatedItemDefinitionMetadata
 
             /// <summary>
             /// Items encountered during evaluation. These are read during the third evaluation pass.
-            /// Unlike those returned by the Items property, these are ordered with respect to all other items 
+            /// Unlike those returned by the Items property, these are ordered with respect to all other items
             /// encountered during evaluation, not just ordered with respect to items of the same item type.
             /// In some applications, like the F# language, this complete mutual ordering is significant, and such hosts
             /// can use this property.
@@ -2279,7 +2290,7 @@ public override ICollection<ProjectItem> AllEvaluatedItems
 
             /// <summary>
             /// The sub-toolset version that, combined with the ToolsVersion, was used to determine
-            /// the toolset properties for this project.  
+            /// the toolset properties for this project.
             /// </summary>
             public override string SubToolsetVersion => _data.SubToolsetVersion;
 
@@ -2304,7 +2315,7 @@ public string FullPath
 
             /// <summary>
             /// Whether ReevaluateIfNecessary is temporarily disabled.
-            /// This is useful when the host expects to make a number of reads and writes 
+            /// This is useful when the host expects to make a number of reads and writes
             /// to the project, and wants to temporarily sacrifice correctness for performance.
             /// </summary>
             public override bool SkipEvaluation { get; set; }
@@ -2322,7 +2333,7 @@ public string FullPath
             /// control which projects it allows to run targets/tasks.  By default, for a newly
             /// created project, we will use whatever setting is in the parent project collection.
             /// When build is disabled, the Build method on this class will fail. However if
-            /// the host has already created a ProjectInstance, it can still build it. (It is 
+            /// the host has already created a ProjectInstance, it can still build it. (It is
             /// free to put a similar check around where it does this.)
             /// </summary>
             public override bool IsBuildEnabled
@@ -2365,19 +2376,19 @@ public override bool IsBuildEnabled
             /// The ID of the last evaluation for this Project.
             /// A project is always evaluated upon construction and can subsequently get evaluated multiple times via
             /// <see cref="ProjectLink.ReevaluateIfNecessary" />
-            /// 
+            ///
             /// It is an arbitrary number that changes when this project reevaluates.
             /// Hosts don't know whether an evaluation actually happened in an interval, but they can compare this number to
             /// their previously stored value to find out, and if so perhaps decide to update their own state.
             /// Note that the number may not increase monotonically.
-            /// 
+            ///
             /// This number corresponds to the <seealso cref="BuildEventContext.EvaluationId"/> and can be used to connect
             /// evaluation logging events back to the Project instance.
             /// </summary>
             public override int LastEvaluationId => _data.EvaluationId;
 
             /// <summary>
-            /// List of names of the properties that, while global, are still treated as overridable 
+            /// List of names of the properties that, while global, are still treated as overridable
             /// </summary>
             public ISet<string> GlobalPropertiesToTreatAsLocal => _data.GlobalPropertiesToTreatAsLocal;
 
@@ -2386,7 +2397,6 @@ public override bool IsBuildEnabled
             /// </summary>
             internal ILoggingService LoggingService => ProjectCollection.LoggingService;
 
-
             /// <summary>
             /// See <see cref="ProjectLink.GetAllGlobs(EvaluationContext)"/>
             /// </summary>
@@ -2402,6 +2412,7 @@ public override List<GlobResult> GetAllGlobs(EvaluationContext evaluationContext
             /// <summary>
             /// See <see cref="ProjectLink.GetAllGlobs(string, EvaluationContext)"/>
             /// </summary>
+            /// <param name="itemType">The type of items to return.</param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
             ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -2582,6 +2593,7 @@ private void CacheInformationFromRemoveItem(ProjectItemElement itemElement, Dict
             /// <summary>
             /// See <see cref="ProjectLink.GetItemProvenance(string, EvaluationContext)"/>
             /// </summary>
+            /// <param name="itemToMatch">The string to perform matching against</param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
             ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -2594,6 +2606,8 @@ public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, Eva
             /// <summary>
             /// See <see cref="ProjectLink.GetItemProvenance(string, string, EvaluationContext)"/>
             /// </summary>
+            /// <param name="itemToMatch">The string to perform matching against</param>
+            /// <param name="itemType">The type of items to return.</param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
             ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -2606,6 +2620,11 @@ public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, str
             /// <summary>
             /// See <see cref="ProjectLink.GetItemProvenance(ProjectItem, EvaluationContext)"/>
             /// </summary>
+            /// /// <param name="item"> 
+            /// The ProjectItem object that indicates: the itemspec to match and the item type to constrain the search in.
+            /// The search is also constrained on item elements appearing before the item element that produced this <paramref name="item"/>.
+            /// The element that produced this <paramref name="item"/> is included in the results.
+            /// </param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
             ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -2626,7 +2645,7 @@ public override List<ProvenanceResult> GetItemProvenance(ProjectItem item, Evalu
             /// Some project APIs need to do analysis that requires the Evaluator to record more data than usual as it evaluates.
             /// This method checks if the Evaluator was run with the extra required settings and if not, does a re-evaluation.
             /// If a re-evaluation was necessary, it saves this information so a next call does not re-evaluate.
-            /// 
+            ///
             /// Using this method avoids storing extra data in memory when its not needed.
             /// </summary>
             /// <param name="evaluationContext"></param>
@@ -2634,7 +2653,7 @@ private List<ProjectItemElement> GetEvaluatedItemElements(EvaluationContext eval
             {
                 if (!_loadSettings.HasFlag(ProjectLoadSettings.RecordEvaluatedItemElements))
                 {
-                    _loadSettings = _loadSettings | ProjectLoadSettings.RecordEvaluatedItemElements;
+                    _loadSettings |= ProjectLoadSettings.RecordEvaluatedItemElements;
                     Reevaluate(LoggingService, _loadSettings, evaluationContext);
                 }
 
@@ -2646,7 +2665,7 @@ private static IEnumerable<ProjectItemElement> GetItemElementsThatMightAffectIte
                 IEnumerable<ProjectItemElement> relevantElementsAfterInclude = evaluatedItemElements
                     // Skip until we encounter the element that produced the item because
                     // there are no item operations that can affect future items
-                    .SkipWhile((i => i != item.Xml))
+                    .SkipWhile(i => i != item.Xml)
                     .Where(itemElement =>
                         // items operations of different item types cannot affect each other
                         itemElement.ItemType.Equals(item.ItemType) &&
@@ -2681,75 +2700,25 @@ private List<ProvenanceResult> GetItemProvenance(string itemToMatch, IEnumerable
                     .ToList();
             }
 
+            // TODO: cache result?
             private ProvenanceResult ComputeProvenanceResult(string itemToMatch, ProjectItemElement itemElement)
             {
                 ProvenanceResult SingleItemSpecProvenance(string itemSpec, IElementLocation elementLocation, Operation operation)
                 {
-                    if (elementLocation == null)
-                    {
-                        return null;
-                    }
-
-                    var matchOccurrences = ItemMatchesInItemSpecString(itemToMatch, itemSpec, elementLocation, itemElement.ContainingProject.DirectoryPath, _data.Expander, out Provenance provenance);
-                    if (matchOccurrences > 0)
+                    if (elementLocation != null && !string.IsNullOrEmpty(itemSpec))
                     {
-                        return new ProvenanceResult(itemElement, operation, provenance, matchOccurrences);
+                        EvaluationItemSpec expandedItemSpec = new EvaluationItemSpec(itemSpec, _data.Expander, elementLocation, itemElement.ContainingProject.DirectoryPath, expandProperties: true);
+                        int matchOccurrences = ItemMatchesInItemSpec(itemToMatch, expandedItemSpec, out Provenance provenance);
+                        return matchOccurrences > 0 ? new ProvenanceResult(itemElement, operation, provenance, matchOccurrences) : null;
                     }
 
                     return null;
                 }
 
-                var includeResult = SingleItemSpecProvenance(itemElement.Include, itemElement.IncludeLocation, Operation.Include);
-                if (includeResult != null)
-                {
-                    var excludeResult = SingleItemSpecProvenance(itemElement.Exclude, itemElement.ExcludeLocation, Operation.Exclude);
-                    if (excludeResult != null)
-                    {
-                        return excludeResult;
-                    }
-
-                    if (includeResult != null)
-                    {
-                        return includeResult;
-                    }
-                }
-
-                var result = SingleItemSpecProvenance(itemElement.Update, itemElement.UpdateLocation, Operation.Update);
-                if (result != null)
-                {
-                    return result;
-                }
-
-                result = SingleItemSpecProvenance(itemElement.Remove, itemElement.RemoveLocation, Operation.Remove);
-                return result;
-            }
-
-            /// <summary>
-            /// Since:
-            ///     - we have no proper AST and interpreter for itemspecs that we can do analysis on
-            ///     - GetItemProvenance needs to have correct counts for exclude strings (as correct as it can get while doing it after evaluation)
-            /// 
-            /// The temporary hack is to use the expander to expand the strings, and if any property or item references were encountered, return Provenance.Inconclusive
-            /// </summary>
-            private static int ItemMatchesInItemSpecString(string itemToMatch, string itemSpec, IElementLocation elementLocation, string projectDirectory, Expander<ProjectProperty, ProjectItem> expander, out Provenance provenance)
-            {
-                if (string.IsNullOrEmpty(itemSpec))
-                {
-                    provenance = Provenance.Undefined;
-                    return 0;
-                }
-
-                // expand the properties
-                var expandedItemSpec = new EvaluationItemSpec(itemSpec, expander, elementLocation, projectDirectory, expandProperties: true);
-                var numberOfMatches = ItemMatchesInItemSpec(itemToMatch, expandedItemSpec, out provenance);
-
-                // Result is inconclusive if properties are present
-                if (itemSpec.Contains("$("))
-                {
-                    provenance |= Provenance.Inconclusive;
-                }
-
-                return numberOfMatches;
+                ProvenanceResult result = SingleItemSpecProvenance(itemElement.Include, itemElement.IncludeLocation, Operation.Include);
+                return result == null ?
+                    SingleItemSpecProvenance(itemElement.Update, itemElement.UpdateLocation, Operation.Update) ?? SingleItemSpecProvenance(itemElement.Remove, itemElement.RemoveLocation, Operation.Remove) :
+                    SingleItemSpecProvenance(itemElement.Exclude, itemElement.ExcludeLocation, Operation.Exclude) ?? result;
             }
 
             private static int ItemMatchesInItemSpec(string itemToMatch, EvaluationItemSpec itemSpec, out Provenance provenance)
@@ -2775,6 +2744,12 @@ private static int ItemMatchesInItemSpec(string itemToMatch, EvaluationItemSpec
                     {
                         ErrorUtilities.ThrowInternalErrorUnreachable();
                     }
+
+                    // Result is inconclusive if properties are present
+                    if (itemSpec.ItemSpecString.Contains("$("))
+                    {
+                        provenance |= Provenance.Inconclusive;
+                    }
                 }
 
                 return occurrences;
@@ -2782,7 +2757,7 @@ private static int ItemMatchesInItemSpec(string itemToMatch, EvaluationItemSpec
 
             /// <summary>
             /// Returns an iterator over the "logical project". The logical project is defined as
-            /// the unevaluated project obtained from the single MSBuild file that is the result 
+            /// the unevaluated project obtained from the single MSBuild file that is the result
             /// of inlining the text of all imports of the original MSBuild project manifest file.
             /// </summary>
             public override IEnumerable<ProjectElement> GetLogicalProject()
@@ -2824,7 +2799,7 @@ public override ProjectProperty GetProperty(string name)
             }
 
             /// <summary>
-            /// Get the unescaped value of a property in this project, or 
+            /// Get the unescaped value of a property in this project, or
             /// an empty string if it does not exist.
             /// </summary>
             /// <remarks>
@@ -2859,12 +2834,11 @@ public override ProjectProperty SetProperty(string name, string unevaluatedValue
 
                 ProjectProperty property = _data.Properties[name];
 
-                ErrorUtilities.VerifyThrowInvalidOperation(property == null || !property.IsReservedProperty, "OM_ReservedName", name);
-                ErrorUtilities.VerifyThrowInvalidOperation(property == null || !property.IsGlobalProperty, "OM_GlobalProperty", name);
+                ErrorUtilities.VerifyThrowInvalidOperation(property?.IsReservedProperty != true, "OM_ReservedName", name);
+                ErrorUtilities.VerifyThrowInvalidOperation(property?.IsGlobalProperty != true, "OM_GlobalProperty", name);
 
                 // If there's an existing regular property, we can reuse it, unless it's not attached to its XML any more
-                if (property != null &&
-                    !property.IsEnvironmentProperty &&
+                if (property?.IsEnvironmentProperty == false &&
                     property.Xml.Parent?.Parent != null &&
                     ReferenceEquals(property.Xml.ContainingProject, Xml))
                 {
@@ -3032,7 +3006,7 @@ public override IList<ProjectItem> AddItemFast(string itemType, string unevaluat
             /// Use AddItem or RemoveItem to modify items in this project.
             /// </summary>
             /// <comments>
-            /// data.GetItems returns a read-only collection, so no need to re-wrap it here. 
+            /// data.GetItems returns a read-only collection, so no need to re-wrap it here.
             /// </comments>
             public override ICollection<ProjectItem> GetItems(string itemType)
             {
@@ -3046,7 +3020,7 @@ public override ICollection<ProjectItem> GetItems(string itemType)
             /// This is a read-only list: use AddItem or RemoveItem to modify items in this project.
             /// </summary>
             /// <comments>
-            /// ItemDictionary[] returns a read only collection, so no need to wrap it. 
+            /// ItemDictionary[] returns a read only collection, so no need to wrap it.
             /// </comments>
             public override ICollection<ProjectItem> GetItemsIgnoringCondition(string itemType)
             {
@@ -3195,10 +3169,10 @@ public override string ExpandString(string unexpandedValue)
                 return result;
             }
 
-
             /// <summary>
             /// See <see cref="ProjectLink.CreateProjectInstance(ProjectInstanceSettings, EvaluationContext)"/>
             /// </summary>
+            /// <param name="settings">Project instance creation settings</param>
             /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
             /// <returns></returns>
             public override ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings, EvaluationContext evaluationContext)
@@ -3236,7 +3210,7 @@ public override void ReevaluateIfNecessary(EvaluationContext evaluationContext)
             }
 
             /// <summary>
-            /// Saves a "logical" or "preprocessed" project file, that includes all the imported 
+            /// Saves a "logical" or "preprocessed" project file, that includes all the imported
             /// files as if they formed a single file.
             /// </summary>
             public override void SaveLogicalProject(TextWriter writer)
@@ -3253,6 +3227,9 @@ public override void SaveLogicalProject(TextWriter writer)
             /// <summary>
             /// See <see cref="ProjectLink.Build"/>
             /// </summary>
+            /// <param name="targets">targets to build</param>
+            /// <param name="loggers">List of loggers</param>
+            /// <param name="remoteLoggers">remote loggers for multi proc logging</param>
             /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
             public override bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers, EvaluationContext evaluationContext)
             {
@@ -3303,10 +3280,10 @@ public bool UsesProjectRootElement(ProjectRootElement xmlRootElement)
             /// A ProjectItemElement could have resulted in several items if it contains wildcards or item or property expressions.
             /// Before any edit to a ProjectItem (remove, rename, set metadata, or remove metadata) this must be called to make
             /// sure that the edit does not affect any other ProjectItems originating in the same ProjectItemElement.
-            /// 
+            ///
             /// For example, an item xml with an include of "@(x)" could evaluate to items "a", "b", and "c". If "b" is removed, then the original
             /// item xml must be removed and replaced with three, then the one corresponding to "b" can be removed.
-            /// 
+            ///
             /// This is an unsophisticated approach; the best that can be said is that the result will likely be correct, if not ideal.
             /// For example, perhaps the user would rather remove the item from the original list "x" instead of expanding the list.
             /// Or, perhaps the user would rather the property in "$(p)\a;$(p)\b" not be expanded when "$(p)\b" is removed.
@@ -3349,7 +3326,7 @@ internal bool ItemElementRequiresSplitting(ProjectItemElement itemElement)
             }
 
             /// <summary>
-            /// Examines the provided ProjectItemElement to see if it has a wildcard that would match the 
+            /// Examines the provided ProjectItemElement to see if it has a wildcard that would match the
             /// item we wish to add, and does not have a condition or an exclude.
             /// Works conservatively - if there is anything that might cause doubt, considers the candidate to not be suitable.
             /// Returns true if it is suitable, otherwise false.
@@ -3364,7 +3341,7 @@ public bool IsSuitableExistingItemXml(ProjectItemElement candidateExistingItemXm
                     return false;
                 }
 
-                if ((metadata != null && metadata.Any()) || candidateExistingItemXml.Count > 0)
+                if ((metadata?.Any() == true) || candidateExistingItemXml.Count > 0)
                 {
                     // Don't try to make sure the metadata are the same.
                     return false;
@@ -3396,7 +3373,7 @@ public bool IsSuitableExistingItemXml(ProjectItemElement candidateExistingItemXm
 
             /// <summary>
             /// Before an item changes its item type, it must be removed from
-            /// our datastructures, which key off item type. 
+            /// our datastructures, which key off item type.
             /// This should be called ONLY by ProjectItems, in this situation.
             /// </summary>
             public void RemoveItemBeforeItemTypeChange(ProjectItem item)
@@ -3493,7 +3470,7 @@ public override void Unload()
             /// <summary>
             /// Verify that the provided object location is in the same file as the project.
             /// If it is not, throws an InvalidOperationException indicating that imported evaluated objects should not be modified.
-            /// This prevents, for example, accidentally updating something like the OutputPath property, that you want be in the 
+            /// This prevents, for example, accidentally updating something like the OutputPath property, that you want be in the
             /// main project, but for some reason was actually read in from an imported targets file.
             /// </summary>
             internal void VerifyThrowInvalidOperationNotImported(ProjectRootElement otherXml)
@@ -3605,7 +3582,7 @@ private void ReevaluateIfNecessary(
 
             /// <summary>
             /// Creates a project instance based on this project using the specified logging service.
-            /// </summary>  
+            /// </summary>
             private ProjectInstance CreateProjectInstance(
                 ILoggingService loggingServiceForEvaluation,
                 ProjectInstanceSettings settings,
@@ -3732,12 +3709,12 @@ private void ProjectRootElement_ProjectXmlChangedHandler(object sender, ProjectX
             /// <summary>
             /// Tries to find a ProjectItemElement already in the project file XML that has a wildcard that would match the
             /// item we wish to add, does not have a condition or an exclude, and is within an itemgroup without a condition.
-            /// 
+            ///
             /// For perf reasons, this method does several jobs in one.
             /// If it finds a suitable existing item element, it returns that as the out parameter, otherwise the out parameter returns null.
             /// Otherwise, if it finds an item element suitable to be just below our new element, it returns that.
             /// Otherwise, if it finds an item group at least that's suitable to put our element in somewhere, it returns that.
-            /// 
+            ///
             /// Returns null if the include of the item being added itself has wildcards, or semicolons, as the case is too difficult.
             /// </summary>
             private ProjectElement GetAnySuitableExistingItemXml(string itemType, string unevaluatedInclude, IEnumerable<KeyValuePair<string, string>> metadata, out ProjectItemElement suitableExistingItemXml)
@@ -3749,7 +3726,7 @@ private ProjectElement GetAnySuitableExistingItemXml(string itemType, string une
                     return null;
                 }
 
-                if (metadata != null && metadata.Any())
+                if (metadata?.Any() == true)
                 {
                     // Don't bother trying to match up metadata
                     return null;
@@ -3920,7 +3897,7 @@ internal class Data : IItemProvider<ProjectItem>, IPropertyProvider<ProjectPrope
             private static WeakReference<RetrievableEntryHashSet<ProjectTargetInstance>> s_typicalTargetsCollection;
 
             /// <summary>
-            /// List of names of the properties that, while global, are still treated as overridable 
+            /// List of names of the properties that, while global, are still treated as overridable
             /// </summary>
             private ISet<string> _globalPropertiesToTreatAsLocal;
 
@@ -3971,7 +3948,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             public PropertyDictionary<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary => this.Project.ProjectCollection.EnvironmentProperties;
 
             /// <summary>
-            /// List of names of the properties that, while global, are still treated as overridable 
+            /// List of names of the properties that, while global, are still treated as overridable
             /// </summary>
             public ISet<string> GlobalPropertiesToTreatAsLocal => _globalPropertiesToTreatAsLocal ?? (_globalPropertiesToTreatAsLocal =
                                                                       new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default));
@@ -4008,13 +3985,13 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
 
             /// <summary>
             /// The externally specified sub-toolset version that, combined with the ToolsVersion, is used to determine
-            /// the toolset properties for this project.  
+            /// the toolset properties for this project.
             /// </summary>
             public string ExplicitSubToolsetVersion { get; }
 
             /// <summary>
             /// The sub-toolset version that, combined with the ToolsVersion, was used to determine
-            /// the toolset properties for this project.  
+            /// the toolset properties for this project.
             /// </summary>
             public string SubToolsetVersion { get; private set; }
 
@@ -4044,17 +4021,17 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// <summary>
             /// Collection of possible values implied for properties contained in the conditions found on properties,
             /// property groups, imports, and whens.
-            /// 
+            ///
             /// For example, if the following conditions existed on properties in a project:
-            /// 
+            ///
             /// Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'"
             /// Condition="'$(Configuration)' == 'Release'"
-            /// 
+            ///
             /// the table would be populated with
-            /// 
+            ///
             /// { "Configuration", { "Debug", "Release" }}
             /// { "Platform", { "x86" }}
-            /// 
+            ///
             /// This is used by Visual Studio to determine the configurations defined in the project.
             /// </summary>
             public Dictionary<string, List<string>> ConditionedProperties { get; private set; }
@@ -4077,7 +4054,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// Read only collection.
             /// </summary>
             /// <comments>
-            /// item.ItemTypes is a KeyCollection, so it doesn't need any 
+            /// item.ItemTypes is a KeyCollection, so it doesn't need any
             /// additional read-only protection
             /// </comments>
             public ICollection<string> ItemTypes => Items.ItemTypes;
@@ -4085,7 +4062,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// <summary>
             /// Properties encountered during evaluation. These are read during the first evaluation pass.
             /// Unlike those returned by the Properties property, these are ordered, and includes any properties that
-            /// were subsequently overridden by others with the same name. It does not include any 
+            /// were subsequently overridden by others with the same name. It does not include any
             /// properties whose conditions did not evaluate to true.
             /// It does not include any properties added since the last evaluation.
             /// </summary>
@@ -4094,7 +4071,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// <summary>
             /// Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
             /// Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
-            /// were subsequently overridden by others with the same name and item type. It does not include any 
+            /// were subsequently overridden by others with the same name and item type. It does not include any
             /// elements whose conditions did not evaluate to true.
             /// It does not include any item definition metadata added since the last evaluation.
             /// </summary>
@@ -4287,7 +4264,7 @@ public void AddItemIgnoringCondition(ProjectItem item)
             /// <summary>
             /// Properties encountered during evaluation. These are read during the first evaluation pass.
             /// Unlike those returned by the Properties property, these are ordered, and includes any properties that
-            /// were subsequently overridden by others with the same name. It does not include any 
+            /// were subsequently overridden by others with the same name. It does not include any
             /// properties whose conditions did not evaluate to true.
             /// </summary>
             public void AddToAllEvaluatedPropertiesList(ProjectProperty property)
@@ -4299,7 +4276,7 @@ public void AddToAllEvaluatedPropertiesList(ProjectProperty property)
             /// <summary>
             /// Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
             /// Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
-            /// were subsequently overridden by others with the same name and item type. It does not include any 
+            /// were subsequently overridden by others with the same name and item type. It does not include any
             /// elements whose conditions did not evaluate to true.
             /// </summary>
             public void AddToAllEvaluatedItemDefinitionMetadataList(ProjectMetadata itemDefinitionMetadatum)
@@ -4392,7 +4369,7 @@ public void AddTarget(ProjectTargetInstance target)
             /// <remarks>
             /// This may include imported files that ended up contributing nothing to the evaluated project.
             /// These might otherwise have no strong references to them at all.
-            /// If they are dirtied, though, they might affect the evaluated project; and that's why we record them. 
+            /// If they are dirtied, though, they might affect the evaluated project; and that's why we record them.
             /// Mostly these will be common imports, so they'll be shared anyway.
             /// </remarks>
             public void RecordImport(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated, SdkResult sdkResult)
@@ -4518,7 +4495,7 @@ internal ICollection<ProjectItem> GetItemsByEvaluatedInclude(string evaluatedInc
             }
 
             /// <summary>
-            /// Get the value of a property in this project, or 
+            /// Get the value of a property in this project, or
             /// an empty string if it does not exist.
             /// Returns the unescaped value.
             /// </summary>
@@ -4593,7 +4570,7 @@ public GlobResult(ProjectItemElement itemElement, IEnumerable<string> includeGlo
     public enum Provenance
     {
         /// <summary>
-        /// Undefined is the bottom element and should not appear in actual results 
+        /// Undefined is the bottom element and should not appear in actual results
         /// </summary>
         Undefined = 0,
 
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index ac5a3ee5701..8869625cae4 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -208,7 +208,7 @@ public void Dispose()
 
         /// <summary>
         /// Whether reevaluation is temporarily disabled on projects in this collection.
-        /// This is useful when the host expects to make a number of reads and writes 
+        /// This is useful when the host expects to make a number of reads and writes
         /// to projects, and wants to temporarily sacrifice correctness for performance.
         /// </summary>
         private bool _skipEvaluation;
@@ -227,17 +227,7 @@ public void Dispose()
         private int _maxNodeCount;
 
         /// <summary>
-        /// Hook up last minute dumping of any exceptions bringing down the process
-        /// </summary>
-        static ProjectCollection()
-        {
-#if FEATURE_APPDOMAIN_UNHANDLED_EXCEPTION
-            AppDomain.CurrentDomain.UnhandledException += ExceptionHandling.UnhandledExceptionHandler;
-#endif
-        }
-
-        /// <summary>
-        /// Instantiates a project collection with no global properties or loggers that reads toolset 
+        /// Instantiates a project collection with no global properties or loggers that reads toolset
         /// information from the configuration file and registry.
         /// </summary>
         public ProjectCollection()
@@ -416,7 +406,7 @@ public ProjectCollection(IDictionary<string, string> globalProperties, IEnumerab
 
         /// <summary>
         /// Retrieves the global project collection object.
-        /// This is a singleton project collection with no global properties or loggers that reads toolset 
+        /// This is a singleton project collection with no global properties or loggers that reads toolset
         /// information from the configuration file and registry.
         /// May throw InvalidToolsetDefinitionException.
         /// Thread safe.
@@ -483,7 +473,6 @@ public static string DisplayVersion
                     s_assemblyDisplayVersion = plusIndex < 0
                                                     ? fullInformationalVersion
                                                     : fullInformationalVersion.Substring(startIndex: 0, length: plusIndex + 10);
-
                 }
 
                 return s_assemblyDisplayVersion;
@@ -493,7 +482,7 @@ public static string DisplayVersion
         /// <summary>
         /// The default tools version of this project collection. Projects use this tools version if they
         /// aren't otherwise told what tools version to use.
-        /// This value is gotten from the .exe.config file, or else in the registry, 
+        /// This value is gotten from the .exe.config file, or else in the registry,
         /// or if neither specify a default tools version then it is hard-coded to the tools version "2.0".
         /// Setter throws InvalidOperationException if a toolset with the provided tools version has not been defined.
         /// Always defined.
@@ -542,8 +531,8 @@ public string DefaultToolsVersion
         /// </summary>
         /// <remarks>
         /// This is the publicly exposed getter, that translates into a read-only dead IDictionary&lt;string, string&gt;.
-        /// 
-        /// To be consistent with Project, setting and removing global properties is done with 
+        ///
+        /// To be consistent with Project, setting and removing global properties is done with
         /// <see cref="SetGlobalProperty">SetGlobalProperty</see> and <see cref="RemoveGlobalProperty">RemoveGlobalProperty</see>.
         /// </remarks>
         public IDictionary<string, string> GlobalProperties
@@ -750,7 +739,7 @@ public HostServices HostServices
 
         /// <summary>
         /// Whether reevaluation is temporarily disabled on projects in this collection.
-        /// This is useful when the host expects to make a number of reads and writes 
+        /// This is useful when the host expects to make a number of reads and writes
         /// to projects, and wants to temporarily sacrifice correctness for performance.
         /// </summary>
         public bool SkipEvaluation
@@ -819,7 +808,6 @@ public bool DisableMarkDirty
             }
         }
 
-
         /// <summary>
         /// Global collection id.
         /// Can be used for external providers to optimize the cross-site link exchange
@@ -830,7 +818,6 @@ public bool DisableMarkDirty
         /// External project support.
         /// Establish a remote project link for this collection.
         /// </summary>
-
         internal ExternalProjectsProvider Link
         {
             get => _link;
@@ -862,7 +849,7 @@ internal PropertyDictionary<ProjectPropertyInstance> GlobalPropertiesCollection
             get
             {
                 var clone = new PropertyDictionary<ProjectPropertyInstance>();
-                
+
                 using (_locker.EnterUpgradeableReadLock())
                 {
                     foreach (ProjectPropertyInstance property in _globalProperties)
@@ -888,11 +875,11 @@ internal PropertyDictionary<ProjectPropertyInstance> EnvironmentProperties
                     // This is only done once, when the project collection is created. Any subsequent
                     // environment changes will be ignored. Child nodes will be passed this set
                     // of properties in their build parameters.
-                    if (null == _environmentProperties)
+                    if (_environmentProperties == null)
                     {
                         using (_locker.EnterWriteLock())
                         {
-                            if (null == _environmentProperties)
+                            if (_environmentProperties == null)
                             {
                                 _environmentProperties = Utilities.GetEnvironmentProperties();
                             }
@@ -975,7 +962,7 @@ public static string Unescape(string escapedString)
         }
 
         /// <summary>
-        /// Returns true if there is a toolset defined for the specified 
+        /// Returns true if there is a toolset defined for the specified
         /// tools version, otherwise false.
         /// </summary>
         public bool ContainsToolset(string toolsVersion) => GetToolset(toolsVersion) != null;
@@ -1055,7 +1042,7 @@ public Toolset GetToolset(string toolsVersion)
         }
 
         /// <summary>
-        /// Figure out what ToolsVersion to use to actually build the project with. 
+        /// Figure out what ToolsVersion to use to actually build the project with.
         /// </summary>
         /// <param name="explicitToolsVersion">The user-specified ToolsVersion (through e.g. /tv: on the command line). May be null</param>
         /// <param name="toolsVersionFromProject">The ToolsVersion from the project file. May be null</param>
@@ -1100,7 +1087,6 @@ internal ICollection<Project> GetLoadedProjects(bool includeExternal, string ful
             return loaded;
         }
 
-
         /// <summary>
         /// Loads a project with the specified filename, using the collection's global properties and tools version.
         /// If a matching project is already loaded, it will be returned, otherwise a new project will be loaded.
@@ -1766,8 +1752,8 @@ internal void ResetToolsetsForTests(ToolsetRegistryReader registryReaderForTests
 #endif
 
         /// <summary>
-        /// Populate Toolsets with a dictionary of (toolset version, Toolset) 
-        /// using information from the registry and config file, if any.  
+        /// Populate Toolsets with a dictionary of (toolset version, Toolset)
+        /// using information from the registry and config file, if any.
         /// </summary>
         private void InitializeToolsetCollection(
 #if FEATURE_WIN32_REGISTRY
@@ -2374,7 +2360,7 @@ private class LoadedProjectCollection : IEnumerable<Project>
             /// with different global properties and/or tools version.
             /// </summary>
             /// <remarks>
-            /// If hosts tend to load lots of projects with the same path, the value will have to be 
+            /// If hosts tend to load lots of projects with the same path, the value will have to be
             /// changed to a more efficient type of collection.
             ///
             /// Lock on this object. Concurrent load must be thread safe.
diff --git a/src/Build/Definition/ProjectItem.cs b/src/Build/Definition/ProjectItem.cs
index 4fd40b3fe7f..40b7b40eed9 100644
--- a/src/Build/Definition/ProjectItem.cs
+++ b/src/Build/Definition/ProjectItem.cs
@@ -127,12 +127,12 @@ internal ProjectItem(
                              List<ProjectItemDefinition> inheritedItemDefinitionsCloned
                             )
         {
-            ErrorUtilities.VerifyThrowInternalNull(project, "project");
-            ErrorUtilities.VerifyThrowArgumentNull(xml, "xml");
+            ErrorUtilities.VerifyThrowInternalNull(project, nameof(project));
+            ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
 
             // Orcas accidentally allowed empty includes if they resulted from expansion: we preserve that bug
-            ErrorUtilities.VerifyThrowArgumentNull(evaluatedIncludeEscaped, "evaluatedIncludeEscaped");
-            ErrorUtilities.VerifyThrowArgumentNull(evaluatedIncludeBeforeWildcardExpansionEscaped, "evaluatedIncludeBeforeWildcardExpansionEscaped");
+            ErrorUtilities.VerifyThrowArgumentNull(evaluatedIncludeEscaped, nameof(evaluatedIncludeEscaped));
+            ErrorUtilities.VerifyThrowArgumentNull(evaluatedIncludeBeforeWildcardExpansionEscaped, nameof(evaluatedIncludeBeforeWildcardExpansionEscaped));
 
             _xml = xml;
             _project = project;
@@ -321,7 +321,7 @@ internal ICollection<ProjectMetadata> MetadataCollection
                 RetrievableEntryHashSet<ProjectMetadata> allMetadata = new RetrievableEntryHashSet<ProjectMetadata>(MSBuildNameIgnoreCaseComparer.Default);
 
                 // Lowest priority: regular item definitions
-                ProjectItemDefinition itemDefinition = null;
+                ProjectItemDefinition itemDefinition;
                 if (_project.ItemDefinitions.TryGetValue(ItemType, out itemDefinition))
                 {
                     foreach (ProjectMetadata metadataFromDefinition in itemDefinition.Metadata)
@@ -344,7 +344,7 @@ internal ICollection<ProjectMetadata> MetadataCollection
                 }
 
                 // Finally any direct metadata win.
-                if (null != _directMetadata)
+                if (_directMetadata != null)
                 {
                     foreach (ProjectMetadata metadatum in _directMetadata)
                     {
@@ -400,7 +400,7 @@ public ProjectMetadata GetMetadata(string name)
                 return Link.GetMetadata(name);
             }
 
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
 
             ProjectMetadata result = null;
 
@@ -441,7 +441,7 @@ public bool HasMetadata(string name)
                 return Link.HasMetadata(name);
             }
 
-            if (_directMetadata != null && _directMetadata.Contains(name))
+            if (_directMetadata?.Contains(name) == true)
             {
                 return true;
             }
@@ -452,7 +452,7 @@ public bool HasMetadata(string name)
             }
 
             ProjectMetadata metadatum = GetItemDefinitionMetadata(name);
-            if (null != metadatum)
+            if (metadatum != null)
             {
                 return true;
             }
@@ -466,7 +466,7 @@ public bool HasMetadata(string name)
         /// </summary>
         string IItem.GetMetadataValueEscaped(string name)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
 
             string value = null;
 
@@ -488,13 +488,13 @@ string IItem.GetMetadataValueEscaped(string name)
             {
                 ProjectMetadata metadatum = GetItemDefinitionMetadata(name);
 
-                if (null != metadatum && Expander<ProjectProperty, ProjectItem>.ExpressionMayContainExpandableExpressions(metadatum.EvaluatedValueEscaped))
+                if (metadatum != null && Expander<ProjectProperty, ProjectItem>.ExpressionMayContainExpandableExpressions(metadatum.EvaluatedValueEscaped))
                 {
                     Expander<ProjectProperty, ProjectItem> expander = new Expander<ProjectProperty, ProjectItem>(null, null, new BuiltInMetadataTable(this), FileSystems.Default);
 
                     value = expander.ExpandIntoStringLeaveEscaped(metadatum.EvaluatedValueEscaped, ExpanderOptions.ExpandBuiltInMetadata, metadatum.Location);
                 }
-                else if (null != metadatum)
+                else if (metadatum != null)
                 {
                     return metadatum.EvaluatedValueEscaped;
                 }
@@ -521,7 +521,7 @@ ProjectMetadata IItem<ProjectMetadata>.GetMetadata(string name)
         /// </summary>
         ProjectMetadata IItem<ProjectMetadata>.SetMetadata(ProjectMetadataElement metadataElement, string evaluatedInclude)
         {
-            _directMetadata = _directMetadata ?? new PropertyDictionary<ProjectMetadata>();
+            _directMetadata ??= new PropertyDictionary<ProjectMetadata>();
 
             ProjectMetadata predecessor = GetMetadata(metadataElement.Name);
 
@@ -573,7 +573,7 @@ private ProjectMetadata SetMetadataOperation(string name, string unevaluatedValu
             XmlUtilities.VerifyThrowArgumentValidElementName(name);
             ErrorUtilities.VerifyThrowArgument(!FileUtilities.ItemSpecModifiers.IsItemSpecModifier(name), "ItemSpecModifierCannotBeCustomMetadata", name);
             ErrorUtilities.VerifyThrowInvalidOperation(!XMakeElements.ReservedItemNames.Contains(name), "CannotModifyReservedItemMetadata", name);
-            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent != null && _xml.Parent.Parent != null, "OM_ObjectIsNoLongerActive");
+            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent?.Parent != null, "OM_ObjectIsNoLongerActive");
 
             if (!propagateMetadataToSiblingItems)
             {
@@ -582,7 +582,7 @@ private ProjectMetadata SetMetadataOperation(string name, string unevaluatedValu
 
             ProjectMetadata metadatum;
 
-            if (_directMetadata != null && _directMetadata.Contains(name))
+            if (_directMetadata?.Contains(name) == true)
             {
                 metadatum = _directMetadata[name];
                 metadatum.UnevaluatedValue = unevaluatedValue;
@@ -598,7 +598,7 @@ private ProjectMetadata SetMetadataOperation(string name, string unevaluatedValu
 
             if (!propagateMetadataToSiblingItems)
             {
-                _directMetadata = _directMetadata ?? new PropertyDictionary<ProjectMetadata>();
+                _directMetadata ??= new PropertyDictionary<ProjectMetadata>();
                 _directMetadata.Set(metadatum);
             }
             else
@@ -607,7 +607,7 @@ private ProjectMetadata SetMetadataOperation(string name, string unevaluatedValu
 
                 foreach (var siblingItem in siblingItems)
                 {
-                    siblingItem._directMetadata = siblingItem._directMetadata ?? new PropertyDictionary<ProjectMetadata>();
+                    siblingItem._directMetadata ??= new PropertyDictionary<ProjectMetadata>();
                     siblingItem._directMetadata.Set(metadatum.DeepClone());
                 }
             }
@@ -628,12 +628,12 @@ public bool RemoveMetadata(string name)
                 return Link.RemoveMetadata(name);
             }
 
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
             ErrorUtilities.VerifyThrowArgument(!FileUtilities.ItemSpecModifiers.IsItemSpecModifier(name), "ItemSpecModifierCannotBeCustomMetadata", name);
             Project.VerifyThrowInvalidOperationNotImported(_xml.ContainingProject);
-            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent != null && _xml.Parent.Parent != null, "OM_ObjectIsNoLongerActive");
+            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent?.Parent != null, "OM_ObjectIsNoLongerActive");
 
-            ProjectMetadata metadatum = (_directMetadata == null) ? null : _directMetadata[name];
+            ProjectMetadata metadatum = _directMetadata?[name];
 
             if (metadatum == null)
             {
@@ -681,7 +681,7 @@ public void Rename(string name)
             }
 
             Project.VerifyThrowInvalidOperationNotImported(_xml.ContainingProject);
-            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent != null && _xml.Parent.Parent != null, "OM_ObjectIsNoLongerActive");
+            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent?.Parent != null, "OM_ObjectIsNoLongerActive");
 
             if (String.Equals(UnevaluatedInclude, name, StringComparison.Ordinal))
             {
@@ -777,7 +777,7 @@ internal void ChangeItemType(string newItemType)
         {
             ErrorUtilities.VerifyThrowArgumentLength(newItemType, "ItemType");
             Project.VerifyThrowInvalidOperationNotImported(_xml.ContainingProject);
-            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent != null && _xml.Parent.Parent != null, "OM_ObjectIsNoLongerActive");
+            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent?.Parent != null, "OM_ObjectIsNoLongerActive");
 
             if (String.Equals(ItemType, newItemType, StringComparison.Ordinal))
             {
@@ -1060,14 +1060,14 @@ private ProjectItem CreateItem(string evaluatedIncludeEscaped, string evaluatedI
 
                 if (source._inheritedItemDefinitions != null)
                 {
-                    inheritedItemDefinitionsClone = inheritedItemDefinitionsClone ?? new List<ProjectItemDefinition>(inheritedItemDefinitionsCount + 1);
+                    inheritedItemDefinitionsClone ??= new List<ProjectItemDefinition>(inheritedItemDefinitionsCount + 1);
                     inheritedItemDefinitionsClone.AddRange(source._inheritedItemDefinitions);
                 }
 
                 ProjectItemDefinition sourceItemDefinition;
                 if (_project.ItemDefinitions.TryGetValue(source.ItemType, out sourceItemDefinition))
                 {
-                    inheritedItemDefinitionsClone = inheritedItemDefinitionsClone ?? new List<ProjectItemDefinition>(inheritedItemDefinitionsCount + 1);
+                    inheritedItemDefinitionsClone ??= new List<ProjectItemDefinition>(inheritedItemDefinitionsCount + 1);
                     inheritedItemDefinitionsClone.Add(sourceItemDefinition);
                 }
 
diff --git a/src/Build/Definition/ProjectItemDefinition.cs b/src/Build/Definition/ProjectItemDefinition.cs
index 08ca675b7a0..e9a7f83cf9e 100644
--- a/src/Build/Definition/ProjectItemDefinition.cs
+++ b/src/Build/Definition/ProjectItemDefinition.cs
@@ -54,8 +54,8 @@ public class ProjectItemDefinition : IKeyed, IMetadataTable, IItemDefinition<Pro
         /// </remarks>
         internal ProjectItemDefinition(Project project, string itemType)
         {
-            ErrorUtilities.VerifyThrowInternalNull(project, "project");
-            ErrorUtilities.VerifyThrowArgumentLength(itemType, "itemType");
+            ErrorUtilities.VerifyThrowInternalNull(project, nameof(project));
+            ErrorUtilities.VerifyThrowArgumentLength(itemType, nameof(itemType));
 
             _project = project;
             _itemType = itemType;
@@ -119,7 +119,7 @@ string IKeyed.Key
         [DebuggerStepThrough]
         public ProjectMetadata GetMetadata(string name)
         {
-            return Link != null ? Link.GetMetadata(name) : (_metadata == null) ? null : _metadata[name];
+            return Link != null ? Link.GetMetadata(name) : _metadata?[name];
         }
 
         /// <summary>
@@ -173,7 +173,7 @@ public ProjectMetadata SetMetadataValue(string name, string unevaluatedValue)
 
             ProjectMetadataElement metadatumXml = itemDefinition.AddMetadata(name, unevaluatedValue);
 
-            _metadata = _metadata ?? new PropertyDictionary<ProjectMetadata>();
+            _metadata ??= new PropertyDictionary<ProjectMetadata>();
 
             string evaluatedValueEscaped = _project.ExpandMetadataValueBestEffortLeaveEscaped(this, unevaluatedValue, metadatumXml.Location);
 
@@ -192,7 +192,7 @@ public ProjectMetadata SetMetadataValue(string name, string unevaluatedValue)
         /// </summary>
         ProjectMetadata IItemDefinition<ProjectMetadata>.SetMetadata(ProjectMetadataElement metadataElement, string evaluatedValue, ProjectMetadata predecessor)
         {
-            _metadata = _metadata ?? new PropertyDictionary<ProjectMetadata>();
+            _metadata ??= new PropertyDictionary<ProjectMetadata>();
 
             ProjectMetadata metadatum = new ProjectMetadata(this, metadataElement, evaluatedValue, predecessor);
             _metadata.Set(metadatum);
diff --git a/src/Build/Definition/ProjectMetadata.cs b/src/Build/Definition/ProjectMetadata.cs
index 2408a1e6c18..3b6b9285233 100644
--- a/src/Build/Definition/ProjectMetadata.cs
+++ b/src/Build/Definition/ProjectMetadata.cs
@@ -56,8 +56,8 @@ public class ProjectMetadata : IKeyed, IValued, IEquatable<ProjectMetadata>, IMe
         /// </summary>
         internal ProjectMetadata(object parent, ProjectMetadataElement xml)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
-            ErrorUtilities.VerifyThrowArgumentNull(xml, "xml");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
+            ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
 
             _parent = (IProjectMetadataParent)parent;
             _xml = xml;
@@ -69,9 +69,9 @@ internal ProjectMetadata(object parent, ProjectMetadataElement xml)
         /// </summary>
         internal ProjectMetadata(IProjectMetadataParent parent, ProjectMetadataElement xml, string evaluatedValueEscaped, ProjectMetadata predecessor)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
-            ErrorUtilities.VerifyThrowArgumentNull(xml, "xml");
-            ErrorUtilities.VerifyThrowArgumentNull(evaluatedValueEscaped, "evaluatedValueEscaped");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
+            ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
+            ErrorUtilities.VerifyThrowArgumentNull(evaluatedValueEscaped, nameof(evaluatedValueEscaped));
 
             _parent = parent;
             _xml = xml;
@@ -132,7 +132,7 @@ public string UnevaluatedValue
             {
                 ErrorUtilities.VerifyThrowArgumentNull(value, "value");
                 Project.VerifyThrowInvalidOperationNotImported(_xml.ContainingProject);
-                ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent != null && _xml.Parent.Parent != null && _xml.Parent.Parent.Parent != null, "OM_ObjectIsNoLongerActive");
+                ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent?.Parent?.Parent != null, "OM_ObjectIsNoLongerActive");
 
                 if (String.Equals(_xml.Value, value, StringComparison.Ordinal))
                 {
@@ -143,7 +143,6 @@ public string UnevaluatedValue
 
                 if (_evaluatedValueEscaped != null)
                 {
-
                     // Clear out the current value of this metadata, so the new value can't refer to the old one.
                     // The expansion call below otherwise passes in the parent item's metadata - including this one's
                     // current value.
@@ -287,8 +286,8 @@ bool IEquatable<ProjectMetadata>.Equals(ProjectMetadata other)
                 return false;
             }
 
-            return (_xml == other._xml &&
-                    EvaluatedValueEscaped == other.EvaluatedValueEscaped);
+            return _xml == other._xml &&
+                    EvaluatedValueEscaped == other.EvaluatedValueEscaped;
         }
 
         #endregion
diff --git a/src/Build/Definition/ProjectProperty.cs b/src/Build/Definition/ProjectProperty.cs
index 5cb358fae95..a8e6b32e4a3 100644
--- a/src/Build/Definition/ProjectProperty.cs
+++ b/src/Build/Definition/ProjectProperty.cs
@@ -14,7 +14,7 @@
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
-    /// An evaluated design-time property 
+    /// An evaluated design-time property
     /// </summary>
     [DebuggerDisplay("{Name}={EvaluatedValue} [{UnevaluatedValue}]")]
     public abstract class ProjectProperty : IKeyed, IValued, IProperty, IEquatable<ProjectProperty>
@@ -33,7 +33,7 @@ public abstract class ProjectProperty : IKeyed, IValued, IProperty, IEquatable<P
 
         internal ProjectProperty(Project project)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(project, "project");
+            ErrorUtilities.VerifyThrowArgumentNull(project, nameof(project));
             _project = project;
         }
 
@@ -42,8 +42,8 @@ internal ProjectProperty(Project project)
         /// </summary>
         internal ProjectProperty(Project project, string evaluatedValueEscaped)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(project, "project");
-            ErrorUtilities.VerifyThrowArgumentNull(evaluatedValueEscaped, "evaluatedValueEscaped");
+            ErrorUtilities.VerifyThrowArgumentNull(project, nameof(project));
+            ErrorUtilities.VerifyThrowArgumentNull(evaluatedValueEscaped, nameof(evaluatedValueEscaped));
 
             _project = project;
             _evaluatedValueEscaped = evaluatedValueEscaped;
@@ -57,7 +57,7 @@ internal ProjectProperty(Project project, string evaluatedValueEscaped)
         /// </summary>
         /// <comment>
         /// If this could be set, it would be necessary to have a callback
-        /// so that the containing collections could be updated, as they use the name as 
+        /// so that the containing collections could be updated, as they use the name as
         /// their key.
         /// </comment>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
@@ -218,7 +218,7 @@ bool IEquatable<ProjectProperty>.Equals(ProjectProperty other)
                 return true;
             }
 
-            if (null == other)
+            if (other == null)
             {
                 return false;
             }
@@ -232,7 +232,7 @@ bool IEquatable<ProjectProperty>.Equals(ProjectProperty other)
         #endregion
 
         /// <summary>
-        /// Creates a property without backing XML. 
+        /// Creates a property without backing XML.
         /// Property MAY BE global, and property MAY HAVE a reserved name (such as "MSBuildProjectDirectory") if indicated.
         /// This is ONLY to be used by the Evaluator (and Project.SetGlobalProperty) and ONLY for Global, Environment, and Built-in properties.
         /// All other properties originate in XML, and should have a backing XML object.
@@ -278,7 +278,7 @@ internal void UpdateEvaluatedValue(string evaluatedValueEscaped)
         /// <remarks>
         /// The reason we do this and not just look at project.GlobalProperties is
         /// that when the project is being loaded, the GlobalProperties collection is already populated.  When we do our
-        /// evaluation, we may attempt to add some properties, such as environment variables, to the master Properties 
+        /// evaluation, we may attempt to add some properties, such as environment variables, to the master Properties
         /// collection.  As GlobalProperties are supposed to override these and thus be added last, we can't check against
         /// the GlobalProperties collection as they are being added.  The correct behavior is to always check against the
         /// collection which is accumulating properties as we go, which is the Properties collection.  Once the project has
@@ -291,7 +291,7 @@ internal void UpdateEvaluatedValue(string evaluatedValueEscaped)
         private static bool ProjectHasMatchingGlobalProperty(Project project, string propertyName)
         {
             ProjectProperty property = project.GetProperty(propertyName);
-            if (property != null && property.IsGlobalProperty && !project.GlobalPropertiesToTreatAsLocal.Contains(propertyName))
+            if (property?.IsGlobalProperty == true && !project.GlobalPropertiesToTreatAsLocal.Contains(propertyName))
             {
                 return true;
             }
@@ -319,7 +319,7 @@ private class ProjectPropertyXmlBacked : ProjectProperty
             internal ProjectPropertyXmlBacked(Project project, ProjectPropertyElement xml, string evaluatedValueEscaped)
                 : base(project, evaluatedValueEscaped)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(xml, "xml");
+                ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
                 ErrorUtilities.VerifyThrowInvalidOperation(!ProjectHasMatchingGlobalProperty(project, xml.Name), "OM_GlobalProperty", xml.Name);
 
                 _xml = xml;
@@ -331,7 +331,7 @@ internal ProjectPropertyXmlBacked(Project project, ProjectPropertyElement xml, s
             /// </summary>
             /// <comment>
             /// If this could be set, it would be necessary to have a callback
-            /// so that the containing collections could be updated, as they use the name as 
+            /// so that the containing collections could be updated, as they use the name as
             /// their key.
             /// </comment>
             [DebuggerBrowsable(DebuggerBrowsableState.Never)]
@@ -348,7 +348,7 @@ public override string Name
             /// </summary>
             /// <remarks>
             /// The containing project will be dirtied by the XML modification.
-            /// If there is no XML backing, the evaluated value returned is the value of the property that has been 
+            /// If there is no XML backing, the evaluated value returned is the value of the property that has been
             /// escaped as necessary.
             /// </remarks>
             public override string UnevaluatedValue
@@ -362,7 +362,7 @@ public override string UnevaluatedValue
                 set
                 {
                     Project.VerifyThrowInvalidOperationNotImported(_xml.ContainingProject);
-                    ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent != null && _xml.Parent.Parent != null, "OM_ObjectIsNoLongerActive");
+                    ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent?.Parent != null, "OM_ObjectIsNoLongerActive");
 
                     _xml.Value = value;
 
@@ -464,7 +464,7 @@ private class ProjectPropertyXmlBackedWithPredecessor : ProjectPropertyXmlBacked
             internal ProjectPropertyXmlBackedWithPredecessor(Project project, ProjectPropertyElement xml, string evaluatedValueEscaped, ProjectProperty predecessor)
                 : base(project, xml, evaluatedValueEscaped)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(predecessor, "predecessor");
+                ErrorUtilities.VerifyThrowArgumentNull(predecessor, nameof(predecessor));
 
                 _predecessor = predecessor;
             }
@@ -496,7 +496,7 @@ private class ProjectPropertyNotXmlBacked : ProjectProperty
             private readonly string _name;
 
             /// <summary>
-            /// Creates a property without backing XML. 
+            /// Creates a property without backing XML.
             /// Property MAY BE global, and property MAY HAVE a reserved name (such as "MSBuildProjectDirectory") if indicated.
             /// This is ONLY to be used by the Evaluator (and Project.SetGlobalProperty) and ONLY for Global, Environment, and Built-in properties.
             /// All other properties originate in XML, and should have a backing XML object.
@@ -504,7 +504,7 @@ private class ProjectPropertyNotXmlBacked : ProjectProperty
             internal ProjectPropertyNotXmlBacked(Project project, string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved)
                 : base(project, evaluatedValueEscaped)
             {
-                ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+                ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
                 ErrorUtilities.VerifyThrowInvalidOperation(isGlobalProperty || !ProjectHasMatchingGlobalProperty(project, name), "OM_GlobalProperty", name);
                 ErrorUtilities.VerifyThrowArgument(!XMakeElements.ReservedItemNames.Contains(name), "OM_ReservedName", name);
                 ErrorUtilities.VerifyThrowArgument(mayBeReserved || !ReservedPropertyNames.IsReservedProperty(name), "OM_ReservedName", name);
@@ -518,7 +518,7 @@ internal ProjectPropertyNotXmlBacked(Project project, string name, string evalua
             /// </summary>
             /// <comment>
             /// If this could be set, it would be necessary to have a callback
-            /// so that the containing collections could be updated, as they use the name as 
+            /// so that the containing collections could be updated, as they use the name as
             /// their key.
             /// </comment>
             [DebuggerBrowsable(DebuggerBrowsableState.Never)]
@@ -535,7 +535,7 @@ public override string Name
             /// </summary>
             /// <remarks>
             /// The containing project will be dirtied.
-            /// As there is no XML backing, the evaluated value returned is the value of the property that has been 
+            /// As there is no XML backing, the evaluated value returned is the value of the property that has been
             /// escaped as necessary.
             /// </remarks>
             public override string UnevaluatedValue
@@ -572,7 +572,7 @@ public override string UnevaluatedValue
             /// </summary>
             public override bool IsEnvironmentProperty
             {
-                get { return (!IsGlobalProperty && !IsReservedProperty); }
+                get { return !IsGlobalProperty && !IsReservedProperty; }
             }
 
             /// <summary>
@@ -628,10 +628,5 @@ public override bool IsImported
                 get { return false; }
             }
         }
-
-
-        /// <summary>
-        /// External projects support
-        /// </summary>
     }
 }
diff --git a/src/Build/Definition/SubToolset.cs b/src/Build/Definition/SubToolset.cs
index aecc042c249..66578f1baa2 100644
--- a/src/Build/Definition/SubToolset.cs
+++ b/src/Build/Definition/SubToolset.cs
@@ -35,7 +35,7 @@ public class SubToolset : ITranslatable
         /// </summary>
         internal SubToolset(string subToolsetVersion, PropertyDictionary<ProjectPropertyInstance> properties)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(subToolsetVersion, "subToolsetVersion");
+            ErrorUtilities.VerifyThrowArgumentLength(subToolsetVersion, nameof(subToolsetVersion));
 
             _subToolsetVersion = subToolsetVersion;
             _properties = properties;
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index 351c8f749bc..fc08972debb 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -43,89 +43,89 @@ public class Toolset : ITranslatable
     {
         /// <summary>
         /// these files list all default tasks and task assemblies that do not need to be explicitly declared by projects
-        /// </summary> 
+        /// </summary>
         private const string DefaultTasksFilePattern = "*.tasks";
 
         /// <summary>
         /// these files list all Override tasks and task assemblies that do not need to be explicitly declared by projects
-        /// </summary> 
+        /// </summary>
         private const string OverrideTasksFilePattern = "*.overridetasks";
 
 #if FEATURE_WIN32_REGISTRY
         /// <summary>
-        /// Regkey that we check to see whether Dev10 is installed.  This should exist if any SKU of Dev10 is installed, 
-        /// but is not removed even when the last version of Dev10 is uninstalled, due to 10.0\bsln sticking around. 
+        /// Regkey that we check to see whether Dev10 is installed.  This should exist if any SKU of Dev10 is installed,
+        /// but is not removed even when the last version of Dev10 is uninstalled, due to 10.0\bsln sticking around.
         /// </summary>
         private const string Dev10OverallInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vs\Servicing\10.0";
 
         /// <summary>
-        /// Regkey that we check to see whether Dev10 Ultimate is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether Dev10 Ultimate is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10UltimateInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vs\Servicing\10.0\vstscore";
 
         /// <summary>
-        /// Regkey that we check to see whether Dev10 Premium is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether Dev10 Premium is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10PremiumInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vs\Servicing\10.0\vstdcore";
 
         /// <summary>
-        /// Regkey that we check to see whether Dev10 Professional is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether Dev10 Professional is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10ProfessionalInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vs\Servicing\10.0\procore";
 
         /// <summary>
-        /// Regkey that we check to see whether C# Express 2010 is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether C# Express 2010 is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10VCSExpressInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vcs\Servicing\10.0\xcor";
 
         /// <summary>
-        /// Regkey that we check to see whether VB Express 2010 is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether VB Express 2010 is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10VBExpressInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vb\Servicing\10.0\xcor";
 
         /// <summary>
-        /// Regkey that we check to see whether VC Express 2010 is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether VC Express 2010 is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10VCExpressInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vc\Servicing\10.0\xcor";
 
         /// <summary>
-        /// Regkey that we check to see whether VWD Express 2010 is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether VWD Express 2010 is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10VWDExpressInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vns\Servicing\10.0\xcor";
 
         /// <summary>
-        /// Regkey that we check to see whether LightSwitch 2010 is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether LightSwitch 2010 is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10LightSwitchInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vs\Servicing\10.0\vslscore";
 
         /// <summary>
-        /// Null if it hasn't been figured out yet; true if (some variation of) Visual Studio 2010 is installed on 
-        /// the current machine, false otherwise. 
+        /// Null if it hasn't been figured out yet; true if (some variation of) Visual Studio 2010 is installed on
+        /// the current machine, false otherwise.
         /// </summary>
         private static bool? s_dev10IsInstalled = null;
 #endif // FEATURE_WIN32_REGISTRY
 
         /// <summary>
         /// Name of the tools version
-        /// </summary> 
+        /// </summary>
         private string _toolsVersion;
 
         /// <summary>
         /// The MSBuildBinPath (and ToolsPath) for this tools version
-        /// </summary> 
+        /// </summary>
         private string _toolsPath;
 
         /// <summary>
         /// The properties defined by the toolset.
-        /// </summary> 
+        /// </summary>
         private PropertyDictionary<ProjectPropertyInstance> _properties;
 
         /// <summary>
@@ -150,22 +150,22 @@ public class Toolset : ITranslatable
 
         /// <summary>
         /// indicates if the default tasks file has already been scanned
-        /// </summary> 
+        /// </summary>
         private bool _defaultTasksRegistrationAttempted;
 
         /// <summary>
         /// indicates if the override tasks file has already been scanned
-        /// </summary> 
+        /// </summary>
         private bool _overrideTasksRegistrationAttempted;
 
         /// <summary>
         /// holds all the default tasks we know about and the assemblies they exist in
-        /// </summary> 
+        /// </summary>
         private TaskRegistry _defaultTaskRegistry;
 
         /// <summary>
         /// holds all the override tasks we know about and the assemblies they exist in
-        /// </summary> 
+        /// </summary>
         private TaskRegistry _overrideTaskRegistry;
 
         /// <summary>
@@ -194,13 +194,13 @@ public class Toolset : ITranslatable
         private PropertyDictionary<ProjectPropertyInstance> _propertyBag;
 
         /// <summary>
-        /// SubToolsets that map to this toolset. 
+        /// SubToolsets that map to this toolset.
         /// </summary>
         private Dictionary<string, SubToolset> _subToolsets;
 
         /// <summary>
-        /// If no sub-toolset is specified, this is the default sub-toolset version.  Null == no default 
-        /// sub-toolset, just use the base toolset. 
+        /// If no sub-toolset is specified, this is the default sub-toolset version.  Null == no default
+        /// sub-toolset, just use the base toolset.
         /// </summary>
         private string _defaultSubToolsetVersion;
 
@@ -253,7 +253,7 @@ public Toolset(string toolsVersion, string toolsPath, IDictionary<string, string
             : this(toolsVersion, toolsPath, null, projectCollection.EnvironmentProperties, projectCollection.GlobalPropertiesCollection, subToolsets, msbuildOverrideTasksPath, defaultOverrideToolsVersion: null)
         {
             _properties = new PropertyDictionary<ProjectPropertyInstance>();
-            if (null != buildProperties)
+            if (buildProperties != null)
             {
                 foreach (KeyValuePair<string, string> keyValuePair in buildProperties)
                 {
@@ -273,10 +273,10 @@ public Toolset(string toolsVersion, string toolsPath, IDictionary<string, string
         /// <param name="defaultOverrideToolsVersion">ToolsVersion to use as the default ToolsVersion for this version of MSBuild.</param>
         internal Toolset(string toolsVersion, string toolsPath, PropertyDictionary<ProjectPropertyInstance> environmentProperties, PropertyDictionary<ProjectPropertyInstance> globalProperties, string msbuildOverrideTasksPath, string defaultOverrideToolsVersion)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, "toolsVersion");
-            ErrorUtilities.VerifyThrowArgumentLength(toolsPath, "toolsPath");
-            ErrorUtilities.VerifyThrowArgumentNull(environmentProperties, "environmentProperties");
-            ErrorUtilities.VerifyThrowArgumentNull(globalProperties, "globalProperties");
+            ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, nameof(toolsVersion));
+            ErrorUtilities.VerifyThrowArgumentLength(toolsPath, nameof(toolsPath));
+            ErrorUtilities.VerifyThrowArgumentNull(environmentProperties, nameof(environmentProperties));
+            ErrorUtilities.VerifyThrowArgumentNull(globalProperties, nameof(globalProperties));
 
             _toolsVersion = toolsVersion;
             this.ToolsPath = toolsPath;
@@ -284,7 +284,6 @@ internal Toolset(string toolsVersion, string toolsPath, PropertyDictionary<Proje
             _environmentProperties = environmentProperties;
             _overrideTasksPath = msbuildOverrideTasksPath;
             _defaultOverrideToolsVersion = defaultOverrideToolsVersion;
-            
         }
 
         /// <summary>
@@ -353,8 +352,8 @@ internal Toolset(
         internal Toolset(string toolsVersion, string toolsPath, PropertyDictionary<ProjectPropertyInstance> buildProperties, ProjectCollection projectCollection, DirectoryGetFiles getFiles, LoadXmlFromPath loadXmlFromPath, string msbuildOverrideTasksPath, DirectoryExists directoryExists)
             : this(toolsVersion, toolsPath, buildProperties, projectCollection.EnvironmentProperties, projectCollection.GlobalPropertiesCollection, null, msbuildOverrideTasksPath, null)
         {
-            ErrorUtilities.VerifyThrowInternalNull(getFiles, "getFiles");
-            ErrorUtilities.VerifyThrowInternalNull(loadXmlFromPath, "loadXmlFromPath");
+            ErrorUtilities.VerifyThrowInternalNull(getFiles, nameof(getFiles));
+            ErrorUtilities.VerifyThrowInternalNull(loadXmlFromPath, nameof(loadXmlFromPath));
 
             _directoryExists = directoryExists;
             _getFiles = getFiles;
@@ -465,16 +464,16 @@ public IDictionary<string, SubToolset> SubToolsets
         }
 
         /// <summary>
-        /// Returns the default sub-toolset version for this sub-toolset.  Heuristic used is: 
-        /// 1) If Visual Studio 2010 is installed and our ToolsVersion is "4.0", use the base toolset, and return 
-        ///    a sub-toolset version of "10.0", to be set as a publicly visible property so that e.g. targets can 
-        ///    consume it.  This is to handle the fact that Visual Studio 2010 did not have any concept of sub-toolsets. 
-        /// 2) Otherwise, use the highest-versioned sub-toolset found.  Sub-toolsets with numbered versions will 
-        ///    be ordered numerically; any additional sub-toolsets will be prepended to the beginning of the list in 
-        ///    the order found. We use the highest-versioned sub-toolset because, in the absence of any other information, 
-        ///    we assume that higher-versioned tools will be more likely to be able to generate something more correct.  
-        /// 
-        /// Will return null if there is no sub-toolset available (and Dev10 is not installed). 
+        /// Returns the default sub-toolset version for this sub-toolset.  Heuristic used is:
+        /// 1) If Visual Studio 2010 is installed and our ToolsVersion is "4.0", use the base toolset, and return
+        ///    a sub-toolset version of "10.0", to be set as a publicly visible property so that e.g. targets can
+        ///    consume it.  This is to handle the fact that Visual Studio 2010 did not have any concept of sub-toolsets.
+        /// 2) Otherwise, use the highest-versioned sub-toolset found.  Sub-toolsets with numbered versions will
+        ///    be ordered numerically; any additional sub-toolsets will be prepended to the beginning of the list in
+        ///    the order found. We use the highest-versioned sub-toolset because, in the absence of any other information,
+        ///    we assume that higher-versioned tools will be more likely to be able to generate something more correct.
+        ///
+        /// Will return null if there is no sub-toolset available (and Dev10 is not installed).
         /// </summary>
         public string DefaultSubToolsetVersion
         {
@@ -521,11 +520,11 @@ public string DefaultSubToolsetVersion
         }
 
         /// <summary>
-        /// Null if it hasn't been figured out yet; true if (some variation of) Visual Studio 2010 is installed on 
-        /// the current machine, false otherwise. 
+        /// Null if it hasn't been figured out yet; true if (some variation of) Visual Studio 2010 is installed on
+        /// the current machine, false otherwise.
         /// </summary>
         /// <comments>
-        /// Internal so that unit tests can use it too. 
+        /// Internal so that unit tests can use it too.
         /// </comments>
         internal static bool Dev10IsInstalled
         {
@@ -632,13 +631,13 @@ void ITranslatable.Translate(ITranslator translator)
 
         /// <summary>
         /// Generates the sub-toolset version to be used with this toolset.  Sub-toolset version is based on:
-        /// 1. If "VisualStudioVersion" is set as a property on the toolset itself (global or environment), 
-        ///    use that. 
-        /// 2. Otherwise, use the default sub-toolset version for this toolset. 
-        /// 
-        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used, 
-        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing 
-        /// sub-toolset.  
+        /// 1. If "VisualStudioVersion" is set as a property on the toolset itself (global or environment),
+        ///    use that.
+        /// 2. Otherwise, use the default sub-toolset version for this toolset.
+        ///
+        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used,
+        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing
+        /// sub-toolset.
         /// </summary>
         public string GenerateSubToolsetVersion()
         {
@@ -648,17 +647,17 @@ public string GenerateSubToolsetVersion()
 
         /// <summary>
         /// Generates the sub-toolset version to be used with this toolset.  Sub-toolset version is based on:
-        /// 1. If the "VisualStudioVersion" global property exists in the set of properties passed to us, use it. 
-        /// 2. Otherwise, if "VisualStudioVersion" is set as a property on the toolset itself (global or environment), 
-        ///    use that. 
-        /// 3. Otherwise, use Visual Studio version from solution file if it maps to an existing sub-toolset. 
-        /// 4. Otherwise, use the default sub-toolset version for this toolset. 
-        /// 
-        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used, 
-        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing 
-        /// sub-toolset.  
-        /// 
-        /// The global properties dictionary may be null. 
+        /// 1. If the "VisualStudioVersion" global property exists in the set of properties passed to us, use it.
+        /// 2. Otherwise, if "VisualStudioVersion" is set as a property on the toolset itself (global or environment),
+        ///    use that.
+        /// 3. Otherwise, use Visual Studio version from solution file if it maps to an existing sub-toolset.
+        /// 4. Otherwise, use the default sub-toolset version for this toolset.
+        ///
+        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used,
+        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing
+        /// sub-toolset.
+        ///
+        /// The global properties dictionary may be null.
         /// </summary>
         [SuppressMessage("Microsoft.Usage", "CA2233:OperationsShouldNotOverflow", MessageId = "solutionVersion-1", Justification = "Method called in restricted places. Checks done by the callee and inside the method.")]
         public string GenerateSubToolsetVersion(IDictionary<string, string> overrideGlobalProperties, int solutionVersion)
@@ -667,9 +666,9 @@ public string GenerateSubToolsetVersion(IDictionary<string, string> overrideGlob
         }
 
         /// <summary>
-        /// Given a property name and a sub-toolset version, searches for that property first in the 
-        /// sub-toolset, then falls back to the base toolset if necessary, and returns the property 
-        /// if it was found. 
+        /// Given a property name and a sub-toolset version, searches for that property first in the
+        /// sub-toolset, then falls back to the base toolset if necessary, and returns the property
+        /// if it was found.
         /// </summary>
         public ProjectPropertyInstance GetProperty(string propertyName, string subToolsetVersion)
         {
@@ -702,7 +701,7 @@ internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, ILoggingServic
 
             try
             {
-                if (null != getFiles)
+                if (getFiles != null)
                 {
                     defaultTasksFiles = getFiles(searchPath, taskPattern);
                 }
@@ -751,50 +750,47 @@ internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, ILoggingServic
 
         /// <summary>
         /// Generates the sub-toolset version to be used with this toolset.  Sub-toolset version is based on:
-        /// 1. If the "VisualStudioVersion" global property exists in the set of properties passed to us, use it. 
-        /// 2. Otherwise, if "VisualStudioVersion" is set as a property on the toolset itself (global or environment), 
-        ///    use that. 
-        /// 3. Otherwise, use Visual Studio version from solution file if it maps to an existing sub-toolset. 
-        /// 4. Otherwise, use the default sub-toolset version for this toolset. 
-        /// 
-        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used, 
-        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing 
-        /// sub-toolset.  
-        /// 
-        /// The global properties dictionary may be null. 
+        /// 1. If the "VisualStudioVersion" global property exists in the set of properties passed to us, use it.
+        /// 2. Otherwise, if "VisualStudioVersion" is set as a property on the toolset itself (global or environment),
+        ///    use that.
+        /// 3. Otherwise, use Visual Studio version from solution file if it maps to an existing sub-toolset.
+        /// 4. Otherwise, use the default sub-toolset version for this toolset.
+        ///
+        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used,
+        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing
+        /// sub-toolset.
+        ///
+        /// The global properties dictionary may be null.
         /// </summary>
         internal string GenerateSubToolsetVersion(PropertyDictionary<ProjectPropertyInstance> overrideGlobalProperties)
         {
-            ProjectPropertyInstance subToolsetProperty = null;
-            string visualStudioVersion = null;
             if (overrideGlobalProperties != null)
             {
-                subToolsetProperty = overrideGlobalProperties[Constants.SubToolsetVersionPropertyName];
+                ProjectPropertyInstance subToolsetProperty = overrideGlobalProperties[Constants.SubToolsetVersionPropertyName];
 
                 if (subToolsetProperty != null)
                 {
-                    visualStudioVersion = subToolsetProperty.EvaluatedValue;
-                    return visualStudioVersion;
+                    return subToolsetProperty.EvaluatedValue;
                 }
             }
 
-            visualStudioVersion = GenerateSubToolsetVersion(0 /* don't care about solution version */);
-            return visualStudioVersion;
+            /* don't care about solution version */
+            return GenerateSubToolsetVersion(0);
         }
 
         /// <summary>
         /// Generates the sub-toolset version to be used with this toolset.  Sub-toolset version is based on:
-        /// 1. If the "VisualStudioVersion" global property exists in the set of properties passed to us, use it. 
-        /// 2. Otherwise, if "VisualStudioVersion" is set as a property on the toolset itself (global or environment), 
-        ///    use that. 
-        /// 3. Otherwise, use Visual Studio version from solution file if it maps to an existing sub-toolset. 
-        /// 4. Otherwise, use the default sub-toolset version for this toolset. 
-        /// 
-        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used, 
-        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing 
-        /// sub-toolset.  
-        /// 
-        /// The global properties dictionary may be null. 
+        /// 1. If the "VisualStudioVersion" global property exists in the set of properties passed to us, use it.
+        /// 2. Otherwise, if "VisualStudioVersion" is set as a property on the toolset itself (global or environment),
+        ///    use that.
+        /// 3. Otherwise, use Visual Studio version from solution file if it maps to an existing sub-toolset.
+        /// 4. Otherwise, use the default sub-toolset version for this toolset.
+        ///
+        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used,
+        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing
+        /// sub-toolset.
+        ///
+        /// The global properties dictionary may be null.
         /// </summary>
         internal string GenerateSubToolsetVersion(int visualStudioVersionFromSolution)
         {
@@ -835,7 +831,7 @@ internal string GenerateSubToolsetVersion(int visualStudioVersionFromSolution)
         }
 
         /// <summary>
-        /// Return a task registry stub for the tasks in the *.tasks file for this toolset         
+        /// Return a task registry stub for the tasks in the *.tasks file for this toolset
         /// </summary>
         /// <param name="loggingServices">The logging services used to log during task registration.</param>
         /// <param name="buildEventContext">The build event context used to log during task registration.</param>
@@ -852,18 +848,17 @@ internal TaskRegistry GetTaskRegistry(ILoggingService loggingServices, BuildEven
         /// </summary>
         internal string GenerateSubToolsetVersionUsingVisualStudioVersion(IDictionary<string, string> overrideGlobalProperties, int visualStudioVersionFromSolution)
         {
-            string visualStudioVersion = null;
+            string visualStudioVersion;
             if (overrideGlobalProperties != null && overrideGlobalProperties.TryGetValue(Constants.SubToolsetVersionPropertyName, out visualStudioVersion))
             {
                 return visualStudioVersion;
             }
 
-            visualStudioVersion = GenerateSubToolsetVersion(visualStudioVersionFromSolution);
-            return visualStudioVersion;
+            return GenerateSubToolsetVersion(visualStudioVersionFromSolution);
         }
 
         /// <summary>
-        /// Return a task registry for the override tasks in the *.overridetasks file for this toolset         
+        /// Return a task registry for the override tasks in the *.overridetasks file for this toolset
         /// </summary>
         /// <param name="loggingServices">The logging services used to log during task registration.</param>
         /// <param name="buildEventContext">The build event context used to log during task registration.</param>
@@ -1002,7 +997,7 @@ private void RegisterOverrideTasks(ILoggingService loggingServices, BuildEventCo
                         {
                             if (Path.IsPathRooted(_overrideTasksPath))
                             {
-                                if (null != _directoryExists)
+                                if (_directoryExists != null)
                                 {
                                     overrideDirectoryExists = _directoryExists(_overrideTasksPath);
                                 }
@@ -1068,7 +1063,7 @@ private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, ILoggingSer
                     {
                         ProjectUsingTaskElement usingTask = elementXml as ProjectUsingTaskElement;
 
-                        if (null == usingTask)
+                        if (usingTask == null)
                         {
                             ProjectErrorUtilities.ThrowInvalidProject
                                 (
diff --git a/src/Build/Definition/ToolsetConfigurationReader.cs b/src/Build/Definition/ToolsetConfigurationReader.cs
index 6f98ee8108f..9023f575257 100644
--- a/src/Build/Definition/ToolsetConfigurationReader.cs
+++ b/src/Build/Definition/ToolsetConfigurationReader.cs
@@ -61,7 +61,7 @@ internal ToolsetConfigurationReader(PropertyDictionary<ProjectPropertyInstance>
         internal ToolsetConfigurationReader(PropertyDictionary<ProjectPropertyInstance> environmentProperties, PropertyDictionary<ProjectPropertyInstance> globalProperties, Func<Configuration> readApplicationConfiguration)
             : base(environmentProperties, globalProperties)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(readApplicationConfiguration, "readApplicationConfiguration");
+            ErrorUtilities.VerifyThrowArgumentNull(readApplicationConfiguration, nameof(readApplicationConfiguration));
             _readApplicationConfiguration = readApplicationConfiguration;
             _projectImportSearchPathsCache = new Dictionary<string, Dictionary<string, ProjectImportPathMatch>>(StringComparer.OrdinalIgnoreCase);
         }
@@ -82,7 +82,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> ToolsVersions
                             toolset.ElementInformation.LineNumber,
                             0);
 
-                        if (toolset.toolsVersion != null && toolset.toolsVersion.Length == 0)
+                        if (toolset.toolsVersion?.Length == 0)
                         {
                             InvalidToolsetDefinitionException.Throw(
                                 "InvalidToolsetValueInConfigFileValue",
@@ -106,7 +106,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> ToolsVersions
         protected override string MSBuildOverrideTasksPath => ConfigurationSection?.MSBuildOverrideTasksPath;
 
         /// <summary>
-        /// DefaultOverrideToolsVersion attribute on msbuildToolsets element, specifying the tools version that should be used by 
+        /// DefaultOverrideToolsVersion attribute on msbuildToolsets element, specifying the tools version that should be used by
         /// default to build projects with this version of MSBuild.
         /// </summary>
         protected override string DefaultOverrideToolsVersion => ConfigurationSection?.DefaultOverrideToolsVersion;
@@ -119,7 +119,7 @@ private ToolsetConfigurationSection ConfigurationSection
         {
             get
             {
-                if (null == _configurationSection && !_configurationReadAttempted)
+                if (_configurationSection == null && !_configurationReadAttempted)
                 {
                     try
                     {
@@ -159,7 +159,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> GetPropertyDefinitions
             {
                 ElementLocation location = ElementLocation.Create(propertyElement.ElementInformation.Source, propertyElement.ElementInformation.LineNumber, 0);
 
-                if (propertyElement.Name != null && propertyElement.Name.Length == 0)
+                if (propertyElement.Name?.Length == 0)
                 {
                     InvalidToolsetDefinitionException.Throw("InvalidToolsetValueInConfigFileValue", location.LocationString);
                 }
@@ -171,7 +171,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> GetPropertyDefinitions
         /// <summary>
         /// Provides an enumerator over the set of sub-toolset names available to a particular
         /// tools version.  MSBuild config files do not currently support sub-toolsets, so
-        /// we return nothing. 
+        /// we return nothing.
         /// </summary>
         /// <param name="toolsVersion">The tools version.</param>
         /// <returns>An enumeration of the sub-toolsets that belong to that tools version.</returns>
@@ -181,9 +181,9 @@ protected override IEnumerable<string> GetSubToolsetVersions(string toolsVersion
         }
 
         /// <summary>
-        /// Provides an enumerator over property definitions for a specified sub-toolset version 
-        /// under a specified toolset version. In the ToolsetConfigurationReader case, breaks 
-        /// immediately because we do not currently support sub-toolsets in the configuration file. 
+        /// Provides an enumerator over property definitions for a specified sub-toolset version
+        /// under a specified toolset version. In the ToolsetConfigurationReader case, breaks
+        /// immediately because we do not currently support sub-toolsets in the configuration file.
         /// </summary>
         /// <param name="toolsVersion">The tools version.</param>
         /// <param name="subToolsetVersion">The sub-toolset version.</param>
@@ -216,9 +216,7 @@ protected override Dictionary<string, ProjectImportPathMatch> GetProjectImportSe
                 return kindToPathsCache;
             }
 
-            kindToPathsCache = ComputeDistinctListOfSearchPaths(propertyCollection);
-
-            return kindToPathsCache;
+            return ComputeDistinctListOfSearchPaths(propertyCollection);
         }
 
         /// <summary>
diff --git a/src/Build/Definition/ToolsetPropertyDefinition.cs b/src/Build/Definition/ToolsetPropertyDefinition.cs
index 5116370d075..356e311b827 100644
--- a/src/Build/Definition/ToolsetPropertyDefinition.cs
+++ b/src/Build/Definition/ToolsetPropertyDefinition.cs
@@ -40,11 +40,11 @@ internal class ToolsetPropertyDefinition
         /// <param name="source">The property source</param>
         public ToolsetPropertyDefinition(string name, string value, IElementLocation source)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
-            ErrorUtilities.VerifyThrowArgumentNull(source, "source");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
+            ErrorUtilities.VerifyThrowArgumentNull(source, nameof(source));
 
             // value can be the empty string but not null
-            ErrorUtilities.VerifyThrowArgumentNull(value, "value");
+            ErrorUtilities.VerifyThrowArgumentNull(value, nameof(value));
 
             _name = name;
             _value = value;
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index 1bd0cee26d6..cd6d48dd786 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -150,7 +150,7 @@ ToolsetDefinitionLocations locations
                 if (NativeMethodsShared.IsWindows || registryReader != null)
                 {
                     // If we haven't been provided a registry reader (i.e. unit tests), create one
-                    registryReader = registryReader ?? new ToolsetRegistryReader(environmentProperties, globalProperties);
+                    registryReader ??= new ToolsetRegistryReader(environmentProperties, globalProperties);
 
                     // We do not accumulate properties when reading them from the registry, because the order
                     // in which values are returned to us is essentially random: so we disallow one property
@@ -509,7 +509,7 @@ bool accumulateProperties
             try
             {
                 var importSearchPathsTable = GetProjectImportSearchPathsTable(toolsVersion.Name, NativeMethodsShared.GetOSNameForExtensionsPath());
-                toolset = new Toolset(toolsVersion.Name, toolsPath == null ? binPath : toolsPath, properties, _environmentProperties, globalProperties, subToolsets, MSBuildOverrideTasksPath, DefaultOverrideToolsVersion, importSearchPathsTable);
+                toolset = new Toolset(toolsVersion.Name, toolsPath ?? binPath, properties, _environmentProperties, globalProperties, subToolsets, MSBuildOverrideTasksPath, DefaultOverrideToolsVersion, importSearchPathsTable);
             }
             catch (ArgumentException e)
             {
@@ -626,7 +626,7 @@ private static void AppendStandardProperties(
         /// <param name="expander">The expander used to expand the value of the properties.  Ref because if we are accumulating the properties, we need to re-create the expander to account for the new property value.</param>
         private void EvaluateAndSetProperty(ToolsetPropertyDefinition property, PropertyDictionary<ProjectPropertyInstance> properties, PropertyDictionary<ProjectPropertyInstance> globalProperties, PropertyDictionary<ProjectPropertyInstance> initialProperties, bool accumulateProperties, ref string toolsPath, ref string binPath, ref Expander<ProjectPropertyInstance, ProjectItemInstance> expander)
         {
-            if (0 == String.Compare(property.Name, ReservedPropertyNames.toolsPath, StringComparison.OrdinalIgnoreCase))
+            if (String.Equals(property.Name, ReservedPropertyNames.toolsPath, StringComparison.OrdinalIgnoreCase))
             {
                 toolsPath = ExpandPropertyUnescaped(property, expander);
                 toolsPath = ExpandRelativePathsRelativeToExeLocation(toolsPath);
@@ -641,7 +641,7 @@ private void EvaluateAndSetProperty(ToolsetPropertyDefinition property, Property
                     );
                 }
             }
-            else if (0 == String.Compare(property.Name, ReservedPropertyNames.binPath, StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(property.Name, ReservedPropertyNames.binPath, StringComparison.OrdinalIgnoreCase))
             {
                 binPath = ExpandPropertyUnescaped(property, expander);
                 binPath = ExpandRelativePathsRelativeToExeLocation(binPath);
@@ -756,7 +756,6 @@ private string ExpandRelativePathsRelativeToExeLocation(string path)
     /// </summary>
     internal struct MSBuildExtensionsPathReferenceKind
     {
-
         /// <summary>
         /// MSBuildExtensionsPathReferenceKind instance for property named "MSBuildExtensionsPath"
         /// </summary>
diff --git a/src/Build/Definition/ToolsetRegistryReader.cs b/src/Build/Definition/ToolsetRegistryReader.cs
index d1437e00e62..7a083fbebbd 100644
--- a/src/Build/Definition/ToolsetRegistryReader.cs
+++ b/src/Build/Definition/ToolsetRegistryReader.cs
@@ -43,12 +43,12 @@ internal class ToolsetRegistryReader : ToolsetReader
     {
         /// <summary>
         /// Registry location for storing tools version dependent data for msbuild
-        /// </summary> 
+        /// </summary>
         private const string MSBuildRegistryPath = @"SOFTWARE\Microsoft\MSBuild";
 
         /// <summary>
         /// Cached registry wrapper at root of the msbuild entries
-        /// </summary> 
+        /// </summary>
         private RegistryKeyWrapper _msbuildRegistryWrapper;
 
         /// <summary>
@@ -65,7 +65,7 @@ internal ToolsetRegistryReader(PropertyDictionary<ProjectPropertyInstance> envir
         internal ToolsetRegistryReader(PropertyDictionary<ProjectPropertyInstance> environmentProperties, PropertyDictionary<ProjectPropertyInstance> globalProperties, RegistryKeyWrapper msbuildRegistryWrapper)
             : base(environmentProperties, globalProperties)
         {
-            error.VerifyThrowArgumentNull(msbuildRegistryWrapper, "msbuildRegistryWrapper");
+            error.VerifyThrowArgumentNull(msbuildRegistryWrapper, nameof(msbuildRegistryWrapper));
 
             _msbuildRegistryWrapper = msbuildRegistryWrapper;
         }
@@ -196,10 +196,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> GetPropertyDefinitions
             }
             finally
             {
-                if (toolsVersionWrapper != null)
-                {
-                    toolsVersionWrapper.Dispose();
-                }
+                toolsVersionWrapper?.Dispose();
             }
         }
 
@@ -227,23 +224,20 @@ protected override IEnumerable<string> GetSubToolsetVersions(string toolsVersion
             }
             finally
             {
-                if (toolsVersionWrapper != null)
-                {
-                    toolsVersionWrapper.Dispose();
-                }
+                toolsVersionWrapper?.Dispose();
             }
         }
 
         /// <summary>
-        /// Provides an enumerator over property definitions for a specified sub-toolset version 
-        /// under a specified toolset version. 
+        /// Provides an enumerator over property definitions for a specified sub-toolset version
+        /// under a specified toolset version.
         /// </summary>
         /// <param name="toolsVersion">The tools version.</param>
         /// <param name="subToolsetVersion">The sub-toolset version.</param>
         /// <returns>An enumeration of property definitions.</returns>
         protected override IEnumerable<ToolsetPropertyDefinition> GetSubToolsetPropertyDefinitions(string toolsVersion, string subToolsetVersion)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(subToolsetVersion, "subToolsetVersion");
+            ErrorUtilities.VerifyThrowArgumentLength(subToolsetVersion, nameof(subToolsetVersion));
 
             RegistryKeyWrapper toolsVersionWrapper = null;
             RegistryKeyWrapper subToolsetWrapper = null;
@@ -275,15 +269,9 @@ protected override IEnumerable<ToolsetPropertyDefinition> GetSubToolsetPropertyD
             }
             finally
             {
-                if (toolsVersionWrapper != null)
-                {
-                    toolsVersionWrapper.Dispose();
-                }
+                toolsVersionWrapper?.Dispose();
 
-                if (subToolsetWrapper != null)
-                {
-                    subToolsetWrapper.Dispose();
-                }
+                subToolsetWrapper?.Dispose();
             }
         }
 
@@ -305,7 +293,7 @@ private static ToolsetPropertyDefinition CreatePropertyFromRegistry(RegistryKeyW
         {
             string propertyValue = null;
 
-            if (propertyName != null && propertyName.Length == 0)
+            if (propertyName?.Length == 0)
             {
                 InvalidToolsetDefinitionException.Throw("PropertyNameInRegistryHasZeroLength", toolsetWrapper.Name);
             }
diff --git a/src/Build/ElementLocation/ElementLocation.cs b/src/Build/ElementLocation/ElementLocation.cs
index 39a9163d490..38eee339263 100644
--- a/src/Build/ElementLocation/ElementLocation.cs
+++ b/src/Build/ElementLocation/ElementLocation.cs
@@ -209,7 +209,7 @@ internal static ElementLocation Create(string file, int line, int column)
         /// </summary>
         private static string GetLocationString(string file, int line, int column)
         {
-            string locationString = String.Empty;
+            string locationString;
             if (line != 0 && column != 0)
             {
                 locationString = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("FileLocation", file, line, column);
@@ -253,7 +253,7 @@ private class RegularElementLocation : ElementLocation
             /// </summary>
             internal RegularElementLocation(string file, int line, int column)
             {
-                ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(file, "file");
+                ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(file, nameof(file));
                 ErrorUtilities.VerifyThrow(line > -1 && column > -1, "Use zero for unknown");
 
                 this.file = file ?? String.Empty;
diff --git a/src/Build/ElementLocation/RegistryLocation.cs b/src/Build/ElementLocation/RegistryLocation.cs
index d8ca9c82d5a..3e37a72f01c 100644
--- a/src/Build/ElementLocation/RegistryLocation.cs
+++ b/src/Build/ElementLocation/RegistryLocation.cs
@@ -29,7 +29,7 @@ internal class RegistryLocation : IElementLocation, ITranslatable
         /// </summary>
         internal RegistryLocation(string registryPath)
         {
-            ErrorUtilities.VerifyThrowInternalLength(registryPath, "registryPath");
+            ErrorUtilities.VerifyThrowInternalLength(registryPath, nameof(registryPath));
 
             this.registryPath = registryPath;
         }
diff --git a/src/Build/ElementLocation/XmlElementWithLocation.cs b/src/Build/ElementLocation/XmlElementWithLocation.cs
index da25514a148..91daed2c350 100644
--- a/src/Build/ElementLocation/XmlElementWithLocation.cs
+++ b/src/Build/ElementLocation/XmlElementWithLocation.cs
@@ -151,7 +151,7 @@ internal ElementLocation GetAttributeLocation(string name)
         {
             XmlAttributeWithLocation attributeWithLocation = GetAttributeWithLocation(name);
 
-            return (attributeWithLocation != null) ? attributeWithLocation.Location : null;
+            return attributeWithLocation?.Location;
         }
     }
 }
diff --git a/src/Build/Errors/InternalLoggerException.cs b/src/Build/Errors/InternalLoggerException.cs
index ca0a8f26a77..d1872605c82 100644
--- a/src/Build/Errors/InternalLoggerException.cs
+++ b/src/Build/Errors/InternalLoggerException.cs
@@ -91,11 +91,11 @@ bool initializationException
          )
             : base(message, innerException)
         {
-            ErrorUtilities.VerifyThrow((message != null) && (message.Length > 0), "Need error message.");
-            ErrorUtilities.VerifyThrow(innerException != null || initializationException == true, "Need the logger exception.");
-            ErrorUtilities.VerifyThrow((errorCode != null) && (errorCode.Length > 0), "Must specify the error message code.");
-            ErrorUtilities.VerifyThrow((helpKeyword != null) && (helpKeyword.Length > 0), "Must specify the help keyword for the IDE.");
-
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(message), "Need error message.");
+            ErrorUtilities.VerifyThrow(innerException != null || initializationException, "Need the logger exception.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(errorCode), "Must specify the error message code.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(helpKeyword), "Must specify the help keyword for the IDE.");
+            
             this.e = e;
             this.errorCode = errorCode;
             this.helpKeyword = helpKeyword;
@@ -105,7 +105,7 @@ bool initializationException
         #region Serialization (update when adding new class members)
 
         /// <summary>
-        /// Protected constructor used for (de)serialization. 
+        /// Protected constructor used for (de)serialization.
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
         /// <param name="info"></param>
diff --git a/src/Build/Errors/InvalidProjectFileException.cs b/src/Build/Errors/InvalidProjectFileException.cs
index 2704ce62392..a9e3aa63f9b 100644
--- a/src/Build/Errors/InvalidProjectFileException.cs
+++ b/src/Build/Errors/InvalidProjectFileException.cs
@@ -186,8 +186,8 @@ internal InvalidProjectFileException
             Exception innerException
         ) : base(message, innerException)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentLength(message, "message");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentLength(message, nameof(message));
 
             // Try to helpfully provide a full path if possible, but do so robustly.
             // This exception might be because the path was invalid!
@@ -196,7 +196,7 @@ Exception innerException
             {
                 string fullPath = FileUtilities.GetFullPathNoThrow(projectFile);
 
-                projectFile = (fullPath == null) ? projectFile : fullPath;
+                projectFile = fullPath ?? projectFile;
             }
 
             file = projectFile;
diff --git a/src/Build/Errors/InvalidToolsetDefinitionException.cs b/src/Build/Errors/InvalidToolsetDefinitionException.cs
index 9da2579231f..d638be88d6f 100644
--- a/src/Build/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Build/Errors/InvalidToolsetDefinitionException.cs
@@ -56,7 +56,7 @@ public InvalidToolsetDefinitionException(string message, Exception innerExceptio
         protected InvalidToolsetDefinitionException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
             errorCode = info.GetString("errorCode");
         }
@@ -95,7 +95,7 @@ public InvalidToolsetDefinitionException(string message, string errorCode, Excep
 #endif
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
             base.GetObjectData(info, context);
 
diff --git a/src/Build/Evaluation/ConditionEvaluator.cs b/src/Build/Evaluation/ConditionEvaluator.cs
index 1c7b12afd74..87e5b423c79 100644
--- a/src/Build/Evaluation/ConditionEvaluator.cs
+++ b/src/Build/Evaluation/ConditionEvaluator.cs
@@ -222,10 +222,10 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>
             where P : class, IProperty
             where I : class, IItem
         {
-            ErrorUtilities.VerifyThrowArgumentNull(condition, "condition");
-            ErrorUtilities.VerifyThrowArgumentNull(expander, "expander");
-            ErrorUtilities.VerifyThrowArgumentLength(evaluationDirectory, "evaluationDirectory");
-            ErrorUtilities.VerifyThrowArgumentNull(buildEventContext, "buildEventContext");
+            ErrorUtilities.VerifyThrowArgumentNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowArgumentNull(expander, nameof(expander));
+            ErrorUtilities.VerifyThrowArgumentLength(evaluationDirectory, nameof(evaluationDirectory));
+            ErrorUtilities.VerifyThrowArgumentNull(buildEventContext, nameof(buildEventContext));
 
             // An empty condition is equivalent to a "true" condition.
             if (condition.Length == 0)
@@ -234,7 +234,7 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>
             }
 
             // If the condition wasn't empty, there must be a location for it
-            ErrorUtilities.VerifyThrowArgumentNull(elementLocation, "elementLocation");
+            ErrorUtilities.VerifyThrowArgumentNull(elementLocation, nameof(elementLocation));
 
             // Get the expression tree cache for the current parsing options.
             var cachedExpressionTreesForCurrentOptions = s_cachedExpressionTrees.GetOrAdd(
@@ -420,10 +420,10 @@ internal ConditionEvaluationState
                 ProjectRootElementCacheBase projectRootElementCache = null
                 )
             {
-                ErrorUtilities.VerifyThrowArgumentNull(condition, "condition");
-                ErrorUtilities.VerifyThrowArgumentNull(expander, "expander");
-                ErrorUtilities.VerifyThrowArgumentNull(evaluationDirectory, "evaluationDirectory");
-                ErrorUtilities.VerifyThrowArgumentNull(elementLocation, "elementLocation");
+                ErrorUtilities.VerifyThrowArgumentNull(condition, nameof(condition));
+                ErrorUtilities.VerifyThrowArgumentNull(expander, nameof(expander));
+                ErrorUtilities.VerifyThrowArgumentNull(evaluationDirectory, nameof(evaluationDirectory));
+                ErrorUtilities.VerifyThrowArgumentNull(elementLocation, nameof(elementLocation));
 
                 Condition = condition;
                 _expander = expander;
diff --git a/src/Build/Evaluation/Conditionals/CharacterUtilities.cs b/src/Build/Evaluation/Conditionals/CharacterUtilities.cs
index 8e44cb99184..71d2979c053 100644
--- a/src/Build/Evaluation/Conditionals/CharacterUtilities.cs
+++ b/src/Build/Evaluation/Conditionals/CharacterUtilities.cs
@@ -10,28 +10,28 @@ internal static class CharacterUtilities
     {
         static internal bool IsNumberStart(char candidate)
         {
-            return (candidate == '+' || candidate == '-' || candidate == '.' || char.IsDigit(candidate));
+            return candidate == '+' || candidate == '-' || candidate == '.' || char.IsDigit(candidate);
         }
 
         static internal bool IsSimpleStringStart(char candidate)
         {
-            return (candidate == '_' || char.IsLetter(candidate));
+            return candidate == '_' || char.IsLetter(candidate);
         }
 
         static internal bool IsSimpleStringChar(char candidate)
         {
-            return (IsSimpleStringStart(candidate) || char.IsDigit(candidate));
+            return IsSimpleStringStart(candidate) || char.IsDigit(candidate);
         }
 
         static internal bool IsHexAlphabetic(char candidate)
         {
-            return (candidate == 'a' || candidate == 'b' || candidate == 'c' || candidate == 'd' || candidate == 'e' || candidate == 'f' ||
-                candidate == 'A' || candidate == 'B' || candidate == 'C' || candidate == 'D' || candidate == 'E' || candidate == 'F');
+            return candidate == 'a' || candidate == 'b' || candidate == 'c' || candidate == 'd' || candidate == 'e' || candidate == 'f' ||
+                candidate == 'A' || candidate == 'B' || candidate == 'C' || candidate == 'D' || candidate == 'E' || candidate == 'F';
         }
 
         static internal bool IsHexDigit(char candidate)
         {
-            return (char.IsDigit(candidate) || IsHexAlphabetic(candidate));
+            return char.IsDigit(candidate) || IsHexAlphabetic(candidate);
         }
     }
 }
diff --git a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
index 8ab1d5a2d65..12547eaa3ae 100644
--- a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
@@ -29,7 +29,7 @@ internal FunctionCallExpressionNode(string functionName, List<GenericExpressionN
         /// </summary>
         internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (String.Compare(_functionName, "exists", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(_functionName, "exists", StringComparison.OrdinalIgnoreCase))
             {
                 // Check we only have one argument
                 VerifyArgumentCount(1, state);
@@ -67,7 +67,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                     return false;
                 }
             }
-            else if (String.Compare(_functionName, "HasTrailingSlash", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(_functionName, "HasTrailingSlash", StringComparison.OrdinalIgnoreCase))
             {
                 // Check we only have one argument
                 VerifyArgumentCount(1, state);
@@ -80,7 +80,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                 {
                     char lastCharacter = expandedValue[expandedValue.Length - 1];
                     // Either back or forward slashes satisfy the function: this is useful for URL's
-                    return (lastCharacter == Path.DirectorySeparatorChar || lastCharacter == Path.AltDirectorySeparatorChar || lastCharacter == '\\');
+                    return lastCharacter == Path.DirectorySeparatorChar || lastCharacter == Path.AltDirectorySeparatorChar || lastCharacter == '\\';
                 }
                 else
                 {
@@ -155,7 +155,6 @@ private List<string> ExpandArgumentAsFileList(GenericExpressionNode argumentNode
                 argument = FileUtilities.FixFilePath(argument);
             }
 
-
             IList<TaskItem> expanded = state.ExpandIntoTaskItems(argument);
             var expandedCount = expanded.Count;
 
diff --git a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
index 41a0d75138d..6854357124e 100644
--- a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
@@ -95,7 +95,7 @@ internal bool PotentialAndOrConflict()
             // first one returns false
             bool detectOr = DetectOr();
             bool detectAnd = DetectAnd();
-            return (detectOr && detectAnd);
+            return detectOr && detectAnd;
         }
 
         internal abstract bool DetectOr();
diff --git a/src/Build/Evaluation/Conditionals/LessThanExpressionNode.cs b/src/Build/Evaluation/Conditionals/LessThanExpressionNode.cs
index 2e58501c88b..0b3ba717d50 100644
--- a/src/Build/Evaluation/Conditionals/LessThanExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/LessThanExpressionNode.cs
@@ -15,6 +15,9 @@ internal sealed class LessThanExpressionNode : NumericComparisonExpressionNode
         /// <summary>
         /// Compare numerically
         /// </summary>
+        /// <param name="left">left input</param>
+        /// <param name="right">right input</param>
+        /// <returns>true if right is higher than left, false otherwise</returns>
         protected override bool Compare(double left, double right)
         {
             return left < right;
@@ -23,7 +26,9 @@ protected override bool Compare(double left, double right)
         /// <summary>
         /// Compare Versions. This is only intended to compare version formats like "A.B.C.D" which can otherwise not be compared numerically
         /// </summary>
-        /// <returns></returns>
+        /// <param name="left">left version</param>
+        /// <param name="right">right version</param>
+        /// <returns>true if right version is higher than left, false otherwise</returns>
         protected override bool Compare(Version left, Version right)
         {
             return left < right;
@@ -32,6 +37,9 @@ protected override bool Compare(Version left, Version right)
         /// <summary>
         /// Compare mixed numbers and Versions
         /// </summary>
+        /// <param name="left">left version</param>
+        /// <param name="right">right number</param>
+        /// <returns>true if right is higher than major version of left, false otherwise</returns>
         protected override bool Compare(Version left, double right)
         {
             if (left.Major != right)
@@ -47,6 +55,9 @@ protected override bool Compare(Version left, double right)
         /// <summary>
         /// Compare mixed numbers and Versions
         /// </summary>
+        /// <param name="left">left number</param>
+        /// <param name="right">right version</param>
+        /// <returns>true if the major version of right is higher than left, false otherwise</returns>
         protected override bool Compare(double left, Version right)
         {
             if (right.Major != left)
diff --git a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
index 33bcefd2607..ce5df805850 100644
--- a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
@@ -55,8 +55,8 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                 "ComparisonOnNonNumericExpression",
                  state.Condition,
                  /* helpfully display unexpanded token and expanded result in error message */
-                 (LeftChild.CanNumericEvaluate(state) ? RightChild.GetUnexpandedValue(state) : LeftChild.GetUnexpandedValue(state)),
-                 (LeftChild.CanNumericEvaluate(state) ? RightChild.GetExpandedValue(state) : LeftChild.GetExpandedValue(state)));
+                 LeftChild.CanNumericEvaluate(state) ? RightChild.GetUnexpandedValue(state) : LeftChild.GetUnexpandedValue(state),
+                 LeftChild.CanNumericEvaluate(state) ? RightChild.GetExpandedValue(state) : LeftChild.GetExpandedValue(state));
 
             // If the values identify as numeric, make that comparison instead of the Version comparison since numeric has a stricter definition
             if (isNumeric)
diff --git a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
index 045fa92f794..918e188ff85 100644
--- a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
@@ -80,15 +80,9 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// </summary>
         internal override void ResetState()
         {
-            if (LeftChild != null)
-            {
-                LeftChild.ResetState();
-            }
+            LeftChild?.ResetState();
 
-            if (RightChild != null)
-            {
-                RightChild.ResetState();
-            }
+            RightChild?.ResetState();
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Conditionals/Parser.cs b/src/Build/Evaluation/Conditionals/Parser.cs
index 6e53b876075..ac231b18964 100644
--- a/src/Build/Evaluation/Conditionals/Parser.cs
+++ b/src/Build/Evaluation/Conditionals/Parser.cs
@@ -131,7 +131,6 @@ private GenericExpressionNode Expr(string expression)
                 node = ExprPrime(expression, node);
             }
 
-
             #region REMOVE_COMPAT_WARNING
             // Check for potential change in behavior
             if (LoggingServices != null && !_warnedForExpression &&
@@ -175,7 +174,7 @@ private GenericExpressionNode ExprPrime(string expression, GenericExpressionNode
         private GenericExpressionNode BooleanTerm(string expression)
         {
             GenericExpressionNode node = RelationalExpr(expression);
-            if (null == node)
+            if (node == null)
             {
                 errorPosition = _lexer.GetErrorPosition();
                 ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
@@ -197,7 +196,7 @@ private GenericExpressionNode BooleanTermPrime(string expression, GenericExpress
             else if (Same(expression, Token.TokenType.And))
             {
                 GenericExpressionNode rhs = RelationalExpr(expression);
-                if (null == rhs)
+                if (rhs == null)
                 {
                     errorPosition = _lexer.GetErrorPosition();
                     ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
@@ -219,7 +218,7 @@ private GenericExpressionNode RelationalExpr(string expression)
         {
             {
                 GenericExpressionNode lhs = Factor(expression);
-                if (null == lhs)
+                if (lhs == null)
                 {
                     errorPosition = _lexer.GetErrorPosition();
                     ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
@@ -237,7 +236,6 @@ private GenericExpressionNode RelationalExpr(string expression)
             }
         }
 
-
         private OperatorExpressionNode RelationalOperation(string expression)
         {
             OperatorExpressionNode node = null;
@@ -384,7 +382,7 @@ private bool Same(string expression, Token.TokenType token)
                 if (!_lexer.Advance())
                 {
                     errorPosition = _lexer.GetErrorPosition();
-                    if (null != _lexer.UnexpectedlyFound)
+                    if (_lexer.UnexpectedlyFound != null)
                     {
                         ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, _lexer.GetErrorResource(), expression, errorPosition, _lexer.UnexpectedlyFound);
                     }
diff --git a/src/Build/Evaluation/Conditionals/Scanner.cs b/src/Build/Evaluation/Conditionals/Scanner.cs
index 442822690b5..70b0ad7bbac 100644
--- a/src/Build/Evaluation/Conditionals/Scanner.cs
+++ b/src/Build/Evaluation/Conditionals/Scanner.cs
@@ -134,7 +134,7 @@ internal bool Advance()
             if (_errorState)
                 return false;
 
-            if (_lookahead != null && _lookahead.IsToken(Token.TokenType.EndOfInput))
+            if (_lookahead?.IsToken(Token.TokenType.EndOfInput) == true)
                 return true;
 
             SkipWhiteSpace();
@@ -538,7 +538,7 @@ private bool ParseQuotedString()
                     // If it's %(a.b) the name is just 'b'
                     if (_parsePoint + 3 < _expression.Length)
                     {
-                        name = _expression.Substring(_parsePoint + 2, (endOfName - _parsePoint - 2 + 1));
+                        name = _expression.Substring(_parsePoint + 2, endOfName - _parsePoint - 2 + 1);
                     }
 
                     if (!CheckForUnexpectedMetadata(name))
@@ -627,11 +627,11 @@ private bool ParseRemaining()
         private bool ParseSimpleStringOrFunction(int start)
         {
             SkipSimpleStringChars();
-            if (0 == string.Compare(_expression.Substring(start, _parsePoint - start), "and", StringComparison.OrdinalIgnoreCase))
+            if (string.Equals(_expression.Substring(start, _parsePoint - start), "and", StringComparison.OrdinalIgnoreCase))
             {
                 _lookahead = Token.And;
             }
-            else if (0 == string.Compare(_expression.Substring(start, _parsePoint - start), "or", StringComparison.OrdinalIgnoreCase))
+            else if (string.Equals(_expression.Substring(start, _parsePoint - start), "or", StringComparison.OrdinalIgnoreCase))
             {
                 _lookahead = Token.Or;
             }
diff --git a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
index bb67a9d78e0..61eabd438fd 100644
--- a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
@@ -117,7 +117,7 @@ internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationS
                 }
             }
 
-            return (_cachedExpandedValue.Length == 0);
+            return _cachedExpandedValue.Length == 0;
         }
 
 
diff --git a/src/Build/Evaluation/Conditionals/Token.cs b/src/Build/Evaluation/Conditionals/Token.cs
index 5887eb2085e..4ff4196dc1c 100644
--- a/src/Build/Evaluation/Conditionals/Token.cs
+++ b/src/Build/Evaluation/Conditionals/Token.cs
@@ -81,7 +81,7 @@ internal Token(TokenType type, string tokenString, bool expandable)
                 "Unexpected token type"
                 );
 
-            ErrorUtilities.VerifyThrowInternalNull(tokenString, "tokenString");
+            ErrorUtilities.VerifyThrowInternalNull(tokenString, nameof(tokenString));
 
             _tokenType = type;
             _tokenString = tokenString;
diff --git a/src/Build/Evaluation/Context/EvaluationContext.cs b/src/Build/Evaluation/Context/EvaluationContext.cs
index 07a36f6d034..633dd5404da 100644
--- a/src/Build/Evaluation/Context/EvaluationContext.cs
+++ b/src/Build/Evaluation/Context/EvaluationContext.cs
@@ -6,6 +6,7 @@
 using System.Collections.Immutable;
 using System.Threading;
 using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.FileSystem;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
@@ -17,13 +18,20 @@ namespace Microsoft.Build.Evaluation.Context
     ///     evaluations).
     ///     The caller should throw away the context when the environment changes (IO, environment variables, SDK resolution
     ///     inputs, etc).
-    ///     This class and it's closure needs to be thread safe since API users can do evaluations in parallel.
+    ///     This class and its closure needs to be thread safe since API users can do evaluations in parallel.
     /// </summary>
     public class EvaluationContext
     {
         public enum SharingPolicy
         {
+            /// <summary>
+            /// Instructs the <see cref="EvaluationContext"/> to reuse state between the different project evaluations that use it.
+            /// </summary>
             Shared,
+
+            /// <summary>
+            /// Instructs the <see cref="EvaluationContext"/> not to reuse state between the different project evaluations that use it.
+            /// </summary>
             Isolated
         }
 
@@ -40,15 +48,21 @@ public enum SharingPolicy
         /// <summary>
         /// Key to file entry list. Example usages: cache glob expansion and intermediary directory expansions during glob expansion.
         /// </summary>
-        internal ConcurrentDictionary<string, ImmutableArray<string>> FileEntryExpansionCache { get; }
+        private ConcurrentDictionary<string, ImmutableArray<string>> FileEntryExpansionCache { get; }
 
-        internal EvaluationContext(SharingPolicy policy)
+        private EvaluationContext(SharingPolicy policy, IFileSystem fileSystem)
         {
+            // Unsupported case: isolated context with non null file system.
+            // Isolated means caches aren't reused, but the given file system might cache.
+            ErrorUtilities.VerifyThrowArgument(
+                policy == SharingPolicy.Shared || fileSystem == null,
+                "IsolatedContextDoesNotSupportFileSystem");
+
             Policy = policy;
 
             SdkResolverService = new CachingSdkResolverService();
             FileEntryExpansionCache = new ConcurrentDictionary<string, ImmutableArray<string>>();
-            FileSystem = new CachingFileSystemWrapper(FileSystems.Default);
+            FileSystem = fileSystem ?? new CachingFileSystemWrapper(FileSystems.Default);
             EngineFileUtilities = new EngineFileUtilities(new FileMatcher(FileSystem, FileEntryExpansionCache));
         }
 
@@ -57,7 +71,28 @@ internal EvaluationContext(SharingPolicy policy)
         /// </summary>
         public static EvaluationContext Create(SharingPolicy policy)
         {
-            var context = new EvaluationContext(policy);
+            
+            // ReSharper disable once IntroduceOptionalParameters.Global
+            // do not remove this method to avoid breaking binary compatibility
+            return Create(policy, fileSystem: null);
+        }
+
+        /// <summary>
+        ///     Factory for <see cref="EvaluationContext" />
+        /// </summary>
+        /// <param name="policy"> The <see cref="SharingPolicy"/> to use.</param>
+        /// <param name="fileSystem">The <see cref="IFileSystem"/> to use.
+        ///     This parameter is compatible only with <see cref="SharingPolicy.Shared"/>.
+        ///     The method throws if a file system is used with <see cref="SharingPolicy.Isolated"/>.
+        ///     The reasoning is that <see cref="SharingPolicy.Isolated"/> means not reusing any caches between evaluations,
+        ///     and the passed in <paramref name="fileSystem"/> might cache state.
+        /// </param>
+        public static EvaluationContext Create(SharingPolicy policy, MSBuildFileSystemBase fileSystem)
+        {
+            var context = new EvaluationContext(
+                policy,
+                fileSystem == null ? null : new MSBuildFileSystemAdapter(fileSystem));
+
             TestOnlyHookOnCreate?.Invoke(context);
 
             return context;
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 449d9e4f3c2..4ab5024acf5 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -29,12 +29,13 @@
 using Constants = Microsoft.Build.Internal.Constants;
 using EngineFileUtilities = Microsoft.Build.Internal.EngineFileUtilities;
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
+using SdkReferencePropertyExpansionMode = Microsoft.Build.Utilities.EscapeHatches.SdkReferencePropertyExpansionMode;
 
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
     /// Evaluates a ProjectRootElement, updating the fresh Project.Data passed in.
-    /// Handles evaluating conditions, expanding expressions, and building up the 
+    /// Handles evaluating conditions, expanding expressions, and building up the
     /// lists of applicable properties, items, and itemdefinitions, as well as gathering targets and tasks
     /// and creating a TaskRegistry from the using tasks.
     /// </summary>
@@ -88,7 +89,7 @@ internal class Evaluator<P, I, M, D>
         private readonly List<Pair<string, ProjectUsingTaskElement>> _usingTaskElements;
 
         /// <summary>
-        /// List of ProjectTargetElement's traversing into imports. 
+        /// List of ProjectTargetElement's traversing into imports.
         /// Gathered during the first pass to avoid traversing again.
         /// </summary>
         private readonly List<ProjectTargetElement> _targetElements;
@@ -99,14 +100,14 @@ internal class Evaluator<P, I, M, D>
         private readonly Dictionary<string, ProjectImportElement> _importsSeen;
 
         /// <summary>
-        /// Depth first collection of InitialTargets strings declared in the main 
+        /// Depth first collection of InitialTargets strings declared in the main
         /// Project and all its imported files, split on semicolons.
         /// </summary>
         private readonly List<string> _initialTargetsList;
 
         /// <summary>
-        /// Dictionary of project full paths and a boolean that indicates whether at least one 
-        /// of their targets has the "Returns" attribute set.  
+        /// Dictionary of project full paths and a boolean that indicates whether at least one
+        /// of their targets has the "Returns" attribute set.
         /// </summary>
         private readonly Dictionary<ProjectRootElement, NGen<bool>> _projectSupportsReturnsAttribute;
 
@@ -139,7 +140,7 @@ internal class Evaluator<P, I, M, D>
         /// The current build submission ID.
         /// </summary>
         private readonly int _submissionId;
-        
+
         private readonly EvaluationContext _evaluationContext;
 
         /// <summary>
@@ -178,6 +179,8 @@ internal class Evaluator<P, I, M, D>
 
         private readonly bool _interactive;
 
+        private readonly bool _isRunningInVisualStudio;
+
         /// <summary>
         /// Private constructor called by the static Evaluate method.
         /// </summary>
@@ -240,6 +243,7 @@ private Evaluator(
             _sdkResolverService = sdkResolverService;
             _submissionId = submissionId;
             _evaluationProfiler = new EvaluationProfiler(profileEvaluation);
+            _isRunningInVisualStudio = String.Equals("true", _data.GlobalPropertiesDictionary.GetProperty("BuildingInsideVisualStudio")?.EvaluatedValue, StringComparison.OrdinalIgnoreCase);
 
             // In 15.9 we added support for the global property "NuGetInteractive" to allow SDK resolvers to be interactive.
             // In 16.0 we added the /interactive command-line argument so the line below keeps back-compat
@@ -320,7 +324,7 @@ internal static void Evaluate(
         /// </summary>
         internal static List<I> CreateItemsFromInclude(string rootDirectory, ProjectItemElement itemElement, IItemFactory<I, I> itemFactory, string unevaluatedIncludeEscaped, Expander<P, I> expander)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(unevaluatedIncludeEscaped, "unevaluatedIncludeEscaped");
+            ErrorUtilities.VerifyThrowArgumentLength(unevaluatedIncludeEscaped, nameof(unevaluatedIncludeEscaped));
 
             List<I> items = new List<I>();
             itemFactory.ItemElement = itemElement;
@@ -644,7 +648,7 @@ private void Evaluate()
                 }
 
                 SetAllProjectsProperty();
-                
+
                 List<string> initialTargets = new List<string>(_initialTargetsList.Count);
                 foreach (var initialTarget in _initialTargetsList)
                 {
@@ -843,92 +847,47 @@ private void PerformDepthFirstPass(ProjectRootElement currentProjectOrImport)
 
                 foreach (ProjectElement element in currentProjectOrImport.Children)
                 {
-                    ProjectPropertyGroupElement propertyGroup = element as ProjectPropertyGroupElement;
-
-                    if (propertyGroup != null)
-                    {
-                        EvaluatePropertyGroupElement(propertyGroup);
-                        continue;
-                    }
-
-                    ProjectItemGroupElement itemGroup = element as ProjectItemGroupElement;
-
-                    if (itemGroup != null)
+                    switch (element)
                     {
-                        _itemGroupElements.Add(itemGroup);
-
-                        continue;
-                    }
-
-                    ProjectItemDefinitionGroupElement itemDefinitionGroup = element as ProjectItemDefinitionGroupElement;
-
-                    if (itemDefinitionGroup != null)
-                    {
-                        _itemDefinitionGroupElements.Add(itemDefinitionGroup);
-
-                        continue;
-                    }
-
-                    ProjectTargetElement target = element as ProjectTargetElement;
-
-                    if (target != null)
-                    {
-                        if (_projectSupportsReturnsAttribute.ContainsKey(currentProjectOrImport))
-                        {
-                            _projectSupportsReturnsAttribute[currentProjectOrImport] |= (target.Returns != null);
-                        }
-                        else
-                        {
-                            _projectSupportsReturnsAttribute[currentProjectOrImport] = (target.Returns != null);
-                        }
-
-                        _targetElements.Add(target);
-
-                        continue;
-                    }
-
-                    ProjectImportElement import = element as ProjectImportElement;
-                    if (import != null)
-                    {
-                        EvaluateImportElement(currentProjectOrImport.DirectoryPath, import);
-                        continue;
-                    }
-
-                    ProjectImportGroupElement importGroup = element as ProjectImportGroupElement;
-
-                    if (importGroup != null)
-                    {
-                        EvaluateImportGroupElement(currentProjectOrImport.DirectoryPath, importGroup);
-                        continue;
-                    }
-
-                    ProjectUsingTaskElement usingTask = element as ProjectUsingTaskElement;
-
-                    if (usingTask != null)
-                    {
-                        _usingTaskElements.Add(new Pair<string, ProjectUsingTaskElement>(currentProjectOrImport.DirectoryPath, usingTask));
-                        continue;
-                    }
-
-                    ProjectChooseElement choose = element as ProjectChooseElement;
-
-                    if (choose != null)
-                    {
-                        EvaluateChooseElement(choose);
-                        continue;
-                    }
-
-                    if (element is ProjectExtensionsElement)
-                    {
-                        continue;
-                    }
-
-                    if (element is ProjectSdkElement)
-                    {
-                        continue; // This case is handled by implicit imports.
+                        case ProjectPropertyGroupElement propertyGroup:
+                            EvaluatePropertyGroupElement(propertyGroup);
+                            break;
+                        case ProjectItemGroupElement itemGroup:
+                            _itemGroupElements.Add(itemGroup);
+                            break;
+                        case ProjectItemDefinitionGroupElement itemDefinitionGroup:
+                            _itemDefinitionGroupElements.Add(itemDefinitionGroup);
+                            break;
+                        case ProjectTargetElement target:
+                            if (_projectSupportsReturnsAttribute.ContainsKey(currentProjectOrImport))
+                            {
+                                _projectSupportsReturnsAttribute[currentProjectOrImport] |= (target.Returns != null);
+                            }
+                            else
+                            {
+                                _projectSupportsReturnsAttribute[currentProjectOrImport] = (target.Returns != null);
+                            }
+                            _targetElements.Add(target);
+                            break;
+                        case ProjectImportElement import:
+                            EvaluateImportElement(currentProjectOrImport.DirectoryPath, import);
+                            break;
+                        case ProjectImportGroupElement importGroup:
+                            EvaluateImportGroupElement(currentProjectOrImport.DirectoryPath, importGroup);
+                            break;
+                        case ProjectUsingTaskElement usingTask:
+                            _usingTaskElements.Add(new Pair<string, ProjectUsingTaskElement>(currentProjectOrImport.DirectoryPath, usingTask));
+                            break;
+                        case ProjectChooseElement choose:
+                            EvaluateChooseElement(choose);
+                            break;
+                        case ProjectExtensionsElement extension:
+                        case ProjectSdkElement sdk: // This case is handled by implicit imports.
+                            break;
+                        default:
+                            ErrorUtilities.ThrowInternalError("Unexpected child type");
+                            break;
                     }
-
-                    ErrorUtilities.ThrowInternalError("Unexpected child type");
                 }
 
                 // Evaluate the "bottom" implicit imports as if they were the last entry in the file.
@@ -963,7 +922,7 @@ private void UpdateDefaultTargets(ProjectRootElement currentProjectOrImport)
                         string target = EscapingUtilities.UnescapeAll(temp[i].Trim());
                         if (target.Length > 0)
                         {
-                            _data.DefaultTargets = _data.DefaultTargets ?? new List<string>(temp.Count);
+                            _data.DefaultTargets ??= new List<string>(temp.Count);
                             _data.DefaultTargets.Add(target);
                         }
                     }
@@ -977,7 +936,7 @@ private void UpdateDefaultTargets(ProjectRootElement currentProjectOrImport)
         private void EvaluatePropertyGroupElement(ProjectPropertyGroupElement propertyGroupElement)
         {
             using (_evaluationProfiler.TrackElement(propertyGroupElement))
-            { 
+            {
                 if (EvaluateConditionCollectingConditionedProperties(propertyGroupElement, ExpanderOptions.ExpandProperties, ParserOptions.AllowProperties))
                 {
                     foreach (ProjectPropertyElement propertyElement in propertyGroupElement.Properties)
@@ -1049,15 +1008,8 @@ private void EvaluateUsingTaskElement(string directoryOfImportingFile, ProjectUs
         /// </summary>
         private void ReadTargetElement(ProjectTargetElement targetElement, LinkedList<ProjectTargetElement> activeTargetsByEvaluationOrder, Dictionary<string, LinkedListNode<ProjectTargetElement>> activeTargets)
         {
-            ProjectTargetInstance targetInstance = null;
-
             // If we already have read a target instance for this element, use that. 
-            targetInstance = targetElement.TargetInstance;
-
-            if (targetInstance == null)
-            {
-                targetInstance = ReadNewTargetElement(targetElement, _projectSupportsReturnsAttribute[(ProjectRootElement)targetElement.Parent], _evaluationProfiler);
-            }
+            ProjectTargetInstance targetInstance = targetElement.TargetInstance ?? ReadNewTargetElement(targetElement, _projectSupportsReturnsAttribute[(ProjectRootElement)targetElement.Parent], _evaluationProfiler);
 
             string targetName = targetElement.Name;
             ProjectTargetInstance otherTarget = _data.GetTarget(targetName);
@@ -1066,8 +1018,7 @@ private void ReadTargetElement(ProjectTargetElement targetElement, LinkedList<Pr
                 _evaluationLoggingContext.LogComment(MessageImportance.Low, "OverridingTarget", otherTarget.Name, otherTarget.Location.File, targetName, targetElement.Location.File);
             }
 
-            LinkedListNode<ProjectTargetElement> node;
-            if (activeTargets.TryGetValue(targetName, out node))
+            if (activeTargets.TryGetValue(targetName, out LinkedListNode<ProjectTargetElement> node))
             {
                 activeTargetsByEvaluationOrder.Remove(node);
             }
@@ -1090,7 +1041,7 @@ private void AddBeforeAndAfterTargetMappings(ProjectTargetElement targetElement,
 
                 if (activeTargets.ContainsKey(unescapedBeforeTarget))
                 {
-                    List<TargetSpecification> beforeTargetsForTarget = null;
+                    List<TargetSpecification> beforeTargetsForTarget;
                     if (!targetsWhichRunBeforeByTarget.TryGetValue(unescapedBeforeTarget, out beforeTargetsForTarget))
                     {
                         beforeTargetsForTarget = new List<TargetSpecification>();
@@ -1113,7 +1064,7 @@ private void AddBeforeAndAfterTargetMappings(ProjectTargetElement targetElement,
 
                 if (activeTargets.ContainsKey(unescapedAfterTarget))
                 {
-                    List<TargetSpecification> afterTargetsForTarget = null;
+                    List<TargetSpecification> afterTargetsForTarget;
                     if (!targetsWhichRunAfterByTarget.TryGetValue(unescapedAfterTarget, out afterTargetsForTarget))
                     {
                         afterTargetsForTarget = new List<TargetSpecification>();
@@ -1132,7 +1083,7 @@ private void AddBeforeAndAfterTargetMappings(ProjectTargetElement targetElement,
         }
 
         /// <summary>
-        /// Set the built-in properties, most of which are read-only 
+        /// Set the built-in properties, most of which are read-only
         /// </summary>
         private ICollection<P> AddBuiltInProperties()
         {
@@ -1248,7 +1199,6 @@ private ICollection<P> AddToolsetProperties()
             }
             else
             {
-                SubToolset subToolset = null;
 
                 // Make the subtoolset version itself available as a property -- but only if it's not already set. 
                 // Because some people may be depending on this value even if there isn't a matching sub-toolset,
@@ -1259,6 +1209,7 @@ private ICollection<P> AddToolsetProperties()
                     toolsetProperties.Add(subToolsetVersionProperty);
                 }
 
+                SubToolset subToolset;
                 if (_data.Toolset.SubToolsets.TryGetValue(_data.SubToolsetVersion, out subToolset))
                 {
                     foreach (ProjectPropertyInstance subToolsetProperty in subToolset.Properties.Values)
@@ -1340,7 +1291,7 @@ private void EvaluatePropertyElement(ProjectPropertyElement propertyElement)
                 if (evaluatedValue.Length > 0 && _expander.WarnForUninitializedProperties)
                 {
                     // Is the property we are currently setting in the list of properties which have been used but not initialized
-                    IElementLocation elementWhichUsedProperty = null;
+                    IElementLocation elementWhichUsedProperty;
                     bool isPropertyInList = _expander.UsedUninitializedProperties.Properties.TryGetValue(propertyElement.Name, out elementWhichUsedProperty);
 
                     if (isPropertyInList)
@@ -1471,7 +1422,7 @@ private void EvaluateImportElement(string directoryOfImportingFile, ProjectImpor
                 foreach (ProjectRootElement importedProjectRootElement in importedProjectRootElements)
                 {
                     _data.RecordImport(importElement, importedProjectRootElement, importedProjectRootElement.Version, sdkResult);
-                    
+
                     PerformDepthFirstPass(importedProjectRootElement);
                 }
             }
@@ -1503,7 +1454,7 @@ private void EvaluateImportGroupElement(string directoryOfImportingFile, Project
         /// </summary>
         /// <remarks>
         /// We enter here in both the property and item passes, since Chooses can contain both.
-        /// However, we only evaluate the When conditions on the first pass, so we only pulse 
+        /// However, we only evaluate the When conditions on the first pass, so we only pulse
         /// those states on that pass. On the other pass, it's as if they're not there.
         /// </remarks>
         private void EvaluateChooseElement(ProjectChooseElement chooseElement)
@@ -1538,31 +1489,21 @@ private bool EvaluateWhenOrOtherwiseChildren(IEnumerable<ProjectElement> childre
             {
                 using (_evaluationProfiler.TrackElement(element))
                 {
-                    ProjectPropertyGroupElement propertyGroup = element as ProjectPropertyGroupElement;
-
-                    if (propertyGroup != null)
-                    {
-                        EvaluatePropertyGroupElement(propertyGroup);
-                        continue;
-                    }
-
-                    ProjectItemGroupElement itemGroup = element as ProjectItemGroupElement;
-
-                    if (itemGroup != null)
-                    {
-                        _itemGroupElements.Add(itemGroup);
-                        continue;
-                    }
-
-                    ProjectChooseElement choose = element as ProjectChooseElement;
-
-                    if (choose != null)
+                    switch (element)
                     {
-                        EvaluateChooseElement(choose);
-                        continue;
+                        case ProjectPropertyGroupElement propertyGroup:
+                            EvaluatePropertyGroupElement(propertyGroup);
+                            break;
+                        case ProjectItemGroupElement itemGroup:
+                            _itemGroupElements.Add(itemGroup);
+                            break;
+                        case ProjectChooseElement choose:
+                            EvaluateChooseElement(choose);
+                            break;
+                        default:
+                            ErrorUtilities.ThrowInternalError("Unexpected child type");
+                            break;
                     }
-
-                    ErrorUtilities.ThrowInternalError("Unexpected child type");
                 }
             }
 
@@ -1572,7 +1513,7 @@ private bool EvaluateWhenOrOtherwiseChildren(IEnumerable<ProjectElement> childre
         /// <summary>
         /// Expands and loads project imports.
         /// <remarks>
-        /// Imports may contain references to "projectImportSearchPaths" defined in the app.config 
+        /// Imports may contain references to "projectImportSearchPaths" defined in the app.config
         /// toolset section. If this is the case, this method will search for the imported project
         /// in those additional paths if the default fails.
         /// </remarks>
@@ -1639,7 +1580,7 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin
             var pathsToSearch = new string[fallbackSearchPathMatch.SearchPaths.Count + 1];
             pathsToSearch[0] = prop?.EvaluatedValue;                       // The actual value of the property, with no fallbacks
             fallbackSearchPathMatch.SearchPaths.CopyTo(pathsToSearch, 1);  // The list of fallbacks, in order
-            
+
             string extensionPropertyRefAsString = fallbackSearchPathMatch.MsBuildPropertyFormat;
 
             _evaluationLoggingContext.LogComment(MessageImportance.Low, "SearchPathsForMSBuildExtensionsPath",
@@ -1750,7 +1691,7 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
                 if (_logProjectImportedEvents)
                 {
                     // Expand the expression for the Log.  Since we know the condition evaluated to false, leave unexpandable properties in the condition so as not to cause an error
-                    string expanded = _expander.ExpandIntoStringAndUnescape(importElement.Condition, ExpanderOptions.ExpandProperties | ExpanderOptions.LeavePropertiesUnexpandedOnError, importElement.ConditionLocation);
+                    string expanded = _expander.ExpandIntoStringAndUnescape(importElement.Condition, ExpanderOptions.ExpandProperties | ExpanderOptions.LeavePropertiesUnexpandedOnError | ExpanderOptions.Truncate, importElement.ConditionLocation);
 
                     ProjectImportedEventArgs eventArgs = new ProjectImportedEventArgs(
                         importElement.Location.Line,
@@ -1776,7 +1717,8 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
 
             string project = importElement.Project;
 
-            if (importElement.SdkReference != null)
+            SdkReference sdkReference = importElement.SdkReference;
+            if (sdkReference != null)
             {
                 // Try to get the path to the solution and project being built. The solution path is not directly known
                 // in MSBuild. It is passed in as a property either by the VS project system or by MSBuild's solution
@@ -1787,8 +1729,58 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
                 if (solutionPath == "*Undefined*") solutionPath = null;
                 var projectPath = _data.GetProperty(ReservedPropertyNames.projectFullPath)?.EvaluatedValue;
 
+                CompareInfo compareInfo = CultureInfo.InvariantCulture.CompareInfo;
+
+                static bool HasProperty(string value, CompareInfo compareInfo) =>
+                    value != null && compareInfo.IndexOf(value, "$(") != -1;
+
+                if (HasProperty(sdkReference.Name, compareInfo) ||
+                    HasProperty(sdkReference.Version, compareInfo) ||
+                    HasProperty(sdkReference.MinimumVersion, compareInfo))
+                {
+                    SdkReferencePropertyExpansionMode mode =
+                        Traits.Instance.EscapeHatches.SdkReferencePropertyExpansion ??
+                        SdkReferencePropertyExpansionMode.DefaultExpand;
+
+                    if (mode != SdkReferencePropertyExpansionMode.NoExpansion)
+                    {
+                        if (mode == SdkReferencePropertyExpansionMode.DefaultExpand)
+                            mode = SdkReferencePropertyExpansionMode.ExpandUnescape;
+
+                        static string EvaluateProperty(string value, IElementLocation location,
+                            Expander<P, I> expander, SdkReferencePropertyExpansionMode mode)
+                        {
+                            if (value == null)
+                                return null;
+
+                            const ExpanderOptions Options = ExpanderOptions.ExpandProperties;
+
+                            switch (mode)
+                            {
+                                case SdkReferencePropertyExpansionMode.ExpandUnescape:
+                                    return expander.ExpandIntoStringAndUnescape(value, Options, location);
+                                case SdkReferencePropertyExpansionMode.ExpandLeaveEscaped:
+                                    return expander.ExpandIntoStringLeaveEscaped(value, Options, location);
+                                case SdkReferencePropertyExpansionMode.NoExpansion:
+                                case SdkReferencePropertyExpansionMode.DefaultExpand:
+                                default:
+                                    ErrorUtilities.ThrowArgumentOutOfRange(nameof(mode));
+                                    return value;
+                            }
+                        }
+
+                        IElementLocation sdkReferenceOrigin = importElement.SdkLocation;
+
+                        sdkReference = new SdkReference(
+                            EvaluateProperty(sdkReference.Name, sdkReferenceOrigin, _expander, mode),
+                            EvaluateProperty(sdkReference.Version, sdkReferenceOrigin, _expander, mode),
+                            EvaluateProperty(sdkReference.MinimumVersion, sdkReferenceOrigin, _expander, mode)
+                        );
+                    }
+                }
+
                 // Combine SDK path with the "project" relative path
-                sdkResult = _sdkResolverService.ResolveSdk(_submissionId, importElement.SdkReference, _evaluationLoggingContext, importElement.Location, solutionPath, projectPath, _interactive);
+                sdkResult = _sdkResolverService.ResolveSdk(_submissionId, sdkReference, _evaluationLoggingContext, importElement.Location, solutionPath, projectPath, _interactive, _isRunningInVisualStudio);
 
                 if (!sdkResult.Success)
                 {
@@ -1798,7 +1790,7 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
                             importElement.Location.Line,
                             importElement.Location.Column,
                             ResourceUtilities.GetResourceString("CouldNotResolveSdk"),
-                            importElement.SdkReference.ToString())
+                            sdkReference.ToString())
                         {
                             BuildEventContext = _evaluationLoggingContext.BuildEventContext,
                             UnexpandedProject = importElement.Project,
@@ -1814,7 +1806,7 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
                         return;
                     }
 
-                    ProjectErrorUtilities.ThrowInvalidProject(importElement.SdkLocation, "CouldNotResolveSdk", importElement.SdkReference.ToString());
+                    ProjectErrorUtilities.ThrowInvalidProject(importElement.SdkLocation, "CouldNotResolveSdk", sdkReference.ToString());
                 }
 
                 if (sdkResult.Path == null)
@@ -1838,8 +1830,8 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
                     }
                 }
 
-                if ((sdkResult.PropertiesToAdd != null && sdkResult.PropertiesToAdd.Any()) ||
-                    (sdkResult.ItemsToAdd != null && sdkResult.ItemsToAdd.Any()))
+                if ((sdkResult.PropertiesToAdd?.Any() == true) ||
+                    (sdkResult.ItemsToAdd?.Any() == true))
                 {
                     //  Inserting at the beginning will mean that the properties or items from the SdkResult will be evaluated before
                     //  any projects from paths returned by the SDK Resolver.
@@ -1872,8 +1864,8 @@ private ProjectRootElement CreateProjectForSdkResult(SdkResult sdkResult)
                     hash.Add(property.Key);
                     hash.Add(property.Value);
 #else
-                    propertiesAndItemsHash = propertiesAndItemsHash * -1521134295 + property.Key.GetHashCode();
-                    propertiesAndItemsHash = propertiesAndItemsHash * -1521134295 + property.Value.GetHashCode();
+                    propertiesAndItemsHash = (propertiesAndItemsHash * -1521134295) + property.Key.GetHashCode();
+                    propertiesAndItemsHash = (propertiesAndItemsHash * -1521134295) + property.Value.GetHashCode();
 #endif
                 }
             }
@@ -1885,8 +1877,8 @@ private ProjectRootElement CreateProjectForSdkResult(SdkResult sdkResult)
                     hash.Add(item.Key);
                     hash.Add(item.Value);
 #else
-                    propertiesAndItemsHash = propertiesAndItemsHash * -1521134295 + item.Key.GetHashCode();
-                    propertiesAndItemsHash = propertiesAndItemsHash * -1521134295 + item.Value.GetHashCode();
+                    propertiesAndItemsHash = (propertiesAndItemsHash * -1521134295) + item.Key.GetHashCode();
+                    propertiesAndItemsHash = (propertiesAndItemsHash * -1521134295) + item.Value.GetHashCode();
 #endif
 
                 }
@@ -1904,7 +1896,7 @@ ProjectRootElement InnerCreate(string _, ProjectRootElementCacheBase __)
                 ProjectRootElement project = ProjectRootElement.Create();
                 project.FullPath = projectPath;
 
-                if (sdkResult.PropertiesToAdd != null && sdkResult.PropertiesToAdd.Any())
+                if (sdkResult.PropertiesToAdd?.Any() == true)
                 {
                     var propertyGroup = project.AddPropertyGroup();
                     foreach (var propertyNameAndValue in sdkResult.PropertiesToAdd)
@@ -1913,7 +1905,7 @@ ProjectRootElement InnerCreate(string _, ProjectRootElementCacheBase __)
                     }
                 }
 
-                if (sdkResult.ItemsToAdd != null && sdkResult.ItemsToAdd.Any())
+                if (sdkResult.ItemsToAdd?.Any() == true)
                 {
                     var itemGroup = project.AddItemGroup();
                     foreach (var item in sdkResult.ItemsToAdd)
@@ -1948,7 +1940,7 @@ ProjectRootElement InnerCreate(string _, ProjectRootElementCacheBase __)
         /// <summary>
         /// Load and parse the specified project import, which may have wildcards,
         /// into one or more ProjectRootElements.
-        /// Caches the parsed import into the provided collection, so future 
+        /// Caches the parsed import into the provided collection, so future
         /// requests can be satisfied without re-parsing it.
         /// </summary>
         private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(string directoryOfImportingFile, ProjectImportElement importElement, string unescapedExpression,
@@ -2194,7 +2186,6 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
                                     _evaluationLoggingContext.LogBuildEvent(eventArgs);
                                 }
 
-
                                 continue;
                             }
 
@@ -2500,7 +2491,7 @@ private static string StringifyList(IList<string> strings)
                     sb.Append(", ");
                 }
 
-                sb.Append($"\"{strings[i]}\"");
+                sb.Append('\"').Append(strings[i]).Append('\"');
             }
 
             if (strings.Count > 1)
@@ -2508,7 +2499,7 @@ private static string StringifyList(IList<string> strings)
                 sb.Append(" and ");
             }
 
-            sb.Append($"\"{strings[strings.Count - 1]}\"");
+            sb.Append('\"').Append(strings[strings.Count - 1]).Append('\"');
 
             return sb.ToString();
         }
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index d9eb06311f0..18ea640140f 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -81,6 +81,11 @@ internal enum ExpanderOptions
         /// </remarks>
         LeavePropertiesUnexpandedOnError = 0x20,
 
+        /// <summary>
+        /// When an expansion occurs, truncate it to Expander.DefaultTruncationCharacterLimit or Expander.DefaultTruncationItemLimit.
+        /// </summary>
+        Truncate = 0x40,
+
         /// <summary>
         /// Expand only properties and then item lists
         /// </summary>
@@ -119,6 +124,16 @@ internal class Expander<P, I>
         where P : class, IProperty
         where I : class, IItem
     {
+        /// <summary>
+        /// A limit for truncating string expansions within an evaluated Condition. Properties, item metadata, or item groups will be truncated to N characters such as 'N...'.
+        /// Enabled by ExpanderOptions.Truncate.
+        /// </summary>
+        private const int CharacterLimitPerExpansion = 1024;
+        /// <summary>
+        /// A limit for truncating string expansions for item groups within an evaluated Condition. N items will be evaluated such as 'A;B;C;...'.
+        /// Enabled by ExpanderOptions.Truncate.
+        /// </summary>
+        private const int ItemLimitPerExpansion = 3;
         private static readonly char[] s_singleQuoteChar = { '\'' };
         private static readonly char[] s_backtickChar = { '`' };
         private static readonly char[] s_doubleQuoteChar = { '"' };
@@ -235,7 +250,7 @@ internal static bool ExpressionContainsItemVector(string expression)
         {
             List<ExpressionShredder.ItemExpressionCapture> transforms = ExpressionShredder.GetReferencedItemExpressions(expression);
 
-            return (transforms != null);
+            return transforms != null;
         }
 
         /// <summary>
@@ -248,9 +263,7 @@ internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions o
         {
             string result = ExpandIntoStringLeaveEscaped(expression, options, elementLocation);
 
-            result = (result == null) ? null : EscapingUtilities.UnescapeAll(result);
-
-            return result;
+            return (result == null) ? null : EscapingUtilities.UnescapeAll(result);
         }
 
         /// <summary>
@@ -267,7 +280,7 @@ internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions
                 return String.Empty;
             }
 
-            ErrorUtilities.VerifyThrowInternalNull(elementLocation, "elementLocation");
+            ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             string result = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation);
             result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem);
@@ -288,7 +301,7 @@ internal object ExpandPropertiesLeaveTypedAndEscaped(string expression, Expander
                 return String.Empty;
             }
 
-            ErrorUtilities.VerifyThrowInternalNull(elementLocation, "elementLocation");
+            ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             string metaExpanded = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation);
             return PropertyExpander<P>.ExpandPropertiesLeaveTypedAndEscaped(metaExpanded, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem);
@@ -336,7 +349,7 @@ internal IList<T> ExpandIntoItemsLeaveEscaped<T>(string expression, IItemFactory
                 return Array.Empty<T>();
             }
 
-            ErrorUtilities.VerifyThrowInternalNull(elementLocation, "elementLocation");
+            ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             expression = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation);
             expression = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(expression, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem);
@@ -410,7 +423,7 @@ internal IList<T> ExpandSingleItemVectorExpressionIntoItems<T>(string expression
                 return Array.Empty<T>();
             }
 
-            ErrorUtilities.VerifyThrowInternalNull(elementLocation, "elementLocation");
+            ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             return ItemExpander.ExpandSingleItemVectorExpressionIntoItems(this, expression, _items, itemFactory, options, includeNullItems, out isTransformExpression, elementLocation);
         }
@@ -463,6 +476,14 @@ private static bool IsValidPropertyName(string propertyName)
             return true;
         }
 
+        /// <summary>
+        /// Returns true if ExpanderOptions.Truncate is set and EscapeHatches.DoNotTruncateConditions is not set
+        /// </summary>
+        private static bool IsTruncationEnabled(ExpanderOptions options)
+        {
+            return (options & ExpanderOptions.Truncate) != 0 && !Traits.Instance.EscapeHatches.DoNotTruncateConditions;
+        }
+
         /// <summary>
         /// Scan for the closing bracket that matches the one we've already skipped;
         /// essentially, pushes and pops on a stack of parentheses to do this.
@@ -471,8 +492,8 @@ private static bool IsValidPropertyName(string propertyName)
         /// </summary>
         private static int ScanForClosingParenthesis(string expression, int index)
         {
-            bool potentialPropertyFunction = false;
-            bool potentialRegistryFunction = false;
+            bool potentialPropertyFunction;
+            bool potentialRegistryFunction;
             return ScanForClosingParenthesis(expression, index, out potentialPropertyFunction, out potentialRegistryFunction);
         }
 
@@ -573,14 +594,14 @@ private static void AddArgument(List<string> arguments, ReuseableStringBuilder a
             // If we don't have something that can be treated as an argument
             // then we should treat it as a null so that passing nulls
             // becomes possible through an empty argument between commas.
-            ErrorUtilities.VerifyThrowArgumentNull(argumentBuilder, "argumentBuilder");
+            ErrorUtilities.VerifyThrowArgumentNull(argumentBuilder, nameof(argumentBuilder));
 
             // we reached the end of an argument, add the builder's final result
             // to our arguments. 
             string argValue = OpportunisticIntern.InternableToString(argumentBuilder).Trim();
 
             // We support passing of null through the argument constant value null
-            if (String.Compare("null", argValue, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals("null", argValue, StringComparison.OrdinalIgnoreCase))
             {
                 arguments.Add(null);
             }
@@ -654,7 +675,7 @@ private static string[] ExtractFunctionArguments(IElementLocation elementLocatio
                             else if (argumentsContent[n] == '`' || argumentsContent[n] == '"' || argumentsContent[n] == '\'')
                             {
                                 int quoteStart = n;
-                                n += 1; // skip over the opening quote
+                                n++; // skip over the opening quote
 
                                 n = ScanForClosingQuote(argumentsString[quoteStart], argumentsString, n);
 
@@ -706,12 +727,13 @@ private static class MetadataExpander
             /// <param name="expression">The expression containing item metadata references</param>
             /// <param name="metadata"></param>
             /// <param name="options"></param>
+            /// <param name="elementLocation"></param>
             /// <returns>The string with item metadata expanded in-place, escaped.</returns>
             internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTable metadata, ExpanderOptions options, IElementLocation elementLocation)
             {
                 try
                 {
-                    if (((options & ExpanderOptions.ExpandMetadata) == 0))
+                    if ((options & ExpanderOptions.ExpandMetadata) == 0)
                     {
                         return expression;
                     }
@@ -746,7 +768,7 @@ internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTa
                         // The most common case is where the transform is the whole expression
                         // Also if there were no valid item vector expressions found, then go ahead and do the replacement on
                         // the whole expression (which is what Orcas did).
-                        if (itemVectorExpressions != null && itemVectorExpressions.Count == 1 && itemVectorExpressions[0].Value == expression && itemVectorExpressions[0].Separator == null)
+                        if (itemVectorExpressions?.Count == 1 && itemVectorExpressions[0].Value == expression && itemVectorExpressions[0].Separator == null)
                         {
                             return expression;
                         }
@@ -841,7 +863,7 @@ private class MetadataMatchEvaluator
                 internal MetadataMatchEvaluator(IMetadataTable metadata, ExpanderOptions options)
                 {
                     _metadata = metadata;
-                    _options = (options & ExpanderOptions.ExpandMetadata);
+                    _options = options & (ExpanderOptions.ExpandMetadata | ExpanderOptions.Truncate);
 
                     ErrorUtilities.VerifyThrow(options != ExpanderOptions.Invalid, "Must be expanding metadata of some kind");
                 }
@@ -873,6 +895,10 @@ internal string ExpandSingleMetadata(Match itemMetadataMatch)
                         )
                     {
                         metadataValue = _metadata.GetEscapedValue(itemType, metadataName);
+                        if (IsTruncationEnabled(_options) && metadataValue.Length > CharacterLimitPerExpansion)
+                        {
+                            metadataValue = metadataValue.Substring(0, CharacterLimitPerExpansion - 3) + "...";
+                        }
                     }
 
                     return metadataValue;
@@ -995,8 +1021,6 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                         results.Add(lastResult);
                     }
 
-                    bool tryExtractPropertyFunction = false;
-                    bool tryExtractRegistryFunction = false;
 
                     // Append the result with the portion of the expression up to
                     // (but not including) the "$(", and advance the sourceIndex pointer.
@@ -1010,8 +1034,8 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                         results.Add(expression.Substring(sourceIndex, propertyStartIndex - sourceIndex));
                     }
 
-                    sourceIndex = propertyStartIndex;
-
+                    bool tryExtractPropertyFunction;
+                    bool tryExtractRegistryFunction;
                     // Following the "$(" we need to locate the matching ')'
                     // Scan for the matching closing bracket, skipping any nested ones
                     // This is a very complete, fast validation of parenthesis matching including for nested
@@ -1038,7 +1062,7 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                         string propertyBody;
 
                         // A property value of null will indicate that we're calling a static function on a type
-                        object propertyValue = null;
+                        object propertyValue;
 
                         // Compat: $() should return String.Empty
                         if (propertyStartIndex + 2 == propertyEndIndex)
@@ -1089,6 +1113,15 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                             propertyValue = LookupProperty(properties, expression, propertyStartIndex + 2, propertyEndIndex - 1, elementLocation, usedUninitializedProperties);
                         }
 
+                        if (IsTruncationEnabled(options) && propertyValue != null)
+                        {
+                            var value = propertyValue.ToString();
+                            if (value.Length > CharacterLimitPerExpansion)
+                            {
+                                propertyValue = value.Substring(0, CharacterLimitPerExpansion - 3) + "...";
+                            }
+                        }
+
                         // Record our result, and advance
                         // our sourceIndex pointer to the character just after the closing
                         // parenthesis.
@@ -1526,7 +1559,7 @@ private static string ExpandRegistryValue(string registryExpression, IElementLoc
 
                         object valueFromRegistry = Registry.GetValue(registryKeyName, valueName, null /* default if key or value name is not found */);
 
-                        if (null != valueFromRegistry)
+                        if (valueFromRegistry != null)
                         {
                             // Convert the result to a string that is reasonable for MSBuild
                             result = ConvertToString(valueFromRegistry);
@@ -1682,8 +1715,7 @@ internal static ExpressionShredder.ItemExpressionCapture ExpandSingleItemVectorE
                     return null;
                 }
 
-                List<ExpressionShredder.ItemExpressionCapture> matches = null;
-
+                List<ExpressionShredder.ItemExpressionCapture> matches;
                 if (s_invariantCompareInfo.IndexOf(expression, '@') == -1)
                 {
                     return null;
@@ -1717,8 +1749,6 @@ internal static IList<T> ExpandExpressionCaptureIntoItems<S, T>(
                 where T : class, IItem
             {
                 ErrorUtilities.VerifyThrow(items != null, "Cannot expand items without providing items");
-
-                IList<T> result = null;
                 isTransformExpression = false;
                 bool brokeEarlyNonEmpty;
 
@@ -1731,6 +1761,8 @@ internal static IList<T> ExpandExpressionCaptureIntoItems<S, T>(
                     itemFactory.ItemType = expressionCapture.ItemType;
                 }
 
+
+                IList<T> result;
                 if (expressionCapture.Separator != null)
                 {
                     // Reference contains a separator, for example @(Compile, ';').
@@ -1844,8 +1876,7 @@ out List<Pair<string, S>> itemsFromCapture
                 if (itemsOfType.Count == 0)
                 {
                     // .. but only if there isn't a function "Count()", since that will want to return something (zero) for an empty list
-                    if (expressionCapture.Captures == null ||
-                        !expressionCapture.Captures.Any(capture => string.Equals(capture.FunctionName, "Count", StringComparison.OrdinalIgnoreCase)))
+                    if (expressionCapture.Captures?.Any(capture => string.Equals(capture.FunctionName, "Count", StringComparison.OrdinalIgnoreCase)) != true)
                     {
                         itemsFromCapture = new List<Pair<string, S>>();
                         return false;
@@ -2022,9 +2053,32 @@ ExpanderOptions options
                     return true;
                 }
 
+                int startLength = builder.Length;
+                bool truncate = IsTruncationEnabled(options);
+
                 // if the capture.Separator is not null, then ExpandExpressionCapture would have joined the items using that separator itself
-                foreach (var item in itemsFromCapture)
+                for (int i = 0; i < itemsFromCapture.Count; i++)
                 {
+                    var item = itemsFromCapture[i];
+                    if (truncate)
+                    {
+                        if (i >= ItemLimitPerExpansion)
+                        {
+                            builder.Append("...");
+                            return false;
+                        }
+                        int currentLength = builder.Length - startLength;
+                        if (!string.IsNullOrEmpty(item.Key) && currentLength + item.Key.Length > CharacterLimitPerExpansion)
+                        {
+                            int truncateIndex = CharacterLimitPerExpansion - currentLength - 3;
+                            if (truncateIndex > 0)
+                            {
+                                builder.Append(item.Key, 0, truncateIndex);
+                            }
+                            builder.Append("...");
+                            return false;
+                        }
+                    }
                     builder.Append(item.Key);
                     builder.Append(';');
                 }
@@ -2153,7 +2207,7 @@ internal static IEnumerable<Pair<string, S>> Count(Expander<P, I> expander, IEle
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> ItemSpecModifierFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     foreach (Pair<string, S> item in itemsOfType)
                     {
@@ -2206,7 +2260,7 @@ internal static IEnumerable<Pair<string, S>> ItemSpecModifierFunction(Expander<P
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> Exists(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     foreach (Pair<string, S> item in itemsOfType)
                     {
@@ -2253,7 +2307,7 @@ internal static IEnumerable<Pair<string, S>> Exists(Expander<P, I> expander, IEl
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> Combine(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments != null && arguments.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     string relativePath = arguments[0];
 
@@ -2277,7 +2331,7 @@ internal static IEnumerable<Pair<string, S>> Combine(Expander<P, I> expander, IE
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> GetPathsOfAllDirectoriesAbove(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     // Phase 1: find all the applicable directories.
 
@@ -2353,7 +2407,7 @@ internal static IEnumerable<Pair<string, S>> GetPathsOfAllDirectoriesAbove(Expan
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> DirectoryName(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     Dictionary<string, string> directoryNameTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
@@ -2366,8 +2420,7 @@ internal static IEnumerable<Pair<string, S>> DirectoryName(Expander<P, I> expand
                             continue;
                         }
 
-                        string directoryName = null;
-
+                        string directoryName;
                         if (!directoryNameTable.TryGetValue(item.Key, out directoryName))
                         {
                             // Unescape as we are passing to the file system
@@ -2421,7 +2474,7 @@ internal static IEnumerable<Pair<string, S>> DirectoryName(Expander<P, I> expand
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> Metadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments != null && arguments.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     string metadataName = arguments[0];
 
@@ -2496,7 +2549,7 @@ internal static IEnumerable<Pair<string, S>> Distinct(Expander<P, I> expander, I
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> DistinctWithComparer(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments, StringComparer comparer)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     // This dictionary will ensure that we only return one result per unique itemspec
                     Dictionary<string, S> seenItems = new Dictionary<string, S>(comparer);
@@ -2517,7 +2570,7 @@ internal static IEnumerable<Pair<string, S>> DistinctWithComparer(Expander<P, I>
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> Reverse(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
                     foreach (Pair<String, S> item in itemsOfType.Reverse())
                     {
                         yield return new Pair<string, S>(item.Key, item.Value);
@@ -2529,7 +2582,7 @@ internal static IEnumerable<Pair<string, S>> Reverse(Expander<P, I> expander, IE
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> ExpandQuotedExpressionFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments != null && arguments.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     foreach (Pair<string, S> item in itemsOfType)
                     {
@@ -2552,7 +2605,7 @@ internal static IEnumerable<Pair<string, S>> ExpandQuotedExpressionFunction(Expa
                         // the caller to possibly do correlation.
 
                         // We pass in the existing item so we can copy over its metadata
-                        if (include != null && include.Length > 0)
+                        if (!string.IsNullOrEmpty(include))
                         {
                             yield return new Pair<string, S>(include, item.Value);
                         }
@@ -2611,7 +2664,7 @@ internal static IEnumerable<Pair<string, S>> ExecuteStringFunction(
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> ClearMetadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     foreach (Pair<string, S> item in itemsOfType)
                     {
@@ -2628,7 +2681,7 @@ internal static IEnumerable<Pair<string, S>> ClearMetadata(Expander<P, I> expand
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments != null && arguments.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     string metadataName = arguments[0];
 
@@ -2651,7 +2704,7 @@ internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander
 
                         // GetMetadataValueEscaped returns empty string for missing metadata,
                         // but IItem specifies it should return null
-                        if (metadataValue != null && metadataValue.Length > 0)
+                        if (!string.IsNullOrEmpty(metadataValue))
                         {
                             // return a result through the enumerator
                             yield return new Pair<string, S>(item.Key, item.Value);
@@ -2665,7 +2718,7 @@ internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments != null && arguments.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     string metadataName = arguments[0];
                     string metadataValueToFind = arguments[1];
@@ -2701,7 +2754,7 @@ internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> ex
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments != null && arguments.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     string metadataName = arguments[0];
                     string metadataValueToFind = arguments[1];
@@ -3134,7 +3187,7 @@ internal static Function<T> ExtractPropertyFunction(
                 }
 
                 // In case we ended up with something we don't understand
-                ProjectErrorUtilities.VerifyThrowInvalidProject(!(expressionRoot.IsEmpty), elementLocation, "InvalidFunctionPropertyExpression", expressionFunction, String.Empty);
+                ProjectErrorUtilities.VerifyThrowInvalidProject(!expressionRoot.IsEmpty, elementLocation, "InvalidFunctionPropertyExpression", expressionFunction, String.Empty);
 
                 functionBuilder.Expression = expressionFunction;
                 functionBuilder.UsedUninitializedProperties = usedUnInitializedProperties;
@@ -3929,6 +3982,11 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                                 returnVal = IntrinsicFunctions.GetTargetFrameworkVersion(arg0);
                                 return true;
                             }
+                            if (TryGetArgs(args, out string arg1, out int arg2))
+                            {
+                                returnVal = IntrinsicFunctions.GetTargetFrameworkVersion(arg1, arg2);
+                                return true;
+                            }
                         }
                         else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.IsTargetFrameworkCompatible), StringComparison.OrdinalIgnoreCase))
                         {
@@ -3938,6 +3996,27 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                                 return true;
                             }
                         }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetTargetPlatformIdentifier), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArg(args, out string arg0))
+                            {
+                                returnVal = IntrinsicFunctions.GetTargetPlatformIdentifier(arg0);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetTargetPlatformVersion), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArg(args, out string arg0))
+                            {
+                                returnVal = IntrinsicFunctions.GetTargetPlatformVersion(arg0);
+                                return true;
+                            }
+                            if (TryGetArgs(args, out string arg1, out int arg2))
+                            {
+                                returnVal = IntrinsicFunctions.GetTargetPlatformVersion(arg1, arg2);
+                                return true;
+                            }
+                        }
                     }
                     else if (_receiverType == typeof(Path))
                     {
@@ -4479,7 +4558,6 @@ private static Type GetTypeFromAssemblyUsingNamespace(string typeName)
             {
                 string baseName = typeName;
                 int assemblyNameEnd = baseName.Length;
-                Type foundType = null;
 
                 // If the string has no dot, or is nothing but a dot, we have no
                 // namespace to look for, so we can't help.
@@ -4494,7 +4572,7 @@ private static Type GetTypeFromAssemblyUsingNamespace(string typeName)
                     string candidateAssemblyName = baseName.Substring(0, assemblyNameEnd);
 
                     // Try to load the assembly with the computed name
-                    foundType = GetTypeFromAssembly(typeName, candidateAssemblyName);
+                    Type foundType = GetTypeFromAssembly(typeName, candidateAssemblyName);
 
                     if (foundType != null)
                     {
@@ -4619,8 +4697,6 @@ private static void ConstructFunction(IElementLocation elementLocation, string e
                 // There are arguments that need to be passed to the function
                 if (argumentStartIndex > -1 && !expressionSubstringAsSpan.Contains(".".AsSpan(), StringComparison.OrdinalIgnoreCase))
                 {
-                    string argumentsContent;
-
                     // separate the function and the arguments
                     functionName = expressionSubstringAsSpan.Trim();
 
@@ -4641,16 +4717,15 @@ private static void ConstructFunction(IElementLocation elementLocation, string e
                     // It may be that there are '()' but no actual arguments content
                     if (argumentStartIndex == expressionFunction.Length - 1)
                     {
-                        argumentsContent = String.Empty;
                         functionArguments = Array.Empty<string>();
                     }
                     else
                     {
                         // we have content within the '()' so let's extract and deal with it
-                        argumentsContent = expressionFunction.Substring(argumentStartIndex, argumentsEndIndex - argumentStartIndex);
+                        string argumentsContent = expressionFunction.Substring(argumentStartIndex, argumentsEndIndex - argumentStartIndex);
 
                         // If there are no arguments, then just create an empty array
-                        if (String.IsNullOrEmpty(argumentsContent))
+                        if (string.IsNullOrEmpty(argumentsContent))
                         {
                             functionArguments = Array.Empty<string>();
                         }
@@ -4870,9 +4945,6 @@ private static bool IsStaticMethodAvailable(Type receiverType, string methodName
             /// </summary>
             private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object objectInstance /* null unless instance method */, object[] args, bool isConstructor)
             {
-                ParameterInfo[] parameters = null;
-                MethodBase[] members = null;
-                MethodBase memberInfo = null;
 
                 // First let's try for a method where all arguments are strings..
                 Type[] types = new Type[_arguments.Length];
@@ -4881,6 +4953,7 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
                     types[n] = typeof(string);
                 }
 
+                MethodBase memberInfo;
                 if (isConstructor)
                 {
                     memberInfo = _receiverType.GetConstructor(bindingFlags, null, types, null);
@@ -4894,6 +4967,7 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
                 // search for a method with the right number of arguments
                 if (memberInfo == null)
                 {
+                    MethodBase[] members;
                     // Gather all methods that may match
                     if (isConstructor)
                     {
@@ -4904,22 +4978,21 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
                         members = _receiverType.GetMethods(bindingFlags);
                     }
 
-                    // Try to find a method with the right name, number of arguments and
-                    // compatible argument types
-                    object[] coercedArguments = null;
                     foreach (MethodBase member in members)
                     {
-                        parameters = member.GetParameters();
+                        ParameterInfo[] parameters = member.GetParameters();
 
                         // Simple match on name and number of params, we will be case insensitive
                         if (parameters.Length == _arguments.Length)
                         {
                             if (isConstructor || String.Equals(member.Name, _methodMethodName, StringComparison.OrdinalIgnoreCase))
                             {
+                                // Try to find a method with the right name, number of arguments and
+                                // compatible argument types
                                 // we have a match on the name and argument number
                                 // now let's try to coerce the arguments we have
                                 // into the arguments on the matching method
-                                coercedArguments = CoerceArguments(args, parameters);
+                                object[] coercedArguments = CoerceArguments(args, parameters);
 
                                 if (coercedArguments != null)
                                 {
diff --git a/src/Build/Evaluation/ExpressionShredder.cs b/src/Build/Evaluation/ExpressionShredder.cs
index 57ac51c9724..d16c2c5d495 100644
--- a/src/Build/Evaluation/ExpressionShredder.cs
+++ b/src/Build/Evaluation/ExpressionShredder.cs
@@ -90,7 +90,7 @@ internal static bool ContainsMetadataExpressionOutsideTransform(string expressio
 
             GetReferencedItemNamesAndMetadata(expression, 0, expression.Length, ref pair, ShredderOptions.MetadataOutsideTransforms);
 
-            bool result = (pair.Metadata != null && pair.Metadata.Count > 0);
+            bool result = (pair.Metadata?.Count > 0);
 
             return result;
         }
@@ -127,10 +127,8 @@ internal static List<ItemExpressionCapture> GetReferencedItemExpressions(string
                 if (Sink(expression, ref i, end, '@', '('))
                 {
                     List<ItemExpressionCapture> transformExpressions = null;
-                    string itemName = null;
                     string separator = null;
                     int separatorStart = -1;
-                    int separatorLength = -1;
 
                     // Start of a possible item list expression
 
@@ -164,7 +162,7 @@ internal static List<ItemExpressionCapture> GetReferencedItemExpressions(string
                     string name = expression.Substring(startOfName, i - startOfName);
 
                     // return the item that we're working with
-                    itemName = name;
+                    string itemName = name;
 
                     SinkWhitespace(expression, ref i);
                     bool transformOrFunctionFound = true;
@@ -235,8 +233,7 @@ internal static List<ItemExpressionCapture> GetReferencedItemExpressions(string
                         }
 
                         separatorStart = i - startPoint;
-                        separatorLength = closingQuote - i;
-                        separator = expression.Substring(i, separatorLength);
+                        separator = expression.Substring(i, closingQuote - i);
 
                         i = closingQuote + 1;
                     }
@@ -386,7 +383,7 @@ private static void GetReferencedItemNamesAndMetadata(string expression, int sta
                     // well formed, so make sure the name's in the table
                     if ((whatToShredFor & ShredderOptions.ItemTypes) != 0)
                     {
-                        pair.Items = pair.Items ?? new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
+                        pair.Items ??= new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
                         pair.Items.Add(name);
                     }
 
@@ -455,7 +452,7 @@ private static void GetReferencedItemNamesAndMetadata(string expression, int sta
 
                     if ((whatToShredFor & ShredderOptions.MetadataOutsideTransforms) != 0)
                     {
-                        pair.Metadata = pair.Metadata ?? new Dictionary<string, MetadataReference>(MSBuildNameIgnoreCaseComparer.Default);
+                        pair.Metadata ??= new Dictionary<string, MetadataReference>(MSBuildNameIgnoreCaseComparer.Default);
                         pair.Metadata[qualifiedMetadataName] = new MetadataReference(itemName, metadataName);
                     }
 
@@ -667,7 +664,7 @@ private static bool Sink(string expression, ref int i, int end, char c1, char c2
         {
             if (i < end - 1 && expression[i] == c1 && expression[i + 1] == c2)
             {
-                i = i + 2;
+                i += 2;
                 return true;
             }
 
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index b91daae440a..e64817750e8 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -27,7 +27,6 @@ internal interface IEvaluatorData<P, I, M, D> : IPropertyProvider<P>, IItemProvi
         where M : class, IMetadatum
         where D : class, IItemDefinition<M>
     {
-
         /// <summary>
         /// The ID of this evaluation
         /// </summary>
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 55f9e185226..d0143d1560d 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -187,7 +187,6 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
             return GetRegistryValueFromView(keyName, valueName, defaultValue, new ArraySegment<object>(views));
         }
 
-
         /// <summary>
         /// Get the value of the registry key from one of the RegistryView's specified
         /// </summary>
@@ -224,7 +223,7 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
 
                         // See if this asks for a specific SDK
                         var m = RegistrySdkRegex.Value.Match(keyName);
-                        
+
                         if (m.Success && m.Groups.Count >= 1 && valueName.Equals("InstallRoot", StringComparison.OrdinalIgnoreCase))
                         {
                             return Path.Combine(NativeMethodsShared.FrameworkBasePath, m.Groups[0].Value) + Path.DirectorySeparatorChar;
@@ -312,6 +311,7 @@ internal static string MakeRelative(string basePath, string path)
         /// </summary>
         /// <param name="startingDirectory">The directory to start the search in.</param>
         /// <param name="fileName">The name of the file to search for.</param>
+        /// <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
         /// <returns>The full path of the directory containing the file if it is found, otherwise an empty string. </returns>
         internal static string GetDirectoryNameOfFileAbove(string startingDirectory, string fileName, IFileSystem fileSystem)
         {
@@ -323,6 +323,7 @@ internal static string GetDirectoryNameOfFileAbove(string startingDirectory, str
         /// </summary>
         /// <param name="file">The name of the file to search for.</param>
         /// <param name="startingDirectory">An optional directory to start the search in.  The default location is the directory
+        /// <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
         /// of the file containing the property function.</param>
         /// <returns>The full path of the file if it is found, otherwise an empty string.</returns>
         internal static string GetPathOfFileAbove(string file, string startingDirectory, IFileSystem fileSystem)
@@ -485,9 +486,9 @@ internal static string GetTargetFrameworkIdentifier(string tfm)
             return NuGetFramework.Value.GetTargetFrameworkIdentifier(tfm);
         }
 
-        internal static string GetTargetFrameworkVersion(string tfm)
+        internal static string GetTargetFrameworkVersion(string tfm, int versionPartCount = 2)
         {
-            return NuGetFramework.Value.GetTargetFrameworkVersion(tfm);
+            return NuGetFramework.Value.GetTargetFrameworkVersion(tfm, versionPartCount);
         }
 
         internal static bool IsTargetFrameworkCompatible(string target, string candidate)
@@ -495,6 +496,16 @@ internal static bool IsTargetFrameworkCompatible(string target, string candidate
             return NuGetFramework.Value.IsCompatible(target, candidate);
         }
 
+        internal static string GetTargetPlatformIdentifier(string tfm)
+        {
+            return NuGetFramework.Value.GetTargetPlatformIdentifier(tfm);
+        }
+
+        internal static string GetTargetPlatformVersion(string tfm, int versionPartCount = 2)
+        {
+            return NuGetFramework.Value.GetTargetPlatformVersion(tfm, versionPartCount);
+        }
+
         public static string GetCurrentToolsDirectory()
         {
             return BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
@@ -559,7 +570,7 @@ private static RegistryKey GetBaseKeyFromKeyName(string keyName, RegistryView vi
         {
             if (keyName == null)
             {
-                throw new ArgumentNullException("keyName");
+                throw new ArgumentNullException(nameof(keyName));
             }
 
             string basekeyName;
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index 1027af72a64..7c81f57ae2b 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -317,6 +317,7 @@ public bool MatchesItem(I item)
         /// </summary>
         /// <param name="item">The item to attempt to find a match for based on matching metadata</param>
         /// <param name="metadata">Names of metadata to look for matches for</param>
+        /// <param name="options">metadata option matching</param>
         /// <returns></returns>
         public bool MatchesItemOnMetadata(IItem item, IEnumerable<string> metadata, MatchOnMetadataOptions options)
         {
@@ -418,19 +419,17 @@ internal abstract class ItemSpecFragment
         protected string ProjectDirectory { get; }
 
         // not a Lazy to reduce memory
-        private FileSpecMatcherTester FileMatcher
+        private ref FileSpecMatcherTester FileMatcher
         {
             get
             {
-                if (_fileMatcherInitialized)
+                if (!_fileMatcherInitialized)
                 {
-                    return _fileMatcher;
+                    _fileMatcher = CreateFileSpecMatcher();
+                    _fileMatcherInitialized = true;
                 }
 
-                _fileMatcher = CreateFileSpecMatcher();
-                _fileMatcherInitialized = true;
-
-                return _fileMatcher;
+                return ref _fileMatcher;
             }
         }
 
@@ -497,5 +496,14 @@ public GlobFragment(string textFragment, string projectDirectory)
             : base(textFragment, projectDirectory)
         {
         }
+
+        /// <summary>
+        /// True if TextFragment starts with /**/ or a variation thereof with backslashes.
+        /// </summary>
+        public bool IsFullFileSystemScan => TextFragment.Length >= 4
+            && FileUtilities.IsAnySlash(TextFragment[0])
+            && TextFragment[1] == '*'
+            && TextFragment[2] == '*'
+            && FileUtilities.IsAnySlash(TextFragment[3]);
     }
 }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index 550b876c290..4c88a6d976f 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -311,6 +311,5 @@ public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalPro
             }
         }
     }
-
     
 }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index 89f99c08aee..a5482b221d9 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -5,6 +5,7 @@
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
 using System;
 using System.Collections.Generic;
 using System.Collections.Immutable;
@@ -81,8 +82,7 @@ protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder
                     {
                         string value = valueFragment.TextFragment;
 
-                        if (excludeTester == null ||
-                            !excludeTester.Value(EscapingUtilities.UnescapeAll(value)))
+                        if (excludeTester?.Value(EscapingUtilities.UnescapeAll(value)) != true)
                         {
                             var item = _itemFactory.CreateItem(value, value, _itemElement.ContainingProject.FullPath);
                             itemsToAdd.Add(item);
@@ -90,34 +90,40 @@ protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder
                     }
                     else if (fragment is GlobFragment globFragment)
                     {
-                        string glob = globFragment.TextFragment;
-
-                        if (excludePatternsForGlobs == null)
-                        {
-                            excludePatternsForGlobs = BuildExcludePatternsForGlobs(globsToIgnore, excludePatterns);
-                        }
-
-                        string[] includeSplitFilesEscaped;
-                        if (MSBuildEventSource.Log.IsEnabled())
-                        {
-                            MSBuildEventSource.Log.ExpandGlobStart(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
-                        }
-                        using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))
-                        {
-                            includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(
-                                _rootDirectory,
-                                glob,
-                                excludePatternsForGlobs
-                            );
-                        }
-                        if (MSBuildEventSource.Log.IsEnabled())
-                        {
-                            MSBuildEventSource.Log.ExpandGlobStop(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
-                        }
-
-                        foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)
+                        // If this item is behind a false condition and represents a full drive/filesystem scan, expanding it is
+                        // almost certainly undesired. It should be skipped to avoid evaluation taking an excessive amount of time.
+                        bool skipGlob = !_conditionResult && globFragment.IsFullFileSystemScan && !Traits.Instance.EscapeHatches.AlwaysEvaluateDangerousGlobs;
+                        if (!skipGlob)
                         {
-                            itemsToAdd.Add(_itemFactory.CreateItem(includeSplitFileEscaped, glob, _itemElement.ContainingProject.FullPath));
+                            string glob = globFragment.TextFragment;
+
+                            if (excludePatternsForGlobs == null)
+                            {
+                                excludePatternsForGlobs = BuildExcludePatternsForGlobs(globsToIgnore, excludePatterns);
+                            }
+
+                            string[] includeSplitFilesEscaped;
+                            if (MSBuildEventSource.Log.IsEnabled())
+                            {
+                                MSBuildEventSource.Log.ExpandGlobStart(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
+                            }
+                            using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))
+                            {
+                                includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(
+                                    _rootDirectory,
+                                    glob,
+                                    excludePatternsForGlobs
+                                );
+                            }
+                            if (MSBuildEventSource.Log.IsEnabled())
+                            {
+                                MSBuildEventSource.Log.ExpandGlobStop(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
+                            }
+
+                            foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)
+                            {
+                                itemsToAdd.Add(_itemFactory.CreateItem(includeSplitFileEscaped, glob, _itemElement.ContainingProject.FullPath));
+                            }
                         }
                     }
                     else
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index 03d07264cf2..146e15c4df2 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -157,7 +157,7 @@ public string GetEscapedValueIfPresent(string itemType, string name)
 
                 private string RouteCall(string itemType, string name, Func<IMetadataTable, string, string, string> getEscapedValueFunc)
                 {
-                    if (itemType == null || itemType.Equals(_operationItem.Key, StringComparison.OrdinalIgnoreCase))
+                    if (itemType?.Equals(_operationItem.Key, StringComparison.OrdinalIgnoreCase) != false)
                     {
                         return getEscapedValueFunc(_operationItem, itemType, name);
                     }
@@ -298,7 +298,7 @@ protected bool NeedToExpandMetadataForEachItem(ImmutableList<ProjectMetadataElem
 
                 bool needToExpandMetadataForEachItem = false;
 
-                if (itemsAndMetadataFound.Metadata != null && itemsAndMetadataFound.Metadata.Values.Count > 0)
+                if (itemsAndMetadataFound.Metadata?.Values.Count > 0)
                 {
                     // If there is bare metadata of any kind, and the Include involved an item list, we should
                     // run items individually, as even non-built-in metadata might differ between items
diff --git a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
index e184cd7c538..00df64e8270 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
@@ -35,7 +35,7 @@ protected override void ApplyImpl(ImmutableList<ItemData>.Builder listBuilder, I
                 var matchOnMetadataValid = !_matchOnMetadata.IsEmpty && _itemSpec.Fragments.Count == 1
                     && _itemSpec.Fragments.First() is ItemSpec<ProjectProperty, ProjectItem>.ItemExpressionFragment;
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
-                    _matchOnMetadata.IsEmpty || matchOnMetadataValid && _matchOnMetadata.Count == 1,
+                    _matchOnMetadata.IsEmpty || (matchOnMetadataValid && _matchOnMetadata.Count == 1),
                     new BuildEventFileInfo(string.Empty),
                     "OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem");
 
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index ce9f84cd29d..58b2d1d661f 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -304,7 +304,6 @@ public ImmutableList<ItemData>.Builder GetItemData(ImmutableHashSet<string> glob
 
                     return ComputeItems(this, globsToIgnore);
                 }
-
             }
 
             private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyItemList, ImmutableHashSet<string> globsToIgnore)
diff --git a/src/Build/Evaluation/Preprocessor.cs b/src/Build/Evaluation/Preprocessor.cs
index dedb60450d1..794e709cefb 100644
--- a/src/Build/Evaluation/Preprocessor.cs
+++ b/src/Build/Evaluation/Preprocessor.cs
@@ -16,7 +16,7 @@
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
-    /// Creates a view of an evaluated project's XML as if it had all been loaded from 
+    /// Creates a view of an evaluated project's XML as if it had all been loaded from
     /// a single file, instead of being assembled by pulling in imported files as it actually was.
     /// </summary>
     /// <remarks>
@@ -73,7 +73,7 @@ private Preprocessor(Project project)
         }
 
         /// <summary>
-        /// Returns an XmlDocument representing the evaluated project's XML as if it all had 
+        /// Returns an XmlDocument representing the evaluated project's XML as if it all had
         /// been loaded from a single file, instead of being assembled by pulling in imported files.
         /// </summary>
         internal static XmlDocument GetPreprocessedDocument(Project project)
@@ -193,7 +193,7 @@ private void AddImplicitImportNodes(XmlElement documentElement)
                     {
                         documentElement.InsertBefore(xmlElement, documentElement.FirstChild);
                     }
-                    
+
                     lastImplicitImportAdded = xmlElement;
                 }
                 else
diff --git a/src/Build/Evaluation/Profiler/EvaluationLocationTabSeparatedPrettyPrinter.cs b/src/Build/Evaluation/Profiler/EvaluationLocationTabSeparatedPrettyPrinter.cs
index 4d47f224e34..555aef21810 100644
--- a/src/Build/Evaluation/Profiler/EvaluationLocationTabSeparatedPrettyPrinter.cs
+++ b/src/Build/Evaluation/Profiler/EvaluationLocationTabSeparatedPrettyPrinter.cs
@@ -36,9 +36,7 @@ protected override string NormalizeExpression(string description, EvaluationLoca
             }
 
             // Swap tabs for spaces, so we don't mess up the TSV format
-            text = text.Replace(Separator, " ");
-
-            return text;
+            return text.Replace(Separator, " ");
         }
     }
 }
diff --git a/src/Build/Evaluation/ProjectChangedEventArgs.cs b/src/Build/Evaluation/ProjectChangedEventArgs.cs
index f70ec35ac11..3504098b754 100644
--- a/src/Build/Evaluation/ProjectChangedEventArgs.cs
+++ b/src/Build/Evaluation/ProjectChangedEventArgs.cs
@@ -20,7 +20,7 @@ public class ProjectChangedEventArgs : EventArgs
         /// <param name="project">The changed project.</param>
         internal ProjectChangedEventArgs(Project project)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(project, "project");
+            ErrorUtilities.VerifyThrowArgumentNull(project, nameof(project));
 
             Project = project;
         }
diff --git a/src/Build/Evaluation/ProjectParser.cs b/src/Build/Evaluation/ProjectParser.cs
index cbdb79a738e..761ef477d6f 100644
--- a/src/Build/Evaluation/ProjectParser.cs
+++ b/src/Build/Evaluation/ProjectParser.cs
@@ -54,7 +54,7 @@ internal class ProjectParser
         private static readonly HashSet<string> ValidAttributesOnTarget = new HashSet<string> { XMakeAttributes.condition, XMakeAttributes.label, XMakeAttributes.name, XMakeAttributes.inputs, XMakeAttributes.outputs, XMakeAttributes.keepDuplicateOutputs, XMakeAttributes.dependsOnTargets, XMakeAttributes.beforeTargets, XMakeAttributes.afterTargets, XMakeAttributes.returns };
 
         /// <summary>
-        /// Valid attributes on on error element
+        /// Valid attributes on error element
         /// </summary>
         private static readonly HashSet<string> ValidAttributesOnOnError = new HashSet<string> { XMakeAttributes.condition, XMakeAttributes.label, XMakeAttributes.executeTargets };
 
@@ -94,8 +94,8 @@ internal class ProjectParser
         /// </summary>
         private ProjectParser(XmlDocumentWithLocation document, ProjectRootElement project)
         {
-            ErrorUtilities.VerifyThrowInternalNull(project, "project");
-            ErrorUtilities.VerifyThrowInternalNull(document, "document");
+            ErrorUtilities.VerifyThrowInternalNull(project, nameof(project));
+            ErrorUtilities.VerifyThrowInternalNull(document, nameof(document));
 
             _document = document;
             _project = project;
@@ -229,7 +229,6 @@ private ProjectPropertyGroupElement ParseProjectPropertyGroupElement(XmlElementW
             return propertyGroup;
         }
 
-
         /// <summary>
         /// Parse a ProjectItemGroupElement
         /// </summary>
@@ -688,7 +687,7 @@ private ProjectOutputElement ParseProjectOutputElement(XmlElementWithLocation el
 
             ProjectErrorUtilities.VerifyThrowInvalidProject
             (
-                String.IsNullOrWhiteSpace(itemNameAttribute?.Value) && !String.IsNullOrWhiteSpace(propertyNameAttribute?.Value) || !String.IsNullOrWhiteSpace(itemNameAttribute?.Value) && String.IsNullOrWhiteSpace(propertyNameAttribute?.Value),
+                (String.IsNullOrWhiteSpace(itemNameAttribute?.Value) && !String.IsNullOrWhiteSpace(propertyNameAttribute?.Value)) || (!String.IsNullOrWhiteSpace(itemNameAttribute?.Value) && String.IsNullOrWhiteSpace(propertyNameAttribute?.Value)),
                 element.Location,
                 "InvalidTaskOutputSpecification",
                 parent.Name
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index 1cba0713bb1..b75de665c00 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -131,8 +131,6 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO
             LoadProjectsReadOnly = loadProjectsReadOnly;
         }
 
-
-
         /// <summary>
         /// Returns an existing ProjectRootElement for the specified file path, if any.
         /// If none exists, calls the provided delegate to load one, and adds that to the cache.
@@ -268,7 +266,7 @@ internal override void RenameEntry(string oldFullPath, ProjectRootElement projec
         {
             lock (_locker)
             {
-                ErrorUtilities.VerifyThrowArgumentLength(oldFullPath, "oldFullPath");
+                ErrorUtilities.VerifyThrowArgumentLength(oldFullPath, nameof(oldFullPath));
                 RenameEntryInternal(oldFullPath, projectRootElement);
             }
         }
@@ -396,7 +394,7 @@ internal override void DiscardImplicitReferences()
         /// </remarks>
         internal override void DiscardAnyWeakReference(ProjectRootElement projectRootElement)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, "projectRootElement");
+            ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, nameof(projectRootElement));
 
             // A PRE may be unnamed if it was only used in memory.
             if (projectRootElement.FullPath != null)
diff --git a/src/Build/Evaluation/ProjectStringCache.cs b/src/Build/Evaluation/ProjectStringCache.cs
index 08a80cf42ea..3413404d5aa 100644
--- a/src/Build/Evaluation/ProjectStringCache.cs
+++ b/src/Build/Evaluation/ProjectStringCache.cs
@@ -128,7 +128,7 @@ public string Get(string key)
         {
             lock (_locker)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(key, "key");
+                ErrorUtilities.VerifyThrowArgumentNull(key, nameof(key));
 
                 if (key.Length == 0)
                 {
@@ -155,7 +155,7 @@ public void Clear(XmlDocument document)
         {
             lock (_locker)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(document, "document");
+                ErrorUtilities.VerifyThrowArgumentNull(document, nameof(document));
 
                 VerifyState();
 
@@ -215,7 +215,7 @@ private void VerifyState()
         /// </remarks>
         private void OnStrongCacheEntryRemoved(object sender, ProjectRootElement projectRootElement)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, "projectRootElement");
+            ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, nameof(projectRootElement));
             Clear(projectRootElement.XmlDocument);
         }
 
diff --git a/src/Build/Evaluation/ProjectXmlChangedEventArgs.cs b/src/Build/Evaluation/ProjectXmlChangedEventArgs.cs
index e16bb5fd0fc..529c07069be 100644
--- a/src/Build/Evaluation/ProjectXmlChangedEventArgs.cs
+++ b/src/Build/Evaluation/ProjectXmlChangedEventArgs.cs
@@ -32,7 +32,7 @@ public class ProjectXmlChangedEventArgs : EventArgs
         /// <param name="formattingParameter">The formatting parameter to use with <paramref name="unformattedReason"/>.</param>
         internal ProjectXmlChangedEventArgs(ProjectRootElement projectXml, string unformattedReason, string formattingParameter)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectXml, "projectXml");
+            ErrorUtilities.VerifyThrowArgumentNull(projectXml, nameof(projectXml));
 
             this.ProjectXml = projectXml;
             _unformattedReason = unformattedReason;
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index 5d9b15567be..0630cd6407b 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -38,6 +38,7 @@ internal class PropertyTrackingEvaluatorDataWrapper<P, I, M, D> : IEvaluatorData
         /// </summary>
         /// <param name="dataToWrap">The underlying <see cref="IEvaluatorData{P,I,M,D}"/> to wrap for property tracking.</param>
         /// <param name="evaluationLoggingContext">The <see cref="EvaluationLoggingContext"/> used to log relevant events.</param>
+        /// <param name="settingValue">Property tracking setting value</param>
         public PropertyTrackingEvaluatorDataWrapper(IEvaluatorData<P, I, M, D> dataToWrap, EvaluationLoggingContext evaluationLoggingContext, int settingValue)
         {
             ErrorUtilities.VerifyThrowInternalNull(dataToWrap, nameof(dataToWrap));
diff --git a/src/Build/Evaluation/SimpleProjectRootElementCache.cs b/src/Build/Evaluation/SimpleProjectRootElementCache.cs
index 979f7e5de03..6890d8bd75b 100644
--- a/src/Build/Evaluation/SimpleProjectRootElementCache.cs
+++ b/src/Build/Evaluation/SimpleProjectRootElementCache.cs
@@ -113,7 +113,7 @@ internal override void DiscardImplicitReferences()
 
         internal override void DiscardAnyWeakReference(ProjectRootElement projectRootElement)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, "projectRootElement");
+            ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, nameof(projectRootElement));
 
             // A PRE may be unnamed if it was only used in memory.
             if (projectRootElement.FullPath != null)
diff --git a/src/Build/Evaluation/StringMetadataTable.cs b/src/Build/Evaluation/StringMetadataTable.cs
index 2cd255fc62d..13161dd15d1 100644
--- a/src/Build/Evaluation/StringMetadataTable.cs
+++ b/src/Build/Evaluation/StringMetadataTable.cs
@@ -73,7 +73,7 @@ public string GetEscapedValueIfPresent(string itemType, string name)
                 key = itemType + "." + name;
             }
 
-            string value = null;
+            string value;
             _metadata.TryGetValue(key, out value);
 
             return value;
diff --git a/src/Build/Evaluation/ToolsetProvider.cs b/src/Build/Evaluation/ToolsetProvider.cs
index af6143d9bff..c45a4d25034 100644
--- a/src/Build/Evaluation/ToolsetProvider.cs
+++ b/src/Build/Evaluation/ToolsetProvider.cs
@@ -64,7 +64,7 @@ private ToolsetProvider(ITranslator translator)
         /// </summary>
         public Toolset GetToolset(string toolsVersion)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, "toolsVersion");
+            ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, nameof(toolsVersion));
             _toolsets.TryGetValue(toolsVersion, out var toolset);
 
             return toolset;
diff --git a/src/Build/FileSystem/MSBuildFileSystemAdapter.cs b/src/Build/FileSystem/MSBuildFileSystemAdapter.cs
new file mode 100644
index 00000000000..4c69284d955
--- /dev/null
+++ b/src/Build/FileSystem/MSBuildFileSystemAdapter.cs
@@ -0,0 +1,54 @@
+Ôªø// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using Microsoft.Build.Shared.FileSystem;
+
+namespace Microsoft.Build.FileSystem
+{
+     internal class MSBuildFileSystemAdapter : IFileSystem
+    {
+        private readonly MSBuildFileSystemBase _msbuildFileSystem;
+        public MSBuildFileSystemAdapter(MSBuildFileSystemBase msbuildFileSystem)
+        {
+            _msbuildFileSystem = msbuildFileSystem;
+        }
+        public TextReader ReadFile(string path) => _msbuildFileSystem.ReadFile(path);
+
+        public Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share) => _msbuildFileSystem.GetFileStream(path, mode, access, share);
+
+        public string ReadFileAllText(string path) => _msbuildFileSystem.ReadFileAllText(path);
+
+        public byte[] ReadFileAllBytes(string path) => _msbuildFileSystem.ReadFileAllBytes(path);
+
+        public IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
+        {
+            return _msbuildFileSystem.EnumerateFiles(path, searchPattern, searchOption);
+        }
+
+        public IEnumerable<string> EnumerateDirectories(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
+        {
+            return _msbuildFileSystem.EnumerateDirectories(path, searchPattern, searchOption);
+        }
+
+        public IEnumerable<string> EnumerateFileSystemEntries(
+            string path,
+            string searchPattern = "*",
+            SearchOption searchOption = SearchOption.TopDirectoryOnly)
+        {
+            return _msbuildFileSystem.EnumerateFileSystemEntries(path, searchPattern, searchOption);
+        }
+
+        public FileAttributes GetAttributes(string path) => _msbuildFileSystem.GetAttributes(path);
+
+        public DateTime GetLastWriteTimeUtc(string path) => _msbuildFileSystem.GetLastWriteTimeUtc(path);
+
+        public bool DirectoryExists(string path) => _msbuildFileSystem.DirectoryExists(path);
+
+        public bool FileExists(string path) => _msbuildFileSystem.FileExists(path);
+
+        public bool DirectoryEntryExists(string path) => _msbuildFileSystem.FileOrDirectoryExists(path);
+    }
+}
diff --git a/src/Build/FileSystem/MSBuildFileSystemBase.cs b/src/Build/FileSystem/MSBuildFileSystemBase.cs
new file mode 100644
index 00000000000..5383e717a9b
--- /dev/null
+++ b/src/Build/FileSystem/MSBuildFileSystemBase.cs
@@ -0,0 +1,79 @@
+Ôªø// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+
+namespace Microsoft.Build.FileSystem
+{
+    /// <summary>
+    /// Abstracts away some file system operations.
+    ///
+    /// Implementations:
+    /// - must be thread safe
+    /// - may cache some or all the calls.
+    /// </summary>
+    public abstract class MSBuildFileSystemBase
+    {
+        /// <summary>
+        /// Use this for var sr = new StreamReader(path)
+        /// </summary>
+        public abstract TextReader ReadFile(string path);
+
+        /// <summary>
+        /// Use this for new FileStream(path, mode, access, share)
+        /// </summary>
+        public abstract Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share);
+
+        /// <summary>
+        /// Use this for File.ReadAllText(path)
+        /// </summary>
+        public abstract string ReadFileAllText(string path);
+
+        /// <summary>
+        /// Use this for File.ReadAllBytes(path)
+        /// </summary>
+        public abstract byte[] ReadFileAllBytes(string path);
+
+        /// <summary>
+        /// Use this for Directory.EnumerateFiles(path, pattern, option)
+        /// </summary>
+        public abstract IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly);
+
+        /// <summary>
+        /// Use this for Directory.EnumerateFolders(path, pattern, option)
+        /// </summary>
+        public abstract IEnumerable<string> EnumerateDirectories(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly);
+
+        /// <summary>
+        /// Use this for Directory.EnumerateFileSystemEntries(path, pattern, option)
+        /// </summary>
+        public abstract IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly);
+
+        /// <summary>
+        /// Use this for File.GetAttributes()
+        /// </summary>
+        public abstract FileAttributes GetAttributes(string path);
+
+        /// <summary>
+        /// Use this for File.GetLastWriteTimeUtc(path)
+        /// </summary>
+        public abstract DateTime GetLastWriteTimeUtc(string path);
+
+        /// <summary>
+        /// Use this for Directory.Exists(path)
+        /// </summary>
+        public abstract bool DirectoryExists(string path);
+
+        /// <summary>
+        /// Use this for File.Exists(path)
+        /// </summary>
+        public abstract bool FileExists(string path);
+
+        /// <summary>
+        /// Use this for File.Exists(path) || Directory.Exists(path)
+        /// </summary>
+        public abstract bool FileOrDirectoryExists(string path);
+    }
+}
diff --git a/src/Build/Globbing/MSBuildGlob.cs b/src/Build/Globbing/MSBuildGlob.cs
index bab387bc147..6eb35e81b52 100644
--- a/src/Build/Globbing/MSBuildGlob.cs
+++ b/src/Build/Globbing/MSBuildGlob.cs
@@ -5,6 +5,7 @@
 using System;
 using System.IO;
 using System.Text.RegularExpressions;
+using Microsoft.Build.Collections;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Globbing
@@ -18,7 +19,7 @@ namespace Microsoft.Build.Globbing
     /// </summary>
     public class MSBuildGlob : IMSBuildGlob
     {
-        private struct GlobState
+        private readonly struct GlobState
         {
             public string GlobRoot { get; }
             public string FileSpec { get; }
@@ -44,11 +45,15 @@ public GlobState(string globRoot, string fileSpec, bool isLegal, string fixedDir
             }
         }
 
+        // Cache of Regex objects that we have created and are still alive.
+        private static WeakValueDictionary<string, Regex> s_regexCache = new WeakValueDictionary<string, Regex>();
+
         private readonly Lazy<GlobState> _state;
 
         internal string TestOnlyGlobRoot => _state.Value.GlobRoot;
         internal string TestOnlyFileSpec => _state.Value.FileSpec;
         internal bool TestOnlyNeedsRecursion => _state.Value.NeedsRecursion;
+        internal Regex TestOnlyRegex => _state.Value.Regex;
 
         /// <summary>
         ///     The fixed directory part.
@@ -141,7 +146,7 @@ private string NormalizeMatchInput(string stringToMatch)
             // Ensure trailing slash because the fixed directory part has a trailing slash.
             if (stringToMatch == string.Empty)
             {
-                normalizedInput = normalizedInput + Path.DirectorySeparatorChar;
+                normalizedInput += Path.DirectorySeparatorChar;
             }
 
             return normalizedInput;
@@ -198,11 +203,28 @@ public static MSBuildGlob Parse(string globRoot, string fileSpec)
                         return (normalizedFixedPart, wildcardDirPart, filePart);
                     });
 
-                // compile the regex since it's expected to be used multiple times
-                var regex = isLegalFileSpec
-                    ? new Regex(matchFileExpression, FileMatcher.DefaultRegexOptions | RegexOptions.Compiled)
-                    : null;
+                Regex regex = null;
+                if (isLegalFileSpec)
+                {
+                    lock (s_regexCache)
+                    {
+                        s_regexCache.TryGetValue(matchFileExpression, out regex);
+                    }
 
+                    if (regex == null)
+                    {
+                        // compile the regex since it's expected to be used multiple times
+                        Regex newRegex = new Regex(matchFileExpression, FileMatcher.DefaultRegexOptions | RegexOptions.Compiled);
+                        lock (s_regexCache)
+                        {
+                            if (!s_regexCache.TryGetValue(matchFileExpression, out regex))
+                            {
+                                s_regexCache[matchFileExpression] = newRegex;
+                            }
+                        }
+                        regex ??= newRegex;
+                    }
+                }
                 return new GlobState(globRoot, fileSpec, isLegalFileSpec, fixedDirectoryPart, wildcardDirectoryPart, filenamePart, matchFileExpression, needsRecursion, regex);
             },
             true);
@@ -216,9 +238,7 @@ private static string NormalizeTheFixedDirectoryPartAgainstTheGlobRoot(string fi
             // concatenate the glob parent to the fixed dir part
             var parentedFixedPart = Path.Combine(globRoot, fixedDirPart);
             var normalizedFixedPart = FileUtilities.GetFullPathNoThrow(parentedFixedPart);
-            normalizedFixedPart = normalizedFixedPart.WithTrailingSlash();
-
-            return normalizedFixedPart;
+            return normalizedFixedPart.WithTrailingSlash();
         }
 
         /// <summary>
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 546fcc45a68..69bb676cedc 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -347,7 +347,6 @@ IReadOnlyDictionary<string, IReadOnlyCollection<string>> GetSolutionDependencies
                     solutionDependencies[FileUtilities.NormalizePath(projectWithDependencies.AbsolutePath)] = projectWithDependencies.Dependencies.Select(
                         dependencyGuid =>
                         {
-
                             // code snippet cloned from SolutionProjectGenerator.AddPropertyGroupForSolutionConfiguration
 
                             if (!solutionFile.ProjectsByGuid.TryGetValue(dependencyGuid, out var dependencyProject))
@@ -576,8 +575,7 @@ internal static string FormatCircularDependencyError(List<string> projectsInCycl
                 if (i != 0)
                 {
                     errorMessage.Append(projectsInCycle[i])
-                        .Append(" ->")
-                        .AppendLine();
+                        .AppendLine(" ->");
                 }
                 else
                 {
diff --git a/src/Build/Graph/ProjectGraph.cs b/src/Build/Graph/ProjectGraph.cs
index f304a90ad46..74939362600 100644
--- a/src/Build/Graph/ProjectGraph.cs
+++ b/src/Build/Graph/ProjectGraph.cs
@@ -177,7 +177,6 @@ public ProjectGraph(IEnumerable<string> entryProjectFiles, ProjectCollection pro
         ///     If a null reference is returned from <paramref name="projectInstanceFactory" />, the InnerException contains
         ///     <see cref="InvalidOperationException" />
         /// </exception>
-        /// </exception>
         public ProjectGraph(string entryProjectFile, ProjectCollection projectCollection, ProjectInstanceFactoryFunc projectInstanceFactory)
             : this(new ProjectGraphEntryPoint(entryProjectFile).AsEnumerable(), projectCollection, projectInstanceFactory)
         {
@@ -502,13 +501,13 @@ internal string ToDot(Func<ProjectGraphNode, string> nodeIdProvider)
                     node.ProjectInstance.GlobalProperties.OrderBy(kvp => kvp.Key)
                         .Select(kvp => $"{kvp.Key}={kvp.Value}"));
 
-                sb.AppendLine($"\t{nodeId} [label=<{nodeName}<br/>{globalPropertiesString}>]");
+                sb.Append('\t').Append(nodeId).Append(" [label=<").Append(nodeName).Append("<br/>").Append(globalPropertiesString).AppendLine(">]");
 
                 foreach (var reference in node.ProjectReferences)
                 {
                     var referenceId = nodeIds.GetOrAdd(reference, (n, idProvider) => idProvider(n), nodeIdProvider);
 
-                    sb.AppendLine($"\t{nodeId} -> {referenceId}");
+                    sb.Append('\t').Append(nodeId).Append(" -> ").AppendLine(referenceId);
                 }
             }
 
@@ -763,7 +762,7 @@ public bool Equals(ProjectGraphBuildRequest other)
 
             public override bool Equals(object obj)
             {
-                return !ReferenceEquals(null, obj) && obj is ProjectGraphBuildRequest graphNodeWithTargets && Equals(graphNodeWithTargets);
+                return !(obj is null) && obj is ProjectGraphBuildRequest graphNodeWithTargets && Equals(graphNodeWithTargets);
             }
 
             public override int GetHashCode()
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index cd9b85686e5..ae88e1064b0 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -423,17 +423,13 @@ public static TargetsToPropagate FromProjectAndEntryTargets(ProjectInstance proj
 
             public ImmutableList<string> GetApplicableTargetsForReference(ProjectInstance reference)
             {
-                switch (GetProjectType(reference))
+                return (GetProjectType(reference)) switch
                 {
-                    case ProjectType.InnerBuild:
-                        return _allTargets;
-                    case ProjectType.OuterBuild:
-                        return _outerBuildTargets;
-                    case ProjectType.NonMultitargeting:
-                        return _allTargets;
-                    default:
-                        throw new ArgumentOutOfRangeException();
-                }
+                    ProjectType.InnerBuild => _allTargets,
+                    ProjectType.OuterBuild => _outerBuildTargets,
+                    ProjectType.NonMultitargeting => _allTargets,
+                    _ => throw new ArgumentOutOfRangeException(),
+                };
             }
         }
 
diff --git a/src/Build/Instance/HostServices.cs b/src/Build/Instance/HostServices.cs
index 8c820643d32..7df873024fc 100644
--- a/src/Build/Instance/HostServices.cs
+++ b/src/Build/Instance/HostServices.cs
@@ -67,9 +67,9 @@ public class HostServices : ITranslatable
         /// </summary>
         public ITaskHost GetHostObject(string projectFile, string targetName, string taskName)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentNull(targetName, "targetName");
-            ErrorUtilities.VerifyThrowArgumentNull(taskName, "taskName");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentNull(targetName, nameof(targetName));
+            ErrorUtilities.VerifyThrowArgumentNull(taskName, nameof(taskName));
 
             HostObjects hostObjects;
             if (_hostObjectMap == null || !_hostObjectMap.TryGetValue(projectFile, out hostObjects))
@@ -121,16 +121,25 @@ public ITaskHost GetHostObject(string projectFile, string targetName, string tas
         /// </summary>
         public void RegisterHostObject(string projectFile, string targetName, string taskName, ITaskHost hostObject)
         {
+
+/* Unmerged change from project 'Microsoft.Build (netcoreapp2.1)'
+Before:
             ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile");
             ErrorUtilities.VerifyThrowArgumentNull(targetName, "targetName");
-            ErrorUtilities.VerifyThrowArgumentNull(taskName, "taskName");
+After:
+            ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile));
+            ErrorUtilities.VerifyThrowArgumentNull(targetName, "targetName));
+*/
+            ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentNull(targetName, nameof(targetName));
+            ErrorUtilities.VerifyThrowArgumentNull(taskName, nameof(taskName));
 
             // We can only set the host object to a non-null value if the affinity for the project is not out of proc, or if it is, it is only implicitly
             // out of proc, in which case it will become in-proc after this call completes.  See GetNodeAffinity.
             bool isExplicit;
-            bool hasExplicitOutOfProcAffinity = (GetNodeAffinity(projectFile, out isExplicit) == NodeAffinity.OutOfProc) && (isExplicit == true);
+            bool hasExplicitOutOfProcAffinity = (GetNodeAffinity(projectFile, out isExplicit) == NodeAffinity.OutOfProc) && isExplicit;
             ErrorUtilities.VerifyThrowInvalidOperation(!hasExplicitOutOfProcAffinity || hostObject == null, "InvalidHostObjectOnOutOfProcProject");
-            _hostObjectMap = _hostObjectMap ?? new Dictionary<string, HostObjects>(StringComparer.OrdinalIgnoreCase);
+            _hostObjectMap ??= new Dictionary<string, HostObjects>(StringComparer.OrdinalIgnoreCase);
 
             HostObjects hostObjects = GetHostObjectsFromMapByKeyOrCreateNew(projectFile);
 
@@ -148,15 +157,18 @@ public void RegisterHostObject(string projectFile, string targetName, string tas
         /// Register and unregister from ROT.
         /// Ensure the host object has appropriate COM interface that can be used in task.
         /// </summary>
+        /// <param name="projectFile">project file name</param>
+        /// <param name="targetName">target name</param>
+        /// <param name="taskName">task name</param>
         /// <param name="monikerName">the Moniker used to register host object in ROT</param>
         public void RegisterHostObject(string projectFile, string targetName, string taskName, string monikerName)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentNull(targetName, "targetName");
-            ErrorUtilities.VerifyThrowArgumentNull(taskName, "taskName");
-            ErrorUtilities.VerifyThrowArgumentNull(monikerName, "monikerName");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentNull(targetName, nameof(targetName));
+            ErrorUtilities.VerifyThrowArgumentNull(taskName, nameof(taskName));
+            ErrorUtilities.VerifyThrowArgumentNull(monikerName, nameof(monikerName));
 
-            _hostObjectMap = _hostObjectMap ?? new Dictionary<string, HostObjects>(StringComparer.OrdinalIgnoreCase);
+            _hostObjectMap ??= new Dictionary<string, HostObjects>(StringComparer.OrdinalIgnoreCase);
 
             HostObjects hostObjects = GetHostObjectsFromMapByKeyOrCreateNew(projectFile);
 
@@ -171,12 +183,12 @@ public void UnregisterProject(string projectFullPath)
         {
             if (projectFullPath != null)
             {
-                if (_hostObjectMap != null && _hostObjectMap.ContainsKey(projectFullPath))
+                if (_hostObjectMap?.ContainsKey(projectFullPath) == true)
                 {
                     _hostObjectMap.Remove(projectFullPath);
                 }
 
-                if (_projectAffinities != null && _projectAffinities.ContainsKey(projectFullPath))
+                if (_projectAffinities?.ContainsKey(projectFullPath) == true)
                 {
                     _projectAffinities.Remove(projectFullPath);
                 }
@@ -271,8 +283,7 @@ private NodeAffinity GetNodeAffinity(string projectFile, out bool isExplicit)
             // Now see if a specific affinity has been provided.
             if (_projectAffinities != null)
             {
-                NodeAffinity affinity = NodeAffinity.Any;
-
+                NodeAffinity affinity;
                 if (_projectAffinities.TryGetValue(projectFile, out affinity))
                 {
                     isExplicit = true;
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index cff4feb6b66..f6de1df07f3 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -62,7 +62,7 @@ public enum ProjectInstanceSettings
     /// and call it several times to build it.
     /// </summary>
     /// <comments>
-    /// Neither this class nor none of its constituents are allowed to have 
+    /// Neither this class nor none of its constituents are allowed to have
     /// references to any of the Construction or Evaluation objects.
     /// This class is immutable except for adding instance items and setting instance properties.
     /// It only exposes items and properties: targets, host services, and the task registry are not exposed as they are only the concern of build.
@@ -100,7 +100,7 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
         private PropertyDictionary<ProjectPropertyInstance> _globalProperties;
 
         /// <summary>
-        /// List of names of the properties that, while global, are still treated as overridable 
+        /// List of names of the properties that, while global, are still treated as overridable
         /// </summary>
         private ISet<string> _globalPropertiesToTreatAsLocal;
 
@@ -134,7 +134,7 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
         /// The project's root directory, for evaluation of relative paths and
         /// setting the current directory during build.
         /// Is never null.
-        /// If the project has not been loaded from disk and has not been given a path, returns the current directory from 
+        /// If the project has not been loaded from disk and has not been given a path, returns the current directory from
         /// the time the project was loaded - this is the same behavior as Whidbey/Orcas.
         /// If the project has not been loaded from disk but has been given a path, this path may not exist.
         /// </summary>
@@ -158,7 +158,7 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
         private HostServices _hostServices;
 
         /// <summary>
-        /// Whether when we read a ToolsVersion that is not equivalent to the current one on the Project tag, we 
+        /// Whether when we read a ToolsVersion that is not equivalent to the current one on the Project tag, we
         /// treat it as the current one.
         /// </summary>
         private bool _usingDifferentToolsVersionFromProjectFile;
@@ -182,7 +182,6 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
         private bool _translateEntireState;
         private int _evaluationId = BuildEventContext.InvalidEvaluationId;
 
-
         /// <summary>
         /// Creates a ProjectInstance directly.
         /// No intermediate Project object is created.
@@ -259,12 +258,13 @@ public ProjectInstance(string projectFile, IDictionary<string, string> globalPro
         /// <param name="toolsVersion">The tools version.</param>
         /// <param name="subToolsetVersion">The sub-toolset version, used in tandem with the ToolsVersion to determine the set of toolset properties.</param>
         /// <param name="projectCollection">Project collection</param>
+        /// <param name="projectLoadSettings">Project load settings</param>
         /// <param name="evaluationContext">The context to use for evaluation.</param>
         /// <returns>A new project instance</returns>
         private ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, "toolsVersion");
+            ErrorUtilities.VerifyThrowArgumentLength(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
 
             // We do not control the current directory at this point, but assume that if we were
             // passed a relative path, the caller assumes we will prepend the current directory.
@@ -340,6 +340,7 @@ public ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globa
         /// <param name="toolsVersion">The tools version.</param>
         /// <param name="subToolsetVersion">The sub-toolset version, used in tandem with the ToolsVersion to determine the set of toolset properties.</param>
         /// <param name="projectCollection">Project collection</param>
+        /// <param name="projectLoadSettings">Project load settings</param>
         /// <param name="evaluationContext">The context to use for evaluation.</param>
         /// <returns>A new project instance</returns>
         private ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext)
@@ -398,8 +399,8 @@ internal ProjectInstance(string projectFile, ProjectInstance projectToInheritFro
         /// This is ideal if the project is simply going to be built, and not displayed or edited.
         /// Global properties may be null.
         /// Tools version may be null.
-        /// Used by SolutionProjectGenerator so that it can explicitly pass the vsVersionFromSolution in for use in 
-        /// determining the sub-toolset version. 
+        /// Used by SolutionProjectGenerator so that it can explicitly pass the vsVersionFromSolution in for use in
+        /// determining the sub-toolset version.
         /// </summary>
         /// <param name="xml">The project root element</param>
         /// <param name="globalProperties">The global properties to use.</param>
@@ -422,9 +423,9 @@ internal ProjectInstance(ProjectRootElement xml, IDictionary<string, string> glo
         /// </summary>
         internal ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext buildEventContext, ISdkResolverService sdkResolverService, int submissionId, ProjectLoadSettings? projectLoadSettings)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, "toolsVersion");
-            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, "buildParameters");
+            ErrorUtilities.VerifyThrowArgumentLength(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
+            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, nameof(buildParameters));
 
             ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(projectFile, globalProperties, toolsVersion, buildParameters.ProjectRootElementCache, false /*Not explicitly loaded*/);
 
@@ -438,9 +439,9 @@ internal ProjectInstance(string projectFile, IDictionary<string, string> globalP
         /// </summary>
         internal ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext buildEventContext, ISdkResolverService sdkResolverService, int submissionId)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(xml, "xml");
-            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, "toolsVersion");
-            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, "buildParameters");
+            ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
+            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
+            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, nameof(buildParameters));
             Initialize(xml, globalProperties, toolsVersion, null, 0 /* no solution version specified */, buildParameters, loggingService, buildEventContext, sdkResolverService, submissionId);
         }
 
@@ -450,14 +451,14 @@ internal ProjectInstance(ProjectRootElement xml, IDictionary<string, string> glo
         /// </summary>
         internal ProjectInstance(Evaluation.Project.Data data, string directory, string fullPath, HostServices hostServices, PropertyDictionary<ProjectPropertyInstance> environmentVariableProperties, ProjectInstanceSettings settings)
         {
-            ErrorUtilities.VerifyThrowInternalNull(data, "data");
-            ErrorUtilities.VerifyThrowInternalLength(directory, "directory");
-            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(fullPath, "fullPath");
+            ErrorUtilities.VerifyThrowInternalNull(data, nameof(data));
+            ErrorUtilities.VerifyThrowInternalLength(directory, nameof(directory));
+            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(fullPath, nameof(fullPath));
 
             _directory = directory;
             _projectFileLocation = ElementLocation.Create(fullPath);
             _hostServices = hostServices;
-            
+
             EvaluationId = data.EvaluationId;
 
             var immutable = (settings & ProjectInstanceSettings.Immutable) == ProjectInstanceSettings.Immutable;
@@ -789,7 +790,7 @@ public List<ProjectItemElement> EvaluatedItemElements
 
         /// <summary>
         /// Serialize the entire project instance state.
-        /// 
+        ///
         /// When false, only a part of the project instance state is serialized (properties and items).
         /// In this case out of proc nodes re-evaluate the project instance from disk to obtain the un-serialized state.
         /// This partial state recombination may lead to build issues when the project instance state differs from what is on disk.
@@ -798,12 +799,12 @@ public bool TranslateEntireState
         {
             get
             {
-                switch (Traits.Instance.EscapeHatches.ProjectInstanceTranslation)
+                return Traits.Instance.EscapeHatches.ProjectInstanceTranslation switch
                 {
-                    case EscapeHatches.ProjectInstanceTranslationMode.Full: return true;
-                    case EscapeHatches.ProjectInstanceTranslationMode.Partial: return false;
-                    default: return _translateEntireState;
-                }
+                    EscapeHatches.ProjectInstanceTranslationMode.Full => true,
+                    EscapeHatches.ProjectInstanceTranslationMode.Partial => false,
+                    _ => _translateEntireState,
+                };
             }
 
             set
@@ -817,7 +818,7 @@ public bool TranslateEntireState
 
         /// <summary>
         /// The ID of the evaluation that produced this ProjectInstance.
-        /// 
+        ///
         /// See <see cref="Project.LastEvaluationId"/>.
         /// </summary>
         public int EvaluationId
@@ -919,7 +920,7 @@ public bool IsImmutable
         }
 
         /// <summary>
-        /// Task classes and locations known to this project. 
+        /// Task classes and locations known to this project.
         /// This is the project-specific task registry, which is consulted before
         /// the toolset's task registry.
         /// Only set during evaluation, so does not check for immutability.
@@ -944,7 +945,7 @@ Toolset IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMeta
 
         /// <summary>
         /// The sub-toolset version we should use during the build, used to determine which set of sub-toolset
-        /// properties we should merge into this toolset. 
+        /// properties we should merge into this toolset.
         /// </summary>
         string IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SubToolsetVersion
         {
@@ -983,7 +984,7 @@ PropertyDictionary<ProjectPropertyInstance> IEvaluatorData<ProjectPropertyInstan
         }
 
         /// <summary>
-        /// List of names of the properties that, while global, are still treated as overridable 
+        /// List of names of the properties that, while global, are still treated as overridable
         /// </summary>
         ISet<string> IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.GlobalPropertiesToTreatAsLocal
         {
@@ -1166,7 +1167,7 @@ internal bool ExplicitToolsVersionSpecified
 
         /// <summary>
         /// The sub-toolset version we should use during the build, used to determine which set of sub-toolset
-        /// properties we should merge into this toolset. 
+        /// properties we should merge into this toolset.
         /// </summary>
         internal string SubToolsetVersion
         {
@@ -1199,7 +1200,7 @@ internal ItemDictionary<ProjectItemInstance> ItemsToBuildWith
         }
 
         /// <summary>
-        /// Task classes and locations known to this project. 
+        /// Task classes and locations known to this project.
         /// This is the project-specific task registry, which is consulted before
         /// the toolset's task registry.
         /// </summary>
@@ -1213,7 +1214,7 @@ internal TaskRegistry TaskRegistry
         }
 
         /// <summary>
-        /// Number of targets in the project. 
+        /// Number of targets in the project.
         /// </summary>
         internal int TargetsCount
         {
@@ -1237,7 +1238,7 @@ internal ProjectRootElementCacheBase ProjectRootElementCache
         [SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "IItem is an internal interface; this is less confusing to outside customers. ")]
         public static string GetEvaluatedItemIncludeEscaped(ProjectItemInstance item)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(item, "item");
+            ErrorUtilities.VerifyThrowArgumentNull(item, nameof(item));
 
             return ((IItem)item).EvaluatedIncludeEscaped;
         }
@@ -1247,38 +1248,38 @@ public static string GetEvaluatedItemIncludeEscaped(ProjectItemInstance item)
         /// </summary>
         public static string GetEvaluatedItemIncludeEscaped(ProjectItemDefinitionInstance item)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(item, "item");
+            ErrorUtilities.VerifyThrowArgumentNull(item, nameof(item));
 
             return ((IItem)item).EvaluatedIncludeEscaped;
         }
 
         /// <summary>
-        /// Gets the escaped value of the provided metadatum. 
+        /// Gets the escaped value of the provided metadatum.
         /// </summary>
         public static string GetMetadataValueEscaped(ProjectMetadataInstance metadatum)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(metadatum, "metadatum");
+            ErrorUtilities.VerifyThrowArgumentNull(metadatum, nameof(metadatum));
 
             return metadatum.EvaluatedValueEscaped;
         }
 
         /// <summary>
-        /// Gets the escaped value of the metadatum with the provided name on the provided item. 
+        /// Gets the escaped value of the metadatum with the provided name on the provided item.
         /// </summary>
         [SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "IItem is an internal interface; this is less confusing to outside customers. ")]
         public static string GetMetadataValueEscaped(ProjectItemInstance item, string name)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(item, "item");
+            ErrorUtilities.VerifyThrowArgumentNull(item, nameof(item));
 
             return ((IItem)item).GetMetadataValueEscaped(name);
         }
 
         /// <summary>
-        /// Gets the escaped value of the metadatum with the provided name on the provided item definition. 
+        /// Gets the escaped value of the metadatum with the provided name on the provided item definition.
         /// </summary>
         public static string GetMetadataValueEscaped(ProjectItemDefinitionInstance item, string name)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(item, "item");
+            ErrorUtilities.VerifyThrowArgumentNull(item, nameof(item));
 
             return ((IItem)item).GetMetadataValueEscaped(name);
         }
@@ -1289,7 +1290,7 @@ public static string GetMetadataValueEscaped(ProjectItemDefinitionInstance item,
         [SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "IProperty is an internal interface; this is less confusing to outside customers. ")]
         public static string GetPropertyValueEscaped(ProjectPropertyInstance property)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(property, "property");
+            ErrorUtilities.VerifyThrowArgumentNull(property, nameof(property));
 
             return ((IProperty)property).EvaluatedValueEscaped;
         }
@@ -1362,7 +1363,7 @@ IItemDefinition<ProjectMetadataInstance> IEvaluatorData<ProjectPropertyInstance,
         /// <summary>
         /// Properties encountered during evaluation. These are read during the first evaluation pass.
         /// Unlike those returned by the Properties property, these are ordered, and include any properties that
-        /// were subsequently overridden by others with the same name. It does not include any 
+        /// were subsequently overridden by others with the same name. It does not include any
         /// properties whose conditions did not evaluate to true.
         /// </summary>
         /// <remarks>
@@ -1376,7 +1377,7 @@ void IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadat
         /// <summary>
         /// Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
         /// Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
-        /// were subsequently overridden by others with the same name and item type. It does not include any 
+        /// were subsequently overridden by others with the same name and item type. It does not include any
         /// elements whose conditions did not evaluate to true.
         /// </summary>
         /// <remarks>
@@ -1504,7 +1505,7 @@ ProjectPropertyInstance IPropertyProvider<ProjectPropertyInstance>.GetProperty(s
         }
 
         /// <summary>
-        /// Get the value of a property in this project, or 
+        /// Get the value of a property in this project, or
         /// an empty string if it does not exist.
         /// </summary>
         /// <remarks>
@@ -1512,7 +1513,7 @@ ProjectPropertyInstance IPropertyProvider<ProjectPropertyInstance>.GetProperty(s
         /// at all are not distinguished between by this method.
         /// This is because the build does not distinguish between the two.
         /// The reason this method exists when users can simply do GetProperty(..).EvaluatedValue,
-        /// is that the caller would have to check for null every time. For properties, empty and undefined are 
+        /// is that the caller would have to check for null every time. For properties, empty and undefined are
         /// not distinguished, so it much more useful to also have a method that returns empty string in
         /// either case.
         /// This function returns the unescaped value.
@@ -1551,9 +1552,9 @@ public ProjectPropertyInstance SetProperty(string name, string evaluatedValue)
         /// in use by another ProjectInstance.
         /// </remarks>
         /// <comments>
-        /// For purposes of declaring the project that defined this item (for use with e.g. the 
-        /// DeclaringProject* metadata), the entrypoint project is used for synthesized items 
-        /// like those added by this API. 
+        /// For purposes of declaring the project that defined this item (for use with e.g. the
+        /// DeclaringProject* metadata), the entrypoint project is used for synthesized items
+        /// like those added by this API.
         /// </comments>
         public ProjectItemInstance AddItem(string itemType, string evaluatedInclude)
         {
@@ -1574,9 +1575,9 @@ public ProjectItemInstance AddItem(string itemType, string evaluatedInclude)
         /// in use by another ProjectInstance.
         /// </remarks>
         /// <comments>
-        /// For purposes of declaring the project that defined this item (for use with e.g. the 
-        /// DeclaringProject* metadata), the entrypoint project is used for synthesized items 
-        /// like those added by this API. 
+        /// For purposes of declaring the project that defined this item (for use with e.g. the
+        /// DeclaringProject* metadata), the entrypoint project is used for synthesized items
+        /// like those added by this API.
         /// </comments>
         public ProjectItemInstance AddItem(string itemType, string evaluatedInclude, IEnumerable<KeyValuePair<string, string>> metadata)
         {
@@ -2105,10 +2106,10 @@ private void TranslateItems(ITranslator translator)
         /// </summary>
         internal static ProjectInstance[] LoadSolutionForBuild(string projectFile, PropertyDictionary<ProjectPropertyInstance> globalPropertiesInstances, string toolsVersion, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext projectBuildEventContext, bool isExplicitlyLoaded, IReadOnlyCollection<string> targetNames, ISdkResolverService sdkResolverService, int submissionId)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentNull(globalPropertiesInstances, "globalPropertiesInstances");
-            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, "toolsVersion");
-            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, "buildParameters");
+            ErrorUtilities.VerifyThrowArgumentLength(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentNull(globalPropertiesInstances, nameof(globalPropertiesInstances));
+            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
+            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, nameof(buildParameters));
             ErrorUtilities.VerifyThrow(FileUtilities.IsSolutionFilename(projectFile), "Project file {0} is not a solution.", projectFile);
 
             ProjectInstance[] projectInstances = null;
@@ -2214,7 +2215,7 @@ internal bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<
         {
             VerifyThrowNotImmutable();
 
-            if (null == targets)
+            if (targets == null)
             {
                 targets = Array.Empty<string>();
             }
@@ -2340,7 +2341,7 @@ internal ProjectTargetInstance AddTarget(
         {
             VerifyThrowNotImmutable();
 
-            ErrorUtilities.VerifyThrowInternalLength(targetName, "targetName");
+            ErrorUtilities.VerifyThrowInternalLength(targetName, nameof(targetName));
             ErrorUtilities.VerifyThrow(!_actualTargets.ContainsKey(targetName), "Target {0} already exists.", targetName);
 
             ProjectTargetInstance target = new ProjectTargetInstance
@@ -2437,8 +2438,8 @@ int submissionId
         }
 
         /// <summary>
-        /// Spawn the old engine to generate a solution wrapper project, so that our build ordering is somewhat more correct 
-        /// when solutions with toolsVersions &lt; 4.0 are passed to us. 
+        /// Spawn the old engine to generate a solution wrapper project, so that our build ordering is somewhat more correct
+        /// when solutions with toolsVersions &lt; 4.0 are passed to us.
         /// </summary>
         /// <comment>
         /// #############################################################################################
@@ -2597,12 +2598,12 @@ private void Initialize(
             ProjectLoadSettings? projectLoadSettings = null,
             EvaluationContext evaluationContext = null)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(xml, "xml");
+            ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(explicitToolsVersion, "toolsVersion");
-            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, "buildParameters");
+            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, nameof(buildParameters));
 
             _directory = xml.DirectoryPath;
-            _projectFileLocation = (xml.ProjectFileLocation != null) ? xml.ProjectFileLocation : ElementLocation.EmptyLocation;
+            _projectFileLocation = xml.ProjectFileLocation ?? ElementLocation.EmptyLocation;
             _properties = new PropertyDictionary<ProjectPropertyInstance>();
             _items = new ItemDictionary<ProjectItemInstance>();
             _actualTargets = new RetrievableEntryHashSet<ProjectTargetInstance>(StringComparer.OrdinalIgnoreCase);
@@ -2846,10 +2847,7 @@ private Dictionary<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(Evaluat
 
                 _items.Add(instance);
 
-                if (projectItemToInstanceMap != null)
-                {
-                    projectItemToInstanceMap.Add(item, instance);
-                }
+                projectItemToInstanceMap?.Add(item, instance);
             }
 
             return projectItemToInstanceMap;
diff --git a/src/Build/Instance/ProjectItemDefinitionInstance.cs b/src/Build/Instance/ProjectItemDefinitionInstance.cs
index 3d502f86f0e..7bc187939e1 100644
--- a/src/Build/Instance/ProjectItemDefinitionInstance.cs
+++ b/src/Build/Instance/ProjectItemDefinitionInstance.cs
@@ -35,11 +35,10 @@ public class ProjectItemDefinitionInstance : IKeyed, IMetadataTable, IItemDefini
         /// <summary>
         /// Constructs an empty project item definition instance.
         /// </summary>
-        /// <param name="projectInstance">The project instance to which this item definition belongs.</param>
         /// <param name="itemType">The type of item this definition object represents.</param>
         internal ProjectItemDefinitionInstance(string itemType)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(itemType, "itemType");
+            ErrorUtilities.VerifyThrowArgumentNull(itemType, nameof(itemType));
 
             _itemType = itemType;
         }
@@ -127,7 +126,7 @@ public IEnumerable<string> MetadataNames
         }
 
         /// <summary>
-        /// Implementation of IKeyed exposing the item type, so these 
+        /// Implementation of IKeyed exposing the item type, so these
         /// can be put in a dictionary conveniently.
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
@@ -143,7 +142,7 @@ string IKeyed.Key
         [DebuggerStepThrough]
         public ProjectMetadataInstance GetMetadata(string name)
         {
-            return (_metadata == null) ? null : _metadata[name];
+            return _metadata?[name];
         }
 
         #region IMetadataTable Members
@@ -198,7 +197,7 @@ string IMetadataTable.GetEscapedValueIfPresent(string specifiedItemType, string
         ProjectMetadataInstance IItemDefinition<ProjectMetadataInstance>.SetMetadata(ProjectMetadataElement xml, string evaluatedValue, ProjectMetadataInstance predecessor)
         {
             // No mutability check as this is used during creation (evaluation)
-            _metadata = _metadata ?? new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+            _metadata ??= new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
 
             ProjectMetadataInstance metadatum = new ProjectMetadataInstance(xml.Name, evaluatedValue);
             _metadata[xml.Name] = metadatum;
diff --git a/src/Build/Instance/ProjectItemGroupTaskInstance.cs b/src/Build/Instance/ProjectItemGroupTaskInstance.cs
index 839d7398ff8..a814b2c41c4 100644
--- a/src/Build/Instance/ProjectItemGroupTaskInstance.cs
+++ b/src/Build/Instance/ProjectItemGroupTaskInstance.cs
@@ -53,9 +53,9 @@ internal ProjectItemGroupTaskInstance
             List<ProjectItemGroupTaskItemInstance> items
             )
         {
-            ErrorUtilities.VerifyThrowInternalNull(condition, "condition");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
-            ErrorUtilities.VerifyThrowInternalNull(items, "items");
+            ErrorUtilities.VerifyThrowInternalNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
+            ErrorUtilities.VerifyThrowInternalNull(items, nameof(items));
 
             _condition = condition;
             _location = location;
diff --git a/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs b/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
index f33856ecb9e..dc80b36a405 100644
--- a/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
+++ b/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
@@ -50,6 +50,7 @@ public class ProjectItemGroupTaskItemInstance: ITranslatable
         /// </summary>
         private string _matchOnMetadataOptions;
 
+        /// <summary>
         /// The list of metadata to keep.
         /// </summary>
         private string _keepMetadata;
@@ -161,15 +162,15 @@ internal ProjectItemGroupTaskItemInstance
             List<ProjectItemGroupTaskMetadataInstance> metadata
             )
         {
-            ErrorUtilities.VerifyThrowInternalNull(itemType, "itemType");
-            ErrorUtilities.VerifyThrowInternalNull(include, "include");
-            ErrorUtilities.VerifyThrowInternalNull(exclude, "exclude");
-            ErrorUtilities.VerifyThrowInternalNull(remove, "remove");
-            ErrorUtilities.VerifyThrowInternalNull(keepMetadata, "keepMetadata");
-            ErrorUtilities.VerifyThrowInternalNull(removeMetadata, "removeMetadata");
-            ErrorUtilities.VerifyThrowInternalNull(keepDuplicates, "keepDuplicates");
-            ErrorUtilities.VerifyThrowInternalNull(condition, "condition");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
+            ErrorUtilities.VerifyThrowInternalNull(itemType, nameof(itemType));
+            ErrorUtilities.VerifyThrowInternalNull(include, nameof(include));
+            ErrorUtilities.VerifyThrowInternalNull(exclude, nameof(exclude));
+            ErrorUtilities.VerifyThrowInternalNull(remove, nameof(remove));
+            ErrorUtilities.VerifyThrowInternalNull(keepMetadata, nameof(keepMetadata));
+            ErrorUtilities.VerifyThrowInternalNull(removeMetadata, nameof(removeMetadata));
+            ErrorUtilities.VerifyThrowInternalNull(keepDuplicates, nameof(keepDuplicates));
+            ErrorUtilities.VerifyThrowInternalNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
 
             _itemType = itemType;
             _include = include;
@@ -196,7 +197,7 @@ List<ProjectItemGroupTaskMetadataInstance> metadata
 
         private ProjectItemGroupTaskItemInstance()
         {
-            
+
         }
 
         /// <summary>
diff --git a/src/Build/Instance/ProjectItemGroupTaskMetadataInstance.cs b/src/Build/Instance/ProjectItemGroupTaskMetadataInstance.cs
index 969940ed267..d8b5f0de745 100644
--- a/src/Build/Instance/ProjectItemGroupTaskMetadataInstance.cs
+++ b/src/Build/Instance/ProjectItemGroupTaskMetadataInstance.cs
@@ -50,10 +50,10 @@ public class ProjectItemGroupTaskMetadataInstance : ITranslatable
         /// </summary>
         internal ProjectItemGroupTaskMetadataInstance(string name, string value, string condition, ElementLocation location, ElementLocation conditionLocation)
         {
-            ErrorUtilities.VerifyThrowInternalNull(name, "name");
-            ErrorUtilities.VerifyThrowInternalNull(value, "value");
-            ErrorUtilities.VerifyThrowInternalNull(condition, "condition");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
+            ErrorUtilities.VerifyThrowInternalNull(name, nameof(name));
+            ErrorUtilities.VerifyThrowInternalNull(value, nameof(value));
+            ErrorUtilities.VerifyThrowInternalNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
 
             _name = name;
             _value = value;
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 972ba876609..716439edbf7 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -52,7 +52,7 @@ public class ProjectItemInstance : IKeyed, IItem<ProjectMetadataInstance>, ITask
         /// <summary>
         /// Constructor for items with no metadata.
         /// Include may be empty.
-        /// Called before the build when virtual items are added, 
+        /// Called before the build when virtual items are added,
         /// and during the build when tasks emit items.
         /// Mutability follows the project.
         /// </summary>
@@ -64,7 +64,7 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
         /// <summary>
         /// Constructor for items with no metadata.
         /// Include may be empty.
-        /// Called before the build when virtual items are added, 
+        /// Called before the build when virtual items are added,
         /// and during the build when tasks emit items.
         /// Mutability follows the project.
         /// </summary>
@@ -75,7 +75,7 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
 
         /// <summary>
         /// Constructor for items with metadata.
-        /// Called before the build when virtual items are added, 
+        /// Called before the build when virtual items are added,
         /// and during the build when tasks emit items.
         /// Include may be empty.
         /// Direct metadata may be null, indicating no metadata. It will be cloned.
@@ -106,7 +106,7 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
         {
             CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = null;
 
-            if (directMetadata != null && directMetadata.GetEnumerator().MoveNext())
+            if (directMetadata?.GetEnumerator().MoveNext() == true)
             {
                 metadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>(directMetadata.FastCountOrZero());
                 foreach (KeyValuePair<string, string> metadatum in directMetadata)
@@ -159,7 +159,7 @@ public ProjectInstance Project
         /// Item type, for example "Compile"
         /// </summary>
         /// <remarks>
-        /// This cannot be set, as it is used as the key into 
+        /// This cannot be set, as it is used as the key into
         /// the project's items table.
         /// </remarks>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
@@ -339,7 +339,7 @@ internal string ProjectFullPath
 
         /// <summary>
         /// Get any metadata in the item that has the specified name,
-        /// otherwise returns null. 
+        /// otherwise returns null.
         /// Includes any metadata inherited from item definitions.
         /// Includes any built-in metadata.
         /// </summary>
@@ -349,7 +349,7 @@ public ProjectMetadataInstance GetMetadata(string name)
         }
 
         /// <summary>
-        /// Get the value of a metadata on this item, or 
+        /// Get the value of a metadata on this item, or
         /// String.Empty if it does not exist or has no value.
         /// Includes any metadata inherited from item definitions and any built-in metadata.
         /// To determine whether a piece of metadata is actually present
@@ -416,7 +416,7 @@ public override string ToString()
         }
 
         /// <summary>
-        /// Get the value of a metadata on this item, or 
+        /// Get the value of a metadata on this item, or
         /// String.Empty if it does not exist or has no value.
         /// Includes any metadata inherited from item definitions and any built-in metadata.
         /// To determine whether a piece of metadata is actually present
@@ -466,7 +466,7 @@ string ITaskItem2.GetMetadataValueEscaped(string name)
         /// ITaskItem implementation
         /// </summary>
         /// <comments>
-        /// MetadataValue is assumed to be in its escaped form. 
+        /// MetadataValue is assumed to be in its escaped form.
         /// </comments>
         void ITaskItem.SetMetadata(string metadataName, string metadataValue)
         {
@@ -477,7 +477,7 @@ void ITaskItem.SetMetadata(string metadataName, string metadataValue)
         /// ITaskItem2 implementation
         /// </summary>
         /// <comments>
-        /// Assumes metadataValue is unescaped. 
+        /// Assumes metadataValue is unescaped.
         /// </comments>
         void ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue)
         {
@@ -627,7 +627,7 @@ internal void SetMetadata(CopyOnWritePropertyDictionary<ProjectMetadataInstance>
         }
 
         /// <summary>
-        /// Sets metadata where one built-in metadata is allowed to be set: RecursiveDir. 
+        /// Sets metadata where one built-in metadata is allowed to be set: RecursiveDir.
         /// This is not normally legal to set outside of evaluation. However, the CreateItem
         /// needs to be able to set it as a task output, because it supports wildcards. So as a special exception we allow
         /// tasks to set this particular metadata as a task output.
@@ -699,7 +699,7 @@ private void CommonConstructor(ProjectInstance projectToUse, string itemTypeToUs
             ProjectItemDefinitionInstance itemDefinition;
             if (projectToUse.ItemDefinitions.TryGetValue(itemTypeToUse, out itemDefinition))
             {
-                inheritedItemDefinitions = inheritedItemDefinitions ?? new List<ProjectItemDefinitionInstance>();
+                inheritedItemDefinitions ??= new List<ProjectItemDefinitionInstance>();
                 inheritedItemDefinitions.Add(itemDefinition);
             }
 
@@ -708,7 +708,7 @@ private void CommonConstructor(ProjectInstance projectToUse, string itemTypeToUs
             _taskItem = new TaskItem(
                                         includeEscaped,
                                         includeBeforeWildcardExpansionEscaped,
-                                        (directMetadata == null) ? null : directMetadata.DeepClone(), // copy on write!
+                                        directMetadata?.DeepClone(), // copy on write!
                                         inheritedItemDefinitions,
                                         _project.Directory,
                                         _project.IsImmutable,
@@ -717,7 +717,7 @@ private void CommonConstructor(ProjectInstance projectToUse, string itemTypeToUs
         }
 
         /// <summary>
-        /// An item without an item type. Cast to an ITaskItem, this is 
+        /// An item without an item type. Cast to an ITaskItem, this is
         /// what is given to tasks. It is also used for target outputs.
         /// </summary>
         internal sealed class TaskItem :
@@ -802,8 +802,8 @@ internal TaskItem(
                               string definingFileEscaped // the actual project file (or import) that defines this item.
                               )
             {
-                ErrorUtilities.VerifyThrowArgumentLength(includeEscaped, "includeEscaped");
-                ErrorUtilities.VerifyThrowArgumentLength(includeBeforeWildcardExpansionEscaped, "includeBeforeWildcardExpansionEscaped");
+                ErrorUtilities.VerifyThrowArgumentLength(includeEscaped, nameof(includeEscaped));
+                ErrorUtilities.VerifyThrowArgumentLength(includeBeforeWildcardExpansionEscaped, nameof(includeBeforeWildcardExpansionEscaped));
 
                 _includeEscaped = FileUtilities.FixFilePath(includeEscaped);
                 _includeBeforeWildcardExpansionEscaped = FileUtilities.FixFilePath(includeBeforeWildcardExpansionEscaped);
@@ -863,9 +863,9 @@ private TaskItem(ITranslator translator, LookasideStringInterner interner)
             /// Gets or sets the unescaped include, or "name", for the item.
             /// </summary>
             /// <comments>
-            /// This one is a bit tricky.  Orcas assumed that the value being set was escaped, but 
+            /// This one is a bit tricky.  Orcas assumed that the value being set was escaped, but
             /// that the value being returned was unescaped.  Maintain that behaviour here.  To get
-            /// the escaped value, use ITaskItem2.EvaluatedIncludeEscaped. 
+            /// the escaped value, use ITaskItem2.EvaluatedIncludeEscaped.
             /// </comments>
             public string ItemSpec
             {
@@ -1114,7 +1114,7 @@ internal CopyOnWritePropertyDictionary<ProjectMetadataInstance> MetadataCollecti
             /// <summary>
             /// This allows an explicit typecast from a "TaskItem" to a "string", returning the ItemSpec for this item.
             /// </summary>
-            public static explicit operator string (TaskItem that)
+            public static explicit operator string(TaskItem that)
             {
                 return that._includeEscaped;
             }
@@ -1127,11 +1127,11 @@ public static explicit operator string (TaskItem that)
             /// <returns>True if the items are equivalent, false otherwise.</returns>
             public static bool operator ==(TaskItem left, TaskItem right)
             {
-                if (!Object.ReferenceEquals(left, null))
+                if (!(left is null))
                 {
                     return left.Equals(right);
                 }
-                else if (!Object.ReferenceEquals(right, null))
+                else if (!(right is null))
                 {
                     return right.Equals(left);
                 }
@@ -1236,14 +1236,12 @@ public string GetMetadata(string metadataName)
             /// </summary>
             public string GetMetadataEscaped(string metadataName)
             {
-                if (metadataName == null || metadataName.Length == 0)
+                if (string.IsNullOrEmpty(metadataName))
                 {
-                    ErrorUtilities.VerifyThrowArgumentLength(metadataName, "metadataName");
+                    ErrorUtilities.VerifyThrowArgumentLength(metadataName, nameof(metadataName));
                 }
 
-                string value = null;
-                ProjectMetadataInstance metadatum = null;
-
+                ProjectMetadataInstance metadatum;
                 if (_directMetadata != null)
                 {
                     metadatum = _directMetadata[metadataName];
@@ -1255,21 +1253,19 @@ public string GetMetadataEscaped(string metadataName)
 
                 metadatum = GetItemDefinitionMetadata(metadataName);
 
-                if (null != metadatum && Expander<ProjectProperty, ProjectItem>.ExpressionMayContainExpandableExpressions(metadatum.EvaluatedValueEscaped))
+                if (metadatum != null && Expander<ProjectProperty, ProjectItem>.ExpressionMayContainExpandableExpressions(metadatum.EvaluatedValueEscaped))
                 {
                     Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(null, null, new BuiltInMetadataTable(null, this), FileSystems.Default);
 
                     // We don't have a location to use, but this is very unlikely to error
-                    value = expander.ExpandIntoStringLeaveEscaped(metadatum.EvaluatedValueEscaped, ExpanderOptions.ExpandBuiltInMetadata, ElementLocation.EmptyLocation);
-
-                    return value;
+                    return expander.ExpandIntoStringLeaveEscaped(metadatum.EvaluatedValueEscaped, ExpanderOptions.ExpandBuiltInMetadata, ElementLocation.EmptyLocation);
                 }
-                else if (null != metadatum)
+                else if (metadatum != null)
                 {
                     return metadatum.EvaluatedValueEscaped;
                 }
 
-                value = GetBuiltInMetadataEscaped(metadataName);
+                string value = GetBuiltInMetadataEscaped(metadataName);
 
                 return value ?? String.Empty;
             }
@@ -1278,7 +1274,7 @@ public string GetMetadataEscaped(string metadataName)
             /// ITaskItem implementation which sets metadata.
             /// </summary>
             /// <comments>
-            /// The value is assumed to be escaped. 
+            /// The value is assumed to be escaped.
             /// </comments>
             public void SetMetadata(string metadataName, string metadataValueEscaped)
             {
@@ -1288,7 +1284,7 @@ public void SetMetadata(string metadataName, string metadataValueEscaped)
             }
 
             /// <summary>
-            /// ITaskItem2 implementation which sets the literal value of metadata -- it is escaped 
+            /// ITaskItem2 implementation which sets the literal value of metadata -- it is escaped
             /// internally as necessary.
             /// </summary>
             void ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue)
@@ -1325,19 +1321,19 @@ public void CopyMetadataTo(ITaskItem destinationItem)
             /// Copies direct and item definition metadata.
             /// Does not copy built-in metadata, and will not overwrite existing, non-empty metadata.
             /// If the destination implements ITaskItem2, this avoids losing the escaped nature of values.
-            /// 
+            ///
             /// When copying metadata to a task item which can be accessed from a task (Utilities task item)
             /// this method will merge and expand any metadata originating with item definitions.
             /// </summary>
             /// <param name="destinationItem">destination item to copy the metadata from this to</param>
-            /// <param name="addOriginalItemSpec">Whether the OriginalItemSpec should be added as a piece 
-            /// of magic metadata. For copying of items this is useful but for cloning of items this adds 
-            /// additional metadata which is not useful because the OriginalItemSpec will always be identical 
+            /// <param name="addOriginalItemSpec">Whether the OriginalItemSpec should be added as a piece
+            /// of magic metadata. For copying of items this is useful but for cloning of items this adds
+            /// additional metadata which is not useful because the OriginalItemSpec will always be identical
             /// to the ItemSpec, and the addition will and will cause copy-on-write to trigger.
             /// </param>
             public void CopyMetadataTo(ITaskItem destinationItem, bool addOriginalItemSpec)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(destinationItem, "destinationItem");
+                ErrorUtilities.VerifyThrowArgumentNull(destinationItem, nameof(destinationItem));
 
                 string originalItemSpec = null;
                 if (addOriginalItemSpec)
@@ -1413,7 +1409,7 @@ public IDictionary CloneCustomMetadata()
 
             /// <summary>
             /// ITaskItem2 implementation which returns a clone of the metadata on this object.
-            /// Values returned are in their original escaped form. 
+            /// Values returned are in their original escaped form.
             /// </summary>
             /// <returns>The cloned metadata.</returns>
             IDictionary ITaskItem2.CloneCustomMetadataEscaped()
@@ -1495,7 +1491,7 @@ public override bool Equals(object obj)
             /// <returns>True if the items are equivalent, false otherwise.</returns>
             public bool Equals(TaskItem other)
             {
-                if (Object.ReferenceEquals(other, null))
+                if (other is null)
                 {
                     return false;
                 }
@@ -1553,7 +1549,7 @@ public bool Equals(TaskItem other)
             /// </remarks>
             public bool HasMetadata(string name)
             {
-                if ((_directMetadata != null && _directMetadata.Contains(name)) ||
+                if ((_directMetadata?.Contains(name) == true) ||
                      FileUtilities.ItemSpecModifiers.IsItemSpecModifier(name) ||
                     GetItemDefinitionMetadata(name) != null)
                 {
@@ -1596,16 +1592,32 @@ internal static TaskItem FactoryForDeserialization(ITranslator translator, Looka
                 return new TaskItem(translator, interner);
             }
 
+            private void WriteInternString(ITranslator translator, LookasideStringInterner interner, ref string str)
+            {
+                var key = interner.Intern(str);
+                translator.Writer.Write(key);
+            }
+            
+            private void ReadInternString(ITranslator translator, LookasideStringInterner interner, ref string str)
+            {
+                var val = translator.Reader.ReadInt32();
+                str = interner.GetString(val);
+            }
+
             /// <summary>
             /// Reads or writes the task item to the translator using an interner for metadata.
             /// </summary>
             internal void TranslateWithInterning(ITranslator translator, LookasideStringInterner interner)
             {
+                translator.Translate(ref _itemDefinitions, ProjectItemDefinitionInstance.FactoryForDeserialization);
+                translator.Translate(ref _isImmutable);
                 translator.Translate(ref _includeEscaped);
-                translator.Translate(ref _includeBeforeWildcardExpansionEscaped);
 
                 if (translator.Mode == TranslationDirection.WriteToStream)
                 {
+                    WriteInternString(translator, interner, ref _includeBeforeWildcardExpansionEscaped);
+                    WriteInternString(translator, interner, ref _definingFileEscaped);
+
                     CopyOnWritePropertyDictionary<ProjectMetadataInstance> temp = MetadataCollection;
 
                     // Intern the metadata
@@ -1624,6 +1636,8 @@ internal void TranslateWithInterning(ITranslator translator, LookasideStringInte
                 }
                 else
                 {
+                    ReadInternString(translator, interner, ref _includeBeforeWildcardExpansionEscaped);
+                    ReadInternString(translator, interner, ref _definingFileEscaped);
                     if (translator.TranslateNullable(_directMetadata))
                     {
                         int count = translator.Reader.ReadInt32();
@@ -1691,7 +1705,7 @@ internal ProjectMetadataInstance SetMetadataObject(string name, string metadataV
             {
                 ProjectInstance.VerifyThrowNotImmutable(_isImmutable);
 
-                _directMetadata = _directMetadata ?? new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+                _directMetadata ??= new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
                 ProjectMetadataInstance metadatum = new ProjectMetadataInstance(name, metadataValueEscaped, allowItemSpecModifiers /* may not be built-in metadata name */);
                 _directMetadata.Set(metadatum);
 
@@ -1699,7 +1713,7 @@ internal ProjectMetadataInstance SetMetadataObject(string name, string metadataV
             }
 
             /// <summary>
-            /// Sets metadata where one built-in metadata is allowed to be set: RecursiveDir. 
+            /// Sets metadata where one built-in metadata is allowed to be set: RecursiveDir.
             /// This is not normally legal to set outside of evaluation. However, the CreateItem
             /// needs to be able to set it as a task output, because it supports wildcards. So as a special exception we allow
             /// tasks to set this particular metadata as a task output.
@@ -1713,7 +1727,7 @@ internal void SetMetadataOnTaskOutput(string name, string evaluatedValueEscaped)
 
                 if (!FileUtilities.ItemSpecModifiers.IsDerivableItemSpecModifier(name))
                 {
-                    _directMetadata = _directMetadata ?? new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+                    _directMetadata ??= new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
                     ProjectMetadataInstance metadatum = new ProjectMetadataInstance(name, evaluatedValueEscaped, true /* may be built-in metadata name */);
                     _directMetadata.Set(metadatum);
                 }
@@ -1763,7 +1777,6 @@ private string GetBuiltInMetadataEscaped(string name)
             /// </summary>
             private ProjectMetadataInstance GetItemDefinitionMetadata(string metadataName)
             {
-                ProjectMetadataInstance metadataFromDefinition = null;
 
                 // Check any inherited item definition metadata first. It's more like
                 // direct metadata, but we didn't want to copy the tables.
@@ -1771,7 +1784,7 @@ private ProjectMetadataInstance GetItemDefinitionMetadata(string metadataName)
                 {
                     foreach (ProjectItemDefinitionInstance itemDefinition in _itemDefinitions)
                     {
-                        metadataFromDefinition = itemDefinition.GetMetadata(metadataName);
+                        ProjectMetadataInstance metadataFromDefinition = itemDefinition.GetMetadata(metadataName);
 
                         if (metadataFromDefinition != null)
                         {
@@ -1809,7 +1822,7 @@ internal ProjectItemInstanceFactory(ProjectInstance project)
                 internal ProjectItemInstanceFactory(ProjectInstance project, string itemType)
                     : this(project)
                 {
-                    ErrorUtilities.VerifyThrowInternalLength(itemType, "itemType");
+                    ErrorUtilities.VerifyThrowInternalLength(itemType, nameof(itemType));
                     this.ItemType = itemType;
                 }
 
@@ -1901,7 +1914,7 @@ public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metada
                 private ProjectItemInstance CreateItem(string includeEscaped, string includeBeforeWildcardExpansionEscaped, ProjectItemInstance source, string definingProject)
                 {
                     ErrorUtilities.VerifyThrowInternalLength(ItemType, "ItemType");
-                    ErrorUtilities.VerifyThrowInternalNull(source, "source");
+                    ErrorUtilities.VerifyThrowInternalNull(source, nameof(source));
 
                     // The new item inherits any metadata originating in item definitions, which
                     // takes precedence over its own item definition metadata.
@@ -1915,14 +1928,14 @@ private ProjectItemInstance CreateItem(string includeEscaped, string includeBefo
                     List<ProjectItemDefinitionInstance> itemDefinitionsClone = null;
                     if (source._taskItem._itemDefinitions != null)
                     {
-                        itemDefinitionsClone = itemDefinitionsClone ?? new List<ProjectItemDefinitionInstance>(source._taskItem._itemDefinitions.Count + 1);
+                        itemDefinitionsClone ??= new List<ProjectItemDefinitionInstance>(source._taskItem._itemDefinitions.Count + 1);
                         itemDefinitionsClone.AddRange(source._taskItem._itemDefinitions);
                     }
 
                     ProjectItemDefinitionInstance sourceItemDefinition;
                     if (_project.ItemDefinitions.TryGetValue(source.ItemType, out sourceItemDefinition))
                     {
-                        itemDefinitionsClone = itemDefinitionsClone ?? new List<ProjectItemDefinitionInstance>();
+                        itemDefinitionsClone ??= new List<ProjectItemDefinitionInstance>();
                         itemDefinitionsClone.Add(sourceItemDefinition);
                     }
 
@@ -2026,7 +2039,7 @@ public TaskItem CreateItem(string includeEscaped, ProjectItemInstance baseItem,
                 {
                     TaskItem item = new TaskItem(baseItem);
 
-                    if (Path.DirectorySeparatorChar != '\\' && includeEscaped != null && includeEscaped.IndexOf('\\') > -1)
+                    if (Path.DirectorySeparatorChar != '\\' && includeEscaped?.IndexOf('\\') > -1)
                     {
                         includeEscaped = includeEscaped.Replace('\\', '/');
                     }
@@ -2057,7 +2070,7 @@ public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metada
             /// <summary>
             /// Implementation of IMetadataTable that can be passed to expander to expose only built-in metadata on this item.
             /// Built-in metadata is stored in a separate table so it can be cleared out when the item is renamed, as this invalidates the values.
-            /// Also, more importantly, because typically the same regular metadata values can be shared by many items, 
+            /// Also, more importantly, because typically the same regular metadata values can be shared by many items,
             /// and keeping item-specific metadata out of it could allow it to be implemented as a copy-on-write table.
             /// </summary>
             private class BuiltInMetadataTable : IMetadataTable
diff --git a/src/Build/Instance/ProjectMetadataInstance.cs b/src/Build/Instance/ProjectMetadataInstance.cs
index 6be365a0822..a328df08dde 100644
--- a/src/Build/Instance/ProjectMetadataInstance.cs
+++ b/src/Build/Instance/ProjectMetadataInstance.cs
@@ -61,7 +61,7 @@ internal ProjectMetadataInstance(string name, string escapedValue)
         /// </remarks>
         internal ProjectMetadataInstance(string name, string escapedValue, bool allowItemSpecModifiers)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
 
             if (allowItemSpecModifiers)
             {
@@ -204,8 +204,8 @@ bool IEquatable<ProjectMetadataInstance>.Equals(ProjectMetadataInstance other)
                 return false;
             }
 
-            return (_escapedValue == other._escapedValue &&
-                    String.Equals(_name, other._name, StringComparison.OrdinalIgnoreCase));
+            return _escapedValue == other._escapedValue &&
+                    String.Equals(_name, other._name, StringComparison.OrdinalIgnoreCase);
         }
 
         #endregion
diff --git a/src/Build/Instance/ProjectOnErrorInstance.cs b/src/Build/Instance/ProjectOnErrorInstance.cs
index a7a50671284..778da933f1f 100644
--- a/src/Build/Instance/ProjectOnErrorInstance.cs
+++ b/src/Build/Instance/ProjectOnErrorInstance.cs
@@ -56,9 +56,9 @@ internal ProjectOnErrorInstance
             ElementLocation conditionLocation
             )
         {
-            ErrorUtilities.VerifyThrowInternalLength(executeTargets, "executeTargets");
-            ErrorUtilities.VerifyThrowInternalNull(condition, "condition");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
+            ErrorUtilities.VerifyThrowInternalLength(executeTargets, nameof(executeTargets));
+            ErrorUtilities.VerifyThrowInternalNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
 
             _executeTargets = executeTargets;
             _condition = condition;
diff --git a/src/Build/Instance/ProjectPropertyGroupTaskInstance.cs b/src/Build/Instance/ProjectPropertyGroupTaskInstance.cs
index 90c7e0a39bf..63aff591bec 100644
--- a/src/Build/Instance/ProjectPropertyGroupTaskInstance.cs
+++ b/src/Build/Instance/ProjectPropertyGroupTaskInstance.cs
@@ -53,9 +53,9 @@ internal ProjectPropertyGroupTaskInstance
             List<ProjectPropertyGroupTaskPropertyInstance> properties
             )
         {
-            ErrorUtilities.VerifyThrowInternalNull(condition, "condition");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
-            ErrorUtilities.VerifyThrowInternalNull(properties, "properties");
+            ErrorUtilities.VerifyThrowInternalNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
+            ErrorUtilities.VerifyThrowInternalNull(properties, nameof(properties));
 
             _condition = condition;
             _location = location;
diff --git a/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs b/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
index 7f3ebd43cf8..1a7e37876dd 100644
--- a/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
@@ -50,10 +50,10 @@ public class ProjectPropertyGroupTaskPropertyInstance : ITranslatable
         /// </summary>
         internal ProjectPropertyGroupTaskPropertyInstance(string name, string value, string condition, ElementLocation location, ElementLocation conditionLocation)
         {
-            ErrorUtilities.VerifyThrowInternalNull(name, "name");
-            ErrorUtilities.VerifyThrowInternalNull(value, "value");
-            ErrorUtilities.VerifyThrowInternalNull(condition, "condition");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
+            ErrorUtilities.VerifyThrowInternalNull(name, nameof(name));
+            ErrorUtilities.VerifyThrowInternalNull(value, nameof(value));
+            ErrorUtilities.VerifyThrowInternalNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
 
             _name = name;
             _value = value;
diff --git a/src/Build/Instance/ProjectPropertyInstance.cs b/src/Build/Instance/ProjectPropertyInstance.cs
index 42869ea60d2..037cdac44a2 100644
--- a/src/Build/Instance/ProjectPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyInstance.cs
@@ -116,7 +116,7 @@ bool IEquatable<ProjectPropertyInstance>.Equals(ProjectPropertyInstance other)
             }
 
             // Do not consider mutability for equality comparison
-            return (_escapedValue == other._escapedValue && String.Equals(_name, other._name, StringComparison.OrdinalIgnoreCase));
+            return _escapedValue == other._escapedValue && String.Equals(_name, other._name, StringComparison.OrdinalIgnoreCase);
         }
 
         #endregion
diff --git a/src/Build/Instance/ProjectTargetInstance.cs b/src/Build/Instance/ProjectTargetInstance.cs
index 74b7b03ef1c..dd3dffc3cc5 100644
--- a/src/Build/Instance/ProjectTargetInstance.cs
+++ b/src/Build/Instance/ProjectTargetInstance.cs
@@ -28,7 +28,7 @@ public sealed class ProjectTargetInstance : IImmutable, IKeyed, ITranslatable
         private string _name;
 
         /// <summary>
-        /// Condition on the target. 
+        /// Condition on the target.
         /// Evaluated during the build.
         /// </summary>
         private string _condition;
@@ -44,7 +44,7 @@ public sealed class ProjectTargetInstance : IImmutable, IKeyed, ITranslatable
         private string _outputs;
 
         /// <summary>
-        /// Return values on the target. 
+        /// Return values on the target.
         /// </summary>
         private string _returns;
 
@@ -76,8 +76,8 @@ public sealed class ProjectTargetInstance : IImmutable, IKeyed, ITranslatable
         /// <summary>
         /// Whether the project file that this target lives in has at least one target
         /// with a Returns attribute on it.  If so, the default behaviour for all targets
-        /// in the file without Returns attributes changes from returning the Outputs, to 
-        /// returning nothing. 
+        /// in the file without Returns attributes changes from returning the Outputs, to
+        /// returning nothing.
         /// </summary>
         private bool _parentProjectSupportsReturnsAttribute;
 
@@ -162,17 +162,17 @@ internal ProjectTargetInstance
             bool parentProjectSupportsReturnsAttribute
             )
         {
-            ErrorUtilities.VerifyThrowInternalLength(name, "name");
-            ErrorUtilities.VerifyThrowInternalNull(condition, "condition");
-            ErrorUtilities.VerifyThrowInternalNull(inputs, "inputs");
-            ErrorUtilities.VerifyThrowInternalNull(outputs, "outputs");
-            ErrorUtilities.VerifyThrowInternalNull(keepDuplicateOutputs, "keepDuplicateOutputs");
-            ErrorUtilities.VerifyThrowInternalNull(dependsOnTargets, "dependsOnTargets");
-            ErrorUtilities.VerifyThrowInternalNull(beforeTargets, "beforeTargets");
-            ErrorUtilities.VerifyThrowInternalNull(afterTargets, "afterTargets");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
-            ErrorUtilities.VerifyThrowInternalNull(children, "children");
-            ErrorUtilities.VerifyThrowInternalNull(onErrorChildren, "onErrorChildren");
+            ErrorUtilities.VerifyThrowInternalLength(name, nameof(name));
+            ErrorUtilities.VerifyThrowInternalNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowInternalNull(inputs, nameof(inputs));
+            ErrorUtilities.VerifyThrowInternalNull(outputs, nameof(outputs));
+            ErrorUtilities.VerifyThrowInternalNull(keepDuplicateOutputs, nameof(keepDuplicateOutputs));
+            ErrorUtilities.VerifyThrowInternalNull(dependsOnTargets, nameof(dependsOnTargets));
+            ErrorUtilities.VerifyThrowInternalNull(beforeTargets, nameof(beforeTargets));
+            ErrorUtilities.VerifyThrowInternalNull(afterTargets, nameof(afterTargets));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
+            ErrorUtilities.VerifyThrowInternalNull(children, nameof(children));
+            ErrorUtilities.VerifyThrowInternalNull(onErrorChildren, nameof(onErrorChildren));
 
             _name = name;
             _condition = condition;
@@ -338,7 +338,7 @@ public ICollection<ProjectTaskInstance> Tasks
 
         /// <summary>
         /// Full path to the file from which this target originated.
-        /// If it originated in a project that was not loaded and has never been 
+        /// If it originated in a project that was not loaded and has never been
         /// given a path, returns an empty string.
         /// </summary>
         public string FullPath
@@ -450,8 +450,8 @@ string IKeyed.Key
         /// <summary>
         /// Whether the project file that this target lives in has at least one target
         /// with a Returns attribute on it.  If so, the default behaviour for all targets
-        /// in the file without Returns attributes changes from returning the Outputs, to 
-        /// returning nothing. 
+        /// in the file without Returns attributes changes from returning the Outputs, to
+        /// returning nothing.
         /// </summary>
         internal bool ParentProjectSupportsReturnsAttribute
         {
@@ -543,7 +543,7 @@ internal ProjectTaskInstance AddTask(string taskName, string condition, string c
         /// <returns>The new task instance.</returns>
         internal ProjectTaskInstance AddTask(string taskName, string condition, string continueOnError, string msbuildRuntime, string msbuildArchitecture)
         {
-            ErrorUtilities.VerifyThrowInternalLength(taskName, "taskName");
+            ErrorUtilities.VerifyThrowInternalLength(taskName, nameof(taskName));
             ProjectTaskInstance task = new ProjectTaskInstance(taskName, _location, condition ?? String.Empty, continueOnError ?? String.Empty, msbuildRuntime ?? String.Empty, msbuildArchitecture ?? String.Empty);
             this.AddProjectTargetInstanceChild(task);
             return task;
diff --git a/src/Build/Instance/ProjectTaskInstance.cs b/src/Build/Instance/ProjectTaskInstance.cs
index 98b42dc76ce..963f55f9601 100644
--- a/src/Build/Instance/ProjectTaskInstance.cs
+++ b/src/Build/Instance/ProjectTaskInstance.cs
@@ -98,8 +98,8 @@ internal ProjectTaskInstance
             IList<ProjectTaskInstanceChild> outputs
             )
         {
-            ErrorUtilities.VerifyThrowInternalNull(element, "element");
-            ErrorUtilities.VerifyThrowInternalNull(outputs, "outputs");
+            ErrorUtilities.VerifyThrowInternalNull(element, nameof(element));
+            ErrorUtilities.VerifyThrowInternalNull(outputs, nameof(outputs));
 
             // These are all immutable
             _name = element.Name;
@@ -163,9 +163,9 @@ internal ProjectTaskInstance
             ElementLocation msbuildRuntimeLocation,
             ElementLocation msbuildArchitectureLocation)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
-            ErrorUtilities.VerifyThrowArgumentNull(condition, "condition");
-            ErrorUtilities.VerifyThrowArgumentNull(continueOnError, "continueOnError");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
+            ErrorUtilities.VerifyThrowArgumentNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowArgumentNull(continueOnError, nameof(continueOnError));
 
             _name = name;
             _condition = condition;
@@ -339,8 +339,8 @@ internal void SetParameter(string parameterName, string unevaluatedValue)
         /// <param name="condition">The condition.</param>
         internal void AddOutputItem(string taskOutputParameterName, string itemName, string condition)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(taskOutputParameterName, "taskOutputParameterName");
-            ErrorUtilities.VerifyThrowArgumentLength(itemName, "itemName");
+            ErrorUtilities.VerifyThrowArgumentLength(taskOutputParameterName, nameof(taskOutputParameterName));
+            ErrorUtilities.VerifyThrowArgumentLength(itemName, nameof(itemName));
             _outputs.Add(new ProjectTaskOutputItemInstance(itemName, taskOutputParameterName, condition ?? String.Empty, ElementLocation.EmptyLocation, ElementLocation.EmptyLocation, ElementLocation.EmptyLocation, condition == null ? null : ElementLocation.EmptyLocation));
         }
 
@@ -352,8 +352,8 @@ internal void AddOutputItem(string taskOutputParameterName, string itemName, str
         /// <param name="condition">The condition.</param>
         internal void AddOutputProperty(string taskOutputParameterName, string propertyName, string condition)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(taskOutputParameterName, "taskOutputParameterName");
-            ErrorUtilities.VerifyThrowArgumentLength(propertyName, "propertyName");
+            ErrorUtilities.VerifyThrowArgumentLength(taskOutputParameterName, nameof(taskOutputParameterName));
+            ErrorUtilities.VerifyThrowArgumentLength(propertyName, nameof(propertyName));
             _outputs.Add(new ProjectTaskOutputPropertyInstance(propertyName, taskOutputParameterName, condition ?? String.Empty, ElementLocation.EmptyLocation, ElementLocation.EmptyLocation, ElementLocation.EmptyLocation, condition == null ? null : ElementLocation.EmptyLocation));
         }
 
diff --git a/src/Build/Instance/ProjectTaskOutputItemInstance.cs b/src/Build/Instance/ProjectTaskOutputItemInstance.cs
index ee8f7df8ac6..7bbaa1fee33 100644
--- a/src/Build/Instance/ProjectTaskOutputItemInstance.cs
+++ b/src/Build/Instance/ProjectTaskOutputItemInstance.cs
@@ -58,11 +58,11 @@ public sealed class ProjectTaskOutputItemInstance : ProjectTaskInstanceChild, IT
         /// </summary>
         internal ProjectTaskOutputItemInstance(string itemType, string taskParameter, string condition, ElementLocation location, ElementLocation itemTypeLocation, ElementLocation taskParameterLocation, ElementLocation conditionLocation)
         {
-            ErrorUtilities.VerifyThrowInternalLength(itemType, "itemType");
-            ErrorUtilities.VerifyThrowInternalLength(taskParameter, "taskParameter");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
-            ErrorUtilities.VerifyThrowInternalNull(itemTypeLocation, "itemTypeLocation");
-            ErrorUtilities.VerifyThrowInternalNull(taskParameterLocation, "taskParameterLocation");
+            ErrorUtilities.VerifyThrowInternalLength(itemType, nameof(itemType));
+            ErrorUtilities.VerifyThrowInternalLength(taskParameter, nameof(taskParameter));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
+            ErrorUtilities.VerifyThrowInternalNull(itemTypeLocation, nameof(itemTypeLocation));
+            ErrorUtilities.VerifyThrowInternalNull(taskParameterLocation, nameof(taskParameterLocation));
 
             _itemType = itemType;
             _taskParameter = taskParameter;
diff --git a/src/Build/Instance/ProjectTaskOutputPropertyInstance.cs b/src/Build/Instance/ProjectTaskOutputPropertyInstance.cs
index fd65a4ceca7..2017af40368 100644
--- a/src/Build/Instance/ProjectTaskOutputPropertyInstance.cs
+++ b/src/Build/Instance/ProjectTaskOutputPropertyInstance.cs
@@ -55,11 +55,11 @@ public sealed class ProjectTaskOutputPropertyInstance : ProjectTaskInstanceChild
         /// </summary>
         internal ProjectTaskOutputPropertyInstance(string propertyName, string taskParameter, string condition, ElementLocation location, ElementLocation propertyNameLocation, ElementLocation taskParameterLocation, ElementLocation conditionLocation)
         {
-            ErrorUtilities.VerifyThrowInternalLength(propertyName, "propertyName");
-            ErrorUtilities.VerifyThrowInternalLength(taskParameter, "taskParameter");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
-            ErrorUtilities.VerifyThrowInternalNull(propertyNameLocation, "propertyNameLocation");
-            ErrorUtilities.VerifyThrowInternalNull(taskParameterLocation, "taskParameterLocation");
+            ErrorUtilities.VerifyThrowInternalLength(propertyName, nameof(propertyName));
+            ErrorUtilities.VerifyThrowInternalLength(taskParameter, nameof(taskParameter));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
+            ErrorUtilities.VerifyThrowInternalNull(propertyNameLocation, nameof(propertyNameLocation));
+            ErrorUtilities.VerifyThrowInternalNull(taskParameterLocation, nameof(taskParameterLocation));
 
             _propertyName = propertyName;
             _taskParameter = taskParameter;
diff --git a/src/Build/Instance/ReflectableTaskPropertyInfo.cs b/src/Build/Instance/ReflectableTaskPropertyInfo.cs
index 81c601c1fd5..4ffcff5b0ac 100644
--- a/src/Build/Instance/ReflectableTaskPropertyInfo.cs
+++ b/src/Build/Instance/ReflectableTaskPropertyInfo.cs
@@ -34,7 +34,7 @@ internal class ReflectableTaskPropertyInfo : TaskPropertyInfo
         internal ReflectableTaskPropertyInfo(TaskPropertyInfo taskPropertyInfo, Type taskType)
             : base(taskPropertyInfo.Name, taskPropertyInfo.PropertyType, taskPropertyInfo.Output, taskPropertyInfo.Required)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(taskType, "taskType");
+            ErrorUtilities.VerifyThrowArgumentNull(taskType, nameof(taskType));
             _taskType = taskType;
         }
 
diff --git a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
index e9960ce22a2..802539f6077 100644
--- a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
+++ b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
@@ -205,7 +205,7 @@ public ITask CreateTask(IBuildEngine taskFactoryLoggingHost, IDictionary<string,
         /// </remarks>
         public void CleanupTask(ITask task)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(task, "task");
+            ErrorUtilities.VerifyThrowArgumentNull(task, nameof(task));
 #if FEATURE_APPDOMAIN
             AppDomain appDomain;
             if (_tasksAndAppDomains.TryGetValue(task, out appDomain))
@@ -261,7 +261,7 @@ internal LoadedType InitializeFactory
                 string taskProjectFile
             )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(loadInfo, "loadInfo");
+            ErrorUtilities.VerifyThrowArgumentNull(loadInfo, nameof(loadInfo));
             VerifyThrowIdentityParametersValid(taskFactoryIdentityParameters, elementLocation, taskName, "Runtime", "Architecture");
 
             if (taskFactoryIdentityParameters != null)
@@ -273,7 +273,7 @@ string taskProjectFile
 
             try
             {
-                ErrorUtilities.VerifyThrowArgumentLength(taskName, "taskName");
+                ErrorUtilities.VerifyThrowArgumentLength(taskName, nameof(taskName));
                 _taskName = taskName;
                 _loadedType = _typeLoader.Load(taskName, loadInfo);
                 ProjectErrorUtilities.VerifyThrowInvalidProject(_loadedType != null, elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, String.Empty);
@@ -332,7 +332,7 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
             // the task factory parameters if we have any to calculate; otherwise even if we 
             // still launch the task factory, it will be with parameters corresponding to the 
             // current process. 
-            if ((_factoryIdentityParameters != null && _factoryIdentityParameters.Count > 0) || (taskIdentityParameters != null && taskIdentityParameters.Count > 0))
+            if ((_factoryIdentityParameters?.Count > 0) || (taskIdentityParameters?.Count > 0))
             {
                 VerifyThrowIdentityParametersValid(taskIdentityParameters, taskLocation, _taskName, "MSBuildRuntime", "MSBuildArchitecture");
 
@@ -351,9 +351,9 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
 
             if (useTaskFactory)
             {
-                ErrorUtilities.VerifyThrowInternalNull(buildComponentHost, "buildComponentHost");
+                ErrorUtilities.VerifyThrowInternalNull(buildComponentHost, nameof(buildComponentHost));
 
-                mergedParameters = mergedParameters ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+                mergedParameters ??= new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
                 string runtime = null;
                 string architecture = null;
@@ -413,20 +413,11 @@ internal bool TaskNameCreatableByFactory(string taskName, IDictionary<string, st
                 return false;
             }
 
-            // Parameters match, so now we check to see if the task exists. 
-            LoadedType taskClass = null;
             try
             {
                 ErrorUtilities.VerifyThrowArgumentLength(taskName, "TaskName");
-                taskClass = _typeLoader.ReflectionOnlyLoad(taskName, _loadedType.Assembly);
-                if (taskClass != null)
-                {
-                    return true;
-                }
-                else
-                {
-                    return false;
-                }
+                // Parameters match, so now we check to see if the task exists. 
+                return _typeLoader.ReflectionOnlyLoad(taskName, _loadedType.Assembly) != null;
             }
             catch (TargetInvocationException e)
             {
@@ -475,9 +466,9 @@ internal bool TaskNameCreatableByFactory(string taskName, IDictionary<string, st
         private static void VerifyThrowIdentityParametersValid(IDictionary<string, string> identityParameters, IElementLocation errorLocation, string taskName, string runtimeName, string architectureName)
         {
             // validate the task factory parameters
-            if (identityParameters != null && identityParameters.Count > 0)
+            if (identityParameters?.Count > 0)
             {
-                string runtime = null;
+                string runtime;
                 if (identityParameters.TryGetValue(XMakeAttributes.runtime, out runtime))
                 {
                     if (!XMakeAttributes.IsValidMSBuildRuntimeValue(runtime))
@@ -497,7 +488,7 @@ private static void VerifyThrowIdentityParametersValid(IDictionary<string, strin
                     }
                 }
 
-                string architecture = null;
+                string architecture;
                 if (identityParameters.TryGetValue(XMakeAttributes.architecture, out architecture))
                 {
                     if (!XMakeAttributes.IsValidMSBuildArchitectureValue(architecture))
@@ -531,17 +522,16 @@ private static bool TaskIdentityParametersMatchFactory(IDictionary<string, strin
                 return true;
             }
 
-            string taskRuntime = null;
-            string taskArchitecture = null;
-            string usingTaskRuntime = null;
-            string usingTaskArchitecture = null;
-
+            string taskArchitecture;
+            string taskRuntime;
             taskIdentityParameters.TryGetValue(XMakeAttributes.runtime, out taskRuntime);
+            string usingTaskRuntime;
             factoryIdentityParameters.TryGetValue(XMakeAttributes.runtime, out usingTaskRuntime);
 
             if (XMakeAttributes.RuntimeValuesMatch(taskRuntime, usingTaskRuntime))
             {
                 taskIdentityParameters.TryGetValue(XMakeAttributes.architecture, out taskArchitecture);
+                string usingTaskArchitecture;
                 factoryIdentityParameters.TryGetValue(XMakeAttributes.architecture, out usingTaskArchitecture);
 
                 if (XMakeAttributes.ArchitectureValuesMatch(taskArchitecture, usingTaskArchitecture))
@@ -562,9 +552,6 @@ private static bool TaskIdentityParametersMatchFactory(IDictionary<string, strin
         private static IDictionary<string, string> MergeTaskFactoryParameterSets(IDictionary<string, string> factoryIdentityParameters, IDictionary<string, string> taskIdentityParameters)
         {
             IDictionary<string, string> mergedParameters = null;
-            string mergedRuntime = null;
-            string mergedArchitecture = null;
-
             if (factoryIdentityParameters == null || factoryIdentityParameters.Count == 0)
             {
                 mergedParameters = new Dictionary<string, string>(taskIdentityParameters, StringComparer.OrdinalIgnoreCase);
@@ -574,6 +561,8 @@ private static IDictionary<string, string> MergeTaskFactoryParameterSets(IDictio
                 mergedParameters = new Dictionary<string, string>(factoryIdentityParameters, StringComparer.OrdinalIgnoreCase);
             }
 
+            string mergedRuntime;
+            string mergedArchitecture;
             if (mergedParameters != null)
             {
                 mergedParameters.TryGetValue(XMakeAttributes.runtime, out mergedRuntime);
@@ -584,14 +573,11 @@ private static IDictionary<string, string> MergeTaskFactoryParameterSets(IDictio
             }
             else
             {
-                string taskRuntime = null;
-                string taskArchitecture = null;
-                string usingTaskRuntime = null;
-                string usingTaskArchitecture = null;
-
                 mergedParameters = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
+                string taskRuntime;
                 taskIdentityParameters.TryGetValue(XMakeAttributes.runtime, out taskRuntime);
+                string usingTaskRuntime;
                 factoryIdentityParameters.TryGetValue(XMakeAttributes.runtime, out usingTaskRuntime);
 
                 if (!XMakeAttributes.TryMergeRuntimeValues(taskRuntime, usingTaskRuntime, out mergedRuntime))
@@ -603,7 +589,9 @@ private static IDictionary<string, string> MergeTaskFactoryParameterSets(IDictio
                     mergedParameters.Add(XMakeAttributes.runtime, mergedRuntime);
                 }
 
+                string taskArchitecture;
                 taskIdentityParameters.TryGetValue(XMakeAttributes.architecture, out taskArchitecture);
+                string usingTaskArchitecture;
                 factoryIdentityParameters.TryGetValue(XMakeAttributes.architecture, out usingTaskArchitecture);
 
                 if (!XMakeAttributes.TryMergeArchitectureValues(taskArchitecture, usingTaskArchitecture, out mergedArchitecture))
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index 072b94052e9..34952491dd4 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -131,7 +131,7 @@ public TaskHostTask(IElementLocation taskLocation, TaskLoggingContext taskLoggin
 #endif
             )
         {
-            ErrorUtilities.VerifyThrowInternalNull(taskType, "taskType");
+            ErrorUtilities.VerifyThrowInternalNull(taskType, nameof(taskType));
 
             _taskLocation = taskLocation;
             _taskLoggingContext = taskLoggingContext;
@@ -206,7 +206,7 @@ public object GetPropertyValue(TaskPropertyInfo property)
 
                 // If we returned an exception, then we want to throw it when we 
                 // do the get.  
-                if (value != null && (value as Exception) != null)
+                if (value is Exception)
                 {
                     throw (Exception)value;
                 }
@@ -464,7 +464,6 @@ private void HandleTaskHostTaskComplete(TaskHostTaskComplete taskHostTaskComplet
                 }
                 else
                 {
-                    exceptionMessage = "TaskInstantiationFailureError";
                     exceptionMessageArgs = new string[] { _taskType.Type.Name,
                         AssemblyUtilities.GetAssemblyLocation(_taskType.Type.GetTypeInfo().Assembly),
                         string.Empty };
diff --git a/src/Build/Instance/TaskFactoryLoggingHost.cs b/src/Build/Instance/TaskFactoryLoggingHost.cs
index 62d541b85d1..945fe1a875f 100644
--- a/src/Build/Instance/TaskFactoryLoggingHost.cs
+++ b/src/Build/Instance/TaskFactoryLoggingHost.cs
@@ -58,8 +58,8 @@ internal class TaskFactoryLoggingHost :
         /// </summary>
         public TaskFactoryLoggingHost(bool isRunningWithMultipleNodes, ElementLocation elementLocation, BuildLoggingContext loggingContext)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(loggingContext, "loggingContext");
-            ErrorUtilities.VerifyThrowInternalNull(elementLocation, "elementLocation");
+            ErrorUtilities.VerifyThrowArgumentNull(loggingContext, nameof(loggingContext));
+            ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             _activeProxy = true;
             _isRunningWithMultipleNodes = isRunningWithMultipleNodes;
@@ -69,11 +69,11 @@ public TaskFactoryLoggingHost(bool isRunningWithMultipleNodes, ElementLocation e
 
         /// <summary>
         /// Returns true in the multiproc case
-        /// REVIEW: Should this mean the same thing in the distributed build case?  If we have 
+        /// REVIEW: Should this mean the same thing in the distributed build case?  If we have
         /// a build which happens to be on a distributed cluster, but the build manager has only
         /// alotted a single machine to this build, is this true?  Because the build manager
         /// could later decide to add more nodes to this build.
-        /// UNDONE: This means we are building with multiple processes. If we are building on 
+        /// UNDONE: This means we are building with multiple processes. If we are building on
         /// one machine then I think the maxcpu-count is still 1. In my mind this means multiple nodes either distributed or on the same machine.
         /// </summary>
         public bool IsRunningMultipleNodes
@@ -152,7 +152,7 @@ internal BuildLoggingContext LoggingContext
         /// <param name="e">The event args</param>
         public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             VerifyActiveProxy();
 
             // If we are in building across process we need the events to be serializable. This method will 
@@ -173,7 +173,7 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
         /// <param name="e">The event args</param>
         public void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             VerifyActiveProxy();
 
             // If we are in building across process we need the events to be serializable. This method will 
@@ -194,7 +194,7 @@ public void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e)
         /// <param name="e">The event args</param>
         public void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             VerifyActiveProxy();
 
             // If we are in building across process we need the events to be serializable. This method will 
@@ -215,7 +215,7 @@ public void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e)
         /// <param name="e">The event args</param>
         public void LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             VerifyActiveProxy();
 
             // If we are in building across process we need the events to be serializable. This method will 
@@ -247,7 +247,7 @@ public bool BuildProjectFile(string projectFileName, string[] targetNames, Syste
 
 #if FEATURE_APPDOMAIN
         /// <summary>
-        /// InitializeLifetimeService is called when the remote object is activated. 
+        /// InitializeLifetimeService is called when the remote object is activated.
         /// This method will determine how long the lifetime for the object will be.
         /// </summary>
         /// <returns>The lease object to control this object's lifetime.</returns>
@@ -321,10 +321,7 @@ internal void MarkAsInactive()
             {
                 ILease lease = (ILease)RemotingServices.GetLifetimeService(this);
 
-                if (lease != null)
-                {
-                    lease.Unregister(_sponsor);
-                }
+                lease?.Unregister(_sponsor);
 
                 _sponsor.Close();
                 _sponsor = null;
@@ -352,7 +349,7 @@ internal bool IsEventSerializable(BuildEventArgs e)
         /// </summary>
         private void VerifyActiveProxy()
         {
-            ErrorUtilities.VerifyThrow(_activeProxy == true, "Attempted to use an inactive task factory logging host.");
+            ErrorUtilities.VerifyThrow(_activeProxy, "Attempted to use an inactive task factory logging host.");
         }
     }
 }
diff --git a/src/Build/Instance/TaskFactoryWrapper.cs b/src/Build/Instance/TaskFactoryWrapper.cs
index b58f1a138cb..f097932a8e6 100644
--- a/src/Build/Instance/TaskFactoryWrapper.cs
+++ b/src/Build/Instance/TaskFactoryWrapper.cs
@@ -62,8 +62,8 @@ internal sealed class TaskFactoryWrapper
         /// </summary>
         internal TaskFactoryWrapper(ITaskFactory taskFactory, LoadedType taskFactoryLoadInfo, string taskName, IDictionary<string, string> factoryIdentityParameters)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(taskFactory, "taskFactory");
-            ErrorUtilities.VerifyThrowArgumentLength(taskName, "taskName");
+            ErrorUtilities.VerifyThrowArgumentNull(taskFactory, nameof(taskFactory));
+            ErrorUtilities.VerifyThrowArgumentLength(taskName, nameof(taskName));
             _taskFactory = taskFactory;
             _taskName = taskName;
             TaskFactoryLoadedType = taskFactoryLoadInfo;
@@ -182,8 +182,8 @@ public TaskPropertyInfo GetProperty(string propertyName)
         /// </summary>
         internal void SetPropertyValue(ITask task, TaskPropertyInfo property, object value)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(task, "task");
-            ErrorUtilities.VerifyThrowArgumentNull(property, "property");
+            ErrorUtilities.VerifyThrowArgumentNull(task, nameof(task));
+            ErrorUtilities.VerifyThrowArgumentNull(property, nameof(property));
 
             IGeneratedTask generatedTask = task as IGeneratedTask;
             if (generatedTask != null)
@@ -202,8 +202,8 @@ internal void SetPropertyValue(ITask task, TaskPropertyInfo property, object val
         /// </summary>
         internal object GetPropertyValue(ITask task, TaskPropertyInfo property)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(task, "task");
-            ErrorUtilities.VerifyThrowArgumentNull(property, "property");
+            ErrorUtilities.VerifyThrowArgumentNull(task, nameof(task));
+            ErrorUtilities.VerifyThrowArgumentNull(property, nameof(property));
 
             IGeneratedTask generatedTask = task as IGeneratedTask;
             if (generatedTask != null)
@@ -305,11 +305,11 @@ private void PopulatePropertyInfoCacheIfNecessary()
                     }
                 }
 
-                _propertyInfoCache = _propertyInfoCache ?? ReadOnlyEmptyDictionary<string, TaskPropertyInfo>.Instance;
+                _propertyInfoCache ??= ReadOnlyEmptyDictionary<string, TaskPropertyInfo>.Instance;
 
-                _namesOfPropertiesWithRequiredAttribute = _namesOfPropertiesWithRequiredAttribute ?? ReadOnlyEmptyDictionary<string, string>.Instance;
-                _namesOfPropertiesWithOutputAttribute = _namesOfPropertiesWithOutputAttribute ?? ReadOnlyEmptyDictionary<string, string>.Instance;
-                _namesOfPropertiesWithAmbiguousMatches = _namesOfPropertiesWithAmbiguousMatches ?? ReadOnlyEmptyDictionary<string, string>.Instance;
+                _namesOfPropertiesWithRequiredAttribute ??= ReadOnlyEmptyDictionary<string, string>.Instance;
+                _namesOfPropertiesWithOutputAttribute ??= ReadOnlyEmptyDictionary<string, string>.Instance;
+                _namesOfPropertiesWithAmbiguousMatches ??= ReadOnlyEmptyDictionary<string, string>.Instance;
             }
         }
         #endregion
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 3d261b4cf46..ef40362e4eb 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -37,7 +37,7 @@ namespace Microsoft.Build.Execution
     /// <example>
     /// &lt;UsingTask TaskName="Microsoft.Build.Tasks.Csc"                     ==> look for the "Csc" task in the
     ///            AssemblyName="Microsoft.Build.Tasks"/&gt;                       weakly-named "Microsoft.Build.Tasks" assembly
-    /// 
+    ///
     /// &lt;UsingTask TaskName="t1"                                            ==> look for the "t1" task in the
     ///            AssemblyName="mytasks, Culture=en, Version=1.0.0.0"/&gt;        strongly-named "mytasks" assembly
     ///
@@ -58,64 +58,64 @@ internal sealed class TaskRegistry : ITranslatable
         /// <summary>
         /// If true, we will force all tasks to run in the MSBuild task host EXCEPT
         /// a small well-known set of tasks that are known to depend on IBuildEngine
-        /// callbacks; as forcing those out of proc would be just setting them up for 
-        /// known failure.  
+        /// callbacks; as forcing those out of proc would be just setting them up for
+        /// known failure.
         /// </summary>
         private static bool s_forceTaskHostLaunch = (Environment.GetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC") == "1");
 
         /// <summary>
-        /// Simple name for the MSBuild tasks (v4), used for shimming in loading 
+        /// Simple name for the MSBuild tasks (v4), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_tasksV4SimpleName = "Microsoft.Build.Tasks.v4.0";
 
         /// <summary>
-        /// Filename for the MSBuild tasks (v4), used for shimming in loading 
+        /// Filename for the MSBuild tasks (v4), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_tasksV4Filename = s_tasksV4SimpleName + ".dll";
 
         /// <summary>
-        /// Expected location that MSBuild tasks (v4) is picked up from if the user 
-        /// references it with just a simple name, used for shimming in loading 
+        /// Expected location that MSBuild tasks (v4) is picked up from if the user
+        /// references it with just a simple name, used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_potentialTasksV4Location = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksV4Filename);
 
         /// <summary>
-        /// Simple name for the MSBuild tasks (v12), used for shimming in loading 
+        /// Simple name for the MSBuild tasks (v12), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_tasksV12SimpleName = "Microsoft.Build.Tasks.v12.0";
 
         /// <summary>
-        /// Filename for the MSBuild tasks (v12), used for shimming in loading 
+        /// Filename for the MSBuild tasks (v12), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_tasksV12Filename = s_tasksV12SimpleName + ".dll";
 
         /// <summary>
-        /// Expected location that MSBuild tasks (v12) is picked up from if the user 
-        /// references it with just a simple name, used for shimming in loading 
+        /// Expected location that MSBuild tasks (v12) is picked up from if the user
+        /// references it with just a simple name, used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_potentialTasksV12Location = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksV12Filename);
 
         /// <summary>
-        /// Simple name for the MSBuild tasks (v14+), used for shimming in loading 
+        /// Simple name for the MSBuild tasks (v14+), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_tasksCoreSimpleName = "Microsoft.Build.Tasks.Core";
 
         /// <summary>
-        /// Filename for the MSBuild tasks (v14+), used for shimming in loading 
+        /// Filename for the MSBuild tasks (v14+), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_tasksCoreFilename = s_tasksCoreSimpleName + ".dll";
 
         /// <summary>
-        /// Expected location that MSBuild tasks (v14+) is picked up from if the user 
-        /// references it with just a simple name, used for shimming in loading 
+        /// Expected location that MSBuild tasks (v14+) is picked up from if the user
+        /// references it with just a simple name, used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_potentialTasksCoreLocation = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksCoreFilename);
@@ -129,7 +129,7 @@ internal sealed class TaskRegistry : ITranslatable
         /// <summary>
         /// Cache of tasks already found using fuzzy matching,
         /// keyed by the task name requested.
-        /// Value is a dictionary of all possible matches for that 
+        /// Value is a dictionary of all possible matches for that
         /// task name, by unique identity.
         /// </summary>
         private Dictionary<string, Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord>> _cachedTaskRecordsWithFuzzyMatch;
@@ -153,7 +153,7 @@ internal sealed class TaskRegistry : ITranslatable
         /// </summary>
         internal TaskRegistry(ProjectRootElementCacheBase projectRootElementCache)
         {
-            ErrorUtilities.VerifyThrowInternalNull(projectRootElementCache, "projectRootElementCache");
+            ErrorUtilities.VerifyThrowInternalNull(projectRootElementCache, nameof(projectRootElementCache));
 
             RootElementCache = projectRootElementCache;
         }
@@ -163,7 +163,7 @@ private TaskRegistry()
         }
 
         /// <summary>
-        /// Creates a task registry that defers to the specified toolset's registry for those tasks it cannot resolve.        
+        /// Creates a task registry that defers to the specified toolset's registry for those tasks it cannot resolve.
         /// UNDONE: (Logging.) We can't pass the base task registry from the Toolset because we can't call GetTaskRegistry
         /// without logging context information.  When the Project load code is altered to contain logging service
         /// references, we can load the toolset task registry at the time this registry is created and pass it to
@@ -173,8 +173,8 @@ private TaskRegistry()
         /// <param name="projectRootElementCache">The <see cref="ProjectRootElementCache"/> to use.</param>
         internal TaskRegistry(Toolset toolset, ProjectRootElementCacheBase projectRootElementCache)
         {
-            ErrorUtilities.VerifyThrowInternalNull(projectRootElementCache, "projectRootElementCache");
-            ErrorUtilities.VerifyThrowInternalNull(toolset, "toolset");
+            ErrorUtilities.VerifyThrowInternalNull(projectRootElementCache, nameof(projectRootElementCache));
+            ErrorUtilities.VerifyThrowInternalNull(toolset, nameof(toolset));
 
             RootElementCache = projectRootElementCache;
             _toolset = toolset;
@@ -198,7 +198,7 @@ internal IDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> TaskReg
         {
             get
             {
-                if (null == _taskRegistrations)
+                if (_taskRegistrations == null)
                 {
                     _taskRegistrations = CreateRegisteredTaskDictionary();
                 }
@@ -228,7 +228,7 @@ IFileSystem fileSystem
             where P : class, IProperty
             where I : class, IItem
         {
-            ErrorUtilities.VerifyThrowInternalNull(directoryOfImportingFile, "directoryOfImportingFile");
+            ErrorUtilities.VerifyThrowInternalNull(directoryOfImportingFile, nameof(directoryOfImportingFile));
 
             if (!ConditionEvaluator.EvaluateCondition
                 (
@@ -380,8 +380,8 @@ IFileSystem fileSystem
             {
                 taskFactoryParameters = CreateTaskFactoryParametersDictionary();
 
-                taskFactoryParameters.Add(XMakeAttributes.runtime, (runtime == String.Empty ? XMakeAttributes.MSBuildRuntimeValues.any : runtime));
-                taskFactoryParameters.Add(XMakeAttributes.architecture, (architecture == String.Empty ? XMakeAttributes.MSBuildArchitectureValues.any : architecture));
+                taskFactoryParameters.Add(XMakeAttributes.runtime, runtime == String.Empty ? XMakeAttributes.MSBuildRuntimeValues.any : runtime);
+                taskFactoryParameters.Add(XMakeAttributes.architecture, architecture == String.Empty ? XMakeAttributes.MSBuildArchitectureValues.any : architecture);
             }
 
             taskRegistry.RegisterTask(taskName, AssemblyLoadInfo.Create(assemblyName, assemblyFile), taskFactory, taskFactoryParameters, parameterGroupAndTaskElementRecord);
@@ -409,7 +409,7 @@ ElementLocation elementLocation
         )
         {
             TaskFactoryWrapper taskFactory = null;
-            bool retrievedFromCache = false;
+            bool retrievedFromCache;
 
             // If there are no usingtask tags in the project don't bother caching or looking for tasks locally
             RegisteredTaskRecord record = GetTaskRegistrationRecord(taskName, taskProjectFile, taskIdentityParameters, exactMatchRequired, targetLoggingContext, elementLocation, out retrievedFromCache);
@@ -447,7 +447,7 @@ ElementLocation elementLocation
         /// </summary>
         /// <param name="taskName">The name of the task to retrieve.</param>
         /// <param name="taskProjectFile">The task's project file.</param>
-        /// <param name="taskIdentityParameters">The set of task identity parameters to be used to identify the 
+        /// <param name="taskIdentityParameters">The set of task identity parameters to be used to identify the
         /// correct task record match.</param>
         /// <param name="exactMatchRequired">True if an exact name match is required.</param>
         /// <param name="targetLoggingContext">The logging context.</param>
@@ -477,7 +477,7 @@ out bool retrievedFromCache
             }
 
             // Try the current task registry
-            if (taskRecord == null && _taskRegistrations != null && _taskRegistrations.Count > 0)
+            if (taskRecord == null && _taskRegistrations?.Count > 0)
             {
                 if (exactMatchRequired)
                 {
@@ -552,12 +552,12 @@ out bool retrievedFromCache
             // Cache the result, even if it is null.  We should never again do the work we just did, for this task name.
             if (exactMatchRequired)
             {
-                _cachedTaskRecordsWithExactMatch = _cachedTaskRecordsWithExactMatch ?? new Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);
+                _cachedTaskRecordsWithExactMatch ??= new Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);
                 _cachedTaskRecordsWithExactMatch[taskIdentity] = taskRecord;
             }
             else
             {
-                _cachedTaskRecordsWithFuzzyMatch = _cachedTaskRecordsWithFuzzyMatch ?? new Dictionary<string, Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord>>(StringComparer.OrdinalIgnoreCase);
+                _cachedTaskRecordsWithFuzzyMatch ??= new Dictionary<string, Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord>>(StringComparer.OrdinalIgnoreCase);
 
                 // Since this is a fuzzy match, we could conceivably have several sets of task identity parameters that match
                 // each other ... but might be mutually exclusive themselves.  E.g. CLR4|x86 and CLR2|x64 both match *|*.  
@@ -591,9 +591,9 @@ out bool retrievedFromCache
         /// </summary>
         private static bool IsTaskFactoryClass(Type type, object unused)
         {
-            return (type.GetTypeInfo().IsClass &&
+            return type.GetTypeInfo().IsClass &&
                 !type.GetTypeInfo().IsAbstract &&
-                typeof(Microsoft.Build.Framework.ITaskFactory).IsAssignableFrom(type));
+                typeof(Microsoft.Build.Framework.ITaskFactory).IsAssignableFrom(type);
         }
 
         /// <summary>
@@ -634,13 +634,13 @@ private Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> GetReleva
         }
 
         /// <summary>
-        /// Registers an evaluated using task tag for future 
+        /// Registers an evaluated using task tag for future
         /// consultation
         /// </summary>
         private void RegisterTask(string taskName, AssemblyLoadInfo assemblyLoadInfo, string taskFactory, Dictionary<string, string> taskFactoryParameters, RegisteredTaskRecord.ParameterGroupAndTaskElementRecord inlineTaskRecord)
         {
-            ErrorUtilities.VerifyThrowInternalLength(taskName, "taskName");
-            ErrorUtilities.VerifyThrowInternalNull(assemblyLoadInfo, "assemblyLoadInfo");
+            ErrorUtilities.VerifyThrowInternalLength(taskName, nameof(taskName));
+            ErrorUtilities.VerifyThrowInternalNull(assemblyLoadInfo, nameof(assemblyLoadInfo));
 
             // Lazily allocate the hashtable
             if (_taskRegistrations == null)
@@ -663,14 +663,13 @@ private void RegisterTask(string taskName, AssemblyLoadInfo assemblyLoadInfo, st
 
         private static Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> CreateRegisteredTaskDictionary(int? capacity = null)
         {
-
             return capacity != null
                 ? new Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>>(capacity.Value, RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact)
                 : new Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);
         }
 
         /// <summary>
-        /// Given a task name and a list of records which may contain the task, this helper method will ask the records to see if the task name 
+        /// Given a task name and a list of records which may contain the task, this helper method will ask the records to see if the task name
         /// can be created by the factories which are wrapped by the records. (this is done by instantiating the task factory and asking it).
         /// </summary>
         private RegisteredTaskRecord GetMatchingRegistration
@@ -696,7 +695,7 @@ ElementLocation elementLocation
         }
 
         /// <summary>
-        /// An object representing the identity of a task -- not just task name, but also 
+        /// An object representing the identity of a task -- not just task name, but also
         /// the set of identity parameters
         /// </summary>
         [DebuggerDisplay("{Name} ParameterCount = {TaskIdentityParameters.Count}")]
@@ -754,7 +753,7 @@ public IDictionary<string, string> TaskIdentityParameters
             }
 
             /// <summary>
-            /// Comparer used to figure out whether two RegisteredTaskIdentities are equal or not. 
+            /// Comparer used to figure out whether two RegisteredTaskIdentities are equal or not.
             /// </summary>
             internal class RegisteredTaskIdentityComparer : IEqualityComparer<RegisteredTaskIdentity>
             {
@@ -764,8 +763,8 @@ internal class RegisteredTaskIdentityComparer : IEqualityComparer<RegisteredTask
                 private static RegisteredTaskIdentityComparer s_exact = new RegisteredTaskIdentityComparer(true /* exact match */);
 
                 /// <summary>
-                /// The singleton comparer to use when a fuzzy match is desired.  Note that this still does an exact match on the 
-                /// name, but does a fuzzy match on the task identity parameters. 
+                /// The singleton comparer to use when a fuzzy match is desired.  Note that this still does an exact match on the
+                /// name, but does a fuzzy match on the task identity parameters.
                 /// </summary>
                 private static RegisteredTaskIdentityComparer s_fuzzy = new RegisteredTaskIdentityComparer(false /* fuzzy match */);
 
@@ -783,7 +782,7 @@ private RegisteredTaskIdentityComparer(bool exactMatchRequired)
                 }
 
                 /// <summary>
-                /// The singleton comparer to use for when an exact match is desired 
+                /// The singleton comparer to use for when an exact match is desired
                 /// </summary>
                 public static RegisteredTaskIdentityComparer Exact
                 {
@@ -791,7 +790,7 @@ public static RegisteredTaskIdentityComparer Exact
                 }
 
                 /// <summary>
-                /// The singleton comparer to use for when a fuzzy match is desired 
+                /// The singleton comparer to use for when a fuzzy match is desired
                 /// </summary>
                 public static RegisteredTaskIdentityComparer Fuzzy
                 {
@@ -799,9 +798,9 @@ public static RegisteredTaskIdentityComparer Fuzzy
                 }
 
                 /// <summary>
-                /// Returns true if these two identities match "fuzzily" -- if the names pass a partial type name 
-                /// match and the task identity parameters would constitute a valid merge (e.g. "don't care" and 
-                /// something explicit).  Otherwise returns false. 
+                /// Returns true if these two identities match "fuzzily" -- if the names pass a partial type name
+                /// match and the task identity parameters would constitute a valid merge (e.g. "don't care" and
+                /// something explicit).  Otherwise returns false.
                 /// </summary>
                 public static bool IsPartialMatch(RegisteredTaskIdentity x, RegisteredTaskIdentity y)
                 {
@@ -816,7 +815,7 @@ public static bool IsPartialMatch(RegisteredTaskIdentity x, RegisteredTaskIdenti
                 }
 
                 /// <summary>
-                /// Returns true if the two task identities are equal; false otherwise. 
+                /// Returns true if the two task identities are equal; false otherwise.
                 /// </summary>
                 public bool Equals(RegisteredTaskIdentity x, RegisteredTaskIdentity y)
                 {
@@ -852,7 +851,6 @@ public int GetHashCode(RegisteredTaskIdentity obj)
                     }
 
                     int nameHash = String.IsNullOrEmpty(obj.Name) ? 0 : StringComparer.OrdinalIgnoreCase.GetHashCode(obj.Name);
-                    int paramHash = 0;
 
                     // Since equality for the exact comparer depends on the exact values of the parameters, 
                     // we need our hash code to depend on them as well. However, for fuzzy matches, we just 
@@ -866,6 +864,7 @@ public int GetHashCode(RegisteredTaskIdentity obj)
                         obj.TaskIdentityParameters.TryGetValue(XMakeAttributes.architecture, out architecture);
                     }
 
+                    int paramHash;
                     if (_exactMatchRequired)
                     {
                         int runtimeHash = runtime == null ? 0 : StringComparer.OrdinalIgnoreCase.GetHashCode(runtime);
@@ -889,8 +888,8 @@ public int GetHashCode(RegisteredTaskIdentity obj)
 
                 /// <summary>
                 /// Returns true if the two dictionaries representing sets of task identity parameters match; false otherwise.
-                /// Internal so that RegisteredTaskRecord can use this function in its determination of whether the task factory 
-                /// supports a certain task identity.  
+                /// Internal so that RegisteredTaskRecord can use this function in its determination of whether the task factory
+                /// supports a certain task identity.
                 /// </summary>
                 private static bool IdentityParametersMatch(IDictionary<string, string> x, IDictionary<string, string> y, bool exactMatchRequired)
                 {
@@ -914,8 +913,7 @@ private static bool IdentityParametersMatch(IDictionary<string, string> x, IDict
                         // make sure that each parameter value matches as well 
                         foreach (KeyValuePair<string, string> param in x)
                         {
-                            string value = null;
-
+                            string value;
                             if (y.TryGetValue(param.Key, out value))
                             {
                                 if (!String.Equals(param.Value, value, StringComparison.OrdinalIgnoreCase))
@@ -997,17 +995,16 @@ internal class RegisteredTaskRecord : ITranslatable
 
             /// <summary>
             /// Task factory used to create CodeDom-based inline tasks.  Special-cased as one of two officially
-            /// supported task factories in Microsoft.Build.Tasks.vX.Y.dll to deal with versioning issue. 
+            /// supported task factories in Microsoft.Build.Tasks.vX.Y.dll to deal with versioning issue.
             /// </summary>
             internal const string CodeTaskFactory = "CodeTaskFactory";
 
             /// <summary>
             /// Task factory used to create CodeDom-based inline tasks.  Special-cased as one of two officially
-            /// supported task factories in Microsoft.Build.Tasks.vX.Y.dll to deal with versioning issue. 
+            /// supported task factories in Microsoft.Build.Tasks.vX.Y.dll to deal with versioning issue.
             /// </summary>
             internal const string XamlTaskFactory = "XamlTaskFactory";
 
-
             /// <summary>
             /// Lock for the taskFactoryTypeLoader
             /// </summary>
@@ -1057,14 +1054,14 @@ internal class RegisteredTaskRecord : ITranslatable
             private TaskFactoryWrapper _taskFactoryWrapperInstance;
 
             /// <summary>
-            /// Cache of task names which can be created by the factory. 
-            /// When ever a taskName is checked against the factory we cache the result so we do not have to 
+            /// Cache of task names which can be created by the factory.
+            /// When ever a taskName is checked against the factory we cache the result so we do not have to
             /// make possibly expensive calls over and over again.
             /// </summary>
             private Dictionary<RegisteredTaskIdentity, object> _taskNamesCreatableByFactory;
 
             /// <summary>
-            /// Set of parameters that can be used by the task factory specifically.  
+            /// Set of parameters that can be used by the task factory specifically.
             /// </summary>
             private Dictionary<string, string> _taskFactoryParameters;
 
@@ -1160,14 +1157,14 @@ internal ParameterGroupAndTaskElementRecord ParameterGroupAndTaskBody
             }
 
             /// <summary>
-            /// Identity of this task. 
+            /// Identity of this task.
             /// </summary>
             internal RegisteredTaskIdentity TaskIdentity => _taskIdentity;
 
             /// <summary>
-            /// Ask the question, whether or not the task name can be created by the task factory. 
-            /// To answer this question we need to instantiate and initialize the task factory and ask it if it can create the given task name. 
-            /// This question is useful for assembly tasks where the task may or may not be in an assembly, this can also be useful if the task factory 
+            /// Ask the question, whether or not the task name can be created by the task factory.
+            /// To answer this question we need to instantiate and initialize the task factory and ask it if it can create the given task name.
+            /// This question is useful for assembly tasks where the task may or may not be in an assembly, this can also be useful if the task factory
             /// loads an external file and uses that to generate the tasks.
             /// </summary>
             /// <returns>true if the task can be created by the factory, false if it cannot be created</returns>
@@ -1263,7 +1260,7 @@ internal bool CanTaskBeCreatedByFactory(string taskName, string taskProjectFile,
             }
 
             /// <summary>
-            /// Given a Registered task record and a task name. Check create an instance of the task factory using the record. 
+            /// Given a Registered task record and a task name. Check create an instance of the task factory using the record.
             /// If the factory is a assembly task factory see if the assemblyFile has the correct task inside of it.
             /// </summary>
             internal TaskFactoryWrapper GetTaskFactoryFromRegistrationRecord(string taskName, string taskProjectFile, IDictionary<string, string> taskIdentityParameters, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation)
@@ -1290,7 +1287,6 @@ private bool GetTaskFactory(TargetLoggingContext targetLoggingContext, ElementLo
                     ITaskFactory factory = null;
                     LoadedType loadedType = null;
 
-
                     bool isAssemblyTaskFactory = String.Equals(TaskFactoryAttributeName, AssemblyTaskFactory, StringComparison.OrdinalIgnoreCase);
                     bool isTaskHostFactory = String.Equals(TaskFactoryAttributeName, TaskHostFactory, StringComparison.OrdinalIgnoreCase);
 
@@ -1475,7 +1471,6 @@ private bool GetTaskFactory(TargetLoggingContext targetLoggingContext, ElementLo
                         }
                     }
 
-
                     _taskFactoryWrapperInstance = new TaskFactoryWrapper(factory, loadedType, RegisteredName, TaskFactoryParameters);
                 }
 
@@ -1543,8 +1538,8 @@ internal void ExpandUsingTask<P, I>(ProjectUsingTaskElement projectUsingTaskXml,
                     where P : class, IProperty
                     where I : class, IItem
                 {
-                    ErrorUtilities.VerifyThrowArgumentNull(projectUsingTaskXml, "projectUsingTaskXml");
-                    ErrorUtilities.VerifyThrowArgumentNull(expander, "expander");
+                    ErrorUtilities.VerifyThrowArgumentNull(projectUsingTaskXml, nameof(projectUsingTaskXml));
+                    ErrorUtilities.VerifyThrowArgumentNull(expander, nameof(expander));
 
                     ProjectUsingTaskBodyElement taskElement = projectUsingTaskXml.TaskBody;
                     if (taskElement != null)
@@ -1607,7 +1602,7 @@ private void ParseUsingTaskParameterGroupElement<P, I>(UsingTaskParameterGroupEl
                     where P : class, IProperty
                     where I : class, IItem
                 {
-                    _usingTaskParameters = _usingTaskParameters ?? new Dictionary<string, TaskPropertyInfo>(StringComparer.OrdinalIgnoreCase);
+                    _usingTaskParameters ??= new Dictionary<string, TaskPropertyInfo>(StringComparer.OrdinalIgnoreCase);
 
                     // Go through each of the parameters and create new ParameterInfo objects from them
                     foreach (ProjectUsingTaskParameterElement parameter in usingTaskParameterGroup.Parameters)
@@ -1665,7 +1660,7 @@ private void ParseUsingTaskParameterGroupElement<P, I>(UsingTaskParameterGroupEl
 
                         if (
                             (!output && (!TaskParameterTypeVerifier.IsValidInputParameter(paramType))) ||
-                            (output && !(TaskParameterTypeVerifier.IsValidOutputParameter(paramType)))
+                            (output && !TaskParameterTypeVerifier.IsValidOutputParameter(paramType))
                            )
                         {
                             ProjectErrorUtilities.ThrowInvalidProject
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index 1b265e7fb62..aad71143328 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -64,7 +64,7 @@ internal static ConsoleColor BackgroundColor
 
         /// <summary>
         /// Gets or sets the number of MSBuild processes participating in the build. If greater than 1,
-        /// include the node ID 
+        /// include the node ID
         /// </summary>
         public int NumberOfProcessors { get; set; } = 1;
 
@@ -113,7 +113,7 @@ public void ParseParameters()
         }
 
         /// <summary>
-        /// An implementation of IComparer useful for comparing the keys 
+        /// An implementation of IComparer useful for comparing the keys
         /// on DictionaryEntry's
         /// </summary>
         /// <remarks>Uses CurrentCulture for display purposes</remarks>
@@ -126,7 +126,7 @@ public int Compare(DictionaryEntry a, DictionaryEntry b)
         }
 
         /// <summary>
-        /// An implementation of IComparer useful for comparing the ItemSpecs 
+        /// An implementation of IComparer useful for comparing the ItemSpecs
         /// on ITaskItem's
         /// </summary>
         /// <remarks>Uses CurrentCulture for display purposes</remarks>
@@ -208,7 +208,7 @@ internal void WriteLinePrettyFromResource(int indentLevel, string resourceString
         }
 
         /// <summary>
-        /// Writes to the log, using the default indentation. Does not 
+        /// Writes to the log, using the default indentation. Does not
         /// terminate with a newline.
         /// </summary>
         internal void WritePretty(string formattedString)
@@ -271,12 +271,12 @@ internal void ShowPerfSummary()
         }
 
         /// <summary>
-        /// Writes to the log, using the specified indentation. Does not 
+        /// Writes to the log, using the specified indentation. Does not
         /// terminate with a newline.
         /// </summary>
         internal void WritePretty(int indentLevel, string formattedString)
         {
-            StringBuilder result = new StringBuilder(indentLevel * tabWidth + formattedString.Length);
+            StringBuilder result = new StringBuilder((indentLevel * tabWidth) + formattedString.Length);
             result.Append(' ', indentLevel * tabWidth).Append(formattedString);
             WriteHandler(result.ToString());
         }
@@ -481,7 +481,7 @@ internal void InitializeConsoleMethods(LoggerVerbosity logverbosity, WriteHandle
         /// <summary>
         /// Writes out the list of property names and their values.
         /// This could be done at any time during the build to show the latest
-        /// property values, using the cached reference to the list from the 
+        /// property values, using the cached reference to the list from the
         /// appropriate ProjectStarted event.
         /// </summary>
         /// <param name="properties">List of properties</param>
@@ -520,7 +520,7 @@ internal void WriteEnvironment(IDictionary<string, string> environment)
         }
 
         /// <summary>
-        /// Generate a list which contains the properties referenced by the properties 
+        /// Generate a list which contains the properties referenced by the properties
         /// enumerable object
         /// </summary>
         internal List<DictionaryEntry> ExtractPropertyList(IEnumerable properties)
@@ -552,7 +552,7 @@ internal virtual void OutputEnvironment(IDictionary<string, string> environment)
                     setColor(ConsoleColor.Gray);
                     WritePretty(String.Format(CultureInfo.CurrentCulture, "{0,-30} = ", entry.Key));
                     setColor(ConsoleColor.DarkGray);
-                    WriteLinePretty((entry.Value));
+                    WriteLinePretty(entry.Value);
                 }
             }
 
@@ -578,7 +578,7 @@ internal virtual void OutputProperties(List<DictionaryEntry> list)
         /// <summary>
         /// Writes out the list of item specs and their metadata.
         /// This could be done at any time during the build to show the latest
-        /// items, using the cached reference to the list from the 
+        /// items, using the cached reference to the list from the
         /// appropriate ProjectStarted event.
         /// </summary>
         internal void WriteItems(SortedList itemTypes)
@@ -678,7 +678,6 @@ internal virtual void OutputItems(string itemType, ArrayList itemTypeList)
             resetColor();
         }
 
-
         /// <summary>
         /// Returns a performance counter for a given scope (either task name or target name)
         /// from the given table.
@@ -837,13 +836,13 @@ internal virtual void PrintCounterMessage(WriteLinePrettyFromResourceDelegate wr
             }
 
             /// <summary>
-            /// Returns an IComparer that will put performance counters 
+            /// Returns an IComparer that will put performance counters
             /// in descending order by elapsed time.
             /// </summary>
             internal static IComparer DescendingByElapsedTimeComparer => new DescendingByElapsedTime();
 
             /// <summary>
-            /// Private IComparer class for sorting performance counters 
+            /// Private IComparer class for sorting performance counters
             /// in descending order by elapsed time.
             /// </summary>
             internal class DescendingByElapsedTime : IComparer
@@ -969,7 +968,7 @@ public virtual void Initialize(IEventSource eventSource)
         /// </summary>
         internal virtual bool ApplyParameter(string parameterName, string parameterValue)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parameterName, "parameterName");
+            ErrorUtilities.VerifyThrowArgumentNull(parameterName, nameof(parameterName));
 
             switch (parameterName.ToUpperInvariant())
             {
@@ -1007,16 +1006,11 @@ internal virtual bool ApplyParameter(string parameterName, string parameterValue
                         }
                         else
                         {
-                            switch (parameterValue.ToUpperInvariant())
+                            showProjectFile = (parameterValue.ToUpperInvariant()) switch
                             {
-                                case "TRUE":
-                                    showProjectFile = true;
-                                    break;
-
-                                default:
-                                    showProjectFile = false;
-                                    break;
-                            }
+                                "TRUE" => true,
+                                _ => false,
+                            };
                         }
                     }
 
@@ -1180,7 +1174,6 @@ private bool ApplyVerbosityParameter(string parameterValue)
 
         internal bool runningWithCharacterFileType = false;
 
-
         #region Per-build Members
 
         /// <summary>
@@ -1219,7 +1212,7 @@ private bool ApplyVerbosityParameter(string parameterValue)
         internal Dictionary<string, PerformanceCounter> taskPerformanceCounters;
 
         /// <summary>
-        /// 
+        ///
         /// </summary>
         internal Dictionary<string, PerformanceCounter> projectEvaluationPerformanceCounters;
 
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
index 22bc39ace76..264eba384ca 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
@@ -53,9 +53,7 @@ public void Replay(string sourceFilePath, CancellationToken cancellationToken)
                         return;
                     }
 
-                    BuildEventArgs instance = null;
-
-                    instance = reader.Read();
+                    BuildEventArgs instance = reader.Read();
                     if (instance == null)
                     {
                         break;
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index e67c64310af..5ee2af9780c 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -971,7 +971,6 @@ private EvaluationLocation ReadEvaluationLocation()
                 if (hasParent)
                 {
                     parentId = ReadInt64();
-
                 }
                 return new EvaluationLocation(id, parentId, evaluationPass, evaluationDescription, file, line, elementName, description, kind);
             }
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 8a46cb45cac..bc8f203903e 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -670,7 +670,7 @@ private void Write(BuildEventContext buildEventContext)
 
         private void Write<TKey, TValue>(IEnumerable<KeyValuePair<TKey, TValue>> keyValuePairs)
         {
-            if (keyValuePairs != null && keyValuePairs.Any())
+            if (keyValuePairs?.Any() == true)
             {
                 Write(keyValuePairs.Count());
                 foreach (var kvp in keyValuePairs)
diff --git a/src/Build/Logging/ConsoleLogger.cs b/src/Build/Logging/ConsoleLogger.cs
index 78b067f88df..b865a4764b0 100644
--- a/src/Build/Logging/ConsoleLogger.cs
+++ b/src/Build/Logging/ConsoleLogger.cs
@@ -58,7 +58,6 @@ public class ConsoleLogger : INodeLogger
         private bool _skipProjectStartedText = false;
         private bool? _showSummary;
 
-
         #region Constructors
 
         /// <summary>
@@ -120,19 +119,19 @@ private void InitializeBaseConsoleLogger()
                 {
                     if (param.Length <= 0) continue;
 
-                    if (0 == string.Compare(param, "ENABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(param, "ENABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
                     {
                         useMPLogger = true;
                     }
-                    if (0 == string.Compare(param, "DISABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(param, "DISABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
                     {
                         useMPLogger = false;
                     }
-                    if (0 == string.Compare(param, "DISABLECONSOLECOLOR", StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(param, "DISABLECONSOLECOLOR", StringComparison.OrdinalIgnoreCase))
                     {
                         disableConsoleColor = true;
                     }
-                    if (0 == string.Compare(param, "FORCECONSOLECOLOR", StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(param, "FORCECONSOLECOLOR", StringComparison.OrdinalIgnoreCase))
                     {
                         forceConsoleColor = true;
                     }
diff --git a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
index 6b04b3cf31f..0267891d4d3 100644
--- a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
@@ -105,9 +105,7 @@ private void ParseParameters()
         {
             if (_loggerParameters != null)
             {
-                string[] parameterComponents;
-
-                parameterComponents = _loggerParameters.Split(s_parameterDelimiters);
+                string[] parameterComponents = _loggerParameters.Split(s_parameterDelimiters);
                 for (int param = 0; param < parameterComponents.Length; param++)
                 {
                     if (parameterComponents[param].Length > 0)
@@ -131,7 +129,7 @@ private void ParseParameters()
         /// </summary>
         private void ApplyParameter(string parameterName)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parameterName, "parameterName");
+            ErrorUtilities.VerifyThrowArgumentNull(parameterName, nameof(parameterName));
 
             if (_forwardingTable.ContainsKey(parameterName))
             {
@@ -141,15 +139,15 @@ private void ApplyParameter(string parameterName)
 
             // If any of the following parameters are set, we will make sure we forward the events
             // necessary for the central logger to emit the requested information
-            if (0 == String.Compare(parameterName, PerformanceSummaryDescription, StringComparison.OrdinalIgnoreCase))
+            if (String.Equals(parameterName, PerformanceSummaryDescription, StringComparison.OrdinalIgnoreCase))
             {
                 _showPerfSummary = true;
             }
-            else if (0 == String.Compare(parameterName, NoSummaryDescription, StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, NoSummaryDescription, StringComparison.OrdinalIgnoreCase))
             {
                 _showSummary = false;
             }
-            else if (0 == String.Compare(parameterName, ShowCommandLineDescription, StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, ShowCommandLineDescription, StringComparison.OrdinalIgnoreCase))
             {
                 _showCommandLine = true;
             }
@@ -160,7 +158,7 @@ private void ApplyParameter(string parameterName)
         /// </summary>
         public virtual void Initialize(IEventSource eventSource)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(eventSource, "eventSource");
+            ErrorUtilities.VerifyThrowArgumentNull(eventSource, nameof(eventSource));
 
             ParseParameters();
 
@@ -171,19 +169,19 @@ public virtual void Initialize(IEventSource eventSource)
                 SetForwardingBasedOnVerbosity();
             }
 
-            eventSource.BuildStarted += new BuildStartedEventHandler(BuildStartedHandler);
-            eventSource.BuildFinished += new BuildFinishedEventHandler(BuildFinishedHandler);
-            eventSource.ProjectStarted += new ProjectStartedEventHandler(ProjectStartedHandler);
-            eventSource.ProjectFinished += new ProjectFinishedEventHandler(ProjectFinishedHandler);
-            eventSource.TargetStarted += new TargetStartedEventHandler(TargetStartedHandler);
-            eventSource.TargetFinished += new TargetFinishedEventHandler(TargetFinishedHandler);
-            eventSource.TaskStarted += new TaskStartedEventHandler(TaskStartedHandler);
-            eventSource.TaskFinished += new TaskFinishedEventHandler(TaskFinishedHandler);
-            eventSource.ErrorRaised += new BuildErrorEventHandler(ErrorHandler);
-            eventSource.WarningRaised += new BuildWarningEventHandler(WarningHandler);
-            eventSource.MessageRaised += new BuildMessageEventHandler(MessageHandler);
-            eventSource.CustomEventRaised += new CustomBuildEventHandler(CustomEventHandler);
-            eventSource.StatusEventRaised += new BuildStatusEventHandler(BuildStatusHandler);
+            eventSource.BuildStarted += BuildStartedHandler;
+            eventSource.BuildFinished += BuildFinishedHandler;
+            eventSource.ProjectStarted += ProjectStartedHandler;
+            eventSource.ProjectFinished += ProjectFinishedHandler;
+            eventSource.TargetStarted += TargetStartedHandler;
+            eventSource.TargetFinished += TargetFinishedHandler;
+            eventSource.TaskStarted += TaskStartedHandler;
+            eventSource.TaskFinished += TaskFinishedHandler;
+            eventSource.ErrorRaised += ErrorHandler;
+            eventSource.WarningRaised += WarningHandler;
+            eventSource.MessageRaised += MessageHandler;
+            eventSource.CustomEventRaised += CustomEventHandler;
+            eventSource.StatusEventRaised += BuildStatusHandler;
         }
 
         /// <summary>
@@ -262,7 +260,6 @@ private void SetForwardingBasedOnVerbosity()
             }
         }
 
-
         /// <summary>
         /// Reset the states of per-build member variables.
         /// Used when a build is finished, but the logger might be needed for the next build.
@@ -478,7 +475,7 @@ protected virtual void ForwardToCentralLogger(BuildEventArgs e)
         /// </summary>
         private bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity)
         {
-            return (_verbosity >= checkVerbosity);
+            return _verbosity >= checkVerbosity;
         }
         #endregion
 
diff --git a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
index f488f9eee31..cca7e04d994 100644
--- a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -43,9 +43,7 @@ private void ParseFileLoggerParameters()
         {
             if (this.Parameters != null)
             {
-                string[] parameterComponents;
-
-                parameterComponents = this.Parameters.Split(s_fileLoggerParameterDelimiters);
+                string[] parameterComponents = this.Parameters.Split(s_fileLoggerParameterDelimiters);
                 for (int param = 0; param < parameterComponents.Length; param++)
                 {
                     if (parameterComponents[param].Length > 0)
@@ -70,7 +68,7 @@ private void ParseFileLoggerParameters()
         /// </summary>
         private void ApplyFileLoggerParameter(string parameterName, string parameterValue)
         {
-            if (String.Compare("LOGFILE", parameterName, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals("LOGFILE", parameterName, StringComparison.OrdinalIgnoreCase))
             {
                 if (string.IsNullOrEmpty(parameterValue))
                 {
@@ -96,7 +94,7 @@ private void ApplyFileLoggerParameter(string parameterName, string parameterValu
         /// </summary>
         public void Initialize(IEventSource eventSource)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(eventSource, "eventSource");
+            ErrorUtilities.VerifyThrowArgumentNull(eventSource, nameof(eventSource));
             ParseFileLoggerParameters();
             string fileName = _logFile;
             try
@@ -118,10 +116,7 @@ public void Initialize(IEventSource eventSource)
             }
             catch (ArgumentException e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
-                if (_nodeFileLogger != null)
-                {
-                    _nodeFileLogger.Shutdown();
-                }
+                _nodeFileLogger?.Shutdown();
 
                 string errorCode;
                 string helpKeyword;
@@ -138,10 +133,7 @@ public void Initialize(IEventSource eventSource)
         /// </summary>
         public void Shutdown()
         {
-            if (_nodeFileLogger != null)
-            {
-                _nodeFileLogger.Shutdown();
-            }
+            _nodeFileLogger?.Shutdown();
         }
         #endregion
 
diff --git a/src/Build/Logging/EvaluationLocationIdAgnosticComparer.cs b/src/Build/Logging/EvaluationLocationIdAgnosticComparer.cs
index e57c17d68b8..7160c103006 100644
--- a/src/Build/Logging/EvaluationLocationIdAgnosticComparer.cs
+++ b/src/Build/Logging/EvaluationLocationIdAgnosticComparer.cs
@@ -36,13 +36,13 @@ public bool Equals(EvaluationLocation x, EvaluationLocation y)
         public int GetHashCode(EvaluationLocation obj)
         {
             var hashCode = 1198539463;
-            hashCode = hashCode * -1521134295 + obj.EvaluationPass.GetHashCode();
-            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(obj.EvaluationPassDescription);
-            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(obj.File);
-            hashCode = hashCode * -1521134295 + EqualityComparer<int?>.Default.GetHashCode(obj.Line);
-            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(obj.ElementName);
-            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(obj.ElementDescription);
-            hashCode = hashCode * -1521134295 + obj.Kind.GetHashCode();
+            hashCode = (hashCode * -1521134295) + EqualityComparer<EvaluationPass>.Default.GetHashCode(obj.EvaluationPass);
+            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(obj.EvaluationPassDescription);
+            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(obj.File);
+            hashCode = (hashCode * -1521134295) + EqualityComparer<int?>.Default.GetHashCode(obj.Line);
+            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(obj.ElementName);
+            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(obj.ElementDescription);
+            hashCode = (hashCode * -1521134295) + EqualityComparer<EvaluationLocationKind>.Default.GetHashCode(obj.Kind);
             return hashCode;
         }
     }
diff --git a/src/Build/Logging/FileLogger.cs b/src/Build/Logging/FileLogger.cs
index 704ae2fb3fe..7394b006c0f 100644
--- a/src/Build/Logging/FileLogger.cs
+++ b/src/Build/Logging/FileLogger.cs
@@ -48,7 +48,7 @@ public FileLogger()
         /// <param name="eventSource">Available events.</param>
         public override void Initialize(IEventSource eventSource)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(eventSource, "eventSource");
+            ErrorUtilities.VerifyThrowArgumentNull(eventSource, nameof(eventSource));
             eventSource.BuildFinished += FileLoggerBuildFinished;
             InitializeFileLogger(eventSource, 1);
         }
diff --git a/src/Build/Logging/LoggerDescription.cs b/src/Build/Logging/LoggerDescription.cs
index 918314c8891..79e0aa1e95e 100644
--- a/src/Build/Logging/LoggerDescription.cs
+++ b/src/Build/Logging/LoggerDescription.cs
@@ -280,12 +280,12 @@ private ILogger CreateLogger(bool forwardingLogger)
         /// <returns>true, if specified type is a logger</returns>
         private static bool IsForwardingLoggerClass(Type type, object unused)
         {
-            return (type.GetTypeInfo().IsClass &&
+            return type.GetTypeInfo().IsClass &&
                 !type.GetTypeInfo().IsAbstract &&
 #if FEATURE_TYPE_GETINTERFACE
-                (type.GetTypeInfo().GetInterface("IForwardingLogger") != null));
+                (type.GetTypeInfo().GetInterface("IForwardingLogger") != null);
 #else
-                (type.GetInterfaces().Any(interfaceType => interfaceType.Name == "IForwardingLogger")));
+                (type.GetInterfaces().Any(interfaceType => interfaceType.Name == "IForwardingLogger"));
 #endif
         }
 
@@ -296,12 +296,12 @@ private static bool IsForwardingLoggerClass(Type type, object unused)
         /// <returns>true, if specified type is a logger</returns>
         private static bool IsLoggerClass(Type type, object unused)
         {
-            return (type.GetTypeInfo().IsClass &&
+            return type.GetTypeInfo().IsClass &&
                 !type.GetTypeInfo().IsAbstract &&
 #if FEATURE_TYPE_GETINTERFACE
-                (type.GetTypeInfo().GetInterface("ILogger") != null));
+                (type.GetTypeInfo().GetInterface("ILogger") != null);
 #else
-                (type.GetInterfaces().Any(interfaceType => interfaceType.Name == "ILogger")));
+                (type.GetInterfaces().Any(interfaceType => interfaceType.Name == "ILogger"));
 #endif
         }
 
diff --git a/src/Build/Logging/NullCentralLogger.cs b/src/Build/Logging/NullCentralLogger.cs
index 7f5eb1d4d58..9e65359edac 100644
--- a/src/Build/Logging/NullCentralLogger.cs
+++ b/src/Build/Logging/NullCentralLogger.cs
@@ -49,7 +49,7 @@ public string Parameters
         #region Methods
         public void Initialize(IEventSource eventSource, int nodeCount)
         {
-            eventSource.AnyEventRaised += new AnyEventHandler(AnyEventRaisedHandler);
+            eventSource.AnyEventRaised += AnyEventRaisedHandler;
         }
 
         public void AnyEventRaisedHandler(object sender, BuildEventArgs e)
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index d953fa3d78d..755391e0e38 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -26,8 +26,12 @@ namespace Microsoft.Build.BackEnd.Logging
     /// <remarks>This class is not thread safe.</remarks>
     internal class ParallelConsoleLogger : BaseConsoleLogger
     {
-        #region Constructors
+        /// <summary>
+        /// Associate a (nodeID and project_context_id) to a target framework.
+        /// </summary>
+        internal Dictionary<(int nodeId, int contextId), string> propertyOutputMap = new Dictionary<(int nodeId, int contextId), string>();
 
+        #region Constructors
         /// <summary>
         /// Default constructor.
         /// </summary>
@@ -119,7 +123,7 @@ internal override bool ApplyParameter(string parameterName, string parameterValu
                 return true;
             }
 
-            if (0 == String.Compare(parameterName, "SHOWCOMMANDLINE", StringComparison.OrdinalIgnoreCase))
+            if (String.Equals(parameterName, "SHOWCOMMANDLINE", StringComparison.OrdinalIgnoreCase))
             {
                 if (String.IsNullOrEmpty(parameterValue))
                 {
@@ -140,17 +144,17 @@ internal override bool ApplyParameter(string parameterName, string parameterValu
 
                 return true;
             }
-            else if (0 == String.Compare(parameterName, "SHOWTIMESTAMP", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "SHOWTIMESTAMP", StringComparison.OrdinalIgnoreCase))
             {
                 _showTimeStamp = true;
                 return true;
             }
-            else if (0 == String.Compare(parameterName, "SHOWEVENTID", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "SHOWEVENTID", StringComparison.OrdinalIgnoreCase))
             {
                 _showEventId = true;
                 return true;
             }
-            else if (0 == String.Compare(parameterName, "FORCENOALIGN", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "FORCENOALIGN", StringComparison.OrdinalIgnoreCase))
             {
                 _forceNoAlign = true;
                 _alignMessages = false;
@@ -204,7 +208,8 @@ internal override void ResetConsoleLoggerState()
             taskPerformanceCounters = null;
             _hasBuildStarted = false;
 
-            // Reset the two data structures created when the logger was created
+            // Reset the data structures created when the logger was created
+            propertyOutputMap = new Dictionary<(int, int), string>();
             _buildEventManager = new BuildEventManager();
             _deferredMessages = new Dictionary<BuildEventContext, List<BuildMessageEventArgs>>(s_compareContextNodeId);
             _prefixWidth = 0;
@@ -351,7 +356,7 @@ private void ShowFlatErrorWarningSummary()
                 setColor(ConsoleColor.Yellow);
                 foreach (BuildWarningEventArgs warning in warningList)
                 {
-                    WriteMessageAligned(EventArgsFormatting.FormatEventMessage(warning, showProjectFile), true);
+                    WriteMessageAligned(EventArgsFormatting.FormatEventMessage(warning, showProjectFile, FindLogOutputProperties(warning)), true);
                 }
             }
 
@@ -360,7 +365,7 @@ private void ShowFlatErrorWarningSummary()
                 setColor(ConsoleColor.Red);
                 foreach (BuildErrorEventArgs error in errorList)
                 {
-                    WriteMessageAligned(EventArgsFormatting.FormatEventMessage(error, showProjectFile), true);
+                    WriteMessageAligned(EventArgsFormatting.FormatEventMessage(error, showProjectFile, FindLogOutputProperties(error)), true);
                 }
             }
 
@@ -425,14 +430,14 @@ private void ShowErrorWarningSummary(IEnumerable<BuildEventArgs> listToProcess)
                 ErrorWarningSummaryDictionaryKey key = new ErrorWarningSummaryDictionaryKey(errorWarningEventArgs.BuildEventContext, targetName);
 
                 // Check to see if there is a bucket for the warning
+                // If there is no bucket create a new one which contains a list of all the errors which
+                // happened for a given buildEventContext / target
                 if (!groupByProjectEntryPoint.ContainsKey(key))
                 {
-                    // If there is no bucket create a new one which contains a list of all the errors which
                     // happened for a given buildEventContext / target
                     var errorWarningEventListByTarget = new List<BuildEventArgs>();
                     groupByProjectEntryPoint.Add(key, errorWarningEventListByTarget);
                 }
-
                 // Add the error event to the correct bucket
                 groupByProjectEntryPoint[key].Add(errorWarningEventArgs);
             }
@@ -442,7 +447,7 @@ private void ShowErrorWarningSummary(IEnumerable<BuildEventArgs> listToProcess)
             // Loop through each of the bucket and print out the stack trace information for the errors
             foreach (KeyValuePair<ErrorWarningSummaryDictionaryKey, List<BuildEventArgs>> valuePair in groupByProjectEntryPoint)
             {
-                //If the project entry point where the error occurred is the same as the previous message do not print the
+                // If the project entry point where the error occurred is the same as the previous message do not print the
                 // stack trace again
                 if (previousEntryPoint != valuePair.Key.EntryPointContext)
                 {
@@ -454,11 +459,11 @@ private void ShowErrorWarningSummary(IEnumerable<BuildEventArgs> listToProcess)
                     previousEntryPoint = valuePair.Key.EntryPointContext;
                 }
 
-                //If the target where the error occurred is the same as the previous message do not print the location
+                // If the target where the error occurred is the same as the previous message do not print the location
                 // where the error occurred again
-                if (String.Compare(previousTarget, valuePair.Key.TargetName, StringComparison.OrdinalIgnoreCase) != 0)
+                if (!String.Equals(previousTarget, valuePair.Key.TargetName, StringComparison.OrdinalIgnoreCase))
                 {
-                    //If no targetName was specified then do not show the target where the error occurred
+                    // If no targetName was specified then do not show the target where the error occurred
                     if (!string.IsNullOrEmpty(valuePair.Key.TargetName))
                     {
                         WriteMessageAligned(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ErrorWarningInTarget", valuePair.Key.TargetName), false);
@@ -471,11 +476,11 @@ private void ShowErrorWarningSummary(IEnumerable<BuildEventArgs> listToProcess)
                 {
                     if (errorWarningEvent is BuildErrorEventArgs)
                     {
-                        WriteMessageAligned("  " + EventArgsFormatting.FormatEventMessage(errorWarningEvent as BuildErrorEventArgs, showProjectFile), false);
+                        WriteMessageAligned("  " + EventArgsFormatting.FormatEventMessage(errorWarningEvent as BuildErrorEventArgs, showProjectFile, FindLogOutputProperties(errorWarningEvent)), false);
                     }
                     else if (errorWarningEvent is BuildWarningEventArgs)
                     {
-                        WriteMessageAligned("  " + EventArgsFormatting.FormatEventMessage(errorWarningEvent as BuildWarningEventArgs, showProjectFile), false);
+                        WriteMessageAligned("  " + EventArgsFormatting.FormatEventMessage(errorWarningEvent as BuildWarningEventArgs, showProjectFile, FindLogOutputProperties(errorWarningEvent)), false);
                     }
                 }
                 WriteNewLine();
@@ -516,25 +521,50 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
                 _deferredMessages.Remove(e.BuildEventContext);
             }
 
-            //If we are in diagnostic and are going to show items, show the project started event
+            // If we are in diagnostic and are going to show items, show the project started event
             // along with the items. The project started event will only be shown if it has not been shown before
             if (Verbosity == LoggerVerbosity.Diagnostic && showItemAndPropertyList)
             {
-                //Show the deferredProjectStartedEvent
+                // Show the deferredProjectStartedEvent
                 if (!showOnlyErrors && !showOnlyWarnings)
                 {
                     DisplayDeferredProjectStartedEvent(e.BuildEventContext);
                 }
-                if (null != e.Properties)
+                if (e.Properties != null)
                 {
                     WriteProperties(e, e.Properties);
                 }
 
-                if (null != e.Items)
+                if (e.Items != null)
                 {
                     WriteItems(e, e.Items);
                 }
             }
+
+            if (e.BuildEventContext == null || e.Items == null)
+            {
+                return;
+            }
+
+            // node and project context ids for the propertyOutputMap key.
+            int nodeID = e.BuildEventContext.NodeId;
+            int projectContextId = e.BuildEventContext.ProjectContextId;
+
+            // Create the value to be added to the propertyOutputMap.
+            using var projectConfigurationDescription = new ReuseableStringBuilder();
+
+            foreach (DictionaryEntry item in e.Items)
+            {
+                ITaskItem itemVal = (ITaskItem)item.Value;
+                // Determine if the LogOutputProperties item has been used.
+                if (string.Equals((string)item.Key, ItemMetadataNames.ProjectConfigurationDescription, StringComparison.OrdinalIgnoreCase))
+                {
+                    // Add the item value to the string to be printed in error/warning messages.
+                    projectConfigurationDescription.Append(" ").Append(itemVal.ItemSpec);
+                }
+            }
+            // Add the finished dictionary to propertyOutputMap.
+            propertyOutputMap.Add((nodeID, projectContextId), projectConfigurationDescription.ToString());
         }
 
         /// <summary>
@@ -546,8 +576,7 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
         {
             ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
 
-
-            //Get the project started event so we can use its information to properly display a project finished event
+            // Get the project started event so we can use its information to properly display a project finished event
             ProjectStartedEventMinimumFields startedEvent = _buildEventManager.GetProjectStartedEvent(e.BuildEventContext);
             ErrorUtilities.VerifyThrow(startedEvent != null, "Project finished event for {0} received without matching start event", e.ProjectFile);
 
@@ -573,10 +602,8 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
                         // In the project finished message the targets which were built and the project which was built
                         // should be shown
                         string targets = startedEvent.TargetNames;
-
-                        string projectName = string.Empty;
-
-                        projectName = startedEvent.ProjectFile == null ? string.Empty : startedEvent.ProjectFile;
+                        string projectName = startedEvent.ProjectFile ?? string.Empty;
+                        
                         // Show which targets were built as part of this project
                         if (string.IsNullOrEmpty(targets))
                         {
@@ -694,7 +721,7 @@ internal void WriteItems(BuildEventArgs e, IEnumerable items)
             if (showOnlyErrors || showOnlyWarnings) return;
             SortedList itemList = ExtractItemList(items);
 
-            // if there are no Items to display return out of the method and don't print out anything related to displaying
+            // If there are no Items to display return out of the method and don't print out anything related to displaying
             // the items, this includes the multiproc prefix information or the Initial items header
             if (itemList.Count == 0)
             {
@@ -720,7 +747,7 @@ internal override void OutputItems(string itemType, ArrayList itemTypeList)
                 setColor(ConsoleColor.Gray);
 
                 // Indent the text by two tab lengths
-                StringBuilder result = new StringBuilder(2 * tabWidth + item.ItemSpec.Length);
+                StringBuilder result = new StringBuilder((2 * tabWidth) + item.ItemSpec.Length);
                 result.Append(' ', 2 * tabWidth).Append(item.ItemSpec);
                 WriteMessageAligned(result.ToString(), false);
 
@@ -756,7 +783,6 @@ public override void TargetStartedHandler(object sender, TargetStartedEventArgs
             // later in the build
             _buildEventManager.AddTargetStartedEvent(e, _showTimeStamp || IsVerbosityAtLeast(LoggerVerbosity.Detailed));
 
-
             if (this.showPerfSummary)
             {
                 // Create a new performance counter for this target
@@ -833,7 +859,7 @@ public override void TargetFinishedHandler(object sender, TargetFinishedEventArg
                 }
             }
 
-            //We no longer need this target started event, it can be removed
+            // We no longer need this target started event, it can be removed
             _buildEventManager.RemoveTargetStartedEvent(e.BuildEventContext);
         }
 
@@ -914,6 +940,22 @@ public override void TaskFinishedHandler(object sender, TaskFinishedEventArgs e)
             }
         }
 
+        /// <summary>
+        /// Finds the LogOutProperty string to be printed in messages.
+        /// </summary>
+        /// <param name="e"> Build event to extract context information from.</param>
+        internal string FindLogOutputProperties(BuildEventArgs e)
+        {
+            string projectConfigurationDescription = String.Empty;
+            if (e.BuildEventContext != null)
+            {
+                int nodeId = e.BuildEventContext.NodeId;
+                int projectContextId = e.BuildEventContext.ProjectContextId;
+                propertyOutputMap.TryGetValue((nodeId, projectContextId), out projectConfigurationDescription);
+            }
+            return projectConfigurationDescription;
+        }
+
         /// <summary>
         /// Prints an error event
         /// </summary>
@@ -947,7 +989,7 @@ public override void ErrorHandler(object sender, BuildErrorEventArgs e)
                 }
 
                 setColor(ConsoleColor.Red);
-                WriteMessageAligned(EventArgsFormatting.FormatEventMessage(e, showProjectFile), true);
+                WriteMessageAligned(EventArgsFormatting.FormatEventMessage(e, showProjectFile, FindLogOutputProperties(e)), true);
                 ShownBuildEventContext(e.BuildEventContext);
                 if (ShowSummary == true)
                 {
@@ -993,7 +1035,7 @@ public override void WarningHandler(object sender, BuildWarningEventArgs e)
                 }
 
                 setColor(ConsoleColor.Yellow);
-                WriteMessageAligned(EventArgsFormatting.FormatEventMessage(e, showProjectFile), true);
+                WriteMessageAligned(EventArgsFormatting.FormatEventMessage(e, showProjectFile, FindLogOutputProperties(e)), true);
             }
 
             ShownBuildEventContext(e.BuildEventContext);
@@ -1059,7 +1101,7 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
                        && IsVerbosityAtLeast(LoggerVerbosity.Normal)
                     )
                 {
-                    List<BuildMessageEventArgs> messageList = null;
+                    List<BuildMessageEventArgs> messageList;
                     if (_deferredMessages.ContainsKey(e.BuildEventContext))
                     {
                         messageList = _deferredMessages[e.BuildEventContext];
@@ -1134,7 +1176,7 @@ private void PrintMessage(BuildMessageEventArgs e, bool lightenText)
             // Include file information if present.
             if (e.File != null)
             {
-                nonNullMessage = EventArgsFormatting.FormatEventMessage(e, showProjectFile);
+                nonNullMessage = EventArgsFormatting.FormatEventMessage(e, showProjectFile, FindLogOutputProperties(e));
             }
             else
             {
@@ -1165,7 +1207,7 @@ private void PrintMessage(BuildMessageEventArgs e, bool lightenText)
             }
             else
             {
-                //A time stamp may be shown on verbosities lower than diagnostic
+                // A time stamp may be shown on verbosities lower than diagnostic
                 if (_showTimeStamp || IsVerbosityAtLeast(LoggerVerbosity.Detailed))
                 {
                     bool prefixAlreadyWritten = WriteTargetMessagePrefix(e, e.BuildEventContext, e.Timestamp);
@@ -1195,7 +1237,7 @@ private void PrintTargetNamePerMessage(BuildMessageEventArgs e, bool lightenText
                 string targetName = string.Empty;
 
                 // Does the context (Project, Node, Context, Target, NOT task) of the previous event match the current message
-                bool contextAreEqual = s_compareContextNodeIdTargetId.Equals(currentBuildEventContext, _lastDisplayedBuildEventContext == null ? null : _lastDisplayedBuildEventContext);
+                bool contextAreEqual = s_compareContextNodeIdTargetId.Equals(currentBuildEventContext, _lastDisplayedBuildEventContext);
 
                 TargetStartedEventMinimumFields targetStartedEvent = null;
                 // If the previous event does not have the same target context information, the target name needs to be printed to the console
@@ -1241,7 +1283,7 @@ private bool WriteTargetMessagePrefix(BuildEventArgs e, BuildEventContext contex
         {
             bool prefixAlreadyWritten = true;
             ProjectFullKey currentProjectFullKey = GetFullProjectKey(e.BuildEventContext);
-            if (!(_lastProjectFullKey.Equals(currentProjectFullKey)))
+            if (!_lastProjectFullKey.Equals(currentProjectFullKey))
             {
                 // Write the prefix information about the target for the message
                 WriteLinePrefix(context, timeStamp, false);
@@ -1303,8 +1345,8 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int
                         {
                             // Calculate how many chars will fit on the console buffer
                             int amountToCopy = (messageLength - index) < (bufferWidthMinusNewLine - adjustedPrefixWidth) ? (messageLength - index) : (bufferWidthMinusNewLine - adjustedPrefixWidth);
-                            WriteBasedOnPrefix(nonNullMessage.Substring(index, amountToCopy), (prefixAlreadyWritten && index == 0 && i == 0), adjustedPrefixWidth);
-                            index = index + amountToCopy;
+                            WriteBasedOnPrefix(nonNullMessage.Substring(index, amountToCopy), prefixAlreadyWritten && index == 0 && i == 0, adjustedPrefixWidth);
+                            index += amountToCopy;
                         }
                     }
                     else
@@ -1342,10 +1384,10 @@ private void DisplayDeferredTargetStartedEvent(BuildEventContext e)
             // Get the deferred target started event
             TargetStartedEventMinimumFields targetStartedEvent = _buildEventManager.GetTargetStartedEvent(e);
 
-            //Make sure we have not shown the event before
-            if (targetStartedEvent != null && !targetStartedEvent.ShowTargetFinishedEvent)
+            // Make sure we have not shown the event before
+            if (targetStartedEvent?.ShowTargetFinishedEvent == false)
             {
-                //Since the target started event has been shows, the target finished event should also be shown
+                // Since the target started event has been shows, the target finished event should also be shown
                 targetStartedEvent.ShowTargetFinishedEvent = true;
 
                 // If there are any other started events waiting and we are the first message, show them
@@ -1417,14 +1459,14 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                 ProjectStartedEventMinimumFields projectStartedEvent = _buildEventManager.GetProjectStartedEvent(e);
 
                 // Make sure the project started event has not been show yet
-                if (projectStartedEvent != null && !projectStartedEvent.ShowProjectFinishedEvent)
+                if (projectStartedEvent?.ShowProjectFinishedEvent == false)
                 {
                     projectStartedEvent.ShowProjectFinishedEvent = true;
 
                     ProjectStartedEventMinimumFields parentStartedEvent = projectStartedEvent.ParentProjectStartedEvent;
                     if (parentStartedEvent != null)
                     {
-                        //Make sure that if there are any events deferred on this event to show them first
+                        // Make sure that if there are any events deferred on this event to show them first
                         DisplayDeferredStartedEvents(parentStartedEvent.ProjectBuildEventContext);
                     }
 
@@ -1440,7 +1482,7 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                         WriteLinePrefix(projectStartedEvent.FullProjectKey, projectStartedEvent.TimeStamp, false);
                         setColor(ConsoleColor.Cyan);
                         string message;
-                        if ((targetNames == null) || (targetNames.Length == 0))
+                        if (string.IsNullOrEmpty(targetNames))
                         {
                             message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStartedTopLevelProjectWithDefaultTargets", current, currentProjectNodeId);
                         }
@@ -1456,7 +1498,7 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                     {
                         WriteLinePrefix(parentStartedEvent.FullProjectKey, parentStartedEvent.TimeStamp, false);
                         setColor(ConsoleColor.Cyan);
-                        if ((targetNames == null) || (targetNames.Length == 0))
+                        if (string.IsNullOrEmpty(targetNames))
                         {
                             WriteMessageAligned(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStartedWithDefaultTargetsMultiProc", previous, parentStartedEvent.FullProjectKey, current, projectStartedEvent.FullProjectKey, currentProjectNodeId), true);
                         }
@@ -1552,7 +1594,7 @@ private ProjectFullKey GetFullProjectKey(BuildEventContext e)
                 startedEvent = _buildEventManager.GetProjectStartedEvent(e);
             }
 
-            //Project started event can be null, if the message has come before the project started event
+            // Project started event can be null, if the message has come before the project started event
             // or the message is not part of a project such as if the message came from the engine
             return startedEvent == null
                 ? new ProjectFullKey(0, 0)
@@ -1675,7 +1717,7 @@ internal override void PrintCounterMessage(WriteLinePrettyFromResourceDelegate W
                     String.Format(CultureInfo.CurrentCulture, "{0,-40}" /* pad to 40 align left */, scopeName),
                     String.Format(CultureInfo.CurrentCulture, "{0,3}", calls));
 
-                if (_internalPerformanceCounters != null && _internalPerformanceCounters.Count > 0)
+                if (_internalPerformanceCounters?.Count > 0)
                 {
                     // For each of the entry points in the project print out the performance numbers for them
                     foreach (var counter in _internalPerformanceCounters.Values)
diff --git a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index af005dfbe68..e767bf26bfb 100644
--- a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -50,12 +50,12 @@ internal void AddProjectStartedEvent(ProjectStartedEventArgs e, bool requireTime
                 if (!_projectStartedEvents.ContainsKey(e.BuildEventContext))
                 {
                     int projectTargetKeyLocal = 1;
-                    int projectIncrementKeyLocal = 1;
+                    int projectIncrementKeyLocal;
                     // If we haven't seen this project before (by full path) then
                     // allocate a new key for it and save it away
                     if (!_projectKey.ContainsKey(e.ProjectFile))
                     {
-                        _projectIncrementKey += 1;
+                        _projectIncrementKey++;
 
                         _projectKey[e.ProjectFile] = _projectIncrementKey;
                         projectIncrementKeyLocal = _projectIncrementKey;
@@ -214,7 +214,7 @@ internal void RemoveProjectStartedEvent(BuildEventContext e)
         {
             ProjectStartedEventMinimumFields startedEvent = GetProjectStartedEvent(e);
             // Only remove the project from the event list if it is in the list, and no errors have occurred in the project
-            if (startedEvent != null && !startedEvent.ErrorInProject)
+            if (startedEvent?.ErrorInProject == false)
             {
                 _projectStartedEvents.Remove(e);
             }
@@ -227,7 +227,7 @@ internal void RemoveTargetStartedEvent(BuildEventContext e)
         {
             TargetStartedEventMinimumFields startedEvent = GetTargetStartedEvent(e);
             // Only remove the project from the event list if it is in the list, and no errors have occurred in the project
-            if (startedEvent != null && !startedEvent.ErrorInTarget)
+            if (startedEvent?.ErrorInTarget == false)
             {
                 _targetStartedEvents.Remove(e);
             }
@@ -259,7 +259,7 @@ public bool Equals(T x, T y)
         public int GetHashCode(T x)
         {
             BuildEventContext context = x as BuildEventContext;
-            return (context.ProjectContextId + (context.NodeId << 24));
+            return context.ProjectContextId + (context.NodeId << 24);
         }
         #endregion
     }
@@ -289,7 +289,7 @@ public bool Equals(T x, T y)
         public int GetHashCode(T x)
         {
             BuildEventContext context = x as BuildEventContext;
-            return (context.ProjectContextId + (context.NodeId << 24));
+            return context.ProjectContextId + (context.NodeId << 24);
         }
 
         #endregion
@@ -569,7 +569,7 @@ internal class ErrorWarningSummaryDictionaryKey
         internal ErrorWarningSummaryDictionaryKey(BuildEventContext entryPoint, string targetName)
         {
             _entryPointContext = entryPoint;
-            _targetName = targetName == null ? string.Empty : targetName;
+            _targetName = targetName ?? string.Empty;
         }
         #endregion
 
@@ -601,12 +601,12 @@ public override bool Equals(object obj)
             {
                 return false;
             }
-            return s_eventComparer.Equals(_entryPointContext, key.EntryPointContext) && (String.Compare(_targetName, key.TargetName, StringComparison.OrdinalIgnoreCase) == 0);
+            return s_eventComparer.Equals(_entryPointContext, key.EntryPointContext) && (String.Equals(_targetName, key.TargetName, StringComparison.OrdinalIgnoreCase));
         }
 
         public override int GetHashCode()
         {
-            return (_entryPointContext.GetHashCode() + _targetName.GetHashCode());
+            return _entryPointContext.GetHashCode() + _targetName.GetHashCode();
         }
         #endregion
 
@@ -648,7 +648,6 @@ internal ProjectFullKey(int projectKey, int entryPointKey)
         /// <summary>
         /// Output the projectKey or the projectKey and the entrypointKey depending on the verbosity level of the logger
         /// </summary>
-
         public string ToString(LoggerVerbosity verbosity)
         {
             string fullProjectKey;
@@ -692,7 +691,7 @@ public override bool Equals(object obj)
             ProjectFullKey compareKey = obj as ProjectFullKey;
             if (compareKey != null)
             {
-                return ((compareKey._projectKey == _projectKey) && (compareKey._entryPointKey == _entryPointKey));
+                return (compareKey._projectKey == _projectKey) && (compareKey._entryPointKey == _entryPointKey);
             }
             else
             {
@@ -702,7 +701,7 @@ public override bool Equals(object obj)
 
         public override int GetHashCode()
         {
-            return (_projectKey + (_entryPointKey << 16));
+            return _projectKey + (_entryPointKey << 16);
         }
         #endregion
     }
diff --git a/src/Build/Logging/ProfilerLogger.cs b/src/Build/Logging/ProfilerLogger.cs
index db37ae85bf1..5d0ed444b07 100644
--- a/src/Build/Logging/ProfilerLogger.cs
+++ b/src/Build/Logging/ProfilerLogger.cs
@@ -143,7 +143,6 @@ internal ProfilerResult GetAggregatedResult(bool pruneSmallItems = true)
                 foreach (var pair in profiledResult.ProfiledLocations.OrderBy(p => p.Key.Id))
                 {
                     MergeItem(originalLocations, mergeMap, _aggregatedLocations, pair);
-
                 }
             }
 
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index 833fc16645c..1f38a87c5e8 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -265,13 +265,13 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
 
             if (Verbosity == LoggerVerbosity.Diagnostic && showItemAndPropertyList)
             {
-                if (null != e.Properties)
+                if (e.Properties != null)
                 {
                     var propertyList = ExtractPropertyList(e.Properties);
                     WriteProperties(propertyList);
                 }
 
-                if (null != e.Items)
+                if (e.Items != null)
                 {
                     SortedList itemList = ExtractItemList(e.Items);
                     WriteItems(itemList);
@@ -533,7 +533,7 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
                     setColor(ConsoleColor.DarkGray);
                 }
 
-                string nonNullMessage = null;
+                string nonNullMessage;
 
                 // Include file information if present.
                 if (e.File != null)
@@ -543,7 +543,7 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
                 else
                 {
                     // null messages are ok -- treat as blank line
-                    nonNullMessage = (e.Message == null) ? String.Empty : e.Message;
+                    nonNullMessage = e.Message ?? String.Empty;
                 }
 
                 WriteLinePretty(nonNullMessage);
@@ -630,13 +630,13 @@ private void WriteProjectStartedText(string current, string targetNames, string
             {
                 setColor(ConsoleColor.Cyan);
 
-                this.VerifyStack((current != null), "Unexpected null project stack");
+                this.VerifyStack(current != null, "Unexpected null project stack");
 
                 WriteLinePretty(projectSeparatorLine);
 
                 if (previous == null)
                 {
-                    if ((targetNames == null) || (targetNames.Length == 0))
+                    if (string.IsNullOrEmpty(targetNames))
                     {
                         WriteLinePrettyFromResource(indentLevel, "ProjectStartedPrefixForTopLevelProjectWithDefaultTargets", current);
                     }
@@ -647,7 +647,7 @@ private void WriteProjectStartedText(string current, string targetNames, string
                 }
                 else
                 {
-                    if ((targetNames == null) || (targetNames.Length == 0))
+                    if (string.IsNullOrEmpty(targetNames))
                     {
                         WriteLinePrettyFromResource(indentLevel, "ProjectStartedPrefixForNestedProjectWithDefaultTargets", previous, current);
                     }
@@ -971,7 +971,7 @@ internal int Count
             /// </summary>
             internal bool IsEmpty()
             {
-                return (_frames.Count == 0);
+                return _frames.Count == 0;
             }
         }
         #endregion
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 43a84039b2e..2f136f3ebf0 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+Ôªø<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -157,6 +157,8 @@
     <Compile Include="BackEnd\Components\Caching\ConfigCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\Caching\ResultsCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
+    <Compile Include="BackEnd\Node\RarNode.cs" />
+    <Compile Include="FileSystem\MSBuildFileSystemBase.cs" />
     <Compile Include="Utilities\NuGetFrameworkWrapper.cs" />
     <Compile Include="ObjectModelRemoting\ConstructionObjectLinks\ProjectUsingTaskParameterElementLink.cs" />
     <Compile Include="ObjectModelRemoting\ExternalProjectsProvider.cs" />
@@ -263,6 +265,7 @@
     <Compile Include="Evaluation\LazyItemEvaluator.ItemFactoryWrapper.cs" />
     <Compile Include="Evaluation\LazyItemEvaluator.RemoveOperation.cs" />
     <Compile Include="Evaluation\MetadataReference.cs" />
+    <Compile Include="FileSystem\MSBuildFileSystemAdapter.cs" />
     <Compile Include="Graph\ProjectGraphEntryPoint.cs" />
     <Compile Include="Graph\ProjectGraph.cs" />
     <Compile Include="Graph\ProjectGraphNode.cs" />
diff --git a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectMetadataLink.cs b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectMetadataLink.cs
index f5aca34ec3b..0de0274f582 100644
--- a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectMetadataLink.cs
+++ b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectMetadataLink.cs
@@ -6,7 +6,6 @@
 
 namespace Microsoft.Build.ObjectModelRemoting
 {
-
     /// <summary>
     /// External projects support.
     /// Allow for creating a local representation to external object of type <see cref="ProjectMetadata"/>
@@ -46,6 +45,7 @@ public static object GetParent(ProjectMetadata metadata)
 
         /// <summary>
         /// Helper utility for External projects provider implementation to get access of the EvaluatedValueEscaped
+        /// </summary>
         public static string GetEvaluatedValueEscaped(ProjectMetadata metadata)
         {
             return metadata.EvaluatedValueEscaped;
diff --git a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs
index 377daf47856..ee5c1263f3a 100644
--- a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs
+++ b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs
@@ -65,10 +65,10 @@ public abstract class ProjectPropertyLink
 
         /// <summary>
         /// Helper utility for External projects provider implementation to get access of the EvaluatedValueEscaped
+        /// </summary>
         public static string GetEvaluatedValueEscaped(ProjectProperty property)
         {
             return property.EvaluatedValueEscapedIntenral;
         }
     }
-
 }
diff --git a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
index d639aa819cd..98ce259b750 100644
--- a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
+++ b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
@@ -8,7 +8,6 @@
 
 namespace Microsoft.Build.ObjectModelRemoting
 {
-
     /// <summary>
     /// implemented by MSBuild objects that support remote linking;
     /// </summary>
@@ -76,15 +75,15 @@ public static IReadOnlyCollection<Project> GetLocalProjects(ProjectCollection co
 
         public ProjectItem Create(ProjectItemLink link, Project project = null, ProjectItemElement xml = null)
         {
-            project = project ?? link.Project;
-            xml = xml ?? link.Xml;
+            project ??= link.Project;
+            xml ??= link.Xml;
 
             return new LinkedProjectItem(xml, project, link);
         }
 
         public ProjectItemDefinition Create(ProjectItemDefinitionLink link, Project project = null)
         {
-            project = project ?? link.Project;
+            project ??= link.Project;
 
             return new LinkedProjectItemDefinition(link, project, link.ItemType);
         }
@@ -101,14 +100,14 @@ public Project Create(ProjectLink link)
 
         public ProjectMetadata Create(ProjectMetadataLink link, object parent = null)
         {
-            parent = parent ?? link.Parent;
+            parent ??= link.Parent;
 
             return new LinkedProjectMetadata(parent, link);
         }
 
         public ProjectProperty Create(ProjectPropertyLink link, Project project = null )
         {
-            project = project ?? link.Project;
+            project ??= link.Project;
 
             return new LinkedProjectProperty(project, link);
         }
@@ -270,7 +269,6 @@ internal LinkedProjectMetadata(object parent, ProjectMetadataLink link)
 
             internal override ProjectMetadataLink Link { get; }
             object ILinkableObject.Link => Link;
-
         }
 
         private class LinkedProjectProperty : ProjectProperty, ILinkableObject
@@ -315,5 +313,4 @@ public override string UnevaluatedValue
         #endregion
     }
 
-
 }
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 113593b7d91..55a89a1db36 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1831,4 +1831,10 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="StaticGraphConstructionMetrics" xml:space="preserve">
     <value>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</value>
   </data>
-</root>
\ No newline at end of file
+  <data name="IsolatedContextDoesNotSupportFileSystem" xml:space="preserve">
+    <value>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</value>
+  </data>
+  <data name="RarControllerReflectionError" xml:space="preserve">
+    <value>Couldn't create an instance of IRarController for '{0}' type</value>
+  </data>
+</root>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index c8ea9ddce01..5991f465065 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -100,6 +100,11 @@
         <target state="translated">≈òetƒõzec verze nem√° spr√°vn√Ω form√°t.</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="new">"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">Podrobnost protokolov√°n√≠ je nastaven√° na: {0}.</target>
@@ -124,7 +129,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">Po≈æadovan√© sestaven√≠ NuGet se nena≈°lo. Oƒçek√°van√° cesta: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +142,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">P≈ôi odebr√°n√≠ pomoc√≠ MatchOnMetadata je mo≈æn√© odkazovat jen na jeden typ polo≈æky.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata se vztahuje pouze na operace odebr√°n√≠ u polo≈æek.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataOptions je platn√© jen p≈ôi odeb√≠r√°n√≠ polo≈æek pomoc√≠ MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">Kl√≠ƒçov√© slovo MyClass nejde pou≈æ√≠t vnƒõ polo≈æky &lt;Target&gt;.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -173,6 +178,11 @@
         <target state="translated">Poƒç√°teƒçn√≠ hodnota vlastnosti: $({0})={1} Zdroj: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="RarControllerReflectionError">
+        <source>Couldn't create an instance of IRarController for '{0}' type</source>
+        <target state="new">Couldn't create an instance of IRarController for '{0}' type</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: Projekt {0} p≈ôeskoƒçil omezen√≠ izolace grafu v odkazovan√©m projektu {1}.</target>
@@ -182,14 +192,14 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: Statick√Ω graf p≈ôij√≠m√° pouze ≈ôe≈°en√≠ jako jedin√Ω vstupn√≠ bod. Zji≈°tƒõno v√≠ce vstupn√≠ch bod≈Ø: {0}</target>
+        <target state="translated">MSB4261: Bylo zji≈°tƒõno v√≠ce vstupn√≠ch bod≈Ø s ≈ôe≈°en√≠mi: {0}. Pokud se z ≈ôe≈°en√≠ naƒçte statick√Ω graf, mus√≠ b√Ωt toto ≈ôe≈°en√≠ jedin√Ωm vstupn√≠m bodem.</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="new">"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</target>
+        <target state="translated">Statick√Ω graf se naƒçetl za {0} s: poƒçet uzl≈Ø: {1}, poƒçet hraniƒçn√≠ch uzl≈Ø: {2}</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 5717c996477..662d0f59824 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -100,6 +100,11 @@
         <target state="translated">Die Versionszeichenfolge liegt nicht im richtigen Format vor.</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="new">"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">Die Ausf√ºhrlichkeit der Protokollierung ist auf "{0}" festgelegt.</target>
@@ -124,7 +129,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">Eine erforderliche NuGet-Assembly wurde nicht gefunden. Erwarteter Pfad: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +142,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">Beim Entfernen mit MatchOnMetadata kann nur ein Elementtyp referenziert werden.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata gilt nur f√ºr Vorg√§nge zum Entfernen von Elementen.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataOptions ist nur g√ºltig, wenn Elemente mit MatchOnMetadata entfernt werden.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">MatchOnMetadata kann nicht au√üerhalb eines &lt;Ziels&gt; verwendet werden.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -173,6 +178,11 @@
         <target state="translated">Anfangswert der Eigenschaft: $({0})="{1}", Quelle: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="RarControllerReflectionError">
+        <source>Couldn't create an instance of IRarController for '{0}' type</source>
+        <target state="new">Couldn't create an instance of IRarController for '{0}' type</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: Das Projekt "{0}" hat Graphisolationseinschr√§nkungen f√ºr das referenzierte Projekt "{1}" √ºbersprungen.</target>
@@ -182,14 +192,14 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: Ein statischer Graph akzeptiert nur eine Projektmappe als einzigen Einstiegspunkt. Es wurden mehrere Einstiegspunkte erkannt: {0}</target>
+        <target state="translated">MSB4261: Es wurden mehrere Einstiegspunkte mit Projektmappen gefunden: {0}. Wenn ein statischer Graph aus einer Projektmappe geladen wird, muss diese Projektmappe der einzige Einstiegspunkt sein.</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="new">"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</target>
+        <target state="translated">"Statisches Diagramm in {0} Sekunden geladen: {1} Knoten, {2} Edges"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
diff --git a/src/Build/Resources/xlf/Strings.en.xlf b/src/Build/Resources/xlf/Strings.en.xlf
index aa60e39687a..9558c861f7b 100644
--- a/src/Build/Resources/xlf/Strings.en.xlf
+++ b/src/Build/Resources/xlf/Strings.en.xlf
@@ -100,6 +100,11 @@
         <target state="new">Version string was not in a correct format.</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="new">"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="new">Logging verbosity is set to: {0}.</target>
@@ -173,6 +178,11 @@
         <target state="new">Property initial value: $({0})="{1}" Source: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="RarControllerReflectionError">
+        <source>Couldn't create an instance of IRarController for '{0}' type</source>
+        <target state="new">Couldn't create an instance of IRarController for '{0}' type</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="new">MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index e12c4d43a2a..09e2180e0a3 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -100,6 +100,11 @@
         <target state="translated">La cadena de versi√≥n no ten√≠a el formato correcto.</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="new">"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">El nivel de detalle de registro est√° establecido en {0}.</target>
@@ -124,7 +129,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">No se encontr√≥ un ensamblado de NuGet necesario. Ruta de acceso esperada: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +142,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">Solo se puede hacer referencia a un tipo de elemento al quitarlo con MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata solo se aplica a operaciones de eliminaci√≥n en elementos.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataOptions solo es v√°lido cuando se quitan elementos mediante MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">MatchOnMetadata no se puede usar fuera de un elemento &lt;Target&gt;.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -173,6 +178,11 @@
         <target state="translated">Valor inicial de la propiedad: $({0})="{1}" Origen: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="RarControllerReflectionError">
+        <source>Couldn't create an instance of IRarController for '{0}' type</source>
+        <target state="new">Couldn't create an instance of IRarController for '{0}' type</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: El proyecto "{0}" ha omitido las restricciones de aislamiento de gr√°ficos en el proyecto "{1}" al que se hace referencia.</target>
@@ -182,14 +192,14 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: Un grafo est√°tico solo acepta una soluci√≥n como √∫nico punto de entrada. Se han detectado varios puntos de entrada: {0}</target>
+        <target state="translated">MSB4261: Se detectaron varios puntos de entrada con soluciones: {0}. Si el gr√°fico est√°tico se carga a partir de una soluci√≥n, esa soluci√≥n debe ser el √∫nico punto de entrada.</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="new">"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</target>
+        <target state="translated">"Grafo est√°tico cargado en {0}¬†segundos: {1}¬†nodos, {2}¬†bordes"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 78fd7a7f1d2..f578b5ce53b 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -100,6 +100,11 @@
         <target state="translated">La cha√Æne de version n'√©tait pas au format appropri√©.</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="new">"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">La verbosit√© de la journalisation a la valeur {0}.</target>
@@ -124,7 +129,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">Un assembly NuGet obligatoire est introuvable. Chemin attendu¬†: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +142,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">Un seul type d'√©l√©ment peut √™tre r√©f√©renc√© pour la suppression √† l'aide de MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata s'applique uniquement aux op√©rations de suppression sur des √©l√©ments.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataOptions est valide uniquement pour la suppression d'√©l√©ments √† l'aide de MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">Impossible d'utiliser MatchOnMetadata en dehors de &lt;Target&gt;.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -173,6 +178,11 @@
         <target state="translated">Valeur initiale de la propri√©t√©¬†: $({0})="{1}" Source¬†: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="RarControllerReflectionError">
+        <source>Couldn't create an instance of IRarController for '{0}' type</source>
+        <target state="new">Couldn't create an instance of IRarController for '{0}' type</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: le projet "{0}" a ignor√© les contraintes d'isolement de graphe dans le projet r√©f√©renc√© "{1}"</target>
@@ -182,14 +192,14 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: le graphe statique n'accepte qu'une solution comme seul point d'entr√©e. Plusieurs points d'entr√©e ont √©t√© d√©tect√©s¬†: {0}</target>
+        <target state="translated">MSB4261: d√©tection de plusieurs points d'entr√©e avec des solutions¬†: {0}. Si un graphe statique est charg√© √† partir d'une solution, cette solution doit √™tre le seul point d'entr√©e.</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="new">"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</target>
+        <target state="translated">"Graphe statique charg√© en {0} secondes¬†: {1} n≈ìuds, {2} ar√™tes"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index e66777bbd6b..e583fca423e 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -100,6 +100,11 @@
         <target state="translated">Il formato della stringa di versione non √® corretto.</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="new">"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">Il livello di dettaglio della registrazione √® impostato su: {0}.</target>
@@ -124,7 +129,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">Un assembly NuGet obbligatorio non √® stato trovato. Percorso previsto: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +142,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">Durante la rimozione con MatchOnMetadata √® possibile fare riferimento a un solo tipo di elemento.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata si applica solo a operazioni Remove su elementi.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataOptions √® valido solo quando si rimuovono elementi con MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">MatchOnMetadata non pu√≤ essere usato all'esterno di un elemento &lt;Target&gt;.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -173,6 +178,11 @@
         <target state="translated">Valore iniziale della propriet√†: $({0})="{1}". Origine: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="RarControllerReflectionError">
+        <source>Couldn't create an instance of IRarController for '{0}' type</source>
+        <target state="new">Couldn't create an instance of IRarController for '{0}' type</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: il progetto "{0}" ha ignorato i vincoli di isolamento del grafico nel progetto di riferimento "{1}"</target>
@@ -182,14 +192,14 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: l'unico punto di ingresso accettato dal grafo statico √® una soluzione. Sono stati rilevati pi√π punti di ingresso: {0}</target>
+        <target state="translated">MSB4261: Sono stati rilevati pi√π punti di ingresso con le soluzioni: {0}. Se il grafo statico viene caricato da una soluzione, tale soluzione deve essere l'unico punto di ingresso.</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="new">"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</target>
+        <target state="translated">"Il grafo statico √® stato caricato in {0} secondi: {1} nodi, {2} vertici"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index d8893b43ee5..f25b31b5d56 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -100,6 +100,11 @@
         <target state="translated">„Éê„Éº„Ç∏„Éß„É≥ÊñáÂ≠óÂàó„ÅÆÂΩ¢Âºè„ÅåÊ≠£„Åó„Åè„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="new">"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">„É≠„Ç∞„ÅÆË©≥Á¥∞Â∫¶„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åô: {0}„ÄÇ</target>
@@ -124,7 +129,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">ÂøÖË¶Å„Å™ NuGet „Ç¢„Çª„É≥„Éñ„É™„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇÊÉ≥ÂÆö„Åï„Çå„Çã„Éë„Çπ: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +142,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadata „ÅßÂâäÈô§„Åô„ÇãÂ†¥Âêà„ÄÅÂèÇÁÖß„Åß„Åç„ÇãÈ†ÖÁõÆ„ÅÆÁ®ÆÈ°û„ÅØ 1 „Å§„Å†„Åë„Åß„Åô„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata „ÅØ„ÄÅÈ†ÖÁõÆ„Åß„ÅÆÂâäÈô§Êìç‰Ωú„Å´„ÅÆ„ÅøÈÅ©Áî®„Åï„Çå„Åæ„Åô„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataOptions „ÅØ„ÄÅMatchOnMetadata „Çí‰ΩøÁî®„Åó„Å¶È†ÖÁõÆ„ÇíÂâäÈô§„Åô„ÇãÂ†¥Âêà„Å´„ÅÆ„ÅøÊúâÂäπ„Åß„Åô„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">MatchOnMetadata „Çí &lt;Target&gt; „ÅÆÂ§ñ„Åß‰ΩøÁî®„Åô„Çã„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -173,6 +178,11 @@
         <target state="translated">„Éó„É≠„Éë„ÉÜ„Ç£„ÅÆÂàùÊúüÂÄ§: $({0})="{1}" „ÇΩ„Éº„Çπ: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="RarControllerReflectionError">
+        <source>Couldn't create an instance of IRarController for '{0}' type</source>
+        <target state="new">Couldn't create an instance of IRarController for '{0}' type</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: „Éó„É≠„Ç∏„Çß„ÇØ„Éà "{0}" „ÅØ„ÄÅÂèÇÁÖßÂÖà„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà "{1}" „Åß„ÄÅ„Ç∞„É©„Éï„ÅÆÂàÜÈõ¢Âà∂Á¥Ñ„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åó„Åü</target>
@@ -182,14 +192,14 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: ÈùôÁöÑ„Ç∞„É©„Éï„Åß„ÅØ„ÄÅ„ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥„ÇíÂîØ‰∏Ä„ÅÆ„Ç®„É≥„Éà„É™ „Éù„Ç§„É≥„Éà„Å®„Åó„Å¶Âèó„ÅëÂÖ•„Çå„Çã„ÅÆ„Åø„Åß„Åô„ÄÇË§áÊï∞„ÅÆ„Ç®„É≥„Éà„É™ „Éù„Ç§„É≥„Éà„ÅåÊ§úÂá∫„Åï„Çå„Åæ„Åó„Åü: {0}</target>
+        <target state="translated">MSB4261: „ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥„ÅåÊ§úÂá∫„Åï„Çå„Åü„Ç®„É≥„Éà„É™ „Éù„Ç§„É≥„Éà„ÅåË§áÊï∞„ÅÇ„Çä„Åæ„Åô: {0}„ÄÇÈùôÁöÑ„Ç∞„É©„Éï„Åå„ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥„Åã„ÇâË™≠„ÅøËæº„Åæ„Çå„ÇãÂ†¥Âêà„ÄÅ„Åù„ÅÆ„ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥„ÅåÂîØ‰∏Ä„ÅÆ„Ç®„É≥„Éà„É™ „Éù„Ç§„É≥„Éà„Åß„ÅÇ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="new">"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</target>
+        <target state="translated">"{0} Áßí„ÅßË™≠„ÅøËæº„Åæ„Çå„ÅüÈùôÁöÑ„Ç∞„É©„Éï: {1} „Éé„Éº„Éâ„ÄÅ{2} „Ç®„ÉÉ„Ç∏"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 0f1469a9389..79ffea47246 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -100,6 +100,11 @@
         <target state="translated">Î≤ÑÏ†Ñ Î¨∏ÏûêÏó¥Ïùò ÌòïÏãùÏù¥ ÏûòÎ™ªÎêòÏóàÏäµÎãàÎã§.</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="new">"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">Î°úÍπÖÏùò ÏÑ∏Î∂Ä Ï†ïÎ≥¥ ÌëúÏãúÍ∞Ä {0}(Ïúº)Î°ú ÏÑ§Ï†ïÎêòÏóàÏäµÎãàÎã§.</target>
@@ -124,7 +129,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">ÌïÑÏöîÌïú NuGet Ïñ¥ÏÖàÎ∏îÎ¶¨Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. ÏòàÏÉÅ Í≤ΩÎ°ú: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +142,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataÎ•º ÏÇ¨Ïö©ÌïòÏó¨ Ï†úÍ±∞ÌïòÎäî Í≤ΩÏö∞ Ìï≠Î™© Ï¢ÖÎ•òÎ•º ÌïòÎÇòÎßå Ï∞∏Ï°∞Ìï† Ïàò ÏûàÏäµÎãàÎã§.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadataÎäî Ìï≠Î™©Ïóê ÎåÄÌïú Ï†úÍ±∞ ÏûëÏóÖÏóêÎßå Ï†ÅÏö©Îê©ÎãàÎã§.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataOptionsÎäî MatchOnMetadataÎ•º ÏÇ¨Ïö©ÌïòÏó¨ Ìï≠Î™©ÏùÑ Ï†úÍ±∞ÌïòÎäî Í≤ΩÏö∞ÏóêÎßå Ïú†Ìö®Ìï©ÎãàÎã§.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">MatchOnMetadataÎäî &lt;Target&gt; Ïô∏Î∂ÄÏóê ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -173,6 +178,11 @@
         <target state="translated">ÏÜçÏÑ± Ï¥àÍ∏∞ Í∞í: $({0})="{1}" ÏÜåÏä§: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="RarControllerReflectionError">
+        <source>Couldn't create an instance of IRarController for '{0}' type</source>
+        <target state="new">Couldn't create an instance of IRarController for '{0}' type</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: ÌîÑÎ°úÏ†ùÌä∏ "{0}"ÏóêÏÑú Ï∞∏Ï°∞Îêú ÌîÑÎ°úÏ†ùÌä∏ "{1}"Ïùò Í∑∏ÎûòÌîÑ Í≤©Î¶¨ Ï†úÏïΩ Ï°∞Í±¥ÏùÑ Í±¥ÎÑàÎõ∞ÏóàÏäµÎãàÎã§.</target>
@@ -182,14 +192,14 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: Ï†ïÏ†Å Í∑∏ÎûòÌîÑÎäî Ïú†ÏùºÌïú ÏßÑÏûÖÏ†êÏúºÎ°ú ÏÜîÎ£®ÏÖòÎßå ÌóàÏö©Ìï©ÎãàÎã§. Ïó¨Îü¨ ÏßÑÏûÖÏ†êÏù¥ Î∞úÍ≤¨ÎêòÏóàÏäµÎãàÎã§. {0}</target>
+        <target state="translated">MSB4261: ÏÜîÎ£®ÏÖòÏóêÏÑú Ïó¨Îü¨ ÏßÑÏûÖÏ†êÏù¥ Í≤ÄÏÉâÎêòÏóàÏäµÎãàÎã§. {0}. ÏÜîÎ£®ÏÖòÏóêÏÑú Ï†ïÏ†Å Í∑∏ÎûòÌîÑÍ∞Ä Î°úÎìúÎêòÎäî Í≤ΩÏö∞ Ìï¥Îãπ ÏÜîÎ£®ÏÖòÏù¥ Ïú†ÏùºÌïú ÏßÑÏûÖÏ†êÏù¥Ïñ¥Ïïº Ìï©ÎãàÎã§.</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="new">"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</target>
+        <target state="translated">"Ï†ïÏ†Å Í∑∏ÎûòÌîÑÍ∞Ä {0}Ï¥à ÏïàÏóê Î°úÎìúÎê®: {1}Í∞ú ÎÖ∏Îìú, {2}Í∞ú ÏóêÏßÄ"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 4e67dadb7c3..107873c75b5 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -100,6 +100,11 @@
         <target state="translated">Nieprawid≈Çowy format ciƒÖgu wersji.</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="new">"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">Szczeg√≥≈Çowo≈õƒá rejestrowania zosta≈Ça ustawiona na: {0}.</target>
@@ -124,7 +129,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">Nie znaleziono wymaganego zestawu NuGet. Oczekiwano ≈õcie≈ºki {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +142,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">Tylko jeden typ elementu mo≈ºe byƒá przywo≈Çywany podczas usuwania przy u≈ºyciu elementu MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">Element MatchOnMetadata ma zastosowanie tylko do operacji usuwania element√≥w.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">Element MatchOnMetadataOptions jest prawid≈Çowy tylko podczas usuwania element√≥w przy u≈ºyciu elementu MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">Nie mo≈ºna u≈ºyƒá elementu MatchOnMetadata poza elementem &lt;Target&gt;.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -173,6 +178,11 @@
         <target state="translated">Warto≈õƒá poczƒÖtkowa w≈Ça≈õciwo≈õci: $({0})=‚Äû{1}‚Äù ≈πr√≥d≈Ço: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="RarControllerReflectionError">
+        <source>Couldn't create an instance of IRarController for '{0}' type</source>
+        <target state="new">Couldn't create an instance of IRarController for '{0}' type</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: W przypadku projektu ‚Äû{0}‚Äù pominiƒôto ograniczenia izolacji grafu dla przywo≈Çywanego projektu ‚Äû{1}‚Äù</target>
@@ -182,14 +192,14 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: wykres statyczny akceptuje tylko rozwiƒÖzanie jako jedyny punkt wej≈õcia. Wykryto wiele punkt√≥w wej≈õcia: {0}</target>
+        <target state="translated">MSB4261: Wykryto wiele punkt√≥w wej≈õcia z rozwiƒÖzaniami: {0}. Je≈õli graf statyczny jest ≈Çadowany z rozwiƒÖzania, musi ono byƒá jedynym punktem wej≈õcia.</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="new">"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</target>
+        <target state="translated">‚ÄûWykres statyczny za≈Çadowany w {0} s, wƒôz≈Çy: {1}, krawƒôdzie: {2}‚Äù</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 73c636ba670..dcd153df703 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -100,6 +100,11 @@
         <target state="translated">A cadeia de caracteres de vers√£o n√£o estava em um formato correto.</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="new">"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">O detalhamento do log est√° definido como: {0}.</target>
@@ -124,7 +129,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">Um assembly NuGet necess√°rio n√£o foi encontrado. Caminho Esperado: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +142,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">Somente um tipo de item pode ser referenciado na remo√ß√£o com MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata s√≥ se aplica a opera√ß√µes de Remo√ß√£o em itens.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataOptions √© v√°lido somente ao remover itens usando MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">MatchOnMetadata n√£o pode ser usado fora de um &lt;Target&gt;.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -173,6 +178,11 @@
         <target state="translated">Valor inicial da propriedade: $({0})="{1}" Origem: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="RarControllerReflectionError">
+        <source>Couldn't create an instance of IRarController for '{0}' type</source>
+        <target state="new">Couldn't create an instance of IRarController for '{0}' type</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: o projeto "{0}" ignorou as restri√ß√µes de isolamento do gr√°fico no projeto referenciado "{1}"</target>
@@ -182,14 +192,14 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: o grafo est√°tico aceita apenas uma solu√ß√£o como o √∫nico ponto de entrada. V√°rios pontos de entrada detectados: {0}</target>
+        <target state="translated">MSB4261: V√°rios pontos de entrada com solu√ß√µes detectados: {0}. Se o grafo est√°tico for carregado de uma solu√ß√£o, ela precisar√° ser o √∫nico ponto de entrada.</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="new">"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</target>
+        <target state="translated">"Grafo est√°tico carregado em {0} segundos: {1} n√≥s, {2} bordas"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -216,7 +226,7 @@
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
-        <target state="translated">MSB4181: a tarefa "{0}" retornou false, mas n√£o registrou um erro.</target>
+        <target state="translated">MSB4181: A tarefa "{0}" retornou false, mas n√£o registrou um erro.</target>
         <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index f717f29d64c..eeb54ff9174 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -100,6 +100,11 @@
         <target state="translated">–°—Ç—Ä–æ–∫–∞ –≤–µ—Ä—Å–∏–∏ –∏–º–µ–ª–∞ –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç.</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="new">"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">–£—Ä–æ–≤–µ–Ω—å –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏–∏ –∂—É—Ä–Ω–∞–ª–∞: {0}.</target>
@@ -124,7 +129,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">–ù–µ –Ω–∞–π–¥–µ–Ω–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞—è —Å–±–æ—Ä–∫–∞ NuGet. –û–∂–∏–¥–∞–µ–º—ã–π –ø—É—Ç—å: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +142,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">–ü—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å –ø–æ–º–æ—â—å—é MatchOnMetadata –º–æ–∂–Ω–æ —Å—Å—ã–ª–∞—Ç—å—Å—è —Ç–æ–ª—å–∫–æ –Ω–∞ –æ–¥–∏–Ω —Ç–∏–ø —ç–ª–µ–º–µ–Ω—Ç–∞.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –∫ –æ–ø–µ—Ä–∞—Ü–∏—è–º —É–¥–∞–ª–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataOptions –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å –ø–æ–º–æ—â—å—é MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">MatchOnMetadata –Ω–µ –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –≤–Ω–µ &lt;Target&gt;.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -173,6 +178,11 @@
         <target state="translated">–ù–∞—á–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Å–≤–æ–π—Å—Ç–≤–∞: $({0})="{1}" –ò—Å—Ç–æ—á–Ω–∏–∫: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="RarControllerReflectionError">
+        <source>Couldn't create an instance of IRarController for '{0}' type</source>
+        <target state="new">Couldn't create an instance of IRarController for '{0}' type</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: –ø—Ä–æ–µ–∫—Ç "{0}" –ø—Ä–æ–ø—É—Å—Ç–∏–ª –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –∏–∑–æ–ª—è—Ü–∏–∏ –≥—Ä–∞—Ñ–∞ –≤ –ø—Ä–æ–µ–∫—Ç–µ "{1}", –Ω–∞ –∫–æ—Ç–æ—Ä—ã–π —É–∫–∞–∑—ã–≤–∞–µ—Ç —Å—Å—ã–ª–∫–∞.</target>
@@ -182,14 +192,14 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π –≥—Ä–∞—Ñ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Ä–µ—à–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ –≤ –∫–∞—á–µ—Å—Ç–≤–µ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–π —Ç–æ—á–∫–∏ –≤—Ö–æ–¥–∞. –û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ç–æ—á–µ–∫ –≤—Ö–æ–¥–∞: {0}</target>
+        <target state="translated">MSB4261: –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ç–æ—á–µ–∫ –≤—Ö–æ–¥–∞ —Å —Ä–µ—à–µ–Ω–∏—è–º–∏: {0}. –ï—Å–ª–∏ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π –≥—Ä–∞—Ñ –∑–∞–≥—Ä—É–∂–µ–Ω –∏–∑ —Ä–µ—à–µ–Ω–∏—è, —Ç–æ —ç—Ç–æ —Ä–µ—à–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–π —Ç–æ—á–∫–æ–π –≤—Ö–æ–¥–∞.</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="new">"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</target>
+        <target state="translated">"–°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π –≥—Ä–∞—Ñ –∑–∞–≥—Ä—É–∂–µ–Ω –∑–∞ {0}¬†—Å: —É–∑–ª–æ–≤¬†‚Äî {1}, —Ä–µ–±–µ—Ä¬†‚Äî {2}."</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 533755ed48a..9854cc7ddfa 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -100,6 +100,11 @@
         <target state="translated">S√ºr√ºm dizesi doƒüru bi√ßimde deƒüildi.</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="new">"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">G√ºnl√ºk kaydƒ± ayrƒ±ntƒ± d√ºzeyi {0} olarak ayarlandƒ±.</target>
@@ -124,7 +129,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">Gereken NuGet derlemesi bulunamadƒ±. Beklenen Yol: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +142,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadata ile kaldƒ±rƒ±rken yalnƒ±zca bir √∂ƒüe t√ºr√ºne ba≈üvurulabilir.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata yalnƒ±zca √∂ƒüelerdeki Kaldƒ±rma i≈ülemleri i√ßin ge√ßerlidir.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataOptions yalnƒ±zca MatchOnMetadata kullanƒ±larak √∂ƒüeler kaldƒ±rƒ±lƒ±rken ge√ßerlidir.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">MatchOnMetadata bir &lt;Target&gt; dƒ±≈üƒ±nda kullanƒ±lamaz.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -173,6 +178,11 @@
         <target state="translated">√ñzellik ba≈ülangƒ±√ß deƒüeri: $({0})="{1}" Kaynak: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="RarControllerReflectionError">
+        <source>Couldn't create an instance of IRarController for '{0}' type</source>
+        <target state="new">Couldn't create an instance of IRarController for '{0}' type</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: "{0}" projesi, ba≈üvurulan "{1}" projesindeki graf yalƒ±tƒ±mƒ± kƒ±sƒ±tlamalarƒ±nƒ± atladƒ±</target>
@@ -182,14 +192,14 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: Statik graf tek giri≈ü noktasƒ± olarak yalnƒ±zca bir √ß√∂z√ºm√º kabul eder. Birden √ßok giri≈ü noktasƒ± algƒ±landƒ±: {0}</target>
+        <target state="translated">MSB4261: √á√∂z√ºmlerde birden fazla giri≈ü noktasƒ± algƒ±landƒ±: {0}. Statik graf bir √ß√∂z√ºmden y√ºkleniyorsa bu √ß√∂z√ºm tek giri≈ü noktasƒ± olmalƒ±dƒ±r.</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="new">"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</target>
+        <target state="translated">"Statik graf {0} saniye i√ßinde y√ºklendi: {1} d√ºƒü√ºm, {2} u√ß"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 4efba3ee08a..e2ca02b06c7 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -100,6 +100,11 @@
         <target state="translated">ÁâàÊú¨Â≠óÁ¨¶‰∏≤ÁöÑÊ†ºÂºè‰∏çÊ≠£Á°Æ„ÄÇ</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="new">"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">Êó•ÂøóËÆ∞ÂΩïËØ¶ÁªÜÁ®ãÂ∫¶ËÆæÁΩÆ‰∏∫: {0}„ÄÇ</target>
@@ -124,7 +129,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">Êú™ÊâæÂà∞ÊâÄÈúÄÁöÑ NuGet Á®ãÂ∫èÈõÜ„ÄÇÊâÄÈúÄË∑ØÂæÑ: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +142,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">‰ΩøÁî® MatchOnMetadata Âà†Èô§Êó∂ÔºåÂè™ËÉΩÂºïÁî®‰∏Ä‰∏™È°πÁ±ªÂûã„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata ‰ªÖÈÄÇÁî®‰∫éÂØπÈ°πÊâßË°åÂà†Èô§Êìç‰Ωú„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataOptions ‰ªÖÂú®‰ΩøÁî® MatchOnMetadata Âà†Èô§È°πÊó∂ÊâçÊúâÊïà„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">MatchOnMetadata ‰∏çËÉΩÂú® &lt;Target&gt; Â§ñÈÉ®‰ΩøÁî®„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -173,6 +178,11 @@
         <target state="translated">Â±ûÊÄßÂàùÂßãÂÄº: $({0})=‚Äú{1}‚ÄùÔºåÊ∫ê: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="RarControllerReflectionError">
+        <source>Couldn't create an instance of IRarController for '{0}' type</source>
+        <target state="new">Couldn't create an instance of IRarController for '{0}' type</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: È°πÁõÆ‚Äú{0}‚ÄùÂ∑≤Ë∑≥ËøáÊâÄÂºïÁî®ÁöÑÈ°πÁõÆ‚Äú{1}‚Äù‰∏äÁöÑÂõæÂΩ¢ÈöîÁ¶ªÁ∫¶Êùü</target>
@@ -182,14 +192,14 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: ÈùôÊÄÅÂõæ‰ªÖÊé•ÂèóËß£ÂÜ≥ÊñπÊ°à‰Ωú‰∏∫ÂîØ‰∏ÄÂÖ•Âè£ÁÇπ„ÄÇÊ£ÄÊµãÂà∞Â§ö‰∏™ÂÖ•Âè£ÁÇπ: {0}</target>
+        <target state="translated">MSB4261: Ê£ÄÊµãÂà∞Â§ö‰∏™ÂÖ∑ÊúâËß£ÂÜ≥ÊñπÊ°àÁöÑÂÖ•Âè£ÁÇπ: {0}„ÄÇÂ¶ÇÊûúÈùôÊÄÅÂõæË°®ÊòØ‰ªéËß£ÂÜ≥ÊñπÊ°à‰∏≠Âä†ËΩΩÁöÑÔºåÂàôËØ•Ëß£ÂÜ≥ÊñπÊ°àÂøÖÈ°ªÊòØÂîØ‰∏ÄÁöÑÂÖ•Âè£ÁÇπ„ÄÇ</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="new">"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</target>
+        <target state="translated">‚ÄúÈùôÊÄÅÂõæÂΩ¢Â∑≤Âú® {0} ÁßíÂÜÖÂä†ËΩΩ: {1} ‰∏™ËäÇÁÇπ„ÄÅ{2} ‰∏™Ëæπ‚Äù</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 0aedbdbcd4b..15c7df1bd3c 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -100,6 +100,11 @@
         <target state="translated">ÁâàÊú¨Â≠ó‰∏≤Ê†ºÂºè‰∏çÊ≠£Á¢∫„ÄÇ</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="new">"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">Ë®òÈåÑË©≥Á¥∞Á®ãÂ∫¶Ë®≠ÂÆöÁÇ∫: {0}„ÄÇ</target>
@@ -124,7 +129,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">Êâæ‰∏çÂà∞ÂøÖË¶ÅÁöÑ NuGet ÂÖÉ‰ª∂„ÄÇÈ†êÊúüÁöÑË∑ØÂæë: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +142,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">‰ΩøÁî® MatchOnMetadata ÁßªÈô§ÊôÇÔºåÂè™ËÉΩÂèÉËÄÉ‰∏ÄÂÄãÈ†ÖÁõÆÈ°ûÂûã„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata Âè™ÂèØÂ∞çÈ†ÖÁõÆÂü∑Ë°åÁßªÈô§‰ΩúÊ•≠„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">ÂÉÖÁï∂‰ΩøÁî® MatchOnMetadata ÁßªÈô§È†ÖÁõÆÊôÇÔºåMatchOnMetadataOptions ÊâçÊúâÊïà„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">MatchOnMetadata ÁÑ°Ê≥ïÂú® &lt;ÁõÆÊ®ô&gt; ‰πãÂ§ñ‰ΩøÁî®„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -173,6 +178,11 @@
         <target state="translated">Â±¨ÊÄßÂàùÂßãÂÄº: $({0})="{1}" ‰æÜÊ∫ê: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="RarControllerReflectionError">
+        <source>Couldn't create an instance of IRarController for '{0}' type</source>
+        <target state="new">Couldn't create an instance of IRarController for '{0}' type</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: Â∞àÊ°à "{0}" Â∑≤Ë∑≥ÈÅéÂèÉËÄÉÂ∞àÊ°à "{1}" ‰∏äÁöÑÂúñÂΩ¢ÈöîÈõ¢Ê¢ù‰ª∂Á¥ÑÊùü</target>
@@ -182,14 +192,14 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: ÈùúÊÖãÂúñË°®Âè™Êé•ÂèóËß£Ê±∫ÊñπÊ°à‰ΩúÁÇ∫ÂîØ‰∏ÄÁöÑÈÄ≤ÂÖ•Èªû„ÄÇÂÅµÊ∏¨Âà∞Â§öÂÄãÈÄ≤ÂÖ•Èªû: {0}</target>
+        <target state="translated">MSB4261: ÂÅµÊ∏¨Âà∞Ëß£Ê±∫ÊñπÊ°àÊúâÂ§öÂÄãÈÄ≤ÂÖ•Èªû: {0}„ÄÇËã•ÊòØÂæûËß£Ê±∫ÊñπÊ°àËºâÂÖ•ÈùúÊÖãÂúñË°®ÔºåÂâáË©≤Ëß£Ê±∫ÊñπÊ°àÂè™ÂèØÊúâ‰∏ÄÂÄãÈÄ≤ÂÖ•Èªû„ÄÇ</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="new">"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</target>
+        <target state="translated">"Âú® {0} ÁßíÂÖßËºâÂÖ•ÁöÑÈùúÊÖãÂúñÂΩ¢: {1} ÂÄãÁØÄÈªû„ÄÅ{2} ÂÄãÈÇäÁ∑£"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -216,7 +226,7 @@
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
-        <target state="translated">MSB4181: "{0}" Â∑•‰ΩúÂÇ≥Âõû‰∫Ü falseÔºå‰ΩÜ‰∏¶Êú™Ë®òÈåÑÈåØË™§„ÄÇ</target>
+        <target state="translated">MSB4181: "{0}" Â∑•‰ΩúÂÇ≥Âõû‰∫Ü FalseÔºå‰ΩÜÊú™Ë®òÈåÑÈåØË™§„ÄÇ</target>
         <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index 35030eefbac..b3c15748810 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -42,7 +42,6 @@ public EngineFileUtilities(FileMatcher fileMatcher)
             _fileMatcher = fileMatcher;
         }
 
-
         /// <summary>
         /// Used for the purposes of evaluating an item specification. Given a filespec that may include wildcard characters * and
         /// ?, we translate it into an actual list of files. If the input filespec doesn't contain any wildcard characters, and it
@@ -143,7 +142,7 @@ private string[] GetFileList
             IEnumerable<string> excludeSpecsEscaped = null
             )
         {
-            ErrorUtilities.VerifyThrowInternalLength(filespecEscaped, "filespecEscaped");
+            ErrorUtilities.VerifyThrowInternalLength(filespecEscaped, nameof(filespecEscaped));
 
             if (excludeSpecsEscaped == null)
             {
diff --git a/src/Build/Utilities/FileSpecMatchTester.cs b/src/Build/Utilities/FileSpecMatchTester.cs
index 2aa18bbb14e..725ef4752a2 100644
--- a/src/Build/Utilities/FileSpecMatchTester.cs
+++ b/src/Build/Utilities/FileSpecMatchTester.cs
@@ -10,7 +10,7 @@
 
 namespace Microsoft.Build.Internal
 {
-    internal struct FileSpecMatcherTester
+    internal readonly struct FileSpecMatcherTester
     {
         private readonly string _currentDirectory;
         private readonly string _unescapedFileSpec;
@@ -53,16 +53,11 @@ public bool IsMatch(string fileToMatch)
         // todo: glob rooting knowledge partially duplicated with MSBuildGlob.Parse and FileMatcher.ComputeFileEnumerationCacheKey
         private static Regex CreateRegex(string unescapedFileSpec, string currentDirectory)
         {
-            Regex regex = null;
-            string fixedDirPart = null;
-            string wildcardDirectoryPart = null;
-            string filenamePart = null;
-
             FileMatcher.Default.SplitFileSpec(
-                unescapedFileSpec,
-                out fixedDirPart,
-                out wildcardDirectoryPart,
-                out filenamePart);
+            unescapedFileSpec,
+            out string fixedDirPart,
+            out string wildcardDirectoryPart,
+            out string filenamePart);
 
             if (FileUtilities.PathIsInvalid(fixedDirPart))
             {
@@ -77,16 +72,13 @@ private static Regex CreateRegex(string unescapedFileSpec, string currentDirecto
 
             normalizedFixedDirPart = FileUtilities.EnsureTrailingSlash(normalizedFixedDirPart);
 
-            var recombinedFileSpec = string.Join("", normalizedFixedDirPart, wildcardDirectoryPart, filenamePart);
-
-            bool isRecursive;
-            bool isLegal;
+            var recombinedFileSpec = string.Concat(normalizedFixedDirPart, wildcardDirectoryPart, filenamePart);
 
             FileMatcher.Default.GetFileSpecInfoWithRegexObject(
                 recombinedFileSpec,
-                out regex,
-                out isRecursive,
-                out isLegal);
+                out Regex regex,
+                out bool _,
+                out bool isLegal);
 
             return isLegal ? regex : null;
         }
diff --git a/src/Build/Utilities/NuGetFrameworkWrapper.cs b/src/Build/Utilities/NuGetFrameworkWrapper.cs
index 117e85acd93..3bb52fd3d73 100644
--- a/src/Build/Utilities/NuGetFrameworkWrapper.cs
+++ b/src/Build/Utilities/NuGetFrameworkWrapper.cs
@@ -21,10 +21,12 @@ internal class NuGetFrameworkWrapper
         private static object DefaultCompatibilityProvider;
         private static PropertyInfo FrameworkProperty;
         private static PropertyInfo VersionProperty;
+        private static PropertyInfo PlatformProperty;
+        private static PropertyInfo PlatformVersionProperty;
 
         public NuGetFrameworkWrapper()
         {
-            /// Resolve the location of the NuGet.Frameworks assembly
+            // Resolve the location of the NuGet.Frameworks assembly
             var assemblyDirectory = BuildEnvironmentHelper.Instance.Mode == BuildEnvironmentMode.VisualStudio ?
                 Path.Combine(BuildEnvironmentHelper.Instance.VisualStudioInstallRootDirectory, "Common7", "IDE", "CommonExtensions", "Microsoft", "NuGet") :
                 BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
@@ -39,6 +41,8 @@ public NuGetFrameworkWrapper()
                 DefaultCompatibilityProvider = NuGetFrameworkDefaultCompatibilityProvider.GetMethod("get_Instance").Invoke(null, new object[] { });
                 FrameworkProperty = NuGetFramework.GetProperty("Framework");
                 VersionProperty = NuGetFramework.GetProperty("Version");
+                PlatformProperty = NuGetFramework.GetProperty("Platform");
+                PlatformVersionProperty = NuGetFramework.GetProperty("PlatformVersion");
             }
             catch
             {
@@ -56,14 +60,32 @@ public string GetTargetFrameworkIdentifier(string tfm)
             return FrameworkProperty.GetValue(Parse(tfm)) as string;
         }
 
-        public string GetTargetFrameworkVersion(string tfm)
+        public string GetTargetFrameworkVersion(string tfm, int minVersionPartCount)
         {
-            return (VersionProperty.GetValue(Parse(tfm)) as Version).ToString(2);
+            var version = VersionProperty.GetValue(Parse(tfm)) as Version;
+            return GetNonZeroVersionParts(version, minVersionPartCount);
+        }
+
+        public string GetTargetPlatformIdentifier(string tfm)
+        {
+            return PlatformProperty.GetValue(Parse(tfm)) as string;
+        }
+
+        public string GetTargetPlatformVersion(string tfm, int minVersionPartCount)
+        {
+            var version = PlatformVersionProperty.GetValue(Parse(tfm)) as Version;
+            return GetNonZeroVersionParts(version, minVersionPartCount);
         }
 
         public bool IsCompatible(string target, string candidate)
         {
             return Convert.ToBoolean(IsCompatibleMethod.Invoke(DefaultCompatibilityProvider, new object[] { Parse(target), Parse(candidate) }));
         }
+
+        private string GetNonZeroVersionParts(Version version, int minVersionPartCount)
+        {
+            var nonZeroVersionParts = version.Revision == 0 ? version.Build == 0 ? version.Minor == 0 ? 1 : 2 : 3: 4;
+            return version.ToString(Math.Max(nonZeroVersionParts, minVersionPartCount));
+        }
     }
 }
diff --git a/src/Build/Utilities/RegistryKeyWrapper.cs b/src/Build/Utilities/RegistryKeyWrapper.cs
index a410a39471f..5db9a22e37c 100644
--- a/src/Build/Utilities/RegistryKeyWrapper.cs
+++ b/src/Build/Utilities/RegistryKeyWrapper.cs
@@ -67,8 +67,8 @@ internal RegistryKeyWrapper(string registryKeyPath, RegistryHive registryHive, R
         /// </summary>
         internal RegistryKeyWrapper(string registryKeyPath, RegistryKey registryHive)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(registryKeyPath, "registryKeyPath");
-            ErrorUtilities.VerifyThrowArgumentNull(registryHive, "registryHive");
+            ErrorUtilities.VerifyThrowArgumentNull(registryKeyPath, nameof(registryKeyPath));
+            ErrorUtilities.VerifyThrowArgumentNull(registryHive, nameof(registryHive));
 
             _registryKeyPath = registryKeyPath;
             _registryHive = registryHive;
@@ -173,7 +173,7 @@ public virtual string[] GetSubKeyNames()
         /// <returns></returns>
         public virtual RegistryKeyWrapper OpenSubKey(string name)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
 
             RegistryKeyWrapper wrapper = this;
             string[] keyNames = name.Split(MSBuildConstants.BackslashChar, StringSplitOptions.RemoveEmptyEntries);
@@ -202,7 +202,7 @@ public virtual RegistryKeyWrapper OpenSubKey(string name)
         /// <returns></returns>
         public virtual bool Exists()
         {
-            return (null != WrappedKey);
+            return WrappedKey != null;
         }
 
         /// <summary>
diff --git a/src/Build/Utilities/SimpleVersion.cs b/src/Build/Utilities/SimpleVersion.cs
index c0534a9a64b..e277165f314 100644
--- a/src/Build/Utilities/SimpleVersion.cs
+++ b/src/Build/Utilities/SimpleVersion.cs
@@ -23,7 +23,7 @@ namespace Microsoft.Build.Utilities
     /// Unlike System.Version, does not tolerate whitespace, and '+' is ignored as
     /// semver metadata as described above, not tolerated as positive sign of integer
     /// component.
-    /// <summary>
+    /// </summary>
     /// <remarks>
     /// Tolerating leading 'v' allows using $(TargetFrameworkVersion) directly.
     ///
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index a0681677b05..6aae23a460e 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -254,7 +254,7 @@ private static bool ContainsNoTagsOtherThanComments(string innerXml, int firstLe
                     {
                         // Found the start of a comment
                         insideComment = true;
-                        i = i + 3;
+                        i += 3;
                         continue;
                     }
                 }
@@ -278,7 +278,7 @@ private static bool ContainsNoTagsOtherThanComments(string innerXml, int firstLe
                     {
                         // Found the end of a comment
                         insideComment = false;
-                        i = i + 2;
+                        i += 2;
                         continue;
                     }
                 }
@@ -450,9 +450,9 @@ internal static string GenerateToolsVersionToUse(string explicitToolsVersion, st
 
         private static bool UsingDifferentToolsVersionFromProjectFile(string toolsVersionFromProject, string toolsVersionToUse, bool explicitToolsVersionSpecified)
         {
-            return (!explicitToolsVersionSpecified &&
+            return !explicitToolsVersionSpecified &&
                     !String.IsNullOrEmpty(toolsVersionFromProject) &&
-                    !String.Equals(toolsVersionFromProject, toolsVersionToUse, StringComparison.OrdinalIgnoreCase));
+                    !String.Equals(toolsVersionFromProject, toolsVersionToUse, StringComparison.OrdinalIgnoreCase);
         }
 
         /// <summary>
diff --git a/src/Build/Xml/ProjectXmlUtilities.cs b/src/Build/Xml/ProjectXmlUtilities.cs
index 8a54c20ef6a..3c1528a3064 100644
--- a/src/Build/Xml/ProjectXmlUtilities.cs
+++ b/src/Build/Xml/ProjectXmlUtilities.cs
@@ -163,7 +163,7 @@ internal static XmlAttributeWithLocation SetOrRemoveAttribute(XmlElementWithLoca
         }
 
         /// <summary>
-        /// Sets the value of an attribute, removing the attribute if the value is null, but still setting it 
+        /// Sets the value of an attribute, removing the attribute if the value is null, but still setting it
         /// if the value is the empty string. Returns the attribute, or null if it was removed.
         /// UNDONE: Make this return a bool if the attribute did not change, so we can avoid dirtying.
         /// </summary>
@@ -185,7 +185,7 @@ internal static XmlAttributeWithLocation SetOrRemoveAttribute(XmlElementWithLoca
         }
 
         /// <summary>
-        /// Returns the value of the attribute. 
+        /// Returns the value of the attribute.
         /// If the attribute is null, returns an empty string.
         /// </summary>
         internal static string GetAttributeValue(XmlAttributeWithLocation attribute, bool returnNullForNonexistentAttributes)
@@ -201,7 +201,7 @@ internal static string GetAttributeValue(XmlAttributeWithLocation attribute, boo
         }
 
         /// <summary>
-        /// Returns the value of the attribute. 
+        /// Returns the value of the attribute.
         /// If the attribute is not present, returns an empty string.
         /// </summary>
         internal static string GetAttributeValue(XmlElementWithLocation element, string attributeName)
@@ -210,8 +210,8 @@ internal static string GetAttributeValue(XmlElementWithLocation element, string
         }
 
         /// <summary>
-        /// Returns the value of the attribute. 
-        /// If the attribute is not present, returns either null or an empty string, depending on the value 
+        /// Returns the value of the attribute.
+        /// If the attribute is not present, returns either null or an empty string, depending on the value
         /// of nullIfNotExists.
         /// </summary>
         internal static string GetAttributeValue(XmlElementWithLocation element, string attributeName, bool nullIfNotExists)
diff --git a/src/Build/Xml/XmlReaderExtension.cs b/src/Build/Xml/XmlReaderExtension.cs
index 77ec4045b3c..b857356476d 100644
--- a/src/Build/Xml/XmlReaderExtension.cs
+++ b/src/Build/Xml/XmlReaderExtension.cs
@@ -19,6 +19,7 @@ internal class XmlReaderExtension : IDisposable
         ///     Creates an XmlReaderExtension with handle to an XmlReader.
         /// </summary>
         /// <param name="filePath">Path to the file on disk.</param>
+        /// <param name="loadAsReadOnly">Whther to load the file in real only mode.</param>
         /// <returns>Disposable XmlReaderExtension object.</returns>
         internal static XmlReaderExtension Create(string filePath, bool loadAsReadOnly)
         {
@@ -78,12 +79,11 @@ private static XmlReader GetXmlReader(string file, StreamReader input, bool load
         {
             string uri = new UriBuilder(Uri.UriSchemeFile, string.Empty) { Path = file }.ToString();
 
-            XmlReader reader;
-
+            
             // Ignore loadAsReadOnly for now; using XmlReader.Create results in whitespace changes
             // of attribute text, specifically newline removal.
             // https://github.com/Microsoft/msbuild/issues/4210
-            reader = new XmlTextReader(uri, input) { DtdProcessing = DtdProcessing.Ignore };
+            XmlReader reader = new XmlTextReader(uri, input) { DtdProcessing = DtdProcessing.Ignore };
 
             reader.Read();
             encoding = input.CurrentEncoding;
diff --git a/src/Deprecated/Conversion/AdditionalOptionsParser.cs b/src/Deprecated/Conversion/AdditionalOptionsParser.cs
index b99929a450e..1695918ddb2 100644
--- a/src/Deprecated/Conversion/AdditionalOptionsParser.cs
+++ b/src/Deprecated/Conversion/AdditionalOptionsParser.cs
@@ -31,7 +31,7 @@ internal enum SwitchesToMigrate
     internal enum SwitchValueType
     {
         /// <summary>
-        /// Boolean value 
+        /// Boolean value
         /// </summary>
         SVT_Boolean,
 
@@ -41,7 +41,7 @@ internal enum SwitchValueType
         SVT_String,
 
         /// <summary>
-        /// This switch can occur multiple times and the 
+        /// This switch can occur multiple times and the
         /// final value is the ';' delimeted concat of all the
         /// individual occurrences
         /// </summary>
@@ -50,7 +50,7 @@ internal enum SwitchValueType
 
     /// <summary>
     /// This class contains the migration info for a switch
-    /// that we want to migrate 
+    /// that we want to migrate
     /// </summary>
     internal sealed class CompSwitchInfo
     {
@@ -85,7 +85,7 @@ internal sealed class CompSwitchInfo
         internal object SwitchValue;
 
         /// <summary>
-        /// This is the the name of property in the project file in which the
+        /// This is the name of property in the project file in which the
         /// value of this switch is stored
         /// </summary>
         internal string SwitchProjectPropertyName;
@@ -110,32 +110,32 @@ string switchProjectPropertyName
     }
 
     /// <summary>
-    /// 
+    ///
     /// Class:       AdditionalOptionsParser
     /// Owner:       ParthaD
-    /// 
-    /// This class contains the logic to parse the AdditionalOptions project 
+    ///
+    /// This class contains the logic to parse the AdditionalOptions project
     /// property of v7.x J# projects and add the individual options as project
     /// properties of the upgraded projects.
-    /// 
+    ///
     /// AdditionalOptions project property in v7.x was basically a string that
     /// was passed ditto to the compiler.
     /// It was used to hold J# compiler options that didnt have an 1-1 equivalent
     /// project property.
     /// For v8.0 and beyond, each J# compiler option has a corresponding project
     /// property.
-    /// 
+    ///
     /// AdditionalOptions property string is broken down into list of options.
     /// White space (only ' ' and '\t') are considered as delimiters if not wrapped
-    /// inside double quotes ("). 
+    /// inside double quotes (").
     /// NOTE:
     ///  1. Other unicode spaces or double quotes sequences not considered
-    ///  2. Backslash (\) not considered as possible escape char for ". 
-    /// 
+    ///  2. Backslash (\) not considered as possible escape char for ".
+    ///
     /// Once broken down into individual options, only a few compiler options are
     /// seached for (viz. the options for which v8.0 has new project properties)
     /// Everything else is ignored.
-    /// 
+    ///
     /// Refer to SwitchesToMigrade enum for the switches that are migrated.
     /// </summary>
     internal sealed class AdditionalOptionsParser
@@ -151,7 +151,7 @@ internal sealed class AdditionalOptionsParser
                 null,
                 "CodePage"
             ),
-            
+
             // /x:[all | net]
             new CompSwitchInfo(
                 SwitchesToMigrate.STM_DisableLangExtensions,
@@ -187,7 +187,7 @@ internal sealed class AdditionalOptionsParser
                 null,
                 "SecureScoping"
             ),
-            
+
             // /win32res:<file>
             new CompSwitchInfo(
                 SwitchesToMigrate.STM_Win32Resource,
@@ -208,15 +208,14 @@ ProjectPropertyGroupElement configPropertyGroup
         )
         {
             // Trivial case
-            if (null == additionalOptionsValue)
+            if (additionalOptionsValue == null)
             {
                 return;
             }
 
             // Tokenize the additional options first
-            string[] compSwitchList;
-            compSwitchList = TokenizeAdditionalOptionsValue(additionalOptionsValue);
-            
+            string[] compSwitchList = TokenizeAdditionalOptionsValue(additionalOptionsValue);
+
             // Extract the switch arguments
             foreach (string compSwitch in compSwitchList)
             {
@@ -228,11 +227,11 @@ ProjectPropertyGroupElement configPropertyGroup
                     }
                 }
             }
-            
+
             // Finally populate the project file and we'r done!
             PopulatePropertyGroup(configPropertyGroup);
         }
-        
+
         /// <summary>
         /// This will tokenize the given string using ' ' and '\t' as delimiters
         /// The delimiters are escaped inside a pair of quotes
@@ -241,7 +240,7 @@ ProjectPropertyGroupElement configPropertyGroup
         private string[] TokenizeAdditionalOptionsValue(string additionalOptionsValue)
         {
             ArrayList tokens = new ArrayList();
-            
+
             bool inQuotes = false;
             StringBuilder option = new StringBuilder();
             foreach (char c in additionalOptionsValue)
@@ -301,7 +300,7 @@ private bool ExtractSwitchInfo(CompSwitchInfo compSwitchInfo, string compSwitch)
                 }
             }
             // No no... we arent dealing with the correct switchInfo
-            if (null == matchedID)
+            if (matchedID == null)
             {
                 return false;
             }
@@ -326,7 +325,7 @@ private bool ExtractSwitchInfo(CompSwitchInfo compSwitchInfo, string compSwitch)
                             switchVal = false;
                         }
                     }
-                    if (null != switchVal)
+                    if (switchVal != null)
                     {
                         compSwitchInfo.SwitchValue = switchVal;
                     }
@@ -341,7 +340,7 @@ private bool ExtractSwitchInfo(CompSwitchInfo compSwitchInfo, string compSwitch)
                     {
                         switchVal = compSwitch.Substring(matchedID.Length);
                     }
-                    if (null != switchVal)
+                    if (switchVal != null)
                     {
                         compSwitchInfo.SwitchValue = switchVal;
                     }
@@ -353,7 +352,7 @@ private bool ExtractSwitchInfo(CompSwitchInfo compSwitchInfo, string compSwitch)
 
                 case SwitchValueType.SVT_MultiString:
                     Debug.Assert(
-                        null != compSwitchInfo.SwitchValue, 
+                        compSwitchInfo.SwitchValue != null,
                         "Non null switch value expected for a multistring switch: " + matchedID
                     );
 
@@ -361,7 +360,7 @@ private bool ExtractSwitchInfo(CompSwitchInfo compSwitchInfo, string compSwitch)
                     {
                         switchVal = compSwitch.Substring(matchedID.Length);
                     }
-                    if (null != switchVal)
+                    if (switchVal != null)
                     {
                         ((StringBuilder)(compSwitchInfo.SwitchValue)).Append(switchVal);
                         ((StringBuilder)(compSwitchInfo.SwitchValue)).Append(";");
@@ -399,17 +398,17 @@ private void PopulatePropertyGroup(ProjectPropertyGroupElement configPropertyGro
                 switch (compSwitchInfo.SwitchValueType)
                 {
                     case SwitchValueType.SVT_Boolean:
-                        if (null != compSwitchInfo.SwitchValue)
+                        if (compSwitchInfo.SwitchValue != null)
                         {
                             configPropertyGroup.AddProperty(
-                                propertyName, 
+                                propertyName,
                                 compSwitchInfo.SwitchValue.ToString().ToLower(CultureInfo.InvariantCulture)
                             );
                         }
                     break;
 
                     case SwitchValueType.SVT_String:
-                        if (null != compSwitchInfo.SwitchValue)
+                        if (compSwitchInfo.SwitchValue != null)
                         {
                             configPropertyGroup.AddProperty(
                                 propertyName,
@@ -419,7 +418,7 @@ private void PopulatePropertyGroup(ProjectPropertyGroupElement configPropertyGro
                     break;
 
                     case SwitchValueType.SVT_MultiString:
-                        Debug.Assert(null != compSwitchInfo.SwitchValue, "Expected non null value for multistring switch");
+                        Debug.Assert(compSwitchInfo.SwitchValue != null, "Expected non null value for multistring switch");
                         if (0 != ((StringBuilder)(compSwitchInfo.SwitchValue)).Length)
                         {
                             configPropertyGroup.AddProperty(
diff --git a/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj b/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
index 83265f55cdd..af98c8f06b8 100644
--- a/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
+++ b/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
@@ -7,6 +7,7 @@
     <IsPackable>true</IsPackable>
     <PackageDescription>This package contains the $(MSBuildProjectName) assembly which contains logic for converting projects.  NOTE: This assembly is deprecated.</PackageDescription>
     <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
+    <NoWarn>$(NoWarn);1570;1572;1573;1587</NoWarn>
   </PropertyGroup>
   <ItemGroup>
     <!-- Source Files -->
diff --git a/src/Deprecated/Conversion/OldVSProjectFileReader.cs b/src/Deprecated/Conversion/OldVSProjectFileReader.cs
index b720fe5e527..25a7bef63eb 100644
--- a/src/Deprecated/Conversion/OldVSProjectFileReader.cs
+++ b/src/Deprecated/Conversion/OldVSProjectFileReader.cs
@@ -143,7 +143,7 @@ int     charactersToRead        // The number of characters to read.
             if ((startIndexIntoBuffer + charactersToRead) > bufferToReadInto.Length)
             {
                 // End-user should never see this message, so it doesn't need to be localized.
-                throw new ArgumentException("Cannot write past end of user's buffer.", "charactersToRead");
+                throw new ArgumentException("Cannot write past end of user's buffer.", nameof(charactersToRead));
             }
 
             int charactersCopied = 0;
@@ -463,7 +463,7 @@ string xmlAttributeText
                         // Case-sensitive comparison to see if the entity name matches any of
                         // the well-known ones that were emitted by the XML writer in the VS.NET
                         // 2002/2003 project system.
-                        if (0 == String.Compare(entityName, entities[i], StringComparison.Ordinal))
+                        if (String.Equals(entityName, entities[i], StringComparison.Ordinal))
                         {
                             foundEntity = true;
                             break;
@@ -554,9 +554,9 @@ int indexOfAmpersand
 
             StringBuilder replacedString = new StringBuilder();
 
-            replacedString.Append(originalString.Substring(0, indexOfAmpersand));
+            replacedString.Append(originalString, 0, indexOfAmpersand);
             replacedString.Append("&amp;");
-            replacedString.Append(originalString.Substring(indexOfAmpersand + 1));
+            replacedString.Append(originalString, indexOfAmpersand + 1, originalString.Length - indexOfAmpersand + 1);
 
             return replacedString.ToString();
         }
diff --git a/src/Deprecated/Conversion/ProjectFileConverter.cs b/src/Deprecated/Conversion/ProjectFileConverter.cs
index baf3db16561..c5a11510966 100644
--- a/src/Deprecated/Conversion/ProjectFileConverter.cs
+++ b/src/Deprecated/Conversion/ProjectFileConverter.cs
@@ -372,9 +372,9 @@ private void DoConvert()
         {
             // Make sure we were passed in non-empty source and destination project
             // file names.
-            error.VerifyThrowArgument((this.oldProjectFile != null) && (this.oldProjectFile.Length > 0),
+            error.VerifyThrowArgument(!string.IsNullOrEmpty(this.oldProjectFile),
                 "MissingOldProjectFile");
-            error.VerifyThrowArgument((this.newProjectFile != null) && (this.newProjectFile.Length > 0),
+            error.VerifyThrowArgument(!string.IsNullOrEmpty(this.newProjectFile),
                 "MissingNewProjectFile");
 
             ConvertInMemoryToMSBuildProject();
@@ -425,7 +425,7 @@ private void ConvertInMemoryToMSBuildProject()
         {
             // Make sure we were passed in non-empty source and destination project
             // file names.
-            error.VerifyThrowArgument((this.oldProjectFile != null) && (this.oldProjectFile.Length > 0),
+            error.VerifyThrowArgument(!string.IsNullOrEmpty(this.oldProjectFile),
                 "MissingOldProjectFile");
 
             // Make sure the source project file exists.
@@ -516,7 +516,7 @@ private void ConvertInMemoryToMSBuildProject()
                 // Find matching imports but don't delete whilst enumerating else it will throw an error
                 foreach (ProjectImportElement nextImport in xmakeProject.Imports)
                 {
-                    if (String.Compare(nextImport.Project, @"$(MSBuildBinPath)\Microsoft.WinFX.targets", StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(nextImport.Project, @"$(MSBuildBinPath)\Microsoft.WinFX.targets", StringComparison.OrdinalIgnoreCase))
                     {
                         listOfImportsToBeDeleted.Add(nextImport);
                     }
@@ -532,7 +532,6 @@ private void ConvertInMemoryToMSBuildProject()
                         listOfWFImportsToBeDeleted.Add(nextImport);
                         workflowImportsToAdd.Add(nextImport.Project.Replace(workflowOldOrcasTargetsPath, workflowNewTargetsPath));
                     }
-
                 }
 
                 // Now delete any matching imports
@@ -564,7 +563,6 @@ private void ConvertInMemoryToMSBuildProject()
                     changedProject = true;
                 }
 
-
                 // Re-add the workflow imports with the v4.0 targets.
                 foreach (string workflowImportToAdd in workflowImportsToAdd)
                 {
@@ -585,7 +583,7 @@ private void ConvertInMemoryToMSBuildProject()
                 {
                     if ((!nextItem.ItemType.Equals("Reference", StringComparison.OrdinalIgnoreCase)) &&
                         (nextItem.Include.Trim().EndsWith(".xaml", StringComparison.OrdinalIgnoreCase)))
-                        
+
                     {
                         if (!nextItem.Metadata.Any(m => String.Equals(m.Name, "Generator", StringComparison.OrdinalIgnoreCase)))
                         {
@@ -634,15 +632,15 @@ private void ConvertInMemoryToMSBuildProject()
 
                 // Fix up TargetFrameworkSubset
                 changedProject = FixTargetFrameworkSubset() || changedProject;
-                
+
                 var hasFSharpSpecificConversions = FSharpSpecificConversions(true);
-                
+
                 changedProject = hasFSharpSpecificConversions || changedProject;
                 changedProject = VBSpecificConversions() || changedProject;
 
                 // Do asset compat repair for any project that was previously a TV < 12.0
                 if (
-                        String.IsNullOrEmpty(oldToolsVersion) || 
+                        String.IsNullOrEmpty(oldToolsVersion) ||
                         String.Equals(oldToolsVersion, "3.5", StringComparison.OrdinalIgnoreCase) ||
                         String.Equals(oldToolsVersion, "4.0", StringComparison.OrdinalIgnoreCase)
                     )
@@ -710,7 +708,7 @@ private bool DoRepairForAssetCompat()
             var toRepairImports = RequiresRepairForAssetCompat();
 
             if (toRepairImports == null || toRepairImports.Count() == 0)
-            { 
+            {
                 // no need to repair
                 return false;
             }
@@ -719,7 +717,7 @@ private bool DoRepairForAssetCompat()
             {
                 RepairImportForAssetCompat(toRepairImport);
             }
-            
+
             //
             // Add PropertyGroup with Conditions right before where the Imports occur
             //   <PropertyGroup>
@@ -754,7 +752,7 @@ private bool DoRepairForAssetCompat()
 
         /// <summary>
         /// Repairs the given import element
-        /// Change Import to use $(VSToolsPath), with Condition using $(VSToolsPath) 
+        /// Change Import to use $(VSToolsPath), with Condition using $(VSToolsPath)
         /// e.g. From: Import Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v10.0\WebApplications\Microsoft.WebApplication.targets"
         ///        To: Import Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v10.0\WebApplications\Microsoft.WebApplication.targets" Condition="false"
         ///            Import Project="$(VSToolsPath)\WebApplications\Microsoft.WebApplication.targets"
@@ -764,7 +762,7 @@ private bool DoRepairForAssetCompat()
         private void RepairImportForAssetCompat(ProjectImportElement toRepairImport)
         {
             // We shouldn't have this happen but check anyway:
-            ErrorUtilities.VerifyThrowInternalNull(toRepairImport, "toRepairImport");
+            ErrorUtilities.VerifyThrowInternalNull(toRepairImport, nameof(toRepairImport));
             ErrorUtilities.VerifyThrow(!toRepairImport.Condition.Equals("false", StringComparison.OrdinalIgnoreCase), "RepairImportForAssetCompat should not receive imports with condition=false already");
 
             var newImportElement = this.xmakeProject.CreateImportElement(toRepairImport.Project);
@@ -816,14 +814,13 @@ private string ExtractImportTargetsString(string importProjectValue)
         /// </summary>
         /// <returns>bool</returns>
         private IEnumerable<ProjectImportElement> RequiresRepairForAssetCompat()
-        { 
+        {
             // check if the project has the to-repair pattern in the Imports
             // pattern: $(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v10.0\
             var toRepairImports =  from import in xmakeProject.Imports
                                    where HasRepairPattern(import)
                                    select import;
 
-            
             return toRepairImports;
         }
 
@@ -896,7 +893,7 @@ private bool FixTargetFrameworkSubset()
                         parentGroup.SetProperty(XMakeProjectStrings.TargetFrameworkProfile, XMakeProjectStrings.ClientProfile);
                         changedProject = true;
                     }
-            
+
                     // In all cases, <TargetFrameworkSubset/> is no longer supported.  If it comes from the project
                     // that we're converting, then we forcibly remove it.  If it comes from some import... the user is
                     // on their own.  
@@ -915,13 +912,13 @@ private bool FixTargetFrameworkSubset()
 
         /// <summary>
         /// Performs conversions specific to F# projects (VS2008 CTP -> VS2012) and (VS2010 -> VS2012).
-        /// This involves: changing the location of FSharp targets, 
+        /// This involves: changing the location of FSharp targets,
         /// and for 2008CTP, adding explicit mscorlib and FSharp.Core references.
         /// </summary>
         /// <param name="actuallyMakeChanges">if true, make the changes, otherwise, don't actually make any changes, but do report the return boolean as to whether you would make changes</param>
         /// <returns>true if anything was (would be) changed, false otherwise</returns>
         public bool FSharpSpecificConversions(bool actuallyMakeChanges)
-        {           
+        {
             // For FSharp projects, should import different location of FSharp targets
             const string fsharpFS10TargetsPath = @"$(MSBuildExtensionsPath)\FSharp\1.0\Microsoft.FSharp.Targets";
             const string fsharpFS10TargetsPath32 = @"$(MSBuildExtensionsPath32)\FSharp\1.0\Microsoft.FSharp.Targets";
@@ -945,7 +942,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
             ProjectImportElement fsharpTargetsDev12PlusImport = null;
             ProjectImportElement fsharpTargetsDev11PortableImport = null;
 
-            if (actuallyMakeChanges == false && this.xmakeProject == null)
+            if (!actuallyMakeChanges && this.xmakeProject == null)
             {
                 // when coming down the actuallyMakeChanges==false code path (from the F# project system's UpgradeProject_CheckOnly method), we may not have loaded the Xml yet, so do that now
                 this.xmakeProject = ProjectRootElement.Open(oldProjectFile);
@@ -953,10 +950,10 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
 
             // local function: string equality check using OrdinalIgnoreCase comparison
             Func<string, string, bool> equals = (s1, s2) => String.Equals(s1, s2, StringComparison.OrdinalIgnoreCase);
-            
+
             // local function: wraps specified string value into Exists('value')
             Func<string, string> exists = s => string.Format(CultureInfo.InvariantCulture, "Exists('{0}')", s);
-            
+
             // local function: 
             // Creates property group element containing one property fsharpDev12PlusProperty with value 'path'. 
             // If addCondition is true, property group will have Exists(path) condition
@@ -967,7 +964,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                     parent.AppendChild(propGroup);
                     var prop = xmakeProject.CreatePropertyElement(fsharpDev12PlusProperty);
                     prop.Value = path;
-                    propGroup.AppendChild(prop);                    
+                    propGroup.AppendChild(prop);
                 };
 
             foreach (ProjectImportElement importElement in xmakeProject.Imports)
@@ -1014,11 +1011,11 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 return false;
 
             if (!actuallyMakeChanges)
-                return true;            
+                return true;
 
             // both branches adds this elements to the project
             var chooseElement = xmakeProject.CreateChooseElement(); // (1)
-            
+
             if (fsharpTargetsDev11PortableImport != null)
             {
                 // Dev11 portable library
@@ -1041,7 +1038,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 // portable libraries are supported since Dev11
                 var whenVsVersionIsDev11 = xmakeProject.CreateWhenElement("'$(VisualStudioVersion)' == '11.0'"); // (2)
                 chooseElement.AppendChild(whenVsVersionIsDev11);
-                
+
                 appendPropertyGroupForDev12PlusTargetsPath(fsharpPortableDev11TargetsPath, whenVsVersionIsDev11);
 
                 var otherwiseIfVsVersionIsDev12Plus = xmakeProject.CreateOtherwiseElement(); // (3)
@@ -1072,7 +1069,6 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 //</Choose>
                 //<Import Project="$(FSharpTargetsPath)" Condition="Exists('$(FSharpTargetsPath)')" />           
 
-
                 var whenVsVersionIsDev11 = xmakeProject.CreateWhenElement("'$(VisualStudioVersion)' == '11.0'");
                 chooseElement.AppendChild(whenVsVersionIsDev11);
                 {
@@ -1132,7 +1128,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 {
                     referencesItemGroup.AddItem(ReferenceItemType, "mscorlib");
                 }
-            }            
+            }
 
             // try to find reference to FSharp.Core 
             ProjectItemElement fsharpCoreItem = null;
@@ -1160,7 +1156,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
             ProjectItemElement newFSharpCoreItem = null;
             string targetFSharpCoreVersionValue = null;
 
-            var hintPathValue = fsharpCoreItem != null ? fsharpCoreItem.Metadata.FirstOrDefault(metadata => metadata.Name == HintPath) : null;
+            var hintPathValue = fsharpCoreItem?.Metadata.FirstOrDefault(metadata => metadata.Name == HintPath);
             if (hintPathValue != null)
             {
                 if (equals(hintPathValue.Value, Dev11PortableFSharpCoreLocation))
@@ -1190,15 +1186,11 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 }
             }
 
-            if (newFSharpCoreItem != null)
-            {
-                newFSharpCoreItem.AddMetadata("Private", "True");
-            }
+            newFSharpCoreItem?.AddMetadata("Private", "True");
 
-            
             const string MinimumVisualStudioVersionProperty = "MinimumVisualStudioVersion";
             var hasMinimumVSVersion = xmakeProject.Properties.Any(prop => prop.Name == MinimumVisualStudioVersionProperty);
-            
+
             foreach(var group in xmakeProject.PropertyGroups)
             {
                 // find first non-conditional property group to add TargetFSharpCoreVersion property
@@ -1225,7 +1217,6 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 fsharpCoreItem.Parent.RemoveChild(fsharpCoreItem);
             }
 
-
             return true;
         }
 
@@ -1433,8 +1424,7 @@ XmlElementWithLocation      visualStudioProjectElement
             )
         {
             // Make sure this is the <VisualStudioProject> element.
-            error.VerifyThrow((visualStudioProjectElement != null) &&
-                (visualStudioProjectElement.Name == VSProjectElements.visualStudioProject),
+            error.VerifyThrow((visualStudioProjectElement?.Name == VSProjectElements.visualStudioProject),
                 "Expected <VisualStudioProject> element.");
 
             // Make sure the caller has given us a valid xmakeProject object.
@@ -1444,7 +1434,7 @@ XmlElementWithLocation      visualStudioProjectElement
             // to convert a VC++ or some other type of project, and give a more friendly
             // error message.
             string projectType = visualStudioProjectElement.GetAttribute(VSProjectAttributes.projectType);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((projectType == null) || (projectType.Length == 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject(string.IsNullOrEmpty(projectType),
                 visualStudioProjectElement.Location, "ProjectTypeCannotBeConverted", projectType);
 
             // Make sure the <VisualStudioProject> tag doesn't have any attributes.
@@ -1518,13 +1508,13 @@ XmlElementWithLocation      languageElement
             // Get the project instance GUID for this project file.  It is required for
             // the main project file, but not for the .USER file.
             this.projectGuid = languageElement.GetAttribute(VSProjectAttributes.projectGuid);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((this.projectGuid != null) || (this.isUserFile == true),
+            ProjectErrorUtilities.VerifyThrowInvalidProject((this.projectGuid != null) || (this.isUserFile),
                 languageElement.Location, "MissingAttribute", languageElement.Name, VSProjectAttributes.projectGuid);
 
             // Get the project type for this project file.  We only support "Local".  We do not
             // convert web projects -- that's Venus's job.
             string projectType = languageElement.GetAttribute(VSProjectAttributes.projectType);
-            ProjectErrorUtilities.VerifyThrowInvalidProject(projectType == null || projectType.Length == 0 ||
+            ProjectErrorUtilities.VerifyThrowInvalidProject(string.IsNullOrEmpty(projectType) ||
                 (String.Compare(projectType, VSProjectAttributes.local, StringComparison.OrdinalIgnoreCase) == 0),
                 languageElement.Location, "ProjectTypeCannotBeConverted", projectType);
 
@@ -1563,7 +1553,7 @@ XmlElementWithLocation      languageElement
             // -----------------------------------------------------------------------
 
             string originalMyType = languageElement.GetAttribute(XMakeProjectStrings.myType);
-            if ((originalMyType != null) && (originalMyType.Length != 0))
+            if (!string.IsNullOrEmpty(originalMyType))
             {
                 // Flag the fact that the Everett project already had a MyType property in there,
                 // so we don't try to override it later.
@@ -1630,7 +1620,6 @@ XmlElementWithLocation      languageElement
                 }
             }
 
-
             // Loop through all the direct child elements of the language element.
             foreach(XmlNode languageChildNode in languageElement)
             {
@@ -1717,9 +1706,9 @@ private void AddFinalPropertiesAndImports(XmlElementWithLocation languageElement
                     !isTriumphProject        // Doesn't apply to Triumph->Trinity conversions.
                 )
                 {
-                    if (this.outputType != null && this.outputType.Length > 0)
+                    if (!string.IsNullOrEmpty(this.outputType))
                     {
-                        if (String.Compare(this.outputType, XMakeProjectStrings.winExe, StringComparison.OrdinalIgnoreCase) == 0)
+                        if (String.Equals(this.outputType, XMakeProjectStrings.winExe, StringComparison.OrdinalIgnoreCase))
                         {
                             if (this.hasWindowsFormsReference)
                             {
@@ -1731,11 +1720,11 @@ private void AddFinalPropertiesAndImports(XmlElementWithLocation languageElement
                                 this.globalPropertyGroup.AddProperty(XMakeProjectStrings.myType, XMakeProjectStrings.console);
                             }
                         }
-                        else if (String.Compare(this.outputType, XMakeProjectStrings.exe, StringComparison.OrdinalIgnoreCase) == 0)
+                        else if (String.Equals(this.outputType, XMakeProjectStrings.exe, StringComparison.OrdinalIgnoreCase))
                         {
                             this.globalPropertyGroup.AddProperty(XMakeProjectStrings.myType, XMakeProjectStrings.console);
                         }
-                        else if (String.Compare(this.outputType, XMakeProjectStrings.library, StringComparison.OrdinalIgnoreCase) == 0)
+                        else if (String.Equals(this.outputType, XMakeProjectStrings.library, StringComparison.OrdinalIgnoreCase))
                         {
                             this.globalPropertyGroup.AddProperty(XMakeProjectStrings.myType, XMakeProjectStrings.windows);
                         }
@@ -1825,8 +1814,7 @@ XmlElementWithLocation      buildElement
             )
         {
             // Make sure this is the <Build> element.
-            error.VerifyThrow((buildElement != null) &&
-                (buildElement.Name == VSProjectElements.build), "Expected <Build> element.");
+            error.VerifyThrow((buildElement?.Name == VSProjectElements.build), "Expected <Build> element.");
 
             // Make sure the caller has given us a valid xmakeProject object.
             error.VerifyThrow(xmakeProject != null, "Expected valid XMake project object.");
@@ -1893,8 +1881,7 @@ XmlElementWithLocation      settingsElement
             )
         {
             // Make sure this is the <Settings> element.
-            error.VerifyThrow((settingsElement != null) &&
-                (settingsElement.Name == VSProjectElements.settings),
+            error.VerifyThrow((settingsElement?.Name == VSProjectElements.settings),
                 "Expected <Settings> element.");
 
             // Make sure the caller has given us a valid xmakeProject object.
@@ -2019,8 +2006,7 @@ XmlElementWithLocation      configElement
             )
         {
             // Make sure this is the <Config> element.
-            error.VerifyThrow((configElement != null) &&
-                (configElement.Name == VSProjectElements.config),
+            error.VerifyThrow((configElement?.Name == VSProjectElements.config),
                 "Expected <Config> element.");
 
             // Make sure the caller has given us a valid xmakeProject object.
@@ -2077,7 +2063,7 @@ XmlElementWithLocation      configElement
 
             // Get the "Name" attribute of the <Config> element.
             string configName = configElement.GetAttribute(VSProjectAttributes.name);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((configName != null) && (configName.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(configName),
                 configElement.Location, "MissingAttribute", VSProjectElements.config, VSProjectAttributes.name);
 
             // In the case of VSD projects, the "Name" attribute will have a pipe in it,
@@ -2115,7 +2101,7 @@ XmlElementWithLocation      configElement
 
             // Process OutputPath attribute separately to ensure it contains trailing backslash
             string outputPath = configElement.GetAttribute(VSProjectAttributes.outputPath);
-            if (outputPath != null && outputPath.Length > 0)
+            if (!string.IsNullOrEmpty(outputPath))
             {
                 if (outputPath[outputPath.Length-1] != Path.DirectorySeparatorChar)
                     outputPath += Path.DirectorySeparatorChar;
@@ -2127,20 +2113,20 @@ XmlElementWithLocation      configElement
             // If the "SelectedDevice" or "DeploymentPlatform" attributes exist in the per-user
             //   project file, we should get rid of them.
             string selectedDevice = configElement.GetAttribute ( VSProjectAttributes.selectedDevice );
-            if ( isUserFile && ( selectedDevice != null ) && ( selectedDevice.Length > 0 ) )
+            if (isUserFile && (selectedDevice?.Length > 0))
             {
                 configElement.RemoveAttribute ( VSProjectAttributes.selectedDevice );
             }
 
             string deploymentPlatform = configElement.GetAttribute ( VSProjectAttributes.deploymentPlatform );
-            if ( isUserFile && ( deploymentPlatform != null ) && ( deploymentPlatform.Length > 0 ) )
+            if (isUserFile && (deploymentPlatform?.Length > 0))
             {
                 configElement.RemoveAttribute ( VSProjectAttributes.deploymentPlatform );
             }
 
             // Get rid of the "IncrementalBuild" attribute
             string incrementalBuild = configElement.GetAttribute ( VSProjectAttributes.incrementalBuild );
-            if (incrementalBuild != null && incrementalBuild.Length > 0)
+            if (!string.IsNullOrEmpty(incrementalBuild))
             {
                 configElement.RemoveAttribute ( VSProjectAttributes.incrementalBuild );
             }
@@ -2185,11 +2171,11 @@ XmlElementWithLocation      configElement
                 if (String.IsNullOrEmpty(debugType))
                 {
                     string debugSymbols = configElement.GetAttribute(XMakeProjectStrings.debugSymbols);
-                    if (  0 == String.Compare ( debugSymbols, "true", StringComparison.OrdinalIgnoreCase ) )
+                    if (  String.Equals ( debugSymbols, "true", StringComparison.OrdinalIgnoreCase ) )
                     {
                         configPropertyGroup.AddProperty(VSProjectAttributes.debugType, VSProjectAttributes.debugTypeFull);
                     }
-                    else if ( 0 == String.Compare(debugSymbols, "false", StringComparison.OrdinalIgnoreCase) )
+                    else if ( String.Equals(debugSymbols, "false", StringComparison.OrdinalIgnoreCase) )
                     {
                         configPropertyGroup.AddProperty(VSProjectAttributes.debugType, VSProjectAttributes.debugTypeNone);
                     }
@@ -2261,8 +2247,7 @@ XmlElementWithLocation      platformElement
             if ( !IsUserFile )
             {
                 // Make sure this is the <Platform> element.
-                error.VerifyThrow((platformElement != null) &&
-                    (platformElement.Name == VSProjectElements.platform),
+                error.VerifyThrow((platformElement?.Name == VSProjectElements.platform),
                     "Expected <Platform> element.");
 
                 // Make sure the caller has given us a valid xmakeProject object.
@@ -2285,7 +2270,7 @@ XmlElementWithLocation      platformElement
 
                 // Get the "Name" attribute of the <Platform> element.
                 platformForVSD = platformElement.GetAttribute(VSProjectAttributes.name);
-                ProjectErrorUtilities.VerifyThrowInvalidProject((platformForVSD != null) && (platformForVSD.Length > 0),
+                ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(platformForVSD),
                     platformElement.Location, "MissingAttribute", VSProjectElements.platform, VSProjectAttributes.name);
 
                 // Create a new property group, and add all of the XML attributes as XMake
@@ -2354,8 +2339,7 @@ ProjectPropertyGroupElement configPropertyGroup
             )
         {
             // Make sure this is the <InteropRegistration> element.
-            error.VerifyThrow((interopRegistrationElement != null) &&
-                (interopRegistrationElement.Name == VSProjectElements.interopRegistration),
+            error.VerifyThrow((interopRegistrationElement?.Name == VSProjectElements.interopRegistration),
                 "Expected <InteropRegistration> element.");
 
             // Make sure we've been given a valid configuration property group.
@@ -2411,8 +2395,7 @@ XmlElementWithLocation      referencesElement
             )
         {
             // Make sure this is the <References> element.
-            error.VerifyThrow((referencesElement != null) &&
-                (referencesElement.Name == VSProjectElements.references),
+            error.VerifyThrow((referencesElement?.Name == VSProjectElements.references),
                 "Expected <References> element.");
 
             // Make sure the caller has given us a valid xmakeProject object.
@@ -2496,8 +2479,7 @@ ProjectItemGroupElement referencesItemGroup
             )
         {
             // Make sure this is the <Reference> element.
-            error.VerifyThrow((referenceElement != null) &&
-                (referenceElement.Name == VSProjectElements.reference),
+            error.VerifyThrow((referenceElement?.Name == VSProjectElements.reference),
                 "Expected <Reference> element.");
 
             // Make sure the caller has already created an ProjectItemGroupElement for us to
@@ -2509,7 +2491,7 @@ ProjectItemGroupElement referencesItemGroup
             //   "-Designer", we need to disregard this reference entirely.
 
             string platform = referenceElement.GetAttribute(VSProjectAttributes.platform);
-            if ((platform != null) && (platform.Length > 0))
+            if (!string.IsNullOrEmpty(platform))
             {
                 if (platform.IndexOf("-Designer", 0, platform.Length, StringComparison.Ordinal) != -1)
                 {
@@ -2524,23 +2506,23 @@ ProjectItemGroupElement referencesItemGroup
             // Get the "Name" attribute.  This is a required attribute in the VS7/
             // Everett format.
             string referenceName = referenceElement.GetAttribute(VSProjectAttributes.name);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((referenceName != null) && (referenceName.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(referenceName),
                 referenceElement.Location, "MissingAttribute", VSProjectAttributes.name, VSProjectElements.reference);
 
             // Before we go any further, we must special-case some assemblies for VSD projects.
 
-            if ( ( ( this.language == VSProjectElements.ECSharp ) ||
-                   ( this.language == VSProjectElements.EVisualBasic ) ) )
+            if ((this.language == VSProjectElements.ECSharp) ||
+                   (this.language == VSProjectElements.EVisualBasic))
             {
                 if ( ( this.frameworkVersionForVSD == XMakeProjectStrings.vTwo ) &&
-                     ( 0 == String.Compare ( referenceName, VSProjectElements.SystemDataCommon, StringComparison.OrdinalIgnoreCase ) ) )
+                     ( String.Equals ( referenceName, VSProjectElements.SystemDataCommon, StringComparison.OrdinalIgnoreCase ) ) )
                 {
                     // We need to remove all references to "System.Data.Common" for VSD projects only.
                     //   Note : We only want to do this for projects that will be updated to v2.0
                     //          System.Data.Common is still valid for v1.0 upgraded projects.
                     return;
                 }
-                else if ( 0 == String.Compare ( referenceName, VSProjectElements.SystemSR, StringComparison.OrdinalIgnoreCase ) )
+                else if ( String.Equals ( referenceName, VSProjectElements.SystemSR, StringComparison.OrdinalIgnoreCase ) )
                 {
                     // We always want to remove all references to "System.SR"
                     return;
@@ -2548,7 +2530,7 @@ ProjectItemGroupElement referencesItemGroup
             }
 
             if ( ( this.language == VSProjectElements.EVisualBasic ) &&
-                 ( 0 == String.Compare ( referenceName, VSProjectElements.MSCorLib, StringComparison.OrdinalIgnoreCase ) ) )
+                 ( String.Equals ( referenceName, VSProjectElements.MSCorLib, StringComparison.OrdinalIgnoreCase ) ) )
             {
                 // We also want to get rid of all 'mscorlib' references for VB projects only.
                 return;
@@ -2566,12 +2548,12 @@ ProjectItemGroupElement referencesItemGroup
             // reference.
             string referencedProjectGuid = referenceElement.GetAttribute(VSProjectAttributes.project);
 
-            if ((comReferenceGuid != null) && (comReferenceGuid.Length > 0) &&
+            if (!string.IsNullOrEmpty(comReferenceGuid) &&
                 (comReferenceGuid != "{00000000-0000-0000-0000-000000000000}"))
             {
                 newReferenceItem = ConvertClassicComReference(referenceElement, referencesItemGroup, referenceName);
             }
-            else if ((referencedProjectGuid != null) && (referencedProjectGuid.Length > 0))
+            else if (!string.IsNullOrEmpty(referencedProjectGuid))
             {
                 newReferenceItem = ConvertProjectToProjectReference(referenceElement, referencesItemGroup, referenceName, ref referencedProjectGuid);
             }
@@ -2600,7 +2582,6 @@ ProjectItemGroupElement referencesItemGroup
         /// <returns></returns>
         private static ProjectItemElement ConvertClassicComReference(XmlElementWithLocation referenceElement, ProjectItemGroupElement referencesItemGroup, string referenceName)
         {
-            ProjectItemElement newReferenceItem;
             // This is a classic COM reference.
 
             // This gets added as a new XMake item of type "COMReference".
@@ -2633,8 +2614,7 @@ private static ProjectItemElement ConvertClassicComReference(XmlElementWithLocat
             referenceElement.RemoveAttribute(VSProjectAttributes.name);
 
             // Add a new item to XMake of type "COMReference".
-            newReferenceItem = referencesItemGroup.AddItem(XMakeProjectStrings.comReference, ProjectCollection.Escape(referenceName));
-            return newReferenceItem;
+            return referencesItemGroup.AddItem(XMakeProjectStrings.comReference, ProjectCollection.Escape(referenceName));
         }
 
         /// <summary>
@@ -2647,9 +2627,7 @@ private static ProjectItemElement ConvertClassicComReference(XmlElementWithLocat
         /// <returns></returns>
         private ProjectItemElement ConvertProjectToProjectReference(XmlElementWithLocation referenceElement, ProjectItemGroupElement referencesItemGroup, string referenceName, ref string referencedProjectGuid)
         {
-            ProjectItemElement newReferenceItem;
             // This is a project-to-project reference.
-
             // This gets added as a new XMake item of type "ProjectReference".
             // The "Include" attribute should be the relative path from the
             // current project to the referenced project file.  For example,
@@ -2688,13 +2666,13 @@ private ProjectItemElement ConvertProjectToProjectReference(XmlElementWithLocati
             {
                 // For VSD Projects, we want to transform all Everett ( .csdproj & .vbdproj ) project 2 project references into
                 // Whidbey ( .csproj & .vbproj ) references.
-                if (0 == String.Compare(Path.GetExtension(pathToReferencedProject),
+                if (String.Equals(Path.GetExtension(pathToReferencedProject),
                                         XMakeProjectStrings.csdprojFileExtension,
                                         StringComparison.OrdinalIgnoreCase))
                 {
                     pathToReferencedProject = Path.ChangeExtension(pathToReferencedProject, XMakeProjectStrings.csprojFileExtension);
                 }
-                else if (0 == String.Compare(Path.GetExtension(pathToReferencedProject),
+                else if (String.Equals(Path.GetExtension(pathToReferencedProject),
                                              XMakeProjectStrings.vbdprojFileExtension,
                                              StringComparison.OrdinalIgnoreCase))
                 {
@@ -2705,9 +2683,8 @@ private ProjectItemElement ConvertProjectToProjectReference(XmlElementWithLocati
             // Add a new item to XMake of type "ProjectReference".  If we were able to find
             // the relative path to the project, use it for the "Include", otherwise just use
             // the project name.
-            string value = (pathToReferencedProject != null) ? pathToReferencedProject : referenceName;
-            newReferenceItem = referencesItemGroup.AddItem(XMakeProjectStrings.projectReference, ProjectCollection.Escape(value));
-            return newReferenceItem;
+            string value = pathToReferencedProject ?? referenceName;
+            return referencesItemGroup.AddItem(XMakeProjectStrings.projectReference, ProjectCollection.Escape(value));
         }
 
         /// <summary>
@@ -2719,7 +2696,6 @@ private ProjectItemElement ConvertProjectToProjectReference(XmlElementWithLocati
         /// <returns></returns>
         private ProjectItemElement ConvertAssemblyReference(XmlElementWithLocation referenceElement, ProjectItemGroupElement referencesItemGroup, string referenceName)
         {
-            ProjectItemElement newReferenceItem;
             // This is a regular .NET assembly reference.
 
             // This gets added as a new XMake item of type "Reference".  The "Include"
@@ -2745,7 +2721,7 @@ private ProjectItemElement ConvertAssemblyReference(XmlElementWithLocation refer
             // Get the "AssemblyName" attribute.  If not found, just use the value from the
             // "Name" attribute.  This is what the project loading code does in VS.
             string assemblyName = referenceElement.GetAttribute(VSProjectAttributes.assemblyName);
-            if ((assemblyName == null) || (assemblyName.Length == 0))
+            if (string.IsNullOrEmpty(assemblyName))
             {
                 assemblyName = referenceName;
             }
@@ -2758,7 +2734,7 @@ private ProjectItemElement ConvertAssemblyReference(XmlElementWithLocation refer
 
             // MyType should only be added when System.Windows.Forms is present. If this
             // reference is seen, then set a flag so we can later add MyType.
-            if (0 == String.Compare("System.Windows.Forms", assemblyName, StringComparison.OrdinalIgnoreCase))
+            if (String.Equals("System.Windows.Forms", assemblyName, StringComparison.OrdinalIgnoreCase))
             {
                 hasWindowsFormsReference = true;
             }
@@ -2776,8 +2752,7 @@ private ProjectItemElement ConvertAssemblyReference(XmlElementWithLocation refer
                 }
             }
 
-            newReferenceItem = referencesItemGroup.AddItem(XMakeProjectStrings.reference, ProjectCollection.Escape(assemblyName));
-            return newReferenceItem;
+            return referencesItemGroup.AddItem(XMakeProjectStrings.reference, ProjectCollection.Escape(assemblyName));
         }
 
         /// <summary>
@@ -2808,7 +2783,7 @@ private void SearchForSolutionFile
                 {
                     // Check that the extension really is ".SLN", because the above call to
                     // GetFiles will also return files such as blah.SLN1 and bloo.SLN2.
-                    if (0 == String.Compare(".sln", slnFile.Extension, StringComparison.OrdinalIgnoreCase))
+                    if (String.Equals(".sln", slnFile.Extension, StringComparison.OrdinalIgnoreCase))
                     {
                         // Parse the .SLN file.
                         SolutionFile solutionParser = new SolutionFile();
@@ -2868,9 +2843,7 @@ internal static string RelativePathTo(string from, string to)
 
             // The URI class returns forward slashes instead of backslashes.  Replace
             // them now, and return the final path.
-            result = result.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
-
-            return result;
+            return result.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
         }
 
         /// <summary>
@@ -2954,8 +2927,7 @@ XmlElementWithLocation      importsElement
             )
         {
             // Make sure this is the <Imports> element.
-            error.VerifyThrow((importsElement != null) &&
-                (importsElement.Name == VSProjectElements.imports),
+            error.VerifyThrow((importsElement?.Name == VSProjectElements.imports),
                 "Expected <Imports> element.");
 
             // Make sure the caller gave us a valid xmakeProject to stuff
@@ -3004,7 +2976,6 @@ XmlElementWithLocation      importsElement
                 {
                     ProjectXmlUtilities.ThrowProjectInvalidChildElement(importsChildNode.Name, importsElement.Name, importsElement.Location);
                 }
-
             }
         }
 
@@ -3020,8 +2991,7 @@ ProjectItemGroupElement importsItemGroup
             )
         {
             // Make sure this is the <Import> element.
-            error.VerifyThrow((importElement != null) &&
-                (importElement.Name == VSProjectElements.import),
+            error.VerifyThrow((importElement?.Name == VSProjectElements.import),
                 "Expected <Import> element.");
 
             // Make sure the caller has already created an ProjectItemGroupElement for us to
@@ -3030,7 +3000,7 @@ ProjectItemGroupElement importsItemGroup
 
             // Get the required "Namespace" attribute.
             string importNamespace = importElement.GetAttribute(VSProjectAttributes.importNamespace);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((importNamespace != null) && (importNamespace.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(importNamespace),
                 importElement.Location, "MissingAttribute", VSProjectAttributes.importNamespace, VSProjectElements.import);
             // Remove the "Namespace" attribute, so it doesn't show up in our loop later.
             importElement.RemoveAttribute(VSProjectAttributes.importNamespace);
@@ -3073,8 +3043,7 @@ XmlElementWithLocation      filesElement
             )
         {
             // Make sure this is the <Files> element.
-            error.VerifyThrow((filesElement != null) &&
-                (filesElement.Name == VSProjectElements.files),
+            error.VerifyThrow((filesElement?.Name == VSProjectElements.files),
                 "Expected <Files> element.");
 
             // Make sure the caller gave us a valid xmakeProject to stuff
@@ -3140,8 +3109,7 @@ XmlElementWithLocation      includeElement
             )
         {
             // Make sure this is the <Include> element.
-            error.VerifyThrow((includeElement != null) &&
-                (includeElement.Name == VSProjectElements.include),
+            error.VerifyThrow((includeElement?.Name == VSProjectElements.include),
                 "Expected <Include> element.");
 
             // Make sure the caller gave us a valid xmakeProject to stuff
@@ -3210,8 +3178,7 @@ ProjectItemGroupElement filesItemGroup
             )
         {
             // Make sure this is the <File> element.
-            error.VerifyThrow((fileElement != null) &&
-                (fileElement.Name == VSProjectElements.file),
+            error.VerifyThrow((fileElement?.Name == VSProjectElements.file),
                 "Expected <File> element.");
 
             // Make sure the caller has already created an ProjectItemGroupElement for us to
@@ -3220,7 +3187,7 @@ ProjectItemGroupElement filesItemGroup
 
             // Get the required "RelPath" attribute.
             string relPath = fileElement.GetAttribute(VSProjectAttributes.relPath);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((relPath != null) && (relPath.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(relPath),
                 fileElement.Location, "MissingAttribute", VSProjectAttributes.relPath, VSProjectElements.file);
             // Remove the "RelPath" attribute, so we don't end up adding it twice.
             fileElement.RemoveAttribute(VSProjectAttributes.relPath);
@@ -3234,7 +3201,7 @@ ProjectItemGroupElement filesItemGroup
             // what the build action is based on the file extension.  This is
             // what the project loading code does in VS.
             string buildAction = fileElement.GetAttribute(VSProjectAttributes.buildAction);
-            if ((buildAction == null) || (buildAction.Length == 0))
+            if (string.IsNullOrEmpty(buildAction))
             {
                 buildAction = VSProjectAttributes.buildActionNone;
             }
@@ -3246,13 +3213,12 @@ ProjectItemGroupElement filesItemGroup
             // Bug Whidbey #248965. If a .resx file is completely empty, do not include a reference
             // to it in the upgraded project file.
             if (!
-                (0 == String.Compare(Path.GetExtension(relPath), ".resx", StringComparison.OrdinalIgnoreCase)
+                (String.Equals(Path.GetExtension(relPath), ".resx", StringComparison.OrdinalIgnoreCase)
                  && IsFilePresentButEmpty(relPath, linkPath))
                )
             {
-
                 // Add the new item to XMake.
-                if ((linkPath == null) || (linkPath.Length == 0))
+                if (string.IsNullOrEmpty(linkPath))
                 {
                     // Normal item.
 
@@ -3316,9 +3282,9 @@ ProjectItemGroupElement filesItemGroup
 
                 // If this is a VSD(devices) project and we're dealing with a content file,
                 // mark it to copy if newer.
-                if ( ( ( ( this.language == VSProjectElements.ECSharp ) ||
-                         ( this.language == VSProjectElements.EVisualBasic ) ) ) &&
-                     ( 0 == String.Compare ( buildAction, XMakeProjectStrings.content, StringComparison.OrdinalIgnoreCase ) ) )
+                if ( ((this.language == VSProjectElements.ECSharp) ||
+                         (this.language == VSProjectElements.EVisualBasic)) &&
+                     ( String.Equals ( buildAction, XMakeProjectStrings.content, StringComparison.OrdinalIgnoreCase ) ) )
                 {
                     newFileItem.AddMetadata ( XMakeProjectStrings.copytooutput,
                                               XMakeProjectStrings.preservenewest );
@@ -3347,7 +3313,7 @@ private bool IsFilePresentButEmpty(string relPath, string linkPath)
             // relpath is the filename
             // linkPath, if it exists, is the relative path from the project, or the absolute full path
             string path;
-            if (linkPath == null || linkPath.Length == 0)
+            if (string.IsNullOrEmpty(linkPath))
             {
                 path = Path.Combine(Path.GetDirectoryName(oldProjectFile), relPath);
             }
@@ -3370,8 +3336,7 @@ private bool IsFilePresentButEmpty(string relPath, string linkPath)
                 return false;
             }
 
-            long length = 0;
-
+            long length;
             try
             {
                 FileInfo fi = new FileInfo(path);
@@ -3385,7 +3350,7 @@ private bool IsFilePresentButEmpty(string relPath, string linkPath)
                 return false;
             }
 
-            return (length == 0);
+            return length == 0;
         }
 
         /// <summary>
@@ -3400,8 +3365,7 @@ ProjectItemGroupElement filesItemGroup
             )
         {
             // Make sure this is the <Folder> element.
-            error.VerifyThrow((folderElement != null) &&
-                (folderElement.Name == VSProjectElements.folder),
+            error.VerifyThrow((folderElement?.Name == VSProjectElements.folder),
                 "Expected <Folder> element.");
 
             // Make sure the caller has already created an ProjectItemGroupElement for us to
@@ -3410,7 +3374,7 @@ ProjectItemGroupElement filesItemGroup
 
             // Get the required "RelPath" attribute.
             string relPath = folderElement.GetAttribute(VSProjectAttributes.relPath);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((relPath != null) && (relPath.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(relPath),
                 folderElement.Location, "MissingAttribute", VSProjectAttributes.relPath, VSProjectElements.folder);
             // Remove the "RelPath" attribute, so we don't end up adding it twice.
             folderElement.RemoveAttribute(VSProjectAttributes.relPath);
@@ -3432,7 +3396,7 @@ ProjectItemGroupElement filesItemGroup
 
             ProjectItemElement newFolderItem;
 
-            if ((webReferences != null) && (0 == String.Compare(webReferences, "true", StringComparison.OrdinalIgnoreCase)))
+            if ((webReferences != null) && (String.Equals(webReferences, "true", StringComparison.OrdinalIgnoreCase)))
             {
                 // This is a web reference folder.
 
@@ -3454,7 +3418,7 @@ ProjectItemGroupElement filesItemGroup
                 newFolderItem = filesItemGroup.AddItem(XMakeProjectStrings.webReferences,
                     ProjectCollection.Escape(relPath));
             }
-            else if ((webReferenceUrl != null) && (webReferenceUrl.Length > 0))
+            else if (!string.IsNullOrEmpty(webReferenceUrl))
             {
                 // This is an actual web reference URL.
 
@@ -3549,8 +3513,7 @@ XmlElementWithLocation      startupServicesElement
             )
         {
             // Make sure this is the <StartupServices> element.
-            error.VerifyThrow((startupServicesElement != null) &&
-                (startupServicesElement.Name == VSProjectElements.startupServices),
+            error.VerifyThrow((startupServicesElement?.Name == VSProjectElements.startupServices),
                 "Expected <StartupServices> element.");
 
             // Make sure the caller gave us a valid xmakeProject to stuff
@@ -3614,8 +3577,7 @@ ProjectItemGroupElement startupServicesItemGroup
             )
         {
             // Make sure this is the <Service> element.
-            error.VerifyThrow((serviceElement != null) &&
-                (serviceElement.Name == VSProjectElements.service),
+            error.VerifyThrow((serviceElement?.Name == VSProjectElements.service),
                 "Expected <Service> element.");
 
             // Make sure the caller has already created an ProjectItemGroupElement for us to
@@ -3624,7 +3586,7 @@ ProjectItemGroupElement startupServicesItemGroup
 
             // Get the required "ID" attribute.
             string id = serviceElement.GetAttribute(VSProjectAttributes.id);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((id != null) && (id.Length > 0), serviceElement.Location,
+            ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(id), serviceElement.Location,
                 "MissingAttribute", VSProjectAttributes.id, VSProjectElements.service);
             // Remove the "ID" attribute, so it doesn't show up in our loop later.
             serviceElement.RemoveAttribute(VSProjectAttributes.id);
@@ -3667,8 +3629,7 @@ XmlElementWithLocation      otherProjectSettingsElement
             )
         {
             // Make sure this is the <OtherProjectSettings> element.
-            error.VerifyThrow((otherProjectSettingsElement != null) &&
-                (otherProjectSettingsElement.Name == VSProjectElements.otherProjectSettings),
+            error.VerifyThrow((otherProjectSettingsElement?.Name == VSProjectElements.otherProjectSettings),
                 "Expected <Settings> element.");
 
             // Make sure the caller gave us a valid globalPropertyGroup to stuff
@@ -3724,8 +3685,7 @@ out bool                    isTriumphProject
             )
         {
             // Make sure this is the <UserProperties> element.
-            error.VerifyThrow((userPropertiesElement != null) &&
-                (userPropertiesElement.Name == VSProjectElements.userProperties),
+            error.VerifyThrow((userPropertiesElement?.Name == VSProjectElements.userProperties),
                 "Expected <UserProperties> element.");
 
             isTriumphProject = false;
@@ -3823,13 +3783,13 @@ out bool                    isTriumphProject
                 if (officeDocumentPathAttribute != null)
                 {
                     string officeDocumentPath = officeDocumentPathAttribute.Value;
-                    if ((officeDocumentPath != null) && (officeDocumentPath.Length > 0))
+                    if (!string.IsNullOrEmpty(officeDocumentPath))
                     {
                         string projectFileDirectory = Path.GetDirectoryName(Path.GetFullPath(this.oldProjectFile));
                         string officeDocumentFullPath = Path.GetFullPath(Path.Combine(projectFileDirectory, officeDocumentPath));
 
                         // If the office document is in the project directory ...
-                        if (0 == String.Compare(projectFileDirectory, Path.GetDirectoryName(officeDocumentFullPath), StringComparison.OrdinalIgnoreCase))
+                        if (String.Equals(projectFileDirectory, Path.GetDirectoryName(officeDocumentFullPath), StringComparison.OrdinalIgnoreCase))
                         {
                             // If the office document actually exists on disk ...
                             if (File.Exists(officeDocumentFullPath))
diff --git a/src/Deprecated/Engine/Caching/BuildResultCacheEntry.cs b/src/Deprecated/Engine/Caching/BuildResultCacheEntry.cs
index 0b942d43fbd..21d4a041643 100644
--- a/src/Deprecated/Engine/Caching/BuildResultCacheEntry.cs
+++ b/src/Deprecated/Engine/Caching/BuildResultCacheEntry.cs
@@ -72,7 +72,7 @@ internal override bool IsEquivalent(CacheEntry other)
                 return false;
             }
 
-            return (this.BuildResult == ((BuildResultCacheEntry)other).BuildResult);
+            return this.BuildResult == ((BuildResultCacheEntry)other).BuildResult;
         }
         #endregion
 
diff --git a/src/Deprecated/Engine/Caching/PropertyCacheEntry.cs b/src/Deprecated/Engine/Caching/PropertyCacheEntry.cs
index 55679673e3d..18c49cb8fbf 100644
--- a/src/Deprecated/Engine/Caching/PropertyCacheEntry.cs
+++ b/src/Deprecated/Engine/Caching/PropertyCacheEntry.cs
@@ -71,7 +71,7 @@ internal override bool IsEquivalent(CacheEntry other)
                 return false;
             }
 
-            return (this.Value == otherEntry.Value);
+            return this.Value == otherEntry.Value;
         }
 
         #region CustomSerializationToStream
diff --git a/src/Deprecated/Engine/Choose/Choose.cs b/src/Deprecated/Engine/Choose/Choose.cs
index 7293f8b23cd..b26f269b905 100644
--- a/src/Deprecated/Engine/Choose/Choose.cs
+++ b/src/Deprecated/Engine/Choose/Choose.cs
@@ -237,10 +237,7 @@ ProcessingPass pass
             else
             {
                 ErrorUtilities.VerifyThrow(pass == ProcessingPass.Pass2, "ProcessingPass must be Pass1 or Pass2.");
-                if (whenLastTaken != null)
-                {
-                    whenLastTaken.Evaluate(parentPropertyBag, ignoreCondition, honorCondition, conditionedPropertiesTable, pass);
-                }
+                whenLastTaken?.Evaluate(parentPropertyBag, ignoreCondition, honorCondition, conditionedPropertiesTable, pass);
             }
         }
 
diff --git a/src/Deprecated/Engine/Choose/GroupingCollection.cs b/src/Deprecated/Engine/Choose/GroupingCollection.cs
index 16d130649e0..5624527929b 100644
--- a/src/Deprecated/Engine/Choose/GroupingCollection.cs
+++ b/src/Deprecated/Engine/Choose/GroupingCollection.cs
@@ -9,7 +9,6 @@
 
 using Microsoft.Build.BuildEngine.Shared;
 
-
 using error = Microsoft.Build.BuildEngine.Shared.ErrorUtilities;
 
 namespace Microsoft.Build.BuildEngine
@@ -65,10 +64,7 @@ internal void ChangePropertyGroupCount(int delta)
             this.propertyGroupCount += delta;
             ErrorUtilities.VerifyThrow(this.propertyGroupCount >= 0, "The property group count should never be negative");
 
-            if (parentGroupingCollection != null)
-            {
-                parentGroupingCollection.ChangePropertyGroupCount(delta);
-            }
+            parentGroupingCollection?.ChangePropertyGroupCount(delta);
         }
 
         /// <summary>
@@ -156,10 +152,7 @@ internal void ChangeItemGroupCount(int delta)
             this.itemGroupCount += delta;
             ErrorUtilities.VerifyThrow(this.itemGroupCount >= 0, "The item group count should never be negative");
 
-            if (parentGroupingCollection != null)
-            {
-                parentGroupingCollection.ChangeItemGroupCount(delta);
-            }
+            parentGroupingCollection?.ChangeItemGroupCount(delta);
         }
 
         /// <summary>
@@ -426,7 +419,6 @@ BuildItemGroup itemGroupToRemove
 
             ChangeItemGroupCount(-1);
             error.VerifyThrow(this.itemGroupCount >= 0, "Too many calls to RemoveItemGroup().");
-
         }
 
         /// <summary>
@@ -570,7 +562,7 @@ internal void RemoveAllPropertyGroupsByCondition(string condition, bool includeI
             ArrayList propertiesToRemove = new ArrayList();
             foreach (BuildPropertyGroup propertyGroup in this.PropertyGroupsAll)
             {
-                if (0 == String.Compare(condition.Trim(), propertyGroup.Condition.Trim(), StringComparison.OrdinalIgnoreCase) 
+                if (String.Equals(condition.Trim(), propertyGroup.Condition.Trim(), StringComparison.OrdinalIgnoreCase) 
                     && (!propertyGroup.IsImported || includeImportedPropertyGroups))
                 {
                     propertiesToRemove.Add(propertyGroup);
@@ -630,7 +622,7 @@ internal void RemoveAllItemGroupsByCondition(string condition)
 
             foreach (BuildItemGroup itemGroup in this.ItemGroupsAll)
             {
-                if (0 == String.Compare(condition.Trim(), itemGroup.Condition.Trim(), StringComparison.OrdinalIgnoreCase) 
+                if (String.Equals(condition.Trim(), itemGroup.Condition.Trim(), StringComparison.OrdinalIgnoreCase) 
                     && !itemGroup.IsImported)
                 {
                     itemsToRemove.Add(itemGroup);
@@ -660,7 +652,7 @@ internal void RemoveItemsByName(string itemName)
                 // ones that are of the requested item type.
                 foreach (BuildItem item in itemGroup)
                 {
-                    if ((0 == String.Compare(item.Name, itemName, StringComparison.OrdinalIgnoreCase)) &&
+                    if ((String.Equals(item.Name, itemName, StringComparison.OrdinalIgnoreCase)) &&
                             !item.IsImported
                         )
                     {
diff --git a/src/Deprecated/Engine/Choose/When.cs b/src/Deprecated/Engine/Choose/When.cs
index 9f1c919092e..de9263754cc 100644
--- a/src/Deprecated/Engine/Choose/When.cs
+++ b/src/Deprecated/Engine/Choose/When.cs
@@ -83,7 +83,6 @@ int nestingDepth
             }
 
             ProcessWhenChildren(whenElement, parentProject, importedFromAnotherProject, nestingDepth);
-
         }
         #endregion
 
diff --git a/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs b/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs
index 7e09548b102..19e9699cb73 100644
--- a/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs
+++ b/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs
@@ -11,7 +11,6 @@
 
 namespace Microsoft.Build.BuildEngine
 {
-
     /// <summary>
     /// A hashtable wrapper that defers copying until the data is written.
     /// </summary>
@@ -46,7 +45,7 @@ internal CopyOnWriteHashtable(StringComparer stringComparer)
         /// </summary>
         internal CopyOnWriteHashtable(int capacity, StringComparer stringComparer)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(stringComparer, "stringComparer");
+            ErrorUtilities.VerifyThrowArgumentNull(stringComparer, nameof(stringComparer));
             this.sharedLock = new object();
 
             if (capacity == 0)
@@ -69,8 +68,8 @@ internal CopyOnWriteHashtable(int capacity, StringComparer stringComparer)
         /// <param name="stringComparer">The string comparer to use.</param>
         internal CopyOnWriteHashtable(IDictionary dictionary, StringComparer stringComparer)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(dictionary, "dictionary");
-            ErrorUtilities.VerifyThrowArgumentNull(stringComparer, "stringComparer");
+            ErrorUtilities.VerifyThrowArgumentNull(dictionary, nameof(dictionary));
+            ErrorUtilities.VerifyThrowArgumentNull(stringComparer, nameof(stringComparer));
 
             this.sharedLock = new object();
             CopyOnWriteHashtable source = dictionary as CopyOnWriteHashtable;
@@ -89,7 +88,6 @@ internal CopyOnWriteHashtable(IDictionary dictionary, StringComparer stringCompa
                     // this means a bug in the engine code somewhere.
                     throw new InternalErrorException("Bug: Changing the case-sensitiveness of a copied hash-table.");
                 }
-
             }
 
             // Can't defer this because we don't control what gets written to the dictionary exogenously.
@@ -193,7 +191,6 @@ public Object this[Object key]
                         }
                     }
                 }
-
             }
         }
 #endregion
diff --git a/src/Deprecated/Engine/Collections/DualQueue.cs b/src/Deprecated/Engine/Collections/DualQueue.cs
index 13afc4e393f..4b2922481f4 100644
--- a/src/Deprecated/Engine/Collections/DualQueue.cs
+++ b/src/Deprecated/Engine/Collections/DualQueue.cs
@@ -79,7 +79,6 @@ internal WaitHandle QueueEmptyEvent
         /// <returns></returns>
         internal int Count
         {
-
             get
             {
                 // Sum both as the number of items is the sum of items in both queues
@@ -131,10 +130,7 @@ internal void Enqueue(T item)
                     queueReadyEvent.Set();
 
                     // reset queue empty
-                    if (queueEmptyEvent != null)
-                    {
-                        queueEmptyEvent.Reset();
-                    }
+                    queueEmptyEvent?.Reset();
                 }
             }
         }
@@ -162,10 +158,7 @@ internal void EnqueueArray(T[] items)
                     queueReadyEvent.Set();
 
                     // reset queue empty
-                    if (queueEmptyEvent != null)
-                    {
-                        queueEmptyEvent.Reset();
-                    }
+                    queueEmptyEvent?.Reset();
                 }
             }
         }
@@ -183,10 +176,7 @@ internal void Clear()
                 // reset queue ready event because the queue is now empty
                 queueReadyEvent.Reset();
                 // raise queue empty event because the queue is now empty
-                if (queueEmptyEvent != null)
-                {
-                    queueEmptyEvent.Set();
-                }
+                queueEmptyEvent?.Set();
             }
         }
 
@@ -235,10 +225,7 @@ private T GetTopItem(bool dequeue)
                         // signal there are no more items to read
                         queueReadyEvent.Reset();
 
-                        if (queueEmptyEvent != null)
-                        {
-                            queueEmptyEvent.Set();
-                        }
+                        queueEmptyEvent?.Set();
                     }
                 }
             }
diff --git a/src/Deprecated/Engine/Conditionals/CharacterUtilities.cs b/src/Deprecated/Engine/Conditionals/CharacterUtilities.cs
index 474e2ebcd86..872e0aa59e0 100644
--- a/src/Deprecated/Engine/Conditionals/CharacterUtilities.cs
+++ b/src/Deprecated/Engine/Conditionals/CharacterUtilities.cs
@@ -10,28 +10,28 @@ internal static class CharacterUtilities
     {
         static internal bool IsNumberStart(char candidate)
         {
-            return (candidate == '+' || candidate == '-' || candidate == '.' || char.IsDigit(candidate));
+            return candidate == '+' || candidate == '-' || candidate == '.' || char.IsDigit(candidate);
         }
 
         static internal bool IsSimpleStringStart(char candidate)
         {
-            return (candidate == '_' || char.IsLetter(candidate));
+            return candidate == '_' || char.IsLetter(candidate);
         }
 
         static internal bool IsSimpleStringChar(char candidate)
         {
-            return (IsSimpleStringStart(candidate) || char.IsDigit(candidate));
+            return IsSimpleStringStart(candidate) || char.IsDigit(candidate);
         }
 
         static internal bool IsHexAlphabetic(char candidate)
         {
-            return (candidate == 'a' || candidate == 'b' || candidate == 'c' || candidate == 'd' || candidate == 'e' || candidate == 'f' ||
-                candidate == 'A' || candidate == 'B' || candidate == 'C' || candidate == 'D' || candidate == 'E' || candidate == 'F');
+            return candidate == 'a' || candidate == 'b' || candidate == 'c' || candidate == 'd' || candidate == 'e' || candidate == 'f' ||
+                candidate == 'A' || candidate == 'B' || candidate == 'C' || candidate == 'D' || candidate == 'E' || candidate == 'F';
         }
 
         static internal bool IsHexDigit(char candidate)
         {
-            return (char.IsDigit(candidate) || IsHexAlphabetic(candidate));
+            return char.IsDigit(candidate) || IsHexAlphabetic(candidate);
         }
     }
 }
diff --git a/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs b/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
index b56ff6595d0..1d284c647e0 100644
--- a/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
@@ -35,7 +35,7 @@ internal FunctionCallExpressionNode(string functionName, ArrayList arguments)
         /// </summary>
         internal override bool BoolEvaluate(ConditionEvaluationState state)
         {
-            if (String.Compare(functionName, "exists", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(functionName, "exists", StringComparison.OrdinalIgnoreCase))
             {
                 // Check we only have one argument
                 VerifyArgumentCount(1, state);
@@ -63,13 +63,12 @@ internal override bool BoolEvaluate(ConditionEvaluationState state)
 
                         return false;
                     }
-
                 }
 
                 // Both Exists functions return false if the value is null or empty
                 return File.Exists(expandedValue) || Directory.Exists(expandedValue);
             }
-            else if (String.Compare(functionName, "HasTrailingSlash", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(functionName, "HasTrailingSlash", StringComparison.OrdinalIgnoreCase))
             {
                 // Check we only have one argument
                 VerifyArgumentCount(1, state);
@@ -82,7 +81,7 @@ internal override bool BoolEvaluate(ConditionEvaluationState state)
                 {
                     char lastCharacter = expandedValue[expandedValue.Length - 1];
                     // Either back or forward slashes satisfy the function: this is useful for URL's
-                    return (lastCharacter == Path.DirectorySeparatorChar || lastCharacter == Path.AltDirectorySeparatorChar);
+                    return lastCharacter == Path.DirectorySeparatorChar || lastCharacter == Path.AltDirectorySeparatorChar;
                 }
                 else
                 {
diff --git a/src/Deprecated/Engine/Conditionals/GenericExpressionNode.cs b/src/Deprecated/Engine/Conditionals/GenericExpressionNode.cs
index f4e8234a0bf..f9348be8d67 100644
--- a/src/Deprecated/Engine/Conditionals/GenericExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/GenericExpressionNode.cs
@@ -76,7 +76,7 @@ internal bool PotentialAndOrConflict()
             // first one returns false
             bool detectOr = DetectOr();
             bool detectAnd = DetectAnd();
-            return (detectOr && detectAnd);
+            return detectOr && detectAnd;
         }
 
         internal abstract bool DetectOr();
diff --git a/src/Deprecated/Engine/Conditionals/NumericComparisonExpressionNode.cs b/src/Deprecated/Engine/Conditionals/NumericComparisonExpressionNode.cs
index 14e1223a51d..ea56f3db77d 100644
--- a/src/Deprecated/Engine/Conditionals/NumericComparisonExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/NumericComparisonExpressionNode.cs
@@ -33,8 +33,8 @@ internal override bool BoolEvaluate(ConditionEvaluationState state)
                 "ComparisonOnNonNumericExpression",
                  state.parsedCondition,
                  /* helpfully display unexpanded token and expanded result in error message */
-                 (LeftChild.CanNumericEvaluate(state) ? RightChild.GetUnexpandedValue(state) : LeftChild.GetUnexpandedValue(state)),
-                 (LeftChild.CanNumericEvaluate(state) ? RightChild.GetExpandedValue(state) : LeftChild.GetExpandedValue(state)));
+                 LeftChild.CanNumericEvaluate(state) ? RightChild.GetUnexpandedValue(state) : LeftChild.GetUnexpandedValue(state),
+                 LeftChild.CanNumericEvaluate(state) ? RightChild.GetExpandedValue(state) : LeftChild.GetExpandedValue(state));
 
             return Compare(LeftChild.NumericEvaluate(state), RightChild.NumericEvaluate(state));
         }
diff --git a/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs b/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs
index a02b7ba708e..df182d5140b 100644
--- a/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs
@@ -72,15 +72,9 @@ internal override string GetUnexpandedValue(ConditionEvaluationState state)
         /// </summary>
         internal override void ResetState()
         {
-            if (leftChild != null)
-            {
-                leftChild.ResetState();
-            }
+            leftChild?.ResetState();
 
-            if (rightChild != null)
-            {
-                rightChild.ResetState();
-            }
+            rightChild?.ResetState();
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Conditionals/Parser.cs b/src/Deprecated/Engine/Conditionals/Parser.cs
index 9b1dec56f0c..685b1e08d1c 100644
--- a/src/Deprecated/Engine/Conditionals/Parser.cs
+++ b/src/Deprecated/Engine/Conditionals/Parser.cs
@@ -125,7 +125,6 @@ private GenericExpressionNode Expr(string expression)
                 node = ExprPrime(expression, node);
             }
 
-
             #region REMOVE_COMPAT_WARNING
             // Check for potential change in behavior
             if (LoggingServices != null && !warnedForExpression &&
@@ -177,7 +176,7 @@ private GenericExpressionNode ExprPrime(string expression, GenericExpressionNode
         private GenericExpressionNode BooleanTerm(string expression)
         {
             GenericExpressionNode node = RelationalExpr(expression);
-            if (null == node)
+            if (node == null)
             {
                 errorPosition = lexer.GetErrorPosition();
                 ProjectErrorUtilities.VerifyThrowInvalidProject(false, this.conditionAttribute, "UnexpectedTokenInCondition", expression, lexer.IsNextString(), errorPosition);
@@ -199,7 +198,7 @@ private GenericExpressionNode BooleanTermPrime(string expression, GenericExpress
             else if (Same(expression, Token.TokenType.And))
             {
                 GenericExpressionNode rhs = RelationalExpr(expression);
-                if (null == rhs)
+                if (rhs == null)
                 {
                     errorPosition = lexer.GetErrorPosition();
                     ProjectErrorUtilities.VerifyThrowInvalidProject(false, this.conditionAttribute, "UnexpectedTokenInCondition", expression, lexer.IsNextString(), errorPosition);
@@ -221,7 +220,7 @@ private GenericExpressionNode RelationalExpr(string expression)
         {
          {
                 GenericExpressionNode lhs = Factor(expression);
-                if (null == lhs)
+                if (lhs == null)
                 {
                     errorPosition = lexer.GetErrorPosition();
                     ProjectErrorUtilities.VerifyThrowInvalidProject(false, this.conditionAttribute, "UnexpectedTokenInCondition", expression, lexer.IsNextString(), errorPosition);
@@ -239,7 +238,6 @@ private GenericExpressionNode RelationalExpr(string expression)
             }
         }
 
-
         private OperatorExpressionNode RelationalOperation(string expression)
         {
             OperatorExpressionNode node = null;
@@ -384,7 +382,7 @@ private bool Same(string expression, Token.TokenType token)
                 if (!lexer.Advance())
                 {
                     errorPosition = lexer.GetErrorPosition();
-                    if (null != lexer.UnexpectedlyFound)
+                    if (lexer.UnexpectedlyFound != null)
                     {
                         ProjectErrorUtilities.VerifyThrowInvalidProject(false, this.conditionAttribute, lexer.GetErrorResource(), expression, errorPosition, lexer.UnexpectedlyFound);
                     }
@@ -398,6 +396,5 @@ private bool Same(string expression, Token.TokenType token)
             else
                 return false;
         }
-
     }
 }
diff --git a/src/Deprecated/Engine/Conditionals/Scanner.cs b/src/Deprecated/Engine/Conditionals/Scanner.cs
index 2c40ffac255..83ae741d5ac 100644
--- a/src/Deprecated/Engine/Conditionals/Scanner.cs
+++ b/src/Deprecated/Engine/Conditionals/Scanner.cs
@@ -148,7 +148,7 @@ internal bool Advance()
             if (errorState)
                 return false;
 
-            if (lookahead != null && lookahead.IsToken(Token.TokenType.EndOfInput))
+            if (lookahead?.IsToken(Token.TokenType.EndOfInput) == true)
                 return true;          
 
             SkipWhiteSpace();
@@ -437,7 +437,6 @@ private bool ParseInternalItemList()
             }
             if (parsePoint >= expression.Length)
             {
-                
                 errorPosition = start + 1;
                 if (fInReplacement)
                 {
@@ -554,11 +553,11 @@ private bool ParseRemaining()
         private bool ParseSimpleStringOrFunction( int start )
         {
             SkipSimpleStringChars();
-            if (0 == string.Compare(expression.Substring(start, parsePoint - start), "and", StringComparison.OrdinalIgnoreCase))
+            if (string.Equals(expression.Substring(start, parsePoint - start), "and", StringComparison.OrdinalIgnoreCase))
             {
                 lookahead = new Token(Token.TokenType.And, expression.Substring(start, parsePoint - start));
             }
-            else if (0 == string.Compare(expression.Substring(start, parsePoint - start), "or", StringComparison.OrdinalIgnoreCase))
+            else if (string.Equals(expression.Substring(start, parsePoint - start), "or", StringComparison.OrdinalIgnoreCase))
             {
                 lookahead = new Token(Token.TokenType.Or, expression.Substring(start, parsePoint - start));
             }
diff --git a/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs b/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs
index a66656634ac..14542e15990 100644
--- a/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs
@@ -83,5 +83,4 @@ internal override void ResetState()
             cachedExpandedValue = null;
         }
     }
-
 }
diff --git a/src/Deprecated/Engine/Engine/BatchingEngine.cs b/src/Deprecated/Engine/Engine/BatchingEngine.cs
index 62d82b0be79..e904d7978df 100644
--- a/src/Deprecated/Engine/Engine/BatchingEngine.cs
+++ b/src/Deprecated/Engine/Engine/BatchingEngine.cs
@@ -123,7 +123,7 @@ string implicitBatchableItemType
             Dictionary<string, MetadataReference> consumedMetadataReferences = pair.Metadata;
 
             ArrayList buckets = null;
-            if (consumedMetadataReferences != null && consumedMetadataReferences.Count > 0)
+            if (consumedMetadataReferences?.Count > 0)
             {
                 // Add any item types that we were explicitly told to assume.
                 if (implicitBatchableItemType != null)
@@ -337,7 +337,7 @@ Dictionary<string, MetadataReference> consumedMetadataReferences
 
                         // If we didn't find a bucket that matches this item, create a new one, adding
                         // this item to the bucket.
-                        if (null == matchingBucket)
+                        if (matchingBucket == null)
                         {
                             matchingBucket = new ItemBucket(itemListsToBeBatched.Keys, itemMetadataValues, lookup, buckets.Count);
 
@@ -392,7 +392,7 @@ Dictionary<string, MetadataReference> consumedMetadataReferences
 
                 if  (
                         (metadataItemName != null) &&
-                        (0 != String.Compare(item.Name, metadataItemName, StringComparison.OrdinalIgnoreCase))
+                        (!String.Equals(item.Name, metadataItemName, StringComparison.OrdinalIgnoreCase))
                     )
                 {
                     itemMetadataValues[metadataQualifiedName] = String.Empty;
@@ -414,7 +414,6 @@ Dictionary<string, MetadataReference> consumedMetadataReferences
             return itemMetadataValues;
         }
 
-
         #endregion
     }
 }
diff --git a/src/Deprecated/Engine/Engine/BuildRequest.cs b/src/Deprecated/Engine/Engine/BuildRequest.cs
index 2ba220509cc..c91a2a92fff 100644
--- a/src/Deprecated/Engine/Engine/BuildRequest.cs
+++ b/src/Deprecated/Engine/Engine/BuildRequest.cs
@@ -364,7 +364,7 @@ internal bool IsGeneratedRequest
         {
             get
             {
-                return (handleId != EngineCallback.invalidEngineHandle);
+                return handleId != EngineCallback.invalidEngineHandle;
             }
         }
 
diff --git a/src/Deprecated/Engine/Engine/BuildResult.cs b/src/Deprecated/Engine/Engine/BuildResult.cs
index 8390e845add..2e09508f9b9 100644
--- a/src/Deprecated/Engine/Engine/BuildResult.cs
+++ b/src/Deprecated/Engine/Engine/BuildResult.cs
@@ -126,7 +126,7 @@ internal bool EvaluationResult
         {
             get
             {
-                return ((this.flags & 1) == 0 ? false : true) ;
+                return (this.flags & 1) == 0 ? false : true;
             }
         }
 
@@ -166,7 +166,7 @@ internal bool UseResultCache
         {
             get
             {
-                return ((this.flags & 2) == 0 ? false : true);
+                return (this.flags & 2) == 0 ? false : true;
             }
         }
 
@@ -232,7 +232,7 @@ internal int TaskTime
         internal void ConvertToTaskItems()
         {
             // If outputsByTarget was null then we dont have to re-create anything as nothing was passed over
-            if (null != outputsByTarget)
+            if (outputsByTarget != null)
             {
                 string[] keys = new string[outputsByTarget.Count];
                 outputsByTarget.Keys.CopyTo(keys, 0);
@@ -343,7 +343,6 @@ internal void WriteToStream(BinaryWriter writer)
             #endregion
         }
 
-
         internal static BuildResult CreateFromStream(BinaryReader reader)
         {
             BuildResult buildResult = new BuildResult();
diff --git a/src/Deprecated/Engine/Engine/BuildTask.cs b/src/Deprecated/Engine/Engine/BuildTask.cs
index d1f7ef13095..4d430453a5e 100644
--- a/src/Deprecated/Engine/Engine/BuildTask.cs
+++ b/src/Deprecated/Engine/Engine/BuildTask.cs
@@ -55,7 +55,7 @@ public class BuildTask
         #region Constructors
         /// <summary>
         /// This constructor initializes a persisted task from an existing task
-        /// element which exists either in the main project file or one of the 
+        /// element which exists either in the main project file or one of the
         /// imported files.
         /// </summary>
         /// <param name="taskElement"></param>
@@ -96,7 +96,7 @@ bool            importedFromAnotherProject
 
                     // this only makes sense in the context of the new OM, 
                     // so just ignore it.  
-                    case XMakeAttributes.msbuildRuntime: 
+                    case XMakeAttributes.msbuildRuntime:
                         // do nothing
                         break;
 
@@ -112,8 +112,8 @@ bool            importedFromAnotherProject
         }
 
         /// <summary>
-        /// Default constructor.  This is not allowed, because it leaves the 
-        /// BuildTask in a bad state. But we have to have it, otherwise FXCop 
+        /// Default constructor.  This is not allowed, because it leaves the
+        /// BuildTask in a bad state. But we have to have it, otherwise FXCop
         /// complains.
         /// </summary>
         /// <owner>rgoel</owner>
@@ -142,7 +142,7 @@ internal XmlElement TaskXmlElement
         }
 
         /// <summary>
-        /// Accessor for the task's "name" element.  
+        /// Accessor for the task's "name" element.
         /// </summary>
         /// <owner>RGoel</owner>
         public string Name
@@ -202,7 +202,7 @@ public bool ContinueOnError
                 {
                     return true;
                 }
-                else 
+                else
                 {
                     return false;
                 }
@@ -237,7 +237,7 @@ public bool ContinueOnError
         }
 
         /// <summary>
-        /// System.Type object corresponding to the task class that implements 
+        /// System.Type object corresponding to the task class that implements
         /// the functionality that runs this task object.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -258,7 +258,7 @@ public Type Type
                                                    parentProject.ProjectBuildEventContext.TaskId
                                                );
 
-                int handleId = parentEngine.EngineCallback.CreateTaskContext(parentProject, ParentTarget, null, taskElement, 
+                int handleId = parentEngine.EngineCallback.CreateTaskContext(parentProject, ParentTarget, null, taskElement,
                                                                                 EngineCallback.inProcNode, taskContext);
                 EngineLoggingServices loggingServices = parentEngine.LoggingServices;
                 TaskExecutionModule taskExecutionModule = parentEngine.NodeManager.TaskExecutionModule;
@@ -313,12 +313,12 @@ internal Target ParentTarget
         #region Methods
 
         /// <summary>
-        /// This retrieves the list of all parameter names from the element 
-        /// node of this task. Note that it excludes anything that a specific 
-        /// property is exposed for or that isn't valid here (Name, Condition, 
+        /// This retrieves the list of all parameter names from the element
+        /// node of this task. Note that it excludes anything that a specific
+        /// property is exposed for or that isn't valid here (Name, Condition,
         /// ContinueOnError).
-        /// 
-        /// Note that if there are none, it returns string[0], rather than null, 
+        ///
+        /// Note that if there are none, it returns string[0], rather than null,
         /// as it makes writing foreach statements over the return value so
         /// much simpler.
         /// </summary>
@@ -336,7 +336,7 @@ public string[] GetParameterNames()
             {
                 string attributeValue = attrib.Name;
 
-                if (!XMakeAttributes.IsSpecialTaskAttribute(attributeValue)) 
+                if (!XMakeAttributes.IsSpecialTaskAttribute(attributeValue))
                 {
                     list.Add(attributeValue);
                 }
@@ -349,7 +349,7 @@ public string[] GetParameterNames()
         /// This retrieves an arbitrary attribute from the task element.  These
         /// are attributes that the project author has placed on the task element
         /// that have no meaning to MSBuild other than that they get passed to the
-        /// task itself as arguments.  
+        /// task itself as arguments.
         /// </summary>
         /// <owner>RGoel</owner>
         public string GetParameterValue
@@ -365,20 +365,16 @@ string attributeName
             error.VerifyThrowInvalidOperation(this.taskElement != null,
                 "CannotUseParameters");
 
-            string attributeValue; 
-
             // If this is a persisted Task, grab the attribute directly from the
             // task element.
-            attributeValue = taskElement.GetAttribute(attributeName);
-
-            return (attributeValue == null) ? String.Empty : attributeValue;
+            return taskElement.GetAttribute(attributeName) ?? string.Empty;
         }
 
         /// <summary>
         /// This sets an arbitrary attribute on the task element.  These
         /// are attributes that the project author has placed on the task element
         /// that get passed in to the task.
-        /// 
+        ///
         /// This optionally escapes the parameter value so it will be treated as a literal.
         /// </summary>
         /// <param name="parameterName"></param>
@@ -509,7 +505,7 @@ public bool Execute
 
         /// <summary>
         /// Indicates that something has changed within the task element, so the project
-        /// needs to be saved and re-evaluated at next build.  Send the "dirtiness" 
+        /// needs to be saved and re-evaluated at next build.  Send the "dirtiness"
         /// notification up the chain.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -517,11 +513,11 @@ private void MarkTaskAsDirty
             (
             )
         {
-            if (this.ParentTarget != null)
-            {
+               
+            
                 // This is a change to the contents of the target.
-                this.ParentTarget.MarkTargetAsDirty();
-            }
+                this.ParentTarget?.MarkTargetAsDirty();
+            
         }
 
         #endregion
diff --git a/src/Deprecated/Engine/Engine/CacheManager.cs b/src/Deprecated/Engine/Engine/CacheManager.cs
index 2263370a656..894d4a82ae8 100644
--- a/src/Deprecated/Engine/Engine/CacheManager.cs
+++ b/src/Deprecated/Engine/Engine/CacheManager.cs
@@ -75,7 +75,7 @@ private CacheScope GetCacheScopeIfExists(string scopeName, BuildPropertyGroup sc
                     {
                         for (int i = 0; i < scopesByName.Count; i++)
                         {
-                            if (scopesByName[i].ScopeProperties.IsEquivalent(scopeProperties) && (String.Compare(scopeToolsVersion, scopesByName[i].ScopeToolsVersion, StringComparison.OrdinalIgnoreCase) == 0))
+                            if (scopesByName[i].ScopeProperties.IsEquivalent(scopeProperties) && (String.Equals(scopeToolsVersion, scopesByName[i].ScopeToolsVersion, StringComparison.OrdinalIgnoreCase)))
                             {
                                 cacheScope = scopesByName[i];
                                 break;
@@ -216,7 +216,7 @@ internal void ClearCacheScope(string projectName, BuildPropertyGroup buildProper
                     {
                         for (int i = 0; i < scopesByName.Count; i++)
                         {
-                            if (scopesByName[i].ScopeProperties.IsEquivalent(buildPropertyGroup) && (String.Compare(toolsVersion, scopesByName[i].ScopeToolsVersion, StringComparison.OrdinalIgnoreCase) == 0))
+                            if (scopesByName[i].ScopeProperties.IsEquivalent(buildPropertyGroup) && (String.Equals(toolsVersion, scopesByName[i].ScopeToolsVersion, StringComparison.OrdinalIgnoreCase)))
                             {
                                 scopesByName.RemoveAt(i);
                                 break;
diff --git a/src/Deprecated/Engine/Engine/CacheScope.cs b/src/Deprecated/Engine/Engine/CacheScope.cs
index 9946ae323d4..cdf83042559 100644
--- a/src/Deprecated/Engine/Engine/CacheScope.cs
+++ b/src/Deprecated/Engine/Engine/CacheScope.cs
@@ -246,14 +246,14 @@ internal void AddCacheEntryForBuildResults(BuildResult buildResult)
                     // If the project file is malformed the build may fail without initializing the initialtargets or
                     // the default targests fields. The retrieval code expects non-null values
                     // so it is necessary to replace null with empty string
-                    ErrorUtilities.VerifyThrow(buildResult.EvaluationResult == false || buildResult.InitialTargets != null 
-                                               && buildResult.DefaultTargets != null , 
+                    ErrorUtilities.VerifyThrow(!buildResult.EvaluationResult || (buildResult.InitialTargets != null 
+                                               && buildResult.DefaultTargets != null), 
                                                "Expect initial targets to be non-null for successful builds");
-                    string defaultTargets = buildResult.DefaultTargets == null ? String.Empty : buildResult.DefaultTargets;
+                    string defaultTargets = buildResult.DefaultTargets ?? String.Empty;
                     PropertyCacheEntry defaultTargetsCacheEntry = new PropertyCacheEntry(Constants.defaultTargetCacheName, defaultTargets);
                     AddCacheEntryInternal(defaultTargetsCacheEntry);
 
-                    string initialTargets = buildResult.InitialTargets == null ? String.Empty : buildResult.InitialTargets;
+                    string initialTargets = buildResult.InitialTargets ?? String.Empty;
                     PropertyCacheEntry initialTargetsCacheEntry = new PropertyCacheEntry(Constants.initialTargetCacheName, initialTargets );
                     AddCacheEntryInternal(initialTargetsCacheEntry);
                 }
@@ -299,7 +299,7 @@ internal void AddCacheEntryForBuildResults(BuildResult buildResult)
                         }
 
                         BuildResultCacheEntry cacheEntry = new BuildResultCacheEntry((string)entry.Key, targetOutputs,
-                            (buildState == Target.BuildState.CompletedSuccessfully));
+                            buildState == Target.BuildState.CompletedSuccessfully);
 
                         if (Engine.debugMode)
                         {
diff --git a/src/Deprecated/Engine/Engine/Engine.cs b/src/Deprecated/Engine/Engine/Engine.cs
index e9b5b85cf45..7b90112b51b 100644
--- a/src/Deprecated/Engine/Engine/Engine.cs
+++ b/src/Deprecated/Engine/Engine/Engine.cs
@@ -95,7 +95,6 @@ public enum ToolsetDefinitionLocations
     [Obsolete("This class has been deprecated. Please use Microsoft.Build.Evaluation.ProjectCollection from the Microsoft.Build assembly instead.")]
     public class Engine
     {
-
         #region Member Data
 
         // For those folks who want to share a single Engine object across many projects
@@ -118,7 +117,7 @@ public class Engine
 
         // The name of the current default toolsVersion. Starts with Constants.defaultVersion
         private string defaultToolsVersion;
-        
+
         // The node Id which the engine is running on
         private int nodeId;
 
@@ -168,7 +167,7 @@ public class Engine
         private DualQueue<BuildRequest> buildRequests;
 
         private ManualResetEvent engineAbortEvent = new ManualResetEvent(false);
-        
+
         // a cached version of the engineAbortEvent so we don't have to wait on it to determine the value.
         // If we do have to wait for something to happen we still need the event though.
         private volatile bool engineAbortCachedValue = false;
@@ -203,7 +202,7 @@ public class Engine
 
         // this seed is used to generate unique logger ids for each distributed logger
         private int lastUsedLoggerId;
-        
+
         // this boolean is true if central logging is enabled 
         private bool enabledCentralLogging;
 
@@ -267,7 +266,7 @@ public class Engine
         /// <summary>
         /// Default constructor that reads toolset information from both the registry
         /// and configuration file.
-        /// The need for parameterless constructor is dictated by COM interop. 
+        /// The need for parameterless constructor is dictated by COM interop.
         /// </summary>
         public Engine()
             : this(1 /* cpu */, false /* not child node */, 0 /* default NodeId */, null/*No msbuild.exe path*/, null, ToolsetDefinitionLocations.ConfigurationFile | ToolsetDefinitionLocations.Registry)
@@ -298,7 +297,7 @@ public Engine(BuildPropertyGroup globalProperties)
         }
 
         /// <summary>
-        /// Constructor to specify whether toolsets should be initialized from the msbuild configuration file and from the registry 
+        /// Constructor to specify whether toolsets should be initialized from the msbuild configuration file and from the registry
         /// </summary>
         public Engine(ToolsetDefinitionLocations locations)
             : this(null, locations)
@@ -306,7 +305,7 @@ public Engine(ToolsetDefinitionLocations locations)
         }
 
         /// <summary>
-        /// Constructor to specify the global properties the engine should inherit and 
+        /// Constructor to specify the global properties the engine should inherit and
         /// the locations the engine should inspect for toolset definitions.
         /// </summary>
         public Engine(BuildPropertyGroup globalProperties, ToolsetDefinitionLocations locations)
@@ -331,7 +330,7 @@ internal Engine(BuildPropertyGroup globalProperties, ToolsetDefinitionLocations
             // Override the startup directory with the one we were passed
             ErrorUtilities.VerifyThrow(startupDirectory != null, "Need startup directory");
             this.startupDirectory = startupDirectory;
-            
+
             forwardPropertiesFromChild = Environment.GetEnvironmentVariable("MSBuildForwardPropertiesFromChild");
             // Get a list of properties which should be serialized
             if (!String.IsNullOrEmpty(forwardPropertiesFromChild))
@@ -341,16 +340,16 @@ internal Engine(BuildPropertyGroup globalProperties, ToolsetDefinitionLocations
         }
 
         /// <summary>
-        /// Constructor to init all data except for BinPath which is initialized separately because 
+        /// Constructor to init all data except for BinPath which is initialized separately because
         /// a parameterless constructor is needed for COM interop
         /// </summary>
         internal Engine
         (
-            int numberOfCpus, 
-            bool isChildNode, 
-            int parentNodeId, 
+            int numberOfCpus,
+            bool isChildNode,
+            int parentNodeId,
             string localNodeProviderParameters,
-            BuildPropertyGroup globalProperties, 
+            BuildPropertyGroup globalProperties,
             ToolsetDefinitionLocations locations
         )
         {
@@ -358,7 +357,7 @@ ToolsetDefinitionLocations locations
             // is null, because it is a value type
 
             this.startupDirectory = Environment.CurrentDirectory;
-            this.engineGlobalProperties = globalProperties == null ? new BuildPropertyGroup() : globalProperties;
+            this.engineGlobalProperties = globalProperties ?? new BuildPropertyGroup();
             this.environmentProperties = new BuildPropertyGroup();
             this.toolsetStateMap = new Dictionary<string, ToolsetState>(StringComparer.OrdinalIgnoreCase);
             this.toolsets = new ToolsetCollection(this);
@@ -453,8 +452,7 @@ private void InitializeLocalNodeProvider(ToolsetDefinitionLocations locations)
             {
                 LocalNodeProvider localNodeProvider = new LocalNodeProvider();
 
-
-                string configuration = string.Empty;
+                string configuration;
                 if (localNodeProviderParameters.EndsWith(";", StringComparison.OrdinalIgnoreCase))
                 {
                     configuration = localNodeProviderParameters + "maxcpucount=" + Convert.ToString(numberOfCpus, CultureInfo.InvariantCulture);
@@ -480,7 +478,7 @@ private void InitializeLocalNodeProvider(ToolsetDefinitionLocations locations)
         /// </summary>
         /// <remarks>
         /// BinPath is an obsolete concept. We retain it for now for all the hosts that use the BinPath
-        /// property, or the Engine(binPath) constructor, but internally it is just the tools path 
+        /// property, or the Engine(binPath) constructor, but internally it is just the tools path
         /// of the default tools version.
         /// </remarks>
         /// <value>The MSBuild path.</value>
@@ -500,7 +498,6 @@ public string BinPath
             }
         }
 
-
         /// <summary>
         /// Is this engine in the process of building?
         /// </summary>
@@ -511,7 +508,7 @@ public bool IsBuilding
                 return numberOfProjectsInProgress > 0;
             }
         }
-        
+
         /// <summary>
         /// The node Id the current engine instance is running on
         /// </summary>
@@ -584,8 +581,7 @@ public static Version Version
             {
                 if (engineVersion == null)
                 {
-                    string msbuildPath = null;
-
+                    string msbuildPath;
                     try
                     {
                         // Get the file version from the currently executing assembly.
@@ -641,7 +637,7 @@ internal BuildPropertyGroup EnvironmentProperties
                 return this.environmentProperties;
             }
         }
-        
+
         /// <summary>
         ///  Get a new TaskId
         /// (NOT Thread safe)
@@ -721,7 +717,7 @@ internal Hashtable ImportedProjectsCache
         /// Returns the table of projects loaded by the host.
         /// </summary>
         /// <owner>RGoel</owner>
-        /// <remarks>Marked "internal" for unit tests only.  To maintain encapsulation, please try not to 
+        /// <remarks>Marked "internal" for unit tests only.  To maintain encapsulation, please try not to
         /// use this accessor in real msbuild code, except from within this class.</remarks>
         internal Hashtable ProjectsLoadedByHost
         {
@@ -844,7 +840,6 @@ internal EngineCallback EngineCallback
             }
         }
 
-
         internal bool EnabledCentralLogging
         {
             get
@@ -876,7 +871,7 @@ internal ManualResetEvent FlushRequestEvent
         }
 
         /// <summary>
-        /// The current directory at the time the Engine was constructed -- 
+        /// The current directory at the time the Engine was constructed --
         /// if msbuild.exe is hosting, this is the current directory when
         /// msbuild.exe was started
         /// </summary>
@@ -884,7 +879,7 @@ internal string StartupDirectory
         {
             get { return startupDirectory; }
         }
-        
+
         #endregion
 
         #region Methods
@@ -902,7 +897,6 @@ internal ITaskRegistry GetTaskRegistry(BuildEventContext buildEventContext, stri
             return toolsetState.GetTaskRegistry(buildEventContext);
         }
 
-
         /// <summary>
         /// Adds a new toolset to the engine. Any pre-existing toolset with the same
         /// tools version is replaced with the provided toolset.
@@ -910,7 +904,7 @@ internal ITaskRegistry GetTaskRegistry(BuildEventContext buildEventContext, stri
         /// <param name="toolset">the Toolset</param>
         internal void AddToolset(Toolset toolset)
         {
-            error.VerifyThrowArgumentNull(toolset, "toolset");
+            error.VerifyThrowArgumentNull(toolset, nameof(toolset));
 
             if (toolsetStateMap.ContainsKey(toolset.ToolsVersion))
             {
@@ -940,7 +934,7 @@ internal void UpdateToolsPath(string toolsVersion, string toolsPath)
             {
                 buildProperties = toolsetStateMap[toolsVersion].BuildProperties.Clone(true /* deep clone */);
             }
-            
+
             toolsets.Add(new Toolset(toolsVersion, toolsPath, buildProperties));
         }
 
@@ -960,7 +954,7 @@ private void DirtyProjectsUsingToolsVersion(string toolsVersion)
         }
 
         /// <summary>
-        /// Populate ToolsetStateMap with a dictionary of (toolset version, ToolsetState) 
+        /// Populate ToolsetStateMap with a dictionary of (toolset version, ToolsetState)
         /// using information from the registry and config file, if any.
         /// </summary>
         /// <remarks>Internal for unit testing purposes only</remarks>
@@ -1007,13 +1001,12 @@ internal void PopulateToolsetStateMap(ToolsetDefinitionLocations locations)
                 // Now update the default tools version to 2.0
                 DefaultToolsVersion = Constants.defaultToolsVersion;
             }
-
         }
 
         /// <summary>
         /// The default tools version of this Engine. Projects use this tools version if they
         /// aren't otherwise told what tools version to use.
-        /// This value is gotten from the .exe.config file, or else in the registry, 
+        /// This value is gotten from the .exe.config file, or else in the registry,
         /// or if neither specify a default tools version then it is hard-coded to the tools version "2.0".
         /// </summary>
         public string DefaultToolsVersion
@@ -1048,7 +1041,7 @@ public string DefaultToolsVersion
         /// <exception cref="InternalLoggerException">Logger threw arbitrary exception</exception>
         public void RegisterLogger(ILogger logger)
         {
-            error.VerifyThrowArgumentNull(logger, "logger");
+            error.VerifyThrowArgumentNull(logger, nameof(logger));
 
             // Since we are registering a central logger - need to make sure central logging is enabled for all nodes
             if (!enabledCentralLogging)
@@ -1109,7 +1102,7 @@ private void RegisterLoggerInternal(ILogger logger, EventSource sourceForLogger,
         }
 
         /// <summary>
-        /// Called to register distributed loggers with the engine. 
+        /// Called to register distributed loggers with the engine.
         /// This method is not thread safe. All loggers should registered prior to
         /// starting the build in order to guarantee uniform behavior
         /// </summary>
@@ -1117,7 +1110,7 @@ private void RegisterLoggerInternal(ILogger logger, EventSource sourceForLogger,
         /// <exception cref="InternalLoggerException">Logger threw arbitrary exception</exception>
         public void RegisterDistributedLogger(ILogger centralLogger, LoggerDescription forwardingLogger)
         {
-            error.VerifyThrowArgumentNull(forwardingLogger, "forwardingLogger");
+            error.VerifyThrowArgumentNull(forwardingLogger, nameof(forwardingLogger));
             if (centralLogger == null)
             {
                 centralLogger = new NullCentralLogger();
@@ -1210,7 +1203,7 @@ internal void EndEatingLoggingEvents()
         /// <exception cref="InternalLoggerException">Logger threw arbitrary exception</exception>
         public void UnregisterAllLoggers()
         {
-            if (forwardingLoggers != null && forwardingLoggers.Count > 0)
+            if (forwardingLoggers?.Count > 0)
             {
                 // Disconnect forwarding loggers from the event source
                 ((EngineLoggingServicesInProc)primaryLoggingServices).UnregisterEventSource
@@ -1257,7 +1250,7 @@ internal void UnregisterLoggersInternal(ArrayList loggersToUnregister)
 
         /// <summary>
         /// Log BuildFinished event (if there is no unhandled exception) and clear
-        /// the projects loaded by host from the 
+        /// the projects loaded by host from the
         /// </summary>
         internal void EndingEngineExecution(bool buildResult, bool exitedDueToError)
         {
@@ -1269,7 +1262,7 @@ internal void EndingEngineExecution(bool buildResult, bool exitedDueToError)
                 // parent node, so post the event directly to the forwarding loggers.
                 if (Router.ChildMode)
                 {
-                    if (loggers != null && loggers.Count > 0)
+                    if (loggers?.Count > 0)
                     {
                         // Flush all the events currently in the queue
                         LoggingServices.ProcessPostedLoggingEvents();
@@ -1332,7 +1325,6 @@ public void Shutdown()
             UnregisterAllLoggers();
         }
 
-
         /// <summary>
         /// Creates a new empty Project object that is associated with this engine. All projects must be associated with an
         /// engine, because they need loggers, global properties, reserved properties, etc.
@@ -1358,7 +1350,7 @@ public Project GetLoadedProject
             string projectFullFileName
             )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFullFileName, "projectFullFileName");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFullFileName, nameof(projectFullFileName));
             return (Project)this.projectsLoadedByHost[projectFullFileName];
         }
 
@@ -1379,7 +1371,7 @@ public void UnloadProject
             Project project
             )
         {
-            error.VerifyThrowArgumentNull(project, "project");
+            error.VerifyThrowArgumentNull(project, nameof(project));
 
             ErrorUtilities.VerifyThrow(project.IsLoadedByHost, "How did the caller get a reference to this Project object if it's not marked as loaded?");
             // Make sure this project object is associated with this engine object.
@@ -1428,8 +1420,8 @@ string newFullFileName
         {
             ErrorUtilities.VerifyThrow(project.IsLoadedByHost, "This method can only be called for projects loaded by the host.");
 
-            oldFullFileName = (oldFullFileName == null) ? String.Empty : oldFullFileName;
-            newFullFileName = (newFullFileName == null) ? String.Empty : newFullFileName;
+            oldFullFileName = oldFullFileName ?? String.Empty;
+            newFullFileName = newFullFileName ?? String.Empty;
             if (oldFullFileName == newFullFileName)
             {
                 // Nothing to do, since this really isn't a rename.
@@ -1558,7 +1550,7 @@ string targetName
         {
             return BuildProject(project, (targetName == null) ? null : new string[] { targetName }, null, BuildSettings.None);
         }
-        
+
         /// <summary>
         /// Builds a list of targets in an already-loaded project.
         /// </summary>
@@ -1637,15 +1629,15 @@ internal BuildResult EngineBuildLoop(BuildRequest terminatingBuildRequest)
             int flushTimeout = EngineLoggingServices.flushTimeoutInMS; // Timeout with which the log is flushed
             bool forceFlush = false;
             while (
-                    continueExecution && 
-                    (terminatingBuildRequest == null || terminatingBuildRequest.BuildCompleted == false)
+                    continueExecution &&
+                    (terminatingBuildRequest == null || !terminatingBuildRequest.BuildCompleted)
                   )
             {
-                int eventType = 0;
+                int eventType;
 
                 // See if we have anything to do without waiting on the handles which is expensive 
                 // for kernel mode objects.
-                if (this.engineAbortCachedValue == true)
+                if (this.engineAbortCachedValue)
                 {
                     eventType = 0;
                 }
@@ -1676,7 +1668,7 @@ internal BuildResult EngineBuildLoop(BuildRequest terminatingBuildRequest)
                     // Decrement time remaining until deadlock check
                     if (loopTimeoutRemaining != Timeout.Infinite)
                     {
-                        loopTimeoutRemaining = flushTimeout > loopTimeoutRemaining ? 
+                        loopTimeoutRemaining = flushTimeout > loopTimeoutRemaining ?
                                                   0 : loopTimeoutRemaining - flushTimeout;
                     }
                     // Always force a flush on a time
@@ -1821,7 +1813,7 @@ internal BuildResult EngineBuildLoop(BuildRequest terminatingBuildRequest)
                 // TEM will be null if we're shutting down
                 if (NodeManager.TaskExecutionModule != null)
                 {
-                    if (NodeManager.TaskExecutionModule.UseBreadthFirstTraversal == false /* using depth first traversal */ &&
+                    if (!NodeManager.TaskExecutionModule.UseBreadthFirstTraversal /* using depth first traversal */ &&
                         buildRequests.Count == 0 && taskOutputUpdates.Count == 0 &&
                         NodeManager.TaskExecutionModule.IsIdle
                         )
@@ -1859,7 +1851,7 @@ internal BuildResult EngineBuildLoop(BuildRequest terminatingBuildRequest)
         /// </summary>
         private void BuildProjectInternal
         (
-            BuildRequest buildRequest, 
+            BuildRequest buildRequest,
             ProjectBuildState buildContext,
             TaskExecutionContext taskExecutionContext,
             bool initialCall
@@ -1890,7 +1882,7 @@ bool initialCall
                 }
 
                 try
-                { 
+                {
                     if (initialCall)
                     {
                         BuildProjectInternalInitial(buildRequest, project);
@@ -1950,7 +1942,7 @@ bool initialCall
                 // Flush out all the logging messages, which may have been posted outside target execution
                 primaryLoggingServices.ProcessPostedLoggingEvents();
 
-                if (buildRequest != null && buildRequest.BuildCompleted || exitedDueToError)
+                if (buildRequest?.BuildCompleted == true || exitedDueToError)
                 {
 #if (!STANDALONEBUILD)
                     CodeMarkers.Instance.CodeMarker(CodeMarkerEvent.perfMSBuildEngineBuildProjectEnd);
@@ -1982,12 +1974,12 @@ Decrementing from 0 projects in progress causes an exception.
                 buildRequest.StartTime = DateTime.Now.Ticks;
                 buildRequest.ProcessingStartTime = buildRequest.StartTime;
             }
-            
+
             if (startRootProjectBuild)
             {
                 StartRootProjectBuild(buildRequest, project);
             }
-            
+
             project.BuildInternal(buildRequest);
         }
 
@@ -2025,7 +2017,6 @@ private void BuildProjectInternalContinue(BuildRequest buildRequest, ProjectBuil
             project.ContinueBuild(buildContext, taskExecutionContext);
         }
 
-
         private void IncrementProjectsInProgress()
         {
             Interlocked.Increment(ref this.numberOfProjectsInProgress);
@@ -2038,8 +2029,8 @@ private void FinishBuildProjectInProgress(BuildRequest buildRequest, ProjectBuil
                 buildRequest.ProcessingTotalTime += DateTime.Now.Ticks - buildRequest.ProcessingStartTime;
             }
 
-            if (buildRequest != null && buildRequest.BuildCompleted ||
-                buildContext != null && buildContext.BuildComplete )
+            if (buildRequest?.BuildCompleted == true ||
+                buildContext?.BuildComplete == true)
             {
                 DecrementProjectsInProgress();
             }
@@ -2089,7 +2080,7 @@ private void StartRootProjectBuild(BuildRequest buildRequest, Project project)
                 // There should be no projects in the ProjectManager with the same full path, global properties and tools version
                 // as any of the loaded projects.  If there are, something went badly awry, because
                 // we were supposed to have deleted them after the last build.
-                ErrorUtilities.VerifyThrow(null == this.cacheOfBuildingProjects.GetProject(loadedProject.FullFileName, loadedProject.GlobalProperties, loadedProject.ToolsVersion),
+                ErrorUtilities.VerifyThrow(this.cacheOfBuildingProjects.GetProject(loadedProject.FullFileName, loadedProject.GlobalProperties, loadedProject.ToolsVersion) == null,
                     "Project shouldn't be in ProjectManager already.");
 
                 // Add the loaded project to the list of projects being built, just
@@ -2211,7 +2202,7 @@ IDictionary targetOutputs
         /// </summary>
         /// <remarks>
         /// If this project file is already in our list of in-progress projects, we use the
-        /// existing Project object instead of instantiating a new one. Always use this method to 
+        /// existing Project object instead of instantiating a new one. Always use this method to
         /// build projects within projects, otherwise the build won't be optimized.
         /// </remarks>
         /// <param name="projectFile"></param>
@@ -2242,7 +2233,7 @@ BuildSettings buildFlags
         /// </summary>
         /// <remarks>
         /// If this project file is already in our list of in-progress projects, we use the
-        /// existing Project object instead of instantiating a new one. Always use this method to 
+        /// existing Project object instead of instantiating a new one. Always use this method to
         /// build projects within projects, otherwise the build won't be optimized.
         /// </remarks>
         /// <param name="projectFile"></param>
@@ -2270,7 +2261,7 @@ string toolsVersion
 
         /// <summary>
         /// Loads a set of project files from disk, and builds the given list of targets for each one. This overload
-        /// takes a set of global properties for each project to use for the build, returns the target outputs, 
+        /// takes a set of global properties for each project to use for the build, returns the target outputs,
         /// and also allows the caller to specify additional build flags.
         /// </summary>
         /// <param name="projectFiles">Array of project files to build (can't be null)</param>
@@ -2305,7 +2296,7 @@ string [] toolsVersions
             }
 
             return PostProjectEvaluationRequests
-                (null, projectFiles, targetNamesPerProject, globalPropertiesPerProject, targetOutputsPerProject, 
+                (null, projectFiles, targetNamesPerProject, globalPropertiesPerProject, targetOutputsPerProject,
                  buildFlags, toolsVersions);
         }
 
@@ -2325,13 +2316,12 @@ string [] toolVersions
             fatalErrorContext = null;
 
             BuildEventContext buildEventContext;
-               
+
             // Already have an instantiated project in the OM and it has not fired a project started event for itself yet
-            if (project != null && !project.HaveUsedInitialProjectContextId)
+            if (project?.HaveUsedInitialProjectContextId == false)
             {
                 buildEventContext = project.ProjectBuildEventContext;
             }
-
             else // Dont have an already instantiated project, need to make a new context
             {
                 buildEventContext = new BuildEventContext(
@@ -2341,7 +2331,7 @@ string [] toolVersions
                                                 BuildEventContext.InvalidTaskId
                                                 );
             }
-            
+
             // Currently, MSBuild requires that the calling thread be marked "STA" -- single
             // threaded apartment.  This is because today we are calling the tasks' Execute()
             // method on this main thread, and there are tasks out there that create unmarshallable
@@ -2373,7 +2363,7 @@ string [] toolVersions
                     targetOutputsWorkingCopy[i] = new Hashtable(StringComparer.OrdinalIgnoreCase);
                 }
 
-                buildRequests[i] = 
+                buildRequests[i] =
                     CreateLocalBuildRequest(buildEventContext, project, projectFiles[i], targetNames[i],
                                             globalPropertiesPerProject[i], targetOutputsWorkingCopy[i], buildFlags,
                                             toolVersions[i]);
@@ -2446,8 +2436,8 @@ string [] toolVersions
         }
 
         /// <summary>
-        /// Create a build request which will be posted to the local engine queue, having a HandleId of -1 meaning it came from the local 
-        /// engine rather than an engine call back 
+        /// Create a build request which will be posted to the local engine queue, having a HandleId of -1 meaning it came from the local
+        /// engine rather than an engine call back
         /// </summary>
         /// <returns></returns>
         private BuildRequest CreateLocalBuildRequest(BuildEventContext buildEventContext, Project project, string projectFile, string[] targetNames, BuildPropertyGroup globalProperties, IDictionary targetOutputs, BuildSettings buildFlags, string toolsVersion)
@@ -2490,7 +2480,7 @@ private BuildRequest CreateLocalBuildRequest(BuildEventContext buildEventContext
         /// </summary>
         /// <remarks>
         /// If this project file is already in our list of in-progress projects, we use the
-        /// existing Project object instead of instantiating a new one. Always use this method to 
+        /// existing Project object instead of instantiating a new one. Always use this method to
         /// build projects within projects, otherwise the build won't be optimized.
         /// </remarks>
         internal void BuildProjectFileInternal
@@ -2534,11 +2524,10 @@ BuildRequest buildRequest
                 {
                     // There's no cached result: we have to build it. Figure out which node to build it on.
                     Project matchingProjectCurrentlyLoaded = null;
-                    Project projectCurrentlyLoaded = null;
-
+                    
                     // See if we have a project loaded by the host already that matches the full path, in the
                     // list of projects which were loaded at the beginning of the build.
-                    projectCurrentlyLoaded = (Project)this.projectsLoadedByHost[projectFileInfo.FullName];
+                    Project projectCurrentlyLoaded = (Project)this.projectsLoadedByHost[projectFileInfo.FullName];
 
                     if (projectCurrentlyLoaded != null)
                     {
@@ -2557,7 +2546,7 @@ BuildRequest buildRequest
                     }
 
                     // Decide to build the project on either the current node or remote node
-                    string toolsVersionToUse = buildRequest.ToolsetVersion == null ? DefaultToolsVersion : buildRequest.ToolsetVersion;
+                    string toolsVersionToUse = buildRequest.ToolsetVersion ?? DefaultToolsVersion;
 
                     // If a matching project is currently loaded, we will build locally.
                     bool isLocal = (matchingProjectCurrentlyLoaded != null);
@@ -2651,7 +2640,7 @@ private void HandleProjectFileInternalException(BuildRequest buildRequest)
         {
             // Flush out all the logging messages, which may have been posted outside target execution
             primaryLoggingServices.ProcessPostedLoggingEvents();
-            
+
             // Mark evaluation as complete
             buildRequest.BuildCompleted = true;
 
@@ -2672,9 +2661,9 @@ private void HandleProjectFileInternalException(BuildRequest buildRequest)
         /// <param name="cachedResult"></param>
         private void ProcessCachedResult
         (
-            BuildRequest buildRequest, 
-            FileInfo projectFileInfo, 
-            ArrayList actuallyBuiltTargets, 
+            BuildRequest buildRequest,
+            FileInfo projectFileInfo,
+            ArrayList actuallyBuiltTargets,
             BuildResult cachedResult
         )
         {
@@ -2702,7 +2691,7 @@ BuildResult cachedResult
                 buildRequest.ResultByTarget[builtTargetName] = buildState;
 
                 primaryLoggingServices.LogComment(currentContext,
-                    ((buildState == Target.BuildState.CompletedSuccessfully) ? "TargetAlreadyCompleteSuccess" : "TargetAlreadyCompleteFailure"),
+                    (buildState == Target.BuildState.CompletedSuccessfully) ? "TargetAlreadyCompleteSuccess" : "TargetAlreadyCompleteFailure",
                     builtTargetName);
 
                 if (buildState == Target.BuildState.CompletedUnsuccessfully)
@@ -2799,11 +2788,11 @@ bool toolsVersionPeekedFromProjectFile
                 // Check if the project has been previously unloaded due to a user request during the current build
                 // In this case reloaded a project is an error because we can't ensure a consistent state of the reloaded project
                 // and the cached resulted of the original
-                string toolsVersionToUse = toolsVersion == null ? DefaultToolsVersion : toolsVersion;
+                string toolsVersionToUse = toolsVersion ?? DefaultToolsVersion;
                 if (this.cacheOfBuildingProjects.HasProjectBeenLoaded(projectFullPath, globalPropertiesToUse, toolsVersionToUse))
                 {
                     string joinedNames = ResourceUtilities.FormatResourceString("DefaultTargets");
-                    if (targetNames != null && targetNames.Length > 0)
+                    if (targetNames?.Length > 0)
                     {
                         joinedNames = EscapingUtilities.UnescapeAll(String.Join(";", targetNames));
                     }
@@ -2862,24 +2851,24 @@ bool toolsVersionPeekedFromProjectFile
 
             return returnProject;
         }
-        
+
         /// <summary>
-        /// When using the MSBuild task to build a child project, we need to figure out the set of 
+        /// When using the MSBuild task to build a child project, we need to figure out the set of
         /// global properties that the child should be built with.  It is a merge of whatever
         /// properties the parent project was being built with, plus whatever properties were
         /// actually passed into the MSBuild task (in the "Properties" parameter).  However,
-        /// the slightly wrinkle is the child project may have actually been one that is 
+        /// the slightly wrinkle is the child project may have actually been one that is
         /// currently loaded in the IDE, and the IDE controls what Configuration/Platform each
         /// project should be built with, so we have to honor that too.  So, the order in which
         /// we look at global properties are:
-        /// 
+        ///
         ///     1.  Whatever global properties the parent project was building with.  (The parent
         ///         project is the one that called the &lt;MSBuild&lt; task.
-        ///     2.  If the child project was already previously loaded by the host, whatever global 
+        ///     2.  If the child project was already previously loaded by the host, whatever global
         ///         properties were sent into the child project by the host (via Project.GlobalProperties).
         ///     3.  Whatever properties were passed into the "Properties" parameter of the &lt;MSBuild&lt;
         ///         task.
-        /// 
+        ///
         /// </summary>
         /// <param name="parentProjectGlobalProperties"></param>
         /// <param name="childProjectFile"></param>
@@ -2904,11 +2893,11 @@ IDictionary globalPropertiesPassedIntoTask
                 // If the project file doesn't actually exist on disk, it's a failure.
                 ErrorUtilities.VerifyThrowArgument(File.Exists(childProjectFile), "ProjectFileNotFound", childProjectFile);
             }
-            
+
             // Create a new BuildPropertyGroup to represent the final set of global properties that we're going to
             // use for the child project.
             BuildPropertyGroup finalGlobalProperties = new BuildPropertyGroup();
-            
+
             // Start with the global properties from the parent project.
             if (postMergeProperties == null)
             {
@@ -2918,7 +2907,7 @@ IDictionary globalPropertiesPassedIntoTask
             {
                 finalGlobalProperties.ImportProperties(postMergeProperties);
             }
-            
+
             // childProjectFile could be null when no Projects were passed into the MSBuild task, which
             // means parentProject == childProject, which means no need to import the same properties again.
             if (childProjectFile != null)
@@ -2936,13 +2925,13 @@ IDictionary globalPropertiesPassedIntoTask
                     finalGlobalProperties.ImportProperties(loadedProjectWithSameFullPath.GlobalProperties);
                 }
             }
-            
+
             // Finally, whatever global properties were passed into the task ... those are the final winners.
             if (globalPropertiesPassedIntoTask != null)
             {
                 foreach (DictionaryEntry newGlobalProperty in globalPropertiesPassedIntoTask)
                 {
-                    finalGlobalProperties.SetProperty((string) newGlobalProperty.Key, 
+                    finalGlobalProperties.SetProperty((string) newGlobalProperty.Key,
                         (string) newGlobalProperty.Value);
                 }
             }
@@ -2984,7 +2973,7 @@ internal TaskExecutionContext GetTaskOutputUpdates()
         }
 
         /// <summary>
-        /// This function collects status about the inprogress targets and engine operations. 
+        /// This function collects status about the inprogress targets and engine operations.
         /// This function should always run from the engine domain because it touch engine data
         /// structures.
         /// </summary>
@@ -3002,13 +2991,13 @@ internal NodeStatus RequestStatus(int requestId)
             {
                 foreach (Target target in project.Targets)
                 {
-                    if (target.ExecutionState != null && target.ExecutionState.BuildingRequiredTargets)
+                    if (target.ExecutionState?.BuildingRequiredTargets == true)
                     {
                         inProgressTargets.Add(target);
                     }
                 }
             }
-            TargetInProgessState[] stateOfInProgressTargets = 
+            TargetInProgessState[] stateOfInProgressTargets =
                     new TargetInProgessState[waitingTargets.Length + inProgressTargets.Count];
             for (int i = 0; i < waitingTargets.Length; i++)
             {
diff --git a/src/Deprecated/Engine/Engine/EngineCallback.cs b/src/Deprecated/Engine/Engine/EngineCallback.cs
index 9e5c03f1702..9745331612b 100644
--- a/src/Deprecated/Engine/Engine/EngineCallback.cs
+++ b/src/Deprecated/Engine/Engine/EngineCallback.cs
@@ -12,7 +12,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
@@ -22,7 +21,7 @@ internal class EngineCallback : IEngineCallback
     {
         #region Constructors
         /// <summary>
-        /// Creates a callback class. There should only be one callback per engine under normal 
+        /// Creates a callback class. There should only be one callback per engine under normal
         /// circumstances.
         /// </summary>
         internal EngineCallback(Engine parentEngine)
@@ -87,7 +86,7 @@ private void ProcessBuildRequest(BuildRequest buildRequest)
             buildRequest.NodeIndex = executionContext.NodeIndex;
 
             ErrorUtilities.VerifyThrow(buildRequest.ParentBuildEventContext != null, "Should not have a null parentBuildEventContext");
-            ErrorUtilities.VerifyThrow(buildRequest.IsGeneratedRequest == true, "Should not be sending a non generated request from the child node to the parent node");
+            ErrorUtilities.VerifyThrow(buildRequest.IsGeneratedRequest, "Should not be sending a non generated request from the child node to the parent node");
 
             // For buildRequests originating from the TEM  - additional initialization is necessary
             TaskExecutionContext taskExecutionContext = executionContext as TaskExecutionContext;
@@ -117,7 +116,7 @@ private void ProcessBuildRequest(BuildRequest buildRequest)
                                                                    buildRequest.ProjectFileName,
                                                                    buildRequest.GlobalPropertiesPassedByTask);
                         }
-                        catch (ArgumentException e) 
+                        catch (ArgumentException e)
                         {
                             ConvertToInvalidProjectException(buildRequest, parentProject, e);
                         }
@@ -136,13 +135,11 @@ private void ProcessBuildRequest(BuildRequest buildRequest)
                         // project.  This allows people to avoid passing in the Projects parameter on the MSBuild task.
                         Project projectToBuild = parentProject;
 
-
-
                         // If the parent project (the calling project) already has the same set of global properties
                         // as what is being requested, just re-use it.  Otherwise, we need to instantiate a new
                         // project object that has the same project contents but different global properties.
                         if (!projectToBuild.GlobalProperties.IsEquivalent(buildRequest.GlobalProperties) &&
-                            (String.Compare(parentProject.ToolsVersion, buildRequest.ToolsetVersion, StringComparison.OrdinalIgnoreCase) == 0))
+                            (String.Equals(parentProject.ToolsVersion, buildRequest.ToolsetVersion, StringComparison.OrdinalIgnoreCase)))
                         {
                             projectToBuild = parentEngine.GetMatchingProject(parentProject,
                                                  parentProject.FullFileName, buildRequest.GlobalProperties,
@@ -185,8 +182,8 @@ private static void ConvertToInvalidProjectException(BuildRequest buildRequest,
         /// </summary>
         internal void PostTaskOutputs
         (
-            int handleId, 
-            bool taskExecutedSuccessfully, 
+            int handleId,
+            bool taskExecutedSuccessfully,
             Exception thrownException,
             long executionTime
         )
@@ -211,7 +208,7 @@ public void PostBuildResultToHost(BuildResult buildResult)
 
             // Cache the results
             routingContext.CacheScope.AddCacheEntryForBuildResults(buildResult);
-            
+
             if (Engine.debugMode)
             {
                 Console.WriteLine("Received result for HandleId " + buildResult.HandleId + ":" + buildResult.RequestId + " mapped to " + routingContext.ParentHandleId + ":" + routingContext.ParentRequestId);
@@ -219,7 +216,7 @@ public void PostBuildResultToHost(BuildResult buildResult)
 
             // Update the results with the original handle id and request id, so that 
             buildResult.HandleId = routingContext.ParentHandleId;
-       
+
             // If the build result is created from a generated build request a done notice should be posted as other targets could be waiting for this target to finish
             if (buildResult.HandleId != invalidEngineHandle)
             {
@@ -233,7 +230,7 @@ public void PostBuildResultToHost(BuildResult buildResult)
                 routingContext.TriggeringBuildRequest.BuildCompleted = true;
                 parentEngine.PostEngineCommand(new HostBuildRequestCompletionEngineCommand());
             }
-            
+
             // At this point the execution context we created for the execution of this build request can be deleted
             lock (freedContexts)
             {
@@ -246,7 +243,7 @@ public void PostBuildResultToHost(BuildResult buildResult)
         /// </summary>
         public void SetCacheEntries
         (
-            int handleId, CacheEntry[] entries, 
+            int handleId, CacheEntry[] entries,
             string cacheScope, string cacheKey, string cacheVersion,
             CacheContentType cacheContentType, bool localNodeOnly
         )
@@ -293,13 +290,13 @@ public void SetCacheEntries
                 }
             }
         }
-        
+
         /// <summary>
         /// Called either on the main or child node. This is the routing method for getting cache entries.
         /// </summary>
         public CacheEntry[] GetCacheEntries
         (
-            int handleId, string[] names, 
+            int handleId, string[] names,
             string cacheScope, string cacheKey, string cacheVersion,
             CacheContentType cacheContentType, bool localNodeOnly
         )
@@ -359,7 +356,7 @@ public CacheEntry[] GetCacheEntries
         }
 
         /// <summary>
-        /// Submit the logging message to the engine queue. Note that we are currently not utilizing the 
+        /// Submit the logging message to the engine queue. Note that we are currently not utilizing the
         /// handleId, but plan to do so in the future to fill out the data structure passed to the engine
         /// </summary>
         public void PostLoggingMessagesToHost(int nodeId, NodeLoggingEvent[] nodeLoggingEventArray)
@@ -390,7 +387,7 @@ internal void GetLineColumnOfXmlNode(int handleId, out int lineNumber, out int c
         internal ITaskRegistry GetEngineTaskRegistry(int handleId)
         {
             TaskExecutionContext executionContext = GetTaskContextFromHandleId(handleId);
-            return parentEngine.GetTaskRegistry(executionContext.BuildEventContext, 
+            return parentEngine.GetTaskRegistry(executionContext.BuildEventContext,
                                     executionContext.ParentProject.ToolsVersion);
         }
 
@@ -495,16 +492,16 @@ internal RequestRoutingContext GetRoutingContextFromHandleId(int handleId)
         /// </summary>
         internal int CreateTaskContext
         (
-            Project parentProject, 
+            Project parentProject,
             Target  parentTarget,
             ProjectBuildState buildContext,
-            XmlElement taskNode, 
+            XmlElement taskNode,
             int nodeIndex,
             BuildEventContext taskContext
         )
         {
             int handleId = nextContextId;
-            nextContextId = nextContextId + 1;
+            nextContextId++;
 
             TaskExecutionContext executionContext =
                 new TaskExecutionContext(parentProject, parentTarget, taskNode, buildContext, handleId, nodeIndex, taskContext);
@@ -530,10 +527,10 @@ BuildEventContext buildEventContext
         )
         {
             int handleId = nextContextId;
-            nextContextId = nextContextId + 1;
+            nextContextId++;
 
             RequestRoutingContext executionContext =
-                new RequestRoutingContext(handleId, nodeIndex, parentHandleId, parentNodeIndex, parentRequestId, 
+                new RequestRoutingContext(handleId, nodeIndex, parentHandleId, parentNodeIndex, parentRequestId,
                                           cacheScope, triggeringBuildRequest, buildEventContext);
 
             executionContexts.Add(handleId, executionContext);
@@ -570,7 +567,7 @@ internal void ClearContextState(int handleId)
 
         #region Constants
         /// <summary>
-        /// Number assigned to an invalid engine handle, This handleId is used by Buildrequests 
+        /// Number assigned to an invalid engine handle, This handleId is used by Buildrequests
         /// to show they are a routing context
         /// </summary>
         internal const int invalidEngineHandle = -1;
diff --git a/src/Deprecated/Engine/Engine/EngineLoggingServices.cs b/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
index 15ad1514da1..10109162531 100644
--- a/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
+++ b/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
@@ -75,7 +75,7 @@ virtual internal void Shutdown()
         /// <param name="e"></param>
         internal void PostLoggingEvent(BuildEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
             if (paused)
             {
@@ -106,7 +106,7 @@ internal void PostLoggingEvent(BuildEventArgs e)
         /// <param name="eventArray"></param>
         internal void PostLoggingEvents(BuildEventArgs[] eventArray)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(eventArray, "eventArray");
+            ErrorUtilities.VerifyThrowArgumentNull(eventArray, nameof(eventArray));
 
             if (paused)
             {
@@ -139,7 +139,7 @@ internal void PostLoggingEvents(BuildEventArgs[] eventArray)
         /// <param name="e"></param>
         internal void PostLoggingEvent(NodeLoggingEvent e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
             if (paused)
             {
@@ -163,7 +163,7 @@ internal void PostLoggingEvent(NodeLoggingEvent e)
         /// <param name="eventArray"></param>
         internal void PostLoggingEvents(NodeLoggingEvent[] eventArray)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(eventArray, "eventArray");
+            ErrorUtilities.VerifyThrowArgumentNull(eventArray, nameof(eventArray));
 
             if (paused)
             {
@@ -220,7 +220,7 @@ virtual internal bool NeedsFlush(long currentTickCount)
                 currentTickCount = DateTime.Now.Ticks;
             }
 
-            return ((currentTickCount - lastFlushTime) > flushTimeoutInTicks);
+            return (currentTickCount - lastFlushTime) > flushTimeoutInTicks;
         }
 
         #endregion
@@ -240,7 +240,7 @@ internal void LogErrorEvent(BuildErrorEventArgs e)
             // issue, and it apparently will also cause us problems if we adopt the
             // new Longhorn Add-In Programming Model.  
 
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             PostLoggingEvent(e);
         }
 
@@ -260,7 +260,7 @@ internal void LogMessageEvent(BuildMessageEventArgs e)
                 // issue, and it apparently will also cause us problems if we adopt the
                 // new Longhorn Add-In Programming Model.
 
-                ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+                ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
                 PostLoggingEvent(e);
             }
         }
@@ -279,7 +279,7 @@ internal void LogWarningEvent(BuildWarningEventArgs e)
             // issue, and it apparently will also cause us problems if we adopt the
             // new Longhorn Add-In Programming Model.
 
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             PostLoggingEvent(e);
         }
 
@@ -297,7 +297,7 @@ internal void LogCustomEvent(CustomBuildEventArgs e)
             // issue, and it apparently will also cause us problems if we adopt the
             // new Longhorn Add-In Programming Model.
 
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             PostLoggingEvent(e);
         }
         #endregion
@@ -616,7 +616,6 @@ virtual internal void LogWarningFromText(BuildEventContext buildEventContext, st
                 subcategory = AssemblyResources.GetString(subcategoryResourceName);
             }
 
-
             BuildWarningEventArgs e = new BuildWarningEventArgs
                 (
                     subcategory,
@@ -742,9 +741,8 @@ virtual internal void LogProjectStarted(int projectId, BuildEventContext parentB
             if (!OnlyLogCriticalEvents)
             {
                 ProjectStartedEventArgs e;
-
-               
-                if (null != targetNames && targetNames.Length > 0)
+              
+                if (!string.IsNullOrEmpty(targetNames))
                 {
                     e = new ProjectStartedEventArgs
                         (
@@ -789,7 +787,7 @@ virtual internal void LogProjectFinished(BuildEventContext buildEventContext, st
         {
             if (!OnlyLogCriticalEvents)
             {
-                string message = ResourceUtilities.FormatResourceString((success ? "ProjectFinishedSuccess" : "ProjectFinishedFailure"), Path.GetFileName(projectFile));
+                string message = ResourceUtilities.FormatResourceString(success ? "ProjectFinishedSuccess" : "ProjectFinishedFailure", Path.GetFileName(projectFile));
 
                 ProjectFinishedEventArgs e = new ProjectFinishedEventArgs
                     (
@@ -839,7 +837,7 @@ virtual internal void LogTargetFinished(BuildEventContext buildEventContext, str
         {
             if (!OnlyLogCriticalEvents)
             {
-                string message = ResourceUtilities.FormatResourceString((success ? "TargetFinishedSuccess" : "TargetFinishedFailure"), targetName, Path.GetFileName(projectFile));
+                string message = ResourceUtilities.FormatResourceString(success ? "TargetFinishedSuccess" : "TargetFinishedFailure", targetName, Path.GetFileName(projectFile));
 
                 TargetFinishedEventArgs e = new TargetFinishedEventArgs
                     (
@@ -892,7 +890,7 @@ virtual internal void LogTaskFinished(BuildEventContext buildEventContext, strin
         {
             if (!OnlyLogCriticalEvents)
             {
-                string message = ResourceUtilities.FormatResourceString((success ? "TaskFinishedSuccess" : "TaskFinishedFailure"), taskName);
+                string message = ResourceUtilities.FormatResourceString(success ? "TaskFinishedSuccess" : "TaskFinishedFailure", taskName);
 
                 TaskFinishedEventArgs e = new TaskFinishedEventArgs
                     (
@@ -1013,7 +1011,6 @@ internal bool FlushBuildEventsImmediatly
         /// </summary>
         protected ManualResetEvent flushRequestEvent;
 
-
         internal const int flushTimeoutInMS = 500;          // flush the queue at least every 1/2 second
         internal const int flushTimeoutInTicks = 500*10000; // flush the queue at least every 1/2 second
         internal const int flushQueueSize = 1000;            // flush the queue every time 1000 events accumulate
diff --git a/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs b/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs
index 2f6bd3a4f9a..9a8799e1205 100644
--- a/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs
+++ b/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs
@@ -62,7 +62,7 @@ override internal bool ProcessPostedLoggingEvents()
             lastFlushTime = DateTime.Now.Ticks;
 
             // Process all the events posted with a logger Id
-            NodeLoggingEvent nodeLoggingEvent = null;
+            NodeLoggingEvent nodeLoggingEvent;
 
             // We may get a single event for multiple messages
             while ((nodeLoggingEvent = loggingQueueOfNodeEvents.Dequeue()) != null)
@@ -89,7 +89,7 @@ override internal bool ProcessPostedLoggingEvents()
             }
 
             // Process all the events in that have been already posted
-            BuildEventArgs buildEventArgs = null;
+            BuildEventArgs buildEventArgs;
 
             // We may get a single event for multiple messages
             while ((buildEventArgs = loggingQueueOfBuildEvents.Dequeue()) != null)
@@ -119,10 +119,7 @@ override internal void ProcessBuildEvent(BuildEventArgs buildEventArgs)
             }
 
             // Check if it necessary to forward the event to another logging service
-            if (forwardingService != null)
-            {
-                forwardingService.PostLoggingEvent(buildEventArgs);
-            }
+            forwardingService?.PostLoggingEvent(buildEventArgs);
         }
 
         internal void RegisterEventSource(int loggerId, EventSource eventSource)
diff --git a/src/Deprecated/Engine/Engine/EngineProxy.cs b/src/Deprecated/Engine/Engine/EngineProxy.cs
index a1934f5d9b3..d32e8382aeb 100644
--- a/src/Deprecated/Engine/Engine/EngineProxy.cs
+++ b/src/Deprecated/Engine/Engine/EngineProxy.cs
@@ -46,7 +46,7 @@ internal sealed class EngineProxy : MarshalByRefObject, IBuildEngine3
         private string projectFileOfTaskNode;
 
         /// <summary>
-        /// The token identifing the context of this evaluation 
+        /// The token identifing the context of this evaluation
         /// </summary>
         private int handleId;
 
@@ -56,7 +56,7 @@ internal sealed class EngineProxy : MarshalByRefObject, IBuildEngine3
         private bool continueOnError;
 
         /// <summary>
-        /// The module within which this class has been created. Used for all callbacks to 
+        /// The module within which this class has been created. Used for all callbacks to
         /// engine.
         /// </summary>
         private TaskExecutionModule parentModule;
@@ -102,7 +102,7 @@ private EngineProxy()
         {
             // do nothing
         }
-     
+
         /// <summary>
         /// Create an instance of this class to represent the IBuildEngine2 interface to the task
         /// including the event location where the log messages are raised
@@ -115,10 +115,10 @@ private EngineProxy()
         /// <param name="buildEventContext">Event Context where events will be seen to be raised from. Task messages will get this as their event context</param>
         internal EngineProxy
         (
-            TaskExecutionModule parentModule, 
-            int handleId, 
+            TaskExecutionModule parentModule,
+            int handleId,
             string parentProjectFullFileName,
-            string projectFileOfTaskNode, 
+            string projectFileOfTaskNode,
             EngineLoggingServices loggingServices,
             BuildEventContext buildEventContext
         )
@@ -143,8 +143,8 @@ BuildEventContext buildEventContext
         /// </summary>
         public void LogErrorEvent(BuildErrorEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
-            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
+            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
             if (parentModule.IsRunningMultipleNodes && !e.GetType().IsSerializable)
             {
@@ -190,14 +190,14 @@ public void LogErrorEvent(BuildErrorEventArgs e)
                     e = new BuildErrorEventArgs
                         (
                             e.Subcategory,
-                            e.Code, 
-                            e.File, 
-                            e.LineNumber, 
-                            e.ColumnNumber, 
-                            e.EndLineNumber, 
-                            e.EndColumnNumber, 
+                            e.Code,
+                            e.File,
+                            e.LineNumber,
+                            e.ColumnNumber,
+                            e.EndLineNumber,
+                            e.EndColumnNumber,
                             message,  // this is the new message from above
-                            e.HelpKeyword, 
+                            e.HelpKeyword,
                             e.SenderName
                         );
                 }
@@ -212,8 +212,8 @@ public void LogErrorEvent(BuildErrorEventArgs e)
         /// </summary>
         public void LogWarningEvent(BuildWarningEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
-            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
+            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
             if (parentModule.IsRunningMultipleNodes && !e.GetType().IsSerializable)
             {
@@ -250,7 +250,7 @@ public void LogWarningEvent(BuildWarningEventArgs e)
         }
 
         /// <summary>
-        /// 
+        ///
         /// </summary>
         /// <param name="file">File field from the original BuildEventArgs</param>
         /// <param name="message">Message field from the original BuildEventArgs</param>
@@ -289,8 +289,8 @@ private static string GetUpdatedMessage(string file, string message, string pare
         /// </summary>
         public void LogMessageEvent(BuildMessageEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
-            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
+            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
             if (parentModule.IsRunningMultipleNodes && !e.GetType().IsSerializable)
             {
@@ -306,8 +306,8 @@ public void LogMessageEvent(BuildMessageEventArgs e)
         /// </summary>
         public void LogCustomEvent(CustomBuildEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
-            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
+            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
             if (parentModule.IsRunningMultipleNodes && !e.GetType().IsSerializable)
             {
@@ -327,7 +327,7 @@ public bool ContinueOnError
         {
             get
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
                 return this.continueOnError;
             }
@@ -351,7 +351,7 @@ public int LineNumberOfTaskNode
         {
             get
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
                 ComputeProjectFileLocationOfTaskNode();
                 return this.lineNumber;
@@ -367,7 +367,7 @@ public int ColumnNumberOfTaskNode
         {
             get
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
                 ComputeProjectFileLocationOfTaskNode();
                 return this.columnNumber;
@@ -381,7 +381,7 @@ public string ProjectFileOfTaskNode
         {
             get
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
                 return projectFileOfTaskNode;
             }
@@ -430,16 +430,16 @@ IDictionary targetOutputs
         /// <returns>result of call to engine</returns>
         public bool BuildProjectFile
             (
-            string projectFileName, 
-            string[] targetNames, 
-            IDictionary globalProperties, 
+            string projectFileName,
+            string[] targetNames,
+            IDictionary globalProperties,
             IDictionary targetOutputs,
             string toolsVersion
             )
         {
             lock (callbackMonitor)
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
                 // Wrap the project name into an array
                 string[] projectFileNames = new string[1];
@@ -485,7 +485,7 @@ bool unloadProjectsOnCompletion
         }
 
         /// <summary>
-        /// Not implemented for the proxy 
+        /// Not implemented for the proxy
         /// </summary>
 	public void Yield()
 	{
@@ -504,12 +504,12 @@ public void Reacquire()
         /// <remarks>
         /// 1) it is acceptable to pass null for both <c>targetNames</c> and <c>targetOutputs</c>
         /// 2) if no targets are specified, the default targets are built
-        /// 
+        ///
         /// </remarks>
         /// <param name="projectFileNames">The project to build.</param>
         /// <param name="targetNames">The targets in the project to build (can be null).</param>
         /// <param name="globalProperties">An array of hashtables of additional global properties to apply
-        ///     to the child project (array entries can be null). 
+        ///     to the child project (array entries can be null).
         ///     The key and value in the hashtable should both be strings.</param>
         /// <param name="removeGlobalProperties">A list of global properties which should be removed.</param>
         /// <param name="toolsVersions">A tools version recognized by the Engine that will be used during this build (can be null).</param>
@@ -527,11 +527,11 @@ bool returnTargetOutputs
         {
             lock (callbackMonitor)
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
-                ErrorUtilities.VerifyThrowArgumentNull(projectFileNames, "projectFileNames");
+                ErrorUtilities.VerifyThrowArgumentNull(projectFileNames, nameof(projectFileNames));
                 ErrorUtilities.VerifyThrowArgumentNull(globalProperties, "globalPropertiesPerProject");
-                
+
                 Dictionary<string, ITaskItem[]>[] targetOutputsPerProject = null;
 
                 if (returnTargetOutputs)
@@ -552,7 +552,7 @@ bool returnTargetOutputs
         }
 
         /// <summary>
-        /// InitializeLifetimeService is called when the remote object is activated. 
+        /// InitializeLifetimeService is called when the remote object is activated.
         /// This method will determine how long the lifetime for the object will be.
         /// </summary>
         public override object InitializeLifetimeService()
@@ -573,7 +573,7 @@ public override object InitializeLifetimeService()
                 int leaseTimeFromEnvironment;
                 if (int.TryParse(initialLeaseTimeFromEnvironment , out leaseTimeFromEnvironment) && leaseTimeFromEnvironment > 0)
                 {
-                      initialLeaseTime = leaseTimeFromEnvironment;        
+                      initialLeaseTime = leaseTimeFromEnvironment;
                 }
             }
 
@@ -593,7 +593,7 @@ public override object InitializeLifetimeService()
                 int leaseExtensionFromEnvironment;
                 if (int.TryParse(leaseExtensionTimeFromEnvironment , out leaseExtensionFromEnvironment) && leaseExtensionFromEnvironment > 0)
                 {
-                      leaseExtensionTime = leaseExtensionFromEnvironment;        
+                      leaseExtensionTime = leaseExtensionFromEnvironment;
                 }
             }
 
@@ -605,7 +605,6 @@ public override object InitializeLifetimeService()
             return lease;
         }
 
-
         /// <summary>
         /// Indicates to the EngineProxy that it is no longer needed.
         /// Called by TaskEngine when the task using the EngineProxy is done.
@@ -619,23 +618,19 @@ internal void MarkAsInActive()
             loggingServices = null;
             parentModule = null;
             buildEventContext = null;
-            
+
             // Clear out the sponsor (who is responsible for keeping the EngineProxy remoting lease alive until the task is done)
             // this will be null if the engineproxy was never sent accross an appdomain boundry.
             if (sponsor != null)
             {
                 ILease lease = (ILease)RemotingServices.GetLifetimeService(this);
-             
-                if (lease != null)
-                {
-                    lease.Unregister(sponsor);
-                }
-                
+                lease?.Unregister(sponsor);
+
                 sponsor.Close();
                 sponsor = null;
             }
         }
-	
+
         #region Properties
         /// <summary>
         /// Provide a way to change the BuildEventContext of the engine proxy. This is important in batching where each batch will need its own buildEventContext.
diff --git a/src/Deprecated/Engine/Engine/Expander.cs b/src/Deprecated/Engine/Engine/Expander.cs
index 8b7230ae7ba..0b277a679bf 100644
--- a/src/Deprecated/Engine/Engine/Expander.cs
+++ b/src/Deprecated/Engine/Engine/Expander.cs
@@ -464,8 +464,6 @@ XmlNode expressionNode
             // any more.
             while (propertyStartIndex != -1)
             {
-                bool tryExtractPropertyFunction = false;
-                bool tryExtractRegistryFunction = false;
 
                 // Append the targetString with the portion of the sourceString up to
                 // (but not including) the "$(", and advance the sourceIndex pointer.
@@ -473,8 +471,9 @@ XmlNode expressionNode
                 {
                     results.Add(expression.Substring(sourceIndex, propertyStartIndex - sourceIndex));
                 }
-                sourceIndex = propertyStartIndex;
 
+                bool tryExtractPropertyFunction;
+                bool tryExtractRegistryFunction;
                 // Following the "$(" we need to locate the matching ')'
                 // Scan for the matching closing bracket, skipping any nested ones
                 // This is a very complete, fast validation of parenthesis matching including for nested
@@ -655,8 +654,8 @@ private static string ConvertToString(object valueToConvert)
         /// </summary>
         private static int ScanForClosingParenthesis(string expression, int index)
         {
-            bool potentialPropertyFunction = false;
-            bool potentialRegistryFunction = false;
+            bool potentialPropertyFunction;
+            bool potentialRegistryFunction;
             return ScanForClosingParenthesis(expression, index, out potentialPropertyFunction, out potentialRegistryFunction);
         }
 
@@ -907,7 +906,7 @@ private string ExpandRegistryValue(string registryExpression, XmlNode node)
                     object valueFromRegistry = Registry.GetValue(registryKeyName,
                                                                  valueName,
                                                                  null /* default if key or value name is not found */);
-                    if (null != valueFromRegistry)
+                    if (valueFromRegistry != null)
                     {
                         // Convert the result to a string that is reasonable for MSBuild
                         result = ConvertToString(valueFromRegistry);
@@ -1042,7 +1041,7 @@ public static Function ExtractPropertyFunction(string expressionFunction, object
                 // First we'll see if there is a static function being called
                 // A static method is the content that follows the last "::", the rest being
                 // the type
-                int methodStartIndex = -1;
+                int methodStartIndex;
 
                 // This is a static method call
                 if (expressionRoot[0] == '[')
@@ -1129,8 +1128,6 @@ public static Function ExtractPropertyFunction(string expressionFunction, object
             /// </summary>
             public object Execute(Expander expander, object objectInstance, BuildPropertyGroup properties, ExpanderOptions options)
             {
-                object functionResult = String.Empty;
-
                 object[] args = null;
 
                 try
@@ -1190,7 +1187,8 @@ public object Execute(Expander expander, object objectInstance, BuildPropertyGro
                         // change the type of the final unescaped string into the destination
                         args[0] = Convert.ChangeType(args[0], objectInstance.GetType(), CultureInfo.InvariantCulture);
                     }
-                    
+
+                    object functionResult;
                     // If we've been asked for and instance to be constructed, then we
                     // need to locate an appropriate constructor and invoke it
                     if (String.Equals("new", this.name, StringComparison.OrdinalIgnoreCase))
@@ -1429,20 +1427,15 @@ private static Type GetTypeFromAssemblyUsingNamespace(string typeName)
             {
                 string baseName = typeName;
                 int assemblyNameEnd = baseName.LastIndexOf('.');
-                Type foundType = null;
-
                 ErrorUtilities.VerifyThrow(assemblyNameEnd > 0, "Invalid typename: {0}", typeName);
 
                 // We will work our way up the namespace looking for an assembly that matches
                 while (assemblyNameEnd > 0)
                 {
-                    string candidateAssemblyName = null;
-
-                    candidateAssemblyName = baseName.Substring(0, assemblyNameEnd);
+                    string candidateAssemblyName = baseName.Substring(0, assemblyNameEnd);
 
                     // Try to load the assembly with the computed name
-                    foundType = GetTypeFromAssembly(typeName, candidateAssemblyName);
-
+                    Type foundType = GetTypeFromAssembly(typeName, candidateAssemblyName);
                     if (foundType != null)
                     {
                         // We have a match, so get the type from that assembly
@@ -1460,7 +1453,6 @@ private static Type GetTypeFromAssemblyUsingNamespace(string typeName)
                 return null;
             }
 
-
             /// <summary>
             /// Get the specified type from the assembly partial name supplied
             /// </summary>
@@ -1526,7 +1518,6 @@ private static Function ConstructFunction(string expressionFunction, string expr
                     // It may be that there are '()' but no actual arguments content
                     if (argumentStartIndex == expressionFunction.Length - 1)
                     {
-                        argumentsContent = String.Empty;
                         functionArguments = new string[0];
                     }
                     else
@@ -1594,7 +1585,7 @@ private static Function ConstructFunction(string expressionFunction, string expr
             private static string[] ExtractFunctionArguments(string expressionFunction, string argumentsContent)
             {
                 List<string> arguments = new List<string>();
-                StringBuilder argumentBuilder = new StringBuilder(argumentsContent.Length); ;
+                StringBuilder argumentBuilder = new StringBuilder(argumentsContent.Length); 
 
                 // Iterate over the contents of the arguments extracting the
                 // the individual arguments as we go
@@ -1611,18 +1602,18 @@ private static string[] ExtractFunctionArguments(string expressionFunction, stri
 
                         ProjectErrorUtilities.VerifyThrowInvalidProject(n != 0, null, "InvalidFunctionPropertyExpression", expressionFunction, String.Empty);
 
-                        argumentBuilder.Append(argumentsContent.Substring(nestedPropertyStart, (n - nestedPropertyStart) + 1));
+                        argumentBuilder.Append(argumentsContent, nestedPropertyStart, (n - nestedPropertyStart) + 1);
                     }
                     else if (argumentsContent[n] == '`' || argumentsContent[n] == '"' || argumentsContent[n] == '\'')
                     {
                         int quoteStart = n;
-                        n += 1; // skip over the opening quote
+                        n++; // skip over the opening quote
 
                         n = ScanForClosingQuote(argumentsContent[quoteStart], argumentsContent, n);
 
                         ProjectErrorUtilities.VerifyThrowInvalidProject(n != 0, null, "InvalidFunctionPropertyExpression", expressionFunction, String.Empty);
 
-                        argumentBuilder.Append(argumentsContent.Substring(quoteStart, (n - quoteStart) + 1));
+                        argumentBuilder.Append(argumentsContent, quoteStart, (n - quoteStart) + 1);
                     }
                     else if (argumentsContent[n] == ',')
                     {
@@ -1672,12 +1663,12 @@ private static void AddArgument(List<string> arguments, StringBuilder argumentBu
                 // If we don't have something that can be treated as an argument
                 // then we should treat it as a null so that passing nulls
                 // becomes possible through an empty argument between commas.
-                ErrorUtilities.VerifyThrowArgumentNull(argumentBuilder, "argumentBuilder");
+                ErrorUtilities.VerifyThrowArgumentNull(argumentBuilder, nameof(argumentBuilder));
                 // we reached the end of an argument, add the builder's final result
                 // to our arguments. 
                 string argValue = argumentBuilder.ToString().Trim();
                 // We support passing of null through the argument constant value null
-                if (String.Compare("null", argValue, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals("null", argValue, StringComparison.OrdinalIgnoreCase))
                 {
                     arguments.Add(null);
                 }
@@ -1784,9 +1775,6 @@ private bool IsStaticMethodAvailable(Type objectType, string methodName)
             /// </summary>
             private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object objectInstance /* null unless instance method */, object[] args, bool isConstructor)
             {
-                ParameterInfo[] parameters = null;
-                MethodBase[] members = null;
-                MethodBase memberInfo = null;
 
                 // First let's try for a method where all arguments are strings..
                 Type[] types = new Type[arguments.Length];
@@ -1795,6 +1783,7 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
                     types[n] = typeof(string);
                 }
 
+                MethodBase memberInfo;
                 if (isConstructor)
                 {
                     memberInfo = objectType.GetConstructor(bindingFlags, null, types, null);
@@ -1808,6 +1797,7 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
                 // search for a method with the right number of arguments
                 if (memberInfo == null)
                 {
+                    MethodBase[] members;
                     // Gather all methods that may match
                     if (isConstructor)
                     {
@@ -1818,22 +1808,21 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
                         members = objectType.GetMethods(bindingFlags);
                     }
 
-                    // Try to find a method with the right name, number of arguments and
-                    // compatible argument types
-                    object[] coercedArguments = null;
                     foreach (MethodBase member in members)
                     {
-                        parameters = member.GetParameters();
+                        ParameterInfo[] parameters = member.GetParameters();
 
                         // Simple match on name and number of params, we will be case insensitive
                         if (parameters.Length == this.arguments.Length)
                         {
                             if (isConstructor || String.Equals(member.Name, this.name, StringComparison.OrdinalIgnoreCase))
                             {
+                                // Try to find a method with the right name, number of arguments and
+                                // compatible argument types
                                 // we have a match on the name and argument number
                                 // now let's try to coerce the arguments we have
                                 // into the arguments on the matching method
-                                coercedArguments = CoerceArguments(args, parameters);
+                                object[] coercedArguments = CoerceArguments(args, parameters);
 
                                 if (coercedArguments != null)
                                 {
diff --git a/src/Deprecated/Engine/Engine/Import.cs b/src/Deprecated/Engine/Engine/Import.cs
index 456143d39f9..6e6f49f32b7 100644
--- a/src/Deprecated/Engine/Engine/Import.cs
+++ b/src/Deprecated/Engine/Engine/Import.cs
@@ -60,7 +60,7 @@ public string ProjectPath
         {
             get 
             { 
-                return (this.projectPathAttribute != null) ? this.projectPathAttribute.Value : null; 
+                return this.projectPathAttribute?.Value; 
             }
             set
             {
@@ -99,7 +99,7 @@ public string Condition
         {
             get 
             { 
-                return (this.conditionAttribute != null) ? this.conditionAttribute.Value : null; 
+                return this.conditionAttribute?.Value; 
             }
             set
             {
diff --git a/src/Deprecated/Engine/Engine/ImportCollection.cs b/src/Deprecated/Engine/Engine/ImportCollection.cs
index 9c5669e5373..65aca2c1ea2 100644
--- a/src/Deprecated/Engine/Engine/ImportCollection.cs
+++ b/src/Deprecated/Engine/Engine/ImportCollection.cs
@@ -171,7 +171,7 @@ public void CopyTo(Import[] array, int index)
         /// <param name="condition">Condition. If null, no condition is added.</param>
         public void AddNewImport(string projectFile, string condition)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(projectFile, "projectFile");
+            ErrorUtilities.VerifyThrowArgumentLength(projectFile, nameof(projectFile));
 
             XmlElement projectElement = this.parentProject.ProjectElement;
             XmlElement newImportElement = projectElement.OwnerDocument.CreateElement(XMakeElements.import, XMakeAttributes.defaultXmlNamespace);
@@ -198,7 +198,7 @@ public void RemoveImport
             Import importToRemove
         )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(importToRemove, "importToRemove");
+            ErrorUtilities.VerifyThrowArgumentNull(importToRemove, nameof(importToRemove));
 
             // Confirm that it's not an imported import.
             ErrorUtilities.VerifyThrowInvalidOperation(!importToRemove.IsImported,
diff --git a/src/Deprecated/Engine/Engine/ImportedProject.cs b/src/Deprecated/Engine/Engine/ImportedProject.cs
index 3d0b9922958..b681602d6cd 100644
--- a/src/Deprecated/Engine/Engine/ImportedProject.cs
+++ b/src/Deprecated/Engine/Engine/ImportedProject.cs
@@ -15,7 +15,6 @@ namespace Microsoft.Build.BuildEngine
     /// <owner>SumedhK</owner>
     internal sealed class ImportedProject
     {
-
         /// <summary>
         /// Creates an instance of this class for the specified project file.
         /// </summary>
@@ -62,7 +61,7 @@ internal bool HasChangedOnDisk(string projectFile)
         {
             FileInfo projectFileInfo = new FileInfo(projectFile);
 
-            return ((lastWriteTime != projectFileInfo.LastWriteTime) || (fileSize != projectFileInfo.Length));
+            return (lastWriteTime != projectFileInfo.LastWriteTime) || (fileSize != projectFileInfo.Length);
         }
 
         // the XML for the imported project
diff --git a/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs b/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
index eb6a90b2a09..f5bab0f2fa2 100644
--- a/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
+++ b/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
@@ -329,7 +329,7 @@ private static RegistryKey GetBaseKeyFromKeyName(string keyName, RegistryView vi
         {
             if (keyName == null)
             {
-                throw new ArgumentNullException("keyName");
+                throw new ArgumentNullException(nameof(keyName));
             }
 
             string basekeyName;
diff --git a/src/Deprecated/Engine/Engine/Node.cs b/src/Deprecated/Engine/Engine/Node.cs
index a16f21d38e1..5881de4307c 100644
--- a/src/Deprecated/Engine/Engine/Node.cs
+++ b/src/Deprecated/Engine/Engine/Node.cs
@@ -29,8 +29,8 @@ internal class Node
         /// </summary>
         internal Node
         (
-            int nodeId, 
-            LoggerDescription[] nodeLoggers, 
+            int nodeId,
+            LoggerDescription[] nodeLoggers,
             IEngineCallback parentCallback,
             BuildPropertyGroup parentGlobalProperties,
             ToolsetDefinitionLocations toolsetSearchLocations,
@@ -127,7 +127,7 @@ internal void PostBuildRequestToHost(BuildRequest currentRequest)
             TaskExecutionContext taskExecutionContext = localEngine.EngineCallback.GetTaskContextFromHandleId(currentRequest.HandleId);
             while (!taskExecutionContext.BuildContext.BuildRequest.IsExternalRequest)
             {
-                ErrorUtilities.VerifyThrow(taskExecutionContext.BuildContext.BuildRequest.IsGeneratedRequest, 
+                ErrorUtilities.VerifyThrow(taskExecutionContext.BuildContext.BuildRequest.IsGeneratedRequest,
                                            "Must be a generated request");
 
                 taskExecutionContext =
@@ -214,7 +214,7 @@ internal void PostStatus(NodeStatus nodeStatus, bool blockUntilSent)
 
         /// <summary>
         /// A variation of PostStatus that throws instead of calling ReportUnhandledError
-        /// if there's a problem. This allows ReportUnhandledError itself to post status 
+        /// if there's a problem. This allows ReportUnhandledError itself to post status
         /// without the possibility of a loop.
         /// </summary>
         internal void PostStatusThrow(NodeStatus nodeStatus, bool blockUntilSent)
@@ -251,7 +251,7 @@ BuildRequest buildRequest
                             launchedEngineLoopThread = true;
                             ThreadStart threadState = new ThreadStart(this.NodeLocalEngineLoop);
                             Thread taskThread = new Thread(threadState);
-                            taskThread.Name = "MSBuild Child Engine";                            
+                            taskThread.Name = "MSBuild Child Engine";
                             taskThread.SetApartmentState(ApartmentState.STA);
                             taskThread.Start();
                         }
@@ -305,7 +305,7 @@ internal void PostBuildResult(BuildResult buildResult)
                 buildResult.HandleId = nodeRequestMapping.HandleId;
                 buildResult.RequestId = nodeRequestMapping.RequestId;
                 nodeRequestMapping.AddResultToCache(buildResult);
-                
+
                 // posts the result to the inproc node
                 localEngine.Router.PostDoneNotice(0, buildResult);
             }
@@ -387,7 +387,6 @@ bool useBreadthFirstTraversal
                 localEngine.LoggingServices.OnlyLogCriticalEvents = this.logOnlyCriticalEvents;
                 localEngine.PostEngineCommand( new ChangeTraversalTypeCommand( useBreadthFirstTraversal, true ));
             }
-
         }
 
         /// <summary>
@@ -436,7 +435,6 @@ internal void ReportUnhandledError(Exception originalException)
             {
                 try
                 {
-
                     PostStatusThrow(nodeStatus, true /* wait for the message to be sent before returning */);
                 }
                 catch (Exception ex)
@@ -457,10 +455,7 @@ internal void ReportUnhandledError(Exception originalException)
                 LocalNode.DumpExceptionToFile(originalException);
             }
 
-            if (localEngine != null)
-            {
-                localEngine.Shutdown();
-            }
+            localEngine?.Shutdown();
         }
 
         /// <summary>
@@ -474,10 +469,7 @@ internal void ReportUnhandledError(Exception originalException)
         /// <exception cref="Exception">Re-throws exception passed in</exception>
         internal void ReportFatalCommunicationError(Exception originalException, TextWriter loggingStream)
         {
-            if (loggingStream != null)
-            {
-                loggingStream.WriteLine(originalException.ToString());
-            }
+            loggingStream?.WriteLine(originalException.ToString());
 
             string message = ResourceUtilities.FormatResourceString("FatalErrorOnChildNode", nodeId, originalException.Message);
 
diff --git a/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs b/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
index b200bda4f0b..092f9dc3858 100644
--- a/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
+++ b/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
@@ -199,7 +199,7 @@ internal virtual void WriteToStream(BinaryWriter writer, Hashtable loggingTypeCa
                 else
                 {
                     // The customer serialization methods are not availiable, default to .net serialization
-                    writer.BaseStream.Position = writer.BaseStream.Position - 1;
+                    writer.BaseStream.Position--;
                     writer.Write((byte)0);
                     binaryFormatter.Serialize(writer.BaseStream, e);
                 }
@@ -269,7 +269,6 @@ internal virtual void CreateFromStream(BinaryReader reader, Hashtable loggingTyp
                             resolver = null;
                         }
                     }
-                
             }
         }
         #endregion
diff --git a/src/Deprecated/Engine/Engine/NodeManager.cs b/src/Deprecated/Engine/Engine/NodeManager.cs
index 68183335a46..f153dc7e0cf 100644
--- a/src/Deprecated/Engine/Engine/NodeManager.cs
+++ b/src/Deprecated/Engine/Engine/NodeManager.cs
@@ -33,8 +33,8 @@ internal NodeManager(int cpuCount, bool childMode, Engine parentEngine)
             if (taskExecutionModule == null)
             {
                 taskExecutionModule = new TaskExecutionModule(parentEngine.EngineCallback,
-                    (cpuCount == 1 && !childMode ? TaskExecutionModule.TaskExecutionModuleMode.SingleProcMode :
-                                                   TaskExecutionModule.TaskExecutionModuleMode.MultiProcFullNodeMode), parentEngine.ProfileBuild);
+                    cpuCount == 1 && !childMode ? TaskExecutionModule.TaskExecutionModuleMode.SingleProcMode :
+                                                   TaskExecutionModule.TaskExecutionModuleMode.MultiProcFullNodeMode, parentEngine.ProfileBuild);
             }
         }
         #endregion
@@ -50,7 +50,7 @@ internal NodeManager(int cpuCount, bool childMode, Engine parentEngine)
         /// <returns></returns>
         internal bool RegisterNodeProvider(INodeProvider nodeProviderToRegister)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(nodeProviderToRegister,"nodeProviderToRegister");
+            ErrorUtilities.VerifyThrowArgumentNull(nodeProviderToRegister, nameof(nodeProviderToRegister));
 
             INodeDescription[] nodeDescriptions = nodeProviderToRegister.QueryNodeDescriptions();
 
@@ -135,7 +135,7 @@ internal NodeStatus[] RequestStatusForNodes(int responseTimeout)
                     // Calculate the time remaining and only continue if there is time left
                     TimeSpan timeSpent = new TimeSpan(DateTime.Now.Ticks - startTime);
                     startTime = DateTime.Now.Ticks;
-                    responseTimeout = responseTimeout - (int)timeSpent.TotalMilliseconds;
+                    responseTimeout -= (int)timeSpent.TotalMilliseconds;
                     if (responseTimeout <= 0)
                     {
                         Console.WriteLine("Response time out out exceeded :" + DateTime.Now.Ticks);
@@ -153,7 +153,6 @@ internal NodeStatus[] RequestStatusForNodes(int responseTimeout)
             return statusForNodes;
         }
 
-
         internal void PostNodeStatus(int nodeId, NodeStatus nodeStatus)
         {
             ErrorUtilities.VerifyThrow( nodeStatus.RequestId != NodeStatus.UnrequestedStatus,
@@ -174,7 +173,6 @@ internal void PostNodeStatus(int nodeId, NodeStatus nodeStatus)
             statusMessageReceived.Set();
         }
 
-
         internal void PostCycleNotification
         (
             int nodeId, 
diff --git a/src/Deprecated/Engine/Engine/Project.cs b/src/Deprecated/Engine/Engine/Project.cs
index 95a20a3e551..da38c4e5831 100644
--- a/src/Deprecated/Engine/Engine/Project.cs
+++ b/src/Deprecated/Engine/Engine/Project.cs
@@ -49,7 +49,7 @@ public enum PropertyPosition
         /// </summary>
         UseExistingOrCreateAfterLastImport = 1
     };
-    
+
     /// <summary>
     /// Whether we are in the first (properties) pass, or the second (items) pass.
     /// </summary>
@@ -62,7 +62,7 @@ internal enum ProcessingPass
         /// <summary>
         /// Second pass (evaluating items)
         /// </summary>
-        Pass2        
+        Pass2
     };
 
     /// <summary>
@@ -316,7 +316,7 @@ public class Project
 
         /// <summary>
         /// Items need the project directory in order to evaluate their built-in
-        /// metadata (like "%(FullPath)") when their itemspec is relative. We store this 
+        /// metadata (like "%(FullPath)") when their itemspec is relative. We store this
         /// here in thread-local-storage because we cannot modify the public constructors
         /// to require it, and also it can change during the life of a BuildItem
         /// (when the item is passed to another project).
@@ -381,7 +381,6 @@ string toolsVersion
                 this.mainProjectElement = mainProjectEntireContents.CreateElement(XMakeElements.project, XMakeAttributes.defaultXmlNamespace);
                 this.mainProjectEntireContents.AppendChild(mainProjectElement);
 
-
                 // initialize all case-insensitive hash-tables
                 this.conditionedPropertiesTable = new Hashtable(StringComparer.OrdinalIgnoreCase);
                 this.evaluatedItemsByName = new Hashtable(StringComparer.OrdinalIgnoreCase);
@@ -427,7 +426,7 @@ string toolsVersion
                 // If the toolsVersion is null, we will use the value specified in
                 // the Project element's ToolsVersion attribute, or else the default if that
                 // attribute is not present.
-                if (null != toolsVersion)
+                if (toolsVersion != null)
                 {
                     this.ToolsVersion = toolsVersion;
                 }
@@ -596,7 +595,7 @@ public string DefaultTargets
         }
 
         /// <summary>
-        /// Returns the array of actual target names that will be built by default. First choice is 
+        /// Returns the array of actual target names that will be built by default. First choice is
         /// the defaultTargets attribute on the Project node, if not present we fall back to the first target
         /// in the project file. Return value is null if there are no targets in the project file.
         /// </summary>
@@ -624,7 +623,7 @@ internal string[] DefaultBuildTargets
         /// Read-write accessor for the "InitialTargets" attribute of the
         /// &lt;Project&gt; element.  This is passed in and out as a semicolon-separated
         /// list of target names.  The "get" returns all of the initial targets in both
-        /// the main project and all imported projects (after property expansion).  The 
+        /// the main project and all imported projects (after property expansion).  The
         /// "set" only sets the initial targets for the main project.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -727,7 +726,6 @@ public bool IsValidated
             }
         }
 
-
         /// <summary>
         /// Is this project in the process of building?
         /// </summary>
@@ -794,12 +792,12 @@ public bool BuildEnabled
 
         /// <summary>
         /// When gotten, returns the effective tools version being used by this project.
-        /// If the tools version is being overridden, the overriding value will be the effective tools version. 
-        /// Otherwise, if there is a ToolsVersion attribute on the Project element, that is the effective tools version. 
+        /// If the tools version is being overridden, the overriding value will be the effective tools version.
+        /// Otherwise, if there is a ToolsVersion attribute on the Project element, that is the effective tools version.
         /// Otherwise, the default tools version of the parent engine is the effective tools version.
-        /// 
+        ///
         /// When set, overrides the current tools version of this project with the provided value.
-        /// 
+        ///
         /// NOTE: This is distinct to the ToolsVersion attribute, if any, on the Project element.
         /// To get and set the ToolsVersion attribute on the Project element use the Project.DefaultToolsVersion
         /// property.
@@ -845,14 +843,14 @@ internal bool OverridingToolsVersion
         }
 
         /// <summary>
-        /// Public read-write accessor for the ToolsVersion xml attribute found on the 
+        /// Public read-write accessor for the ToolsVersion xml attribute found on the
         /// &lt;Project /&gt; element.  If this attribute is not present on the &lt;Project/&gt;
         /// element, getting the value will return the default tools version of the parent Engine.
-        /// 
+        ///
         /// NOTE: This value is distinct from the effective tools version used during a build,
         /// as that value may be overridden during construction of the Project instance or
-        /// by setting the Project.ToolsVersion property. Setting this attribute value will not change the 
-        /// effective tools version if it has been overridden. To change the effective tools version, 
+        /// by setting the Project.ToolsVersion property. Setting this attribute value will not change the
+        /// effective tools version if it has been overridden. To change the effective tools version,
         /// set the Project.ToolsVersion property.
         /// </summary>
         public string DefaultToolsVersion
@@ -903,7 +901,7 @@ public string DefaultToolsVersion
                 // version is actually valid
                 ProjectElement.SetAttribute(XMakeAttributes.toolsVersion, value);
 
-                if (overridingToolsVersion == false)
+                if (!overridingToolsVersion)
                 {
                     this.toolsVersion = DefaultToolsVersion;
                 }
@@ -960,7 +958,7 @@ internal ITaskRegistry TaskRegistry
         }
 
         /// <summary>
-        /// The project directory where the project file is in, this can be empty if the project is constructed in memory and does 
+        /// The project directory where the project file is in, this can be empty if the project is constructed in memory and does
         /// not come from a file location
         /// </summary>
         internal string ProjectDirectory
@@ -1018,10 +1016,7 @@ public BuildPropertyGroup GlobalProperties
                 // the XML every time any property value changes.
 
                 // Unhook the old globalProperties from this project.
-                if (globalProperties != null)
-                {
-                    globalProperties.ClearParentProject();
-                }
+                globalProperties?.ClearParentProject();
 
                 globalProperties = value.Clone(true);
 
@@ -1356,7 +1351,7 @@ private XmlDeclaration XmlDeclarationNode
         {
             get
             {
-                if (mainProjectEntireContents != null && mainProjectEntireContents.HasChildNodes)
+                if (mainProjectEntireContents?.HasChildNodes == true)
                 {
                     return mainProjectEntireContents.FirstChild as XmlDeclaration;
                 }
@@ -1421,7 +1416,7 @@ public string GetEvaluatedProperty(string propertyName)
 
             // Project system needs to know the difference between a property not existing,
             // a property that is set to empty string.
-            return (property == null) ? null : property.FinalValue;
+            return property?.FinalValue;
         }
 
         /// <summary>
@@ -1450,7 +1445,7 @@ private void SetDefaultTargets(string defaultTargetsList, BuildPropertyGroup pro
 
         /// <summary>
         /// Determines whether a project file can be considered equivalent to this Project, taking into account
-        /// the set of global properties and the tools version (if any) that that project file 
+        /// the set of global properties and the tools version (if any) that that project file
         /// is going to be built with.
         /// </summary>
         /// <param name="projectFullPath"></param>
@@ -1459,7 +1454,7 @@ private void SetDefaultTargets(string defaultTargetsList, BuildPropertyGroup pro
         /// <returns></returns>
         internal bool IsEquivalentToProject(string projectFullPath, BuildPropertyGroup projectGlobalProperties, string projectToolsVersion)
         {
-            if (String.Compare(projectFullPath, this.FullFileName, StringComparison.OrdinalIgnoreCase) != 0)
+            if (!String.Equals(projectFullPath, this.FullFileName, StringComparison.OrdinalIgnoreCase))
             {
                 return false;
             }
@@ -1473,8 +1468,8 @@ internal bool IsEquivalentToProject(string projectFullPath, BuildPropertyGroup p
                 projectToolsVersion = this.DefaultToolsVersion;
             }
 
-            return (String.Compare(ToolsVersion, projectToolsVersion, StringComparison.OrdinalIgnoreCase) == 0
-                && this.GlobalProperties.IsEquivalent(projectGlobalProperties));
+            return String.Equals(ToolsVersion, projectToolsVersion, StringComparison.OrdinalIgnoreCase)
+                && this.GlobalProperties.IsEquivalent(projectGlobalProperties);
         }
 
         /// <summary>
@@ -1672,7 +1667,7 @@ private void SetProjectFileReservedProperties
             this.ReservedProperties.SetProperty(new BuildProperty(ReservedPropertyNames.programFiles32,
                     FrameworkLocationHelper.programFiles32, PropertyType.ReservedProperty));
 
-            this.ReservedProperties.SetProperty(new BuildProperty(ReservedPropertyNames.assemblyVersion, 
+            this.ReservedProperties.SetProperty(new BuildProperty(ReservedPropertyNames.assemblyVersion,
                     Constants.AssemblyVersion, PropertyType.ReservedProperty));
 
             if (this.fullFileName.Length == 0)
@@ -1714,7 +1709,6 @@ private void SetProjectFileReservedProperties
 
                 this.ReservedProperties.SetProperty(new BuildProperty(ReservedPropertyNames.projectDirectoryNoRoot,
                     EscapingUtilities.Escape(projectDirectoryNoRoot), PropertyType.ReservedProperty));
-                
             }
 
             this.projectDirectory = this.ReservedProperties[ReservedPropertyNames.projectDirectory].FinalValue;
@@ -1788,7 +1782,7 @@ internal void Load
             ProjectLoadSettings projectLoadSettings
         )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFileName, "projectFileName");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFileName, nameof(projectFileName));
             ErrorUtilities.VerifyThrowArgument(projectFileName.Length > 0, "EmptyProjectFileName");
             ErrorUtilities.VerifyThrowArgument(File.Exists(projectFileName), "ProjectFileNotFound", projectFileName);
 
@@ -1827,7 +1821,6 @@ ProjectLoadSettings projectLoadSettings
                         // on <MSBuild> task tags, and what MSBuildToolsPath to use when scanning child projects
                         // for dependency information.
                         SolutionWrapperProject.Generate(sp, this, toolsVersion, buildEventContext);
-
                     }
                     else if (IsVCProjFilename(projectFileName))
                     {
@@ -1852,7 +1845,6 @@ ProjectLoadSettings projectLoadSettings
                         InternalLoadFromXmlDocument(projectDocument, projectLoadSettings);
                     }
 
-
                     // This project just came off the disk, so it is certainly not dirty yet.
                     this.dirtyNeedToSaveProjectFile = false;
                 }
@@ -1936,7 +1928,7 @@ public void Load
             ProjectLoadSettings projectLoadSettings
         )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(textReader, "textReader");
+            ErrorUtilities.VerifyThrowArgumentNull(textReader, nameof(textReader));
 
             try
             {
@@ -1988,7 +1980,7 @@ public void LoadXml
             ProjectLoadSettings projectLoadSettings
         )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectXml, "projectXml");
+            ErrorUtilities.VerifyThrowArgumentNull(projectXml, nameof(projectXml));
 
             try
             {
@@ -2019,7 +2011,6 @@ ProjectLoadSettings projectLoadSettings
             }
         }
 
-
         /// <summary>
         /// Reads in the contents of this project from an in-memory XmlDocument handed to us.
         /// </summary>
@@ -2031,7 +2022,7 @@ internal void LoadFromXmlDocument
             ProjectLoadSettings projectLoadSettings
             )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectXml, "projectXml");
+            ErrorUtilities.VerifyThrowArgumentNull(projectXml, nameof(projectXml));
 
             try
             {
@@ -2086,7 +2077,7 @@ private void InternalLoadFromXmlDocument(XmlDocument projectXml, ProjectLoadSett
                 ProjectErrorUtilities.VerifyThrowInvalidProject(this.mainProjectElement.LocalName == XMakeElements.project,
                     this.mainProjectElement, "UnrecognizedElement", this.mainProjectElement.Name);
 
-                ProjectErrorUtilities.VerifyThrowInvalidProject((mainProjectElement.Prefix.Length == 0) && (String.Compare(mainProjectElement.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase) == 0),
+                ProjectErrorUtilities.VerifyThrowInvalidProject((mainProjectElement.Prefix.Length == 0) && (String.Equals(mainProjectElement.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase)),
                     mainProjectElement, "ProjectMustBeInMSBuildXmlNamespace", XMakeAttributes.defaultXmlNamespace);
 
                 MarkProjectAsDirtyForReprocessXml();
@@ -2103,7 +2094,6 @@ private void InternalLoadFromXmlDocument(XmlDocument projectXml, ProjectLoadSett
                 }
                 throw;
             }
-
         }
 
         /// <summary>
@@ -2153,7 +2143,7 @@ Encoding encoding
 
                 // Update the project filename/path if it has changed.
                 string newFullProjectFilePath = Path.GetFullPath(projectFileName);
-                if (0 != String.Compare(newFullProjectFilePath, this.FullFileName, StringComparison.OrdinalIgnoreCase))
+                if (!String.Equals(newFullProjectFilePath, this.FullFileName, StringComparison.OrdinalIgnoreCase))
                 {
                     this.FullFileName = newFullProjectFilePath;
                 }
@@ -2368,7 +2358,7 @@ PropertyPosition position
         }
 
         /// <summary>
-        /// Sets a property, and optionally escapes it so that it will be treated as a literal 
+        /// Sets a property, and optionally escapes it so that it will be treated as a literal
         /// value despite any special characters that may be in it.
         /// </summary>
         /// <param name="propertyName"></param>
@@ -2386,7 +2376,7 @@ public void SetProperty
             bool treatPropertyValueAsLiteral
             )
         {
-            this.SetProperty(propertyName, 
+            this.SetProperty(propertyName,
                 treatPropertyValueAsLiteral ? EscapingUtilities.Escape(propertyValue) : propertyValue,
                 condition, position);
         }
@@ -2465,7 +2455,7 @@ PropertyPosition position
         )
         {
             // Property name must be non-empty.
-            error.VerifyThrowArgumentLength(propertyName, "propertyName");
+            error.VerifyThrowArgumentLength(propertyName, nameof(propertyName));
 
             // Property value must be non-null.
             error.VerifyThrowArgument(propertyValue != null,
@@ -2513,7 +2503,6 @@ PropertyPosition position
                         matchingPropertyGroup = this.AddNewPropertyGroup(afterImportPosition);
                         matchingPropertyGroup.Condition = condition;
                     }
-
                 }
 
                 if (importedProperty)
@@ -2565,8 +2554,8 @@ ref BuildProperty matchingProperty
                 }
 
                 if (propertyGroup.IsImported == importedPropertyGroup &&
-                    (0 == String.Compare(propertyGroup.Condition.Trim(), condition.Trim(), StringComparison.OrdinalIgnoreCase)) &&
-                    (!importedPropertyGroup || (importedPropertyGroup && (0 == String.Compare(propertyGroup.ImportedFromFilename, importedFilename, StringComparison.OrdinalIgnoreCase)))))
+                    (String.Equals(propertyGroup.Condition.Trim(), condition.Trim(), StringComparison.OrdinalIgnoreCase)) &&
+                    (!importedPropertyGroup || (importedPropertyGroup && (String.Equals(propertyGroup.ImportedFromFilename, importedFilename, StringComparison.OrdinalIgnoreCase)))))
                 {
                     if (matchingPropertyGroup == null)
                     {
@@ -2581,7 +2570,7 @@ ref BuildProperty matchingProperty
                     // property.
                     foreach (BuildProperty property in propertyGroup)
                     {
-                        if (0 == String.Compare(property.Name, propertyName, StringComparison.OrdinalIgnoreCase))
+                        if (String.Equals(property.Name, propertyName, StringComparison.OrdinalIgnoreCase))
                         {
                             matchingProperty = property;
                         }
@@ -2644,7 +2633,7 @@ public void RemovePropertyGroup
             BuildPropertyGroup propertyGroupToRemove
         )
         {
-            error.VerifyThrowArgumentNull(propertyGroupToRemove, "propertyGroupToRemove");
+            error.VerifyThrowArgumentNull(propertyGroupToRemove, nameof(propertyGroupToRemove));
 
             // Confirm that it's not an imported property group.
             error.VerifyThrowInvalidOperation(!propertyGroupToRemove.IsImported,
@@ -2679,7 +2668,7 @@ public void RemoveImportedPropertyGroup
             BuildPropertyGroup propertyGroupToRemove
         )
         {
-            error.VerifyThrowArgumentNull(propertyGroupToRemove, "propertyGroupToRemove");
+            error.VerifyThrowArgumentNull(propertyGroupToRemove, nameof(propertyGroupToRemove));
 
             // Confirm that it's actually a persisted BuildPropertyGroup in the current project.
             error.VerifyThrowInvalidOperation(
@@ -2793,8 +2782,8 @@ public BuildItem AddNewItem
             string itemInclude
             )
         {
-            ErrorUtilities.VerifyThrowArgumentLength(itemName, "itemName");
-            ErrorUtilities.VerifyThrowArgumentLength(itemInclude, "itemInclude");
+            ErrorUtilities.VerifyThrowArgumentLength(itemName, nameof(itemName));
+            ErrorUtilities.VerifyThrowArgumentLength(itemInclude, nameof(itemInclude));
 
             BuildItemGroup matchingItemGroup = null;
 
@@ -2814,7 +2803,7 @@ string itemInclude
                     // the same type as the new item being added.
                     foreach (BuildItem originalItem in itemGroup)
                     {
-                        if ( 0 == String.Compare( originalItem.Name, itemName, StringComparison.OrdinalIgnoreCase))
+                        if ( String.Equals( originalItem.Name, itemName, StringComparison.OrdinalIgnoreCase))
                         {
                             // If the new item that the user is trying to add is already covered by 
                             // a wildcard in an existing item of the project, then there's really
@@ -2932,7 +2921,7 @@ public void RemoveItemGroup
             BuildItemGroup itemGroupToRemove
         )
         {
-            error.VerifyThrowArgumentNull(itemGroupToRemove, "itemGroupToRemove");
+            error.VerifyThrowArgumentNull(itemGroupToRemove, nameof(itemGroupToRemove));
 
             // Confirm that it's not an imported item group.
             error.VerifyThrowInvalidOperation(!itemGroupToRemove.IsImported,
@@ -2981,7 +2970,7 @@ public void RemoveItem
             BuildItem itemToRemove
         )
         {
-            error.VerifyThrowArgumentNull(itemToRemove, "itemToRemove");
+            error.VerifyThrowArgumentNull(itemToRemove, nameof(itemToRemove));
 
             // Confirm that it's not an imported item.
             error.VerifyThrowInvalidOperation(!itemToRemove.IsImported, "CannotModifyImportedProjects");
@@ -3176,7 +3165,7 @@ public bool Build
             string targetName
             )
         {
-            return this.ParentEngine.BuildProject(this, (targetName == null) ? null : new string[] {targetName}, 
+            return this.ParentEngine.BuildProject(this, (targetName == null) ? null : new string[] {targetName},
                 null, BuildSettings.None);
         }
 
@@ -3312,7 +3301,7 @@ internal void ContinueBuild(ProjectBuildState buildContext, TaskExecutionContext
                 else if (buildContext.CurrentBuildContextState == ProjectBuildState.BuildContextState.CycleDetected)
                 {
                     ErrorUtilities.VerifyThrow(
-                        taskExecutionContext != null && taskExecutionContext.ParentTarget != null,
+                        taskExecutionContext?.ParentTarget != null,
                         "Unexpected task context. Should not be null");
                     // Check that the target is in progress
                     ErrorUtilities.VerifyThrow(
@@ -3358,8 +3347,7 @@ internal void ContinueBuild(ProjectBuildState buildContext, TaskExecutionContext
                             while (buildContext.NameOfBlockingTarget != null)
                             {
                                 Target blockingTarget = GetTargetForName(buildContext.NameOfBlockingTarget);
-                                if (blockingTarget.ExecutionState != null &&
-                                    blockingTarget.ExecutionState.BuildingRequiredTargets)
+                                if (blockingTarget.ExecutionState?.BuildingRequiredTargets == true)
                                 {
                                     blockingTarget.ContinueBuild(buildContext, null);
                                 }
@@ -3367,14 +3355,12 @@ internal void ContinueBuild(ProjectBuildState buildContext, TaskExecutionContext
                                 buildContext.RemoveBlockingTarget();
                             }
                             Target inprogressTarget = GetTargetForName(buildContext.NameOfTargetInProgress);
-                            if (inprogressTarget.ExecutionState != null &&
-                                inprogressTarget.ExecutionState.BuildingRequiredTargets)
+                            if (inprogressTarget.ExecutionState?.BuildingRequiredTargets == true)
                             {
                                 inprogressTarget.ContinueBuild(buildContext, null);
                             }
                         }
 
-
                         buildContext.CurrentBuildContextState = ProjectBuildState.BuildContextState.BuildComplete;
                     }
 
@@ -3428,7 +3414,7 @@ internal void CalculateNextActionForProjectContext(ProjectBuildState buildContex
                 recalculateAction = false;
 
                 // Check if there is a dependent target
-                Target currentTarget = null;
+                Target currentTarget;
                 if (buildContext.NameOfBlockingTarget != null)
                 {
                     currentTarget = GetTargetForName(buildContext.NameOfBlockingTarget);
@@ -3491,7 +3477,7 @@ internal void CalculateNextActionForProjectContext(ProjectBuildState buildContex
 
         private void ExecuteNextActionForProjectContext(ProjectBuildState buildContext, bool initialCall)
         {
-            Target nextTarget = null;
+            Target nextTarget;
             if (buildContext.NameOfBlockingTarget != null)
             {
                 // Notify the next target in depends on/on error stack
@@ -3534,7 +3520,7 @@ private ProjectBuildState InitializeForBuildingTargets(BuildRequest buildRequest
             ProjectBuildState buildContext = null;
 
             string[] targetNamesToBuild = buildRequest.TargetNames;
-            
+
             // Initialize to the parent requests project context id
             int projectContextId = buildRequest.ParentBuildEventContext.ProjectContextId;
 
@@ -3579,9 +3565,9 @@ private ProjectBuildState InitializeForBuildingTargets(BuildRequest buildRequest
                 // Only log the project started event after making sure the project is reevaluated if necessary,
                 // otherwise we could log stale item/property information.
                 if (!ParentEngine.LoggingServices.OnlyLogCriticalEvents && buildRequest.FireProjectStartedFinishedEvents)
-                {  
+                {
                     string joinedTargetNamesToBuild = null;
-                    if (targetNamesToBuild != null && targetNamesToBuild.Length > 0)
+                    if (targetNamesToBuild?.Length > 0)
                     {
                         joinedTargetNamesToBuild = EscapingUtilities.UnescapeAll(String.Join(";", targetNamesToBuild));
                     }
@@ -3603,7 +3589,7 @@ private ProjectBuildState InitializeForBuildingTargets(BuildRequest buildRequest
 
                         // Get the list of properties to serialize to the parent node
                         string[] propertyListToSerialize = parentEngine.PropertyListToSerialize;
-                        if (propertyListToSerialize != null && propertyListToSerialize.Length > 0)
+                        if (propertyListToSerialize?.Length > 0)
                         {
                             foreach (string propertyToGet in propertyListToSerialize)
                             {
@@ -3622,7 +3608,7 @@ private ProjectBuildState InitializeForBuildingTargets(BuildRequest buildRequest
                     BuildItemGroupProxy itemsProxy = new BuildItemGroupProxy(this.evaluatedItems);
 
                     ParentEngine.LoggingServices.LogProjectStarted(this.projectId, buildRequest.ParentBuildEventContext, buildEventContext, FullFileName, joinedTargetNamesToBuild, propertiesProxy, itemsProxy);
-                    
+
                     // See comment on DefaultToolsVersion setter.
                     if (treatinghigherToolsVersionsAs40)
                     {
@@ -3744,7 +3730,7 @@ private void ProcessMainProjectElement
             // Technically, this belongs in ProcessProjectAttributes. However, ToolsVersion
             // affects strategic reserved properties, so it's better to process it before anything else happens
             ProcessToolsVersionDependentProperties();
-            
+
             if (IsValidated)
             {
                 // Validate the project schema. If we have a file, then validate that
@@ -3779,12 +3765,12 @@ private void ProcessMainProjectElement
             // variables ... so we need to set these up early.
             this.evaluatedProperties.Clear();
             this.evaluatedProperties.ImportInitialProperties(this.EnvironmentProperties, this.ReservedProperties, this.Toolset.BuildProperties, this.GlobalProperties);
-            
+
             // Process the attributes of the <project> element.
             ProcessProjectAttributes(this.mainProjectElement, false);
 
             // Figure out where the project is located
-            this.projectDirectory = !string.IsNullOrEmpty(this.fullFileName) ? 
+            this.projectDirectory = !string.IsNullOrEmpty(this.fullFileName) ?
                 Path.GetDirectoryName(this.fullFileName) : Directory.GetCurrentDirectory();
 
             // Process the child elements of the <Project> element, instantiating
@@ -3987,7 +3973,7 @@ bool importedProject
                         case XMakeElements.projectExtensions:
                             if (!importedProject)
                             {
-                                ProjectErrorUtilities.VerifyThrowInvalidProject(null == this.projectExtensionsNode, childElement,
+                                ProjectErrorUtilities.VerifyThrowInvalidProject(this.projectExtensionsNode == null, childElement,
                                     "DuplicateProjectExtensions");
                                 this.projectExtensionsNode = childElement;
 
@@ -4037,7 +4023,6 @@ bool importedProject
             }
         }
 
-
         /// <summary>
         /// Process the &lt;Import&gt; element by loading the child project file, and processing its &lt;Project&gt; element. In a
         /// given main project, the same file cannot be imported twice -- this is to prevent circular imports.
@@ -4060,8 +4045,8 @@ bool        importedProject
                 // Do not expand properties or items before passing in the value of the
                 // condition attribute to EvaluateCondition, otherwise special characters
                 // inside the property values can really confuse the condition parser.
-                if (!Utilities.EvaluateCondition(temp.Condition, temp.ConditionAttribute, 
-                    new Expander(this.evaluatedProperties), this.conditionedPropertiesTable, 
+                if (!Utilities.EvaluateCondition(temp.Condition, temp.ConditionAttribute,
+                    new Expander(this.evaluatedProperties), this.conditionedPropertiesTable,
                     ParserOptions.AllowProperties, ParentEngine.LoggingServices, projectBuildEventContext))
                 {
                     return;
@@ -4073,15 +4058,14 @@ bool        importedProject
 
             // Expand any $(propertyname) references inside the "Project" attribute value.
             string expandedImportedFilename = (new Expander(this.evaluatedProperties)).ExpandAllIntoStringLeaveEscaped(temp.ProjectPath, temp.ProjectPathAttribute);
-            
+
             // Expand any wildcards
             string[] importedFilenames = EngineFileUtilities.GetFileListEscaped(projectDirectoryLocation, expandedImportedFilename);
 
             for (int i = 0; i < importedFilenames.Length; i++)
             {
-                string importedFilename = EscapingUtilities.UnescapeAll(importedFilenames[i]);
-                         
-                ProjectErrorUtilities.VerifyThrowInvalidProject((importedFilename != null) && (importedFilename.Length != 0),
+                string importedFilename = EscapingUtilities.UnescapeAll(importedFilenames[i]);     
+                ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(importedFilename),
                     importElement, "MissingRequiredAttribute",
                     XMakeAttributes.project, XMakeElements.import);
 
@@ -4132,10 +4116,9 @@ bool        importedProject
                             ProjectErrorUtilities.VerifyThrowInvalidProject(importedChildNode.LocalName == XMakeElements.project,
                                 importedChildNode, "UnrecognizedElement", importedChildNode.Name);
 
-                            ProjectErrorUtilities.VerifyThrowInvalidProject((importedChildNode.Prefix.Length == 0) && (String.Compare(importedChildNode.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase) == 0),
+                            ProjectErrorUtilities.VerifyThrowInvalidProject((importedChildNode.Prefix.Length == 0) && (String.Equals(importedChildNode.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase)),
                                 importedChildNode, "ProjectMustBeInMSBuildXmlNamespace", XMakeAttributes.defaultXmlNamespace);
 
-
                             // We have the <Project> element, so process it.
                             this.ProcessProjectAttributes((XmlElement)importedChildNode,
                                 /* imported project */ true);
@@ -4175,7 +4158,7 @@ private XmlDocument LoadImportedProject(Import import)
             // also prevents the same file from being imported twice, even it it's not a
             // circular dependency, but that's fine -- no good reason to do that anyway.
             if ((this.imports[import.EvaluatedProjectPath] != null) ||
-                (string.Compare(this.FullFileName, import.EvaluatedProjectPath, StringComparison.OrdinalIgnoreCase) == 0))
+                (string.Equals(this.FullFileName, import.EvaluatedProjectPath, StringComparison.OrdinalIgnoreCase)))
             {
                 ParentEngine.LoggingServices.LogWarning(projectBuildEventContext, Utilities.CreateBuildEventFileInfo(import.ProjectPathAttribute, FullFileName),
                     "DuplicateImport", import.EvaluatedProjectPath);
@@ -4200,9 +4183,9 @@ private XmlDocument LoadImportedProject(Import import)
                         // look up the engine's cache to see if we've already loaded this imported project on behalf of another
                         // top-level project
                         ImportedProject previouslyImportedProject = (ImportedProject)ParentEngine.ImportedProjectsCache[import.EvaluatedProjectPath];
-                        
+
                         // if this project hasn't been imported before, or if it has changed on disk, we need to load it
-                        if ((previouslyImportedProject == null) || previouslyImportedProject.HasChangedOnDisk(import.EvaluatedProjectPath))
+                        if ((previouslyImportedProject?.HasChangedOnDisk(import.EvaluatedProjectPath) != false))
                         {
                             try
                             {
@@ -4267,7 +4250,7 @@ internal void OnRenameOfImportedFile(string oldFileName, string newFileName)
                 {
                     // ... then check the filename of the PropertyGroup to see if it
                     // matches the *old* file name.
-                    if (0 == String.Compare(pg.ImportedFromFilename, oldFileName, StringComparison.OrdinalIgnoreCase))
+                    if (String.Equals(pg.ImportedFromFilename, oldFileName, StringComparison.OrdinalIgnoreCase))
                     {
                         // Okay, we found a PropertyGroup that appears to have originated from
                         // the imported file that just got renamed.  We should update the PropertyGroup
@@ -4310,7 +4293,6 @@ private void EvaluateProject(bool currentlyLoading)
                     // on conditions to work correctly, and for wildcards to evaluate relative to the project directory.
                     Project.PerThreadProjectDirectory = this.ProjectDirectory;
 
-
                     // In case we've just loaded the project file, we don't want to repeat all
                     // of the work done during ProcessProjectChildren(...) to evaluate the
                     // properties.
@@ -4446,7 +4428,7 @@ private void EvaluateAllUsingTasks()
         }
 
         /// <summary>
-        /// Adds an item to the appropriate project's evaluated items collection.  This method is 
+        /// Adds an item to the appropriate project's evaluated items collection.  This method is
         /// NOT to be used during the build process to add items that are emitted by tasks.
         /// This is only for the purposes of adding statically-declared items in the logical
         /// project file, or items added to the project file by an IDE modifying the project contents.
@@ -4473,7 +4455,7 @@ internal void AddToItemListByNameIgnoringCondition(BuildItem item)
         }
 
         /// <summary>
-        /// Adds an item to the appropriate project's evaluated items collection.  This method is 
+        /// Adds an item to the appropriate project's evaluated items collection.  This method is
         /// NOT to be used during the build process to add items that are emitted by tasks.
         /// This is only for the purposes of adding statically-declared items in the logical
         /// project file, or items added to the project file by an IDE modifying the project contents.
@@ -4508,7 +4490,7 @@ internal void AddToItemListByName(BuildItem item)
         /// <owner>jomof</owner>
         internal static bool IsSolutionFilename(string filename)
         {
-            return (string.Compare(Path.GetExtension(filename), ".sln", StringComparison.OrdinalIgnoreCase) == 0);
+            return string.Equals(Path.GetExtension(filename), ".sln", StringComparison.OrdinalIgnoreCase);
         }
 
         /// <summary>
@@ -4517,7 +4499,7 @@ internal static bool IsSolutionFilename(string filename)
         /// <owner>LukaszG</owner>
         internal static bool IsVCProjFilename(string filename)
         {
-            return (string.Compare(Path.GetExtension(filename), ".vcproj", StringComparison.OrdinalIgnoreCase) == 0);
+            return string.Equals(Path.GetExtension(filename), ".vcproj", StringComparison.OrdinalIgnoreCase);
         }
     }
 }
diff --git a/src/Deprecated/Engine/Engine/ProjectBuildState.cs b/src/Deprecated/Engine/Engine/ProjectBuildState.cs
index f21598c28a5..5f1aadea672 100644
--- a/src/Deprecated/Engine/Engine/ProjectBuildState.cs
+++ b/src/Deprecated/Engine/Engine/ProjectBuildState.cs
@@ -89,8 +89,8 @@ internal string NameOfBlockingTarget
         {
             get
             {
-                return (requiredTargets != null && requiredTargets.Count > 0 ?
-                        this.requiredTargets.Peek() : null);
+                return requiredTargets?.Count > 0 ?
+                        this.requiredTargets.Peek() : null;
             }
         }
 
@@ -138,7 +138,7 @@ internal string GetNextTarget()
         {
             if ((indexOfTargetInProgress + 1) < targetNamesToBuild.Count)
             {
-                indexOfTargetInProgress = indexOfTargetInProgress + 1;
+                indexOfTargetInProgress++;
                 return (string)targetNamesToBuild[indexOfTargetInProgress];
             }
             else
@@ -199,17 +199,17 @@ internal void RecordBuildException()
         internal bool ContainsCycle(string name)
         {
             bool containsCycle = false;
-            if (requiredTargets != null && requiredTargets.Count > 1)
+            if (requiredTargets?.Count > 1)
             {
                 string topTarget = requiredTargets.Pop();
                 ErrorUtilities.VerifyThrow(topTarget == name, "Requesting target should be on the top of stack");
                 containsCycle = requiredTargets.Contains(name);
                 requiredTargets.Push(topTarget);
             }
-            if (!containsCycle && requiredTargets != null && requiredTargets.Count > 0)
+            if (!containsCycle && requiredTargets?.Count > 0)
             {
                 containsCycle = 
-                    (String.Compare(name, (string)targetNamesToBuild[indexOfTargetInProgress], StringComparison.OrdinalIgnoreCase) == 0);
+                    (String.Equals(name, (string)targetNamesToBuild[indexOfTargetInProgress], StringComparison.OrdinalIgnoreCase));
             }
             return containsCycle;
         }
@@ -221,7 +221,7 @@ internal bool ContainsCycle(string name)
         internal bool ContainsBlockingTarget(string name)
         {
             bool containsName = false;
-            if (requiredTargets != null && requiredTargets.Count > 0)
+            if (requiredTargets?.Count > 0)
             {
                 containsName = requiredTargets.Contains(name);
             }
@@ -237,7 +237,7 @@ internal bool ContainsBlockingTarget(string name)
         internal string GetParentTarget(string name)
         {
             string parentName = null;
-            if (requiredTargets != null && requiredTargets.Count > 0)
+            if (requiredTargets?.Count > 0)
             {
                 parentName = (string)targetNamesToBuild[indexOfTargetInProgress];
 
diff --git a/src/Deprecated/Engine/Engine/ProjectManager.cs b/src/Deprecated/Engine/Engine/ProjectManager.cs
index 234a362b835..ba497699405 100644
--- a/src/Deprecated/Engine/Engine/ProjectManager.cs
+++ b/src/Deprecated/Engine/Engine/ProjectManager.cs
@@ -156,7 +156,7 @@ string projectFileFullPath
             // Get the list of projects that have this full path.
             ArrayList projectsWithThisFullPath = (ArrayList) this.projects[projectFileFullPath];
 
-            if ((projectsWithThisFullPath != null) && (projectsWithThisFullPath.Count > 0))
+            if ((projectsWithThisFullPath?.Count > 0))
             {
                 return (Project) projectsWithThisFullPath[0];
             }
@@ -396,7 +396,7 @@ internal static ProjectEntry GetProjectEntry(Hashtable entryTable, string projec
                 // Loop through them and find the one with the matching set of global properties.
                 foreach (ProjectEntry projectEntry in projectsWithFullPath)
                 {
-                    if ((String.Compare(projectEntry.toolsVersion, toolsVersion, StringComparison.OrdinalIgnoreCase) == 0) &&
+                    if ((String.Equals(projectEntry.toolsVersion, toolsVersion, StringComparison.OrdinalIgnoreCase)) &&
                         projectEntry.globalProperties.IsEquivalent(globalProperties))
                     {
                         return projectEntry;
diff --git a/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs b/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs
index 11401822424..ab4840d7004 100644
--- a/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs
+++ b/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs
@@ -113,9 +113,9 @@ string projectFile
             XmlReaderSettings validatorSettings = new XmlReaderSettings();
             validatorSettings.ValidationType = ValidationType.Schema;
             validatorSettings.XmlResolver = null;
-            validatorSettings.ValidationEventHandler += new ValidationEventHandler(this.OnSchemaValidationError);
+            validatorSettings.ValidationEventHandler += this.OnSchemaValidationError;
             
-            if ((schemaFile == null) || (schemaFile.Length == 0))
+            if (string.IsNullOrEmpty(schemaFile))
             {
                 schemaFile = Path.Combine(binPath, "Microsoft.Build.xsd");
             }
diff --git a/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs b/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
index 9d392e957cf..e6e4d42be8e 100644
--- a/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
+++ b/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
@@ -56,8 +56,8 @@ internal RegistryKeyWrapper(string registryKeyPath)
         /// <param name="registryHive"></param>
         internal RegistryKeyWrapper(string registryKeyPath, RegistryKey registryHive)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(registryKeyPath, "registryKeyPath");
-            ErrorUtilities.VerifyThrowArgumentNull(registryHive, "registryHive");
+            ErrorUtilities.VerifyThrowArgumentNull(registryKeyPath, nameof(registryKeyPath));
+            ErrorUtilities.VerifyThrowArgumentNull(registryHive, nameof(registryHive));
 
             this.registryKeyPath = registryKeyPath;
             this.registryHive = registryHive;
@@ -150,7 +150,7 @@ public virtual string[] GetSubKeyNames()
         /// <returns></returns>
         public virtual RegistryKeyWrapper OpenSubKey(string name)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
             
             RegistryKeyWrapper wrapper = this;
             string[] keyNames = name.Split(new char[] { '\\' }, StringSplitOptions.RemoveEmptyEntries);
@@ -179,7 +179,7 @@ public virtual RegistryKeyWrapper OpenSubKey(string name)
         /// <returns></returns>
         public virtual bool Exists()
         {
-            return (null != WrappedKey);
+            return WrappedKey != null;
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Engine/Router.cs b/src/Deprecated/Engine/Engine/Router.cs
index 7e61058766d..651b7a8ed9e 100644
--- a/src/Deprecated/Engine/Engine/Router.cs
+++ b/src/Deprecated/Engine/Engine/Router.cs
@@ -85,7 +85,7 @@ internal bool SingleThreadedMode
         {
             get
             {
-                return (!childMode && nodeManager.MaxNodeCount == 1);
+                return !childMode && nodeManager.MaxNodeCount == 1;
             }
         }
 
@@ -131,12 +131,12 @@ internal void PostDoneNotice(BuildRequest buildRequest)
         /// </summary>
         internal void PostDoneNotice(int nodeId, BuildResult buildResult)
         {
-            if (scheduler != null)
-            {
+               
+            
                 // Notify the scheduler that a given node(nodeId) will be getting a buildResult.
                 // This method is a no-op if the router is on a child process
-                scheduler.NotifyOfBuildResult(nodeId, buildResult);
-            }
+                scheduler?.NotifyOfBuildResult(nodeId, buildResult);
+            
 
             if (nodeId == EngineCallback.inProcNode)
             {
@@ -179,12 +179,12 @@ internal void PostBuildRequest(BuildRequest currentRequest, int nodeIndex)
                                     (nodeIndex, currentRequest.HandleId, currentRequest.NodeIndex,
                                      currentRequest.RequestId, cacheScope, currentRequest, null);
 
-                    if (scheduler != null)
-                    {
+                       
+                    
                         // Check to see if we need to change the traversal strategy of the system
                         // parentHandleId and node index are not used in the function so it can be ignored
-                        scheduler.NotifyOfBuildRequest(nodeIndex, currentRequest, parentHandleId);
-                    }
+                        scheduler?.NotifyOfBuildRequest(nodeIndex, currentRequest, parentHandleId);
+                    
                     
                     nodeManager.PostBuildRequestToNode(nodeIndex, currentRequest);
                 }
diff --git a/src/Deprecated/Engine/Engine/Scheduler.cs b/src/Deprecated/Engine/Engine/Scheduler.cs
index f872023873d..d2a36cab2cf 100644
--- a/src/Deprecated/Engine/Engine/Scheduler.cs
+++ b/src/Deprecated/Engine/Engine/Scheduler.cs
@@ -100,7 +100,6 @@ internal int CalculateNodeForBuildRequest(BuildRequest currentRequest, int nodeI
                 // If we have not chosen an node yet, this can happen if the node was loaded previously on a child node
                 if (nodeUsed == EngineCallback.invalidNode)
                 {
-                    
                     if (useLoadBalancing)
                     {
                         #region UseLoadBalancing
@@ -157,11 +156,11 @@ internal int CalculateNodeForBuildRequest(BuildRequest currentRequest, int nodeI
                         }
                         #endregion
                     }
-                    else 
+                    else
                     {
                         // round robin schedule the build request 
                         nodeUsed = (lastUsedNode % nodes.Length);
-                        
+
                         // Running total of the number of times this round robin scheduler has been called
                         lastUsedNode++;
 
@@ -210,7 +209,7 @@ internal void NotifyOfSchedulingDecision(BuildRequest currentRequest, int nodeUs
             // Update the records
             ScheduleRecordKey recordKey = new ScheduleRecordKey(currentRequest.HandleId, currentRequest.RequestId);
             ScheduleRecordKey parentKey = new ScheduleRecordKey(currentRequest.ParentHandleId, currentRequest.ParentRequestId);
-            ScheduleRecord record = new ScheduleRecord(recordKey, parentKey, nodeUsed, currentRequest.ProjectFileName, 
+            ScheduleRecord record = new ScheduleRecord(recordKey, parentKey, nodeUsed, currentRequest.ProjectFileName,
                                                        currentRequest.ToolsetVersion, currentRequest.TargetNames);
 
             lock (scheduleTableLock)
@@ -266,7 +265,7 @@ internal void NotifyOfBuildResult(int nodeId, BuildResult buildResult)
                         ErrorUtilities.VerifyThrow(handleIdToScheduleRecord.ContainsKey(scheduleRecord.ParentKey),
                                                    "Parent schedule record should be in the table");
                         ScheduleRecord parentRecord = handleIdToScheduleRecord[scheduleRecord.ParentKey];
-                        
+
                         // As long as there are child requests under the parent request the parent request is considered blocked
                         // Remove this build request from the list of requests the parent request is waiting on. This may unblock the parent request
                         parentRecord.ReportChildCompleted(recordKey);
@@ -283,16 +282,15 @@ internal void NotifyOfBuildResult(int nodeId, BuildResult buildResult)
                 // Dump some interesting information to the console if profile build is turned on by an environment variable
                 if (parentEngine.ProfileBuild && scheduleRecord != null && buildResult.TaskTime != 0 )
                 {
-
                     Console.WriteLine("N " + scheduleRecord.EvaluationNode + " Name " + scheduleRecord.ProjectName + ":" +
-                                      scheduleRecord.ParentKey.HandleId + ":" + scheduleRecord.ParentKey.RequestId + 
+                                      scheduleRecord.ParentKey.HandleId + ":" + scheduleRecord.ParentKey.RequestId +
                                       " Total " + buildResult.TotalTime + " Engine " + buildResult.EngineTime + " Task " + buildResult.TaskTime);
                 }
             }
         }
 
         /// <summary>
-        /// Called when the engine is in the process of sending a buildRequest to a child node. The entire purpose of this method 
+        /// Called when the engine is in the process of sending a buildRequest to a child node. The entire purpose of this method
         /// is to switch the traversal strategy of the systems if there are nodes which do not have enough work availiable to them.
         /// </summary>
         internal void NotifyOfBuildRequest(int nodeIndex, BuildRequest currentRequest, int parentHandleId)
@@ -302,7 +300,7 @@ internal void NotifyOfBuildRequest(int nodeIndex, BuildRequest currentRequest, i
             if (totalRequestsPerNode != null)
             {
                 // Check if it makes sense to switch from one traversal strategy to the other
-                if (parentEngine.NodeManager.TaskExecutionModule.UseBreadthFirstTraversal == true)
+                if (parentEngine.NodeManager.TaskExecutionModule.UseBreadthFirstTraversal)
                 {
                     // Check if a switch to depth first traversal is in order
                     bool useBreadthFirstTraversal = false;
@@ -317,14 +315,14 @@ internal void NotifyOfBuildRequest(int nodeIndex, BuildRequest currentRequest, i
                         }
                     }
 
-                    if (useBreadthFirstTraversal == false)
+                    if (!useBreadthFirstTraversal)
                     {
                         if (Engine.debugMode)
                         {
                              Console.WriteLine("Switching to depth first traversal because all node have workitems");
                         }
                         parentEngine.NodeManager.TaskExecutionModule.UseBreadthFirstTraversal = false;
-                        
+
                         // Switch to depth first and change the traversal strategy of the entire system by notifying all child nodes of the change
                         parentEngine.PostEngineCommand(new ChangeTraversalTypeCommand(false, false));
                     }
@@ -412,7 +410,7 @@ internal void DumpState()
         #region Data
 
         /// <summary>
-        /// NodeId of the engine who instantiated the scheduler. This is used to determine if a 
+        /// NodeId of the engine who instantiated the scheduler. This is used to determine if a
         /// BuildRequest should be build locally as the project has already been loaded on this node.
         /// </summary>
         private int localNodeId;
@@ -430,10 +428,10 @@ internal void DumpState()
         private int[] totalRequestsPerNode;
 
         /// <summary>
-        /// The number of BuildRequests blocked waiting for results for each node. 
+        /// The number of BuildRequests blocked waiting for results for each node.
         /// This will be incremented once when a build request is scheduled which was generated as part of a msbuild callback
         /// and once for each call to NotifyOfBlockedRequest.
-        /// 
+        ///
         /// It is decremented for each call to NotifyOfUnblockedRequest and once all of the child requests have been fullfilled.
         /// </summary>
         private int[] blockedRequestsPerNode;
@@ -460,8 +458,8 @@ internal void DumpState()
         private Dictionary<ScheduleRecordKey, ScheduleRecord> handleIdToScheduleRecord;
 
         /// <summary>
-        /// Indicates the scheduler is instantiated on a child node. This is being determined by 
-        /// initializaing the variable to true in the constructor and then setting it to false in the 
+        /// Indicates the scheduler is instantiated on a child node. This is being determined by
+        /// initializaing the variable to true in the constructor and then setting it to false in the
         /// initialize method (the initialize method will only be called on the parent engine)
         /// </summary>
         private bool childMode;
@@ -476,7 +474,6 @@ internal void DumpState()
         /// </summary>
         private const int nodeWorkLoadProjectCount = 4;
 
-        
         /// <summary>
         /// Used to calculate which node a build request should be sent to if the scheduler is operating in a round robin fashion.
         /// Each time a build request is scheduled to a node in CalculateNodeForBuildRequest the lastUsedNode is incremented.
diff --git a/src/Deprecated/Engine/Engine/SchedulerRecord.cs b/src/Deprecated/Engine/Engine/SchedulerRecord.cs
index 2d404105f49..d0215904cf4 100644
--- a/src/Deprecated/Engine/Engine/SchedulerRecord.cs
+++ b/src/Deprecated/Engine/Engine/SchedulerRecord.cs
@@ -229,7 +229,7 @@ public override bool Equals(object obj)
 
         public override int GetHashCode()
         {
-            return (handleId + (requestId << 24));
+            return handleId + (requestId << 24);
         }
         #endregion
 
diff --git a/src/Deprecated/Engine/Engine/Target.cs b/src/Deprecated/Engine/Engine/Target.cs
index fcf77939cb8..13435cd8e61 100644
--- a/src/Deprecated/Engine/Engine/Target.cs
+++ b/src/Deprecated/Engine/Engine/Target.cs
@@ -226,7 +226,7 @@ bool        importedFromAnotherProject
             }
 
             // It's considered an error if a target does not have a name.
-            ProjectErrorUtilities.VerifyThrowInvalidProject((targetName != null) && (targetName.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(targetName),
                 targetElement, "MissingRequiredAttribute", XMakeAttributes.name, XMakeElements.target);
 
             this.taskElementList = new ArrayList();
@@ -492,7 +492,6 @@ internal BuildState TargetBuildState
             }
         }
 
-
         internal TargetExecutionWrapper ExecutionState
         {
             get
@@ -590,7 +589,7 @@ ProjectBuildState buildContext
                     // cache the individual target IDs for unloaded projects and it's not really worth the trouble.
                     // Just use the parent event context.
                     parentEngine.LoggingServices.LogComment(buildContext.ProjectBuildEventContext,
-                        ((buildState == BuildState.CompletedSuccessfully) ? "TargetAlreadyCompleteSuccess" : "TargetAlreadyCompleteFailure"),
+                        (buildState == BuildState.CompletedSuccessfully) ? "TargetAlreadyCompleteSuccess" : "TargetAlreadyCompleteFailure",
                         this.targetName);
 
                     // Only contexts which are generated from an MSBuild task could need 
@@ -601,7 +600,7 @@ ProjectBuildState buildContext
                          buildContext.NameOfBlockingTarget == null))
                     {
                         error.VerifyThrow(
-                            String.Compare(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), this.Name, StringComparison.OrdinalIgnoreCase) == 0,
+                            String.Equals(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), this.Name, StringComparison.OrdinalIgnoreCase),
                             "The name of the target in progress is inconsistent with the target being built");
 
                         error.VerifyThrow(targetOutputItems != null,
@@ -699,8 +698,6 @@ internal void ContinueBuild( ProjectBuildState buildContext, TaskExecutionContex
         /// <returns>true, if successful</returns>
         internal bool ExecuteOneTask(XmlElement taskNode, ITaskHost hostObject)
         {
-            bool taskExecutedSuccessfully = false;
-
             string projectFileOfTaskNode = XmlUtilities.GetXmlNodeFile(taskNode, parentProject.FullFileName);
             BuildEventContext targetBuildEventContext = new BuildEventContext
                                 (
@@ -714,14 +711,11 @@ internal bool ExecuteOneTask(XmlElement taskNode, ITaskHost hostObject)
             TaskExecutionModule taskExecutionModule = parentEngine.NodeManager.TaskExecutionModule;
             TaskEngine taskEngine = new TaskEngine(taskNode, hostObject, parentProject.FullFileName, projectFileOfTaskNode, parentEngine.LoggingServices, handleId, taskExecutionModule, targetBuildEventContext);
 
-            taskExecutedSuccessfully =
-                taskEngine.ExecuteTask
+            return taskEngine.ExecuteTask
                 (
                     TaskExecutionMode.ExecuteTaskAndGatherOutputs,
                     new Lookup(parentProject.evaluatedItemsByName, parentProject.evaluatedProperties, ParentProject.ItemDefinitionLibrary)
                 );
-
-            return taskExecutedSuccessfully;
         }
 
         /// <summary>
@@ -732,11 +726,11 @@ internal void MarkTargetAsDirty
             (
             )
         {
-            if (this.ParentProject != null)
-            {
+               
+            
                 // This is a change to the contents of the project file.
-                this.ParentProject.MarkProjectAsDirty();
-            }
+                this.ParentProject?.MarkProjectAsDirty();
+            
         }
 
         /// <summary>
@@ -751,7 +745,6 @@ internal XmlAttribute SetOrRemoveTargetAttribute
             string attributeValue
             )
         {
-            XmlAttribute updatedAttribute = null;
             // If this Target object is not actually represented by a 
             // <Target> element in the parentProject.file, then do not allow
             // the caller to set the condition.
@@ -760,7 +753,7 @@ string attributeValue
             // If this item was imported from another parentProject. we don't allow modifying it.
             error.VerifyThrowInvalidOperation(!this.importedFromAnotherProject, "CannotModifyImportedProjects");
 
-            updatedAttribute = ProjectXmlUtilities.SetOrRemoveAttribute(this.targetElement, attributeName, attributeValue);
+            XmlAttribute updatedAttribute = ProjectXmlUtilities.SetOrRemoveAttribute(targetElement, attributeName, attributeValue);
 
             // Mark the project dirty after an attribute has been updated
             this.MarkTargetAsDirty();
@@ -779,7 +772,7 @@ string taskName
             )
         {
             error.VerifyThrow(this.taskElementList != null, "Arraylist not initialized!");
-            error.VerifyThrowArgumentLength(taskName, "taskName");
+            error.VerifyThrowArgumentLength(taskName, nameof(taskName));
 
             // Confirm that it's not an imported target.
             error.VerifyThrowInvalidOperation(!this.IsImported, "CannotModifyImportedProjects");
@@ -812,7 +805,7 @@ BuildTask taskElement
             error.VerifyThrowInvalidOperation(!this.IsImported, "CannotModifyImportedProjects");
 
             error.VerifyThrow(this.taskElementList != null, "Arraylist not initialized!");
-            error.VerifyThrowArgumentNull(taskElement, "taskElement");
+            error.VerifyThrowArgumentNull(taskElement, nameof(taskElement));
 
             // Confirm that the BuildTask belongs to this Target.
             error.VerifyThrowInvalidOperation(taskElement.ParentTarget == this,
diff --git a/src/Deprecated/Engine/Engine/TargetCollection.cs b/src/Deprecated/Engine/Engine/TargetCollection.cs
index ed38ed7f986..d7aedf2f70d 100644
--- a/src/Deprecated/Engine/Engine/TargetCollection.cs
+++ b/src/Deprecated/Engine/Engine/TargetCollection.cs
@@ -159,7 +159,6 @@ public IEnumerator GetEnumerator
             return this.targetTable.Values.GetEnumerator();
         }
 
-
         /// <summary>
         /// Adds a new Target to our collection.  This method does nothing
         /// to manipulate the project's XML content.
@@ -218,7 +217,7 @@ public void RemoveTarget
             Target targetToRemove
         )
         {
-            error.VerifyThrowArgumentNull(targetToRemove, "targetToRemove");
+            error.VerifyThrowArgumentNull(targetToRemove, nameof(targetToRemove));
 
             // Confirm that it's not an imported target.
             error.VerifyThrowInvalidOperation(!targetToRemove.IsImported,
diff --git a/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs b/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
index 377fe8f63ad..bb909a079e0 100644
--- a/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
+++ b/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
@@ -238,7 +238,7 @@ out Hashtable upToDateTargetInputs
                 // 1) they do not reference any item vector
                 // 2) they reference item vectors that are not referenced by any input item
                 if ((discreteItemsInTargetOutputs.Count > 0) ||
-                    ((itemVectorsReferencedOnlyInTargetOutputs != null) && (itemVectorsReferencedOnlyInTargetOutputs.Count > 0)))
+                    ((itemVectorsReferencedOnlyInTargetOutputs?.Count > 0)))
                 {
                     result = PerformDependencyAnalysisIfDiscreteOutputs(
                                 itemVectorsInTargetInputs, itemVectorTransformsInTargetInputs, discreteItemsInTargetInputs,
@@ -254,9 +254,8 @@ out Hashtable upToDateTargetInputs
                     // Log the target inputs & outputs
                     if (!loggingService.OnlyLogCriticalEvents)
                     {
-                        string inputs = null;
-                        string outputs = null;
-
+                        string inputs;
+                        string outputs;
                         // Extract the unique inputs and outputs gatheres during TLDA
                         ExtractUniqueInputsAndOutputs(out inputs, out outputs);
 
@@ -609,7 +608,6 @@ out Hashtable upToDateTargetInputs
 
                             for (int i = 0; i < inputItemsAssumedToBeUpToDate.Length; i++)
                             {
-
                                 // if we haven't already determined that this input item has changed
                                 if (inputItemsAssumedToBeUpToDate[i] != null)
                                 {
@@ -720,7 +718,6 @@ ArrayList targetOutputItemSpecs
                     loggingService.LogComment(buildEventContext, "BuildTargetCompletely", this.targetToAnalyze.Name);
                     loggingService.LogComment(buildEventContext, "BuildTargetCompletelyNoInputsSpecified");
 
-
                     // otherwise, do a full build
                     result = DependencyAnalysisResult.FullBuild;
                 }
@@ -782,8 +779,7 @@ out Hashtable discreteItems
                 BuildItemGroup itemVectorContents = bucket.Expander.ExpandSingleItemListExpressionIntoItemsLeaveEscaped(item, attributeContainingItems, out itemVectorMatch);
                 if (itemVectorContents != null)
                 {
-                    Hashtable itemVectorCollection = null;
-
+                    Hashtable itemVectorCollection;
                     if ((itemVectorTransforms == null) ||
                         (itemVectorMatch.Groups["TRANSFORM_SPECIFICATION"].Length == 0))
                     {
@@ -925,7 +921,7 @@ internal static bool IsAnyOutOfDate(out DependencyAnalysisLogDetail dependencyAn
 
             string oldestOutput = EscapingUtilities.UnescapeAll((string)outputs[0]);
 
-            FileInfo oldestOutputInfo = null;
+            FileInfo oldestOutputInfo;
             try
             {
                 string oldestOutputFullPath = Path.Combine(projectDirectory, oldestOutput);
@@ -953,7 +949,7 @@ internal static bool IsAnyOutOfDate(out DependencyAnalysisLogDetail dependencyAn
             {
                 string candidateOutput = EscapingUtilities.UnescapeAll((string)outputs[i]);
 
-                FileInfo candidateOutputInfo = null;
+                FileInfo candidateOutputInfo;
                 try
                 {
                     string candidateOutputFullPath = Path.Combine(projectDirectory, candidateOutput);
@@ -1140,10 +1136,10 @@ private void RecordComparisonResults(string input, string output, string inputIt
         /// </returns>
         private int CompareLastWriteTimes(string path1, string path2, out bool path1DoesNotExist, out bool path2DoesNotExist)
         {
-            ErrorUtilities.VerifyThrow((path1 != null) && (path1.Length > 0) && (path2 != null) && (path2.Length > 0),
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(path1) && !string.IsNullOrEmpty(path2),
                 "Need to specify paths to compare.");
 
-            FileInfo path1Info = null;
+            FileInfo path1Info;
             try
             {
                 path1 = Path.Combine(projectDirectory, path1);
@@ -1158,7 +1154,7 @@ private int CompareLastWriteTimes(string path1, string path2, out bool path1Does
                 path1Info = null;
             }
 
-            FileInfo path2Info = null;
+            FileInfo path2Info;
             try
             {
                 path2 = Path.Combine(projectDirectory, path2);
diff --git a/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs b/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
index d9456bffd51..937cd28b801 100644
--- a/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
+++ b/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
@@ -115,8 +115,8 @@ internal bool BuildingRequiredTargets
         {
             get
             {
-                return (inProgressBuildState == InProgressBuildState.BuildingDependencies ||
-                        inProgressBuildState == InProgressBuildState.BuildingErrorClause);
+                return inProgressBuildState == InProgressBuildState.BuildingDependencies ||
+                        inProgressBuildState == InProgressBuildState.BuildingErrorClause;
             }
         }
 
@@ -220,8 +220,8 @@ private void ContinueBuildingDependencies (ProjectBuildState buildContext)
             string nameDependentTarget = dependsOnTargetNames[currentDependentTarget];
 
             ErrorUtilities.VerifyThrow(
-                parentProject.Targets[nameDependentTarget].TargetBuildState != Target.BuildState.InProgress &&
-                parentProject.Targets[nameDependentTarget].TargetBuildState != Target.BuildState.NotStarted ||
+                (parentProject.Targets[nameDependentTarget].TargetBuildState != Target.BuildState.InProgress &&
+                parentProject.Targets[nameDependentTarget].TargetBuildState != Target.BuildState.NotStarted) ||
                 buildContext.CurrentBuildContextState == ProjectBuildState.BuildContextState.ExceptionThrown,
                 "This target should only be updated once the dependent target is completed");
 
@@ -291,8 +291,8 @@ private void ContinueBuildingErrorClause (ProjectBuildState buildContext)
             string nameErrorTarget = onErrorTargets[currentErrorTarget];
 
             ErrorUtilities.VerifyThrow(
-                parentProject.Targets[nameErrorTarget].TargetBuildState != Target.BuildState.InProgress &&
-                parentProject.Targets[nameErrorTarget].TargetBuildState != Target.BuildState.NotStarted ||
+                (parentProject.Targets[nameErrorTarget].TargetBuildState != Target.BuildState.InProgress &&
+                parentProject.Targets[nameErrorTarget].TargetBuildState != Target.BuildState.NotStarted) ||
                 buildContext.CurrentBuildContextState == ProjectBuildState.BuildContextState.ExceptionThrown,
                 "This target should only be updated once the error target is completed");
 
@@ -533,9 +533,6 @@ private void InitializeForRunningSingleTargetBatch()
             ErrorUtilities.VerifyThrow(inProgressBuildState == InProgressBuildState.RunningTasks, "Wrong state");
             // Check if the current task number is valid
             ErrorUtilities.VerifyThrow(currentBucket < buckets.Count, "No buckets left");
-
-            Hashtable changedTargetInputs = null;
-            Hashtable upToDateTargetInputs = null;
             howToBuild = DependencyAnalysisResult.FullBuild;
             ItemBucket bucket = (ItemBucket)buckets[currentBucket];
 
@@ -555,6 +552,9 @@ private void InitializeForRunningSingleTargetBatch()
 
             // Figure out how we should build the target
             TargetDependencyAnalyzer dependencyAnalyzer = new TargetDependencyAnalyzer(parentProject.ProjectDirectory, targetClass, parentEngine.LoggingServices, targetBuildEventContext);
+
+            Hashtable changedTargetInputs;
+            Hashtable upToDateTargetInputs;
             howToBuild = dependencyAnalyzer.PerformDependencyAnalysis(bucket, out changedTargetInputs, out upToDateTargetInputs);
 
             targetBuildSuccessful = true;
@@ -576,7 +576,7 @@ private void InitializeForRunningSingleTargetBatch()
                 // if we're doing an incremental build, we need to effectively run the task twice -- once
                 // to infer the outputs for up-to-date input items, and once to actually execute the task;
                 // as a result we need separate sets of item and property collections to track changes
-                if (howToBuild == DependencyAnalysisResult.IncrementalBuild)    
+                if (howToBuild == DependencyAnalysisResult.IncrementalBuild)
                 {
                     // subset the relevant items to those that are up-to-date
                     foreach (DictionaryEntry upToDateTargetInputsEntry in upToDateTargetInputs)
@@ -690,7 +690,7 @@ private void ExecuteCurrentTask(ProjectBuildState buildContext)
             // Send the task for execution 
             SubmitNonIntrinsicTask(
                 (XmlElement)targetChildNode,
-                ((BuildTask)taskElementList[(currentTask - skippedNodeCount)]).HostObject,
+                ((BuildTask)taskElementList[currentTask - skippedNodeCount]).HostObject,
                 buildContext);
 
             return;
@@ -713,7 +713,7 @@ private TaskExecutionMode DetermineExecutionMode()
             if ((howToBuild == DependencyAnalysisResult.FullBuild) ||
                 (howToBuild == DependencyAnalysisResult.IncrementalBuild))
             {
-                executionMode = executionMode | TaskExecutionMode.ExecuteTaskAndGatherOutputs;
+                executionMode |= TaskExecutionMode.ExecuteTaskAndGatherOutputs;
             }
             return executionMode;
         }
@@ -740,7 +740,7 @@ private void ExecuteIntrinsicTask(XmlElement taskNode)
             BuildEventContext buildEventContext = PrepareBuildEventContext(true);
             TaskExecutionMode executionMode = DetermineExecutionMode();
 
-            IntrinsicTask task = new IntrinsicTask(taskNode, 
+            IntrinsicTask task = new IntrinsicTask(taskNode,
                                                    parentEngine.LoggingServices,
                                                    buildEventContext,
                                                    parentProject.ProjectDirectory,
@@ -826,10 +826,10 @@ private void ProcessTaskOutputs(TaskExecutionContext executionContext)
                             // by bad user input), the build should be terminated. The exception
                             // will be logged as a fatal build error in engine. The exceptions caused
                             // by user code are converted into LogFatalTaskError messages by the TaskEngine
-                            RemoteErrorException.Throw(executionContext.ThrownException, 
-                                                       targetBuildEventContext, 
+                            RemoteErrorException.Throw(executionContext.ThrownException,
+                                                       targetBuildEventContext,
                                                        "RemoteErrorDuringTaskExecution",
-                                                       parentProject.FullFileName, 
+                                                       parentProject.FullFileName,
                                                        targetClass.Name);
                         }
                     }
@@ -876,7 +876,7 @@ private void FinishRunningSingleTargetBatch
                 targetClass.Name,
                 this.parentProject.FullFileName,
                 targetClass.ProjectFileOfTargetElement,
-                (overallSuccess && targetBuildSuccessful));
+                overallSuccess && targetBuildSuccessful);
             loggedTargetStart = false;
 
             // Get the next bucket
@@ -889,7 +889,7 @@ private void FinishRunningTargetBatches(ProjectBuildState buildContext)
             foreach (ItemBucket bucket in buckets)
             {
                 bucket.Lookup.LeaveScope();
-            }         
+            }
 
             // and also leave the extra scope we created with the cloned project items
             projectContent.LeaveScope();
@@ -909,7 +909,7 @@ private void FinishRunningTargetBatches(ProjectBuildState buildContext)
                     buildContext.NameOfBlockingTarget == null)
                 {
                     ErrorUtilities.VerifyThrow(
-                        String.Compare(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), targetClass.Name, StringComparison.OrdinalIgnoreCase) == 0,
+                        String.Equals(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), targetClass.Name, StringComparison.OrdinalIgnoreCase),
                         "The name of the target in progress is inconsistent with the target being built");
 
                     ErrorUtilities.VerifyThrow(targetOutputItems != null,
@@ -979,7 +979,7 @@ internal List<ProjectBuildState> GetWaitingBuildContexts()
         }
 
         /// <summary>
-        /// Iterate over the contexts waiting for the target - triggering updates for each of them since the target 
+        /// Iterate over the contexts waiting for the target - triggering updates for each of them since the target
         /// is complete
         /// </summary>
         internal void NotifyWaitingTargets(ProjectBuildState errorContext)
@@ -1008,7 +1008,7 @@ internal void NotifyWaitingTargets(ProjectBuildState errorContext)
                 {
                     continue;
                 }
-                
+
                 parentEngine.Scheduler.NotifyOfUnblockedRequest(buildContext.BuildRequest);
 
                 ErrorUtilities.VerifyThrow(
@@ -1019,7 +1019,7 @@ internal void NotifyWaitingTargets(ProjectBuildState errorContext)
                 if (buildContext.NameOfBlockingTarget == null)
                 {
                     ErrorUtilities.VerifyThrow(
-                        String.Compare(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), targetClass.Name, StringComparison.OrdinalIgnoreCase) == 0,
+                        String.Equals(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), targetClass.Name, StringComparison.OrdinalIgnoreCase),
                         "The name of the target in progress is inconsistent with the target being built");
 
                     // This target was part of a sequential request so we need to notify the parent project
@@ -1035,7 +1035,7 @@ internal void NotifyWaitingTargets(ProjectBuildState errorContext)
                     // The target on the waiting list must be waiting for this target to complete due to
                     // a dependent or onerror relationship between targets
                     ErrorUtilities.VerifyThrow(
-                        String.Compare(buildContext.NameOfBlockingTarget, targetClass.Name, StringComparison.OrdinalIgnoreCase) == 0,
+                        String.Equals(buildContext.NameOfBlockingTarget, targetClass.Name, StringComparison.OrdinalIgnoreCase),
                         "This target should only be updated once the dependent target is completed");
 
                     if (Engine.debugMode)
@@ -1045,8 +1045,8 @@ internal void NotifyWaitingTargets(ProjectBuildState errorContext)
                 }
 
                 // Post a dummy context to the queue to cause the target to run in this context
-                TaskExecutionContext taskExecutionContext = 
-                    new TaskExecutionContext(parentProject, null, null, buildContext, 
+                TaskExecutionContext taskExecutionContext =
+                    new TaskExecutionContext(parentProject, null, null, buildContext,
                                              EngineCallback.invalidEngineHandle, EngineCallback.inProcNode, null);
                 parentEngine.PostTaskOutputUpdates(taskExecutionContext);
             }
diff --git a/src/Deprecated/Engine/Engine/TaskEngine.cs b/src/Deprecated/Engine/Engine/TaskEngine.cs
index 54396fee8ad..50618e45403 100644
--- a/src/Deprecated/Engine/Engine/TaskEngine.cs
+++ b/src/Deprecated/Engine/Engine/TaskEngine.cs
@@ -30,7 +30,7 @@ namespace Microsoft.Build.BuildEngine
     internal enum TaskExecutionMode
     {
         /// <summary>
-        /// This entry is necessary to use the enum with binary math. It is never used outside 
+        /// This entry is necessary to use the enum with binary math. It is never used outside
         /// intermediate calculations.
         /// </summary>
         Invalid = 0,
@@ -159,7 +159,7 @@ private List<string> CreateListOfParameterValues()
         /// 2) checks the global task declarations (in *.TASKS in MSbuild bin dir), searching by exact name
         /// 3) checks the tasks declared by the project, searching by fuzzy match (missing namespace, etc.)
         /// 4) checks the global task declarations (in *.TASKS in MSbuild bin dir), searching by fuzzy match (missing namespace, etc.)
-        /// 
+        ///
         /// The search ordering is meant to reduce the number of assemblies we scan, because loading assemblies can be expensive.
         /// The tasks and assemblies declared by the project are scanned first, on the assumption that if the project declared
         /// them, they are likely used.
@@ -190,7 +190,7 @@ internal bool FindTask()
                 }
             }
 
-            return (TaskClass != null);
+            return TaskClass != null;
         }
 
         /// <summary>
@@ -203,7 +203,7 @@ private AppDomain PrepareAppDomain()
             // here. Instead, NDP will try to Load (not LoadFrom!) the task assembly into our AppDomain, and since
             // we originally used LoadFrom, it will fail miserably not knowing where to find it.
             // We need to temporarily subscribe to the AppDomain.AssemblyResolve event to fix it.
-            if (null == resolver)
+            if (resolver == null)
             {
                 resolver = new TaskEngineAssemblyResolver();
                 resolver.Initialize(TaskClass.Assembly.AssemblyFile);
@@ -254,7 +254,7 @@ private AppDomain PrepareAppDomain()
         }
 
         /// <summary>
-        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it. 
+        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it.
         /// </summary>
         /// <returns>true, if successful</returns>
         internal bool ExecuteTask(TaskExecutionMode howToExecuteTask, Lookup lookup)
@@ -278,7 +278,7 @@ internal bool ExecuteTask(TaskExecutionMode howToExecuteTask, Lookup lookup)
                 {
                     lookupHash = Utilities.CreateTableIfNecessary((Hashtable)null);
                 }
-		
+
 		// Loop through each of the batch buckets and execute them one at a time
                 for (int i=0; i < buckets.Count; i++)
                 {
@@ -293,15 +293,9 @@ internal bool ExecuteTask(TaskExecutionMode howToExecuteTask, Lookup lookup)
             finally
             {
                 // Remove the AssemblyResolve handler in the default AppDomain, we are done with the task.
-                if (resolver != null)
-                {
-                    resolver.RemoveHandler();
-                }
+                resolver?.RemoveHandler();
 
-                if (engineProxy != null)
-                {
-                    engineProxy.MarkAsInActive();
-                }
+                engineProxy?.MarkAsInActive();
 
                 // Now all task batches are done, apply all item adds to the outer 
                 // target batch; we do this even if the task wasn't found (in that case,
@@ -422,13 +416,9 @@ private bool ExecuteBucket(EngineProxy engineProxy, ItemBucket bucket, int bucke
                         parentProjectFullFileName,
                         projectFileOfTaskNode,
                         taskResult);
-
-                    task = null;
-
                     if (taskAppDomain != null)
                     {
                         AppDomain.Unload(taskAppDomain);
-                        taskAppDomain = null;
                     }
                 }
             }
@@ -509,9 +499,8 @@ private ITask InstantiateTask(AppDomain taskAppDomain)
 
                     task = (ITask)taskAppDomain.CreateInstanceFromAndUnwrap(TaskClass.Assembly.AssemblyFile, TaskClass.Type.FullName);
 
-                    Type taskType = null;
-                    // this will force evaluation of the task class type and try to load the task assembly
-                    taskType = task.GetType();
+                                        // this will force evaluation of the task class type and try to load the task assembly
+                    Type taskType = task.GetType();
 
                     // If the types don't match, we have a problem. It means that our AppDomain was able to load
                     // a task assembly using Load, and loaded a different one. I don't see any other choice than
@@ -665,7 +654,6 @@ private bool InitializeTaskParameters(ITask task, ItemBucket bucket)
             return taskInitialized;
         }
 
-
         /// <summary>
         /// Finds all the task properties that are required.
         /// Returns them as keys in a dictionary.
@@ -985,7 +973,6 @@ internal bool GatherGeneratedTaskOutputs
             return gatheredGeneratedOutputsSuccessfully;
         }
 
-
         private void GatherArrayStringAndValueOutputs(Lookup lookup, TaskOutput taskOutputSpecification, string itemName, string propertyName, PropertyInfo parameter, object outputs)
         {
             // if the task has generated outputs (if it didn't, don't do anything)
@@ -997,7 +984,7 @@ private void GatherArrayStringAndValueOutputs(Lookup lookup, TaskOutput taskOutp
 
                 if (taskOutputSpecification.IsItemVector)
                 {
-                    ErrorUtilities.VerifyThrow((itemName != null) && (itemName.Length > 0), "Need item type.");
+                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(itemName), "Need item type.");
 
                     // to store the outputs as items, use the string representations of the outputs as item-specs
                     foreach (object output in convertibleOutputs)
@@ -1018,7 +1005,7 @@ private void GatherArrayStringAndValueOutputs(Lookup lookup, TaskOutput taskOutp
                 else
                 {
                     Debug.Assert(taskOutputSpecification.IsProperty);
-                    ErrorUtilities.VerifyThrow((propertyName != null) && (propertyName.Length > 0), "Need property name.");
+                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(propertyName), "Need property name.");
 
                     // to store an object array in a property, join all the string representations of the objects with
                     // semi-colons to make the property value
@@ -1055,7 +1042,7 @@ private void GatherTaskItemOutputs(Lookup lookup, TaskOutput taskOutputSpecifica
 
                 if (taskOutputSpecification.IsItemVector)
                 {
-                    ErrorUtilities.VerifyThrow((itemName != null) && (itemName.Length > 0), "Need item type.");
+                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(itemName), "Need item type.");
 
                     foreach (ITaskItem output in taskItemOutputs)
                     {
@@ -1069,7 +1056,7 @@ private void GatherTaskItemOutputs(Lookup lookup, TaskOutput taskOutputSpecifica
                 else
                 {
                     Debug.Assert(taskOutputSpecification.IsProperty);
-                    ErrorUtilities.VerifyThrow((propertyName != null) && (propertyName.Length > 0), "Need property name.");
+                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(propertyName), "Need property name.");
 
                     // to store an ITaskItem array in a property, join all the item-specs with semi-colons to make the
                     // property value, and ignore/discard the attributes on the ITaskItems
@@ -1119,20 +1106,19 @@ ItemBucket bucket
             // DevDiv bugs: 33981
             foreach (XmlAttribute taskNodeAttribute in taskNode.Attributes)
             {
-                if (String.Compare(taskNodeAttribute.Name, taskParameterName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(taskNodeAttribute.Name, taskParameterName, StringComparison.OrdinalIgnoreCase))
                 {
                     taskParameterAttribute = taskNodeAttribute;
                     break;
                 }
             }
- 
+
             if (taskParameterAttribute != null)
             {
                 if (taskOutputSpecification.IsItemVector)
                 {
                     // This is an output item.
-
-                    ErrorUtilities.VerifyThrow((itemName != null) && (itemName.Length > 0), "Need item type.");
+                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(itemName), "Need item type.");
 
                     // Expand only with properties first, so that expressions like Include="@(foo)" will transfer the metadata of the "foo" items as well, not just their item specs.
                     Expander propertyAndMetadataExpander = new Expander(bucket.Expander, ExpanderOptions.ExpandPropertiesAndMetadata);
@@ -1165,9 +1151,8 @@ ItemBucket bucket
                 else
                 {
                     // This is an output property.
-
                     Debug.Assert(taskOutputSpecification.IsProperty);
-                    ErrorUtilities.VerifyThrow((propertyName != null) && (propertyName.Length > 0), "Need property name.");
+                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(propertyName), "Need property name.");
 
                     string taskParameterValue = bucket.Expander.ExpandAllIntoString(taskParameterAttribute);
 
@@ -1224,7 +1209,6 @@ private List<TaskOutput> GetTaskOutputSpecifications(bool showWarnings)
             return taskOutputSpecifications;
         }
 
-
         /// <summary>
         /// Given an instantiated task, this helper method sets the specified parameter based on its type.
         /// </summary>
@@ -1495,7 +1479,7 @@ out bool taskParameterSet
                 // to avoid project authors having to add Conditions on all their tasks to avoid calling them
                 // when a particular item list is empty.  This way, we just call the task with an empty list,
                 // the task will loop over an empty list, and return quickly.
-                if ((finalTaskInputs.Count > 0) || (isRequired))
+                if ((finalTaskInputs.Count > 0) || isRequired)
                 {
                     // Send the array into the task parameter.
                     success = SetTaskParameter(task, parameter, finalTaskInputs.ToArray(parameterType.GetElementType()));
@@ -1590,15 +1574,15 @@ object parameterValue
         }
 
         /// <summary>
-        /// This function correctly computes the line/column number of the task node 
-        /// in the project file (or .TARGETS file) that called it. The XmlNode available 
+        /// This function correctly computes the line/column number of the task node
+        /// in the project file (or .TARGETS file) that called it. The XmlNode available
         /// to the task engine lacks this information so we call back into the build engine
         /// to obtain it.
         /// </summary>
         private BuildEventFileInfo CreateBuildEventFileInfoForTask()
         {
-            int lineNumber = 0;
-            int columnNumber = 0;
+            int lineNumber;
+            int columnNumber;
             parentModule.GetLineColumnOfXmlNode(handleId, out lineNumber, out columnNumber);
             return new BuildEventFileInfo(projectFileOfTaskNode, lineNumber, columnNumber);
         }
diff --git a/src/Deprecated/Engine/Engine/TaskEngineAssemblyResolver.cs b/src/Deprecated/Engine/Engine/TaskEngineAssemblyResolver.cs
index 47694f4d3d3..1f014fc5526 100644
--- a/src/Deprecated/Engine/Engine/TaskEngineAssemblyResolver.cs
+++ b/src/Deprecated/Engine/Engine/TaskEngineAssemblyResolver.cs
@@ -38,10 +38,10 @@ internal void Initialize(string taskAssemblyFileToResolve)
         }
 
         /// <summary>
-        /// Installs an AssemblyResolve handler in the current AppDomain. This class can be created in any AppDomain, 
+        /// Installs an AssemblyResolve handler in the current AppDomain. This class can be created in any AppDomain,
         /// so it's possible to create an AppDomain, create an instance of this class in it and use this method to install
         /// an event handler in that AppDomain. Since the event handler instance is stored internally, this method
-        /// should only be called once before a corresponding call to RemoveHandler (not that it would make sense to do 
+        /// should only be called once before a corresponding call to RemoveHandler (not that it would make sense to do
         /// anything else).
         /// </summary>
         /// <owner>lukaszg</owner>
diff --git a/src/Deprecated/Engine/Engine/TaskExecutionModule.cs b/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
index 9c1c984d50c..54915eebb4d 100644
--- a/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
+++ b/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
@@ -30,7 +30,7 @@ internal class TaskExecutionModule
         /// </summary>
         internal TaskExecutionModule
         (
-            EngineCallback engineCallback, 
+            EngineCallback engineCallback,
             TaskExecutionModuleMode moduleMode,
             bool profileExecution
         )
@@ -128,19 +128,19 @@ internal bool UseBreadthFirstTraversal
         }
 
         /// <summary>
-        /// Returns true if the TEM doesn't have a thread in user code and there are no pending 
+        /// Returns true if the TEM doesn't have a thread in user code and there are no pending
         /// workitems
         /// </summary>
         internal bool IsIdle
         {
             get
             {
-                return (activeThreadCount == 0 && workerThread.WorkItemCount == 0);
+                return activeThreadCount == 0 && workerThread.WorkItemCount == 0;
             }
         }
 
         /// <summary>
-        /// Return total time spent executing the tasks by this TEM. This value is only valid if the TEM is created with 
+        /// Return total time spent executing the tasks by this TEM. This value is only valid if the TEM is created with
         /// profileExecution set to true, otherwise this value will be 0
         /// </summary>
         internal long TaskExecutionTime
@@ -155,7 +155,7 @@ internal long TaskExecutionTime
         #region Method used internally inside the TEM boundary (i.e. not called from the engine)
 
         /// <summary>
-        /// This method passes the task outputs to the engine, it is virtual for testing purposes to 
+        /// This method passes the task outputs to the engine, it is virtual for testing purposes to
         /// create a mock TEM
         /// </summary>
         virtual internal void PostTaskOutputs
@@ -176,15 +176,15 @@ long executionTime
         /// <returns>result of call to engine</returns>
         virtual internal bool BuildProjectFile
         (
-            int handleId, 
-            string[] projectFileNames, 
-            string[] targetNames, 
+            int handleId,
+            string[] projectFileNames,
+            string[] targetNames,
             IDictionary[] globalPropertiesPerProject,
             IDictionary[] targetOutputsPerProject,
             EngineLoggingServices loggingServices,
             string [] toolsVersions,
             bool useResultsCache,
-            bool unloadProjectsOnCompletion, 
+            bool unloadProjectsOnCompletion,
             BuildEventContext taskContext
         )
         {
@@ -203,8 +203,7 @@ BuildEventContext taskContext
                 bool remoteNode = false;
                 for (int r = 0; r < projectFileNames.Length; r++)
                 {
-                    string fullProjectName = projectFileNames[r] != null ?
-                       projectFileNames[r] : "null";
+                    string fullProjectName = projectFileNames[r] ?? "null";
                     Console.WriteLine("RemoteNode: " + remoteNode + " Project " + fullProjectName + " T:" + targetName + " NodeProdyId# " + handleId + " Time " + DateTime.Now.ToLongTimeString());
                     if (globalPropertiesPerProject[r] != null)
                     {
@@ -226,7 +225,7 @@ BuildEventContext taskContext
 
                 buildRequests[i] = new BuildRequest(handleId, fullProjectName, targetNames, globalPropertiesPerProject[i],
                                                     toolsVersions[i], i, useResultsCache, unloadProjectsOnCompletion);
-                ErrorUtilities.VerifyThrow(buildRequests[i].IsGeneratedRequest == true, "Should not be sending non generated requests from TEM to engine");
+                ErrorUtilities.VerifyThrow(buildRequests[i].IsGeneratedRequest, "Should not be sending non generated requests from TEM to engine");
                 buildRequests[i].ParentBuildEventContext = taskContext;
             }
 
@@ -290,16 +289,16 @@ BuildEventContext taskContext
 
             return overallResult;
         }
-       
+
        /// <summary>
        /// Once the buildRequests from the EngineCallback have been created they are sent to this method which will
        /// post the build requests to the parent engine and then wait on the results to come back.
        /// This method uses either a breadthFirst or depthFirst traversal strategy when sending buildRequests to the parent engine.
        /// This method will start in breadthFirst traversal. It will continue to use this strategy until one of two events occur:
-       ///     1. The parent node sents a message indicating the TEM should switch to depthFirst traversal. 
+       ///     1. The parent node sents a message indicating the TEM should switch to depthFirst traversal.
        ///     2. The number of buildRequests is larger than the batchRequestSize.
        /// In both of these cases the system will go from a breadthFirstTraversal to a depthFirst Traversal. In the second case
-       /// a message will be sent to the parent engine to switch the system to depthFirst traversal as the system is starting to 
+       /// a message will be sent to the parent engine to switch the system to depthFirst traversal as the system is starting to
        /// be overloaded with work.
        /// In a depth first strategy the buildRequests will be sent to the parent engine one at a time and waiting for results for
        /// each buildRequest sent. In a breadthFirst traversal strategy some number of the buildrequests will be sent to the parent engine
@@ -310,7 +309,7 @@ private void WaitForBuildResults(int handleId, BuildResult[] buildResultsLocal,
         {
             // If the traversal strategy is breadth first and the number of requests is less than the batchRequestSize
             // or if there is only 1 build request then send ALL build requests to the parent engine and wait on the results.
-            if ((breadthFirstTraversal == true && buildRequests.Length < batchRequestSize) || buildRequests.Length == 1)
+            if ((breadthFirstTraversal && buildRequests.Length < batchRequestSize) || buildRequests.Length == 1)
             {
                 engineCallback.PostBuildRequestsToHost(buildRequests);
                 workerThread.WaitForResults(handleId, buildResultsLocal, buildRequests);
@@ -318,8 +317,7 @@ private void WaitForBuildResults(int handleId, BuildResult[] buildResultsLocal,
             else
             {
                 int currentRequestIndex = 0; // Which build request is being processed
-                int numberOfRequestsToSend = 0; // How many buildRequests are going to be sent based on the number of buildRequests remaining and the build request batch size.
-                
+
                 // Arrays that will be used to partion the buildRequests array when sending batches of builds requests at a time.
                 BuildRequest[] wrapperArrayBreadthFirst = new BuildRequest[batchRequestSize];
                 BuildResult[] resultsArrayBreadthFirst = new BuildResult[batchRequestSize];
@@ -332,10 +330,10 @@ private void WaitForBuildResults(int handleId, BuildResult[] buildResultsLocal,
                 while (currentRequestIndex < buildRequests.Length)
                 {
                     // If there is a breadth first traversal and there are more than batchRequestSize build requests, send the first batchRequestSize, then do the rest depth first
-                    if (breadthFirstTraversal == true)
+                    if (breadthFirstTraversal)
                     {
                         // Figure out how many requests to send, either the full batch size or only part of a batch
-                        numberOfRequestsToSend = (buildRequests.Length - currentRequestIndex) <batchRequestSize ? (buildRequests.Length - currentRequestIndex) : batchRequestSize;
+                        int numberOfRequestsToSend = (buildRequests.Length - currentRequestIndex) < batchRequestSize ? (buildRequests.Length - currentRequestIndex) : batchRequestSize;
 
                         // Initialize the wrapper array to how many requests are going to be sent
                         if (numberOfRequestsToSend != wrapperArrayBreadthFirst.Length)
@@ -343,7 +341,7 @@ private void WaitForBuildResults(int handleId, BuildResult[] buildResultsLocal,
                             wrapperArrayBreadthFirst = new BuildRequest[numberOfRequestsToSend];
                             resultsArrayBreadthFirst = new BuildResult[numberOfRequestsToSend];
                         }
-                        
+
                         // Fill the wrapper array with one batch of build requests
                         for (int i = 0; i < numberOfRequestsToSend; i++)
                         {
@@ -353,14 +351,14 @@ private void WaitForBuildResults(int handleId, BuildResult[] buildResultsLocal,
                         }
 
                         engineCallback.PostBuildRequestsToHost(wrapperArrayBreadthFirst);
-                        
+
                         // Only switch from breadth to depth if there are more thanbatchRequestSize items
                         if ((buildRequests.Length - currentRequestIndex) > batchRequestSize)
                         {
                             engineCallback.PostStatus(nodeId, new NodeStatus(false /* use depth first traversal*/), false /* don't block waiting on the send */);
                             breadthFirstTraversal = false;
                         }
-                        
+
                         workerThread.WaitForResults(handleId, resultsArrayBreadthFirst, wrapperArrayBreadthFirst);
                         Array.Copy(resultsArrayBreadthFirst, 0, buildResultsLocal, currentRequestIndex, numberOfRequestsToSend);
                         currentRequestIndex += numberOfRequestsToSend;
@@ -427,15 +425,15 @@ internal string GetToolsPath(int handleId)
 
         internal bool RethrowTaskExceptions()
         {
-            return (moduleMode == TaskExecutionModuleMode.SingleProcMode);
+            return moduleMode == TaskExecutionModuleMode.SingleProcMode;
         }
 
         #endregion
 
         #region Methods called from the engine
         /// <summary>
-        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, 
-        /// and executes it. 
+        /// Called to execute a task within a target. This method instantiates the task, sets its parameters,
+        /// and executes it.
         /// </summary>
         /// <param name="taskState"></param>
         public void ExecuteTask(TaskExecutionState taskState)
@@ -648,12 +646,12 @@ internal TaskWorkerThread GetWorkerThread()
 
         /// <summary>
         /// In a multiproc build this is the maximum number of build requests which will be sent at a time to the parent engine
-        /// A default of 10 was an arbitrary number but turned out to be a good balance between being too small 
+        /// A default of 10 was an arbitrary number but turned out to be a good balance between being too small
         /// causing the system to run out of work too quickly and being too big and flooding the system with requests.
         /// </summary>
         private const int defaultBatchRequestSize = 10;
         private int batchRequestSize = defaultBatchRequestSize;
-        
+
         /// <summary>
         /// The nodeId of the node the TaskExecutionModule is running on
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/TaskExecutionState.cs b/src/Deprecated/Engine/Engine/TaskExecutionState.cs
index 63920dac6c3..f801c546fa9 100644
--- a/src/Deprecated/Engine/Engine/TaskExecutionState.cs
+++ b/src/Deprecated/Engine/Engine/TaskExecutionState.cs
@@ -158,14 +158,10 @@ virtual internal void ExecuteTask()
                 // been built by the task
                 if ((howToExecuteTask & TaskExecutionMode.InferOutputsOnly) != TaskExecutionMode.Invalid)
                 {
-                    bool targetInferenceSuccessful = false;
-
-                    targetInferenceSuccessful =
-                       TaskEngineExecuteTask
-                        (   taskEngine,
-                            TaskExecutionMode.InferOutputsOnly,
-                            lookupForInference
-                        );
+                    bool targetInferenceSuccessful = TaskEngineExecuteTask
+                        (taskEngine,
+                         TaskExecutionMode.InferOutputsOnly,
+                         lookupForInference);
 
                     ErrorUtilities.VerifyThrow(targetInferenceSuccessful, "A task engine should never fail to infer its task's up-to-date outputs.");
                 }
diff --git a/src/Deprecated/Engine/Engine/TaskOutput.cs b/src/Deprecated/Engine/Engine/TaskOutput.cs
index c2b730fdaa0..3989f6c560d 100644
--- a/src/Deprecated/Engine/Engine/TaskOutput.cs
+++ b/src/Deprecated/Engine/Engine/TaskOutput.cs
@@ -94,7 +94,7 @@ internal bool IsItemVector
         {
             get
             {
-                return (this.itemNameAttribute != null);
+                return this.itemNameAttribute != null;
             }
         }
 
@@ -106,7 +106,7 @@ internal bool IsProperty
         {
             get
             {
-                return (this.propertyNameAttribute != null);
+                return this.propertyNameAttribute != null;
             }
         }
 
diff --git a/src/Deprecated/Engine/Engine/TaskRegistry.cs b/src/Deprecated/Engine/Engine/TaskRegistry.cs
index 69e52ef45ae..47758b2a47e 100644
--- a/src/Deprecated/Engine/Engine/TaskRegistry.cs
+++ b/src/Deprecated/Engine/Engine/TaskRegistry.cs
@@ -157,7 +157,7 @@ out LoadedType taskClass
                 cachedTaskClasses[taskName] = taskClass;
             }
 
-            return (taskClass != null);
+            return taskClass != null;
         }
 
         /// <summary>
@@ -194,7 +194,7 @@ internal bool FindRegisteredTasks(string taskName, bool exactMatchRequired, out
                 }
             }
 
-            return (registeredTasksFound.Count > 0);
+            return registeredTasksFound.Count > 0;
         }
 
         /// <summary>
@@ -331,7 +331,6 @@ public void RegisterTask(UsingTask usingTask, Expander expander, EngineLoggingSe
                             "InvalidAttributeValueWithException", assemblyFile,
                             XMakeAttributes.assemblyFile, XMakeElements.usingTask, ex.Message);
                     }
-
                 }
 
                 AssemblyLoadInfo taskAssembly = new AssemblyLoadInfo(assemblyName, assemblyFile);
@@ -366,9 +365,9 @@ public void RegisterTask(UsingTask usingTask, Expander expander, EngineLoggingSe
         /// <returns>true, if specified type is a task</returns>
         private static bool IsTaskClass(Type type, object unused)
         {
-            return (type.IsClass &&
+            return type.IsClass &&
                 !type.IsAbstract &&
-                (type.GetInterface("ITask") != null));
+                (type.GetInterface("ITask") != null);
         }
         #endregion
 
diff --git a/src/Deprecated/Engine/Engine/TaskWorkerThread.cs b/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
index 4be9db73912..1e02d208ea9 100644
--- a/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
+++ b/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
@@ -142,7 +142,7 @@ internal int WorkItemCount
 
         /// <summary>
         /// This a base loop of a worker thread. The worker thread is asleep waiting for either an
-        /// event indicating that it should shut down or that it should become active and take 
+        /// event indicating that it should shut down or that it should become active and take
         /// ownership of the work item queue
         /// </summary>
         private void MainThreadLoop()
@@ -308,12 +308,11 @@ private WaitHandle [] GetHandlesArray( NodeLoopExecutionMode executionMode )
         /// </summary>
         private void NodeActionLoop
         (
-            NodeLoopExecutionMode executionMode, 
-            int handleId, 
+            NodeLoopExecutionMode executionMode,
+            int handleId,
             BuildResult [] buildResults
         )
         {
-
             // Create an array of event to the node thread responds
             WaitHandle[] waitHandles = GetHandlesArray(executionMode);
 
@@ -331,7 +330,7 @@ BuildResult [] buildResults
                     entryTime = DateTime.Now.Ticks;
                 }
             }
-            
+
             bool continueExecution = true;
             while (continueExecution)
             {
@@ -421,8 +420,8 @@ BuildResult [] buildResults
                         workerThread.ActivateThread();
                     }
                 }
-                else if (eventType == 1 && executionMode == NodeLoopExecutionMode.WaitingPassiveThread ||
-                         eventType == 2 && executionMode == NodeLoopExecutionMode.WaitingActiveThread)
+                else if ((eventType == 1 && executionMode == NodeLoopExecutionMode.WaitingPassiveThread) ||
+                         (eventType == 2 && executionMode == NodeLoopExecutionMode.WaitingActiveThread))
                 {
                     // There maybe multiple results in the list so we need to loop over it 
                     // and store the results
@@ -431,7 +430,7 @@ BuildResult [] buildResults
                     {
                         LinkedListNode<BuildResult> currentNode = postedBuildResults.First;
                         while (currentNode != null)
-                        {   
+                        {
                             BuildResult buildResult = currentNode.Value;
                             ErrorUtilities.VerifyThrow(
                                             buildResult.RequestId < buildResults.Length,
@@ -455,7 +454,7 @@ BuildResult [] buildResults
                     }
                 }
                 // Check if we need to update the state
-                if (executionMode == NodeLoopExecutionMode.BaseActiveThread && !threadActive) 
+                if (executionMode == NodeLoopExecutionMode.BaseActiveThread && !threadActive)
                 {
                     continueExecution = false;
                 }
@@ -501,7 +500,7 @@ internal void ActivateThread()
         /// </summary>
         internal void WaitForResults
         (
-            int handleId, 
+            int handleId,
             BuildResult[] buildResults,
             BuildRequest [] buildRequests
         )
@@ -513,7 +512,7 @@ BuildRequest [] buildRequests
             {
                 waitingTasks.Add(handleId, taskData);
             }
-            workerThread.NodeActionLoop(workerThread.threadActive ? NodeLoopExecutionMode.WaitingActiveThread : 
+            workerThread.NodeActionLoop(workerThread.threadActive ? NodeLoopExecutionMode.WaitingActiveThread :
                                         NodeLoopExecutionMode.WaitingPassiveThread,
                                         handleId, buildResults);
             lock (waitingTasks)
diff --git a/src/Deprecated/Engine/Engine/Toolset.cs b/src/Deprecated/Engine/Engine/Toolset.cs
index 89764055263..6e96c01f231 100644
--- a/src/Deprecated/Engine/Engine/Toolset.cs
+++ b/src/Deprecated/Engine/Engine/Toolset.cs
@@ -40,8 +40,8 @@ public Toolset(string toolsVersion, string toolsPath)
         /// May be null, in which case an empty property group will be used.</param>
         public Toolset(string toolsVersion, string toolsPath, BuildPropertyGroup buildProperties)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, "toolsVersion");
-            ErrorUtilities.VerifyThrowArgumentLength(toolsPath, "toolsPath");
+            ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, nameof(toolsVersion));
+            ErrorUtilities.VerifyThrowArgumentLength(toolsPath, nameof(toolsPath));
 
             this.toolsVersion = toolsVersion;
             this.ToolsPath = toolsPath;
diff --git a/src/Deprecated/Engine/Engine/ToolsetCollection.cs b/src/Deprecated/Engine/Engine/ToolsetCollection.cs
index f7c5e536f51..c9025f7c3f6 100644
--- a/src/Deprecated/Engine/Engine/ToolsetCollection.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetCollection.cs
@@ -40,7 +40,7 @@ private ToolsetCollection()
         /// <param name="parentEngine"></param>
         internal ToolsetCollection(Engine parentEngine)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parentEngine, "parentEngine");
+            ErrorUtilities.VerifyThrowArgumentNull(parentEngine, nameof(parentEngine));
 
             this.parentEngine = parentEngine;
             this.toolsetMap = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
@@ -66,7 +66,7 @@ public Toolset this[string toolsVersion]
         {
             get
             {
-                ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, "toolsVersion");
+                ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, nameof(toolsVersion));
 
                 if (this.toolsetMap.ContainsKey(toolsVersion))
                 {
@@ -121,7 +121,7 @@ public bool IsReadOnly
         /// <param name="item"></param>
         public void Add(Toolset item)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(item, "item");
+            ErrorUtilities.VerifyThrowArgumentNull(item, nameof(item));
 
             if (toolsetMap.ContainsKey(item.ToolsVersion))
             {
diff --git a/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs b/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
index ef382bd585a..4b129cf256b 100644
--- a/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
@@ -33,7 +33,7 @@ internal ToolsetConfigurationReader()
         /// <param name="readApplicationConfiguration"></param>
         internal ToolsetConfigurationReader(ReadApplicationConfiguration readApplicationConfiguration)
         {
-            error.VerifyThrowArgumentNull(readApplicationConfiguration, "readApplicationConfiguration");
+            error.VerifyThrowArgumentNull(readApplicationConfiguration, nameof(readApplicationConfiguration));
             this.readApplicationConfiguration = readApplicationConfiguration;
         }
 
@@ -55,7 +55,7 @@ protected override IEnumerable<PropertyDefinition> ToolsVersions
                                               toolset.ElementInformation.LineNumber
                                           );
 
-                        if (toolset.toolsVersion != null && toolset.toolsVersion.Length == 0)
+                        if (toolset.toolsVersion?.Length == 0)
                         {
                             InvalidToolsetDefinitionException.Throw("InvalidToolsetValueInConfigFileValue", location);
                         }
@@ -77,7 +77,7 @@ protected override string DefaultToolsVersion
         {
             get
             {
-                return (ConfigurationSection == null ? null : ConfigurationSection.Default);
+                return ConfigurationSection?.Default;
             }
         }
 
@@ -104,7 +104,7 @@ protected override IEnumerable<PropertyDefinition> GetPropertyDefinitions(string
                                       propertyElement.ElementInformation.LineNumber
                                   );
 
-                if (propertyElement.Name != null && propertyElement.Name.Length == 0)
+                if (propertyElement.Name?.Length == 0)
                 {
                     InvalidToolsetDefinitionException.Throw("InvalidToolsetValueInConfigFileValue", location);
                 }
@@ -131,7 +131,7 @@ private ToolsetConfigurationSection ConfigurationSection
         {
             get
             {
-                if (null == configurationSection && !configurationReadAttempted)
+                if (configurationSection == null && !configurationReadAttempted)
                 {
                     try
                     {
@@ -148,7 +148,7 @@ private ToolsetConfigurationSection ConfigurationSection
                         // If section definition is not present and section is also not present, this value is null
                         // If the section definition is not present and section is present, then this value is null
 
-                        if (null != configuration)
+                        if (configuration != null)
                         {
                             configurationSection = configuration.GetSection("msbuildToolsets") as ToolsetConfigurationSection;
                         }
@@ -226,7 +226,7 @@ public string Default
                 // Note this means we can't distinguish between the attribute being present but containing
                 // an empty string for its value and the attribute not being present at all.
                 string defaultValue = (string)base["default"];
-                return (String.IsNullOrEmpty(defaultValue) ? null : defaultValue);
+                return String.IsNullOrEmpty(defaultValue) ? null : defaultValue;
             }
             set
             {
@@ -387,7 +387,7 @@ public string toolsVersion
             }
             set
             {
-                base["toolsVersion"] = value;
+                base[nameof(toolsVersion)] = value;
             }
         }
 
diff --git a/src/Deprecated/Engine/Engine/ToolsetReader.cs b/src/Deprecated/Engine/Engine/ToolsetReader.cs
index f573b78cc11..2e8cf10ce14 100644
--- a/src/Deprecated/Engine/Engine/ToolsetReader.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetReader.cs
@@ -19,12 +19,12 @@ internal class PropertyDefinition
 
         public PropertyDefinition(string name, string value, string source)
         {
-            error.VerifyThrowArgumentLength(name, "name");
-            error.VerifyThrowArgumentLength(source, "source");
+            error.VerifyThrowArgumentLength(name, nameof(name));
+            error.VerifyThrowArgumentLength(source, nameof(source));
 
             // value can be the empty string but not null
-            error.VerifyThrowArgumentNull(value, "value");
-            
+            error.VerifyThrowArgumentNull(value, nameof(value));
+
             this.name = name;
             this.value = value;
             this.source = source;
@@ -54,7 +54,7 @@ public string Value
 
         /// <summary>
         /// A description of the location where the property was defined,
-        /// such as a registry key path or a path to a config file and 
+        /// such as a registry key path or a path to a config file and
         /// line number.
         /// </summary>
         public string Source
@@ -65,7 +65,7 @@ public string Source
             }
         }
     }
-    
+
     internal abstract class ToolsetReader
     {
         /// <summary>
@@ -132,21 +132,17 @@ internal static string ReadAllToolsets(ToolsetCollection toolsets,
             // The ordering here is important because the configuration file should have greater precedence
             // than the registry
             string defaultToolsVersionFromRegistry = null;
-
-            ToolsetRegistryReader registryReaderToUse = null;
             if ((locations & ToolsetDefinitionLocations.Registry) == ToolsetDefinitionLocations.Registry)
             {
-                registryReaderToUse = registryReader == null ? new ToolsetRegistryReader() : registryReader;
+                ToolsetRegistryReader registryReaderToUse = registryReader ?? new ToolsetRegistryReader();
                 // We do not accumulate properties when reading them from the registry, because the order
                 // in which values are returned to us is essentially random: so we disallow one property
                 // in the registry to refer to another also in the registry
-                defaultToolsVersionFromRegistry = 
+                defaultToolsVersionFromRegistry =
                     registryReaderToUse.ReadToolsets(toolsets, globalProperties, initialProperties, false /* do not accumulate properties */);
             }
 
             string defaultToolsVersionFromConfiguration = null;
-            
-            ToolsetConfigurationReader configurationReaderToUse = null;
             if ((locations & ToolsetDefinitionLocations.ConfigurationFile) == ToolsetDefinitionLocations.ConfigurationFile)
             {
                 if (configurationReader == null && ConfigurationFileMayHaveToolsets())
@@ -159,13 +155,13 @@ internal static string ReadAllToolsets(ToolsetCollection toolsets,
 
                 if (configurationReader != null)
                 {
-                    configurationReaderToUse = configurationReader == null ? new ToolsetConfigurationReader() : configurationReader;
+                    ToolsetConfigurationReader configurationReaderToUse = configurationReader ?? new ToolsetConfigurationReader();
                     // Accumulation of properties is okay in the config file because it's deterministically ordered
                     defaultToolsVersionFromConfiguration =
                         configurationReaderToUse.ReadToolsets(toolsets, globalProperties, initialProperties, true /* accumulate properties */);
                 }
             }
-            
+
             // We'll use the default from the configuration file if it was specified, otherwise we'll try
             // the one from the registry.  It's possible (and valid) that neither the configuration file
             // nor the registry specify a default, in which case we'll just return null.
@@ -209,9 +205,9 @@ internal static string ReadAllToolsets(ToolsetCollection toolsets,
         }
 
         /// <summary>
-        /// Creating a ToolsetConfigurationReader, and also reading toolsets from the 
-        /// configuration file, are a little expensive. To try to avoid this cost if it's 
-        /// not necessary, we'll check if the file exists first. If it exists, we'll scan for 
+        /// Creating a ToolsetConfigurationReader, and also reading toolsets from the
+        /// configuration file, are a little expensive. To try to avoid this cost if it's
+        /// not necessary, we'll check if the file exists first. If it exists, we'll scan for
         /// the string "toolsVersion" to see if it might actually have any tools versions
         /// defined in it.
         /// </summary>
@@ -252,7 +248,7 @@ internal string ReadToolsets(ToolsetCollection toolsets,
                                      BuildPropertyGroup initialProperties,
                                      bool accumulateProperties)
         {
-            error.VerifyThrowArgumentNull(toolsets, "toolsets");
+            error.VerifyThrowArgumentNull(toolsets, nameof(toolsets));
 
             ReadEachToolset(toolsets, globalProperties, initialProperties, accumulateProperties);
 
@@ -265,7 +261,7 @@ internal string ReadToolsets(ToolsetCollection toolsets,
             // they'll get a nice error saying that toolset isn't available and listing those that are.
             return defaultToolsVersion;
         }
-        
+
         /// <summary>
         /// Reads all the toolsets and populates the given ToolsetCollection with them
         /// </summary>
@@ -313,13 +309,13 @@ private Toolset ReadToolset(PropertyDefinition toolsVersion,
             string toolsPath = null;
             string binPath = null;
             BuildPropertyGroup properties = new BuildPropertyGroup();
-            
+
             IEnumerable<PropertyDefinition> rawProperties = GetPropertyDefinitions(toolsVersion.Name);
             Expander expander = new Expander(initialProperties);
 
             foreach (PropertyDefinition property in rawProperties)
             {
-                if (0 == String.Compare(property.Name, ReservedPropertyNames.toolsPath, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(property.Name, ReservedPropertyNames.toolsPath, StringComparison.OrdinalIgnoreCase))
                 {
                     toolsPath = ExpandProperty(property, expander);
                     toolsPath = ExpandRelativePathsRelativeToExeLocation(toolsPath);
@@ -334,7 +330,7 @@ private Toolset ReadToolset(PropertyDefinition toolsVersion,
                         );
                     }
                 }
-                else if (0 == String.Compare(property.Name, ReservedPropertyNames.binPath, StringComparison.OrdinalIgnoreCase))
+                else if (String.Equals(property.Name, ReservedPropertyNames.binPath, StringComparison.OrdinalIgnoreCase))
                 {
                     binPath = ExpandProperty(property, expander);
                     binPath = ExpandRelativePathsRelativeToExeLocation(binPath);
@@ -360,7 +356,7 @@ private Toolset ReadToolset(PropertyDefinition toolsVersion,
                     // It's an arbitrary property
                     string propertyValue = ExpandProperty(property, expander);
                     PropertyDefinition expandedProperty = new PropertyDefinition(property.Name, propertyValue, property.Source);
-                    
+
                     SetProperty(expandedProperty, properties, globalProperties);
 
                     if (accumulateProperties)
@@ -368,7 +364,7 @@ private Toolset ReadToolset(PropertyDefinition toolsVersion,
                         SetProperty(expandedProperty, initialProperties, globalProperties);
                     }
                 }
-                
+
                 if (accumulateProperties)
                 {
                     expander = new Expander(initialProperties);
@@ -388,10 +384,10 @@ private Toolset ReadToolset(PropertyDefinition toolsVersion,
             }
 
             Toolset toolset = null;
-            
+
             try
             {
-                toolset = new Toolset(toolsVersion.Name, toolsPath == null ? binPath : toolsPath, properties);
+                toolset = new Toolset(toolsVersion.Name, toolsPath ?? binPath, properties);
             }
             catch (ArgumentException e)
             {
diff --git a/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs b/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs
index bb45c98d08a..075f4754872 100644
--- a/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs
@@ -51,7 +51,7 @@ internal ToolsetRegistryReader()
         /// <param name="msbuildRegistryWrapper"></param>
         internal ToolsetRegistryReader(RegistryKeyWrapper msbuildRegistryWrapper)
         {
-            error.VerifyThrowArgumentNull(msbuildRegistryWrapper, "msbuildRegistryWrapper");
+            error.VerifyThrowArgumentNull(msbuildRegistryWrapper, nameof(msbuildRegistryWrapper));
        
             this.msbuildRegistryWrapper = msbuildRegistryWrapper;
         }
@@ -125,7 +125,7 @@ protected override IEnumerable<PropertyDefinition> GetPropertyDefinitions(string
             {
                 string propertyValue = null;
 
-                if (propertyName != null && propertyName.Length == 0)
+                if (propertyName?.Length == 0)
                 {
                     InvalidToolsetDefinitionException.Throw("PropertyNameInRegistryHasZeroLength", toolsVersionWrapper.Name);
                 }
diff --git a/src/Deprecated/Engine/Engine/ToolsetState.cs b/src/Deprecated/Engine/Engine/ToolsetState.cs
index 3bfdc74d917..062a0ef03e6 100644
--- a/src/Deprecated/Engine/Engine/ToolsetState.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetState.cs
@@ -55,7 +55,7 @@ LoadXmlFromPath loadXmlFromPath
             this.parentEngine = engine;
             this.loggingServices = engine.LoggingServices;
 
-            ErrorUtilities.VerifyThrowArgumentNull(toolset, "toolset");
+            ErrorUtilities.VerifyThrowArgumentNull(toolset, nameof(toolset));
             this.toolset = toolset;
 
             this.getFiles = getFiles;
@@ -109,7 +109,6 @@ internal BuildPropertyGroup BuildProperties
             }
         }
 
-
         #endregion
 
         #region Methods
@@ -146,7 +145,7 @@ internal ITaskRegistry GetTaskRegistry(BuildEventContext buildEventContext)
         /// <param name="taskRegistry"></param>
         internal void SetTaskRegistry(ITaskRegistry taskRegistry)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(taskRegistry, "taskRegistry");
+            ErrorUtilities.VerifyThrowArgumentNull(taskRegistry, nameof(taskRegistry));
             defaultTasksRegistrationAttempted = true;
             defaultTaskRegistry = taskRegistry;
         }
@@ -231,7 +230,7 @@ private void RegisterDefaultTasks(BuildEventContext buildEventContext)
                                     ProjectErrorUtilities.VerifyThrowInvalidProject(topLevelNode.LocalName == XMakeElements.project,
                                         topLevelNode, "UnrecognizedElement", topLevelNode.Name);
 
-                                    ProjectErrorUtilities.VerifyThrowInvalidProject((topLevelNode.Prefix.Length == 0) && (String.Compare(topLevelNode.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase) == 0),
+                                    ProjectErrorUtilities.VerifyThrowInvalidProject((topLevelNode.Prefix.Length == 0) && (String.Equals(topLevelNode.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase)),
                                         topLevelNode, "ProjectMustBeInMSBuildXmlNamespace", XMakeAttributes.defaultXmlNamespace);
 
                                     // the <Project> tag can only the XML namespace -- no other attributes
diff --git a/src/Deprecated/Engine/Engine/UsingTask.cs b/src/Deprecated/Engine/Engine/UsingTask.cs
index 0ce6469a9cc..ecc52eb687a 100644
--- a/src/Deprecated/Engine/Engine/UsingTask.cs
+++ b/src/Deprecated/Engine/Engine/UsingTask.cs
@@ -37,7 +37,7 @@ public bool IsImported
         /// <owner>LukaszG</owner>
         public string TaskName
         {
-            get { return (this.taskNameAttribute != null) ? this.taskNameAttribute.Value : null; }
+            get { return this.taskNameAttribute?.Value; }
         }
 
         /// <summary>
@@ -56,7 +56,7 @@ internal XmlAttribute TaskNameAttribute
         /// <owner>LukaszG</owner>
         public string AssemblyName
         {
-            get { return (this.assemblyNameAttribute != null) ? this.assemblyNameAttribute.Value : null; }
+            get { return this.assemblyNameAttribute?.Value; }
         }
 
         /// <summary>
@@ -75,7 +75,7 @@ internal XmlAttribute AssemblyNameAttribute
         /// <owner>LukaszG</owner>
         public string AssemblyFile
         {
-            get { return (this.assemblyFileAttribute != null) ? this.assemblyFileAttribute.Value : null; }
+            get { return this.assemblyFileAttribute?.Value; }
         }
 
         /// <summary>
@@ -94,7 +94,7 @@ internal XmlAttribute AssemblyFileAttribute
         /// <owner>LukaszG</owner>
         public string Condition
         {
-            get { return (this.conditionAttribute != null) ? this.conditionAttribute.Value : null; }
+            get { return this.conditionAttribute?.Value; }
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Engine/Utilities.cs b/src/Deprecated/Engine/Engine/Utilities.cs
index eb54fda085a..ce453502b25 100644
--- a/src/Deprecated/Engine/Engine/Utilities.cs
+++ b/src/Deprecated/Engine/Engine/Utilities.cs
@@ -476,7 +476,7 @@ private static bool ContainsNoTagsOtherThanComments(string innerXml, int firstLe
                     {
                         // Found the start of a comment
                         insideComment = true;
-                        i = i + 3;
+                        i += 3;
                         continue;
                     }
                 }
@@ -500,7 +500,7 @@ private static bool ContainsNoTagsOtherThanComments(string innerXml, int firstLe
                     {
                         // Found the end of a comment
                         insideComment = false;
-                        i = i + 2;
+                        i += 2;
                         continue;
                     }
                 }
diff --git a/src/Deprecated/Engine/Engine/XmlSearcher.cs b/src/Deprecated/Engine/Engine/XmlSearcher.cs
index f6a663a3ebf..c2ffefb6f1f 100644
--- a/src/Deprecated/Engine/Engine/XmlSearcher.cs
+++ b/src/Deprecated/Engine/Engine/XmlSearcher.cs
@@ -239,7 +239,7 @@ out int foundColumnNumber
             )
         {
             ErrorUtilities.VerifyThrow(xmlElementNumberToSearchFor != 0, "No element to search for!");
-            ErrorUtilities.VerifyThrow((projectFile != null) && (projectFile.Length != 0), "No project file!");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(projectFile), "No project file!");
 
             // Initialize output parameters.
             foundLineNumber = 0;
@@ -282,7 +282,7 @@ out int foundColumnNumber
                                         // letter of the tag name, whereas we would prefer to point at the opening
                                         // left-angle-bracket.  (Whitespace between the left-angle-bracket and
                                         // the tag name is not allowed in XML, so this is safe.)
-                                        foundColumnNumber = foundColumnNumber - 1;
+                                        foundColumnNumber--;
                                     }
                                 }
                                 else if (reader.MoveToFirstAttribute()) 
@@ -327,7 +327,7 @@ out int foundColumnNumber
                 // Eat the exception.  If anything fails, we simply don't surface the line/column number.
             }
 
-            return ((foundColumnNumber != 0) && (foundLineNumber != 0));
+            return (foundColumnNumber != 0) && (foundLineNumber != 0);
         }
     }
 }
diff --git a/src/Deprecated/Engine/Errors/InternalLoggerException.cs b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
index 54447515463..22f730e348c 100644
--- a/src/Deprecated/Engine/Errors/InternalLoggerException.cs
+++ b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
@@ -84,19 +84,19 @@ public InternalLoggerException(string message, Exception innerException)
         /// <param name="helpKeyword"></param>
         internal InternalLoggerException
         (
-            string message, 
-            Exception innerException, 
-            BuildEventArgs e, 
-            string errorCode, 
-            string helpKeyword, 
+            string message,
+            Exception innerException,
+            BuildEventArgs e,
+            string errorCode,
+            string helpKeyword,
             bool initializationException
          )
             : base(message, innerException)
         {
-            ErrorUtilities.VerifyThrow((message != null) && (message.Length > 0), "Need error message.");
-            ErrorUtilities.VerifyThrow(innerException != null || initializationException == true, "Need the logger exception.");
-            ErrorUtilities.VerifyThrow((errorCode != null) && (errorCode.Length > 0), "Must specify the error message code.");
-            ErrorUtilities.VerifyThrow((helpKeyword != null) && (helpKeyword.Length > 0), "Must specify the help keyword for the IDE.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(message), "Need error message.");
+            ErrorUtilities.VerifyThrow(innerException != null || initializationException, "Need the logger exception.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(errorCode), "Must specify the error message code.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(helpKeyword), "Must specify the help keyword for the IDE.");
 
             this.e = e;
             this.errorCode = errorCode;
@@ -107,7 +107,7 @@ bool initializationException
         #region Serialization (update when adding new class members)
 
         /// <summary>
-        /// Protected constructor used for (de)serialization. 
+        /// Protected constructor used for (de)serialization.
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
         /// <param name="info"></param>
@@ -220,11 +220,11 @@ public bool InitializationException
         /// <param name="messageArgs"></param>
         internal static void Throw
         (
-            Exception innerException, 
-            BuildEventArgs e, 
-            string messageResourceName, 
+            Exception innerException,
+            BuildEventArgs e,
+            string messageResourceName,
             bool initializationException,
-            params string[] messageArgs 
+            params string[] messageArgs
         )
         {
             ErrorUtilities.VerifyThrow(messageResourceName != null, "Need error message.");
diff --git a/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs b/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
index b3946d77c9c..63d3c34a620 100644
--- a/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
+++ b/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
@@ -137,7 +137,7 @@ string helpKeyword
         ) : 
             base(message)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(message, "message");
+            ErrorUtilities.VerifyThrowArgumentLength(message, nameof(message));
 
             if (xmlNode != null)
             {
@@ -178,8 +178,8 @@ string helpKeyword
         ) : 
             base(message)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentLength(message, "message");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentLength(message, nameof(message));
 
             this.projectFile = projectFile;
             this.lineNumber = lineNumber;
diff --git a/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs b/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
index 2c54e13abf3..7e24aef9654 100644
--- a/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
@@ -56,7 +56,7 @@ public InvalidToolsetDefinitionException(string message, Exception innerExceptio
         protected InvalidToolsetDefinitionException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
             this.errorCode = info.GetString("errorCode");
         }
@@ -93,7 +93,7 @@ public InvalidToolsetDefinitionException(string message, string errorCode, Excep
         [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
         override public void GetObjectData(SerializationInfo info, StreamingContext context)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
             base.GetObjectData(info, context);
 
diff --git a/src/Deprecated/Engine/Errors/RemoteErrorException.cs b/src/Deprecated/Engine/Errors/RemoteErrorException.cs
index 1e040579d39..00839224075 100644
--- a/src/Deprecated/Engine/Errors/RemoteErrorException.cs
+++ b/src/Deprecated/Engine/Errors/RemoteErrorException.cs
@@ -19,7 +19,7 @@ public sealed class RemoteErrorException : Exception
         internal RemoteErrorException(string message, Exception innerException, BuildEventContext buildEventContext)
             : base(message, innerException)
         {
-            ErrorUtilities.VerifyThrow((message != null) && (message.Length > 0), "Need error message.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(message), "Need error message.");
             ErrorUtilities.VerifyThrow(innerException != null, "Need the logger exception.");
 
             this.buildEventContext = buildEventContext;
diff --git a/src/Deprecated/Engine/Introspector/Introspector.cs b/src/Deprecated/Engine/Introspector/Introspector.cs
index a829277fe83..1946f84a967 100644
--- a/src/Deprecated/Engine/Introspector/Introspector.cs
+++ b/src/Deprecated/Engine/Introspector/Introspector.cs
@@ -214,7 +214,6 @@ private void LogOrDumpError(string resourceName, params object[] args)
         /// </summary>
         private void AddTargetStatesToCycleDetector(NodeStatus[] nodeStatus, TargetCycleDetector cycleDetector)
         {
-
             for (int i = 0; i < nodeStatus.Length; i++)
             {
                cycleDetector.AddTargetsToGraph(nodeStatus[i].StateOfInProgressTargets);
@@ -230,7 +229,6 @@ private void GatherNodeInformationForShutdown(NodeStatus[] nodeStatus, NodeStatu
         {
             for (int i = 0; i < nodeStatus.Length; i++)
             {
-
                 TimeSpan timeSinceLastNodeTaskActivity = new TimeSpan(nodeStatus[i].TimeSinceLastTaskActivity);
                 TimeSpan timeSinceLastNodeLoopActivity = new TimeSpan(nodeStatus[i].TimeSinceLastLoopActivity);
  
@@ -253,7 +251,6 @@ private void GatherNodeInformationForShutdown(NodeStatus[] nodeStatus, NodeStatu
             }
 
             parentEngine.Scheduler.DumpState();
-
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Introspector/NodeStatus.cs b/src/Deprecated/Engine/Introspector/NodeStatus.cs
index 054fd1a125f..72665029a69 100644
--- a/src/Deprecated/Engine/Introspector/NodeStatus.cs
+++ b/src/Deprecated/Engine/Introspector/NodeStatus.cs
@@ -98,7 +98,7 @@ internal long TimeSinceLastTaskActivity
         {
             get
             {
-                return (statusTimeStamp - lastTaskActivityTimeStamp);
+                return statusTimeStamp - lastTaskActivityTimeStamp;
             }
         }
 
@@ -110,7 +110,7 @@ internal long TimeSinceLastLoopActivity
         {
             get
             {
-                return (statusTimeStamp - lastEngineActivityTimeStamp);
+                return statusTimeStamp - lastEngineActivityTimeStamp;
             }
         }
 
diff --git a/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs b/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs
index 8778f8bcc85..90d499820e2 100644
--- a/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs
+++ b/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs
@@ -9,17 +9,16 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class is used to construct and analyze the graph of inprogress targets in order to find
-    /// cycles inside the graph. To find cycles a post order traversal is used to assign a post order 
+    /// cycles inside the graph. To find cycles a post order traversal is used to assign a post order
     /// traversal to each node. Back edges indicate cycles in the graph and they can indentified by
-    /// a link from lower index node to a higher index node. 
-    /// 
+    /// a link from lower index node to a higher index node.
+    ///
     /// The graph arrives in pieces from individual nodes and needs to be stiched together by identifying
-    /// the parent and child for each cross node link. To do that it is necessary to match up parent 
+    /// the parent and child for each cross node link. To do that it is necessary to match up parent
     /// build request for a child with and outstanding request from the parent (see LinkCrossNodeBuildRequests)
     /// </summary>
     internal class TargetCycleDetector
@@ -138,7 +137,7 @@ internal bool FindCycles()
             // First try to perform the traversal from the roots (i.e nodes that are due to host requests)
             foreach (GraphNode node in dependencyGraph.Values)
             {
-                if (node.isRoot == true && node.traversalIndex == GraphNode.InvalidIndex)
+                if (node.isRoot && node.traversalIndex == GraphNode.InvalidIndex)
                 {
                     BreadthFirstTraversal(node);
                 }
@@ -165,7 +164,7 @@ internal bool FindCycles()
                 }
             }
 
-            return (cycleParent != null);
+            return cycleParent != null;
         }
 
         /// <summary>
@@ -177,7 +176,7 @@ private void LinkCrossNodeBuildRequests()
         {
             foreach (GraphNode node in dependencyGraph.Values)
             {
-                TargetInProgessState.TargetIdWrapper[] parentsForBuildRequests = 
+                TargetInProgessState.TargetIdWrapper[] parentsForBuildRequests =
                     new TargetInProgessState.TargetIdWrapper[node.targetState.ParentBuildRequests.Count];
 
                 for (int j = 0; j < node.targetState.ParentBuildRequests.Count; j++ )
@@ -236,7 +235,7 @@ private void LinkCrossNodeBuildRequests()
                             {
                                 // Verify that the project name is the same
                                 ErrorUtilities.VerifyThrow(
-                                    String.Compare(buildRequest.ProjectFileName, externalRequests[i].ProjectFileName, StringComparison.OrdinalIgnoreCase) == 0,
+                                    String.Equals(buildRequest.ProjectFileName, externalRequests[i].ProjectFileName, StringComparison.OrdinalIgnoreCase),
                                     "The two requests should have the same project name");
 
                                 // Link the two graph nodes together
@@ -317,10 +316,10 @@ private void DumpCycleSequence(GraphNode parent, GraphNode child)
             {
                 node.traversalIndex = GraphNode.InvalidIndex;
             }
-            BuildEventContext buildEventContext = 
+            BuildEventContext buildEventContext =
                 new BuildEventContext(child.targetState.TargetId.nodeId,
-                                 child.targetState.TargetId.id, 
-                                 BuildEventContext.InvalidProjectContextId, 
+                                 child.targetState.TargetId.id,
+                                 BuildEventContext.InvalidProjectContextId,
                                  BuildEventContext.InvalidTaskId
                                 );
             DumpCycleSequenceOutput(parent, child, buildEventContext);
diff --git a/src/Deprecated/Engine/Introspector/TargetInProgressState.cs b/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
index 52ff67e5b6d..41e647d7dd5 100644
--- a/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
+++ b/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
@@ -59,7 +59,7 @@ string projectName
         /// </summary>
         private void ProcessBuildContext(EngineCallback engineCallback, ProjectBuildState buildContext, Target target)
         {
-            BuildRequest parentRequest = null;
+            BuildRequest parentRequest;
             TargetIdWrapper parentName = FindParentTarget(engineCallback, buildContext, target, out parentRequest);
 
             if (parentName != null)
@@ -201,7 +201,7 @@ out BuildRequest parentRequest
             {
                 // The build context must have formed due to IBuildEngine call
                 ErrorUtilities.VerifyThrow(
-                    String.Compare(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), target.Name, StringComparison.OrdinalIgnoreCase) == 0,
+                    String.Equals(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), target.Name, StringComparison.OrdinalIgnoreCase),
                     "The target should be the in progress target for the context");
                 // This target is called due to IBuildEngine or host request
                 return FindParentTargetForBuildRequest(engineCallback, buildContext.BuildRequest, out parentRequest);
@@ -254,7 +254,6 @@ out BuildRequest parentTriggeringRequest
             return null;
         }
 
-
         /// <summary>
         /// This function checks if the given ProjectBuildState is caused by a given parent target (via
         /// a dependency, onerror or IBuildEngine relationship)
@@ -267,11 +266,11 @@ internal bool CheckBuildContextForParentMatch
             ProjectBuildState projectBuildState
         )
         {
-            BuildRequest parentRequest = null;
+            BuildRequest parentRequest;
             TargetInProgessState.TargetIdWrapper parentName =
                 FindParentTarget(engineCallback, projectBuildState, target, out parentRequest);
 
-            if (parentName != null && parentName.Equals(parentId))
+            if (parentName?.Equals(parentId) == true)
             {
                 return true;
             }
@@ -582,7 +581,7 @@ public override bool Equals(object obj)
                 if (other != null)
                 {
                     if (other.projectId == projectId && other.nodeId == nodeId &&
-                        (String.Compare(other.name, name, StringComparison.OrdinalIgnoreCase) == 0))
+                        (String.Equals(other.name, name, StringComparison.OrdinalIgnoreCase)))
                     {
                         return true;
                     }
diff --git a/src/Deprecated/Engine/Items/BuildItem.cs b/src/Deprecated/Engine/Items/BuildItem.cs
index 8abbf2b1924..b34b7ec2f67 100644
--- a/src/Deprecated/Engine/Items/BuildItem.cs
+++ b/src/Deprecated/Engine/Items/BuildItem.cs
@@ -419,7 +419,7 @@ private void BuildItemHelper(XmlDocument ownerDocument, string itemName, string
             // Only check for null. It's legal to make BuildItems with empty
             // item specs -- this is to be consistent with how we shipped TaskItem.
             // See #567058.
-            ErrorUtilities.VerifyThrowArgumentNull(itemInclude, "itemInclude");
+            ErrorUtilities.VerifyThrowArgumentNull(itemInclude, nameof(itemInclude));
 
             // Validate that the item name doesn't contain any illegal characters.
             if (itemName != null)
@@ -505,7 +505,7 @@ internal BuildItem(XmlElement itemElement, bool importedFromAnotherProject, bool
         /// </summary>
         public BuildItem(string itemName, ITaskItem taskItem) 
         {
-            ErrorUtilities.VerifyThrowArgumentNull(taskItem, "taskItem");
+            ErrorUtilities.VerifyThrowArgumentNull(taskItem, nameof(taskItem));
 
             string itemInclude = EscapingUtilities.Escape(taskItem.ItemSpec);
 
@@ -647,7 +647,7 @@ public string Include
                 {
                     // If this is an evaluated item that originated from the project file, and the original
                     // item is declared using a wildcard that still matches the new item spec ...
-                    if ((ParentPersistedItem != null) && (ParentPersistedItem.NewItemSpecMatchesExistingWildcard(value)))
+                    if ((ParentPersistedItem?.NewItemSpecMatchesExistingWildcard(value) == true))
                     {
                         // Don't need to touch the project file since the original wildcard still matches
                         // the new item spec.  But it still should be reevaluated the next time around.
@@ -704,7 +704,7 @@ public int MetadataCount
         {
             get
             {
-                return (GetCustomMetadataCount() + FileUtilities.ItemSpecModifiers.All.Length);
+                return GetCustomMetadataCount() + FileUtilities.ItemSpecModifiers.All.Length;
             }
         }
 
@@ -741,7 +741,7 @@ public int CustomMetadataCount
         /// </summary>
         internal XmlAttribute IncludeAttribute
         {
-            get { return (IsBackedByXml ? xml.IncludeAttribute : null); }
+            get { return IsBackedByXml ? xml.IncludeAttribute : null; }
         }
 
         /// <summary>
@@ -750,7 +750,7 @@ internal XmlAttribute IncludeAttribute
         /// <owner>RGoel</owner>
         public string Exclude
         {
-            get { return (IsBackedByXml ? xml.Exclude : String.Empty); }
+            get { return IsBackedByXml ? xml.Exclude : String.Empty; }
 
             set
             {
@@ -772,7 +772,7 @@ public string Exclude
         /// <owner>RGoel</owner>
         internal XmlAttribute ExcludeAttribute
         {
-            get { return (IsBackedByXml ? xml.ExcludeAttribute : null); }
+            get { return IsBackedByXml ? xml.ExcludeAttribute : null; }
         }
 
         /// <summary>
@@ -781,7 +781,7 @@ internal XmlAttribute ExcludeAttribute
         /// <owner>RGoel</owner>
         public string Condition
         {
-            get { return (IsBackedByXml ? xml.Condition : String.Empty); }
+            get { return IsBackedByXml ? xml.Condition : String.Empty; }
 
             set
             {
@@ -806,7 +806,7 @@ public string Condition
         /// <owner>RGoel</owner>
         internal XmlAttribute ConditionAttribute
         {
-            get { return (IsBackedByXml ? xml.ConditionAttribute : null); }
+            get { return IsBackedByXml ? xml.ConditionAttribute : null; }
         }
 
         /// <summary>
@@ -816,7 +816,7 @@ internal XmlAttribute ConditionAttribute
         /// <value>The item XmlElement, or null if item is virtual.</value>
         internal XmlElement ItemElement
         {
-            get { return (IsBackedByXml ? xml.Element : null); }
+            get { return IsBackedByXml ? xml.Element : null; }
         }
 
         /// <summary>
@@ -910,7 +910,7 @@ internal BuildItemGroup ChildItems
 
         internal bool IsUninitializedItem
         {
-            get { return (this.name == null); }
+            get { return this.name == null; }
         }
 
         /// <summary>
@@ -935,7 +935,7 @@ internal bool IsBackedByXml
         /// </summary>
         internal bool IsBackedUp
         {
-            get { return (unevaluatedCustomMetadataBackup != null); }
+            get { return unevaluatedCustomMetadataBackup != null; }
         }
 
         #endregion
@@ -953,9 +953,7 @@ internal bool IsBackedUp
         internal IDictionary CloneCustomMetadata() 
         {
             IDictionary result = (IDictionary)this.evaluatedCustomMetadata.Clone();
-            result = MergeDefaultMetadata(result);
-
-            return result; 
+            return MergeDefaultMetadata(result);
         }
 
         /// <summary>
@@ -1196,7 +1194,6 @@ BuildEventContext buildEventContext
 
                         // Add this metadata to the running table we're using, so that one piece of metadata can refer to another one above
                         expander.SetMetadataInMetadataTable(name, metadataElement.Name, evaluatedMetadataValue);
-
                     }
                 }
             }
@@ -1208,7 +1205,7 @@ BuildEventContext buildEventContext
         /// <remarks>BuildItem-spec modifiers are treated as metadata.</remarks>
         public bool HasMetadata(string metadataName)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(metadataName, "metadataName");
+            ErrorUtilities.VerifyThrowArgumentLength(metadataName, nameof(metadataName));
             ErrorUtilities.VerifyThrow(this.unevaluatedCustomMetadata != null, "Item not initialized properly. unevaluatedCustomAttributes is null.");
 #if DEBUG
             // The hashtable of metadata (this.unevaluatedCustomMetadata) should never contain 
@@ -1249,8 +1246,7 @@ public bool HasMetadata(string metadataName)
         /// <exception cref="InvalidOperationException">Thrown when the requested metadata is not applicable to the item.</exception>
         public string GetMetadata(string metadataName)
         {
-            string metadataValue = null;
-
+            string metadataValue;
             if (FileUtilities.IsItemSpecModifier(metadataName))
             {
                 // BUGBUG VSWhidbey 377466.  If this method is being called directly by an OM
@@ -1275,7 +1271,7 @@ public string GetMetadata(string metadataName)
                 metadataValue = GetDefaultMetadataValue(metadataName);
             } 
 
-            return (metadataValue == null) ? String.Empty : metadataValue;
+            return metadataValue ?? String.Empty;
         }
 
         /// <summary>
@@ -1300,8 +1296,7 @@ public string GetEvaluatedMetadata(string metadataName)
         /// <exception cref="InvalidOperationException">Thrown when the requested attribute is not applicable to the item.</exception>
         internal string GetEvaluatedMetadataEscaped(string metadataName)
         {
-            string metadataValue = null;
-
+            string metadataValue;
             if (FileUtilities.IsItemSpecModifier(metadataName))
             {
                 // BUGBUG VSWhidbey 377466.  If this method is being called directly by an OM
@@ -1326,7 +1321,7 @@ internal string GetEvaluatedMetadataEscaped(string metadataName)
                 metadataValue = GetDefaultMetadataValue(metadataName);
             }              
 
-            return (metadataValue == null) ? String.Empty : metadataValue;
+            return metadataValue ?? String.Empty;
         }
 
         /// <summary>
@@ -1381,7 +1376,7 @@ internal int GetCustomMetadataCount()
         /// <param name="destinationItem">BuildItem to copy custom attributes to</param>
         public void CopyCustomMetadataTo(BuildItem destinationItem)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(destinationItem, "destinationItem");
+            ErrorUtilities.VerifyThrowArgumentNull(destinationItem, nameof(destinationItem));
 
             if (IsBackedByXml)
             {
@@ -1523,8 +1518,8 @@ private void VerifyForMetadataSet(string metadataName, string metadataValue)
             ErrorUtilities.VerifyThrowArgument(!FileUtilities.IsDerivableItemSpecModifier(metadataName),
                 "Shared.CannotChangeItemSpecModifiers", metadataName);
 
-            ErrorUtilities.VerifyThrowArgumentLength(metadataName, "metadataName");
-            ErrorUtilities.VerifyThrowArgumentNull(metadataValue, "metadataValue");
+            ErrorUtilities.VerifyThrowArgumentLength(metadataName, nameof(metadataName));
+            ErrorUtilities.VerifyThrowArgumentNull(metadataValue, nameof(metadataValue));
 
             // Make sure the metadata doesn't use any special characters in the name.
             XmlUtilities.VerifyThrowValidElementName(metadataName);
@@ -1662,7 +1657,7 @@ private string GetItemSpecModifier(string modifier)
 
             if (modifiedItemSpec.Length == 0)
             {
-                if (String.Compare(modifier, FileUtilities.ItemSpecModifiers.RecursiveDir, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(modifier, FileUtilities.ItemSpecModifiers.RecursiveDir, StringComparison.OrdinalIgnoreCase))
                 {
                     modifiedItemSpec = ExtractRecursivePortionOfFinalItemSpecDirectory();
 
@@ -1776,10 +1771,7 @@ private Project GetParentProject()
         private void MarkItemAsDirty()
         {
             Project parentProject = GetParentProject();
-            if (parentProject != null)
-            {
-                parentProject.MarkProjectAsDirty();
-            }
+            parentProject?.MarkProjectAsDirty();
         }
 
         /// <summary>
@@ -1789,10 +1781,7 @@ private void MarkItemAsDirty()
         private void MarkItemAsDirtyForReevaluation()
         {
             Project parentProject = GetParentProject();
-            if (parentProject != null)
-            {
-                parentProject.MarkProjectAsDirtyForReevaluation();
-            }
+            parentProject?.MarkProjectAsDirtyForReevaluation();
         }
 
         /// <summary>
@@ -1877,10 +1866,7 @@ private void SplitItem()
         /// <owner>rgoel</owner>
         internal void SplitChildItemIfNecessary()
         {
-            if (this.ParentPersistedItem != null)
-            {
-                this.ParentPersistedItem.SplitItem();
-            }
+            this.ParentPersistedItem?.SplitItem();
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Items/BuildItemGroup.cs b/src/Deprecated/Engine/Items/BuildItemGroup.cs
index f80ff6d33d8..a8ce9e29aac 100644
--- a/src/Deprecated/Engine/Items/BuildItemGroup.cs
+++ b/src/Deprecated/Engine/Items/BuildItemGroup.cs
@@ -17,7 +17,7 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class represents a collection of items.  It may be represented
-    /// physically by an &lt;ItemGroup&gt; element persisted in the project file, 
+    /// physically by an &lt;ItemGroup&gt; element persisted in the project file,
     /// or it may just be a virtual BuildItemGroup (e.g., the evaluated items).
     /// </summary>
     [DebuggerDisplay("BuildItemGroup (Count = { Count }, Condition = { Condition })")]
@@ -119,7 +119,7 @@ public string Condition
         {
             get
             {
-                return (IsPersisted ? xml.Condition : String.Empty);
+                return IsPersisted ? xml.Condition : String.Empty;
             }
 
             set
@@ -363,7 +363,7 @@ internal void AddExistingItemAt(int index, BuildItem itemToAdd)
         /// <summary>
         /// Adds an BuildItem to this BuildItemGroup.  If this is a persisted BuildItemGroup, then
         /// this method also inserts the BuildItem's XML into the appropriate location
-        /// in the XML document.  For persisted ItemGroups, the behavior is that 
+        /// in the XML document.  For persisted ItemGroups, the behavior is that
         /// it tries to insert the new BuildItem such that it is "near" other items of the
         /// same type.  ("Near" is defined as just after the last existing item
         /// of the same type, or at the end if none is found.)
@@ -392,7 +392,7 @@ internal void AddItem(BuildItem itemToAdd)
                 int insertionIndex = items.Count;
                 for (int i = 0; i < items.Count; i++)
                 {
-                    if ( 0 == String.Compare(itemToAdd.Name, items[i].Name, StringComparison.OrdinalIgnoreCase))
+                    if ( String.Equals(itemToAdd.Name, items[i].Name, StringComparison.OrdinalIgnoreCase))
                     {
                         insertionIndex = i + 1;
 
@@ -439,7 +439,7 @@ internal void AddItem(BuildItem itemToAdd)
         }
 
         /// <summary>
-        /// Creates a new BuildItem defined by the given "Type" and "Include", and 
+        /// Creates a new BuildItem defined by the given "Type" and "Include", and
         /// adds it to the end of this BuildItemGroup.
         /// If the group is persisted, the item is persisted; otherwise it is virtual
         /// </summary>
@@ -453,7 +453,7 @@ public BuildItem AddNewItem(string itemName, string itemInclude)
                 newItem = new BuildItem(xml.OwnerDocument, itemName, itemInclude, parentProject.ItemDefinitionLibrary);
             }
             else
-            { 
+            {
                 // Create a new virtual BuildItem.
                 newItem = new BuildItem(itemName, itemInclude);
             }
@@ -539,8 +539,8 @@ private void RemoveItemElement(BuildItem item)
         /// <summary>
         /// Clones the BuildItemGroup.  A shallow clone here is one that references
         /// the same BuildItem objects as the original, whereas a deep clone actually
-        /// clones the BuildItem objects as well.  If this is a persisted BuildItemGroup, 
-        /// only deep clones are allowed, because you can't have the same XML 
+        /// clones the BuildItem objects as well.  If this is a persisted BuildItemGroup,
+        /// only deep clones are allowed, because you can't have the same XML
         /// element belonging to two parents.
         /// </summary>
         public BuildItemGroup Clone(bool deepClone)
@@ -663,10 +663,7 @@ internal void RemoveAllIntermediateItems()
         /// </summary>
         private void MarkItemGroupAsDirty()
         {
-            if (parentProject != null)
-            {
-                parentProject.MarkProjectAsDirty();
-            }
+            parentProject?.MarkProjectAsDirty();
         }
 
         /// <summary>
@@ -715,7 +712,7 @@ internal bool IsPersisted
         /// </summary>
         internal bool IsBackedUp
         {
-            get { return (persistedItemBackup != null); }
+            get { return persistedItemBackup != null; }
         }
 
         /// <summary>
@@ -747,7 +744,7 @@ private void MustBeInitialized()
         /// </summary>
         private void MustHaveThisParentElement(BuildItem item)
         {
-            ErrorUtilities.VerifyThrowInvalidOperation(item != null && item.ItemElement != null && item.ItemElement.ParentNode == xml.Element, "ItemDoesNotBelongToItemGroup");
+            ErrorUtilities.VerifyThrowInvalidOperation(item?.ItemElement?.ParentNode == xml.Element, "ItemDoesNotBelongToItemGroup");
         }
 
         /// <summary>
@@ -767,8 +764,8 @@ internal void Evaluate
         (
             BuildPropertyGroup existingProperties,
             Hashtable existingItemsByName,
-            bool collectItemsIgnoringCondition, 
-            bool collectItemsRespectingCondition, 
+            bool collectItemsIgnoringCondition,
+            bool collectItemsRespectingCondition,
             ProcessingPass pass
         )
         {
@@ -778,7 +775,7 @@ ProcessingPass pass
             Expander expander = new Expander(existingProperties, existingItemsByName, ExpanderOptions.ExpandAll);
 
             bool itemGroupCondition = Utilities.EvaluateCondition(Condition,
-                                                         (IsPersisted ? xml.ConditionAttribute : null),
+                                                         IsPersisted ? xml.ConditionAttribute : null,
                                                          expander,
                                                          ParserOptions.AllowPropertiesAndItemLists,
                                                          parentProject);
@@ -897,7 +894,7 @@ bool expandMetadata
                     itemsToInclude.RemoveItem(item);
                 }
             }
-            
+
             return itemsToInclude;
         }
 
diff --git a/src/Deprecated/Engine/Items/ItemDefinitionLibrary.cs b/src/Deprecated/Engine/Items/ItemDefinitionLibrary.cs
index d632df67c55..aeac9827c4a 100644
--- a/src/Deprecated/Engine/Items/ItemDefinitionLibrary.cs
+++ b/src/Deprecated/Engine/Items/ItemDefinitionLibrary.cs
@@ -241,9 +241,9 @@ private void EvaluateItemDefinitionElement(XmlElement itemDefinitionElement, Bui
 
                 XmlAttribute conditionAttribute = ProjectXmlUtilities.GetConditionAttribute(itemDefinitionElement, /* sole attribute */ true);
                 string condition = ProjectXmlUtilities.GetAttributeValue(conditionAttribute);
-
-                MetadataDictionary metadataDictionary = null;
                 string itemType = itemDefinitionElement.Name;
+
+                MetadataDictionary metadataDictionary;
                 itemDefinitionsDictionary.TryGetValue(itemType, out metadataDictionary);
 
                 Expander expander = new Expander(properties, itemType, metadataDictionary);
@@ -274,9 +274,9 @@ private void EvaluateItemDefinitionChildElement(XmlElement itemDefinitionChildEl
 
                 XmlAttribute conditionAttribute = ProjectXmlUtilities.GetConditionAttribute(itemDefinitionChildElement, /* sole attribute */ true);
                 string condition = ProjectXmlUtilities.GetAttributeValue(conditionAttribute);
-
-                MetadataDictionary metadataDictionary = null;
                 string itemType = itemDefinitionChildElement.ParentNode.Name;
+
+                MetadataDictionary metadataDictionary;
                 itemDefinitionsDictionary.TryGetValue(itemType, out metadataDictionary);
 
                 Expander expander = new Expander(properties, itemType, metadataDictionary);
diff --git a/src/Deprecated/Engine/Items/ItemExpander.cs b/src/Deprecated/Engine/Items/ItemExpander.cs
index 56f3737c2f7..f53cd289186 100644
--- a/src/Deprecated/Engine/Items/ItemExpander.cs
+++ b/src/Deprecated/Engine/Items/ItemExpander.cs
@@ -186,12 +186,11 @@ internal static BuildItemGroup ItemizeItemVector
             out Match itemVectorMatch
         )
         {
-            itemVectorMatch = null;
             BuildItemGroup items = null;
 
             itemVectorMatch = GetItemVectorMatches(itemVectorExpression);
 
-            if (itemVectorMatch != null && itemVectorMatch.Success)
+            if (itemVectorMatch?.Success == true)
             {
                 // The method above reports a match if there are any
                 // valid @(itemlist) references in the given expression.
@@ -236,7 +235,7 @@ internal static bool ExpressionContainsItemVector(string expression)
         {
             Match itemVectorMatch = GetItemVectorMatches(expression);
 
-            if (itemVectorMatch != null && itemVectorMatch.Success)
+            if (itemVectorMatch?.Success == true)
             {
                 return true;
             }
@@ -288,7 +287,7 @@ private BuildItemGroup ItemizeItemVector(Match itemVector)
             }
             else
             {
-                items = items.Clone((transform != null) /* deep clone on transforms because we're actually creating new items */);
+                items = items.Clone(transform != null /* deep clone on transforms because we're actually creating new items */);
             }
 
             if (transform != null)
diff --git a/src/Deprecated/Engine/Items/TaskItem.cs b/src/Deprecated/Engine/Items/TaskItem.cs
index afc43738a54..9b2f69fda41 100644
--- a/src/Deprecated/Engine/Items/TaskItem.cs
+++ b/src/Deprecated/Engine/Items/TaskItem.cs
@@ -12,7 +12,6 @@
 
 namespace Microsoft.Build.BuildEngine
 {
-
     /// <summary>
     /// This class wraps a project item, and provides a "view" on the item's BuildItem class that is suitable to expose to tasks.
     /// </summary>
@@ -98,7 +97,6 @@ public int MetadataCount
             }
         }
 
-
         /// <summary>
         /// Gets the names of custom metadata on the item
         /// </summary>
@@ -132,7 +130,7 @@ public int CustomMetadataCount
         /// <returns>value of metadata</returns>
         public string GetMetadata(string metadataName)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(metadataName, "metadataName");
+            ErrorUtilities.VerifyThrowArgumentNull(metadataName, nameof(metadataName));
 
             // Return the unescaped data to the task.
             return item.GetEvaluatedMetadata(metadataName);
@@ -146,8 +144,8 @@ public string GetMetadata(string metadataName)
         /// <param name="metadataValue"></param>
         public void SetMetadata(string metadataName, string metadataValue)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(metadataName, "metadataName");
-            ErrorUtilities.VerifyThrowArgumentNull(metadataValue, "metadataValue");
+            ErrorUtilities.VerifyThrowArgumentLength(metadataName, nameof(metadataName));
+            ErrorUtilities.VerifyThrowArgumentNull(metadataValue, nameof(metadataValue));
 
             item.SetMetadata(metadataName, EscapingUtilities.Escape(metadataValue));
         }
@@ -159,7 +157,7 @@ public void SetMetadata(string metadataName, string metadataValue)
         /// <param name="metadataName"></param>
         public void RemoveMetadata(string metadataName)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(metadataName, "metadataName");
+            ErrorUtilities.VerifyThrowArgumentNull(metadataName, nameof(metadataName));
 
             item.RemoveMetadata(metadataName);
         }
@@ -175,7 +173,7 @@ public void CopyMetadataTo
             ITaskItem destinationItem
         )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(destinationItem, "destinationItem");
+            ErrorUtilities.VerifyThrowArgumentNull(destinationItem, nameof(destinationItem));
 
             // Intentionally not _computed_ properties. These are slow and don't really
             // apply anyway.
@@ -185,7 +183,7 @@ ITaskItem destinationItem
 
                 string destinationValue = destinationItem.GetMetadata(key);
 
-                if ((destinationValue == null) || (destinationValue.Length == 0))
+                if (string.IsNullOrEmpty(destinationValue))
                 {
                     destinationItem.SetMetadata(key, EscapingUtilities.UnescapeAll((string)entry.Value));
                 }
@@ -195,13 +193,12 @@ ITaskItem destinationItem
             // between items, and need to know the source item where the metadata came from
             string originalItemSpec = destinationItem.GetMetadata("OriginalItemSpec");
 
-            if ((originalItemSpec == null) || (originalItemSpec.Length == 0))
+            if (string.IsNullOrEmpty(originalItemSpec))
             {
                 destinationItem.SetMetadata("OriginalItemSpec", ItemSpec);
             }
         }
 
-
         /// <summary>
         /// Get the collection of metadata. This does not include built-in metadata.
         /// </summary>
diff --git a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
index e41665da673..cc741b9b68b 100644
--- a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
+++ b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
@@ -120,7 +120,7 @@ internal static bool ContainsMetadataExpressionOutsideTransform(string expressio
 
             GetReferencedItemNamesAndMetadata(expression, 0, expression.Length, ref pair, ShredderOptions.MetadataOutsideTransforms);
 
-            bool result = (pair.Metadata != null && pair.Metadata.Count > 0);
+            bool result = (pair.Metadata?.Count > 0);
 
             return result;
         }
@@ -372,7 +372,7 @@ private static bool Sink(string expression, ref int i, int end, char c1, char c2
         {
             if (i < end - 1 && expression[i] == c1 && expression[i + 1] == c2)
             {
-                i = i + 2;
+                i += 2;
                 return true;
             }
 
diff --git a/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs b/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
index 30fb00eb92b..459aedf5f15 100644
--- a/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
+++ b/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
@@ -61,7 +61,6 @@ namespace Microsoft.Build.BuildEngine
     /// </remarks>
     internal class Lookup
     {
-
         #region Fields
 
         /// <summary>
@@ -884,10 +883,7 @@ private void ImportItemsIntoTable(Hashtable table, string name, BuildItemGroup g
         private void RemoveItemsFromTableWithBackup(Hashtable table, string name, BuildItemGroup group)
         {
             BuildItemGroup existing = (BuildItemGroup)table[name];
-            if (existing != null)
-            {
-                existing.RemoveItemsWithBackup(group);
-            }
+            existing?.RemoveItemsWithBackup(group);
         }
 
         /// <summary>
@@ -897,10 +893,7 @@ private void RemoveItemsFromTableWithBackup(Hashtable table, string name, BuildI
         private void ApplyModificationsToTable(Hashtable table, string name, Dictionary<BuildItem, Dictionary<string, string>> modify)
         {
             BuildItemGroup existing = (BuildItemGroup)table[name];
-            if (existing != null)
-            {
-                existing.ModifyItemsUsingVirtualMetadata(modify);
-            }
+            existing?.ModifyItemsUsingVirtualMetadata(modify);
         }
 
         /// <summary>
@@ -1018,7 +1011,7 @@ private void MustNotBeInTable(Hashtable table, BuildItem item)
         /// </summary>
         private void MustNotBeInTable(Dictionary<string, Dictionary<BuildItem, Dictionary<string, string>>> table, BuildItem item)
         {
-            if (table != null && table.ContainsKey(item.Name))
+            if (table?.ContainsKey(item.Name) == true)
             {
                 Dictionary<BuildItem, Dictionary<string, string>> tableOfItemsOfSameType = table[item.Name];
                 if (tableOfItemsOfSameType != null)
@@ -1034,7 +1027,7 @@ private void MustNotBeInTable(Dictionary<string, Dictionary<BuildItem, Dictionar
         /// </summary>
         private void MustNotBeInTable(Hashtable table, string name, BuildItemGroup group)
         {
-            if (table != null && table.ContainsKey(name))
+            if (table?.ContainsKey(name) == true)
             {
                 BuildItemGroup existing = (BuildItemGroup)table[name];
                 if (existing != null)
diff --git a/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs b/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs
index 0a1d5607bcc..cc36bd059f0 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs
@@ -475,7 +475,7 @@ internal void CreateFromStream(BinaryReader reader, Hashtable loggingTypeCache)
 
             for (int i = 0; i < numberOfNodeEvents; i++)
             {
-                NodeLoggingEvent e = null;
+                NodeLoggingEvent e;
                 if (reader.ReadByte() == 0)
                 {
                     e = new NodeLoggingEvent();
@@ -954,7 +954,6 @@ internal class LocalCallDescriptorForRequestStatus : LocalCallDescriptor
         #region Constructors
         internal LocalCallDescriptorForRequestStatus()
         {
-
         }
 
         internal LocalCallDescriptorForRequestStatus(int requestId)
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNode.cs b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
index 4b071b8da18..90708fdef36 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNode.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
@@ -28,7 +28,7 @@ public class LocalNode
         static LocalNode()
         {
             AppDomain currentDomain = AppDomain.CurrentDomain;
-            currentDomain.UnhandledException += new UnhandledExceptionEventHandler(UnhandledExceptionHandler);
+            currentDomain.UnhandledException += UnhandledExceptionHandler;
         }
         #endregion
 
@@ -131,13 +131,11 @@ void StartCommunicationThreads()
             ErrorUtilities.VerifyThrow(this.sharedMemory.IsUsable,
                 "Failed to create shared memory for local node input.");
 
-
             // Start the thread that will be processing the calls from the parent engine
             ThreadStart threadState = new ThreadStart(this.SharedMemoryReaderThread);
             readerThread = new Thread(threadState);
             readerThread.Name = "MSBuild Child<-Parent Reader";
             readerThread.Start();
-            
         }
 
         /// <summary>
@@ -153,15 +151,9 @@ void StopCommunicationThreads()
             // to start up its communication threads. This can happen if the node is started with /nodemode:x
             // and no parent is running, or if the parent node has spawned a new process and then crashed 
             // before establishing communication with the child node.
-            if(writerThread != null)
-            {
-              writerThread.Join();
-            }
+            writerThread?.Join();
 
-            if (readerThread != null)
-            {
-                readerThread.Join();
-            }
+            readerThread?.Join();
 
             // Make sure the exit event is not set
             communicationThreadExitEvent.Reset();
@@ -178,7 +170,7 @@ void StopCommunicationThreads()
         /// <returns>True if events created successfully and false otherwise</returns>
         private static bool CreateGlobalEvents(int nodeNumber)
         {
-            bool createdNew = false;
+            bool createdNew;
             if (NativeMethods.IsUserAdministrator())
             {
                 EventWaitHandleSecurity mSec = new EventWaitHandleSecurity();
@@ -209,7 +201,7 @@ private static bool CreateGlobalEvents(int nodeNumber)
 
             // Indicate to the parent process, this node is currently is ready to start to recieve requests
             globalNodeInUse = new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeInUseEventName(nodeNumber));
-            
+
             // Used by the parent process to inform the child process to shutdown due to the child process
             // not recieving the initialization command.
             globalNodeErrorShutdown = new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeErrorShutdownEventName(nodeNumber));
@@ -280,13 +272,13 @@ public static void StartLocalNodeServer(int nodeNumber)
                     waitHandlesActive[2] = notInUseEvent;
 
                     eventType = WaitHandle.WaitTimeout;
-                    while (eventType == WaitHandle.WaitTimeout && continueRunning == true)
+                    while (eventType == WaitHandle.WaitTimeout && continueRunning)
                     {
                         eventType = WaitHandle.WaitAny(waitHandlesActive, parentCheckInterval, false);
 
                         if (eventType == 0 || /* nice shutdown due to shutdownEvent */
                             eventType == 1 || /* error shutdown due to globalNodeErrorShutdown */
-                            eventType == WaitHandle.WaitTimeout && !localNode.IsParentProcessAlive())
+                            (eventType == WaitHandle.WaitTimeout && !localNode.IsParentProcessAlive()))
                         {
                             continueRunning = false;
                             // If the exit is not triggered by running of shutdown method
@@ -338,7 +330,7 @@ public static void StartLocalNodeServer(int nodeNumber)
         #region Methods
 
         /// <summary>
-        /// This method is run in its own thread, it is responsible for reading messages sent from the parent process 
+        /// This method is run in its own thread, it is responsible for reading messages sent from the parent process
         /// through the shared memory region.
         /// </summary>
         private void SharedMemoryReaderThread()
@@ -450,7 +442,7 @@ internal void ShutdownNode(Node.NodeShutdownLevel shutdownLevel, bool exitProces
                 // accomplished by calling this method again with the ErrorShutdown handle
                 if ( shutdownLevel == Node.NodeShutdownLevel.BuildCompleteSuccess || shutdownLevel == Node.NodeShutdownLevel.BuildCompleteFailure )
                 {
-                    ShutdownNode(Node.NodeShutdownLevel.ErrorShutdown, false, true); 
+                    ShutdownNode(Node.NodeShutdownLevel.ErrorShutdown, false, true);
                 }
                 // Signal all the communication threads to exit
                 shutdownEvent.Set();
@@ -495,7 +487,6 @@ string parentStartupDirectory
             // Host the msbuild engine and system
             node = new Node(nodeId, nodeLoggers, engineCallback, parentGlobalProperties, toolsetSearchLocations, parentStartupDirectory);
 
-
             // Write the initialization complete event out directly
             LocalCallDescriptorForInitializationComplete callDescriptor =
                 new LocalCallDescriptorForInitializationComplete(Process.GetCurrentProcess().Id);
@@ -548,10 +539,7 @@ internal void ReportFatalCommunicationError(Exception originalException)
             }
             finally
             {
-                if (node != null)
-                {
-                    node.ReportFatalCommunicationError(originalException, null);
-                }
+                node?.ReportFatalCommunicationError(originalException, null);
             }
         }
 
@@ -562,7 +550,6 @@ internal void ReportFatalCommunicationError(Exception originalException)
         /// <param name="originalException"></param>
         internal void ReportNonFatalCommunicationError(Exception originalException)
         {
-             
             if (node != null)
             {
                 try
@@ -624,9 +611,9 @@ internal static string DumpFileName
         private static ManualResetEvent communicationThreadExitEvent = new ManualResetEvent(false);
         private static ManualResetEvent shutdownEvent = new ManualResetEvent(false);
         private static ManualResetEvent notInUseEvent = new ManualResetEvent(false);
-        
+
         /// <summary>
-        /// Indicates the node is now in use. This means the node has recieved an activate command with initialization 
+        /// Indicates the node is now in use. This means the node has recieved an activate command with initialization
         /// data from the parent procss
         /// </summary>
         private static ManualResetEvent inUseEvent    = new ManualResetEvent(false);
@@ -640,7 +627,7 @@ internal static string DumpFileName
         // Timeouts && Constants
         private const int inactivityTimeout   = 60 * 1000; // 60 seconds of inactivity to exit
         private const int parentCheckInterval = 5 * 1000; // Check if the parent process is there every 5 seconds
-	
+
         #endregion
 
     }
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeCallback.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeCallback.cs
index 2137adc272a..3c0d967fd5d 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeCallback.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeCallback.cs
@@ -122,7 +122,7 @@ internal void PostReplyFromParent(LocalReplyCallDescriptor reply)
             lock (repliesFromParent)
             {
                 ReplyData replyData = (ReplyData) repliesFromParent[requestingCallNumber];
-                ErrorUtilities.VerifyThrow(replyData != null && replyData.waitEvent != null, 
+                ErrorUtilities.VerifyThrow(replyData?.waitEvent != null, 
                     "We must have an event for this call at this point");
 
                 replyData.reply = reply;
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeInfo.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeInfo.cs
index ba2972020e4..0e0a7d25ae6 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeInfo.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeInfo.cs
@@ -213,7 +213,7 @@ private void ReserveNextAvailableNodeNumber(int currentNodeNumber)
         {
             while (nodeReserveHandle == null)
             {
-                bool createdNew = false;
+                bool createdNew;
                 nodeReserveHandle = 
                     new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeReserveEventName(currentNodeNumber), out createdNew);
                 if (!createdNew)
@@ -232,7 +232,6 @@ private void ReserveNextAvailableNodeNumber(int currentNodeNumber)
                         nodeReserveHandle = null;
                         currentNodeNumber++;
                     }
-
                 }
             }
         }
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
index ef43c638ee9..ceacf26f9f6 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
@@ -41,12 +41,10 @@ string startupDirectory
             if (configuration != null)
             {
                 // Split out the parameter sets based on ;
-                string[] parameters;
-                parameters = configuration.Split(parameterDelimiters);
+                string[] parameters = configuration.Split(parameterDelimiters);
                 // Go through each of the parameter name value pairs and split them appart
                 for (int param = 0; param < parameters.Length; param++)
                 {
-
                     if (parameters[param].Length > 0)
                     {
                         string[] parameterComponents = parameters[param].Split(valueDelimiters);
@@ -57,7 +55,7 @@ string startupDirectory
                         }
                         else // Only the parameter name is known, this could be for a boolean parameter
                         {
-                            ApplyParameter(parameters[param], null); 
+                            ApplyParameter(parameters[param], null);
                         }
                     }
                 }
@@ -123,14 +121,13 @@ string startupDirectory
         /// </summary>
         public void ApplyParameter(string parameterName, string parameterValue)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parameterName, "parameterName");
+            ErrorUtilities.VerifyThrowArgumentNull(parameterName, nameof(parameterName));
 
-            if (0 == String.Compare(parameterName, "MAXCPUCOUNT", StringComparison.OrdinalIgnoreCase))
+            if (String.Equals(parameterName, "MAXCPUCOUNT", StringComparison.OrdinalIgnoreCase))
             {
                  try
                 {
                     this.cpuCount = Convert.ToInt32(parameterValue, CultureInfo.InvariantCulture);
-
                 }
                 catch (FormatException)
                 {
@@ -141,11 +138,11 @@ public void ApplyParameter(string parameterName, string parameterValue)
                     //
                 }
             }
-            else if (0 == String.Compare(parameterName, "MSBUILDLOCATION", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "MSBUILDLOCATION", StringComparison.OrdinalIgnoreCase))
             {
                 this.locationOfMSBuildExe = parameterValue;
             }
-            else if (0 == String.Compare(parameterName, "NODEREUSE", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "NODEREUSE", StringComparison.OrdinalIgnoreCase))
             {
                 try
                 {
@@ -170,7 +167,6 @@ public void ApplyParameter(string parameterName, string parameterValue)
             }
         }
 
-
         public INodeDescription[] QueryNodeDescriptions()
         {
             return new INodeDescription[cpuCount-1];
@@ -211,7 +207,7 @@ public void RequestNodeStatus(int nodeIndex, int requestId)
             // on its behalf
             if (nodeData[nodeIndex].NodeState != NodeState.Launched)
             {
-                NodeStatus nodeStatus = new NodeStatus(requestId, false, 0, 0, 0, (nodeData[nodeIndex].NodeState == NodeState.LaunchInProgress));
+                NodeStatus nodeStatus = new NodeStatus(requestId, false, 0, 0, 0, nodeData[nodeIndex].NodeState == NodeState.LaunchInProgress);
                 engineCallback.PostStatus(nodeData[nodeIndex].NodeId, nodeStatus, false);
             }
             else if (!IsNodeProcessAliveOrUninitialized(nodeIndex))
@@ -252,7 +248,7 @@ public void PostBuildRequestToNode(int nodeIndex, BuildRequest buildRequest)
                             }
                             ThreadStart threadState = new ThreadStart(this.LaunchNodeAndPostBuildRequest);
                             Thread taskThread = new Thread(threadState);
-                            taskThread.Name = "MSBuild Node Launcher";                            
+                            taskThread.Name = "MSBuild Node Launcher";
                             taskThread.Start();
                         }
                         nodeData[nodeIndex].TargetList.AddFirst(new LinkedListNode<BuildRequest>(buildRequest));
@@ -296,10 +292,10 @@ public void ShutdownNodes(Node.NodeShutdownLevel nodeShutdownLevel)
             SendShutdownRequests(nodeShutdownLevel);
 
             DateTime startTime = DateTime.Now;
-            
+
             // Wait for all nodes to shutdown
             bool timeoutExpired = false;
-            
+
             // Loop until we are ready to shutdown. We are ready to shutdown when
             // all nodes either have sent their shutdown completed response or they are dead.
             // Secondly, we will exit the loop if our shudtownTimeout has expired
@@ -319,7 +315,7 @@ public void ShutdownNodes(Node.NodeShutdownLevel nodeShutdownLevel)
                 {
                     //Terminate all of the nodes which have valid processId's but for which we
                     // have not recieved a shutdown response
-                    if ((nodeInfo.ProcessId > 0 && !nodeInfo.ShutdownResponseReceived))
+                    if (nodeInfo.ProcessId > 0 && !nodeInfo.ShutdownResponseReceived)
                     {
                         TerminateChildNode(nodeInfo.ProcessId);
                     }
@@ -367,7 +363,7 @@ internal bool ReadyToShutdown()
         /// </summary>
         public void UpdateSettings
         (
-            bool enableCentralizedLogging, 
+            bool enableCentralizedLogging,
             bool enableOnlyLogCriticalEvents,
             bool useBreadthFirstTraversalSetting
         )
@@ -383,7 +379,6 @@ bool useBreadthFirstTraversalSetting
                     UpdateSettings(i);
                 }
             }
-
         }
 
         private void UpdateSettings(int nodeIndex)
@@ -394,7 +389,6 @@ private void UpdateSettings(int nodeIndex)
             nodeData[nodeIndex].NodeCommandQueue.Enqueue(callDescriptor);
         }
 
-
         public void PostIntrospectorCommand(int nodeIndex, TargetInProgessState child, TargetInProgessState parent)
         {
             // Send the updated settings once the node has initialized
@@ -457,7 +451,6 @@ private void TerminateChildNode(int processId)
         {
             try
             {
-
                 if (!Process.GetProcessById(processId).HasExited)
                 {
                     Process.GetProcessById(processId).Kill();
@@ -480,15 +473,13 @@ private void TerminateChildNode(int processId)
         private bool IsNodeProcessAliveOrUninitialized(int nodeId)
         {
             // If it's alive but not being communicated with anymore, that counts as not alive
-            if (nodeData[nodeId].CommunicationFailed == true)
+            if (nodeData[nodeId].CommunicationFailed)
             {
                 return false;
             }
-            
+
             try
             {
- 
-
                 bool isUninitialized = nodeData[nodeId].ProcessId == LocalNodeInfo.unInitializedProcessId;
 
                 if (isUninitialized)
@@ -502,7 +493,6 @@ private bool IsNodeProcessAliveOrUninitialized(int nodeId)
                 {
                     return true;
                 }
-
            }
             catch (ArgumentException)
             {
@@ -727,7 +717,7 @@ private void InitializeNode(int nodeIndex)
             finally
             {
                 // Make sure to decrement the active node count if the communication has failed
-                if (nodeConnected != true)
+                if (!nodeConnected)
                 {
                     DecreaseActiveNodeCount(nodeData[nodeIndex].NodeId);
                     nodeData[nodeIndex].CommunicationFailed = true;
@@ -737,7 +727,7 @@ private void InitializeNode(int nodeIndex)
 
         /// <summary>
         /// This function attempts to find out if there is currently a node running
-        /// for a given index. The node is running if the global mutex with a 
+        /// for a given index. The node is running if the global mutex with a
         /// "Node_" + nodeId + "_ActiveReady" as a name was created
         /// </summary>
         private static  bool checkIfNodeActive(int nodeNumber)
@@ -755,10 +745,7 @@ private static  bool checkIfNodeActive(int nodeNumber)
             }
             finally
             {
-                if (nodeActiveHandle != null)
-                {
-                    nodeActiveHandle.Close();
-                }
+                nodeActiveHandle?.Close();
             }
 
             return nodeIsActive;
@@ -786,7 +773,7 @@ private void LaunchNode(int nodeIndex)
                     startInfo.hStdInput = NativeMethods.InvalidHandle;
                     startInfo.hStdOutput = NativeMethods.InvalidHandle;
                     startInfo.dwFlags = NativeMethods.STARTF_USESTDHANDLES;
-                    dwCreationFlags = dwCreationFlags | NativeMethods.CREATE_NO_WINDOW;
+                    dwCreationFlags |= NativeMethods.CREATE_NO_WINDOW;
                 }
 
                 NativeMethods.SECURITY_ATTRIBUTES pSec = new NativeMethods.SECURITY_ATTRIBUTES();
@@ -812,15 +799,11 @@ private void LaunchNode(int nodeIndex)
                 {
                     exitedDueToError = false;
                 }
-
             }
             finally
             {
                 // Dispose before losing scope
-                if (nodeReadyEvent != null)
-                {
-                    nodeReadyEvent.Close();
-                }
+                nodeReadyEvent?.Close();
 
                 if (exitedDueToError)
                 {
@@ -835,7 +818,7 @@ private void LaunchNode(int nodeIndex)
         private void ReportNodeCommunicationFailure
         (
             int nodeIndex,
-            Exception innerException, 
+            Exception innerException,
             bool decreaseActiveNodeCount
         )
         {
@@ -860,7 +843,7 @@ bool decreaseActiveNodeCount
                 // We can't really do anything except re-throw so this problem can be diagnosed.
                 throw wrappedException;
             }
-            
+
             engineCallback.PostStatus(nodeData[nodeIndex].NodeId, nodeStatus, false);
         }
 
@@ -1003,7 +986,6 @@ private void SharedMemoryReaderThread()
         private int activeNodeCount;
         private int responseCount;
 
-
         private int cpuCount;
 
         private object nodeStateLock;
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeProviderGlobalNames.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeProviderGlobalNames.cs
index aed8912e2b5..bf2622777aa 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeProviderGlobalNames.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeProviderGlobalNames.cs
@@ -150,12 +150,9 @@ static internal string NodeOutputMemoryName(int nodeNumber)
         /// </summary>
         static private void InitializeGlobalNamePostFixValues()
         {
-            string engineVersion = null;
-            string accountTypePostfix = null;
-            string usernamePostFix = null;
             AssemblyName name = new AssemblyName(Assembly.GetExecutingAssembly().FullName);
-            engineVersion = name.Version.ToString();
-
+            string engineVersion = name.Version.ToString();
+            string accountTypePostfix;
             if (NativeMethods.IsUserAdministrator())
             {
                 accountTypePostfix = "Admin";
@@ -165,7 +162,7 @@ static private void InitializeGlobalNamePostFixValues()
                 accountTypePostfix = "NotAdmin";
             }
             // As per the msdn docs for WindowsIdentity.Name Property The logon name is in the form DOMAIN\USERNAME. so replace the \ so it is not confused as a path
-            usernamePostFix = System.Security.Principal.WindowsIdentity.GetCurrent().Name.Replace("\\", "_");
+            string usernamePostFix = System.Security.Principal.WindowsIdentity.GetCurrent().Name.Replace("\\", "_");
 
             nodePostfix = engineVersion + accountTypePostfix + usernamePostFix;
         }
diff --git a/src/Deprecated/Engine/LocalProvider/NativeMethods.cs b/src/Deprecated/Engine/LocalProvider/NativeMethods.cs
index 79783bfc6f2..d2be3516f56 100644
--- a/src/Deprecated/Engine/LocalProvider/NativeMethods.cs
+++ b/src/Deprecated/Engine/LocalProvider/NativeMethods.cs
@@ -67,15 +67,12 @@ internal static bool IsUserAdministrator()
         {
             int SECURITY_BUILTIN_DOMAIN_RID = 0x00000020;
             int DOMAIN_ALIAS_RID_ADMINS  = 0x00000220;
-            bool bRet = false;
-
-            IntPtr psidRidGroup = NullPtr;
             IntPtr pNtAuthority = Marshal.AllocHGlobal(6);
             Marshal.WriteInt32(pNtAuthority, 0, 0);
             Marshal.WriteByte(pNtAuthority, 4, 0);
             Marshal.WriteByte(pNtAuthority, 5, 5);
-
-            bRet = AllocateAndInitializeSid(pNtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, out psidRidGroup);
+            IntPtr psidRidGroup;
+            bool bRet = AllocateAndInitializeSid(pNtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, out psidRidGroup);
             try
             {
                 if (bRet)
@@ -92,7 +89,6 @@ internal static bool IsUserAdministrator()
             }
 
             return bRet;
-            
         }
 
         [DllImport("advapi32.dll", SetLastError = true)]
diff --git a/src/Deprecated/Engine/LocalProvider/SharedMemory.cs b/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
index a5df97442c7..837c7e63920 100644
--- a/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
+++ b/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
@@ -25,7 +25,7 @@ internal enum SharedMemoryType
     }
 
     /// <summary>
-    /// The shared memory is used to transmit serialized LocalCallDescriptors. 
+    /// The shared memory is used to transmit serialized LocalCallDescriptors.
     /// These local call descriptors encapsulate commands and data that needs
     /// to be communicated between the parent and child objects. This enumeration
     /// is used by the shared memory to mark what kind of LocalCallDescriptor
@@ -36,7 +36,7 @@ internal enum SharedMemoryType
     internal enum ObjectType
     {
         // Has the object been serialized using .net serialization (binary formatter)
-        NetSerialization = 1, 
+        NetSerialization = 1,
         // Used to mark that the next int read represents how many bytes are in the
         // large object which is about to be sent      
         FrameMarker = 2,
@@ -61,10 +61,10 @@ internal enum ObjectType
     }
 
     /// <summary>
-    /// This class is responsible for providing a communication channel between 
+    /// This class is responsible for providing a communication channel between
     /// a child process and a parent process. Each process (child or parent) will
     /// have two SharedMemory class instances, one for reading and one for writing.
-    /// For example, a parent will have one shared memory class to "read" data 
+    /// For example, a parent will have one shared memory class to "read" data
     /// sent from the child and one "write" shared The shared memory communicates
     /// through named shared memory regions.
     /// </summary>
@@ -81,7 +81,7 @@ private SharedMemory()
         /// </summary>
         /// <param name="name">
         /// The name the shared memory will be given, this is combination of node,
-        /// username, admin status, and some other ones, 
+        /// username, admin status, and some other ones,
         /// see LocalNodeProviderGlobalNames.NodeInputMemoryName for greater detail.
         /// </param>
         /// <param name="type">
@@ -89,19 +89,19 @@ private SharedMemory()
         ///  within the shared memory class. For example,
         ///  read only means, only create a memory stream,
         ///  a read lock and a backing byte array and a binary reader. A write
-        ///  only type means,  create a memory stream, write lock and a binary writer. 
+        ///  only type means,  create a memory stream, write lock and a binary writer.
         ///  This type however does not set the type of the memory mapped section,
         ///  the memory mapped section itself is created
         ///  with READWRITE access.
         ///</param>
         /// <param name="allowExistingMapping">
-        ///  The shared memory is given a parameter to determine whether or not to 
-        ///  reuse an existing mapped memory secion. When the node is first created 
+        ///  The shared memory is given a parameter to determine whether or not to
+        ///  reuse an existing mapped memory secion. When the node is first created
         ///  this is false, however when the shared memory threads are created this
-        ///  is true. We do this because we create the shared memory when the node 
+        ///  is true. We do this because we create the shared memory when the node
         ///  is created, at this point the there should be no shared memory with the
-        ///  same name. However when we create the reader and writer threads 
-        ///  (which happens on node reuse) we want to reuse the memory. 
+        ///  same name. However when we create the reader and writer threads
+        ///  (which happens on node reuse) we want to reuse the memory.
         ///</param>
         internal SharedMemory(string name, SharedMemoryType type, bool allowExistingMapping)
         {
@@ -224,7 +224,7 @@ private void InitializeMemoryMapping(string memoryMapName, bool allowExistingMap
                         0,  // Start mapped view at low order offset 0
                          // The size of the shared memory plus some extra space for an int
                          // to write the number of bytes written
-                        (IntPtr)(size + 4)  
+                        (IntPtr)(size + 4)
                     );
 
                 // Check to see if the file view has been created on the fileMapping.
@@ -255,7 +255,6 @@ private void InitializeStreams(SharedMemoryType streamType)
                 this.readStream = new MemoryStream(this.readBuffer);
                 this.binaryReader = new BinaryReader(this.readStream);
                 readLock = new object();
-
             }
             else if (streamType == SharedMemoryType.WriteOnly)
             {
@@ -267,7 +266,6 @@ private void InitializeStreams(SharedMemoryType streamType)
             {
                 ErrorUtilities.VerifyThrow(false, "Unknown shared memory type.");
             }
-
         }
 
         /// <summary>
@@ -328,13 +326,11 @@ protected virtual void Dispose(bool disposing)
             }
         }
 
-
         public void Dispose()
         {
             Dispose(true);
         }
 
-
         ~SharedMemory()
         {
             Dispose();
@@ -360,7 +356,7 @@ internal bool IsUsable
         /// Returns the readActionCounter as a WaitHandle. This WaitHandle is used
         /// to notify the SharedMemory reader threads that there is something ready
         /// in the shared memory to be read. The ReadFlag will remain set as long as
-        /// the number of times the shared memory has been read is less than the 
+        /// the number of times the shared memory has been read is less than the
         /// number of times writer thread has written to the shared memory.
         /// </summary>
         internal WaitHandle ReadFlag
@@ -441,7 +437,7 @@ private void IncrementUnreadBatchCounter()
         }
 
         /// <summary>
-        /// A batch has just been read out of shared memory. 
+        /// A batch has just been read out of shared memory.
         /// </summary>
         private void DecrementUnreadBatchCounter()
         {
@@ -450,13 +446,13 @@ private void DecrementUnreadBatchCounter()
         }
 
         /// <summary>
-        /// This function write out a set of objects into the the shared buffer.
+        /// This function write out a set of objects into the shared buffer.
         /// In normal operation all the objects in the queue are serialized into
         /// the buffer followed by an end marker class. If the buffer is not big
-        /// enough to contain a single object the object is broken into into 
+        /// enough to contain a single object the object is broken into
         /// multiple buffers as follows - first a frame marker is sent containing
         /// the size of the serialized object + size of end marker. The reader makes
-        /// sure upon receiving the frame marker that its buffer is large enough 
+        /// sure upon receiving the frame marker that its buffer is large enough
         /// to contain the object about to be sent. After the frame marker the object
         /// is sent as a series of buffers until all of it is written out.
         /// </summary>
@@ -557,7 +553,7 @@ internal void Write(DualQueue<LocalCallDescriptor> objectsToWrite, DualQueue<Loc
                             (int)writeLength // Length of bytes to write
                         );
 
-                        writeBytesRemaining = writeBytesRemaining - writeLength;
+                        writeBytesRemaining -= writeLength;
                         IncrementUnreadBatchCounter();
 
                         // Once the object is fully sent - remove it from the queue
@@ -692,9 +688,9 @@ private void SerializeCallDescriptorToStream(DualQueue<LocalCallDescriptor> obje
         /// <summary>
         /// This function reads data from the shared memory buffer and returns a list
         /// of deserialized LocalCallDescriptors or null. The method will return null
-        /// if the object being sent accross is a multi buffer object. Read needs to 
+        /// if the object being sent accross is a multi buffer object. Read needs to
         /// be called multiple times until the entire large object has been recived.
-        /// Once this has happened the large object is deserialized and returned in 
+        /// Once this has happened the large object is deserialized and returned in
         /// the Ilist. Read is used by the shared memory reader threads in the LocalNode
         /// (child end) and the LocalNodeProvider(ParentEnd) to read LocalCallDescriptors
         /// from the shared memory. Read is called from loops in the SharedMemoryReaderThread
@@ -703,8 +699,6 @@ internal IList Read()
         {
             ErrorUtilities.VerifyThrow(type == SharedMemoryType.ReadOnly, "Should only be calling Read from a readonly shared memory object");
             ArrayList objectsRead = null;
-            int objectId = -1;
-
             lock (readLock)
             {
                 if (NumberOfUnreadBatches > 0)
@@ -739,6 +733,7 @@ internal IList Read()
                     {
                         objectsRead = new ArrayList();
 
+                        int objectId;
                         // Deserialize the object in the read stream to a LocalCallDescriptor. The objectId
                         // is the "ObjectType" which was written to the head of the object when written to the memory stream.
                         // It describes which kind of object was serialized
@@ -802,12 +797,12 @@ internal IList Read()
         }
 
         /// <summary>
-        /// This method first reads the objectId as an int from the stream, 
-        /// this int should be found in the "ObjectType" enumeration. This 
-        /// objectId informs the method what kind of object should be 
+        /// This method first reads the objectId as an int from the stream,
+        /// this int should be found in the "ObjectType" enumeration. This
+        /// objectId informs the method what kind of object should be
         /// deserialized and returned from the method. The objectId is an
-        /// output parameter. This parameter is also returned so it can be 
-        /// used in the read and write methods to determine if 
+        /// output parameter. This parameter is also returned so it can be
+        /// used in the read and write methods to determine if
         /// a frame or end marker was found.
         /// </summary>
         private object DeserializeFromStream(out int objectId)
@@ -915,12 +910,12 @@ internal void Reset()
         private IntPtr pageFileView;
 
         private BinaryFormatter binaryFormatter;
-        
+
         // Binary reader and writer used to read and write from the memory streams used to contain the deserialized LocalCallDescriptors before and after they are copied 
         // to and from the shared memory region.
         private BinaryWriter binaryWriter;
         private BinaryReader binaryReader;
-        
+
         /// <summary>
         /// Memory stream to contain the deserialized objects before they are sent accross the shared memory region
         /// </summary>
@@ -929,7 +924,7 @@ internal void Reset()
         // Backing byte array of the readStream
         private byte[] readBuffer;
         private MemoryStream readStream;
-        
+
         // The count on a semaphore is decremented each time a thread enters the semaphore,
         // and incremented when a thread releases the semaphore. 
         // When the count is zero, subsequent requests block until other threads release the semaphore. 
@@ -937,7 +932,7 @@ internal void Reset()
 
         // unreadBatchCounter is used to track how many batches are remaining to be read from shared memory.
         private Semaphore unreadBatchCounter;
- 
+
         //Used to inform the shared memory reader threads the writer thread has written something in shared memory to read.
 	//The semaphore is incremented when the shared memory is full and when there is an unreadBatch availiable to be read or the shared memory is full.
 	//The semaphore is decremented when the shared memory reader thread is about to read from the shared memory.
@@ -946,7 +941,7 @@ internal void Reset()
         // Whether or not the shared memory is full
         private EventWaitHandle fullFlag;
         private EventWaitHandle notFullFlag;
-        
+
         private object writeLock;
         private object readLock;
 
@@ -959,7 +954,7 @@ internal void Reset()
 
         // Have we disposed this object yet;
         private bool disposed;
-        
+
         // Is the memory read only or write only
         private SharedMemoryType type;
 
@@ -967,7 +962,7 @@ internal void Reset()
         // we were spending a lot of time reflecting for these methods. The loggingTypeCache, caches the methodInfo for the classes and then look them
         // up when serializing or deserializing the objects. 
         private Hashtable loggingTypeCache;
-        
+
         // Keep a pointer to the queue which contains the large object which is being deserialized. We do this because we want to make sure 
         // after the object is properly sent we dequeue off the correct queue.
         private DualQueue<LocalCallDescriptor> largeObjectsQueue;
diff --git a/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs b/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
index eb841f4102b..f7fe92fa404 100644
--- a/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
@@ -113,9 +113,7 @@ public void ParseParameters()
         {
             if (loggerParameters != null)
             {
-                string[] parameterComponents;
-
-                parameterComponents = loggerParameters.Split(parameterDelimiters);
+                string[] parameterComponents = loggerParameters.Split(parameterDelimiters);
                 for (int param = 0; param < parameterComponents.Length; param++)
                 {
                     if (parameterComponents[param].Length > 0)
@@ -175,7 +173,7 @@ public int Compare(Object a, Object b)
         internal string IndentString(string s, int indent)
         {
             // It's possible the event has a null message
-            if (null == s)
+            if (s == null)
             {
                 s = String.Empty;
             }
@@ -347,7 +345,7 @@ internal void IsRunningWithCharacterFileType()
         /// </summary>
         internal bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity)
         {
-            return (this.verbosity >= checkVerbosity);
+            return this.verbosity >= checkVerbosity;
         }
 
         /// <summary>
@@ -566,7 +564,6 @@ internal SortedList ExtractItemList(IEnumerable items)
             return itemTypes;
         }
 
-
         internal virtual void OutputItems(string itemType, ArrayList itemTypeList)
         {
             // Write each item, one per line
@@ -590,7 +587,6 @@ internal virtual void OutputItems(string itemType, ArrayList itemTypeList)
             resetColor();
         }
 
-
         /// <summary>
         /// Returns a performance counter for a given scope (either task name or target name)
         /// from the given table.
@@ -719,7 +715,6 @@ internal  bool InScope
                             inScope = false;
 
                             elapsedTime += (System.DateTime.Now - scopeStartTime);
-
                         }
                         else if (!InScope && value)
                         {
@@ -868,31 +863,31 @@ public virtual void Initialize(IEventSource eventSource)
             if (eventSource != null)
             {
                 eventSource.BuildStarted +=
-                        new BuildStartedEventHandler(BuildStartedHandler);
+                         BuildStartedHandler;
                 eventSource.BuildFinished +=
-                        new BuildFinishedEventHandler(BuildFinishedHandler);
+                         BuildFinishedHandler;
                 eventSource.ProjectStarted +=
-                        new ProjectStartedEventHandler(ProjectStartedHandler);
+                         ProjectStartedHandler;
                 eventSource.ProjectFinished +=
-                        new ProjectFinishedEventHandler(ProjectFinishedHandler);
+                         ProjectFinishedHandler;
                 eventSource.TargetStarted +=
-                        new TargetStartedEventHandler(TargetStartedHandler);
+                         TargetStartedHandler;
                 eventSource.TargetFinished +=
-                        new TargetFinishedEventHandler(TargetFinishedHandler);
+                         TargetFinishedHandler;
                 eventSource.TaskStarted +=
-                        new TaskStartedEventHandler(TaskStartedHandler);
+                         TaskStartedHandler;
                 eventSource.TaskFinished +=
-                        new TaskFinishedEventHandler(TaskFinishedHandler);
+                         TaskFinishedHandler;
 
                 eventSource.ErrorRaised +=
-                        new BuildErrorEventHandler(ErrorHandler);
+                         ErrorHandler;
                 eventSource.WarningRaised +=
-                        new BuildWarningEventHandler(WarningHandler);
+                         WarningHandler;
                 eventSource.MessageRaised +=
-                        new BuildMessageEventHandler(MessageHandler);
+                         MessageHandler;
 
                 eventSource.CustomEventRaised +=
-                        new CustomBuildEventHandler(CustomEventHandler);
+                         CustomEventHandler;
             }
         }
 
@@ -902,7 +897,7 @@ public virtual void Initialize(IEventSource eventSource)
         /// </summary>
         internal virtual bool ApplyParameter(string parameterName, string parameterValue)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parameterName, "parameterName");
+            ErrorUtilities.VerifyThrowArgumentNull(parameterName, nameof(parameterName));
 
             switch (parameterName.ToUpperInvariant())
             {
diff --git a/src/Deprecated/Engine/Logging/ConsoleLogger.cs b/src/Deprecated/Engine/Logging/ConsoleLogger.cs
index 0ac8f1ffcf4..28772e3dbd5 100644
--- a/src/Deprecated/Engine/Logging/ConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ConsoleLogger.cs
@@ -54,7 +54,6 @@ public class ConsoleLogger : INodeLogger
         private bool skipProjectStartedText = false;
         private bool? showSummary;
 
-
         #region Constructors
 
         /// <summary>
@@ -99,7 +98,7 @@ public ConsoleLogger
             ColorResetter colorReset
         )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(write, "write");
+            ErrorUtilities.VerifyThrowArgumentNull(write, nameof(write));
             this.verbosity = verbosity;
             this.write = write;
             this.colorSet = colorSet;
@@ -122,11 +121,11 @@ private void InitializeBaseConsoleLogger()
                     {
                         if (parameterComponents[param].Length > 0)
                         {
-                            if (0 == String.Compare(parameterComponents[param], "ENABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
+                            if (String.Equals(parameterComponents[param], "ENABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
                             {
                                 useMPLogger = true;
                             }
-                            if (0 == String.Compare(parameterComponents[param], "DISABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
+                            if (String.Equals(parameterComponents[param], "DISABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
                             {
                                 useMPLogger = false;
                             }
@@ -255,7 +254,6 @@ public bool ShowSummary
                 else
                 {
                     consoleLogger.ShowSummary = value;
-
                 }
             }
         }
@@ -322,10 +320,7 @@ public virtual void Initialize(IEventSource eventSource, int nodeCount)
         /// </summary>
         public virtual void Shutdown()
         {
-            if (consoleLogger != null)
-            {
-                consoleLogger.Shutdown();
-            }
+            consoleLogger?.Shutdown();
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs b/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
index ce9d5ab068c..a45685bd267 100644
--- a/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
+++ b/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
@@ -9,7 +9,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
@@ -101,9 +100,7 @@ private void ParseParameters()
         {
             if (loggerParameters != null)
             {
-                string[] parameterComponents;
-
-                parameterComponents = loggerParameters.Split(parameterDelimiters);
+                string[] parameterComponents = loggerParameters.Split(parameterDelimiters);
                 for (int param = 0; param < parameterComponents.Length; param++)
                 {
                     if (parameterComponents[param].Length > 0)
@@ -127,7 +124,7 @@ private void ParseParameters()
         /// </summary>
         private void ApplyParameter(string parameterName)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parameterName, "parameterName");
+            ErrorUtilities.VerifyThrowArgumentNull(parameterName, nameof(parameterName));
 
             if (forwardingTable.ContainsKey(parameterName))
             {
@@ -137,15 +134,15 @@ private void ApplyParameter(string parameterName)
 
             // If any of the following parameters are set, we will make sure we forward the events
             // necessary for the central logger to emit the requested information
-            if (0 == String.Compare(parameterName, PerformanceSummaryDescription, StringComparison.OrdinalIgnoreCase))
+            if (String.Equals(parameterName, PerformanceSummaryDescription, StringComparison.OrdinalIgnoreCase))
             {
                 this.showPerfSummary = true;
             }
-            else if (0 == String.Compare(parameterName, NoSummaryDescription, StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, NoSummaryDescription, StringComparison.OrdinalIgnoreCase))
             {
                 this.showSummary = false;
             }
-            else if (0 == String.Compare(parameterName, ShowCommandLineDescription, StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, ShowCommandLineDescription, StringComparison.OrdinalIgnoreCase))
             {
                 showCommandLine = true;
             }
@@ -156,7 +153,7 @@ private void ApplyParameter(string parameterName)
         /// </summary>
         public virtual void Initialize(IEventSource eventSource)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(eventSource, "eventSource");
+            ErrorUtilities.VerifyThrowArgumentNull(eventSource, nameof(eventSource));
 
             ParseParameters();
 
@@ -167,18 +164,18 @@ public virtual void Initialize(IEventSource eventSource)
                 SetForwardingBasedOnVerbosity();
             }
 
-            eventSource.BuildStarted += new BuildStartedEventHandler(BuildStartedHandler);
-            eventSource.BuildFinished += new BuildFinishedEventHandler(BuildFinishedHandler);
-            eventSource.ProjectStarted += new ProjectStartedEventHandler(ProjectStartedHandler);
-            eventSource.ProjectFinished += new ProjectFinishedEventHandler(ProjectFinishedHandler);
-            eventSource.TargetStarted += new TargetStartedEventHandler(TargetStartedHandler);
-            eventSource.TargetFinished += new TargetFinishedEventHandler(TargetFinishedHandler);
-            eventSource.TaskStarted += new TaskStartedEventHandler(TaskStartedHandler);
-            eventSource.TaskFinished += new TaskFinishedEventHandler(TaskFinishedHandler);
-            eventSource.ErrorRaised += new BuildErrorEventHandler(ErrorHandler);
-            eventSource.WarningRaised += new BuildWarningEventHandler(WarningHandler);
-            eventSource.MessageRaised += new BuildMessageEventHandler(MessageHandler);
-            eventSource.CustomEventRaised += new CustomBuildEventHandler(CustomEventHandler);
+            eventSource.BuildStarted += BuildStartedHandler;
+            eventSource.BuildFinished += BuildFinishedHandler;
+            eventSource.ProjectStarted += ProjectStartedHandler;
+            eventSource.ProjectFinished += ProjectFinishedHandler;
+            eventSource.TargetStarted += TargetStartedHandler;
+            eventSource.TargetFinished += TargetFinishedHandler;
+            eventSource.TaskStarted += TaskStartedHandler;
+            eventSource.TaskFinished += TaskFinishedHandler;
+            eventSource.ErrorRaised += ErrorHandler;
+            eventSource.WarningRaised += WarningHandler;
+            eventSource.MessageRaised += MessageHandler;
+            eventSource.CustomEventRaised += CustomEventHandler;
         }
 
         /// <summary>
@@ -191,7 +188,6 @@ public void Initialize(IEventSource eventSource, int nodeCount)
 
         private void SetForwardingBasedOnVerbosity()
         {
-
             forwardingTable[BuildStartedEventDescription] = 0;
             forwardingTable[BuildFinishedEventDescription] = 0;
 
@@ -254,7 +250,6 @@ private void SetForwardingBasedOnVerbosity()
             }
         }
 
-
         /// <summary>
         /// Reset the states of per-build member variables.
         /// Used when a build is finished, but the logger might be needed for the next build.
@@ -453,7 +448,7 @@ protected virtual void ForwardToCentralLogger(BuildEventArgs e)
         /// </summary>
         private bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity)
         {
-            return (this.verbosity >= checkVerbosity);
+            return this.verbosity >= checkVerbosity;
         }
         #endregion
 
diff --git a/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
index 128db0a76cc..ae124ed5473 100644
--- a/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -40,9 +40,7 @@ private void ParseFileLoggerParameters()
         {
             if (this.Parameters != null)
             {
-                string[] parameterComponents;
-
-                parameterComponents = this.Parameters.Split(fileLoggerParameterDelimiters);
+                string[] parameterComponents = this.Parameters.Split(fileLoggerParameterDelimiters);
                 for (int param = 0; param < parameterComponents.Length; param++)
                 {
                     if (parameterComponents[param].Length > 0)
@@ -67,7 +65,7 @@ private void ParseFileLoggerParameters()
         /// </summary>
         private void ApplyFileLoggerParameter(string parameterName, string parameterValue)
         {
-            if (String.Compare("LOGFILE", parameterName, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals("LOGFILE", parameterName, StringComparison.OrdinalIgnoreCase))
             {
                 if(string.IsNullOrEmpty(parameterValue))
                 {
@@ -90,7 +88,7 @@ private void ApplyFileLoggerParameter(string parameterName, string parameterValu
 
         public void Initialize(IEventSource eventSource)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(eventSource, "eventSource");
+            ErrorUtilities.VerifyThrowArgumentNull(eventSource, nameof(eventSource));
             ParseFileLoggerParameters();
             string fileName = logFile;
             try
@@ -112,11 +110,7 @@ public void Initialize(IEventSource eventSource)
             }
             catch (ArgumentException e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
-
-                if(nodeFileLogger != null)
-                {
-                    nodeFileLogger.Shutdown();
-                }
+                nodeFileLogger?.Shutdown();
 
                 string errorCode;
                 string helpKeyword;
@@ -130,10 +124,7 @@ public void Initialize(IEventSource eventSource)
 
         public void Shutdown()
         {
-            if (nodeFileLogger != null)
-            {
-                nodeFileLogger.Shutdown();
-            }
+            nodeFileLogger?.Shutdown();
         }
         #endregion
 
diff --git a/src/Deprecated/Engine/Logging/FileLogger.cs b/src/Deprecated/Engine/Logging/FileLogger.cs
index 80c7e610897..8c00dd56627 100644
--- a/src/Deprecated/Engine/Logging/FileLogger.cs
+++ b/src/Deprecated/Engine/Logging/FileLogger.cs
@@ -45,17 +45,14 @@ public FileLogger() : base(LoggerVerbosity.Normal)
         /// <param name="eventSource">Available events.</param>
         public override void Initialize(IEventSource eventSource)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(eventSource, "eventSource");
-            eventSource.BuildFinished += new BuildFinishedEventHandler(FileLoggerBuildFinished);
+            ErrorUtilities.VerifyThrowArgumentNull(eventSource, nameof(eventSource));
+            eventSource.BuildFinished += FileLoggerBuildFinished;
             InitializeFileLogger(eventSource, 1);
         }
 
         private void FileLoggerBuildFinished(object sender, BuildFinishedEventArgs e)
         {
-            if (fileWriter != null)
-            {
-                fileWriter.Flush();
-            }
+            fileWriter?.Flush();
         }
 
         /// <summary>
@@ -99,10 +96,7 @@ private void InitializeFileLogger(IEventSource eventSource, int nodeCount)
                 string errorCode;
                 string helpKeyword;
                 string message = ResourceUtilities.FormatResourceString(out errorCode, out helpKeyword, "InvalidFileLoggerFile", logFileName, e.Message);
-                if (fileWriter != null)
-                {
-                    fileWriter.Close();
-                }
+                fileWriter?.Close();
                 throw new LoggerException(message,e.InnerException,errorCode, helpKeyword);
             }
         }
@@ -133,10 +127,7 @@ private void Write(string text)
                 string errorCode;
                 string helpKeyword;
                 string message = ResourceUtilities.FormatResourceString(out errorCode, out helpKeyword, "InvalidFileLoggerFile", logFileName, ex.Message);
-                if (fileWriter != null)
-                {
-                    fileWriter.Close();
-                }
+                fileWriter?.Close();
                 throw new LoggerException(message, ex.InnerException, errorCode, helpKeyword);
             }
         }
@@ -154,10 +145,7 @@ public override void Shutdown()
             finally
             {
                 // Keep FxCop happy by closing in a Finally.
-                if (fileWriter != null)
-                {
-                    fileWriter.Close();
-                }
+                fileWriter?.Close();
             }
         }
 
@@ -169,9 +157,7 @@ private void ParseFileLoggerParameters()
         {
             if (this.Parameters != null)
             {
-                string[] parameterComponents;
-
-                parameterComponents = this.Parameters.Split(fileLoggerParameterDelimiters);
+                string[] parameterComponents = this.Parameters.Split(fileLoggerParameterDelimiters);
                 for (int param = 0; param < parameterComponents.Length; param++)
                 {
                     if (parameterComponents[param].Length > 0)
@@ -263,7 +249,6 @@ private void ApplyFileLoggerParameter(string parameterName, string parameterValu
         /// </summary>
         private static readonly char[] fileLoggerParameterValueSplitCharacter = { '=' };
 
-
         #endregion
     }
 }
diff --git a/src/Deprecated/Engine/Logging/LoggerDescription.cs b/src/Deprecated/Engine/Logging/LoggerDescription.cs
index b505e646692..88330bd342e 100644
--- a/src/Deprecated/Engine/Logging/LoggerDescription.cs
+++ b/src/Deprecated/Engine/Logging/LoggerDescription.cs
@@ -206,9 +206,9 @@ private ILogger CreateLogger(bool forwardingLogger)
         /// <returns>true, if specified type is a logger</returns>
         private static bool IsForwardingLoggerClass(Type type, object unused)
         {
-            return (type.IsClass &&
+            return type.IsClass &&
                 !type.IsAbstract &&
-                (type.GetInterface("IForwardingLogger") != null));
+                (type.GetInterface("IForwardingLogger") != null);
         }
 
         /// <summary>
@@ -218,9 +218,9 @@ private static bool IsForwardingLoggerClass(Type type, object unused)
         /// <returns>true, if specified type is a logger</returns>
         private static bool IsLoggerClass(Type type, object unused)
         {
-            return (type.IsClass &&
+            return type.IsClass &&
                 !type.IsAbstract &&
-                (type.GetInterface("ILogger") != null));
+                (type.GetInterface("ILogger") != null);
         }
 
         /// <summary>
@@ -332,7 +332,6 @@ internal void CreateFromStream(BinaryReader reader)
             }
             else
             {
-
                 string assemblyName = null;
                 string assemblyFile = null;
 
diff --git a/src/Deprecated/Engine/Logging/NullCentralLogger.cs b/src/Deprecated/Engine/Logging/NullCentralLogger.cs
index 62ea0223c28..7e187e96839 100644
--- a/src/Deprecated/Engine/Logging/NullCentralLogger.cs
+++ b/src/Deprecated/Engine/Logging/NullCentralLogger.cs
@@ -49,7 +49,7 @@ public string Parameters
         #region Methods
         public void Initialize(IEventSource eventSource, int nodeCount)
         {
-            eventSource.AnyEventRaised += new AnyEventHandler(AnyEventRaisedHandler);
+            eventSource.AnyEventRaised += AnyEventRaisedHandler;
         }
 
         public void AnyEventRaisedHandler(object sender, BuildEventArgs e)
diff --git a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 11a0c9161f2..4aa273db8c9 100644
--- a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -102,22 +102,22 @@ internal override bool ApplyParameter(string parameterName, string parameterValu
             {
                 return true;
             }
-            if (0 == String.Compare(parameterName, "SHOWCOMMANDLINE", StringComparison.OrdinalIgnoreCase))
+            if (String.Equals(parameterName, "SHOWCOMMANDLINE", StringComparison.OrdinalIgnoreCase))
             {
                 showCommandline = true;
                 return true;
             }
-            else if (0 == String.Compare(parameterName, "SHOWTIMESTAMP", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "SHOWTIMESTAMP", StringComparison.OrdinalIgnoreCase))
             {
                 showTimeStamp = true;
                 return true;
             }
-            else if (0 == String.Compare(parameterName, "SHOWEVENTID", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "SHOWEVENTID", StringComparison.OrdinalIgnoreCase))
             {
                 showEventId = true;
                 return true;
             }
-            else if (0 == String.Compare(parameterName, "FORCENOALIGN", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "FORCENOALIGN", StringComparison.OrdinalIgnoreCase))
             {
                 forceNoAlign = true;
                 alignMessages = false;
@@ -376,7 +376,6 @@ private void ShowErrorWarningSummary<T>(ArrayList listToProcess) where T : Build
             // Loop through each of the warnings and put them into the correct buckets
             for (int listCount = 0; listCount < listToProcess.Count; listCount++)
             {
-
                 T errorWarningEventArgs = (T)listToProcess[listCount];
 
                 // Target event may be null for a couple of reasons:
@@ -431,7 +430,7 @@ private void ShowErrorWarningSummary<T>(ArrayList listToProcess) where T : Build
 
                 //If the target where the error occurred is the same as the previous message do not print the location
                 // where the error occurred again
-                if (String.Compare(previousTarget, valuePair.Key.TargetName, StringComparison.OrdinalIgnoreCase) != 0)
+                if (!String.Equals(previousTarget, valuePair.Key.TargetName, StringComparison.OrdinalIgnoreCase))
                 {
                     //If no targetName was specified then do not show the target where the error occurred
                     if (! string.IsNullOrEmpty(valuePair.Key.TargetName))
@@ -500,12 +499,12 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
                 {
                     DisplayDeferredProjectStartedEvent(e.BuildEventContext);
                 }
-                if (null != e.Properties)
+                if (e.Properties != null)
                 {
                     WriteProperties(e, e.Properties);          
                 }
 
-                if (null != e.Items)
+                if (e.Items != null)
                 {
                     WriteItems(e, e.Items);
                 }
@@ -548,10 +547,8 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
                         // In the project finished message the targets which were built and the project which was built
                         // should be shown
                         string targets = startedEvent.TargetNames;
-
-                        string projectName = string.Empty;
-
-                        projectName = startedEvent.ProjectFile == null ? string.Empty : startedEvent.ProjectFile;
+                        string projectName = startedEvent.ProjectFile ?? string.Empty;
+                        
                         // Show which targets were built as part of this project
                         if (string.IsNullOrEmpty(targets))
                         {
@@ -967,7 +964,7 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
                        && IsVerbosityAtLeast(LoggerVerbosity.Normal)
                     )
                 {
-                    List<BuildMessageEventArgs> messageList = null;
+                    List<BuildMessageEventArgs> messageList;
                     if (deferredMessages.ContainsKey(e.BuildEventContext))
                     {
                         messageList = deferredMessages[e.BuildEventContext];
@@ -1013,7 +1010,7 @@ private void DisplayDeferredStartedEvents(BuildEventContext e)
         /// </summary>
         private void PrintMessage(BuildMessageEventArgs e, bool lightenText)
         {
-            string nonNullMessage = (e.Message == null) ? String.Empty : e.Message;
+            string nonNullMessage = e.Message ?? String.Empty;
             int prefixAdjustment = 0;
 
             if (e.BuildEventContext.TaskId != BuildEventContext.InvalidTaskId)
@@ -1064,7 +1061,7 @@ private void PrintTargetNamePerMessage(BuildMessageEventArgs e, bool lightenText
                 string targetName = string.Empty;
 
                 // Does the context (Project, Node, Context, Target, NOT task) of the previous event match the current message
-                bool contextAreEqual = compareContextNodeIdTargetId.Equals(currentBuildEventContext, lastDisplayedBuildEventContext == null ? null : lastDisplayedBuildEventContext);
+                bool contextAreEqual = compareContextNodeIdTargetId.Equals(currentBuildEventContext, lastDisplayedBuildEventContext ?? null);
 
                 TargetStartedEventMinimumFields targetStartedEvent = null;
                 // If the previous event does not have the same target context information, the target name needs to be printed to the console
@@ -1113,7 +1110,7 @@ private bool WriteTargetMessagePrefix(BuildEventArgs e, BuildEventContext contex
         {
             bool prefixAlreadyWritten = true;
             ProjectFullKey currentProjectFullKey = GetFullProjectKey(e.BuildEventContext);
-            if (!(lastProjectFullKey.Equals(currentProjectFullKey)))
+            if (!lastProjectFullKey.Equals(currentProjectFullKey))
             {
                 // Write the prefix information about the target for the message
                 WriteLinePrefix(context, timeStamp, false);
@@ -1175,8 +1172,8 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int
                         {
                             // Calculate how many chars will fit on the console buffer
                             amountToCopy = (messageLength - index) < (bufferWidthMinusNewLine - adjustedPrefixWidth) ? (messageLength - index) : (bufferWidthMinusNewLine - adjustedPrefixWidth);
-                            WriteBasedOnPrefix(nonNullMessage.Substring(index, amountToCopy), (prefixAlreadyWritten && index == 0 && i == 0), adjustedPrefixWidth);
-                            index = index + amountToCopy;
+                            WriteBasedOnPrefix(nonNullMessage.Substring(index, amountToCopy), prefixAlreadyWritten && index == 0 && i == 0, adjustedPrefixWidth);
+                            index += amountToCopy;
                         }
                     }
                     else
@@ -1218,7 +1215,7 @@ private void DisplayDeferredTargetStartedEvent(BuildEventContext e)
             TargetStartedEventMinimumFields targetStartedEvent = buildEventManager.GetTargetStartedEvent(e);
 
             //Make sure we have not shown the event before
-            if (targetStartedEvent != null && !targetStartedEvent.ShowTargetFinishedEvent)
+            if (targetStartedEvent?.ShowTargetFinishedEvent == false)
             {
                 //Since the target started event has been shows, the target finished event should also be shown
                 targetStartedEvent.ShowTargetFinishedEvent = true;
@@ -1232,9 +1229,9 @@ private void DisplayDeferredTargetStartedEvent(BuildEventContext e)
                
                 ProjectStartedEventMinimumFields startedEvent = buildEventManager.GetProjectStartedEvent(e);
                 ErrorUtilities.VerifyThrow(startedEvent != null, "Project Started should not be null in deferred target started");
-                string currentProjectFile = startedEvent.ProjectFile == null ? string.Empty : startedEvent.ProjectFile;
+                string currentProjectFile = startedEvent.ProjectFile ?? string.Empty;
 
-                string targetName = null;
+                string targetName;
                 if (IsVerbosityAtLeast(LoggerVerbosity.Diagnostic) || showEventId)
                 {
                    targetName = ResourceUtilities.FormatResourceString("TargetMessageWithId", targetStartedEvent.TargetName, targetStartedEvent.ProjectBuildEventContext.TargetId);
@@ -1271,7 +1268,7 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                 ProjectStartedEventMinimumFields projectStartedEvent = buildEventManager.GetProjectStartedEvent(e);
 
                 // Make sure the project started event has not been show yet
-                if (projectStartedEvent != null && !projectStartedEvent.ShowProjectFinishedEvent)
+                if (projectStartedEvent?.ShowProjectFinishedEvent == false)
                 {
                     projectStartedEvent.ShowProjectFinishedEvent = true;
 
@@ -1282,8 +1279,8 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                         DisplayDeferredStartedEvents(parentStartedEvent.ProjectBuildEventContext);
                     }
 
-                    string current = projectStartedEvent.ProjectFile == null ? string.Empty : projectStartedEvent.ProjectFile;
-                    string previous = parentStartedEvent == null ? null : parentStartedEvent.ProjectFile;
+                    string current = projectStartedEvent.ProjectFile ?? string.Empty;
+                    string previous = parentStartedEvent?.ProjectFile;
                     string targetNames = projectStartedEvent.TargetNames;
 
                     // Log 0-based node id's, where 0 is the parent. This is a little unnatural for the reader,
@@ -1293,8 +1290,8 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                     {
                         WriteLinePrefix(projectStartedEvent.FullProjectKey, projectStartedEvent.TimeStamp, false);
                         setColor(ConsoleColor.Cyan);
-                        string message = string.Empty;
-                        if ((targetNames == null) || (targetNames.Length == 0))
+                        string message;
+                        if (string.IsNullOrEmpty(targetNames))
                         {
                             message = ResourceUtilities.FormatResourceString("ProjectStartedTopLevelProjectWithDefaultTargets", current, currentProjectNodeId);
                         }
@@ -1310,7 +1307,7 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                     {
                         WriteLinePrefix(parentStartedEvent.FullProjectKey, parentStartedEvent.TimeStamp, false);
                         setColor(ConsoleColor.Cyan);
-                        if ((targetNames == null) || (targetNames.Length == 0))
+                        if (string.IsNullOrEmpty(targetNames))
                         {
                             WriteMessageAligned(ResourceUtilities.FormatResourceString("ProjectStartedWithDefaultTargetsMultiProc", previous, parentStartedEvent.FullProjectKey, current, projectStartedEvent.FullProjectKey, currentProjectNodeId), true);
                         }
@@ -1372,8 +1369,7 @@ private void WriteLinePrefix(string key, DateTime eventTimeStamp, bool isMessage
                 context = LogFormatter.FormatLogTimeStamp(eventTimeStamp);
             }
 
-            string prefixString = string.Empty;
-
+            string prefixString;
             if (!isMessagePrefix || IsVerbosityAtLeast(LoggerVerbosity.Detailed))
             {
                 prefixString = ResourceUtilities.FormatResourceString("BuildEventContext", context, key) + ">";
@@ -1509,7 +1505,6 @@ internal void AddEventStarted(string projectTargetNames, BuildEventContext build
             /// </summary>
             internal void AddEventFinished(string projectTargetNames, BuildEventContext buildEventContext, DateTime eventTimeStamp)
             {
-
                 if (!string.IsNullOrEmpty(projectTargetNames))
                 {
                     MPPerformanceCounter entryPoint = GetPerformanceCounter(projectTargetNames, ref internalPerformanceCounters);
@@ -1550,7 +1545,7 @@ internal override void PrintCounterMessage(WriteLinePrettyFromResourceDelegate W
                                "{0,3}", calls)
                    );
 
-                if (internalPerformanceCounters != null && internalPerformanceCounters.Count > 0)
+                if (internalPerformanceCounters?.Count > 0)
                 {
                     // For each of the entry points in the project print out the performance numbers for them
                     foreach (MPPerformanceCounter counter in internalPerformanceCounters.Values)
diff --git a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index d8fa15e6395..41b8ddb199f 100644
--- a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -50,12 +50,12 @@ internal void AddProjectStartedEvent(ProjectStartedEventArgs e)
                 if (!projectStartedEvents.ContainsKey(e.BuildEventContext))
                 {
                     int projectTargetKeyLocal = 1;
-                    int projectIncrementKeyLocal = 1;
+                    int projectIncrementKeyLocal;
                     // If we haven't seen this project before (by full path) then
                     // allocate a new key for it and save it away
                     if (!projectKey.ContainsKey(e.ProjectFile))
                     {
-                        projectIncrementKey += 1;
+                        projectIncrementKey++;
 
                         projectKey[e.ProjectFile] = projectIncrementKey;
                         projectIncrementKeyLocal = projectIncrementKey;
@@ -214,7 +214,7 @@ internal void RemoveProjectStartedEvent(BuildEventContext e)
         {
             ProjectStartedEventMinimumFields startedEvent = GetProjectStartedEvent(e);
             // Only remove the project from the event list if it is in the list, and no errors have occurred in the project
-            if (startedEvent != null && !startedEvent.ErrorInProject)
+            if (startedEvent?.ErrorInProject == false)
             {
                 projectStartedEvents.Remove(e);
             }
@@ -227,7 +227,7 @@ internal void RemoveTargetStartedEvent(BuildEventContext e)
         {
             TargetStartedEventMinimumFields startedEvent = GetTargetStartedEvent(e);
             // Only remove the project from the event list if it is in the list, and no errors have occurred in the project
-            if (startedEvent != null && !startedEvent.ErrorInTarget)
+            if (startedEvent?.ErrorInTarget == false)
             {
                 targetStartedEvents.Remove(e);
             }
@@ -259,7 +259,7 @@ public bool Equals(T x, T y)
         public int GetHashCode(T x)
         {
             BuildEventContext context = x as BuildEventContext;
-            return (context.ProjectContextId + (context.NodeId << 24));
+            return context.ProjectContextId + (context.NodeId << 24);
         }
         #endregion
     }
@@ -289,7 +289,7 @@ public bool Equals(T x, T y)
         public int GetHashCode(T x)
         {
             BuildEventContext context = x as BuildEventContext;
-            return (context.ProjectContextId + (context.NodeId << 24));
+            return context.ProjectContextId + (context.NodeId << 24);
         }
 
         #endregion
@@ -513,7 +513,6 @@ internal TargetStartedEventMinimumFields(TargetStartedEventArgs startedEvent)
             this.errorInTarget = false;
             this.buildEventContext = startedEvent.BuildEventContext;
             this.timeStamp = startedEvent.Timestamp;
-
         }
         #endregion
     }
@@ -534,7 +533,7 @@ internal class ErrorWarningSummaryDictionaryKey
         internal ErrorWarningSummaryDictionaryKey(BuildEventContext entryPoint, string targetName)
         {
             this.entryPointContext = entryPoint;
-            this.targetName = targetName == null ? string.Empty : targetName;
+            this.targetName = targetName ?? string.Empty;
         }
         #endregion
 
@@ -566,12 +565,12 @@ public override bool Equals(object obj)
             {
                 return false;
             }
-           return  eventComparer.Equals(entryPointContext, key.EntryPointContext) && (String.Compare(targetName, key.TargetName, StringComparison.OrdinalIgnoreCase) == 0);
+           return  eventComparer.Equals(entryPointContext, key.EntryPointContext) && (String.Equals(targetName, key.TargetName, StringComparison.OrdinalIgnoreCase));
         }
 
         public override int GetHashCode()
         {
-            return (entryPointContext.GetHashCode() + targetName.GetHashCode());
+            return entryPointContext.GetHashCode() + targetName.GetHashCode();
         }
         #endregion
 
@@ -657,8 +656,7 @@ public override bool Equals(object obj)
             ProjectFullKey compareKey = obj as ProjectFullKey;
             if (compareKey != null)
             {
-                
-                return ((compareKey.projectKey == this.projectKey) && (compareKey.entryPointKey == this.entryPointKey));
+                return (compareKey.projectKey == this.projectKey) && (compareKey.entryPointKey == this.entryPointKey);
             }
             else
             {
@@ -668,7 +666,7 @@ public override bool Equals(object obj)
 
         public override int GetHashCode()
         {
-            return (this.projectKey + (this.entryPointKey << 16));
+            return this.projectKey + (this.entryPointKey << 16);
         }
         #endregion
     }
diff --git a/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs b/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
index a3a3193e116..751e4b0717b 100644
--- a/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
@@ -267,13 +267,13 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
 
             if (Verbosity == LoggerVerbosity.Diagnostic && showItemAndPropertyList)
             {
-                if (null != e.Properties)
+                if (e.Properties != null)
                 {
                     ArrayList propertyList = ExtractPropertyList(e.Properties);
                     WriteProperties(propertyList);
                 }
 
-                if (null != e.Items)
+                if (e.Items != null)
                 {
                     SortedList itemList = ExtractItemList(e.Items);
                     WriteItems(itemList);
@@ -529,7 +529,7 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
                 }
 
                 // null messages are ok -- treat as blank line
-                string nonNullMessage = (e.Message == null) ? String.Empty : e.Message;
+                string nonNullMessage = e.Message ?? String.Empty;
 
                 WriteLinePretty(nonNullMessage);
 
@@ -594,13 +594,13 @@ private void WriteProjectStartedText(string current, string targetNames, string
             {
                 setColor(ConsoleColor.Cyan);
 
-                this.VerifyStack((current != null), "Unexpected null project stack");
+                this.VerifyStack(current != null, "Unexpected null project stack");
 
                 WriteLinePretty(projectSeparatorLine);
 
                 if (previous == null)
                 {
-                    if ((targetNames == null) || (targetNames.Length == 0))
+                    if (string.IsNullOrEmpty(targetNames))
                     {
                         WriteLinePrettyFromResource(indentLevel, "ProjectStartedPrefixForTopLevelProjectWithDefaultTargets", current);
                     }
@@ -611,7 +611,7 @@ private void WriteProjectStartedText(string current, string targetNames, string
                 }
                 else
                 {
-                    if ((targetNames == null) || (targetNames.Length == 0))
+                    if (string.IsNullOrEmpty(targetNames))
                     {
                         WriteLinePrettyFromResource(indentLevel, "ProjectStartedPrefixForNestedProjectWithDefaultTargets", previous, current);
                     }
@@ -962,7 +962,7 @@ internal int Count
             /// <owner>t-jeffv, sumedhk</owner>
             internal bool IsEmpty()
             {
-                return (frames.Count == 0);
+                return frames.Count == 0;
             }
         }
         #endregion
diff --git a/src/Deprecated/Engine/Microsoft.Build.Engine.csproj b/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
index 5015d92adb4..1626f53236d 100644
--- a/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
+++ b/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
@@ -13,6 +13,7 @@
     <IsPackable>true</IsPackable>
     <PackageDescription>This package contains the $(MSBuildProjectName) assembly which contains the legacy compatibility shim for the MSBuild engine.  NOTE: This assembly is deprecated.</PackageDescription>
     <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
+    <NoWarn>$(NoWarn);1570;1572;1573;1587</NoWarn>
   </PropertyGroup>
   
   <ItemGroup>
diff --git a/src/Deprecated/Engine/Properties/BuildProperty.cs b/src/Deprecated/Engine/Properties/BuildProperty.cs
index e168ef4fe4a..0a36af60177 100644
--- a/src/Deprecated/Engine/Properties/BuildProperty.cs
+++ b/src/Deprecated/Engine/Properties/BuildProperty.cs
@@ -54,9 +54,9 @@ internal enum PropertyType
     }
 
     /// <summary>
-    /// This class holds an MSBuild property.  This may be a property that is 
+    /// This class holds an MSBuild property.  This may be a property that is
     /// represented in the MSBuild project file by an XML element, or it
-    /// may not be represented in any real XML file (e.g., global properties, 
+    /// may not be represented in any real XML file (e.g., global properties,
     /// environment properties, etc.)
     /// </summary>
     /// <owner>rgoel</owner>
@@ -129,13 +129,13 @@ internal void WriteToStream(BinaryWriter writer)
         /// </summary>
         private static string Intern(string stringToIntern)
         {
-            string value = stringToIntern;
+            string value;
             if (!customInternTable.TryGetValue(stringToIntern, out value))
             {
                 customInternTable.Add(stringToIntern, stringToIntern);
                 value = stringToIntern;
             }
-            
+
             return value;
         }
 
@@ -186,7 +186,7 @@ internal BuildProperty
             XmlElement      propertyElement,
             PropertyType    propertyType
         ) :
-            this(propertyElement, 
+            this(propertyElement,
                  propertyElement != null ? Utilities.GetXmlNodeInnerContents(propertyElement) : null,
                  propertyType)
         {
@@ -231,7 +231,7 @@ PropertyType propertyType
                         break;
 
                     default:
-                        ProjectXmlUtilities.ThrowProjectInvalidAttribute(propertyAttribute); 
+                        ProjectXmlUtilities.ThrowProjectInvalidAttribute(propertyAttribute);
                         break;
                 }
             }
@@ -239,7 +239,6 @@ PropertyType propertyType
             this.propertyValue = propertyValue;
             this.finalValueEscaped = propertyValue;
             this.type = propertyType;
-
         }
 
         /// <summary>
@@ -257,12 +256,12 @@ internal BuildProperty
         (
             XmlDocument ownerDocument,
             string propertyName,
-            string propertyValue, 
+            string propertyValue,
             PropertyType propertyType
         )
         {
-            ErrorUtilities.VerifyThrowArgumentLength(propertyName, "propertyName");
-            ErrorUtilities.VerifyThrowArgumentNull(propertyValue, "propertyValue");
+            ErrorUtilities.VerifyThrowArgumentLength(propertyName, nameof(propertyName));
+            ErrorUtilities.VerifyThrowArgumentNull(propertyValue, nameof(propertyValue));
 
             // Validate that the property name doesn't contain any illegal characters.
             XmlUtilities.VerifyThrowValidElementName(propertyName);
@@ -306,7 +305,6 @@ PropertyType propertyType
 
             // Assign the property type.
             this.type = propertyType;
-
         }
 
         /// <summary>
@@ -324,7 +322,7 @@ PropertyType propertyType
         internal BuildProperty
         (
             string propertyName,
-            string propertyValue, 
+            string propertyValue,
             PropertyType propertyType
         ) :
             this(null, propertyName, propertyValue, propertyType)
@@ -332,8 +330,8 @@ PropertyType propertyType
         }
 
         /// <summary>
-        /// Constructor, which initializes the property from just the property 
-        /// name and value, creating it as a "normal" property.  This ends up 
+        /// Constructor, which initializes the property from just the property
+        /// name and value, creating it as a "normal" property.  This ends up
         /// creating a new XML element for the property under a dummy XML document.
         /// </summary>
         /// <param name="propertyName"></param>
@@ -349,7 +347,7 @@ string propertyValue
         }
 
         /// <summary>
-        /// Default constructor.  This is not allowed because it leaves the 
+        /// Default constructor.  This is not allowed because it leaves the
         /// property in a bad state -- without a name or value.  But we have to
         /// have it, otherwise FXCop complains.
         /// </summary>
@@ -367,16 +365,16 @@ private BuildProperty
 
         /// <summary>
         /// Accessor for the property name.  This is read-only, so one cannot
-        /// change the property name once it's set ... your only option is 
+        /// change the property name once it's set ... your only option is
         /// to create a new BuildProperty object.  The reason is that BuildProperty objects
-        /// are often stored in hash tables where the hash function is based 
+        /// are often stored in hash tables where the hash function is based
         /// on the property name.  Modifying the property name of an existing
         /// BuildProperty object would make the hash table incorrect.
         /// </summary>
         /// <owner>RGoel</owner>
         public string Name
         {
-            get 
+            get
             {
                 if (propertyElement != null)
                 {
@@ -386,7 +384,7 @@ public string Name
                 else
                 {
                     // If we are not persisted, propertyName and propertyValue must not be null.
-                    ErrorUtilities.VerifyThrow((this.propertyName != null) && (this.propertyName.Length > 0) && (this.propertyValue != null),
+                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(this.propertyName) && (this.propertyValue != null),
                         "BuildProperty object doesn't have a name/value pair.");
 
                     // Get the property name from the string variable
@@ -405,13 +403,13 @@ public string Value
             get
             {
                 // If we are not persisted, propertyName and propertyValue must not be null.
-                ErrorUtilities.VerifyThrow(this.propertyValue != null, 
+                ErrorUtilities.VerifyThrow(this.propertyValue != null,
                     "BuildProperty object doesn't have a name/value pair.");
 
                 return this.propertyValue;
             }
 
-            set 
+            set
             {
                 ErrorUtilities.VerifyThrowInvalidOperation(this.type != PropertyType.ImportedProperty,
                     "CannotModifyImportedProjects", this.Name);
@@ -493,7 +491,7 @@ public string FinalValue
         }
 
         /// <summary>
-        /// Accessor for the property type.  This is internal, so that nobody 
+        /// Accessor for the property type.  This is internal, so that nobody
         /// calling the OM can modify the type.  We actually need to modify
         /// it in certain cases internally.  C# doesn't allow a different
         /// access mode for the "get" vs. the "set", so we've made them both
@@ -502,12 +500,12 @@ public string FinalValue
         /// <owner>RGoel</owner>
         internal PropertyType Type
         {
-            get 
+            get
             {
                 return this.type;
             }
 
-            set 
+            set
             {
                 this.type = value;
             }
@@ -521,7 +519,7 @@ public bool IsImported
         {
             get
             {
-                return (this.type == PropertyType.ImportedProperty);
+                return this.type == PropertyType.ImportedProperty;
             }
         }
 
@@ -606,7 +604,7 @@ internal BuildPropertyGroup ParentPersistedPropertyGroup
         #region Methods
 
         /// <summary>
-        /// Given a property bag, this method evaluates the current property, 
+        /// Given a property bag, this method evaluates the current property,
         /// expanding any property references contained within.  It stores this
         /// evaluated value in the "finalValue" member.
         /// </summary>
@@ -633,16 +631,16 @@ private void MarkPropertyAsDirty
             {
                 ErrorUtilities.VerifyThrow(this.ParentPersistedPropertyGroup.ParentProject != null, "Persisted BuildPropertyGroup doesn't have parent project.");
                 this.ParentPersistedPropertyGroup.MarkPropertyGroupAsDirty();
-            };
+            }
         }
 
         /// <summary>
         /// Creates a shallow or deep clone of this BuildProperty object.
-        /// 
-        /// A shallow clone points at the same XML element as the original, so 
-        /// that modifications to the name or value will be reflected in both 
+        ///
+        /// A shallow clone points at the same XML element as the original, so
+        /// that modifications to the name or value will be reflected in both
         /// copies.  However, the two copies could have different a finalValue.
-        /// 
+        ///
         /// A deep clone actually clones the XML element as well, so that the
         /// two copies are completely independent of each other.
         /// </summary>
@@ -711,9 +709,9 @@ BuildProperty compareToProperty
             // just a back-pointer, and doesn't really contribute to the "identity" of
             // the property.
 
-            return 
+            return
                 (compareToProperty != null) &&
-                (0 == String.Compare(compareToProperty.propertyName, this.propertyName, StringComparison.OrdinalIgnoreCase)) &&
+                (String.Equals(compareToProperty.propertyName, this.propertyName, StringComparison.OrdinalIgnoreCase)) &&
                 (compareToProperty.propertyValue                == this.propertyValue) &&
                 (compareToProperty.FinalValue                   == this.FinalValue) &&
                 (compareToProperty.type                         == this.type);
@@ -744,7 +742,7 @@ public override string ToString
         public static explicit operator string
         (
             BuildProperty propertyToCast
-        ) 
+        )
         {
             if (propertyToCast == null)
             {
diff --git a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
index cfc4f221e58..b666ba90434 100644
--- a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
+++ b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
@@ -195,7 +195,7 @@ internal BuildPropertyGroup(Project parentProject, XmlElement propertyGroupEleme
         /// be imported
         /// </summary>
         internal BuildPropertyGroup(Project parentProject, XmlElement propertyGroupElement, bool isImported)
-            : this(parentProject, propertyGroupElement, (isImported ? PropertyType.ImportedProperty : PropertyType.NormalProperty))
+            : this(parentProject, propertyGroupElement, isImported ? PropertyType.ImportedProperty : PropertyType.NormalProperty)
         {
         }
 
@@ -242,7 +242,7 @@ internal BuildPropertyGroup(Project parentProject, XmlElement propertyGroupEleme
 
                     // Unrecognized attribute.
                     default:
-                        ProjectXmlUtilities.ThrowProjectInvalidAttribute(propertyGroupAttribute); 
+                        ProjectXmlUtilities.ThrowProjectInvalidAttribute(propertyGroupAttribute);
                         break;
                 }
             }
@@ -386,7 +386,7 @@ internal XmlAttribute ConditionAttribute
         }
 
         /// <summary>
-        /// Accessor for the XmlElement representing this property group.  This is 
+        /// Accessor for the XmlElement representing this property group.  This is
         /// internal to MSBuild, and is read-only.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -525,7 +525,7 @@ internal string ImportedFromFilename
         /// <returns>The property with the given name, or null if it does not exist in this group</returns>
         public BuildProperty this[string propertyName]
         {
-            get 
+            get
             {
                 // We don't support this method for PropertyGroups that are persisted.
                 // This is because persisted PropertyGroups can contain multiple 
@@ -545,7 +545,7 @@ public BuildProperty this[string propertyName]
 
                 // Make sure that the property name passed into the indexer matches
                 // the property name on the BuildProperty object.
-                error.VerifyThrowArgument(0 == String.Compare(propertyName, value.Name, StringComparison.OrdinalIgnoreCase),
+                error.VerifyThrowArgument(String.Equals(propertyName, value.Name, StringComparison.OrdinalIgnoreCase),
                     "PropertyNamesDoNotMatch", "BuildProperty");
 
                 this.SetProperty(value);
@@ -627,7 +627,7 @@ bool deepClone
                     // Do not set the ParentProject on the new BuildPropertyGroup, because it isn't really
                     // part of the project
                     clone = new BuildPropertyGroup(null, propertyTableByName.Count);
-                    
+
                     foreach (DictionaryEntry propertyEntry in this.propertyTableByName)
                     {
                         // If the caller requested a deep clone, then deep clone the BuildProperty object,
@@ -707,8 +707,8 @@ part of the project */
         /// <summary>
         /// ImportInitialProperties is used when setting up an evaluated BuildProperty
         /// Group with the initial set of properties from MSBuild reserved properties,
-        /// environment variables, tools version dependent properties, and global 
-        /// properties.  After this virtual BuildPropertyGroup has been populated with 
+        /// environment variables, tools version dependent properties, and global
+        /// properties.  After this virtual BuildPropertyGroup has been populated with
         /// these, we can continue to read in the properties from the project file.
         /// </summary>
         /// <param name="environmentProperties"></param>
@@ -718,9 +718,9 @@ part of the project */
         /// <owner>RGoel</owner>
         internal void ImportInitialProperties
         (
-            BuildPropertyGroup environmentProperties, 
-            BuildPropertyGroup reservedProperties, 
-            BuildPropertyGroup toolsVersionDependentProperties, 
+            BuildPropertyGroup environmentProperties,
+            BuildPropertyGroup reservedProperties,
+            BuildPropertyGroup toolsVersionDependentProperties,
             BuildPropertyGroup globalProperties
         )
         {
@@ -754,7 +754,7 @@ BuildPropertyGroup globalProperties
         }
 
         /// <summary>
-        /// Sets a property. 
+        /// Sets a property.
         ///
         /// Either overrides the value of the property with the given name, or adds it if it
         /// doesn't already exist. Setting to the same value as before does nothing.
@@ -812,7 +812,7 @@ BuildProperty newProperty
                 {
                     // Allow properties to be "set" to the same value during a build. This is because Visual Studio unfortunately does this often,
                     // and it is safe to do this, because we won't actually change any state.
-                    ErrorUtilities.VerifyThrowInvalidOperation(parentProject == null || !parentProject.IsBuilding, "CannotSetPropertyDuringBuild");
+                    ErrorUtilities.VerifyThrowInvalidOperation(parentProject?.IsBuilding != true, "CannotSetPropertyDuringBuild");
                 }
             }
 
@@ -831,7 +831,7 @@ BuildProperty newProperty
                 }
                 else
                 {
-                    error.VerifyThrow((existingProperty == null) || (existingProperty.Type != PropertyType.OutputProperty), 
+                    error.VerifyThrow((existingProperty == null) || (existingProperty.Type != PropertyType.OutputProperty),
                         "If the property already exists in the main property table, it can't already be there as an output property, because then we would have stored an entry in propertiesOverriddenByOutputProperties.");
 
                     // NOTE: Use Hashtable.Add() because each output property should only be added to this
@@ -851,8 +851,8 @@ BuildProperty newProperty
         }
 
         /// <summary>
-        /// Sets a property taking the property name and value as strings directly. 
-        /// 
+        /// Sets a property taking the property name and value as strings directly.
+        ///
         /// Either overrides the value of the property with the given name, or adds it if it
         /// doesn't already exist. Setting to the same value as before does nothing.
         ///
@@ -883,7 +883,7 @@ public void SetProperty
             bool treatPropertyValueAsLiteral
             )
         {
-            this.SetProperty(propertyName, 
+            this.SetProperty(propertyName,
                 treatPropertyValueAsLiteral ? EscapingUtilities.Escape(propertyValue) : propertyValue);
         }
 
@@ -964,12 +964,12 @@ Project importedProject
         }
 
         /// <summary>
-        /// Adds an existing BuildProperty to the list of properties, does not attempt 
+        /// Adds an existing BuildProperty to the list of properties, does not attempt
         /// to add backing Xml for the item.
         /// </summary>
         /// <param name="propertyToAdd"></param>
         /// <owner>JomoF</owner>
-        internal void AddExistingProperty 
+        internal void AddExistingProperty
         (
             BuildProperty propertyToAdd
         )
@@ -1004,7 +1004,7 @@ BuildProperty propertyToAdd
             // Make sure the property to be added has an XML element backing it,
             // and that its XML belongs to the same XML document as our BuildPropertyGroup.
             error.VerifyThrow(propertyToAdd.PropertyElement != null, "BuildProperty does not have an XML element");
-            error.VerifyThrow(propertyToAdd.PropertyElement.OwnerDocument == this.ownerDocument, 
+            error.VerifyThrow(propertyToAdd.PropertyElement.OwnerDocument == this.ownerDocument,
                 "Cannot add an BuildProperty with a different XML owner document.");
 
             // For persisted groups, just append the property at the end of the <BuildPropertyGroup> tag.
@@ -1025,7 +1025,7 @@ public void RemoveProperty
             BuildProperty property
         )
         {
-            error.VerifyThrowArgumentNull(property, "property");
+            error.VerifyThrowArgumentNull(property, nameof(property));
 
             // If this is a persisted <PropertyGroup>, then remove the property element from 
             // the XML and from the array list.
@@ -1087,7 +1087,7 @@ string propertyName
                 // name.
                 foreach (BuildProperty property in this)
                 {
-                    if (0 == String.Compare(property.Name, propertyName, StringComparison.OrdinalIgnoreCase))
+                    if (String.Equals(property.Name, propertyName, StringComparison.OrdinalIgnoreCase))
                     {
                         // Add the property to our list of things to remove.
                         propertiesToRemove.Add(property);
@@ -1109,10 +1109,7 @@ string propertyName
                 this.propertyTableByName.Remove(propertyName);
 
                 // if the property was overridden by an output property, we also want to remove the original
-                if (propertiesOverriddenByOutputProperties != null)
-                {
-                    propertiesOverriddenByOutputProperties.Remove(propertyName);
-                }
+                propertiesOverriddenByOutputProperties?.Remove(propertyName);
             }
 
             this.MarkPropertyGroupAsDirty();
@@ -1128,7 +1125,6 @@ internal void EnsureNoReservedProperties()
                 // Make sure this property doesn't override a reserved property
                 ProjectErrorUtilities.VerifyThrowInvalidProject(this.ParentProject.ReservedProperties[property.Name] == null,
                     property.PropertyElement, "CannotModifyReservedProperty", property.Name);
-
             }
         }
 
@@ -1216,19 +1212,13 @@ internal void ClearHelper(bool clearImportedPropertyGroup)
             this.conditionAttribute = null;
 
             // Clear the contents of the hash table, if one exists.
-            if (this.propertyTableByName != null)
-            {
-                this.propertyTableByName.Clear();
-            }
+            this.propertyTableByName?.Clear();
 
             // clear out saved properties
             propertiesOverriddenByOutputProperties = null;
 
             // Clear the contents of the arraylist, if one exists.
-            if (this.propertyList != null)
-            {
-                this.propertyList.Clear();
-            }
+            this.propertyList?.Clear();
 
             this.MarkPropertyGroupAsDirty();
         }
@@ -1277,7 +1267,7 @@ internal void MarkPropertyGroupAsDirty
                     // example, if a global property changes....
                     this.ParentProject.MarkProjectAsDirtyForReevaluation();
                 }
-            };
+            }
         }
 
         /// <summary>
@@ -1287,7 +1277,7 @@ internal void MarkPropertyGroupAsDirty
         /// the previously gathered variables, and set new ones. This method
         /// will not, however, unset previously set variables.
         /// Requires property group to be virtual.
-        /// 
+        ///
         /// NOTE: this method does not allow environment variables to override
         /// previously set properties of type "GlobalProperty" or "ReservedProperty"
         /// </summary>
@@ -1333,7 +1323,7 @@ private void SetExtensionsPathProperties()
             // "MSBuildExtensionsPath32". This points to whatever the value of "Program Files (x86)" environment variable is;
             // but on a 32 bit box this isn't set, and we should use "Program Files" instead.
             string programFiles = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles);
-    
+
             // Similarly for "MSBuildExtensionsPath32". This points to whatever the value of "Program Files (x86)" environment variable is;
             // but on a 32 bit box this isn't set, and we should use "Program Files" instead.
             string programFiles32 = Environment.GetEnvironmentVariable(Constants.programFilesx86);
@@ -1352,7 +1342,7 @@ private void SetExtensionsPathProperties()
 
             bool useLegacyMSBuildExtensionsPathBehavior = !String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLEGACYEXTENSIONSPATH"));
 
-            string extensionsPath; 
+            string extensionsPath;
             if (useLegacyMSBuildExtensionsPathBehavior)
             {
                 extensionsPath = Path.Combine(programFiles, ReservedPropertyNames.extensionsPathSuffix);
@@ -1367,7 +1357,7 @@ private void SetExtensionsPathProperties()
 
         /// <summary>
         /// This method does a comparison of the actual contents of two property bags
-        /// and returns True if they are equal, else False.  Equality means that 
+        /// and returns True if they are equal, else False.  Equality means that
         /// the two collections contain the same set of property names (case insensitive)
         /// with the same values (case sensitive).
         /// Requires property group to be virtual.
@@ -1465,7 +1455,7 @@ string errorResourceName
         /// <returns></returns>
         private bool IsPersisted
         {
-            get { return (this.propertyGroupElement != null); }
+            get { return this.propertyGroupElement != null; }
         }
 
         /// <summary>
@@ -1484,11 +1474,11 @@ string arg
 
             // If this is a persisted element, then we should have an
             // ArrayList of BuildProperty objects, but not a hash table.
-            error.VerifyThrow(this.propertyList != null, 
+            error.VerifyThrow(this.propertyList != null,
                 "ArrayList of BuildProperty objects expected for this BuildPropertyGroup.");
-            error.VerifyThrow(this.propertyTableByName == null, 
+            error.VerifyThrow(this.propertyTableByName == null,
                 "HashTable of BuildProperty objects not expected for this BuildPropertyGroup.");
-            error.VerifyThrow(this.ownerDocument != null, 
+            error.VerifyThrow(this.ownerDocument != null,
                 "There must be an owner document. It should have been set in the constructor.");
         }
 
@@ -1501,7 +1491,7 @@ private void MustBelongToPropertyGroup
             XmlElement propertyElement
         )
         {
-            error.VerifyThrowInvalidOperation(propertyElement != null, 
+            error.VerifyThrowInvalidOperation(propertyElement != null,
                 "PropertyDoesNotBelongToPropertyGroup");
             error.VerifyThrowInvalidOperation(propertyElement.ParentNode == this.propertyGroupElement,
                 "PropertyDoesNotBelongToPropertyGroup");
diff --git a/src/Deprecated/Engine/Resources/Constants.cs b/src/Deprecated/Engine/Resources/Constants.cs
index 23106a2504e..499b2fa4acd 100644
--- a/src/Deprecated/Engine/Resources/Constants.cs
+++ b/src/Deprecated/Engine/Resources/Constants.cs
@@ -43,20 +43,20 @@ internal static class ReservedPropertyNames
         /// <returns>true, if specified property is reserved</returns>
         internal static bool IsReservedProperty(string property)
         {
-            return 
-                (
-                    (String.Compare(property, projectDirectory, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, projectFile, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, projectExtension, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, projectFullPath, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, projectName, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, binPath, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, toolsPath, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, projectDefaultTargets, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, programFiles32, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, assemblyVersion, StringComparison.OrdinalIgnoreCase) == 0)
-                    // Intentionally do not include MSBuildExtensionsPath or MSBuildExtensionsPath32 in this list.  We need tasks to be able to override those.
-                );
+            return
+
+                    (String.Equals(property, projectDirectory, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, projectFile, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, projectExtension, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, projectFullPath, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, projectName, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, binPath, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, toolsPath, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, projectDefaultTargets, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, programFiles32, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, assemblyVersion, StringComparison.OrdinalIgnoreCase))
+                // Intentionally do not include MSBuildExtensionsPath or MSBuildExtensionsPath32 in this list.  We need tasks to be able to override those.
+                ;
         }
     }
 
diff --git a/src/Deprecated/Engine/Shared/AssemblyLoadInfo.cs b/src/Deprecated/Engine/Shared/AssemblyLoadInfo.cs
index f9d16f4a33a..cf9e5f80249 100644
--- a/src/Deprecated/Engine/Shared/AssemblyLoadInfo.cs
+++ b/src/Deprecated/Engine/Shared/AssemblyLoadInfo.cs
@@ -22,7 +22,7 @@ internal sealed class AssemblyLoadInfo
         /// <param name="assemblyFile"></param>
         public AssemblyLoadInfo(string assemblyName, string assemblyFile)
         {
-            ErrorUtilities.VerifyThrow(((assemblyName != null) && (assemblyName.Length > 0)) || ((assemblyFile != null) && (assemblyFile.Length > 0)),
+            ErrorUtilities.VerifyThrow((!string.IsNullOrEmpty(assemblyName)) || (!string.IsNullOrEmpty(assemblyFile)),
                 "We must have either the assembly name or the assembly file/path.");
             ErrorUtilities.VerifyThrow((assemblyName == null) || (assemblyFile == null),
                 "We must not have both the assembly name and the assembly file/path.");
@@ -115,7 +115,7 @@ public override bool Equals(Object obj)
                 return false;
             }
 
-            return ((this.AssemblyName == otherAssemblyInfo.AssemblyName) && (this.AssemblyFile == otherAssemblyInfo.AssemblyFile));
+            return (this.AssemblyName == otherAssemblyInfo.AssemblyName) && (this.AssemblyFile == otherAssemblyInfo.AssemblyFile);
         }
 
         #endregion
diff --git a/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs b/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
index 2dbf3da4b36..dd92e681f9b 100644
--- a/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
+++ b/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
@@ -123,7 +123,6 @@ internal string Name
             }
         }
 
-
         /// <summary>
         /// The assembly's version number.
         /// </summary>
@@ -226,7 +225,6 @@ internal static AssemblyNameExtension UnnamedAssembly
         /// <returns></returns>
         internal int CompareTo(AssemblyNameExtension that)
         {
-
             // Are they identical?
             if (this.Equals(that))
             {
@@ -397,7 +395,7 @@ internal bool Equals(AssemblyNameExtension that)
             }
 
             // Do the names match?
-            if (0 != String.Compare(Name, that.Name, StringComparison.OrdinalIgnoreCase))
+            if (!String.Equals(Name, that.Name, StringComparison.OrdinalIgnoreCase))
             {
                 return false;
             }
diff --git a/src/Deprecated/Engine/Shared/ConfigurationInSolution.cs b/src/Deprecated/Engine/Shared/ConfigurationInSolution.cs
index 111786115c7..03d78fe93bd 100644
--- a/src/Deprecated/Engine/Shared/ConfigurationInSolution.cs
+++ b/src/Deprecated/Engine/Shared/ConfigurationInSolution.cs
@@ -31,7 +31,7 @@ internal ConfigurationInSolution(string configurationName, string platformName)
             this.platformName = platformName;
 
             // Some configurations don't have the platform part
-            if ((platformName != null) && (platformName.Length > 0))
+            if (!string.IsNullOrEmpty(platformName))
             {
                 this.fullName = string.Format(CultureInfo.InvariantCulture, "{0}{1}{2}", configurationName, configurationPlatformSeparator, platformName);
             }
diff --git a/src/Deprecated/Engine/Shared/ConversionUtilities.cs b/src/Deprecated/Engine/Shared/ConversionUtilities.cs
index 0ea5e8ad182..faa3cc499c3 100644
--- a/src/Deprecated/Engine/Shared/ConversionUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ConversionUtilities.cs
@@ -44,7 +44,7 @@ internal static bool ConvertStringToBool(string parameterValue)
         /// </summary>
         internal static bool CanConvertStringToBool(string parameterValue)
         {
-            return (ValidBooleanTrue(parameterValue) || ValidBooleanFalse(parameterValue));
+            return ValidBooleanTrue(parameterValue) || ValidBooleanFalse(parameterValue);
         }
 
         /// <summary>
@@ -53,12 +53,12 @@ internal static bool CanConvertStringToBool(string parameterValue)
         /// </summary>
         private static bool ValidBooleanTrue(string parameterValue)
         {
-            return ((String.Compare(parameterValue, "true", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "on", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "yes", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "!false", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "!off", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "!no", StringComparison.OrdinalIgnoreCase) == 0));
+            return (String.Equals(parameterValue, "true", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "on", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "yes", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "!false", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "!off", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "!no", StringComparison.OrdinalIgnoreCase));
         }
 
         /// <summary>
@@ -67,12 +67,12 @@ private static bool ValidBooleanTrue(string parameterValue)
         /// </summary>
         private static bool ValidBooleanFalse(string parameterValue)
         {
-            return ((String.Compare(parameterValue, "false", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "off", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "no", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "!true", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "!on", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "!yes", StringComparison.OrdinalIgnoreCase) == 0));
+            return (String.Equals(parameterValue, "false", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "off", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "no", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "!true", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "!on", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "!yes", StringComparison.OrdinalIgnoreCase));
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Shared/EscapingUtilities.cs b/src/Deprecated/Engine/Shared/EscapingUtilities.cs
index 3baf1c1d815..d339c3e0492 100644
--- a/src/Deprecated/Engine/Shared/EscapingUtilities.cs
+++ b/src/Deprecated/Engine/Shared/EscapingUtilities.cs
@@ -16,7 +16,7 @@ static internal class EscapingUtilities
     {
         /// <summary>
         /// Replaces all instances of %XX in the input string with the character represented
-        /// by the hexadecimal number XX. 
+        /// by the hexadecimal number XX.
         /// </summary>
         /// <param name="escapedString"></param>
         /// <returns>unescaped string</returns>
@@ -31,7 +31,7 @@ string escapedString
 
         /// <summary>
         /// Replaces all instances of %XX in the input string with the character represented
-        /// by the hexadecimal number XX. 
+        /// by the hexadecimal number XX.
         /// </summary>
         /// <param name="escapedString"></param>
         /// <param name="escapingWasNecessary"></param>
@@ -53,7 +53,7 @@ out bool escapingWasNecessary
             {
                 return escapedString;
             }
-            
+
             // This is where we're going to build up the final string to return to the caller.
             StringBuilder unescapedString = new StringBuilder();
 
@@ -76,7 +76,7 @@ out bool escapingWasNecessary
 
                     // Convert the %XX to an actual real character.
                     string hexString = escapedString.Substring(indexOfPercent + 1, 2);
-                    char unescapedCharacter = (char) int.Parse(hexString, System.Globalization.NumberStyles.HexNumber, 
+                    char unescapedCharacter = (char) int.Parse(hexString, System.Globalization.NumberStyles.HexNumber,
                         CultureInfo.InvariantCulture);
 
                     // if the unescaped character is not on the exception list, append it
@@ -101,7 +101,7 @@ out bool escapingWasNecessary
         }
 
         /// <summary>
-        /// Adds instances of %XX in the input string where the char char to be escaped appears
+        /// Adds instances of %XX in the input string where the char to be escaped appears
         /// XX is the hex value of the ASCII code for the char.
         /// </summary>
         /// <param name="unescapedString"></param>
@@ -147,7 +147,7 @@ private static bool ContainsReservedCharacters
             string unescapedString
             )
         {
-            return (-1 != unescapedString.IndexOfAny(charsToEscape));
+            return -1 != unescapedString.IndexOfAny(charsToEscape);
         }
 
         /// <summary>
@@ -170,13 +170,13 @@ string escapedString
                     )
                 {
                     // It has either a '%2' or a '%3'.  This is looking very promising.
-                    return 
-                        (
+                    return
+
                             (-1 != escapedString.IndexOf("%2a", StringComparison.Ordinal)) ||
                             (-1 != escapedString.IndexOf("%2A", StringComparison.Ordinal)) ||
                             (-1 != escapedString.IndexOf("%3f", StringComparison.Ordinal)) ||
                             (-1 != escapedString.IndexOf("%3F", StringComparison.Ordinal))
-                        );
+                        ;
                 }
             }
             return false;
@@ -184,9 +184,9 @@ string escapedString
 
         /// <summary>
         /// Special characters that need escaping.
-        /// It's VERY important that the percent character is the FIRST on the list - since it's both a character 
-        /// we escape and use in escape sequences, we can unintentionally escape other escape sequences if we 
-        /// don't process it first. Of course we'll have a similar problem if we ever decide to escape hex digits 
+        /// It's VERY important that the percent character is the FIRST on the list - since it's both a character
+        /// we escape and use in escape sequences, we can unintentionally escape other escape sequences if we
+        /// don't process it first. Of course we'll have a similar problem if we ever decide to escape hex digits
         /// (that would require rewriting the algorithm) but since it seems unlikely that we ever do, this should
         /// be good enough to avoid complicating the algorithm at this point.
         /// </summary>
diff --git a/src/Deprecated/Engine/Shared/EventArgsFormatting.cs b/src/Deprecated/Engine/Shared/EventArgsFormatting.cs
index 4a86b11903b..9a9623e2303 100644
--- a/src/Deprecated/Engine/Shared/EventArgsFormatting.cs
+++ b/src/Deprecated/Engine/Shared/EventArgsFormatting.cs
@@ -51,7 +51,7 @@ internal static string FormatEventMessage(BuildErrorEventArgs e)
         /// <returns>The formatted message string.</returns>
         internal static string FormatEventMessage(BuildErrorEventArgs e, bool removeCarriageReturn)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
             // "error" should not be localized
             return FormatEventMessage("error", e.Subcategory, removeCarriageReturn ? EscapeCarriageReturn(e.Message) : e.Message,
@@ -80,7 +80,7 @@ internal static string FormatEventMessage(BuildWarningEventArgs e)
         /// <returns>The formatted message string.</returns>
         internal static string FormatEventMessage(BuildWarningEventArgs e, bool removeCarriageReturn)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
             // "warning" should not be localized
             return FormatEventMessage("warning", e.Subcategory, removeCarriageReturn ? EscapeCarriageReturn(e.Message) : e.Message,
@@ -129,7 +129,7 @@ int threadId
             }
             */
 
-            if ((file == null) || (file.Length == 0))
+            if (string.IsNullOrEmpty(file))
             {
                 format.Append("MSBUILD : ");    // Should not be localized.
             }
@@ -182,7 +182,7 @@ int threadId
                 }
             }
 
-            if ((subcategory != null) && (subcategory.Length != 0))
+            if (!string.IsNullOrEmpty(subcategory))
             {
                 format.Append("{9} ");
             }
@@ -207,7 +207,7 @@ int threadId
             }
 
             // A null message is allowed and is to be treated as a blank line.
-            if (null == message)
+            if (message == null)
             {
                 message = String.Empty;
             }
@@ -220,12 +220,12 @@ int threadId
 
             for (int i = 0; i < lines.Length; i++)
             {
-                formattedMessage.Append(String.Format(
+                formattedMessage.AppendFormat(
                         CultureInfo.CurrentCulture, finalFormat,
                         threadId, file,
                         lineNumber, columnNumber, category, code,
                         lines[i], endLineNumber, endColumnNumber,
-                        subcategory));
+                        subcategory);
 
                 if (i < (lines.Length - 1))
                 {
@@ -236,7 +236,6 @@ int threadId
             return formattedMessage.ToString();
         }
 
-
         /// <summary>
         /// Splits strings on 'newLines' with tolerance for Everett and Dogfood builds.
         /// </summary>
diff --git a/src/Deprecated/Engine/Shared/FileMatcher.cs b/src/Deprecated/Engine/Shared/FileMatcher.cs
index 14872e95a16..26ef4635b3e 100644
--- a/src/Deprecated/Engine/Shared/FileMatcher.cs
+++ b/src/Deprecated/Engine/Shared/FileMatcher.cs
@@ -56,7 +56,6 @@ internal enum FileSystemEntity
         /// <returns>True if the directory exists.</returns>
         internal delegate bool DirectoryExists(string path);
 
-
         /// <summary>
         /// Determines whether the given path has any wild card characters.
         /// </summary>
@@ -253,7 +252,6 @@ internal static string GetLongPathName
             GetFileSystemEntries getFileSystemEntries
         )
         {
-
             if (path.IndexOf("~", StringComparison.Ordinal) == -1)
             {
                 // A path with no '~' must not be a short name.
@@ -265,9 +263,8 @@ GetFileSystemEntries getFileSystemEntries
 
             string[] parts = path.Split(directorySeparatorCharacters);
             string pathRoot;
-            int startingElement=0;
-
             bool isUnc = path.StartsWith(directorySeparator + directorySeparator, StringComparison.Ordinal);
+            int startingElement;
             if (isUnc)
             {
                 pathRoot = directorySeparator + directorySeparator;
@@ -280,7 +277,7 @@ GetFileSystemEntries getFileSystemEntries
             else
             {
                 // Is it relative?
-                if (path.Length>2 && path[1] == ':')
+                if (path.Length > 2 && path[1] == ':')
                 {
                     // Not relative
                     pathRoot = parts[0] + directorySeparator;
@@ -308,7 +305,6 @@ GetFileSystemEntries getFileSystemEntries
                 }
                 else
                 {
-
                     if (parts[i].IndexOf("~", StringComparison.Ordinal) == -1)
                     {
                         // If there's no ~, don't hit the disk.
@@ -514,7 +510,7 @@ string[] paths
         /// <returns></returns>
         internal static bool IsDirectorySeparator(char c)
         {
-            return (c == Path.DirectorySeparatorChar || c == Path.AltDirectorySeparatorChar);
+            return c == Path.DirectorySeparatorChar || c == Path.AltDirectorySeparatorChar;
         }
         /// <summary>
         /// Removes the current directory converting the file back to relative path 
@@ -841,7 +837,6 @@ out bool isLegalFileSpec
 
             } while (matchFileExpression.Length < sizeBefore);
 
-
             /*
              * By definition, "**" must appear alone between directory slashes. If there is any remaining "**" then this is not
              * a valid filespec.
@@ -902,8 +897,6 @@ out bool isLegalFileSpec
             return matchFileExpression.ToString();
         }
 
-
-
         /// <summary>
         /// Given a filespec, get the information needed for file matching. 
         /// </summary>
@@ -1249,8 +1242,7 @@ DirectoryExists directoryExists
             // 2) if the extension is three characters, and the filename contains the * wildcard, it matches files with longer
             //    extensions that start with the same three characters e.g. "*.htm" would match both "file.htm" and "file.html"
             bool needToEnforceExtensionLength =
-                    (extensionPart != null) &&
-                    (extensionPart.IndexOf('*') == -1)
+                    (extensionPart?.IndexOf('*') == -1)
                 &&
                     (extensionPart.EndsWith("?", StringComparison.Ordinal)
                 ||
@@ -1262,9 +1254,9 @@ DirectoryExists directoryExists
              */
             GetFilesRecursive(listOfFiles, fixedDirectoryPart, wildcardDirectoryPart,
                 // if using the regular expression, ignore the file pattern
-                (matchWithRegex ? null : filenamePart), (needToEnforceExtensionLength ? extensionPart.Length : 0),
+                matchWithRegex ? null : filenamePart, needToEnforceExtensionLength ? extensionPart.Length : 0,
                 // if using the file pattern, ignore the regular expression
-                (matchWithRegex ? new Regex(matchFileExpression, RegexOptions.IgnoreCase) : null),
+                matchWithRegex ? new Regex(matchFileExpression, RegexOptions.IgnoreCase) : null,
                 needsRecursion, projectDirectory, stripProjectDirectory, getFileSystemEntries);
 
             /*
diff --git a/src/Deprecated/Engine/Shared/FileUtilities.cs b/src/Deprecated/Engine/Shared/FileUtilities.cs
index 82ff1e65b26..b85a2471b52 100644
--- a/src/Deprecated/Engine/Shared/FileUtilities.cs
+++ b/src/Deprecated/Engine/Shared/FileUtilities.cs
@@ -12,7 +12,6 @@
 using System.Threading;
 using System.Runtime.InteropServices;
 
-
 namespace Microsoft.Build.BuildEngine.Shared
 {
     /// <summary>
@@ -97,7 +96,6 @@ internal static bool IsItemSpecModifier(string name)
                 return false;
             }
 
-
             /* 
              * What follows requires some explanation.
              * 
@@ -333,7 +331,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
 
                 try
                 {
-                    if (String.Compare(modifier, ItemSpecModifiers.FullPath, StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(modifier, ItemSpecModifiers.FullPath, StringComparison.OrdinalIgnoreCase))
                     {
                         if(currentDirectory == null)
                         {
@@ -342,7 +340,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
 
                         modifiedItemSpec = GetFullPath(itemSpec, currentDirectory);
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.RootDir, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.RootDir, StringComparison.OrdinalIgnoreCase))
                     {
                         if (currentDirectory == null)
                         {
@@ -362,7 +360,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec += Path.DirectorySeparatorChar;
                         }
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.Filename, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.Filename, StringComparison.OrdinalIgnoreCase))
                     {
                         // if the item-spec is a root directory, it can have no filename
                         if (Path.GetDirectoryName(itemSpec) == null)
@@ -376,7 +374,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec = Path.GetFileNameWithoutExtension(itemSpec);
                         }
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.Extension, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.Extension, StringComparison.OrdinalIgnoreCase))
                     {
                         // if the item-spec is a root directory, it can have no extension
                         if (Path.GetDirectoryName(itemSpec) == null)
@@ -390,11 +388,11 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec = Path.GetExtension(itemSpec);
                         }
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.RelativeDir, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.RelativeDir, StringComparison.OrdinalIgnoreCase))
                     {
                         modifiedItemSpec = GetDirectory(itemSpec);
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.Directory, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.Directory, StringComparison.OrdinalIgnoreCase))
                     {
                         if (currentDirectory == null)
                         {
@@ -417,16 +415,16 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec = modifiedItemSpec.Substring(root.Length + 1);
                         }
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.RecursiveDir, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.RecursiveDir, StringComparison.OrdinalIgnoreCase))
                     {
                         // only the BuildItem class can compute this modifier -- so leave empty
                         modifiedItemSpec = String.Empty;
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.Identity, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.Identity, StringComparison.OrdinalIgnoreCase))
                     {
                         modifiedItemSpec = itemSpec;
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.ModifiedTime, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.ModifiedTime, StringComparison.OrdinalIgnoreCase))
                     {
                         isVolatile = true;
 
@@ -446,7 +444,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec = String.Empty;
                         }
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.CreatedTime, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.CreatedTime, StringComparison.OrdinalIgnoreCase))
                     {
                         isVolatile = true;
 
@@ -464,7 +462,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec = String.Empty;
                         }
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.AccessedTime, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.AccessedTime, StringComparison.OrdinalIgnoreCase))
                     {
                         isVolatile = true;
 
@@ -578,7 +576,7 @@ internal static bool EndsWithSlash(string fileSpec)
         /// <returns>true, if slash</returns>
         internal static bool IsSlash(char c)
         {
-            return ((c == Path.DirectorySeparatorChar) || (c == Path.AltDirectorySeparatorChar));
+            return (c == Path.DirectorySeparatorChar) || (c == Path.AltDirectorySeparatorChar);
         }
 
         /// <summary>
@@ -776,7 +774,7 @@ internal static string GetCurrentDirectoryStaticBuffer(StringBuilder buffer)
         /// </summary>
         internal static bool IsVCProjFilename(string filename)
         {
-            return (String.Equals(Path.GetExtension(filename), ".vcproj", StringComparison.OrdinalIgnoreCase));
+            return String.Equals(Path.GetExtension(filename), ".vcproj", StringComparison.OrdinalIgnoreCase);
         }
 
         /// <summary>
@@ -795,8 +793,8 @@ internal static bool IsVCProjFilename(string filename)
         /// <returns>relative path (can be the full path)</returns>
         internal static string MakeRelative(string basePath, string path)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(basePath, "basePath");
-            ErrorUtilities.VerifyThrowArgumentLength(path, "path");
+            ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));
+            ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));
 
             if (basePath.Length == 0)
             {
@@ -828,9 +826,9 @@ internal static string MakeRelative(string basePath, string path)
         /// <returns>uri object</returns>
         private static Uri CreateUriFromPath(string path)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(path, "path");
+            ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));
 
-            Uri pathUri = null;
+            Uri pathUri;
 
             // Try absolute first, then fall back on relative, otherwise it
             // makes some absolute UNC paths like (\\foo\bar) relative ...
diff --git a/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs b/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
index 44491ff72c4..156bc7a8437 100644
--- a/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
+++ b/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
@@ -64,7 +64,6 @@ internal static class FrameworkLocationHelper
         internal const string fullDotNetFrameworkSdkRegistryKeyV40 = "HKEY_LOCAL_MACHINE\\" + dotNetFrameworkSdkRegistryPathV40;
         internal const string dotNetFrameworkSdkInstallKeyValueV40 = "InstallationFolder";
 
-
         private const string dotNetFrameworkAssemblyFoldersRegistryKeyV40 = dotNetFrameworkAssemblyFoldersRegistryPath + "\\" + dotNetFrameworkVersionFolderPrefixV40;
         private const string secondaryDotNetFrameworkSdkRegistryPathV40 = "SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows";
         internal const string secondaryDotNetFrameworkSdkInstallKeyValueV40 = "CurrentInstallFolder";
@@ -85,7 +84,6 @@ internal static string PathToDotNetFrameworkV11
                     }
                     else
                     {
-
                         FrameworkLocationHelper.pathToDotNetFrameworkV11 =
                             FindDotNetFrameworkPath(
                                 Path.GetDirectoryName(typeof(object).Module.FullyQualifiedName),
@@ -113,7 +111,6 @@ internal static string PathToDotNetFrameworkV20
                     }
                     else
                     {
-
                         FrameworkLocationHelper.pathToDotNetFrameworkV20 =
                             FindDotNetFrameworkPath(
                                 Path.GetDirectoryName(typeof(object).Module.FullyQualifiedName),
@@ -141,7 +138,6 @@ internal static string PathToDotNetFrameworkV30
                     }
                     else
                     {
-
                         FrameworkLocationHelper.pathToDotNetFrameworkV30 =
                             FindDotNetFrameworkPath(
                                 Path.GetDirectoryName(typeof(object).Module.FullyQualifiedName),
@@ -269,7 +265,6 @@ internal static string PathToDotNetFrameworkSdkV35
                             secondaryDotNetFrameworkSdkRegistryPathV35,
                             secondaryDotNetFrameworkSdkInstallKeyValueV35);
                     }
-
                 }
 
                 return FrameworkLocationHelper.pathToDotNetFrameworkSdkV35;
@@ -302,7 +297,6 @@ internal static string PathToDotNetFrameworkSdkV40
                             secondaryDotNetFrameworkSdkRegistryPathV40,
                             secondaryDotNetFrameworkSdkInstallKeyValueV40);
                     }
-
                 }
 
                 return FrameworkLocationHelper.pathToDotNetFrameworkSdkV40;
@@ -347,7 +341,6 @@ internal static string PathToDotNetFrameworkReferenceAssembliesV35
                     {
                         FrameworkLocationHelper.pathToDotNetFrameworkReferenceAssembliesV35 = GenerateReferenceAssemblyDirectory(dotNetFrameworkVersionFolderPrefixV35);
                     }
-
                 }
 
                 return FrameworkLocationHelper.pathToDotNetFrameworkReferenceAssembliesV35;
@@ -432,27 +425,23 @@ private static string FindRegistryValueUnderKey
             string registryKeyName
         )
         {
-            string keyValueAsString = String.Empty;
-
             Microsoft.Win32.RegistryKey baseKey = Microsoft.Win32.Registry
                 .LocalMachine
                 .OpenSubKey(registryBaseKeyName);
 
-            if (null == baseKey)
+            if (baseKey == null)
             {
                 return null;
             }
 
             object keyValue = baseKey.GetValue(registryKeyName);
 
-            if (null == keyValue)
+            if (keyValue == null)
             {
                 return null;
             }
 
-            keyValueAsString = keyValue.ToString();
-
-            return keyValueAsString;
+            return keyValue.ToString();
         }
 
         /// <summary>
@@ -472,7 +461,7 @@ internal static bool CheckForFrameworkInstallation(string registryEntryToCheckIn
             if (String.IsNullOrEmpty(complusInstallRoot) && String.IsNullOrEmpty(complusVersion))
             {
                 // If the registry entry is 1 then the framework is installed. Go ahead and find the directory. If it is not 1 then the framework is not installed, return null.
-                return String.Compare("1", FindRegistryValueUnderKey(registryEntryToCheckInstall, registryValueToCheckInstall), StringComparison.OrdinalIgnoreCase) == 0;
+                return String.Equals("1", FindRegistryValueUnderKey(registryEntryToCheckInstall, registryValueToCheckInstall), StringComparison.OrdinalIgnoreCase);
             }
 
             return true;
@@ -524,7 +513,7 @@ GetDirectories getDirectories
             // This was removed in beta2
             // We should favor \v3.5 over \v3.5.xxxxx
             // versions previous to 2.0 have .xxxx version numbers.  3.0 and 3.5 do not.
-            if (max.EndsWith(prefix, StringComparison.OrdinalIgnoreCase) != true )
+            if (!max.EndsWith(prefix, StringComparison.OrdinalIgnoreCase))
             {
                 for (int i = 1; i < directories.Length; ++i)
                 {
diff --git a/src/Deprecated/Engine/Shared/LoadedType.cs b/src/Deprecated/Engine/Shared/LoadedType.cs
index 47ec35d0174..6cbb2758453 100644
--- a/src/Deprecated/Engine/Shared/LoadedType.cs
+++ b/src/Deprecated/Engine/Shared/LoadedType.cs
@@ -205,6 +205,5 @@ internal AssemblyLoadInfo Assembly
 
         // whether the loadinseparateappdomain attribute is applied to this type
         private bool? hasLoadInSeparateAppDomainAttribute;
-
     }
 }
diff --git a/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs b/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs
index ee6cb1b6727..e443b6f188c 100644
--- a/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs
+++ b/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs
@@ -50,7 +50,7 @@ internal bool IncludeInBuild
         /// <owner>LukaszG</owner>
         static private string RemoveSpaceFromAnyCpuPlatform(string platformName)
         {
-            if (string.Compare(platformName, "Any CPU", StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(platformName, "Any CPU", StringComparison.OrdinalIgnoreCase))
                 return "AnyCPU";
 
             return platformName;
diff --git a/src/Deprecated/Engine/Shared/ProjectInSolution.cs b/src/Deprecated/Engine/Shared/ProjectInSolution.cs
index 0c720f90641..c3cf27ccd70 100644
--- a/src/Deprecated/Engine/Shared/ProjectInSolution.cs
+++ b/src/Deprecated/Engine/Shared/ProjectInSolution.cs
@@ -249,9 +249,9 @@ internal bool CanBeMSBuildProjectFile(out string errorMessage)
                     }
                 }
 
-                if (mainProjectElement != null && mainProjectElement.LocalName == "Project")
+                if (mainProjectElement?.LocalName == "Project")
                 {
-                    if (String.Compare(mainProjectElement.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(mainProjectElement.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase))
                     {
                         canBeMSBuildProjectFile = true;
                         return canBeMSBuildProjectFile;
@@ -374,7 +374,7 @@ static internal string DisambiguateProjectTargetName(string uniqueProjectName)
             // entry point targets
             foreach (string projectName in projectNamesToDisambiguate)
             {
-                if (String.Compare(uniqueProjectName, projectName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(uniqueProjectName, projectName, StringComparison.OrdinalIgnoreCase))
                 {
                     // Prepend "Solution:" so that the collision is resolved, but the
                     // log of the solution project still looks reasonable.
diff --git a/src/Deprecated/Engine/Shared/ResourceUtilities.cs b/src/Deprecated/Engine/Shared/ResourceUtilities.cs
index 89cb88cf8b2..d6443759b87 100644
--- a/src/Deprecated/Engine/Shared/ResourceUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ResourceUtilities.cs
@@ -60,7 +60,7 @@ internal static string ExtractMessageCode(Regex messageCodePattern, string messa
         /// <returns>The MSBuild F1-help keyword string.</returns>
         private static string GetHelpKeyword(string resourceName)
         {
-            return ("MSBuild." + resourceName);
+            return "MSBuild." + resourceName;
         }
 
         /// <summary>
@@ -121,7 +121,7 @@ internal static string FormatString(string unformatted, params object[] args)
             string formatted = unformatted;
 
             // NOTE: String.Format() does not allow a null arguments array
-            if ((args != null) && (args.Length > 0))
+            if ((args?.Length > 0))
             {
 #if DEBUG
 
diff --git a/src/Deprecated/Engine/Shared/SolutionParser.cs b/src/Deprecated/Engine/Shared/SolutionParser.cs
index 0bb83616e54..7790ff7d26e 100644
--- a/src/Deprecated/Engine/Shared/SolutionParser.cs
+++ b/src/Deprecated/Engine/Shared/SolutionParser.cs
@@ -312,7 +312,7 @@ private string ReadLine()
         /// <owner>RGoel</owner>
         internal void ParseSolutionFile()
         {
-            error.VerifyThrow((solutionFile != null) && (solutionFile.Length != 0), "ParseSolutionFile() got a null solution file!");
+            error.VerifyThrow(!string.IsNullOrEmpty(solutionFile), "ParseSolutionFile() got a null solution file!");
 
             FileStream fileStream = null;
             reader = null;
@@ -328,15 +328,9 @@ internal void ParseSolutionFile()
             }
             finally
             {
-                if (fileStream != null)
-                {
-                    fileStream.Close();
-                }
+                fileStream?.Close();
 
-                if (reader != null)
-                {
-                    reader.Close();
-                }
+                reader?.Close();
             }
         }
 
@@ -412,7 +406,6 @@ internal void ParseSolution()
                 // Update the hash table with this unique name
                 projectsByUniqueName[uniqueName] = proj;
             }
-
         } // ParseSolutionFile()
 
         /// <summary>
@@ -501,7 +494,6 @@ private void ValidateSolutionFileVersion(string versionString)
                 "SolutionParseVersionMismatchError", 
                 slnFileMinUpgradableVersion, slnFileMaxVersion);
 
-
             // If the solution file version is greater than the maximum one we will create a comment rather than warn
             // as users such as blend opening a dev10 project cannot do anything about it.
             if (this.slnFileActualVersion > slnFileMaxVersion)
@@ -531,7 +523,7 @@ private void ValidateSolutionFileVersion(string versionString)
         /// <owner>RGoel</owner>
         private void ParseProject(string firstLine)
         {
-            error.VerifyThrow((firstLine != null) && (firstLine.Length != 0), "ParseProject() got a null firstLine!");
+            error.VerifyThrow(!string.IsNullOrEmpty(firstLine), "ParseProject() got a null firstLine!");
             error.VerifyThrow(reader != null, "ParseProject() got a null reader!");
 
             ProjectInSolution proj = new ProjectInSolution(this);
@@ -555,7 +547,7 @@ private void ParseProject(string firstLine)
                     // We have a ProjectDependencies section.  Each subsequent line should identify
                     // a dependency.
                     line = ReadLine();
-                    while ((line != null) && (!line.StartsWith("EndProjectSection", StringComparison.Ordinal)))
+                    while ((line?.StartsWith("EndProjectSection", StringComparison.Ordinal) == false))
                     {
                         // This should be a dependency.  The GUID identifying the parent project should
                         // be both the property name and the property value.
@@ -575,7 +567,7 @@ private void ParseProject(string firstLine)
                     // projects, and contains properties that we'll need in order to call the 
                     // AspNetCompiler task.
                     line = ReadLine();
-                    while ((line != null) && (!line.StartsWith("EndProjectSection", StringComparison.Ordinal)))
+                    while ((line?.StartsWith("EndProjectSection", StringComparison.Ordinal) == false))
                     {
                         Match match = crackPropertyLine.Match(line);
                         ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(match.Success, "SubCategoryForSolutionParsingErrors",
@@ -942,7 +934,7 @@ string propertyValue
             else
             {
                 // ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;" 
-                if (string.Compare(propertyName, "ProjectReferences", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(propertyName, "ProjectReferences", StringComparison.OrdinalIgnoreCase))
                 {
                     string[] projectReferenceEntries = propertyValue.Split(new char[] { ';' });
 
@@ -984,7 +976,7 @@ string property
             )
         {
             // If the incoming string starts and ends with a double-quote, strip the double-quotes.
-            if ((property != null) && (property.Length > 0) && (property[0] == '"') && (property[property.Length - 1] == '"'))
+            if (!string.IsNullOrEmpty(property) && (property[0] == '"') && (property[property.Length - 1] == '"'))
             {
                 return property.Substring(1, property.Length - 2);
             }
@@ -1022,21 +1014,21 @@ ProjectInSolution proj
             ValidateProjectRelativePath(proj);
             
             // Figure out what type of project this is.
-            if ((String.Compare(projectTypeGuid, vbProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, csProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, vjProjectGuid, StringComparison.OrdinalIgnoreCase) == 0))
+            if ((String.Equals(projectTypeGuid, vbProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, csProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, vjProjectGuid, StringComparison.OrdinalIgnoreCase)))
             {
                 proj.ProjectType = SolutionProjectType.ManagedProject;
             }
-            else if (String.Compare(projectTypeGuid, solutionFolderGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, solutionFolderGuid, StringComparison.OrdinalIgnoreCase))
             {
                 proj.ProjectType = SolutionProjectType.SolutionFolder;
             }
-            else if (String.Compare(projectTypeGuid, vcProjectGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, vcProjectGuid, StringComparison.OrdinalIgnoreCase))
             {
                 proj.ProjectType = SolutionProjectType.VCProject;
             }
-            else if (String.Compare(projectTypeGuid, webProjectGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, webProjectGuid, StringComparison.OrdinalIgnoreCase))
             {
                 proj.ProjectType = SolutionProjectType.WebProject;
                 solutionContainsWebProjects = true;
@@ -1116,7 +1108,7 @@ internal void ParseSolutionConfigurations()
                 string fullConfigurationName = configurationNames[0].Trim();
 
                 //Fixing bug 555577: Solution file can have description information, in which case we ignore.
-                if (0 == String.Compare(fullConfigurationName, "DESCRIPTION", StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(fullConfigurationName, "DESCRIPTION", StringComparison.OrdinalIgnoreCase))
                     continue;
 
                 // Both names must be identical
@@ -1258,7 +1250,7 @@ internal string GetDefaultConfigurationName()
             // Pick the Debug configuration as default if present
             foreach (ConfigurationInSolution solutionConfiguration in this.SolutionConfigurations)
             {
-                if (string.Compare(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase))
                 {
                     defaultConfigurationName = solutionConfiguration.ConfigurationName;
                     break;
@@ -1293,7 +1285,7 @@ internal string GetDefaultPlatformName()
             // Pick the Mixed Platforms platform as default if present
             foreach (ConfigurationInSolution solutionConfiguration in this.SolutionConfigurations)
             {
-                if (string.Compare(solutionConfiguration.PlatformName, "Mixed Platforms", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(solutionConfiguration.PlatformName, "Mixed Platforms", StringComparison.OrdinalIgnoreCase))
                 {
                     defaultPlatformName = solutionConfiguration.PlatformName;
                     break;
@@ -1319,7 +1311,7 @@ internal string GetDefaultPlatformName()
         internal string GetProjectUniqueNameByGuid(string projectGuid)
         {
             ProjectInSolution proj = (ProjectInSolution) projects[projectGuid];
-            return (proj == null) ? null : proj.GetUniqueProjectName();
+            return proj?.GetUniqueProjectName();
         }
 
         /// <summary>
@@ -1332,10 +1324,9 @@ internal string GetProjectUniqueNameByGuid(string projectGuid)
         internal string GetProjectRelativePathByGuid(string projectGuid)
         {
             ProjectInSolution proj = (ProjectInSolution) projects[projectGuid];
-            return (proj == null) ? null : proj.RelativePath;
+            return proj?.RelativePath;
         }
 
         #endregion
     } // class SolutionParser
-
 } // namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Shared/TypeLoader.cs b/src/Deprecated/Engine/Shared/TypeLoader.cs
index 9485f1065c1..85c3e281e2e 100644
--- a/src/Deprecated/Engine/Shared/TypeLoader.cs
+++ b/src/Deprecated/Engine/Shared/TypeLoader.cs
@@ -52,7 +52,7 @@ AssemblyLoadInfo assembly
 
             // Maybe we've already cracked open this assembly before.  If so, just grab the list
             // of public desired types that we found last time.
-            List<Type> desiredTypesInAssembly = null;
+            List<Type> desiredTypesInAssembly;
             cacheOfAllDesiredTypesInAnAssembly.TryGetValue(assembly, out desiredTypesInAssembly);
 
             // If we have the assembly name (strong or weak), and we haven't cracked this assembly open
@@ -224,7 +224,7 @@ internal static bool IsPartialTypeNameMatch(string typeName1, string typeName2)
             // check if the type names match exactly
             else
             {
-                isPartialMatch = (String.Compare(typeName1, typeName2, StringComparison.OrdinalIgnoreCase) == 0);
+                isPartialMatch = (String.Equals(typeName1, typeName2, StringComparison.OrdinalIgnoreCase));
             }
 
             return isPartialMatch;
diff --git a/src/Deprecated/Engine/Shared/XMakeAttributes.cs b/src/Deprecated/Engine/Shared/XMakeAttributes.cs
index 128ee5b03bb..7ca23215793 100644
--- a/src/Deprecated/Engine/Shared/XMakeAttributes.cs
+++ b/src/Deprecated/Engine/Shared/XMakeAttributes.cs
@@ -75,12 +75,11 @@ string attribute
             //  Condition, ContinueOnError
             //
             // We want to match case-sensitively on all of them
-            return ((attribute == condition) ||
+            return (attribute == condition) ||
                     (attribute == continueOnError) ||
                     (attribute == msbuildRuntime) ||
                     (attribute == msbuildArchitecture) ||
-                    (attribute == xmlns));
-
+                    (attribute == xmlns);
         }
 
         /// <summary>
@@ -91,11 +90,11 @@ string attribute
         /// <returns>true, if the given attribute is reserved and badly cased</returns>
         internal static bool IsBadlyCasedSpecialTaskAttribute(string attribute)
         {
-            return (!IsSpecialTaskAttribute(attribute) &&
-                ((String.Compare(attribute, condition, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(attribute, continueOnError, StringComparison.OrdinalIgnoreCase) == 0) || 
-                (String.Compare(attribute, msbuildRuntime, StringComparison.OrdinalIgnoreCase) == 0) || 
-                (String.Compare(attribute, msbuildArchitecture, StringComparison.OrdinalIgnoreCase) == 0)));
+            return !IsSpecialTaskAttribute(attribute) &&
+                ((String.Equals(attribute, condition, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(attribute, continueOnError, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(attribute, msbuildRuntime, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(attribute, msbuildArchitecture, StringComparison.OrdinalIgnoreCase)));
         }
 
         /// <summary>
@@ -106,9 +105,9 @@ internal static bool IsBadlyCasedSpecialTaskAttribute(string attribute)
         /// <returns>true, if a target cannot batch on the given attribute</returns>
         internal static bool IsNonBatchingTargetAttribute(string attribute)
         {
-            return ((attribute == name) ||
+            return (attribute == name) ||
                     (attribute == condition) ||
-                    (attribute == dependsOnTargets));
+                    (attribute == dependsOnTargets);
         }
     }
 }
diff --git a/src/Deprecated/Engine/Shared/XMakeElements.cs b/src/Deprecated/Engine/Shared/XMakeElements.cs
index 23040d39c4e..73705f027a6 100644
--- a/src/Deprecated/Engine/Shared/XMakeElements.cs
+++ b/src/Deprecated/Engine/Shared/XMakeElements.cs
@@ -44,9 +44,9 @@ internal static class XMakeElements
         /// <returns>true, if specified node can be a child of a task element</returns>
         internal static bool IsValidTaskChildNode(XmlNode childNode)
         {
-            return ((childNode.Name == output) ||
+            return (childNode.Name == output) ||
                     (childNode.NodeType == XmlNodeType.Comment) ||
-                    (childNode.NodeType == XmlNodeType.Whitespace));
+                    (childNode.NodeType == XmlNodeType.Whitespace);
         }
 
         internal static readonly char[] illegalTargetNameCharacters = new char[] { '$', '@', '(', ')', '%', '*', '?', '.' };
@@ -97,5 +97,4 @@ internal static Hashtable IllegalItemPropertyNames
             }
         }
     }
-
 }
diff --git a/src/Deprecated/Engine/Shared/XmlUtilities.cs b/src/Deprecated/Engine/Shared/XmlUtilities.cs
index b9921bfee35..e16d9685062 100644
--- a/src/Deprecated/Engine/Shared/XmlUtilities.cs
+++ b/src/Deprecated/Engine/Shared/XmlUtilities.cs
@@ -44,11 +44,11 @@ internal static XmlElement RenameXmlElement(XmlElement oldElement, string newEle
                 newElement.AppendChild(newChildNode);
             }
 
-            if (oldElement.ParentNode != null)
-            {
+               
+            
                 // Add the new element in the same place the old element was.
-                oldElement.ParentNode.ReplaceChild(newElement, oldElement);
-            }
+                oldElement.ParentNode?.ReplaceChild(newElement, oldElement);
+            
 
             return newElement;
         }
@@ -69,7 +69,7 @@ internal static string GetXmlNodeFile(XmlNode node, string defaultFile)
             string file = defaultFile;
 
             // NOTE: the XML node may not have a filename if it's purely an in-memory node
-            if ((node.OwnerDocument.BaseURI != null) && (node.OwnerDocument.BaseURI.Length > 0))
+            if (!string.IsNullOrEmpty(node.OwnerDocument.BaseURI))
             {
                 file = new Uri(node.OwnerDocument.BaseURI).LocalPath;
             }
@@ -89,13 +89,13 @@ internal static bool IsXmlRootElement(XmlNode node)
         {
             // "A Document node can have the following child node types: XmlDeclaration,
             // Element (maximum of one), ProcessingInstruction, Comment, and DocumentType."
-            return (
+            return
                    (node.NodeType != XmlNodeType.Comment) &&
                    (node.NodeType != XmlNodeType.Whitespace) &&
                    (node.NodeType != XmlNodeType.XmlDeclaration) &&
                    (node.NodeType != XmlNodeType.ProcessingInstruction) &&
                    (node.NodeType != XmlNodeType.DocumentType)
-                   );
+                   ;
         }
 
         /// <summary>
@@ -147,7 +147,7 @@ internal static void VerifyThrowProjectValidElementName(XmlElement element)
         /// <returns>true, if name is valid</returns>
         internal static bool IsValidElementName(string name)
         {
-            return (LocateFirstInvalidElementNameCharacter(name) == -1);
+            return LocateFirstInvalidElementNameCharacter(name) == -1;
         }
 
         /// <summary>
@@ -211,14 +211,14 @@ string attributeName
                     {
                         if (xmlReader.NodeType == XmlNodeType.Element)
                         {
-                            if (String.Compare(xmlReader.Name, elementName, StringComparison.OrdinalIgnoreCase) == 0)
+                            if (String.Equals(xmlReader.Name, elementName, StringComparison.OrdinalIgnoreCase))
                             {
                                 if (xmlReader.HasAttributes)
                                 {
                                     for (int i = 0; i < xmlReader.AttributeCount; i++)
                                     {
                                         xmlReader.MoveToAttribute(i);
-                                        if (String.Compare(xmlReader.Name, attributeName, StringComparison.OrdinalIgnoreCase) == 0)
+                                        if (String.Equals(xmlReader.Name, attributeName, StringComparison.OrdinalIgnoreCase))
                                         {
                                             attributeValue = xmlReader.Value;
                                             break;
diff --git a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
index abf63f9efc6..74dae80d970 100644
--- a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
@@ -30,7 +30,7 @@ static public class SolutionWrapperProject
 
         /// <summary>
         /// Given the full path to a solution, returns a string containing the v3.5 MSBuild-format
-        /// wrapper project for that solution.  
+        /// wrapper project for that solution.
         /// </summary>
         /// <param name="solutionPath">Full path to the solution we are wrapping</param>
         /// <param name="toolsVersionOverride">May be null.  If non-null, contains the ToolsVersion passed in on the command line</param>\
@@ -55,14 +55,14 @@ static public string Generate(string solutionPath, string toolsVersionOverride,
         /// </summary>
         /// <param name="solution"></param>
         /// <param name="msbuildProject"></param>
-        /// <param name="toolsVersionOverride">Tools Version override (may be null). 
+        /// <param name="toolsVersionOverride">Tools Version override (may be null).
         /// Any /tv:xxx switch would cause a value here.</param>
         /// <returns></returns>
         /// <owner>RGoel</owner>
         static internal void Generate(SolutionParser solution, Project msbuildProject, string toolsVersionOverride, BuildEventContext projectBuildEventContext)
         {
             // Validate against our minimum for upgradable projects
-            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile((solution.Version >= SolutionParser.slnFileMinVersion),
+            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(solution.Version >= SolutionParser.slnFileMinVersion,
                 "SubCategoryForSolutionParsingErrors", new BuildEventFileInfo(solution.SolutionFile), "SolutionParseUpgradeNeeded");
 
             // Although we only return an XmlDocument back, we need to make decisions about tools versions because
@@ -104,7 +104,6 @@ static internal void Generate(SolutionParser solution, Project msbuildProject, s
 
             // Write a new cache file, hopefully we can use it next time
             UpdateCache(parentEngine, msbuildProject, solutionProjectCache, projectBuildEventContext);
-
         }
 
         /// <summary>
@@ -201,7 +200,7 @@ private static bool IsCacheUpToDate(Engine parentEngine, string solutionFile,  s
                 parentEngine.LoggingServices.LogComment(projectBuildEventContext, "SolutionCacheNotApplicable", "Configuration", cacheSolutionConfigurationName, fullSolutionConfigurationName);
                 return false;
             }
-            
+
             if (!String.Equals(wrapperProjectToolsVersion, cacheToolsVersion, StringComparison.OrdinalIgnoreCase))
             {
                 parentEngine.LoggingServices.LogComment(projectBuildEventContext, "SolutionCacheNotApplicable", "ToolsVersion", cacheToolsVersion, wrapperProjectToolsVersion);
@@ -261,7 +260,7 @@ private static bool IsCacheUpToDate(Engine parentEngine, string solutionFile,  s
             else
             {
                 return true;
-            }   
+            }
         }
 
         /// <summary>
@@ -352,7 +351,7 @@ private static void CreateSolutionProject(SolutionParser solution, Project msbui
             // Add a <target> element for each project we have
             foreach (ProjectInSolution proj in solution.ProjectsInOrder)
             {
-                string errorMessage = null;
+                string errorMessage;
 
                 // is it a solution folder?
                 if (proj.ProjectType == SolutionProjectType.SolutionFolder)
@@ -446,7 +445,7 @@ private static void AddCacheRelatedProperties(Project msbuildProject, string ful
                 // Only add projects that correspond to actual files on disk. Solution folders and web projects correspond to folders, so we don't care about them.
                 if (project.ProjectType != SolutionProjectType.SolutionFolder && project.ProjectType != SolutionProjectType.WebProject)
                 {
-                    cacheItemGroup.AddNewItem(cacheProjectListName, EscapingUtilities.Escape(project.RelativePath)); 
+                    cacheItemGroup.AddNewItem(cacheProjectListName, EscapingUtilities.Escape(project.RelativePath));
                 }
             }
         }
@@ -504,10 +503,10 @@ private static string DetermineChildProjectToolsVersion(Engine parentEngine, str
         /// <owner>RGoel, LukaszG</owner>
         static private BuildTask AddMSBuildTaskElement
         (
-            Target target, 
+            Target target,
             string projectPath,
-            string msbuildTargetName, 
-            string configurationName, 
+            string msbuildTargetName,
+            string configurationName,
             string platformName,
             bool specifyProjectToolsVersion
         )
@@ -515,7 +514,7 @@ bool specifyProjectToolsVersion
             BuildTask newTask = target.AddNewTask("MSBuild");
             newTask.SetParameterValue("Projects", projectPath, true /* treat as literal */);
 
-            if (msbuildTargetName != null && msbuildTargetName.Length > 0)
+            if (!string.IsNullOrEmpty(msbuildTargetName))
             {
                 newTask.SetParameterValue("Targets", msbuildTargetName);
             }
@@ -544,7 +543,7 @@ bool specifyProjectToolsVersion
         /// <param name="msbuildProject"></param>
         /// <param name="solution"></param>
         /// <param name="proj"></param>
-        /// <param name="targetOutputItemName">The name of the item exposing this target's outputs.  May be null.</param>        
+        /// <param name="targetOutputItemName">The name of the item exposing this target's outputs.  May be null.</param>
         /// <param name="subTargetName"></param>
         /// <owner>RGoel, LukaszG</owner>
         static private void AddTargetForManagedProject
@@ -557,7 +556,7 @@ string subTargetName
         )
         {
             string targetName = ProjectInSolution.DisambiguateProjectTargetName(proj.GetUniqueProjectName());
-            if (subTargetName != null && subTargetName.Length > 0)
+            if (!string.IsNullOrEmpty(subTargetName))
             {
                 targetName = targetName + ":" + subTargetName;
             }
@@ -570,14 +569,13 @@ string subTargetName
             {
                 newTarget.TargetElement.SetAttribute("Outputs", string.Format(CultureInfo.InvariantCulture, "@({0})", targetOutputItemName));
             }
-            
+
             // Only create build items if we're called with the null subtarget. We're getting called
             // a total of four times and only want to create the build items once.
             bool createBuildItems = (subTargetName == null);
 
             foreach (ConfigurationInSolution solutionConfiguration in solution.SolutionConfigurations)
             {
-                ProjectConfigurationInSolution projectConfiguration = null;
                 string condition = GetConditionStringForConfiguration(solutionConfiguration);
 
                 // Create the build item group for this configuration if we haven't already
@@ -587,6 +585,7 @@ string subTargetName
                     solutionConfiguration.ProjectBuildItems.Condition = condition;
                 }
 
+                ProjectConfigurationInSolution projectConfiguration;
                 if (proj.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out projectConfiguration))
                 {
                     if (projectConfiguration.IncludeInBuild)
@@ -600,7 +599,7 @@ string subTargetName
                         // PERF: We could emit two <MSBuild> tasks, with a condition on them. But this doubles the size of
                         // the solution wrapper project, and the cost is too high. The consequence is that when solution wrapper
                         // projects are emitted to disk (with MSBUILDEMITSOLUION=1) they cannot be reused for tools version v2.0.
-                        bool specifyProjectToolsVersion = 
+                        bool specifyProjectToolsVersion =
                             String.Equals(msbuildProject.ToolsVersion, "2.0", StringComparison.OrdinalIgnoreCase) ? false : true;
 
                         BuildTask msbuildTask = AddMSBuildTaskElement(newTarget, proj.RelativePath, subTargetName,
@@ -703,8 +702,6 @@ out string addedReferenceGuids
         {
             StringBuilder referenceGuids = new StringBuilder();
 
-            string message = null;
-
             // Suffix for the reference item name. Since we need to attach additional (different) metadata to every
             // reference item, we need to have helper item lists each with only one item
             int outputReferenceItemNameSuffix = 0;
@@ -719,11 +716,12 @@ out string addedReferenceGuids
                     (referencedProject.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out referencedProjectConfiguration)) &&
                     (referencedProjectConfiguration != null))
                 {
-                    string outputReferenceItemNameWithSuffix = string.Format(CultureInfo.InvariantCulture, "{0}_{1}", 
+                    string outputReferenceItemNameWithSuffix = string.Format(CultureInfo.InvariantCulture, "{0}_{1}",
                         outputReferenceItemName, outputReferenceItemNameSuffix);
 
                     bool addCreateItem = false;
 
+                    string message;
                     if ((referencedProject.ProjectType == SolutionProjectType.ManagedProject) ||
                         ((referencedProject.ProjectType == SolutionProjectType.Unknown) && (referencedProject.CanBeMSBuildProjectFile(out message))))
                     {
@@ -734,7 +732,7 @@ out string addedReferenceGuids
                         BuildTask msbuildTask = AddMSBuildTaskElement(target, referencedProject.RelativePath, "GetTargetPath",
                             referencedProjectConfiguration.ConfigurationName, referencedProjectConfiguration.PlatformName, specifyProjectToolsVersion);
                         msbuildTask.Condition = condition;
-                        msbuildTask.AddOutputItem("TargetOutputs", outputReferenceItemNameWithSuffix);                        
+                        msbuildTask.AddOutputItem("TargetOutputs", outputReferenceItemNameWithSuffix);
 
                         if (referenceGuids.Length > 0)
                         {
@@ -743,7 +741,6 @@ out string addedReferenceGuids
 
                         referenceGuids.Append(projectReferenceGuid);
                         addCreateItem = true;
-
                     }
                     else if (referencedProject.ProjectType == SolutionProjectType.VCProject)
                     {
@@ -754,11 +751,8 @@ out string addedReferenceGuids
                             vcbuildTask = AddResolveVCProjectOutputTaskElement(target, Path.Combine(solution.SolutionFileDirectory, Path.GetFileName(solution.SolutionFile)),
                                 referencedProject.AbsolutePath, referencedProjectConfiguration.FullName);
                         }
-                        catch (Exception e)
+                        catch (Exception e) when (!ExceptionHandling.NotExpectedException(e))
                         {
-                            if (ExceptionHandling.NotExpectedException(e))
-                               throw;
-
                             ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(false,
                                 "SubCategoryForSolutionParsingErrors",
                                 new BuildEventFileInfo(solution.SolutionFile),
@@ -768,7 +762,7 @@ out string addedReferenceGuids
 
                         vcbuildTask.Condition = GetConditionStringForConfiguration(solutionConfiguration);
                         vcbuildTask.AddOutputItem("ResolvedOutputPaths", outputReferenceItemNameWithSuffix);
-                        
+
                         if (outputImportLibraryItemName != null)
                         {
                             vcbuildTask.AddOutputItem("ResolvedImportLibraryPaths", outputImportLibraryItemName);
@@ -837,8 +831,7 @@ string projectConfigurationName
                 importLibraryItemName.Append(subTargetName);
             }
 
-            string referenceGuidsToRemove = null;
-
+            string referenceGuidsToRemove;
             AddResolveProjectReferenceTasks(solution, msbuildProject, target, proj, solutionConfiguration,
                 referenceItemName.ToString(), importLibraryItemName.ToString(), out referenceGuidsToRemove);
 
@@ -846,13 +839,12 @@ string projectConfigurationName
                 referenceGuidsToRemove = string.Empty;
 
             string fullProjectPath = null;
-            string tmpExtension = null;
             string projectPath = null;
 
             try
             {
                 fullProjectPath = proj.AbsolutePath;
-                tmpExtension = string.Format(CultureInfo.InvariantCulture, ".tmp_{0}_{1}.vcproj", solutionConfiguration.ConfigurationName, solutionConfiguration.PlatformName);
+                string tmpExtension = string.Format(CultureInfo.InvariantCulture, ".tmp_{0}_{1}.vcproj", solutionConfiguration.ConfigurationName, solutionConfiguration.PlatformName);
                 projectPath = Path.ChangeExtension(fullProjectPath, tmpExtension);
             }
             catch (Exception e)
@@ -867,7 +859,6 @@ string projectConfigurationName
                     proj.RelativePath, e.Message);
             }
 
-
             // Create the temporary VC project
             BuildTask createVCProjectTask = target.AddNewTask("CreateTemporaryVCProject");
             createVCProjectTask.SetParameterValue("ProjectFile", fullProjectPath, true /* treat as literal */);
@@ -902,7 +893,7 @@ string subTargetName
         )
         {
             string targetName = ProjectInSolution.DisambiguateProjectTargetName(proj.GetUniqueProjectName());
-            if (subTargetName != null && subTargetName.Length > 0)
+            if (!string.IsNullOrEmpty(subTargetName))
             {
                 targetName = targetName + ":" + subTargetName;
             }
@@ -956,15 +947,15 @@ string subTargetName
                         if (proj.ProjectReferences.Count > 0)
                         {
                             projectPath = AddCreateTemporaryVCProjectTasks(solution, msbuildProject, newTarget, proj,
-                                solutionConfiguration, subTargetName, 
+                                solutionConfiguration, subTargetName,
                                 vcProjectConfiguration.FullName);
                         }
 
                         newTask = VCWrapperProject.AddVCBuildTaskElement(
                             msbuildProject,
                             newTarget,
-                            EscapingUtilities.Escape(Path.Combine(solution.SolutionFileDirectory, Path.GetFileName(solution.SolutionFile))), 
-                            projectPath, subTargetName, 
+                            EscapingUtilities.Escape(Path.Combine(solution.SolutionFileDirectory, Path.GetFileName(solution.SolutionFile))),
+                            projectPath, subTargetName,
                             null, EscapingUtilities.Escape(vcProjectConfiguration.FullName));
 
                         // Delete the temporary VC project
@@ -1035,7 +1026,7 @@ Project msbuildProject
 
             // TFV v3.5 supported by TV 4.0, TV 3.5
             getFrameworkPathTask.AddOutputItem(
-                "FrameworkVersion35Path", 
+                "FrameworkVersion35Path",
                 "_CombinedTargetFrameworkDirectoriesItem",
                 " ('$(TargetFrameworkVersion)' == 'v3.5' or '$(TargetFrameworkVersion)' == 'v4.0') and '$(MSBuildToolsVersion)' != '2.0'");
 
@@ -1086,9 +1077,9 @@ string conditionDescribingValidConfigurations
 
             newTask.Condition = conditionDescribingValidConfigurations;
         }
-            
+
         /// <summary>
-        /// Add a call to the ResolveAssemblyReference task to crack the pre-resolved referenced 
+        /// Add a call to the ResolveAssemblyReference task to crack the pre-resolved referenced
         /// assemblies for the complete list of dependencies, PDBs, satellites, etc.  The invoke
         /// the Copy task to copy all these files (or at least the ones that RAR determined should
         /// be copied local) into the web project's bin directory.
@@ -1100,9 +1091,9 @@ string conditionDescribingValidConfigurations
         /// <owner>RGoel</owner>
         static private void AddTasksToCopyAllDependenciesIntoBinDir
             (
-            Target target, 
-            ProjectInSolution proj, 
-            string referenceItemName, 
+            Target target,
+            ProjectInSolution proj,
+            string referenceItemName,
             string conditionDescribingValidConfigurations
             )
         {
@@ -1142,7 +1133,7 @@ string conditionDescribingValidConfigurations
             BuildTask copyTask = target.AddNewTask("Copy");
             copyTask.SetParameterValue("SourceFiles", "@(" + copyLocalFilesItemName + ")", false /* DO NOT treat as literal */);
             copyTask.SetParameterValue("DestinationFiles", String.Format(CultureInfo.InvariantCulture,
-                @"@({0}->'{1}%(DestinationSubDirectory)%(Filename)%(Extension)')", 
+                @"@({0}->'{1}%(DestinationSubDirectory)%(Filename)%(Extension)')",
                 copyLocalFilesItemName, destinationFolder), false /* DO NOT treat as literal */);
             copyTask.Condition = conditionDescribingValidConfigurations;
         }
@@ -1159,16 +1150,16 @@ string conditionDescribingValidConfigurations
         /// <owner>RGoel</owner>
         static private void AddPropertyGroupForAspNetConfiguration
             (
-            Project msbuildProject, 
-            ProjectInSolution proj, 
-            string configurationName, 
+            Project msbuildProject,
+            ProjectInSolution proj,
+            string configurationName,
             AspNetCompilerParameters aspNetCompilerParameters,
             string solutionFile
             )
         {
             // Add a new PropertyGroup that is condition'd on the Configuration.
             BuildPropertyGroup newPropertyGroup = msbuildProject.AddNewPropertyGroup(false /* insertAtEndOfProject = false */);
-            newPropertyGroup.Condition = String.Format(CultureInfo.InvariantCulture, " '$(AspNetConfiguration)' == '{0}' ", 
+            newPropertyGroup.Condition = String.Format(CultureInfo.InvariantCulture, " '$(AspNetConfiguration)' == '{0}' ",
                 EscapingUtilities.Escape(configurationName));
 
             // Add properties into the property group for each of the AspNetCompiler properties.
@@ -1221,8 +1212,8 @@ string solutionFile
                     // override the AspNetTargetPath.  What we want to do in this case is concatenate:
                     //  $(OutDir) + "\_PublishedWebsites" + (the last portion of the folder in the AspNetPhysicalPath).
                     BuildProperty targetPathOverrideProperty = newPropertyGroup.AddNewProperty(GenerateSafePropertyName(proj, "AspNetTargetPath"),
-                        @"$(OutDir)" + 
-                        EscapingUtilities.Escape(webProjectOverrideFolder) + Path.DirectorySeparatorChar + 
+                        @"$(OutDir)" +
+                        EscapingUtilities.Escape(webProjectOverrideFolder) + Path.DirectorySeparatorChar +
                         EscapingUtilities.Escape(lastFolderInPhysicalPath) + Path.DirectorySeparatorChar);
                     targetPathOverrideProperty.Condition = " '$(OutDir)' != '' ";
                 }
@@ -1230,10 +1221,10 @@ string solutionFile
         }
 
         /// <summary>
-        /// This code handles the *.REFRESH files that are in the "bin" subdirectory of 
-        /// a web project.  These .REFRESH files are just text files that contain absolute or 
-        /// relative paths to the referenced assemblies.  The goal of these tasks is to 
-        /// search all *.REFRESH files and extract fully-qualified absolute paths for 
+        /// This code handles the *.REFRESH files that are in the "bin" subdirectory of
+        /// a web project.  These .REFRESH files are just text files that contain absolute or
+        /// relative paths to the referenced assemblies.  The goal of these tasks is to
+        /// search all *.REFRESH files and extract fully-qualified absolute paths for
         /// each of the references.
         /// </summary>
         /// <param name="target"></param>
@@ -1242,8 +1233,8 @@ string solutionFile
         /// <owner>RGoel</owner>
         static private void AddTasksToResolveAutoRefreshFileReferences
             (
-            Target target, 
-            ProjectInSolution proj, 
+            Target target,
+            ProjectInSolution proj,
             string referenceItemName
             )
         {
@@ -1257,7 +1248,7 @@ string referenceItemName
             // Read the lines out of each .REFRESH file; they should be paths to .DLLs.  Put these paths
             // into an item list.
             BuildTask readLinesTask = target.AddNewTask("ReadLinesFromFile");
-            readLinesTask.SetParameterValue("File", 
+            readLinesTask.SetParameterValue("File",
                 String.Format(CultureInfo.InvariantCulture, @"%({0}_RefreshFile.Identity)", referenceItemName));
             readLinesTask.Condition = String.Format(CultureInfo.InvariantCulture, @" '%({0}_RefreshFile.Identity)' != '' ", referenceItemName);
             readLinesTask.AddOutputItem("Lines", referenceItemName + "_ReferenceRelPath");
@@ -1267,14 +1258,14 @@ string referenceItemName
             // directly to RAR later.
             BuildTask combinePathTask = target.AddNewTask("CombinePath");
             combinePathTask.SetParameterValue("BasePath", webRoot);
-            combinePathTask.SetParameterValue("Paths", 
+            combinePathTask.SetParameterValue("Paths",
                 String.Format(CultureInfo.InvariantCulture, @"@({0}_ReferenceRelPath)", referenceItemName));
             combinePathTask.AddOutputItem("CombinedPaths", referenceItemName);
         }
 
         /// <summary>
         /// When adding a target to build a web project, we want to put a Condition on the Target node that
-        /// effectively says "Only build this target if the web project is active (marked for building) in the 
+        /// effectively says "Only build this target if the web project is active (marked for building) in the
         /// current solution configuration.
         /// </summary>
         /// <param name="solution"></param>
@@ -1295,7 +1286,7 @@ ProjectInSolution proj
                 // Find out if the web project has a project configuration for this solution configuration.
                 // (Actually, web projects only have one project configuration, so the TryGetValue should
                 // pretty much always return "true".
-                ProjectConfigurationInSolution projectConfiguration = null;
+                ProjectConfigurationInSolution projectConfiguration;
                 if (proj.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out projectConfiguration))
                 {
                     // See if the web project is marked as active for this solution configuration.  If so,
@@ -1307,8 +1298,8 @@ ProjectInSolution proj
                         condition.Append(")");
                     }
                 }
-                else if (String.Compare(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase) == 0 ||
-                         String.Compare(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase) == 0)
+                else if (String.Equals(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase) ||
+                         String.Equals(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase))
                 {
                     // we don't have a project configuration that matches the solution configuration but
                     // the solution configuration is called "Release" or "Debug" which are standard AspNetConfigurations
@@ -1344,7 +1335,7 @@ string subTargetName
             AddTargetForGetFrameworkPathAndRedistList(msbuildProject);
 
             string targetName = ProjectInSolution.DisambiguateProjectTargetName(proj.GetUniqueProjectName());
-            if (subTargetName != null && subTargetName.Length > 0)
+            if (!string.IsNullOrEmpty(subTargetName))
             {
                 targetName = targetName + ":" + subTargetName;
             }
@@ -1395,15 +1386,14 @@ string subTargetName
                     // subTargetName=null and once when subTargetName="Rebuild".
                     if (subTargetName == null)
                     {
-                        AddPropertyGroupForAspNetConfiguration(msbuildProject, proj, configurationName, 
+                        AddPropertyGroupForAspNetConfiguration(msbuildProject, proj, configurationName,
                             aspNetCompilerParameters, solution.SolutionFile);
                     }
 
                     // Update our big condition string to include this configuration.
                     conditionDescribingValidConfigurations.Append(" or ");
-                    conditionDescribingValidConfigurations.Append(
-                        String.Format(CultureInfo.InvariantCulture, "('$(AspNetConfiguration)' == '{0}')", 
-                        EscapingUtilities.Escape(configurationName)));
+                    conditionDescribingValidConfigurations.AppendFormat(CultureInfo.InvariantCulture, "('$(AspNetConfiguration)' == '{0}')",
+                        EscapingUtilities.Escape(configurationName));
                 }
 
                 StringBuilder referenceItemName = new StringBuilder(GenerateSafePropertyName(proj, "References"));
@@ -1421,8 +1411,7 @@ string subTargetName
                     // of referenced projects.
                     foreach (ConfigurationInSolution solutionConfiguration in solution.SolutionConfigurations)
                     {
-                        string referenceProjectGuids = null;
-
+                        string referenceProjectGuids;
                         AddResolveProjectReferenceTasks(solution, msbuildProject, newTarget, proj, solutionConfiguration,
                             referenceItemName.ToString(), null /* don't care about native references */, out referenceProjectGuids);
                     }
@@ -1499,11 +1488,11 @@ private static string MakeIntoSafeItemName(string name)
         /// <param name="textResourceName">Resource string name to use in the tag text</param>
         /// <param name="args">Additional parameters to pass to FormatString</param>
         /// <owner>LukaszG</owner>
-        static internal BuildTask AddErrorWarningMessageElement(Target target, string elementType, 
+        static internal BuildTask AddErrorWarningMessageElement(Target target, string elementType,
             bool treatAsLiteral, string textResourceName, params object[] args)
         {
-            string code = null;
-            string helpKeyword = null;
+            string code;
+            string helpKeyword;
             string text = ResourceUtilities.FormatResourceString(out code, out helpKeyword, textResourceName, args);
 
             BuildTask task = target.AddNewTask(elementType);
@@ -1528,7 +1517,7 @@ static internal BuildTask AddErrorWarningMessageElement(Target target, string el
         /// <param name="msbuildProject">The project to add the target to</param>
         /// <param name="proj">The project to add as a target.</param>
         /// <param name="subTargetName">The target to call within the project that's being added.</param>
-        /// <param name="errorMessage">Optional detailed error message to print out in case we already tried accessing the 
+        /// <param name="errorMessage">Optional detailed error message to print out in case we already tried accessing the
         /// project file before and failed.</param>
         /// <owner>RGoel</owner>
         static private void AddTargetForUnknownProjectType
@@ -1541,7 +1530,7 @@ string errorMessage
         )
         {
             string targetName = ProjectInSolution.DisambiguateProjectTargetName(proj.GetUniqueProjectName());
-            if (subTargetName != null && subTargetName.Length > 0)
+            if (!string.IsNullOrEmpty(subTargetName))
             {
                 targetName = targetName + ":" + subTargetName;
             }
@@ -1552,9 +1541,8 @@ string errorMessage
 
             foreach (ConfigurationInSolution solutionConfiguration in solution.SolutionConfigurations)
             {
-                ProjectConfigurationInSolution projectConfiguration = null;
-                BuildTask newTask = null;
-
+                ProjectConfigurationInSolution projectConfiguration;
+                BuildTask newTask;
                 if (proj.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out projectConfiguration))
                 {
                     if (projectConfiguration.IncludeInBuild)
@@ -1599,8 +1587,8 @@ string errorMessage
         /// <owner>RGoel</owner>
         static private Target AddAllDependencyTarget
         (
-            Project msbuildProject, 
-            string targetName, 
+            Project msbuildProject,
+            string targetName,
             string targetOutputItemName,
             string subTargetName,
             Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel
@@ -1608,7 +1596,7 @@ Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel
         {
             Target newTarget = msbuildProject.Targets.AddNewTarget(targetName);
             newTarget.Condition = "'$(CurrentSolutionConfigurationContents)' != ''";
-            
+
             if (!String.IsNullOrEmpty(targetOutputItemName))
             {
                 newTarget.TargetElement.SetAttribute("Outputs", string.Format(CultureInfo.InvariantCulture, "@({0})", targetOutputItemName));
@@ -1624,7 +1612,7 @@ Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel
                 msbuildTask.SetParameterValue("Projects", buildItemReference);
                 msbuildTask.SetParameterValue("Properties", "Configuration=%(Configuration); Platform=%(Platform); BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionPath=$(SolutionPath)");
 
-                if (subTargetName != null && subTargetName.Length > 0)
+                if (!string.IsNullOrEmpty(subTargetName))
                 {
                     msbuildTask.SetParameterValue("Targets", subTargetName);
                 }
@@ -1642,14 +1630,14 @@ Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel
                     msbuildTask.SetParameterValue("UseResultsCache", "$(UseResultsCache)");
                 }
 
-                BuildTask messageTask = AddErrorWarningMessageElement(newTarget, XMakeElements.message, false /* don't treat as literal */, "SolutionProjectSkippedForBuilding", 
+                BuildTask messageTask = AddErrorWarningMessageElement(newTarget, XMakeElements.message, false /* don't treat as literal */, "SolutionProjectSkippedForBuilding",
                     string.Format(CultureInfo.InvariantCulture, "%(SkipLevel{0}.Identity)", dependencyLevel), "$(Configuration)|$(Platform)");
                 messageTask.Condition = string.Format(CultureInfo.InvariantCulture, "@(SkipLevel{0}) != ''", dependencyLevel);
 
                 BuildTask warningTask = AddErrorWarningMessageElement(newTarget, XMakeElements.warning, false /* don't treat as literal */, "SolutionProjectConfigurationMissing",
                     string.Format(CultureInfo.InvariantCulture, "%(MissingConfigLevel{0}.Identity)", dependencyLevel), "$(Configuration)|$(Platform)");
                 warningTask.Condition = string.Format(CultureInfo.InvariantCulture, "@(MissingConfigLevel{0}) != ''", dependencyLevel);
-                
+
                 string allProjects = GetAllNonMSBuildProjectDependencies(projectsByDependencyLevel, dependencyLevel, subTargetName);
                 if (allProjects.Length > 0)
                 {
@@ -1693,7 +1681,7 @@ static private string GetProjectDependencies(SolutionParser solution, ProjectInS
                     "SolutionParseProjectDepNotFoundError", project.ProjectGuid, dependency);
 
                 dependencies.Append(ProjectInSolution.DisambiguateProjectTargetName(projectUniqueName));
-                if (subTargetName != null && subTargetName.Length > 0)
+                if (!string.IsNullOrEmpty(subTargetName))
                 {
                     dependencies.Append(":");
                     dependencies.Append(subTargetName);
@@ -1712,8 +1700,8 @@ static private string GetProjectDependencies(SolutionParser solution, ProjectInS
         /// <returns></returns>
         static private string GetAllNonMSBuildProjectDependencies
         (
-            Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel, 
-            int dependencyLevel, 
+            Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel,
+            int dependencyLevel,
             string subTargetName
         )
         {
@@ -1738,7 +1726,7 @@ string subTargetName
                 }
 
                 dependencies.Append(ProjectInSolution.DisambiguateProjectTargetName(proj.GetUniqueProjectName()));
-                if (subTargetName != null && subTargetName.Length > 0)
+                if (!string.IsNullOrEmpty(subTargetName))
                 {
                     dependencies.Append(":");
                     dependencies.Append(subTargetName);
@@ -1761,7 +1749,7 @@ string subTargetName
         static private string GetConditionStringForConfiguration(ConfigurationInSolution configuration)
         {
             return string.Format(CultureInfo.InvariantCulture, " ('$(Configuration)' == '{0}') and ('$(Platform)' == '{1}') ",
-                EscapingUtilities.Escape(configuration.ConfigurationName), 
+                EscapingUtilities.Escape(configuration.ConfigurationName),
                 EscapingUtilities.Escape(configuration.PlatformName));
         }
 
@@ -1796,7 +1784,7 @@ SolutionParser solution
         /// <owner>LukaszG</owner>
         static internal void AddPropertyGroupForSolutionConfiguration
         (
-            Project msbuildProject, 
+            Project msbuildProject,
             SolutionParser solution,
             ConfigurationInSolution solutionConfiguration
         )
@@ -1809,8 +1797,7 @@ ConfigurationInSolution solutionConfiguration
             // add a project configuration entry for each project in the solution
             foreach (ProjectInSolution project in solution.ProjectsInOrder)
             {
-                ProjectConfigurationInSolution projectConfiguration = null;
-
+                ProjectConfigurationInSolution projectConfiguration;
                 if (project.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out projectConfiguration))
                 {
                     solutionConfigurationContents.AppendFormat(
@@ -1830,12 +1817,12 @@ ConfigurationInSolution solutionConfiguration
         /// <summary>
         /// Creates the default Venus configuration property based on the selected solution configuration.
         /// Unfortunately, Venus projects only expose one project configuration in the IDE (Debug) although
-        /// they allow building Debug and Release from command line. This means that if we wanted to use 
+        /// they allow building Debug and Release from command line. This means that if we wanted to use
         /// the project configuration from the active solution configuration for Venus projects, we'd always
         /// end up with Debug and there'd be no way to build the Release configuration. To work around this,
         /// we use a special mechanism for choosing ASP.NET project configuration: we set it to Release if
-        /// we're building a Release solution configuration, and to Debug if we're building a Debug solution 
-        /// configuration. The property is also settable from the command line, in which case it takes 
+        /// we're building a Release solution configuration, and to Debug if we're building a Debug solution
+        /// configuration. The property is also settable from the command line, in which case it takes
         /// precedence over this algorithm.
         /// </summary>
         /// <param name="msbuildProject"></param>
@@ -1891,7 +1878,7 @@ static private void AddGlobalProperties(Project msbuildProject, SolutionParser s
 
         /// <summary>
         /// Special hack for web projects. It can happen that there is no Release configuration for solutions
-        /// containing web projects, yet we still want to be able to build the Release configuration for 
+        /// containing web projects, yet we still want to be able to build the Release configuration for
         /// those projects. Since the ASP.NET project configuration defaults to the solution configuration,
         /// we allow Release even if it doesn't actually exist in the solution.
         /// </summary>
@@ -1904,7 +1891,7 @@ static private void AddFakeReleaseSolutionConfigurationIfNecessary(SolutionParse
                 bool solutionHasReleaseConfiguration = false;
                 foreach (ConfigurationInSolution solutionConfiguration in solution.SolutionConfigurations)
                 {
-                    if (string.Compare(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase) == 0)
+                    if (string.Equals(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase))
                     {
                         solutionHasReleaseConfiguration = true;
                         break;
@@ -1944,13 +1931,13 @@ static private void AddInitialTargets(Project msbuildProject)
                 "SolutionToolsVersionDoesNotSupportProjectToolsVersion", "$(MSBuildToolsVersion)");
             toolsVersionErrorTask.Condition = "'$(MSBuildToolsVersion)' == '2.0' and ('$(ProjectToolsVersion)' != '2.0' and '$(ProjectToolsVersion)' != '')";
 
-            msbuildProject.InitialTargets = initialTarget.Name + ";" + validateToolsVersionsTarget.Name;            
-        }          
+            msbuildProject.InitialTargets = initialTarget.Name + ";" + validateToolsVersionsTarget.Name;
+        }
 
         /// <summary>
         /// Normally the active solution configuration/platform is determined when we build the solution
         /// wrapper project, not when we create it. However, we need to know them to scan project references
-        /// for the right project configuration/platform. It's unlikely that references would be conditional, 
+        /// for the right project configuration/platform. It's unlikely that references would be conditional,
         /// but still possible and we want to get that case right.
         /// </summary>
         /// <returns></returns>
@@ -1982,7 +1969,7 @@ private static string DetermineLikelyActiveSolutionConfiguration(SolutionParser
         {
             string activeSolutionConfiguration;
             string activeSolutionPlatform;
-            
+
             BuildProperty configurationProperty = parentEngine.GlobalProperties["Configuration"];
             BuildProperty platformProperty = parentEngine.GlobalProperties["Platform"];
 
@@ -2011,13 +1998,11 @@ private static string DetermineLikelyActiveSolutionConfiguration(SolutionParser
 
         /// <summary>
         /// Loads each MSBuild project in this solution and looks for its project-to-project references so that
-        /// we know what build order we should use when building the solution. 
+        /// we know what build order we should use when building the solution.
         /// </summary>
         /// <owner>LukaszG</owner>
         static private void ScanProjectDependencies(SolutionParser solution, Engine parentEngine, string childProjectToolsVersion, string fullSolutionConfigurationName, BuildEventContext projectBuildEventContext)
         {
-            string message = null;
-
             // Don't bother with all this if the solution configuration doesn't even exist.
             if (fullSolutionConfigurationName == null)
             {
@@ -2032,7 +2017,8 @@ static private void ScanProjectDependencies(SolutionParser solution, Engine pare
                     continue;
                 }
 
-                if ((project.ProjectType == SolutionProjectType.ManagedProject) || 
+                string message;
+                if ((project.ProjectType == SolutionProjectType.ManagedProject) ||
                     ((project.ProjectType == SolutionProjectType.Unknown) && (project.CanBeMSBuildProjectFile(out message))))
                 {
                     try
@@ -2040,7 +2026,7 @@ static private void ScanProjectDependencies(SolutionParser solution, Engine pare
                         //Will fail to load a throw an error if the tools version is incorrect.
                         Project msbuildProject = new Project(parentEngine, childProjectToolsVersion);
                         msbuildProject.IsLoadedByHost = false;
-                        
+
                         // this is before building the solution wrapper project, so the current directory may be not set to
                         // the one containing the solution file, and we'd get the relative path wrong
                         msbuildProject.Load(project.AbsolutePath);
@@ -2049,11 +2035,11 @@ static private void ScanProjectDependencies(SolutionParser solution, Engine pare
                         // so set it before retrieving references.
                         msbuildProject.GlobalProperties.SetProperty("Configuration",
                             project.ProjectConfigurations[fullSolutionConfigurationName].ConfigurationName, true /* treat as literal */);
-                        msbuildProject.GlobalProperties.SetProperty("Platform", 
+                        msbuildProject.GlobalProperties.SetProperty("Platform",
                             project.ProjectConfigurations[fullSolutionConfigurationName].PlatformName, true /* treat as literal */);
-                        
+
                         BuildItemGroup references = msbuildProject.GetEvaluatedItemsByName("ProjectReference");
-                        
+
                         foreach (BuildItem reference in references)
                         {
                             string referencedProjectGuid = reference.GetEvaluatedMetadata("Project");   // Need unescaped data here.
@@ -2091,7 +2077,7 @@ static private void ScanProjectDependencies(SolutionParser solution, Engine pare
                             // Grab the guid with its curly braces...
                             referencedWebProjectGuid = referencedWebProjectGuid.Substring(0, 38);
                             AddDependencyByGuid(solution, project, parentEngine, projectBuildEventContext, referencedWebProjectGuid);
-                        }                                                
+                        }
                     }
                     // We don't want any problems scanning the project file to result in aborting the build.
                     catch (Exception e)
@@ -2175,7 +2161,7 @@ static private void AddDependencyByGuid(SolutionParser solution, ProjectInSoluti
         /// For MSBuild projects, project dependencies you can set in the IDE only represent build order constraints.
         /// If both projects are VC however, the VC project system treats dependencies as regular P2P references.
         /// This behavior is a carry-over from the days of VC5/6, that's how P2P refs were done back then. Tricky.
-        /// To compensate for that, we need to add a P2P reference for every dependency between two VC projects. 
+        /// To compensate for that, we need to add a P2P reference for every dependency between two VC projects.
         /// MSBuild -> VC, VC -> MSBuild dependencies are not affected.
         /// </summary>
         /// <param name="solution"></param>
@@ -2276,11 +2262,11 @@ static private void AssignDependencyLevels(SolutionParser solution, Dictionary<i
         }
 
         /// <summary>
-        /// Add virtual references for reference chains containing VC static library projects. 
-        /// Since static libraries have no link step, any references they have have to be passed
+        /// Add virtual references for reference chains containing VC static library projects.
+        /// Since static libraries have no link step, any references they have to be passed
         /// to their parent project, if any. So for example, in a chain like
         /// native dll -> native static lib1 -> native static lib2
-        /// we need to add a virtual reference between the native dll and the static lib2 
+        /// we need to add a virtual reference between the native dll and the static lib2
         /// to maintain parity with the IDE behavior.
         /// </summary>
         /// <param name="solution"></param>
@@ -2315,7 +2301,7 @@ private static void GatherChildReferencesForStaticLibraries(SolutionParser solut
                     {
                         foreach (string childReferenceGuid in referencedProject.ProjectReferences)
                         {
-                            if (!project.ProjectReferences.Contains(childReferenceGuid) && 
+                            if (!project.ProjectReferences.Contains(childReferenceGuid) &&
                                 !referenceGuidsToAdd.Contains(childReferenceGuid))
                             {
                                 referenceGuidsToAdd.Add(childReferenceGuid);
diff --git a/src/Deprecated/Engine/Solution/VCProjectParser.cs b/src/Deprecated/Engine/Solution/VCProjectParser.cs
index a58f9d2bf4e..7046679da8b 100644
--- a/src/Deprecated/Engine/Solution/VCProjectParser.cs
+++ b/src/Deprecated/Engine/Solution/VCProjectParser.cs
@@ -44,8 +44,6 @@ static internal List<string> GetReferencedProjectGuids(XmlDocument project)
         internal static bool IsStaticLibrary(XmlDocument project, string configurationName)
         {
             XmlNodeList configurationsElements = project.DocumentElement.GetElementsByTagName("Configurations");
-            XmlElement configurationElement = null;
-
             bool isStaticLibrary = false;
 
             // There should be only one configurations element
@@ -58,11 +56,10 @@ internal static bool IsStaticLibrary(XmlDocument project, string configurationNa
                         XmlElement element = (XmlElement)configurationNode;
 
                         // Look for configuration that matches our name
-                        if ((string.Compare(element.Name, "Configuration", StringComparison.OrdinalIgnoreCase) == 0) &&
-                            (string.Compare(element.GetAttribute("Name"), configurationName, StringComparison.OrdinalIgnoreCase) == 0))
+                        if ((string.Equals(element.Name, "Configuration", StringComparison.OrdinalIgnoreCase)) &&
+                            (string.Equals(element.GetAttribute("Name"), configurationName, StringComparison.OrdinalIgnoreCase)))
                         {
-                            configurationElement = element;
-
+                            XmlElement configurationElement = element;
                             string configurationType = configurationElement.GetAttribute("ConfigurationType");
                             isStaticLibrary = (configurationType == "4");
 
diff --git a/src/Deprecated/Engine/Solution/VCWrapperProject.cs b/src/Deprecated/Engine/Solution/VCWrapperProject.cs
index 2bb2aefb038..fe252f31141 100644
--- a/src/Deprecated/Engine/Solution/VCWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/VCWrapperProject.cs
@@ -99,7 +99,7 @@ string fullConfigurationName
 
             newTask.SetParameterValue("SolutionFile", solutionPath);
 
-            if ((vcbuildTargetName != null) && (vcbuildTargetName.Length > 0))
+            if (!string.IsNullOrEmpty(vcbuildTargetName))
             {
                 newTask.SetParameterValue(vcbuildTargetName, "true");
             }
@@ -138,8 +138,7 @@ string fullConfigurationName
         static internal XmlDocument GenerateVCWrapperProject(Engine parentEngine, string vcProjectFilename, string toolsVersion)
         {
             string projectPath = Path.GetFullPath(vcProjectFilename);
-            Project msbuildProject = null;
-
+            Project msbuildProject;
             try
             {
                 msbuildProject = new Project(parentEngine, toolsVersion);
@@ -228,7 +227,6 @@ static internal string VCBuildLocationHint
         /// <summary>
         /// constants for VS9 Pro and above SKUs
         /// </summary>
-
         // root registry key for VS9
         private const string vs9RegKey = @"SOFTWARE\Microsoft\VisualStudio\9.0";
         // the name of the value containing disk install directory for the IDE components 
@@ -242,7 +240,6 @@ static internal string VCBuildLocationHint
         /// <summary>
         /// constants for the VC9 Express SKU
         /// </summary>
-
         // root registry key for VC9
         private const string vc9RegKey = @"SOFTWARE\Microsoft\VCExpress\9.0";
         // the name of the value containing disk install directory for the IDE components 
@@ -268,7 +265,7 @@ private static string GenerateFullPathToTool(RegistryView registryView)
                 string location = TryLocationFromRegistry(baseKey, vs9RegKey, vs9InstallDirValueName,
                     vs9RelativePathToVCBuildLayouts, vs9RelativePathToVCBuildBatch);
 
-                if (null != location)
+                if (location != null)
                 {
                     return location;
                 }
@@ -277,7 +274,7 @@ private static string GenerateFullPathToTool(RegistryView registryView)
                 location = TryLocationFromRegistry(baseKey, vc9RegKey, vc9InstallDirValueName,
                     vc9RelativePathToVCBuildLayouts, vc9RelativePathToVCBuildBatch);
 
-                if (null != location)
+                if (location != null)
                 {
                     return location;
                 }
@@ -328,7 +325,7 @@ private static string TryLocationFromRegistry(RegistryKey root, string subKeyNam
 
                         // if not found in layouts location, try the alternate dir if any,
                         // which contains vcbuild for batch installs
-                        if (null != relativePathFromValueOnBatch)
+                        if (relativePathFromValueOnBatch != null)
                         {
                             vcBuildPath = Path.Combine(rootDir, relativePathFromValueOnBatch);
                             if (File.Exists(vcBuildPath))
diff --git a/src/Deprecated/Engine/Tasks/IntrinsicTask.cs b/src/Deprecated/Engine/Tasks/IntrinsicTask.cs
index 1ee2e4e97c4..ee398d9d5dd 100644
--- a/src/Deprecated/Engine/Tasks/IntrinsicTask.cs
+++ b/src/Deprecated/Engine/Tasks/IntrinsicTask.cs
@@ -366,8 +366,8 @@ private enum BackingType
         /// </summary>
         internal static bool IsIntrinsicTaskName(string name)
         {
-            return (String.Equals(name, XMakeElements.propertyGroup, StringComparison.Ordinal)
-                ||  String.Equals(name, XMakeElements.itemGroup, StringComparison.Ordinal));
+            return String.Equals(name, XMakeElements.propertyGroup, StringComparison.Ordinal)
+                || String.Equals(name, XMakeElements.itemGroup, StringComparison.Ordinal);
         }
 
         #endregion  
diff --git a/src/Deprecated/Engine/Xml/BuildItemGroupChildXml.cs b/src/Deprecated/Engine/Xml/BuildItemGroupChildXml.cs
index e496b4a57f8..f53abbf2461 100644
--- a/src/Deprecated/Engine/Xml/BuildItemGroupChildXml.cs
+++ b/src/Deprecated/Engine/Xml/BuildItemGroupChildXml.cs
@@ -38,7 +38,6 @@ internal BuildItemGroupChildXml(XmlDocument ownerDocument, string name, string i
         {
             this.element = ownerDocument.CreateElement(name, XMakeAttributes.defaultXmlNamespace);
             this.Include = include;
-
         }
 
         internal BuildItemGroupChildXml(XmlElement element, ChildType childTypeExpected)
@@ -362,5 +361,4 @@ internal enum ChildType
         /// </summary>
         Any = BuildItemAdd | BuildItemRemove | BuildItemModify
     }
-
 }
diff --git a/src/Deprecated/Engine/Xml/BuildItemGroupXml.cs b/src/Deprecated/Engine/Xml/BuildItemGroupXml.cs
index a9d6773aa49..357ff686326 100644
--- a/src/Deprecated/Engine/Xml/BuildItemGroupXml.cs
+++ b/src/Deprecated/Engine/Xml/BuildItemGroupXml.cs
@@ -55,7 +55,7 @@ internal string Condition
         {
             get
             {
-                return (conditionAttribute != null ? conditionAttribute.Value : String.Empty);
+                return conditionAttribute != null ? conditionAttribute.Value : String.Empty;
             }
 
             set
@@ -68,7 +68,7 @@ internal XmlElement ParentElement
         {
             get
             {
-                if (element != null && element.ParentNode is XmlElement)
+                if (element?.ParentNode is XmlElement)
                 {
                     return (XmlElement)element.ParentNode;
                 }
diff --git a/src/Directory.Build.props b/src/Directory.Build.props
index 1dbbd8dcff8..54b620c6013 100644
--- a/src/Directory.Build.props
+++ b/src/Directory.Build.props
@@ -56,8 +56,6 @@
     <GenerateResourceMSBuildRuntime>CurrentRuntime</GenerateResourceMSBuildRuntime>
 
     <GenerateDocumentationFile>true</GenerateDocumentationFile>
-    <!-- Disable warnings from XML documentation. https://github.com/Microsoft/msbuild/issues/2927 -->
-    <NoWarn>$(NoWarn);1570;1572;1573;1587</NoWarn>
 
     <GenAPIAdditionalParameters>$(GenAPIAdditionalParameters) -excludeApiList:&quot;$(RepoRoot)ref\ExcludeAPIList.txt&quot;</GenAPIAdditionalParameters>
     <GenAPIAdditionalParameters>$(GenAPIAdditionalParameters) -excludeAttributesList:&quot;$(RepoRoot)ref\ExcludeAttributeList.txt&quot;</GenAPIAdditionalParameters>
diff --git a/src/Framework.UnitTests/Attribute_Tests.cs b/src/Framework.UnitTests/Attribute_Tests.cs
index 448d3a9aa3e..e94e9d66173 100644
--- a/src/Framework.UnitTests/Attribute_Tests.cs
+++ b/src/Framework.UnitTests/Attribute_Tests.cs
@@ -18,7 +18,6 @@ public class AttributeTests
         [Fact]
         public void RequiredRuntimeAttribute()
         {
-
             RequiredRuntimeAttribute attribute =
                 typeof(X).GetTypeInfo().GetCustomAttribute<RequiredRuntimeAttribute>();
 
diff --git a/src/Framework.UnitTests/BuildErrorEventArgs_Tests.cs b/src/Framework.UnitTests/BuildErrorEventArgs_Tests.cs
index 823429cf4fb..55015b677ef 100644
--- a/src/Framework.UnitTests/BuildErrorEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/BuildErrorEventArgs_Tests.cs
@@ -23,9 +23,10 @@ public void EventArgsCtors()
             beea = new BuildErrorEventArgs("Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender");
             beea = new BuildErrorEventArgs("Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender", DateTime.Now);
             beea = new BuildErrorEventArgs("Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "sender", DateTime.Now, "Message");
+            beea = new BuildErrorEventArgs("Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "sender", "HelpLink", DateTime.Now, "Message");
             beea = new BuildErrorEventArgs(null, null, null, 1, 2, 3, 4, null, null, null);
             beea = new BuildErrorEventArgs(null, null, null, 1, 2, 3, 4, null, null, null, DateTime.Now);
-            beea = new BuildErrorEventArgs(null, null, null, 1, 2, 3, 4, null, null, null, DateTime.Now, null);
+            beea = new BuildErrorEventArgs(null, null, null, 1, 2, 3, 4, null, null, null, null, DateTime.Now, null);
         }
 
         /// <summary>
diff --git a/src/Framework.UnitTests/BuildWarningEventArgs_Tests.cs b/src/Framework.UnitTests/BuildWarningEventArgs_Tests.cs
index 23c51ca3a39..ecb02ac6e2c 100644
--- a/src/Framework.UnitTests/BuildWarningEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/BuildWarningEventArgs_Tests.cs
@@ -28,9 +28,11 @@ public void EventArgsCtors()
             buildWarningEvent = new BuildWarningEventArgs("Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender");
             buildWarningEvent = new BuildWarningEventArgs("Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender", DateTime.Now);
             buildWarningEvent = new BuildWarningEventArgs("Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "sender", DateTime.Now, "Message");
+            buildWarningEvent = new BuildWarningEventArgs("Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "sender", "HelpLink", DateTime.Now, "Message");
             buildWarningEvent = new BuildWarningEventArgs(null, null, null, 1, 2, 3, 4, null, null, null);
             buildWarningEvent = new BuildWarningEventArgs(null, null, null, 1, 2, 3, 4, null, null, null, DateTime.Now);
             buildWarningEvent = new BuildWarningEventArgs(null, null, null, 1, 2, 3, 4, null, null, null, DateTime.Now, null);
+            buildWarningEvent = new BuildWarningEventArgs(null, null, null, 1, 2, 3, 4, null, null, null, null, DateTime.Now, null);
         }
 
         /// <summary>
@@ -57,4 +59,4 @@ public BuildWarningEventArgs2()
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Framework.UnitTests/CustomEventArgSerialization_Tests.cs b/src/Framework.UnitTests/CustomEventArgSerialization_Tests.cs
index 774b4e18f18..b8893caabde 100644
--- a/src/Framework.UnitTests/CustomEventArgSerialization_Tests.cs
+++ b/src/Framework.UnitTests/CustomEventArgSerialization_Tests.cs
@@ -172,6 +172,23 @@ public void TestBuildErrorEventArgs()
             _stream.Position.ShouldBe(streamWriteEndPosition); // "Stream End Positions Should Match"
             VerifyGenericEventArg(genericEvent, newGenericEvent);
             VerifyBuildErrorEventArgs(genericEvent, newGenericEvent);
+
+            // Test using HelpLink
+            _stream.Position = 0;
+            genericEvent = new BuildErrorEventArgs("Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "SenderName", "HelpLink", DateTime.Now);
+            genericEvent.BuildEventContext = new BuildEventContext(5, 4, 3, 2);
+
+            // Serialize
+            genericEvent.WriteToStream(_writer);
+            streamWriteEndPosition = _stream.Position;
+
+            // Deserialize and Verify
+            _stream.Position = 0;
+            newGenericEvent = new BuildErrorEventArgs("Something", "SomeThing", "SomeThing", -1, -1, -1, -1, "Something", "SomeThing", "Something", "HelpLink", DateTime.Now);
+            newGenericEvent.CreateFromStream(_reader, _eventArgVersion);
+            _stream.Position.ShouldBe(streamWriteEndPosition); // "Stream End Positions Should Match"
+            VerifyGenericEventArg(genericEvent, newGenericEvent);
+            VerifyBuildErrorEventArgs(genericEvent, newGenericEvent);
         }
 
         /// <summary>
@@ -184,6 +201,7 @@ private static void VerifyBuildErrorEventArgs(BuildErrorEventArgs genericEvent,
             newGenericEvent.ColumnNumber.ShouldBe(genericEvent.ColumnNumber); // "Expected ColumnNumber to Match"
             newGenericEvent.EndColumnNumber.ShouldBe(genericEvent.EndColumnNumber); // "Expected EndColumnNumber to Match"
             newGenericEvent.EndLineNumber.ShouldBe(genericEvent.EndLineNumber); // "Expected EndLineNumber to Match"
+            newGenericEvent.HelpLink.ShouldBe(genericEvent.HelpLink); // "Expected HelpLink to Match"
         }
 
 
@@ -464,6 +482,23 @@ public void TestBuildWarningEventArgs()
             _stream.Position.ShouldBe(streamWriteEndPosition); // "Stream End Positions Should Match"
             VerifyGenericEventArg(genericEvent, newGenericEvent);
             VerifyBuildWarningEventArgs(genericEvent, newGenericEvent);
+
+            // Test with help link
+            _stream.Position = 0;
+            genericEvent = new BuildWarningEventArgs("Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "SenderName", "HelpLink", DateTime.Now, null);
+            genericEvent.BuildEventContext = new BuildEventContext(5, 4, 3, 2);
+
+            // Serialize
+            genericEvent.WriteToStream(_writer);
+            streamWriteEndPosition = _stream.Position;
+
+            // Deserialize and Verify
+            _stream.Position = 0;
+            newGenericEvent = new BuildWarningEventArgs("Something", "SomeThing", "SomeThing", -1, -1, -1, -1, "Something", "SomeThing", "Something");
+            newGenericEvent.CreateFromStream(_reader, _eventArgVersion);
+            _stream.Position.ShouldBe(streamWriteEndPosition); // "Stream End Positions Should Match"
+            VerifyGenericEventArg(genericEvent, newGenericEvent);
+            VerifyBuildWarningEventArgs(genericEvent, newGenericEvent);
         }
 
         /// <summary>
@@ -477,6 +512,7 @@ private static void VerifyBuildWarningEventArgs(BuildWarningEventArgs genericEve
             newGenericEvent.ColumnNumber.ShouldBe(genericEvent.ColumnNumber); // "Expected ColumnNumber to Match"
             newGenericEvent.EndColumnNumber.ShouldBe(genericEvent.EndColumnNumber); // "Expected EndColumnNumber to Match"
             newGenericEvent.EndLineNumber.ShouldBe(genericEvent.EndLineNumber); // "Expected EndLineNumber to Match"
+            newGenericEvent.HelpLink.ShouldBe(genericEvent.HelpLink); // "Expected HelpLink to Match"
         }
 
         [Fact]
diff --git a/src/Framework/BuildErrorEventArgs.cs b/src/Framework/BuildErrorEventArgs.cs
index 9542a6ce057..5d086d1850e 100644
--- a/src/Framework/BuildErrorEventArgs.cs
+++ b/src/Framework/BuildErrorEventArgs.cs
@@ -61,6 +61,11 @@ public class BuildErrorEventArgs : LazyFormattedBuildEventArgs
         /// </summary>
         private int endColumnNumber;
 
+        /// <summary>
+        /// A link pointing to more information about the error
+        /// </summary>
+        private string helpLink;
+
         /// <summary>
         /// This constructor allows all event data to be initialized
         /// </summary>
@@ -119,11 +124,12 @@ public BuildErrorEventArgs
             string senderName,
             DateTime eventTimestamp
             )
-            : this(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, eventTimestamp, null)
+            : this(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, null, eventTimestamp, null)
         {
             // do nothing
         }
 
+
         /// <summary>
         /// This constructor which allows a timestamp to be set
         /// </summary>
@@ -154,6 +160,43 @@ public BuildErrorEventArgs
             DateTime eventTimestamp,
             params object[] messageArgs
             )
+            : this(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, null, eventTimestamp, messageArgs)
+        {
+            // do nothing
+        }
+
+        /// <summary>
+        /// This constructor which allows a timestamp to be set
+        /// </summary>
+        /// <param name="subcategory">event sub-category</param>
+        /// <param name="code">event code</param>
+        /// <param name="file">file associated with the event</param>
+        /// <param name="lineNumber">line number (0 if not applicable)</param>
+        /// <param name="columnNumber">column number (0 if not applicable)</param>
+        /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+        /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+        /// <param name="message">text message</param>
+        /// <param name="helpKeyword">help keyword </param>
+        /// <param name="helpLink">A link pointing to more information about the error </param>
+        /// <param name="senderName">name of event sender</param>
+        /// <param name="eventTimestamp">Timestamp when event was created</param>
+        /// <param name="messageArgs">message arguments</param>
+        public BuildErrorEventArgs
+            (
+            string subcategory,
+            string code,
+            string file,
+            int lineNumber,
+            int columnNumber,
+            int endLineNumber,
+            int endColumnNumber,
+            string message,
+            string helpKeyword,
+            string senderName,
+            string helpLink,
+            DateTime eventTimestamp,
+            params object[] messageArgs
+            )
             : base(message, helpKeyword, senderName, eventTimestamp, messageArgs)
         {
             this.subcategory = subcategory;
@@ -163,6 +206,7 @@ params object[] messageArgs
             this.columnNumber = columnNumber;
             this.endLineNumber = endLineNumber;
             this.endColumnNumber = endColumnNumber;
+            this.helpLink = helpLink;
         }
 
         /// <summary>
@@ -175,18 +219,18 @@ protected BuildErrorEventArgs()
         }
 
         /// <summary>
-        /// The custom sub-type of the event.         
+        /// The custom sub-type of the event.
         /// </summary>
         public string Subcategory => subcategory;
 
         /// <summary>
-        /// Code associated with event. 
+        /// Code associated with event.
         /// </summary>
         public string Code => code;
 
         /// <summary>
-        /// File associated with event.   
-        /// </summary>  
+        /// File associated with event.
+        /// </summary>
         public string File => file;
 
         /// <summary>
@@ -199,25 +243,30 @@ public string ProjectFile
         }
 
         /// <summary>
-        /// Line number of interest in associated file. 
+        /// Line number of interest in associated file.
         /// </summary>
         public int LineNumber => lineNumber;
 
         /// <summary>
-        /// Column number of interest in associated file. 
+        /// Column number of interest in associated file.
         /// </summary>
         public int ColumnNumber => columnNumber;
 
         /// <summary>
-        /// Ending line number of interest in associated file. 
+        /// Ending line number of interest in associated file.
         /// </summary>
         public int EndLineNumber => endLineNumber;
 
         /// <summary>
-        /// Ending column number of interest in associated file. 
+        /// Ending column number of interest in associated file.
         /// </summary>
         public int EndColumnNumber => endColumnNumber;
 
+        /// <summary>
+        /// A link pointing to more information about the error.
+        /// </summary>
+        public string HelpLink => helpLink;
+
         #region CustomSerializationToStream
         /// <summary>
         /// Serializes to a stream through a binary writer
@@ -236,6 +285,8 @@ internal override void WriteToStream(BinaryWriter writer)
             writer.Write((Int32)columnNumber);
             writer.Write((Int32)endLineNumber);
             writer.Write((Int32)endColumnNumber);
+
+            writer.WriteOptionalString(helpLink);
         }
 
         /// <summary>
@@ -264,6 +315,15 @@ internal override void CreateFromStream(BinaryReader reader, int version)
             columnNumber = reader.ReadInt32();
             endLineNumber = reader.ReadInt32();
             endColumnNumber = reader.ReadInt32();
+
+            if (version >= 40)
+            {
+                helpLink = reader.ReadByte() == 0 ? null : reader.ReadString();
+            }
+            else
+            {
+                helpLink = null;
+            }
         }
         #endregion
     }
diff --git a/src/Framework/BuildEventContext.cs b/src/Framework/BuildEventContext.cs
index d744a273696..23f0488181d 100644
--- a/src/Framework/BuildEventContext.cs
+++ b/src/Framework/BuildEventContext.cs
@@ -219,12 +219,12 @@ public override int GetHashCode()
             var hash = 17;
             // submission ID does not contribute to equality
             //hash = hash * 31 + _submissionId;
-            hash = hash * 31 + _nodeId;
-            hash = hash * 31 + _evaluationId;
-            hash = hash * 31 + _targetId;
-            hash = hash * 31 + _projectContextId;
-            hash = hash * 31 + _taskId;
-            hash = hash * 31 + _projectInstanceId;
+            hash = (hash * 31) + _nodeId;
+            hash = (hash * 31) + _evaluationId;
+            hash = (hash * 31) + _targetId;
+            hash = (hash * 31) + _projectContextId;
+            hash = (hash * 31) + _taskId;
+            hash = (hash * 31) + _projectInstanceId;
 
             return hash;
         }
@@ -246,7 +246,7 @@ public override bool Equals(object obj)
                 return true;
             }
 
-            if (ReferenceEquals(obj, null))
+            if (obj is null)
             {
                 return false;
             }
@@ -273,7 +273,7 @@ public override bool Equals(object obj)
                 return true;
             }
 
-            if (ReferenceEquals(left, null))
+            if (left is null)
             {
                 return false;
             }
diff --git a/src/Framework/BuildWarningEventArgs.cs b/src/Framework/BuildWarningEventArgs.cs
index cfb39e143dc..0bf9641b45d 100644
--- a/src/Framework/BuildWarningEventArgs.cs
+++ b/src/Framework/BuildWarningEventArgs.cs
@@ -23,7 +23,7 @@ namespace Microsoft.Build.Framework
     public class BuildWarningEventArgs : LazyFormattedBuildEventArgs
     {
         /// <summary>
-        /// Default constructor 
+        /// Default constructor
         /// </summary>
         protected BuildWarningEventArgs()
             : base()
@@ -123,6 +123,42 @@ public BuildWarningEventArgs
             string senderName,
             DateTime eventTimestamp,
             params object[] messageArgs
+        ) : this(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, null, eventTimestamp, messageArgs)
+        {
+            // do nothing
+        }
+
+        /// <summary>
+        /// This constructor allows timestamp to be set
+        /// </summary>
+        /// <param name="subcategory">event subcategory</param>
+        /// <param name="code">event code</param>
+        /// <param name="file">file associated with the event</param>
+        /// <param name="lineNumber">line number (0 if not applicable)</param>
+        /// <param name="columnNumber">column number (0 if not applicable)</param>
+        /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+        /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+        /// <param name="message">text message</param>
+        /// <param name="helpKeyword">help keyword </param>
+        /// <param name="helpLink">A link pointing to more  information about the warning</param>
+        /// <param name="senderName">name of event sender</param>
+        /// <param name="eventTimestamp">custom timestamp for the event</param>
+        /// <param name="messageArgs">message arguments</param>
+        public BuildWarningEventArgs
+        (
+            string subcategory,
+            string code,
+            string file,
+            int lineNumber,
+            int columnNumber,
+            int endLineNumber,
+            int endColumnNumber,
+            string message,
+            string helpKeyword,
+            string senderName,
+            string helpLink,
+            DateTime eventTimestamp,
+            params object[] messageArgs
         )
             : base(message, helpKeyword, senderName, eventTimestamp, messageArgs)
         {
@@ -133,6 +169,7 @@ params object[] messageArgs
             this.columnNumber = columnNumber;
             this.endLineNumber = endLineNumber;
             this.endColumnNumber = endColumnNumber;
+            this.helpLink = helpLink;
         }
 
         private string subcategory;
@@ -143,6 +180,7 @@ params object[] messageArgs
         private int columnNumber;
         private int endLineNumber;
         private int endColumnNumber;
+        private string helpLink;
 
         #region CustomSerializationToStream
         /// <summary>
@@ -162,6 +200,8 @@ internal override void WriteToStream(BinaryWriter writer)
             writer.Write((Int32)columnNumber);
             writer.Write((Int32)endLineNumber);
             writer.Write((Int32)endColumnNumber);
+
+            writer.WriteOptionalString(helpLink);
         }
 
         /// <summary>
@@ -186,41 +226,50 @@ internal override void CreateFromStream(BinaryReader reader, int version)
             columnNumber = reader.ReadInt32();
             endLineNumber = reader.ReadInt32();
             endColumnNumber = reader.ReadInt32();
+
+            if (version >= 40)
+            {
+                helpLink = reader.ReadByte() == 0 ? null : reader.ReadString();
+            }
+            else
+            {
+                helpLink = null;
+            }
         }
         #endregion
 
         /// <summary>
-        /// The custom sub-type of the event.         
+        /// The custom sub-type of the event.
         /// </summary>
         public string Subcategory => subcategory;
 
         /// <summary>
-        /// Code associated with event. 
+        /// Code associated with event.
         /// </summary>
         public string Code => code;
 
         /// <summary>
-        /// File associated with event.   
+        /// File associated with event.
         /// </summary>
         public string File => file;
 
         /// <summary>
-        /// Line number of interest in associated file. 
+        /// Line number of interest in associated file.
         /// </summary>
         public int LineNumber => lineNumber;
 
         /// <summary>
-        /// Column number of interest in associated file. 
+        /// Column number of interest in associated file.
         /// </summary>
         public int ColumnNumber => columnNumber;
 
         /// <summary>
-        /// Ending line number of interest in associated file. 
+        /// Ending line number of interest in associated file.
         /// </summary>
         public int EndLineNumber => endLineNumber;
 
         /// <summary>
-        /// Ending column number of interest in associated file. 
+        /// Ending column number of interest in associated file.
         /// </summary>
         public int EndColumnNumber => endColumnNumber;
 
@@ -232,5 +281,10 @@ public string ProjectFile
             get => projectFile;
             set => projectFile = value;
         }
+
+        /// <summary>
+        /// A link pointing to more information about the warning.
+        /// </summary>
+        public string HelpLink => helpLink;
     }
 }
diff --git a/src/Framework/EnvironmentVariableReadEventArgs.cs b/src/Framework/EnvironmentVariableReadEventArgs.cs
index f34cade967b..809a1b097fd 100644
--- a/src/Framework/EnvironmentVariableReadEventArgs.cs
+++ b/src/Framework/EnvironmentVariableReadEventArgs.cs
@@ -22,6 +22,10 @@ public EnvironmentVariableReadEventArgs()
         /// Initializes an instance of the EnvironmentVariableReadEventArgs class.
         /// </summary>
         /// <param name="environmentVariableName">The name of the environment variable that was read.</param>
+        /// <param name="message">The value of the environment variable that was read.</param>
+        /// <param name="helpKeyword">Help keyword.</param>
+        /// <param name="senderName">The name of the sender of the event.</param>
+        /// <param name="importance">The importance of the message.</param>
         public EnvironmentVariableReadEventArgs(
             string environmentVariableName,
             string message,
diff --git a/src/Framework/IProjectElement.cs b/src/Framework/IProjectElement.cs
index a5eea6df205..9c2dff5336f 100644
--- a/src/Framework/IProjectElement.cs
+++ b/src/Framework/IProjectElement.cs
@@ -8,7 +8,6 @@ namespace Microsoft.Build.Framework
     /// </summary>
     public interface IProjectElement
     {
-
         /// <summary>
         /// Gets the name of the associated element. 
         /// Useful for display in some circumstances.
diff --git a/src/Framework/IRarBuildEngine.cs b/src/Framework/IRarBuildEngine.cs
new file mode 100644
index 00000000000..b5178887550
--- /dev/null
+++ b/src/Framework/IRarBuildEngine.cs
@@ -0,0 +1,28 @@
+Ôªø// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System.IO.Pipes;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// This interface provides necessary functionality from <see cref="Microsoft.Build"/> to RAR as a service functionality.
+    /// </summary>
+    internal interface IRarBuildEngine
+    {
+        /// <summary>
+        /// Inialize new RAR node
+        /// </summary>
+        internal bool CreateRarNode();
+
+        /// <summary>
+        /// Provides RAR node name for current configuration
+        /// </summary>
+        internal string GetRarPipeName();
+
+        /// <summary>
+        /// Constructs <seealso cref="NamedPipeClientStream"/>
+        /// </summary>
+        internal NamedPipeClientStream GetRarClientStream(string pipeName, int timeout);
+    }
+}
diff --git a/src/Framework/IRarController.cs b/src/Framework/IRarController.cs
new file mode 100644
index 00000000000..639daafb75a
--- /dev/null
+++ b/src/Framework/IRarController.cs
@@ -0,0 +1,18 @@
+Ôªøusing System;
+using System.Collections.Generic;
+using System.IO.Pipes;
+using System.Linq;
+using System.Text;
+using System.Threading;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// API for controller of ResolveAssemblyReference node
+    /// </summary>
+    internal interface IRarController
+    {
+        Task<int> StartAsync(CancellationToken token);
+    }
+}
diff --git a/src/Framework/LazyFormattedBuildEventArgs.cs b/src/Framework/LazyFormattedBuildEventArgs.cs
index 8c38696e5bc..9813392c45f 100644
--- a/src/Framework/LazyFormattedBuildEventArgs.cs
+++ b/src/Framework/LazyFormattedBuildEventArgs.cs
@@ -94,7 +94,7 @@ public override string Message
             {
                 lock (locker)
                 {
-                    if (arguments != null && arguments.Length > 0)
+                    if (arguments?.Length > 0)
                     {
                         if (originalCultureInfo == null)
                         {
@@ -196,7 +196,7 @@ private static string FormatString(CultureInfo culture, string unformatted, para
             string formatted = unformatted;
 
             // NOTE: String.Format() does not allow a null arguments array
-            if ((args != null) && (args.Length > 0))
+            if ((args?.Length > 0))
             {
 #if DEBUG
 
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index 0f547aea1fc..ae45efb429e 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -1,12 +1,7 @@
-Ôªøusing System;
-using System.Collections.Generic;
-using System.Diagnostics.Tracing;
-using System.Runtime.InteropServices;
-using System.Threading;
+Ôªøusing System.Diagnostics.Tracing;
 
 namespace Microsoft.Build.Eventing
 {
-
     /// <summary>
     /// This captures information of how various key methods of building with MSBuild ran.
     /// </summary>
@@ -281,7 +276,6 @@ public void RarLogResultsStop()
         [Event(33)]
         public void ParseStart(string projectFileName)
         {
-
             WriteEvent(33, projectFileName);
         }
 
@@ -333,7 +327,7 @@ public void SaveStop(string fileLocation)
             WriteEvent(40, fileLocation);
         }
 
-        /// <param name="targetName"/>The name of the target being executed.</param>
+        /// <param name="targetName">The name of the target being executed.</param>
         [Event(43)]
         public void TargetStart(string targetName)
         {
@@ -411,6 +405,24 @@ public void ProjectGraphConstructionStop(string graphEntryPoints)
         {
             WriteEvent(54, graphEntryPoints);
         }
+
+        [Event(55)]
+        public void PacketReadSize(int size)
+        {
+            WriteEvent(55, size);
+        }
+
+        [Event(56)]
+        public void ResolveAssemblyReferenceNodeConnectStart()
+        {
+            WriteEvent(56);
+        }
+
+        [Event(57)]
+        public void ResolveAssemblyReferenceNodeConnectStop()
+        {
+            WriteEvent(57);
+        }
         #endregion
     }
 }
diff --git a/src/Framework/Profiler/EvaluationLocation.cs b/src/Framework/Profiler/EvaluationLocation.cs
index 7eb1ede3978..61ff4933c84 100644
--- a/src/Framework/Profiler/EvaluationLocation.cs
+++ b/src/Framework/Profiler/EvaluationLocation.cs
@@ -255,16 +255,15 @@ public override string ToString()
         public override int GetHashCode()
         {
             var hashCode = 1198539463;
-            hashCode = hashCode * -1521134295 + base.GetHashCode();
-            hashCode = hashCode * -1521134295 + Id.GetHashCode();
-            hashCode = hashCode * -1521134295 + EqualityComparer<long?>.Default.GetHashCode(ParentId);
-            hashCode = hashCode * -1521134295 + EvaluationPass.GetHashCode();
-            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(EvaluationPassDescription);
-            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(File);
-            hashCode = hashCode * -1521134295 + EqualityComparer<int?>.Default.GetHashCode(Line);
-            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(ElementName);
-            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(ElementDescription);
-            hashCode = hashCode * -1521134295 + Kind.GetHashCode();
+            hashCode = (hashCode * -1521134295) + Id.GetHashCode();
+            hashCode = (hashCode * -1521134295) + EqualityComparer<long?>.Default.GetHashCode(ParentId);
+            hashCode = (hashCode * -1521134295) + EqualityComparer<EvaluationPass>.Default.GetHashCode(EvaluationPass);
+            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(EvaluationPassDescription);
+            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(File);
+            hashCode = (hashCode * -1521134295) + EqualityComparer<int?>.Default.GetHashCode(Line);
+            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ElementName);
+            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ElementDescription);
+            hashCode = (hashCode * -1521134295) + EqualityComparer<EvaluationLocationKind>.Default.GetHashCode(Kind);
             return hashCode;
         }
 
diff --git a/src/Framework/Profiler/ProfilerResult.cs b/src/Framework/Profiler/ProfilerResult.cs
index 61ceb229ae9..43cf2d62331 100644
--- a/src/Framework/Profiler/ProfilerResult.cs
+++ b/src/Framework/Profiler/ProfilerResult.cs
@@ -86,10 +86,9 @@ public override bool Equals(object obj)
         public override int GetHashCode()
         {
             var hashCode = -2131368567;
-            hashCode = hashCode * -1521134295 + base.GetHashCode();
-            hashCode = hashCode * -1521134295 + EqualityComparer<TimeSpan>.Default.GetHashCode(InclusiveTime);
-            hashCode = hashCode * -1521134295 + EqualityComparer<TimeSpan>.Default.GetHashCode(ExclusiveTime);
-            hashCode = hashCode * -1521134295 + NumberOfHits.GetHashCode();
+            hashCode = (hashCode * -1521134295) + EqualityComparer<TimeSpan>.Default.GetHashCode(InclusiveTime);
+            hashCode = (hashCode * -1521134295) + EqualityComparer<TimeSpan>.Default.GetHashCode(ExclusiveTime);
+            hashCode = (hashCode * -1521134295) + NumberOfHits.GetHashCode();
             return hashCode;
         }
 
diff --git a/src/Framework/ProjectEvaluationFinishedEventArgs.cs b/src/Framework/ProjectEvaluationFinishedEventArgs.cs
index 7179df89d9a..1d900b49c03 100644
--- a/src/Framework/ProjectEvaluationFinishedEventArgs.cs
+++ b/src/Framework/ProjectEvaluationFinishedEventArgs.cs
@@ -17,7 +17,6 @@ public sealed class ProjectEvaluationFinishedEventArgs : BuildStatusEventArgs
         /// </summary>
         public ProjectEvaluationFinishedEventArgs()
         {
-            
         }
 
         /// <summary>
diff --git a/src/Framework/ProjectEvaluationStartedEventArgs.cs b/src/Framework/ProjectEvaluationStartedEventArgs.cs
index f391d8825d6..80332d2c4f4 100644
--- a/src/Framework/ProjectEvaluationStartedEventArgs.cs
+++ b/src/Framework/ProjectEvaluationStartedEventArgs.cs
@@ -16,7 +16,6 @@ public class ProjectEvaluationStartedEventArgs : BuildStatusEventArgs
         /// </summary>
         public ProjectEvaluationStartedEventArgs()
         {
-
         }
 
         /// <summary>
diff --git a/src/Framework/PropertyInitialValueSetEventArgs.cs b/src/Framework/PropertyInitialValueSetEventArgs.cs
index 49754632277..d73247be932 100644
--- a/src/Framework/PropertyInitialValueSetEventArgs.cs
+++ b/src/Framework/PropertyInitialValueSetEventArgs.cs
@@ -22,6 +22,10 @@ public PropertyInitialValueSetEventArgs() { }
         /// <param name="propertyName">The name of the property.</param>
         /// <param name="propertyValue">The value of the property.</param>
         /// <param name="propertySource">The source of the property.</param>
+        /// <param name="message">The message of the property.</param>
+        /// <param name="helpKeyword">The help keyword.</param>
+        /// <param name="senderName">The sender name of the event.</param>
+        /// <param name="importance">The importance of the message.</param>
         public PropertyInitialValueSetEventArgs(
             string propertyName,
             string propertyValue,
diff --git a/src/Framework/PropertyReassignmentEventArgs.cs b/src/Framework/PropertyReassignmentEventArgs.cs
index 6de36dab633..7f9ccb491a5 100644
--- a/src/Framework/PropertyReassignmentEventArgs.cs
+++ b/src/Framework/PropertyReassignmentEventArgs.cs
@@ -25,6 +25,10 @@ public PropertyReassignmentEventArgs()
         /// <param name="previousValue">The previous value of the reassigned property.</param>
         /// <param name="newValue">The new value of the reassigned property.</param>
         /// <param name="location">The location of the reassignment.</param>
+        /// <param name="message">The message of the reassignment event.</param>
+        /// <param name="helpKeyword">The help keyword of the reassignment.</param>
+        /// <param name="senderName">The sender name of the reassignment event.</param>
+        /// <param name="importance">The importance of the message.</param>
         public PropertyReassignmentEventArgs(
             string propertyName,
             string previousValue,
diff --git a/src/Framework/Sdk/SdkReference.cs b/src/Framework/Sdk/SdkReference.cs
index 9be25528bcc..f48c8444bbc 100644
--- a/src/Framework/Sdk/SdkReference.cs
+++ b/src/Framework/Sdk/SdkReference.cs
@@ -50,7 +50,7 @@ public SdkReference(string name, string version, string minimumVersion)
         /// <returns></returns>
         public bool Equals(SdkReference other)
         {
-            if (ReferenceEquals(null, other)) return false;
+            if (other is null) return false;
             if (ReferenceEquals(this, other)) return true;
             return string.Equals(Name, other.Name, StringComparison.OrdinalIgnoreCase) &&
                    string.Equals(Version, other.Version, StringComparison.OrdinalIgnoreCase) &&
@@ -94,7 +94,7 @@ public static bool TryParse(string sdk, out SdkReference sdkReference)
         /// <inheritdoc />
         public override bool Equals(object obj)
         {
-            if (ReferenceEquals(null, obj)) return false;
+            if (obj is null) return false;
             if (ReferenceEquals(this, obj)) return true;
             return obj is SdkReference && Equals((SdkReference) obj);
         }
diff --git a/src/Framework/Sdk/SdkResolverContext.cs b/src/Framework/Sdk/SdkResolverContext.cs
index 1cb1260c30d..df8c5f3f148 100644
--- a/src/Framework/Sdk/SdkResolverContext.cs
+++ b/src/Framework/Sdk/SdkResolverContext.cs
@@ -15,6 +15,11 @@ public abstract class SdkResolverContext
         /// </summary>
         public virtual bool Interactive { get; protected set; }
 
+        /// <summary>
+        /// Gets a value indicating if the resolver is running in Visual Studio.
+        /// </summary>
+        public virtual bool IsRunningInVisualStudio { get; protected set; }
+
         /// <summary>
         ///     Logger to log real-time messages back to MSBuild.
         /// </summary>
diff --git a/src/Framework/Sdk/SdkResultFactory.cs b/src/Framework/Sdk/SdkResultFactory.cs
index 1016680adc5..70f672cd62e 100644
--- a/src/Framework/Sdk/SdkResultFactory.cs
+++ b/src/Framework/Sdk/SdkResultFactory.cs
@@ -21,6 +21,24 @@ public abstract class SdkResultFactory
         /// <returns></returns>
         public abstract SdkResult IndicateSuccess(string path, string version, IEnumerable<string> warnings = null);
 
+        /// <summary>
+        ///     Create an <see cref="SdkResolver" /> object indicating success resolving the SDK.
+        /// </summary>
+        /// <param name="path">Path to the SDK.</param>
+        /// <param name="version">Version of the SDK that was resolved.</param>
+        /// <param name="propertiesToAdd">Properties to set in the evaluation</param>
+        /// <param name="itemsToAdd">Items to add to the evaluation</param>
+        /// <param name="warnings">Optional warnings to display during resolution.</param>
+        /// <returns></returns>
+        public virtual SdkResult IndicateSuccess(string path,
+            string version,
+            IDictionary<string, string> propertiesToAdd,
+            IDictionary<string, SdkResultItem> itemsToAdd,
+            IEnumerable<string> warnings = null)
+        {
+            throw new NotImplementedException();
+        }
+
         /// <summary>
         ///     Create an <see cref="SdkResolver" /> object indicating success.
         /// </summary>
@@ -31,6 +49,7 @@ public abstract class SdkResultFactory
         /// components to take more appropriate action (for example installing optional workloads or downloading NuGet SDKs).
         /// </remarks>
         /// <param name="paths">SDK paths which should be imported</param>
+        /// <param name="version">SDK version which should be imported</param>
         /// <param name="propertiesToAdd">Properties to set in the evaluation</param>
         /// <param name="itemsToAdd">Items to add to the evaluation</param>
         /// <param name="warnings">Optional warnings to display during resolution.</param>
diff --git a/src/Framework/Sdk/SdkResultItem.cs b/src/Framework/Sdk/SdkResultItem.cs
index 0ed9de3114e..ca76abd1421 100644
--- a/src/Framework/Sdk/SdkResultItem.cs
+++ b/src/Framework/Sdk/SdkResultItem.cs
@@ -58,14 +58,14 @@ public override bool Equals(object obj)
         public override int GetHashCode()
         {
             int hashCode = -849885975;
-            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(ItemSpec);
+            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ItemSpec);
 
             if (Metadata != null)
             {
                 foreach (var kvp in Metadata)
                 {
-                    hashCode = hashCode * -1521134295 + kvp.Key.GetHashCode();
-                    hashCode = hashCode * -1521134295 + kvp.Value.GetHashCode();
+                    hashCode = (hashCode * -1521134295) + kvp.Key.GetHashCode();
+                    hashCode = (hashCode * -1521134295) + kvp.Value.GetHashCode();
                 }
             }
 
diff --git a/src/Framework/TaskPropertyInfo.cs b/src/Framework/TaskPropertyInfo.cs
index eb5808ef40b..bbda09f9634 100644
--- a/src/Framework/TaskPropertyInfo.cs
+++ b/src/Framework/TaskPropertyInfo.cs
@@ -17,7 +17,7 @@ public class TaskPropertyInfo
         /// </summary>
         /// <param name="name">Name of the parameter</param>
         /// <param name="typeOfParameter">The actual type of the parameter</param>
-        /// <param name="output">True if the parameter is both an output and and input parameter. False if the parameter is only an input parameter</param>
+        /// <param name="output">True if the parameter is both an output and input parameter. False if the parameter is only an input parameter</param>
         /// <param name="required">True if the parameter must be supplied to each invocation of the task.</param>
         public TaskPropertyInfo(string name, Type typeOfParameter, bool output, bool required)
         {
diff --git a/src/Framework/UninitializedPropertyReadEventArgs.cs b/src/Framework/UninitializedPropertyReadEventArgs.cs
index 62448bdb008..fa11b3c8f89 100644
--- a/src/Framework/UninitializedPropertyReadEventArgs.cs
+++ b/src/Framework/UninitializedPropertyReadEventArgs.cs
@@ -22,6 +22,10 @@ public UninitializedPropertyReadEventArgs()
         /// Creates an instance of the UninitializedPropertyReadEventArgs class
         /// </summary>
         /// <param name="propertyName">The name of the uninitialized property that was read.</param>
+        /// <param name="message">The message of the uninitialized property that was read.</param>
+        /// <param name="helpKeyword">The helpKeyword of the uninitialized property that was read.</param>
+        /// <param name="senderName">The sender name of the event.</param>
+        /// <param name="importance">The message importance of the event.</param>
         public UninitializedPropertyReadEventArgs(
             string propertyName,
             string message,
diff --git a/src/Framework/XamlTypes/ContentType.cs b/src/Framework/XamlTypes/ContentType.cs
index 5eb55529bba..0fe304b22fc 100644
--- a/src/Framework/XamlTypes/ContentType.cs
+++ b/src/Framework/XamlTypes/ContentType.cs
@@ -96,7 +96,7 @@ public string GetMetadata(string metadataName)
         {
             if (String.IsNullOrEmpty(metadataName))
             {
-                throw new ArgumentNullException("metadataName");
+                throw new ArgumentNullException(nameof(metadataName));
             }
 
             string value;
diff --git a/src/Framework/XamlTypes/DataSource.cs b/src/Framework/XamlTypes/DataSource.cs
index 64c683badc6..515bbaa392c 100644
--- a/src/Framework/XamlTypes/DataSource.cs
+++ b/src/Framework/XamlTypes/DataSource.cs
@@ -27,8 +27,8 @@ public enum DefaultValueSourceLocation
     /// <summary>
     /// Represents the location and grouping for a <see cref="BaseProperty"/>.
     /// </summary>
-    /// <remarks> 
-    /// Those who manually 
+    /// <remarks>
+    /// Those who manually
     /// instantiate this class should remember to call <see cref="BeginInit"/> before setting the first
     /// property and <see cref="EndInit"/> after setting the last property of the object.
     /// </remarks>
@@ -52,12 +52,12 @@ public DataSource()
         #region Properties
 
         /// <summary>
-        /// The storage location for this data source. 
+        /// The storage location for this data source.
         /// </summary>
         /// <remarks>
-        /// This field is mandatory unless <see cref="PersistenceStyle"/> is set. In that case, the parent 
-        /// <see cref="DataSource"/> will be used with the specified style. Example values are <c>ProjectFile</c> and 
-        /// <c>UserFile</c>. <c>ProjectFile</c> causes the property value to be written to and read from the project 
+        /// This field is mandatory unless <see cref="PersistenceStyle"/> is set. In that case, the parent
+        /// <see cref="DataSource"/> will be used with the specified style. Example values are <c>ProjectFile</c> and
+        /// <c>UserFile</c>. <c>ProjectFile</c> causes the property value to be written to and read from the project
         /// manifest file or the property sheet (depending on which node in the solution explorer/property manager window
         /// is used to spawn the property pages UI). <c>UserFile</c> causes the property value to be written to and read
         /// from the .user file.
@@ -72,7 +72,7 @@ public string Persistence
         /// The storage style for this data source.
         /// </summary>
         /// <remarks>
-        /// For example, with <see cref="Persistence"/> of <c>ProjectFile</c>, this field can be <c>Element</c> (default) to 
+        /// For example, with <see cref="Persistence"/> of <c>ProjectFile</c>, this field can be <c>Element</c> (default) to
         /// save as a child XML Element, or <c>Attribute</c> to save properties as an XML attribute.
         /// </remarks>
         public string PersistenceStyle
@@ -146,7 +146,7 @@ public bool HasConfigurationCondition
         /// Among other things this governs how the data is treated during build.
         /// </summary>
         /// <example>
-        /// A value of <c>Item</c> for this property indicates that this property is actually 
+        /// A value of <c>Item</c> for this property indicates that this property is actually
         /// an item array - the list of all items with the item type specified by <see cref="ItemType"/>.
         /// </example>
         public string SourceType
diff --git a/src/Framework/XamlTypes/Rule.cs b/src/Framework/XamlTypes/Rule.cs
index caac61eec3a..5893a27acf7 100644
--- a/src/Framework/XamlTypes/Rule.cs
+++ b/src/Framework/XamlTypes/Rule.cs
@@ -422,7 +422,7 @@ public List<Category> EvaluatedCategories
                 // check-lock-check pattern DOESN'T work here because two fields get initialized within this lazy initialization method.
                 lock (_syncObject)
                 {
-                    if (null == _evaluatedCategories)
+                    if (_evaluatedCategories == null)
                     {
                         CreateCategoryNamePropertyListMap();
                     }
@@ -453,7 +453,7 @@ public OrderedDictionary GetPropertiesByCategory()
             // check-lock-check pattern DOESN'T work here because two fields get initialized within this lazy initialization method.
             lock (_syncObject)
             {
-                if (null == _categoryNamePropertyListMap)
+                if (_categoryNamePropertyListMap == null)
                 {
                     CreateCategoryNamePropertyListMap();
                 }
@@ -471,7 +471,7 @@ public IList<BaseProperty> GetPropertiesInCategory(string categoryName)
             // check-lock-check pattern DOESN'T work here because two fields get initialized within this lazy initialization method.
             lock (_syncObject)
             {
-                if (null == _categoryNamePropertyListMap)
+                if (_categoryNamePropertyListMap == null)
                 {
                     CreateCategoryNamePropertyListMap();
                 }
@@ -557,7 +557,7 @@ public IEnumerable<object> GetSchemaObjects(Type type)
         /// </summary>
         private void Initialize()
         {
-            if (null != Properties)
+            if (Properties != null)
             {
                 // Set parent pointers on all containing properties.
                 foreach (BaseProperty property in Properties)
@@ -577,7 +577,7 @@ private void CreateCategoryNamePropertyListMap()
             {
                 _evaluatedCategories = new List<Category>();
 
-                if (null != Categories)
+                if (Categories != null)
                 {
                     _evaluatedCategories.AddRange(Categories);
                 }
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index 04697b84240..5fee06a9d1e 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -1265,7 +1265,6 @@ public void HelpMessagesAreValid()
                         // Ignore empty lines
                         if (!String.IsNullOrWhiteSpace(helpMessageLines[i]))
                         {
-
                             if (item.Key.Contains("Examples"))
                             {
                                 // Examples require a certain number of leading spaces
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 6c4a2e79218..a2cc9a8d075 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -659,7 +659,6 @@ public void ConfigurationInvalid()
             // if there's not, we will catch when we try to read the toolsets. Either is fine; we just want to not crash.
             (output.Contains("MSB1043") || output.Contains("MSB4136")).ShouldBeTrue("Output should contain 'MSB1043' or 'MSB4136'");
 
-
         }
 #endif
 
@@ -1424,14 +1423,12 @@ public void TestProcessProjectSwitch()
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
             MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
 
-
             projects = new string[] { "test.sln~", "test.sln" };
             extensionsToIgnore = new string[] { };
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
             MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
         }
 
-
         /// <summary>
         /// Ignore .sln and .vcproj files to replicate Building_DF_LKG functionality
         /// </summary>
@@ -1444,7 +1441,6 @@ public void TestProcessProjectSwitchReplicateBuildingDFLKG()
             MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.proj"); // "Expected test.proj to be only project found"
         }
 
-
         /// <summary>
         /// Test the case where we remove all of the project extensions that exist in the directory
         /// </summary>
@@ -1584,14 +1580,14 @@ internal string[] GetFiles(string path, string searchPattern)
                 List<string> fileNamesToReturn = new List<string>();
                 foreach (string file in _directoryFileNameList)
                 {
-                    if (String.Compare(searchPattern, "*.sln", StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(searchPattern, "*.sln", StringComparison.OrdinalIgnoreCase))
                     {
-                        if (String.Compare(Path.GetExtension(file), ".sln", StringComparison.OrdinalIgnoreCase) == 0)
+                        if (String.Equals(Path.GetExtension(file), ".sln", StringComparison.OrdinalIgnoreCase))
                         {
                             fileNamesToReturn.Add(file);
                         }
                     }
-                    else if (String.Compare(searchPattern, "*.*proj", StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(searchPattern, "*.*proj", StringComparison.OrdinalIgnoreCase))
                     {
                         if (Path.GetExtension(file).Contains("proj"))
                         {
@@ -1903,7 +1899,7 @@ public void ProcessConsoleLoggerSwitches()
         {
             ArrayList loggers = new ArrayList();
             LoggerVerbosity verbosity = LoggerVerbosity.Normal;
-            List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>(); ;
+            List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>(); 
             string[] consoleLoggerParameters = new string[6] { "Parameter1", ";Parameter;", "", ";", ";Parameter", "Parameter;" };
 
             MSBuildApp.ProcessConsoleLoggerSwitch
@@ -2208,7 +2204,6 @@ public void TasksGetAssemblyLoadContexts()
 
 #endif
 
-
         private string CopyMSBuild()
         {
             string dest = null;
diff --git a/src/MSBuild/CommandLineSwitchException.cs b/src/MSBuild/CommandLineSwitchException.cs
index dd02ff90a83..2563e623a45 100644
--- a/src/MSBuild/CommandLineSwitchException.cs
+++ b/src/MSBuild/CommandLineSwitchException.cs
@@ -46,7 +46,6 @@ string commandLineArg
             this.commandLineArg = commandLineArg;
         }
 
-
         /// <summary>
         /// Serialization constructor
         /// </summary>
@@ -58,7 +57,7 @@ StreamingContext context
             base(info, context)
 
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
             commandLineArg = info.GetString("commandLineArg");
         }
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index 9f2af74b651..9e3a7923e83 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -197,7 +197,6 @@ bool emptyParametersAllowed
             internal bool emptyParametersAllowed;
         }
 
-
         // map switches that do not take parameters to their identifiers (taken from ParameterlessSwitch enum)
         // WARNING: keep this map in the same order as the ParameterlessSwitch enumeration
         private static readonly ParameterlessSwitchInfo[] s_parameterlessSwitchesMap =
@@ -299,7 +298,7 @@ out string duplicateSwitchErrorMessage
             {
                 foreach (string parameterlessSwitchName in switchInfo.switchNames)
                 {
-                    if (String.Compare(switchName, parameterlessSwitchName, StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(switchName, parameterlessSwitchName, StringComparison.OrdinalIgnoreCase))
                     {
                         parameterlessSwitch = switchInfo.parameterlessSwitch;
                         duplicateSwitchErrorMessage = switchInfo.duplicateSwitchErrorMessage;
@@ -308,7 +307,7 @@ out string duplicateSwitchErrorMessage
                 }
             }
 
-            return (parameterlessSwitch != ParameterlessSwitch.Invalid);
+            return parameterlessSwitch != ParameterlessSwitch.Invalid;
         }
 
         /// <summary>
@@ -369,7 +368,7 @@ out bool emptyParametersAllowed
                 }
             }
 
-            return (parameterizedSwitch != ParameterizedSwitch.Invalid);
+            return parameterizedSwitch != ParameterizedSwitch.Invalid;
         }
 
         /// <summary>
@@ -498,7 +497,6 @@ bool emptyParametersAllowed
                     // check if they were all stored successfully i.e. they were all non-empty (after removing quoting, if requested)
                     parametersStored = (emptyParameters == 0);
                 }
-
             }
             else
             {
@@ -560,7 +558,7 @@ internal string GetEquivalentCommandLineExceptProjectFile()
         /// <returns>true, if switch has been seen before</returns>
         internal bool IsParameterlessSwitchSet(ParameterlessSwitch parameterlessSwitch)
         {
-            return (_parameterlessSwitches[(int)parameterlessSwitch].commandLineArg != null);
+            return _parameterlessSwitches[(int)parameterlessSwitch].commandLineArg != null;
         }
 
         /// <summary>
@@ -575,7 +573,7 @@ internal bool this[ParameterlessSwitch parameterlessSwitch]
         {
             get
             {
-                return (_parameterlessSwitches[(int)parameterlessSwitch].commandLineArg != null);
+                return _parameterlessSwitches[(int)parameterlessSwitch].commandLineArg != null;
             }
         }
 
@@ -597,7 +595,7 @@ internal string GetParameterlessSwitchCommandLineArg(ParameterlessSwitch paramet
         /// <returns>true, if switch has been seen before</returns>
         internal bool IsParameterizedSwitchSet(ParameterizedSwitch parameterizedSwitch)
         {
-            return (_parameterizedSwitches[(int)parameterizedSwitch].commandLineArg != null);
+            return _parameterizedSwitches[(int)parameterizedSwitch].commandLineArg != null;
         }
 
         // used to indicate a null parameter list for a switch
@@ -792,7 +790,7 @@ private void SetError(string messageResourceNameValue, string badCommandLineArgV
         /// <returns>true, if any errors were found</returns>
         internal bool HaveErrors()
         {
-            return (_errorMessage != null);
+            return _errorMessage != null;
         }
 
         /// <summary>
diff --git a/src/MSBuild/InitializationException.cs b/src/MSBuild/InitializationException.cs
index c8584f04930..e12b6c3000a 100644
--- a/src/MSBuild/InitializationException.cs
+++ b/src/MSBuild/InitializationException.cs
@@ -63,7 +63,7 @@ StreamingContext context
             base(info, context)
 
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
             invalidSwitch = info.GetString("invalidSwitch");
         }
@@ -152,7 +152,7 @@ internal static void Throw(string messageResourceName, string invalidSwitch, Exc
             else
             {
                 // the exception message can contain a format item i.e. "{0}" to hold the given exception's message
-                errorMessage = ResourceUtilities.FormatString(errorMessage, ((e == null) ? String.Empty : e.Message));
+                errorMessage = ResourceUtilities.FormatString(errorMessage, (e == null) ? String.Empty : e.Message);
             }
 
             InitializationException.Throw(errorMessage, invalidSwitch);
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 0d230763e6b..74b1c3e0d35 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -141,6 +141,7 @@
     <Compile Include="..\Shared\TaskLoader.cs" />
     <Compile Include="..\Shared\MSBuildLoadContext.cs" Condition="'$(TargetFrameworkIdentifier)'!='.NETFramework'" />
     <Compile Include="..\Shared\TypeLoader.cs" />
+    <Compile Include="..\Shared\NamedPipeUtil.cs" />
     <Compile Include="..\Shared\LoadedType.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -216,16 +217,9 @@
     <Content Include="MSBuild.rsp" Pack="false">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </Content>
-    <None Include="MSBuild\Microsoft.Build.CommonTypes.xsd">
-      <SubType>Designer</SubType>
-      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-    </None>
-    <None Include="MSBuild\Microsoft.Build.Core.xsd">
-      <SubType>Designer</SubType>
-      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-    </None>
-    <None Include="Microsoft.Build.xsd">
-      <SubType>Designer</SubType>
+    <XsdsForVS Include="**\*.xsd" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)" />
+    <XsdsForVS Include="Update-MSBuildXsds.ps1" />
+    <None Include="@(XsdsForVS)">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </None>
   </ItemGroup>
@@ -247,6 +241,14 @@
     <ProjectReference Include="..\Tasks\Microsoft.Build.Tasks.csproj" />
   </ItemGroup>
 
+  <Target Name="CopyXsds"
+          BeforeTargets="AfterBuild">
+    <Copy SourceFiles="@(XsdsForVS)"
+          DestinationFiles="@(XsdsForVS->'$([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'xsd'))%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="$(SkipCopyUnchangedFiles)"
+          />
+  </Target>
+
   <!-- Include MSBuild.deps.json and MSBuild.runtimeconfig.json in ContentWithTargetPath so they will be copied to the output folder of projects
        that reference this one. -->
   <Target Name="AddRuntimeDependenciesToContent" Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp'" BeforeTargets="GetCopyToOutputDirectoryItems">
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 3f21a504d85..1e8dc5f827b 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -1541,6 +1541,7 @@ elementFormDefault="qualified">
             <xs:documentation><!-- _locID_text="InstallFrom" _locComment="" -->Web, Unc, or Disk</xs:documentation>
         </xs:annotation>
     </xs:element>
+    <xs:element name="AnalysisLevel" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="InstallUrl" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="IsCodeSharingProject" type="msb:boolean" substitutionGroup="msb:Property"/>
     <xs:element name="IsWebBootstrapper" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
@@ -1651,6 +1652,14 @@ elementFormDefault="qualified">
       <xs:annotation>
         <xs:documentation><!-- _locID_text="Nullable" _locComment="" -->Set the nullable annotations and warnings context for the C# project. Possible values are enable, disable, warnings and annotations.</xs:documentation>
       </xs:annotation>
+      <xs:simpleType>
+        <xs:restriction base="xs:string">
+          <xs:enumeration value="enable" />
+          <xs:enumeration value="disable" />
+          <xs:enumeration value="warnings" />
+          <xs:enumeration value="annotations" />
+        </xs:restriction>
+      </xs:simpleType>
     </xs:element>
     <xs:element name="Platform" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="PlatformName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
@@ -1808,7 +1817,7 @@ elementFormDefault="qualified">
     <xs:element name="VSTO_TrustAssembliesLocation" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="WarningLevel" type="msb:StringPropertyType" substitutionGroup="msb:Property">
         <xs:annotation>
-            <xs:documentation><!-- _locID_text="WarningLevel" _locComment="" -->integer between 0 and 4 inclusive</xs:documentation>
+            <xs:documentation><!-- _locID_text="WarningLevel" _locComment="" -->integer between 0 and 5 inclusive</xs:documentation>
         </xs:annotation>
     </xs:element>
     <xs:element name="WarningsAsErrors" type="msb:StringPropertyType" substitutionGroup="msb:Property">
diff --git a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
index 6029f16baf0..a03db6f636f 100644
--- a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
+++ b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
@@ -27,17 +27,9 @@ internal NodeEndpointOutOfProcTaskHost(string pipeName)
         /// <summary>
         /// Returns the host handshake for this node endpoint
         /// </summary>
-        protected override long GetHostHandshake()
+        protected override Handshake GetHandshake()
         {
-            return CommunicationsUtilities.GetHostHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: true));
-        }
-
-        /// <summary>
-        /// Returns the client handshake for this node endpoint
-        /// </summary>
-        protected override long GetClientHandshake()
-        {
-            return CommunicationsUtilities.GetClientHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: true));
+            return new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: true));
         }
     }
 }
diff --git a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
index 463e12c5f2c..19cffc08b6d 100644
--- a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
+++ b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
@@ -360,7 +360,7 @@ IDictionary<string, TaskParameter> taskParams
                 try
                 {
                     PropertyInfo paramInfo = wrappedTask.GetType().GetProperty(param.Key, BindingFlags.Instance | BindingFlags.Public);
-                    paramInfo.SetValue(wrappedTask, (param.Value == null ? null : param.Value.WrappedParameter), null);
+                    paramInfo.SetValue(wrappedTask, param.Value?.WrappedParameter, null);
                 }
                 catch (Exception e)
                 {
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index 9050a35fd48..14375770a96 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -178,10 +178,6 @@ public OutOfProcTaskHostNode()
             // was initially launched. 
             _debugCommunications = (Environment.GetEnvironmentVariable("MSBUILDDEBUGCOMM") == "1");
 
-#if FEATURE_APPDOMAIN
-            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(ExceptionHandling.UnhandledExceptionHandler);
-#endif
-
             _receivedPackets = new Queue<INodePacket>();
 
             // These WaitHandles are disposed in HandleShutDown()
@@ -626,7 +622,7 @@ private void HandlePacket(INodePacket packet)
         /// </summary>
         private void HandleTaskHostConfiguration(TaskHostConfiguration taskHostConfiguration)
         {
-            ErrorUtilities.VerifyThrow(_isTaskExecuting == false, "Why are we getting a TaskHostConfiguration packet while we're still executing a task?");
+            ErrorUtilities.VerifyThrow(!_isTaskExecuting, "Why are we getting a TaskHostConfiguration packet while we're still executing a task?");
             _currentConfiguration = taskHostConfiguration;
 
             // Kick off the task running thread.
@@ -640,7 +636,7 @@ private void HandleTaskHostConfiguration(TaskHostConfiguration taskHostConfigura
         /// </summary>
         private void CompleteTask()
         {
-            ErrorUtilities.VerifyThrow(_isTaskExecuting == false, "The task should be done executing before CompleteTask.");
+            ErrorUtilities.VerifyThrow(!_isTaskExecuting, "The task should be done executing before CompleteTask.");
             if (_nodeEndpoint.LinkStatus == LinkStatus.Active)
             {
                 TaskHostTaskComplete taskCompletePacketToSend;
@@ -678,7 +674,7 @@ private void CancelTask()
 
             // Store in a local to avoid a race
             var wrapper = _taskWrapper;
-            if (wrapper != null && !wrapper.CancelTask())
+            if (wrapper?.CancelTask() == false)
             {
                 // Create a possibility for the task to be aborted if the user really wants it dropped dead asap
                 if (Environment.GetEnvironmentVariable("MSBUILDTASKHOSTABORTTASKONCANCEL") == "1")
@@ -715,10 +711,7 @@ private void HandleNodeBuildComplete(NodeBuildComplete buildComplete)
         private NodeEngineShutdownReason HandleShutdown()
         {
             // Wait for the RunTask task runner thread before shutting down so that we can cleanly dispose all WaitHandles.
-            if (_taskRunnerThread != null)
-            {
-                _taskRunnerThread.Join();
-            }
+            _taskRunnerThread?.Join();
 
             if (_debugCommunications)
             {
@@ -1051,8 +1044,8 @@ private void InitializeMismatchedEnvironmentTable(IDictionary<string, string> en
 
                 foreach (string variable in _savedEnvironment.Keys)
                 {
-                    string newValue = null;
                     string oldValue = _savedEnvironment[variable];
+                    string newValue;
                     if (!environment.TryGetValue(variable, out newValue))
                     {
                         s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(null, oldValue);
@@ -1069,7 +1062,7 @@ private void InitializeMismatchedEnvironmentTable(IDictionary<string, string> en
                 foreach (string variable in environment.Keys)
                 {
                     string newValue = environment[variable];
-                    string oldValue = null;
+                    string oldValue;
                     if (!_savedEnvironment.TryGetValue(variable, out oldValue))
                     {
                         s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(newValue, null);
@@ -1090,7 +1083,7 @@ private void InitializeMismatchedEnvironmentTable(IDictionary<string, string> en
         /// </summary>
         private void SendBuildEvent(BuildEventArgs e)
         {
-            if (_nodeEndpoint != null && _nodeEndpoint.LinkStatus == LinkStatus.Active)
+            if (_nodeEndpoint?.LinkStatus == LinkStatus.Active)
             {
                 if (!e.GetType().GetTypeInfo().IsSerializable)
                 {
diff --git a/src/MSBuild/ProjectSchemaValidationHandler.cs b/src/MSBuild/ProjectSchemaValidationHandler.cs
index 89a92070750..8620083844b 100644
--- a/src/MSBuild/ProjectSchemaValidationHandler.cs
+++ b/src/MSBuild/ProjectSchemaValidationHandler.cs
@@ -38,10 +38,10 @@ internal static void VerifyProjectSchema
             string binPath
         )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentNull(binPath, "binPath");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentNull(binPath, nameof(binPath));
 
-            if ((schemaFile == null) || (schemaFile.Length == 0))
+            if (string.IsNullOrEmpty(schemaFile))
             {
                 schemaFile = Path.Combine(binPath, "Microsoft.Build.xsd");
             }
@@ -76,8 +76,8 @@ private void VerifyProjectSchema
             string schemaFile
         )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(schemaFile, "schemaFile");
-            ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile");
+            ErrorUtilities.VerifyThrowArgumentNull(schemaFile, nameof(schemaFile));
+            ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
 
             // Options for XmlReader object can be set only in constructor. After the object is created, they
             // become read-only. Because of that we need to create
@@ -86,7 +86,7 @@ string schemaFile
             XmlReaderSettings validatorSettings = new XmlReaderSettings();
             validatorSettings.ValidationType = ValidationType.Schema;
             validatorSettings.XmlResolver = null;
-            validatorSettings.ValidationEventHandler += new ValidationEventHandler(this.OnSchemaValidationError);
+            validatorSettings.ValidationEventHandler += this.OnSchemaValidationError;
 
             XmlTextReader schemaReader = new XmlTextReader(schemaFile);
             schemaReader.DtdProcessing = DtdProcessing.Ignore;
diff --git a/src/MSBuild/Update-MSBuildXsds.ps1 b/src/MSBuild/Update-MSBuildXsds.ps1
new file mode 100644
index 00000000000..ef22f59d4ca
--- /dev/null
+++ b/src/MSBuild/Update-MSBuildXsds.ps1
@@ -0,0 +1,9 @@
+$ErrorActionPreference = 'Stop'
+
+$vsXsdPath = "src\xmake\XMakeCommandLine"
+
+Write-Host "Updating XSDs in $(Resolve-Path $vsXsdPath)"
+
+Copy-Item -Path (Join-Path $PSScriptRoot "Microsoft.Build.xsd") -Destination $vsXsdPath -Force
+Copy-Item -Path (Join-Path $PSScriptRoot "MSBuild\Microsoft.Build.CommonTypes.xsd") -Destination $vsXsdPath -Force
+Copy-Item -Path (Join-Path $PSScriptRoot "MSBuild\Microsoft.Build.Core.xsd") -Destination $vsXsdPath -Force
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 524d4dc1141..0640d2d95e2 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using System.ComponentModel;
 #if FEATURE_SYSTEM_CONFIGURATION
 using System.Configuration;
 #endif
@@ -293,7 +294,7 @@ private static void DumpCounters(bool initializeOnly)
 
             if (!initializeOnly)
             {
-                Console.WriteLine("\n{0}{1}{0}", new String('=', 41 - "Process".Length / 2), "Process");
+                Console.WriteLine("\n{0}{1}{0}", new String('=', 41 - ("Process".Length / 2)), "Process");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Peak Working Set", currentProcess.PeakWorkingSet64, "bytes");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Peak Paged Memory", currentProcess.PeakPagedMemorySize64, "bytes"); // Not very useful one
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Peak Virtual Memory", currentProcess.PeakVirtualMemorySize64, "bytes"); // Not very useful one
@@ -363,7 +364,7 @@ private static void DumpAllInCategory(string currentInstance, PerformanceCounter
 
             if (!initializeOnly)
             {
-                Console.WriteLine("\n{0}{1}{0}", new String('=', 41 - category.CategoryName.Length / 2), category.CategoryName);
+                Console.WriteLine("\n{0}{1}{0}", new String('=', 41 - (category.CategoryName.Length / 2)), category.CategoryName);
             }
 
             foreach (PerformanceCounter counter in counters)
@@ -394,12 +395,11 @@ private static void DumpCounter(PerformanceCounter counter, bool initializeOnly)
                 if (!initializeOnly)
                 {
                     string friendlyCounterType = GetFriendlyCounterType(counter.CounterType, counter.CounterName);
-                    string valueFormat;
-
+                    
                     // At least some (such as % in GC; maybe all) "%" counters are already multiplied by 100. So we don't do that here.
 
                     // Show decimal places if meaningful
-                    valueFormat = value < 10 ? "{0,20:N2}" : "{0,20:N0}";
+                    string valueFormat = value < 10 ? "{0,20:N2}" : "{0,20:N0}";
 
                     string valueString = String.Format(CultureInfo.CurrentCulture, valueFormat, value);
 
@@ -509,7 +509,11 @@ string [] commandLine
             }
 
 #if FEATURE_GET_COMMANDLINE
-            ErrorUtilities.VerifyThrowArgumentLength(commandLine, "commandLine");
+            ErrorUtilities.VerifyThrowArgumentLength(commandLine, nameof(commandLine));
+#endif
+
+#if FEATURE_APPDOMAIN_UNHANDLED_EXCEPTION
+            AppDomain.CurrentDomain.UnhandledException += ExceptionHandling.UnhandledExceptionHandler;
 #endif
 
             ExitType exitType = ExitType.Success;
@@ -521,7 +525,7 @@ string [] commandLine
                 MSBuildEventSource.Log.MSBuildExeStart(commandLine);
 #else
                 if (MSBuildEventSource.Log.IsEnabled()) {
-                    MSBuildEventSource.Log.MSBuildExeStop(string.Join(" ", commandLine));
+                    MSBuildEventSource.Log.MSBuildExeStart(string.Join(" ", commandLine));
                 }
 #endif
                 Console.CancelKeyPress += cancelHandler;
@@ -627,11 +631,17 @@ string [] commandLine
 
                     // Honor the low priority flag, we place our selves below normal priority and let sub processes inherit
                     // that priority. Idle priority would prevent the build from proceeding as the user does normal actions.
-                    // We avoid increasing priority because that causes failures on mac/linux.
-                    if (lowPriority && Process.GetCurrentProcess().PriorityClass != ProcessPriorityClass.Idle)
+                    try
                     {
-                        Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.BelowNormal;
+                        if (lowPriority && Process.GetCurrentProcess().PriorityClass != ProcessPriorityClass.Idle)
+                        {
+                            Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.BelowNormal;
+                        }
                     }
+                    // We avoid increasing priority because that causes failures on mac/linux, but there is no good way to
+                    // verify that a particular priority is lower than "BelowNormal." If the error appears, ignore it and
+                    // leave priority where it was.
+                    catch (Win32Exception) { }
 
                     DateTime t1 = DateTime.Now;
 
@@ -742,7 +752,7 @@ string [] commandLine
             catch (LoggerException e)
             {
                 // display the localized message from the outer exception in canonical format
-                if (null != e.ErrorCode)
+                if (e.ErrorCode != null)
                 {
                     // Brief prefix to indicate that it's a logger failure, and provide the "error" indication
                     Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("LoggerFailurePrefixNoErrorCode", e.ErrorCode, e.Message));
@@ -754,7 +764,7 @@ string [] commandLine
                     Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("LoggerFailurePrefixWithErrorCode", e.Message));
                 }
 
-                if (null != e.InnerException)
+                if (e.InnerException != null)
                 {
                     // write out exception details -- don't bother triggering Watson, because most of these exceptions will be coming
                     // from buggy loggers written by users
@@ -1096,7 +1106,7 @@ string outputResultsCache
                 if (needToValidateProject && !FileUtilities.IsSolutionFilename(projectFile))
                 {
                     Microsoft.Build.Evaluation.Project project = projectCollection.LoadProject(projectFile, globalProperties, toolsVersion);
-                    Microsoft.Build.Evaluation.Toolset toolset = projectCollection.GetToolset((toolsVersion == null) ? project.ToolsVersion : toolsVersion);
+                    Microsoft.Build.Evaluation.Toolset toolset = projectCollection.GetToolset(toolsVersion ?? project.ToolsVersion);
 
                     if (toolset == null)
                     {
@@ -1312,10 +1322,7 @@ string outputResultsCache
             finally
             {
                 FileUtilities.ClearCacheDirectory();
-                if (projectCollection != null)
-                {
-                    projectCollection.Dispose();
-                }
+                projectCollection?.Dispose();
 
                 BuildManager.DefaultBuildManager.Dispose();
             }
@@ -1768,7 +1775,6 @@ internal static string ExtractSwitchParameters
             int switchParameterIndicator
         )
         {
-            string switchParameters = null;
 
             // find the parameter indicator again using the quoted arg
             // NOTE: since the parameter indicator cannot be part of a switch name, quoting around it is not relevant, because a
@@ -1785,6 +1791,7 @@ int switchParameterIndicator
             ErrorUtilities.VerifyThrow(doubleQuotesRemovedFromArg >= doubleQuotesRemovedFromSwitchIndicatorAndName,
                 "The name portion of the switch cannot contain more quoting than the arg itself.");
 
+            string switchParameters;
             // if quoting in the name portion of the switch was terminated
             if ((doubleQuotesRemovedFromSwitchIndicatorAndName % 2) == 0)
             {
@@ -1851,7 +1858,7 @@ private static void GatherResponseFileSwitch(string unquotedCommandLineArg, Comm
 
                     foreach (string includedResponseFile in s_includedResponseFiles)
                     {
-                        if (String.Compare(responseFile, includedResponseFile, StringComparison.OrdinalIgnoreCase) == 0)
+                        if (String.Equals(responseFile, includedResponseFile, StringComparison.OrdinalIgnoreCase))
                         {
                             commandLineSwitches.SetParameterError("RepeatedResponseFileError", unquotedCommandLineArg);
                             isRepeatedResponseFile = true;
@@ -2186,7 +2193,7 @@ bool recursing
                         if (!String.Equals(projectDirectory, s_exePath, StringComparison.OrdinalIgnoreCase))
                         {
                             // this combines any found, with higher precedence, with the switches from the original auto response file switches
-                            found = found | GatherAutoResponseFileSwitches(projectDirectory, switchesFromAutoResponseFile);
+                            found |= GatherAutoResponseFileSwitches(projectDirectory, switchesFromAutoResponseFile);
                         }
 
                         if (found)
@@ -2574,7 +2581,6 @@ internal static ProfilerLogger ProcessProfileEvaluationSwitch(string[] parameter
                     ex.Message);
             }
 
-
             var logger = new ProfilerLogger(profilerFile);
             loggers.Add(logger);
 
@@ -2624,7 +2630,8 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches)
 
                         // If FEATURE_NODE_REUSE is OFF, just validates that the switch is OK, and always returns False
                         bool nodeReuse = ProcessNodeReuseSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeReuse]);
-                        bool lowpriority = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.LowPriority][0].Equals("true");
+                        string[] lowPriorityInput = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.LowPriority];
+                        bool lowpriority = lowPriorityInput.Length > 0 ? lowPriorityInput[0].Equals("true") : false;
 
                         shutdownReason = node.Run(nodeReuse, lowpriority, out nodeException);
 
@@ -2635,12 +2642,21 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches)
                         OutOfProcTaskHostNode node = new OutOfProcTaskHostNode();
                         shutdownReason = node.Run(out nodeException);
                     }
+                    else if (nodeModeNumber == 3)
+                    {
+                        var node = new RarNode(); 
+                        // If FEATURE_NODE_REUSE is OFF, just validates that the switch is OK, and always returns False
+                        bool nodeReuse = ProcessNodeReuseSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeReuse]);
+                        string[] lowPriorityInput = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.LowPriority];
+                        bool lowPriority = lowPriorityInput.Length > 0 && string.Equals(lowPriorityInput[0], bool.TrueString, StringComparison.OrdinalIgnoreCase);
+
+                        shutdownReason = node.Run(nodeReuse, lowPriority, out nodeException, s_buildCancellationSource.Token);
+                    }
                     else
                     {
-                        CommandLineSwitchException.Throw("InvalidNodeNumberValue", input[0]);
+                        CommandLineSwitchException.Throw("InvalidNodeNumberValue", nodeModeNumber.ToString());
                     }
 
-
                     if (shutdownReason == NodeEngineShutdownReason.Error)
                     {
                         Debug.WriteLine("An error has happened, throwing an exception");
@@ -2771,7 +2787,6 @@ DirectoryGetFiles getFiles
                     }
                 }
 
-
                 if (potentialSolutionFiles != null)
                 {
                     foreach (string s in potentialSolutionFiles)
@@ -2790,13 +2805,13 @@ DirectoryGetFiles getFiles
                 if (extensionsToIgnoreDictionary.Count > 0)
                 {
                     // No point removing extensions if we have no project files
-                    if (potentialProjectFiles != null && potentialProjectFiles.Length > 0)
+                    if (potentialProjectFiles?.Length > 0)
                     {
                         potentialProjectFiles = RemoveFilesWithExtensionsToIgnore(potentialProjectFiles, extensionsToIgnoreDictionary);
                     }
 
                     // No point removing extensions if we have no solutions
-                    if (potentialSolutionFiles != null && potentialSolutionFiles.Length > 0)
+                    if (potentialSolutionFiles?.Length > 0)
                     {
                         potentialSolutionFiles = RemoveFilesWithExtensionsToIgnore(potentialSolutionFiles, extensionsToIgnoreDictionary);
                     }
@@ -2808,7 +2823,7 @@ DirectoryGetFiles getFiles
                     string solutionName = Path.GetFileNameWithoutExtension(potentialSolutionFiles[0]);
                     string projectName = Path.GetFileNameWithoutExtension(potentialProjectFiles[0]);
                     // Compare the names and error if they are not identical
-                    InitializationException.VerifyThrow(String.Compare(solutionName, projectName, StringComparison.OrdinalIgnoreCase) == 0, projectDirectory == null ? "AmbiguousProjectError" : "AmbiguousProjectDirectoryError", null, projectDirectory);
+                    InitializationException.VerifyThrow(String.Equals(solutionName, projectName, StringComparison.OrdinalIgnoreCase), projectDirectory == null ? "AmbiguousProjectError" : "AmbiguousProjectDirectoryError", null, projectDirectory);
                 }
                 // If there is more than one solution file in the current directory we have no idea which one to use
                 else if (potentialSolutionFiles.Length > 1)
@@ -2828,17 +2843,17 @@ DirectoryGetFiles getFiles
                         string secondPotentialProjectExtension = Path.GetExtension(potentialProjectFiles[1]);
 
                         // If the two projects have the same extension we can't decide which one to pick
-                        if (String.Compare(firstPotentialProjectExtension, secondPotentialProjectExtension, StringComparison.OrdinalIgnoreCase) != 0)
+                        if (!String.Equals(firstPotentialProjectExtension, secondPotentialProjectExtension, StringComparison.OrdinalIgnoreCase))
                         {
                             // Check to see if the first project is the proj, if it is use it
-                            if (String.Compare(firstPotentialProjectExtension, ".proj", StringComparison.OrdinalIgnoreCase) == 0)
+                            if (String.Equals(firstPotentialProjectExtension, ".proj", StringComparison.OrdinalIgnoreCase))
                             {
                                 potentialProjectFiles = new string[] { potentialProjectFiles[0] };
                                 // We have made a decision
                                 isAmbiguousProject = false;
                             }
                             // If the first project is not the proj check to see if the second one is the proj, if so use it
-                            else if (String.Compare(secondPotentialProjectExtension, ".proj", StringComparison.OrdinalIgnoreCase) == 0)
+                            else if (String.Equals(secondPotentialProjectExtension, ".proj", StringComparison.OrdinalIgnoreCase))
                             {
                                 potentialProjectFiles = new string[] { potentialProjectFiles[1] };
                                 // We have made a decision
@@ -2877,7 +2892,7 @@ private static Dictionary<string, object> ValidateExtensions(string[] projectsEx
             Dictionary<string, object> extensionsToIgnoreDictionary = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
 
             // Go through each of the extensions to ignore and add them as a key in the dictionary
-            if (projectsExtensionsToIgnore != null && projectsExtensionsToIgnore.Length > 0)
+            if (projectsExtensionsToIgnore?.Length > 0)
             {
                 string extension = null;
 
@@ -2904,7 +2919,7 @@ private static Dictionary<string, object> ValidateExtensions(string[] projectsEx
 
                     // The parsed extension does not match the passed in extension, this means that there were
                     // some other chars before the last extension
-                    if (string.Compare(extension, extensionToIgnore, StringComparison.OrdinalIgnoreCase) != 0)
+                    if (!string.Equals(extension, extensionToIgnore, StringComparison.OrdinalIgnoreCase))
                     {
                         InitializationException.Throw("InvalidExtensionToIgnore", extensionToIgnore, null, false);
                     }
@@ -2913,7 +2928,7 @@ private static Dictionary<string, object> ValidateExtensions(string[] projectsEx
                     if (extensionToIgnore.IndexOfAny(s_wildcards) > -1)
                     {
                         InitializationException.Throw("InvalidExtensionToIgnore", extensionToIgnore, null, false);
-                    };
+                    }
                     if (!extensionsToIgnoreDictionary.ContainsKey(extensionToIgnore))
                     {
                         extensionsToIgnoreDictionary.Add(extensionToIgnore, null);
@@ -2936,8 +2951,8 @@ Dictionary<string, object> extensionsToIgnoreDictionary
                                 )
         {
             // If we got to this method we should have to possible projects or solutions and some extensions to ignore
-            ErrorUtilities.VerifyThrow(((potentialProjectOrSolutionFiles != null) && (potentialProjectOrSolutionFiles.Length > 0)), "There should be some potential project or solution files");
-            ErrorUtilities.VerifyThrow(((extensionsToIgnoreDictionary != null) && (extensionsToIgnoreDictionary.Count > 0)), "There should be some extensions to Ignore");
+            ErrorUtilities.VerifyThrow(potentialProjectOrSolutionFiles?.Length > 0, "There should be some potential project or solution files");
+            ErrorUtilities.VerifyThrow(extensionsToIgnoreDictionary?.Count > 0, "There should be some extensions to Ignore");
 
             List<string> filesToKeep = new List<string>();
             foreach (string projectOrSolutionFile in potentialProjectOrSolutionFiles)
@@ -3193,7 +3208,7 @@ ArrayList loggers
                 ConsoleLogger logger = new ConsoleLogger(verbosity);
                 string consoleParameters = "SHOWPROJECTFILE=TRUE;";
 
-                if ((consoleLoggerParameters != null) && (consoleLoggerParameters.Length > 0))
+                if ((consoleLoggerParameters?.Length > 0))
                 {
                     consoleParameters = AggregateParameters(consoleParameters, consoleLoggerParameters);
                 }
@@ -3260,7 +3275,7 @@ int cpuCount
             if (distributedFileLogger)
             {
                 string fileParameters = string.Empty;
-                if ((fileLoggerParameters != null) && (fileLoggerParameters.Length > 0))
+                if ((fileLoggerParameters?.Length > 0))
                 {
                     // Join the file logger parameters into one string seperated by semicolons
                     fileParameters = AggregateParameters(null, fileLoggerParameters);
@@ -3534,7 +3549,7 @@ private static LoggerDescription ParseLoggingParameter(string parameter, string
             // DDB Bug msbuild.exe -Logger:FileLogger,Microsoft.Build.Engine fails due to moved engine file.
             // Only add strong naming if the assembly is a non-strong named 'Microsoft.Build.Engine' (i.e, no additional characteristics)
             // Concat full Strong Assembly to match v4.0
-            if (String.Compare(loggerAssemblySpec, "Microsoft.Build.Engine", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(loggerAssemblySpec, "Microsoft.Build.Engine", StringComparison.OrdinalIgnoreCase))
             {
                 loggerAssemblySpec = "Microsoft.Build.Engine,Version=4.0.0.0,Culture=neutral,PublicKeyToken=b03f5f7f11d50a3a";
             }
@@ -3615,7 +3630,6 @@ out ILogger logger
                     logger.Parameters = loggerDescription.LoggerSwitchParameters;
                 }
             }
-
             catch (LoggerException)
             {
                 // Logger failed politely during parameter/verbosity setting
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index c2023dc939a..0d9ca6d8f34 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -10,7 +10,7 @@
       <DisableFXClosureWalk enabled="true" />
       <DeferFXClosureWalk enabled="true" />
       <generatePublisherEvidence enabled="false" />
-      <AppContextSwitchOverrides value="Switch.System.Security.Cryptography.UseLegacyFipsThrow=false;Switch.System.IO.UseLegacyPathHandling=false;Switch.System.IO.BlockLongPaths=false" />
+      <AppContextSwitchOverrides value="Switch.System.Security.Cryptography.UseLegacyFipsThrow=false" />
       <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Build.Framework" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
@@ -48,8 +48,8 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Build.CPPTasks.Common" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <bindingRedirect oldVersion="16.0.0.0-16.7.0.0" newVersion="16.7.0.0" />
-          <codeBase version="16.7.0.0" href="..\..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
+          <bindingRedirect oldVersion="16.0.0.0-16.8.0.0" newVersion="16.8.0.0" />
+          <codeBase version="16.8.0.0" href="..\..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
         </dependentAssembly>
 
         <!-- Redirects for components dropped by Visual Studio -->
@@ -59,7 +59,7 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="XamlBuildTask" culture="neutral" publicKeyToken="31bf3856ad364e35" />
-          <bindingRedirect oldVersion="4.0.0.0" newVersion="16.0.0.0" />
+          <bindingRedirect oldVersion="4.0.0.0-16.0.0.0" newVersion="16.0.0.0" />
         </dependentAssembly>
 
         <!-- Workaround for crash in C++ CodeAnalysis scenarios due to https://github.com/Microsoft/msbuild/issues/1675 -->
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 7e595eacfc0..07b6a964c1c 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -49,13 +49,13 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="XamlBuildTask" culture="neutral" publicKeyToken="31bf3856ad364e35" />
-          <bindingRedirect oldVersion="4.0.0.0" newVersion="16.0.0.0" />
+          <bindingRedirect oldVersion="4.0.0.0-16.0.0.0" newVersion="16.0.0.0" />
           <codeBase version="16.0.0.0" href=".\amd64\XamlBuildTask.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Build.CPPTasks.Common" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <bindingRedirect oldVersion="16.0.0.0-16.7.0.0" newVersion="16.7.0.0" />
-          <codeBase version="16.7.0.0" href="..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
+          <bindingRedirect oldVersion="16.0.0.0-16.8.0.0" newVersion="16.8.0.0" />
+          <codeBase version="16.8.0.0" href="..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
         </dependentAssembly>
 
         <!-- Workaround for crash in C++ CodeAnalysis scenarios due to https://github.com/Microsoft/msbuild/issues/1675 -->
diff --git a/src/MSBuildTaskHost/AssemblyInfo.cs b/src/MSBuildTaskHost/AssemblyInfo.cs
index bf85c36e740..34783459140 100644
--- a/src/MSBuildTaskHost/AssemblyInfo.cs
+++ b/src/MSBuildTaskHost/AssemblyInfo.cs
@@ -2,4 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Reflection;
+using System.Runtime.CompilerServices;
 
+[assembly: InternalsVisibleTo("Microsoft.Build.Engine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
diff --git a/src/MSBuildTaskHost/Concurrent/ConcurrentDictionary.cs b/src/MSBuildTaskHost/Concurrent/ConcurrentDictionary.cs
index e7e6a6221ef..e83adf88dce 100644
--- a/src/MSBuildTaskHost/Concurrent/ConcurrentDictionary.cs
+++ b/src/MSBuildTaskHost/Concurrent/ConcurrentDictionary.cs
@@ -93,7 +93,6 @@ private static bool IsValueWriteAtomic()
         /// </summary>
         public ConcurrentDictionary(IEqualityComparer<TKey> comparer = null)
         {
-
             int concurrencyLevel = Environment.ProcessorCount;
             int capacity = DefaultCapacity;
 
@@ -347,7 +346,7 @@ private void GrowTable(Tables tables)
                     checked
                     {
                         // Double the size of the buckets table and add one, so that we have an odd integer.
-                        newLength = tables._buckets.Length * 2 + 1;
+                        newLength = (tables._buckets.Length * 2) + 1;
 
                         // Now, we only need to check odd integers, and find the first that is not divisible
                         // by 3, 5 or 7.
diff --git a/src/MSBuildTaskHost/FileSystem/MSBuildTaskHostFileSystem.cs b/src/MSBuildTaskHost/FileSystem/MSBuildTaskHostFileSystem.cs
index 3b285db56ba..103061df36c 100644
--- a/src/MSBuildTaskHost/FileSystem/MSBuildTaskHostFileSystem.cs
+++ b/src/MSBuildTaskHost/FileSystem/MSBuildTaskHostFileSystem.cs
@@ -21,6 +21,16 @@ public bool DirectoryEntryExists(string path)
             return NativeMethodsShared.FileOrDirectoryExists(path);
         }
 
+        public FileAttributes GetAttributes(string path)
+        {
+            return File.GetAttributes(path);
+        }
+
+        public DateTime GetLastWriteTimeUtc(string path)
+        {
+            return File.GetLastWriteTimeUtc(path);
+        }
+
         public bool DirectoryExists(string path)
         {
             return NativeMethodsShared.DirectoryExists(path);
@@ -31,6 +41,26 @@ public IEnumerable<string> EnumerateDirectories(string path, string searchPatter
             return Directory.GetDirectories(path, searchPattern, searchOption);
         }
 
+        public TextReader ReadFile(string path)
+        {
+            return new StreamReader(path);
+        }
+
+        public Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share)
+        {
+            return new FileStream(path, mode, access, share);
+        }
+
+        public string ReadFileAllText(string path)
+        {
+            return File.ReadAllText(path);
+        }
+
+        public byte[] ReadFileAllBytes(string path)
+        {
+            return File.ReadAllBytes(path);
+        }
+
         public IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
         {
             return Directory.GetFiles(path, searchPattern, searchOption);
diff --git a/src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs b/src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs
new file mode 100644
index 00000000000..e4e16592ca2
--- /dev/null
+++ b/src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs
@@ -0,0 +1,273 @@
+Ôªø// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace System.Collections.Immutable
+{
+    static class ImmutableExtensions
+    {
+        public static ImmutableDictionary<K,V> ToImmutableDictionary<K,V>(this IDictionary<K,V> dictionary)
+        {
+            return new ImmutableDictionary<K, V>(dictionary);
+        }
+    }
+
+    static class ImmutableDictionary
+    {
+        internal static ImmutableDictionary<K, V> Create<K, V>(IEqualityComparer<K> comparer)
+        {
+            return new ImmutableDictionary<K, V>(comparer);
+        }
+    }
+
+    /// <summary>
+    /// Inefficient ImmutableDictionary implementation: keep a mutable dictionary and wrap all operations.
+    /// </summary>
+    /// <typeparam name="K"></typeparam>
+    /// <typeparam name="V"></typeparam>
+    sealed class ImmutableDictionary<K, V> : IDictionary<K, V>, IDictionary
+    {
+        /// <summary>
+        /// The underlying dictionary.
+        /// </summary>
+        private Dictionary<K, V> _backing;
+
+        #region Read-only Operations
+
+        public ICollection<K> Keys => _backing.Keys;
+        public ICollection<V> Values => _backing.Values;
+
+        ICollection IDictionary.Keys => _backing.Keys;
+        ICollection IDictionary.Values => _backing.Values;
+
+        public int Count => _backing.Count;
+
+        public V this[K key] => _backing[key];
+
+        public bool IsReadOnly => true;
+        public bool IsFixedSize => true;
+        public bool IsSynchronized => true;
+
+        public object SyncRoot => this;
+
+        public bool TryGetValue(K key, out V value)
+        {
+            return _backing.TryGetValue(key, out value);
+        }
+
+        public bool Contains(KeyValuePair<K, V> item)
+        {
+            return _backing.Contains(item);
+        }
+
+        bool IDictionary.Contains(object key)
+        {
+            return ((IDictionary)_backing).Contains(key);
+        }
+
+        public bool ContainsKey(K key)
+        {
+            return _backing.ContainsKey(key);
+        }
+
+        public IEnumerator<KeyValuePair<K, V>> GetEnumerator()
+        {
+            return _backing.GetEnumerator();
+        }
+
+        IDictionaryEnumerator IDictionary.GetEnumerator()
+        {
+            return _backing.GetEnumerator();
+        }
+
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            return _backing.GetEnumerator();
+        }
+
+        void ICollection<KeyValuePair<K, V>>.CopyTo(KeyValuePair<K, V>[] array, int arrayIndex)
+        {
+            CheckCopyToArguments(array, arrayIndex);
+            foreach (var item in this)
+            {
+                array[arrayIndex++] = item;
+            }
+        }
+
+        void ICollection.CopyTo(Array array, int arrayIndex)
+        {
+            CheckCopyToArguments(array, arrayIndex);
+            foreach (var item in this)
+            {
+                array.SetValue(new DictionaryEntry(item.Key, item.Value), arrayIndex++);
+            }
+        }
+
+        private void CheckCopyToArguments(Array array, int arrayIndex)
+        {
+            if (array == null)
+            {
+                throw new ArgumentNullException(nameof(array));
+            }
+            if (arrayIndex < 0)
+            {
+                throw new ArgumentOutOfRangeException(nameof(arrayIndex));
+            }
+            if (arrayIndex + Count > array.Length)
+            {
+                throw new ArgumentException(nameof(arrayIndex));
+            }
+        }
+
+        #endregion
+
+        #region Write Operations
+
+        internal ImmutableDictionary<K, V> SetItem(K key, V value)
+        {
+            if (TryGetValue(key, out V existingValue) && Object.Equals(existingValue, value))
+            {
+                return this;
+            }
+
+            var clone = new ImmutableDictionary<K, V>(_backing);
+            clone._backing[key] = value;
+
+            return clone;
+        }
+
+        internal ImmutableDictionary<K, V> Remove(K key)
+        {
+            if (!ContainsKey(key))
+            {
+                return this;
+            }
+
+            var clone = new ImmutableDictionary<K, V>(_backing);
+            clone._backing.Remove(key);
+
+            return clone;
+        }
+
+        internal ImmutableDictionary<K, V> Clear()
+        {
+            return new ImmutableDictionary<K, V>(_backing.Comparer);
+        }
+
+        internal ImmutableDictionary()
+        {
+            _backing = new Dictionary<K, V>();
+        }
+
+        internal ImmutableDictionary(IEqualityComparer<K> comparer)
+        {
+            _backing = new Dictionary<K, V>(comparer);
+        }
+
+        internal ImmutableDictionary(IDictionary<K, V> source, IEqualityComparer<K> keyComparer = null)
+        {
+            if (source is ImmutableDictionary<K, V> imm)
+            {
+                _backing = new Dictionary<K, V>(imm._backing, keyComparer ?? imm._backing.Comparer);
+            }
+            else
+            {
+                _backing = new Dictionary<K, V>(source, keyComparer);
+            }
+        }
+
+        internal static ImmutableDictionary<K, V> Empty
+        {
+            get
+            {
+                return new ImmutableDictionary<K, V>();
+            }
+        }
+
+        public IEqualityComparer<K> KeyComparer { get => _backing.Comparer; internal set => throw new NotSupportedException(); }
+
+        internal KeyValuePair<K, V>[] ToArray()
+        {
+            return _backing.ToArray();
+        }
+
+        internal ImmutableDictionary<K, V> AddRange(KeyValuePair<K, V>[] v)
+        {
+            var n = new Dictionary<K, V>(_backing, _backing.Comparer);
+
+            foreach (var item in v)
+            {
+                n.Add(item.Key, item.Value);
+            }
+
+            return new ImmutableDictionary<K, V>(n);
+        }
+
+        internal ImmutableDictionary<K, V> WithComparers(IEqualityComparer<K> keyComparer)
+        {
+            return new ImmutableDictionary<K, V>(_backing, keyComparer);
+        }
+
+        #endregion
+
+        #region Unsupported Operations
+
+        object IDictionary.this[object key]
+        {
+            get { return _backing[(K)key]; }
+            set { throw new NotSupportedException(); }
+        }
+
+        void IDictionary.Add(object key, object value)
+        {
+            throw new NotSupportedException();
+        }
+
+        void IDictionary.Remove(object key)
+        {
+            throw new NotSupportedException();
+        }
+
+        void IDictionary.Clear()
+        {
+            throw new NotSupportedException();
+        }
+
+        V IDictionary<K, V>.this[K key]
+        {
+            get { return _backing[key]; }
+            set { throw new NotSupportedException(); }
+        }
+
+        void IDictionary<K, V>.Add(K key, V value)
+        {
+            throw new NotSupportedException();
+        }
+
+        bool IDictionary<K, V>.Remove(K key)
+        {
+            throw new NotSupportedException();
+        }
+
+        void ICollection<KeyValuePair<K, V>>.Add(KeyValuePair<K, V> item)
+        {
+            throw new NotSupportedException();
+        }
+
+        void ICollection<KeyValuePair<K, V>>.Clear()
+        {
+            throw new NotSupportedException();
+        }
+
+        bool ICollection<KeyValuePair<K, V>>.Remove(KeyValuePair<K, V> item)
+        {
+            throw new NotSupportedException();
+        }
+
+        #endregion
+    }
+}
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 4fcb3ad7d8d..577b7b4c1d4 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -24,6 +24,9 @@
     <LargeAddressAware>true</LargeAddressAware>
     <ApplicationIcon>..\MSBuild\MSBuild.ico</ApplicationIcon>
 
+    <!-- workaround for https://github.com/dotnet/msbuild/issues/5620 -->
+    <BypassFrameworkInstallChecks>true</BypassFrameworkInstallChecks>
+
     <DebugType>full</DebugType><!-- Work around arcade stomping on symbols for same-program-different-arches. -->
   </PropertyGroup>
   <ItemGroup>
@@ -58,6 +61,7 @@
       <Link>CopyOnWriteDictionary.cs</Link>
     </Compile>
     <Compile Include="..\Shared\Constants.cs" />
+    <Compile Include="..\Shared\NamedPipeUtil.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyDictionary.cs" />
     <Compile Include="..\Shared\ErrorUtilities.cs">
       <Link>ErrorUtilities.cs</Link>
@@ -163,6 +167,7 @@
     <Compile Include="AssemblyResources.cs" />
     <Compile Include="Concurrent\ConcurrentDictionary.cs" />
     <Compile Include="Concurrent\ConcurrentQueue.cs" />
+    <Compile Include="Immutable\ImmutableDictionary.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
     <Compile Include="TypeLoader.cs" />
     <Compile Include="WeakStringCache.Locking.cs" />
@@ -194,7 +199,6 @@
     </Compile>
     <Compile Include="OutOfProcTaskAppDomainWrapper.cs" />
   </ItemGroup>
-  <ItemGroup />
   <ItemGroup>
     <None Include="app.config" />
   </ItemGroup>
@@ -213,6 +217,7 @@
     <PackageReference Include="PdbGit" /> -->
     <PackageReference Include="SourceLink.Create.CommandLine" />
     <PackageReference Include="LargeAddressAware" PrivateAssets="All" />
+    <PackageReference Include="jnm2.ReferenceAssemblies.net35" />
   </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
     <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
diff --git a/src/MSBuildTaskHost/TypeLoader.cs b/src/MSBuildTaskHost/TypeLoader.cs
index 666fc50449f..1b8bdd09f92 100644
--- a/src/MSBuildTaskHost/TypeLoader.cs
+++ b/src/MSBuildTaskHost/TypeLoader.cs
@@ -18,7 +18,6 @@ namespace Microsoft.Build.Shared
     /// </summary>
     internal class TypeLoader
     {
-
         /// <summary>
         /// Cache to keep track of the assemblyLoadInfos based on a given typeFilter.
         /// </summary>
@@ -119,7 +118,7 @@ internal static bool IsPartialTypeNameMatch(string typeName1, string typeName2)
             }
             else
             {
-                isPartialMatch = (String.Compare(typeName1, typeName2, StringComparison.OrdinalIgnoreCase) == 0);
+                isPartialMatch = (String.Equals(typeName1, typeName2, StringComparison.OrdinalIgnoreCase));
             }
 
             return isPartialMatch;
@@ -225,7 +224,7 @@ private class AssemblyInfoToLoadedTypes
             internal AssemblyInfoToLoadedTypes(TypeFilter typeFilter, AssemblyLoadInfo loadInfo)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(typeFilter, "typefilter");
-                ErrorUtilities.VerifyThrowArgumentNull(loadInfo, "loadInfo");
+                ErrorUtilities.VerifyThrowArgumentNull(loadInfo, nameof(loadInfo));
 
                 _isDesiredType = typeFilter;
                 _assemblyLoadInfo = loadInfo;
@@ -238,7 +237,7 @@ internal AssemblyInfoToLoadedTypes(TypeFilter typeFilter, AssemblyLoadInfo loadI
             /// </summary>
             internal LoadedType GetLoadedTypeByTypeName(string typeName)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(typeName, "typeName");
+                ErrorUtilities.VerifyThrowArgumentNull(typeName, nameof(typeName));
 
                 // Only one thread should be doing operations on this instance of the object at a time.
 
diff --git a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
index f2132af28e6..6e3cd15181e 100644
--- a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
+++ b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
@@ -40,6 +40,13 @@
     <file src="$X86BinPath$/System.Resources.Extensions.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Runtime.CompilerServices.Unsafe.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Threading.Tasks.Dataflow.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/StreamJsonRpc.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/Nerdbank.Streams.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/System.IO.Pipelines.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/Microsoft.VisualStudio.Threading.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/Microsoft.VisualStudio.Validation.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/MessagePack.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/MessagePack.Annotations.dll" target="v15.0/bin" />
 
     <file src="$X86BinPath$/MSBuild/Microsoft.Build.Core.xsd" target="v15.0/bin/MSBuild" />
     <file src="$X86BinPath$/MSBuild/Microsoft.Build.CommonTypes.xsd" target="v15.0/bin/MSBuild" />
@@ -94,6 +101,13 @@
     <file src="$X86BinPath$/System.Resources.Extensions.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Runtime.CompilerServices.Unsafe.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Threading.Tasks.Dataflow.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/StreamJsonRpc.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/Nerdbank.Streams.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/System.IO.Pipelines.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/Microsoft.VisualStudio.Threading.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/Microsoft.VisualStudio.Validation.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/MessagePack.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/MessagePack.Annotations.dll" target="v15.0/bin/amd64" />
 
     <file src="$X86BinPath$/MSBuild/Microsoft.Build.Core.xsd" target="v15.0/bin/amd64/MSBuild" />
     <file src="$X86BinPath$/MSBuild/Microsoft.Build.CommonTypes.xsd" target="v15.0/bin/amd64/MSBuild" />
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 44277b783c7..d813b8deb3d 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -48,6 +48,13 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Threading.Tasks.Dataflow.dll vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Collections.Immutable.dll vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)StreamJsonRpc.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Nerdbank.Streams.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.IO.Pipelines.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Microsoft.VisualStudio.Threading.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Microsoft.VisualStudio.Validation.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)MessagePack.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)MessagePack.Annotations.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Common.CurrentVersion.targets
   file source=$(X86BinPath)Microsoft.Common.CrossTargeting.targets
   file source=$(X86BinPath)Microsoft.Common.overridetasks
@@ -197,6 +204,13 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Threading.Tasks.Dataflow.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Collections.Immutable.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)StreamJsonRpc.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Nerdbank.Streams.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.IO.Pipelines.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Microsoft.VisualStudio.Threading.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Microsoft.VisualStudio.Validation.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)MessagePack.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)MessagePack.Annotations.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Common.CurrentVersion.targets
   file source=$(X86BinPath)Microsoft.Common.CrossTargeting.targets
   file source=$(X86BinPath)Microsoft.Common.overridetasks
diff --git a/src/Samples/TaskUsageLogger/TaskUsageLogger.cs b/src/Samples/TaskUsageLogger/TaskUsageLogger.cs
index bf28365a775..4ed1dbcb9b0 100644
--- a/src/Samples/TaskUsageLogger/TaskUsageLogger.cs
+++ b/src/Samples/TaskUsageLogger/TaskUsageLogger.cs
@@ -64,10 +64,10 @@ public override void Initialize(IEventSource eventSource)
         {
             ProcessParameters();
 
-            eventSource.ProjectStarted += new ProjectStartedEventHandler(HandleProjectStarted);
-            eventSource.TargetStarted += new TargetStartedEventHandler(HandleTargetStarted);
-            eventSource.TaskStarted += new TaskStartedEventHandler(HandleTaskStarted);
-            eventSource.BuildFinished += new BuildFinishedEventHandler(HandleBuildFinished);
+            eventSource.ProjectStarted += HandleProjectStarted;
+            eventSource.TargetStarted += HandleTargetStarted;
+            eventSource.TaskStarted += HandleTaskStarted;
+            eventSource.BuildFinished += HandleBuildFinished;
 
             _targetIdsToNames = new Dictionary<int, string>();
             _tasks = new HashSet<TaskData>();
@@ -215,7 +215,7 @@ private void GatherAndEvaluateDefaultTasksForToolsVersion(string toolsVersion, P
         /// </summary>
         private void GatherAndEvaluateTasksForProject(Project p, int projectContextId)
         {
-            HashSet<UsingTaskData> usingTasks = null;
+            HashSet<UsingTaskData> usingTasks;
             if (!_tasksByProjectContextId.TryGetValue(projectContextId, out usingTasks))
             {
                 usingTasks = new HashSet<UsingTaskData>();
@@ -248,7 +248,7 @@ private void GatherAndEvaluatedTasksInFile(ProjectRootElement pre, Project conta
                 string evaluatedTaskName = EvaluateIfNecessary(usingTask.TaskName, containingProject);
 
                 // A task registration can define either AssemblyName or AssemblyFile, but not both.
-                string evaluatedTaskAssemblyPath = null;
+                string evaluatedTaskAssemblyPath;
                 if (String.IsNullOrEmpty(usingTask.AssemblyName))
                 {
                     evaluatedTaskAssemblyPath = EvaluateIfNecessary(usingTask.AssemblyFile, containingProject);
diff --git a/src/Samples/XmlFileLogger/ObjectModel/Build.cs b/src/Samples/XmlFileLogger/ObjectModel/Build.cs
index 2aaba8f0054..639fb441a70 100644
--- a/src/Samples/XmlFileLogger/ObjectModel/Build.cs
+++ b/src/Samples/XmlFileLogger/ObjectModel/Build.cs
@@ -171,7 +171,7 @@ public void AddTask(TaskStartedEventArgs taskStartedEventArgs)
             var project = GetOrAddProject(taskStartedEventArgs.BuildEventContext.ProjectContextId);
             var target = project.GetTargetById(taskStartedEventArgs.BuildEventContext.TargetId);
 
-            target.AddChildTask(new Task(taskStartedEventArgs.TaskName, taskStartedEventArgs, GetTaskAssembly((taskStartedEventArgs.TaskName))));
+            target.AddChildTask(new Task(taskStartedEventArgs.TaskName, taskStartedEventArgs, GetTaskAssembly(taskStartedEventArgs.TaskName)));
         }
 
         /// <summary>
@@ -182,7 +182,7 @@ public void AddProject(ProjectStartedEventArgs projectStartedEventArgs)
         {
             Project parent = null;
 
-            if (projectStartedEventArgs.ParentProjectBuildEventContext != null && projectStartedEventArgs.ParentProjectBuildEventContext.ProjectContextId >= 0)
+            if (projectStartedEventArgs.ParentProjectBuildEventContext?.ProjectContextId >= 0)
             {
                 parent = GetOrAddProject(projectStartedEventArgs.ParentProjectBuildEventContext.ProjectContextId);
             }
diff --git a/src/Samples/XmlFileLogger/ObjectModel/TaskParameter.cs b/src/Samples/XmlFileLogger/ObjectModel/TaskParameter.cs
index 022fc191533..4e28d5136f1 100644
--- a/src/Samples/XmlFileLogger/ObjectModel/TaskParameter.cs
+++ b/src/Samples/XmlFileLogger/ObjectModel/TaskParameter.cs
@@ -65,21 +65,15 @@ public void SaveToElement(XElement parentElement)
         /// <returns>Concrete task parameter node.</returns>
         public static TaskParameter Create(string message, string prefix)
         {
-            switch (prefix)
+            return prefix switch
             {
-                case XmlFileLogger.OutputItemsMessagePrefix:
-                    return new OutputItem(message, prefix);
-                case XmlFileLogger.TaskParameterMessagePrefix:
-                    return new InputParameter(message, prefix);
-                case XmlFileLogger.OutputPropertyMessagePrefix:
-                    return new OutputProperty(message, prefix);
-                case XmlFileLogger.ItemGroupIncludeMessagePrefix:
-                    return new ItemGroup(message, prefix, "Include");
-                case XmlFileLogger.ItemGroupRemoveMessagePrefix:
-                    return new ItemGroup(message, prefix, "Remove");
-                default:
-                    throw new UnknownTaskParameterPrefixException(prefix);
-            }
+                XmlFileLogger.OutputItemsMessagePrefix => new OutputItem(message, prefix),
+                XmlFileLogger.TaskParameterMessagePrefix => new InputParameter(message, prefix),
+                XmlFileLogger.OutputPropertyMessagePrefix => new OutputProperty(message, prefix),
+                XmlFileLogger.ItemGroupIncludeMessagePrefix => new ItemGroup(message, prefix, "Include"),
+                XmlFileLogger.ItemGroupRemoveMessagePrefix => new ItemGroup(message, prefix, "Remove"),
+                _ => throw new UnknownTaskParameterPrefixException(prefix),
+            };
         }
     }
 }
diff --git a/src/Samples/XmlFileLogger/PropertyBag.cs b/src/Samples/XmlFileLogger/PropertyBag.cs
index 7b16f65907b..b70c9300fac 100644
--- a/src/Samples/XmlFileLogger/PropertyBag.cs
+++ b/src/Samples/XmlFileLogger/PropertyBag.cs
@@ -60,7 +60,7 @@ public void AddProperties(IEnumerable<KeyValuePair<string, string>> newPropertie
         {
             if (newProperties == null)
             {
-                throw new ArgumentNullException("newProperties");
+                throw new ArgumentNullException(nameof(newProperties));
             }
 
             foreach (var property in newProperties)
@@ -79,7 +79,7 @@ public void AddProperties(IEnumerable<DictionaryEntry> newProperties)
         {
             if (newProperties == null)
             {
-                throw new ArgumentNullException("newProperties");
+                throw new ArgumentNullException(nameof(newProperties));
             }
 
             foreach (var property in newProperties)
@@ -134,7 +134,7 @@ public bool TryGetValue(string key, out string value)
                 return true;
             }
 
-            return _parent != null && _parent.TryGetValue(key, out value);
+            return _parent?.TryGetValue(key, out value) == true;
         }
     }
 }
diff --git a/src/Samples/XmlFileLogger/XmlFileLogger.cs b/src/Samples/XmlFileLogger/XmlFileLogger.cs
index 10772659ed8..5663da5cd74 100644
--- a/src/Samples/XmlFileLogger/XmlFileLogger.cs
+++ b/src/Samples/XmlFileLogger/XmlFileLogger.cs
@@ -62,7 +62,6 @@ public override void Initialize(IEventSource eventSource)
             };
             eventSource.WarningRaised += (o, args) =>
             {
-
                 _warings++;
                 _build.AddMessage(args, string.Format("Warning {0}: {1}", args.Code, args.Message));
             };
diff --git a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
index 26f7c644e4f..da266d8220e 100644
--- a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
+++ b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
@@ -46,6 +46,11 @@ internal class AssemblyFoldersEx : IEnumerable<AssemblyFoldersExInfo>
         /// </summary>
         private List<AssemblyFoldersExInfo> _directoryNames = new List<AssemblyFoldersExInfo>();
 
+        /// <summary>
+        /// Set of unique paths to directories found from the registry
+        /// </summary>
+        private HashSet<string> _uniqueDirectoryPaths = new HashSet<string>();
+
         /// <summary>
         /// Construct.
         /// </summary>
@@ -229,9 +234,9 @@ OpenBaseKey openBaseKey
                     {
                         using (RegistryKey keyPlatform = baseKey.OpenSubKey(directoryKey.RegistryKey, false))
                         {
-                            if (keyPlatform != null && keyPlatform.ValueCount > 0)
+                            if (keyPlatform?.ValueCount > 0)
                             {
-                                if (platform != null && platform.Length > 0)
+                                if (!string.IsNullOrEmpty(platform))
                                 {
                                     string platformValue = keyPlatform.GetValue("Platform", null) as string;
 
@@ -241,7 +246,7 @@ OpenBaseKey openBaseKey
                                     }
                                 }
 
-                                if (osVersion != null && osVersion.Length > 0)
+                                if (!string.IsNullOrEmpty(osVersion))
                                 {
                                     Version ver = VersionUtilities.ConvertToVersion(osVersion);
 
@@ -256,8 +261,9 @@ OpenBaseKey openBaseKey
 
                     string directoryName = getRegistrySubKeyDefaultValue(baseKey, directoryKey.RegistryKey);
 
-                    if (null != directoryName)
+                    if (directoryName != null)
                     {
+                        _uniqueDirectoryPaths.Add(directoryName);
                         _directoryNames.Add(new AssemblyFoldersExInfo(hive, view, directoryKey.RegistryKey, directoryName, directoryKey.TargetFrameworkVersion));
                     }
                 }
@@ -268,12 +274,12 @@ private bool MatchingPlatformExists(string platform, string platformValue)
         {
             bool match = false;
 
-            if (platformValue != null && platformValue.Length > 0)
+            if (!string.IsNullOrEmpty(platformValue))
             {
                 string[] platforms = platformValue.Split(MSBuildConstants.SemicolonChar);
                 foreach (string p in platforms)
                 {
-                    if (String.Compare(p, platform, StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(p, platform, StringComparison.OrdinalIgnoreCase))
                     {
                         match = true;
                         break;
@@ -363,7 +369,7 @@ internal static List<ExtensionFoldersRegistryKey> GatherVersionStrings(string ta
             // Loop over versions from registry.
             foreach (string version in versions)
             {
-                if ((version.Length > 0) && (String.Compare(version.Substring(0, 1), "v", StringComparison.OrdinalIgnoreCase) == 0))
+                if ((version.Length > 0) && (String.Equals(version.Substring(0, 1), "v", StringComparison.OrdinalIgnoreCase)))
                 {
                     Version candidateVersion = VersionUtilities.ConvertToVersion(version);
 
@@ -381,7 +387,7 @@ internal static List<ExtensionFoldersRegistryKey> GatherVersionStrings(string ta
                         // To be added to our dictionary our candidate version from the registry must be a valid target framework version which is less than or equal 
                         // to the target version. Therefore if the candidate version is not a valid target framework version we will pretend it is and sort it in its correct form.
 
-                        Version replacementVersion = null;
+                        Version replacementVersion;
                         if (candidateVersion.Build > 255)
                         {
                             // Pretend the candidate version is really Maj.Minor ignore the build and revision
@@ -451,7 +457,7 @@ internal static List<ExtensionFoldersRegistryKey> GatherVersionStrings(string ta
         /// </summary>
         private static void AddCandidateVersion(SortedDictionary<Version, List<string>> targetFrameworkVersionToRegistryVersions, string version, Version candidateVersion)
         {
-            List<string> listOfFrameworks = null;
+            List<string> listOfFrameworks;
             if (targetFrameworkVersionToRegistryVersions.TryGetValue(candidateVersion, out listOfFrameworks))
             {
                 listOfFrameworks.Add(version);
@@ -483,6 +489,11 @@ IEnumerator IEnumerable.GetEnumerator()
         {
             return ((IEnumerable<AssemblyFoldersExInfo>)this).GetEnumerator();
         }
+
+        internal IEnumerable<string> UniqueDirectoryPaths
+        {
+            get => _uniqueDirectoryPaths;
+        }
     }
 }
 #endif
diff --git a/src/Shared/AssemblyLoadInfo.cs b/src/Shared/AssemblyLoadInfo.cs
index 8284c1a1f5e..15fa6b27e44 100644
--- a/src/Shared/AssemblyLoadInfo.cs
+++ b/src/Shared/AssemblyLoadInfo.cs
@@ -23,7 +23,7 @@ internal abstract class AssemblyLoadInfo : ITranslatable, IEquatable<AssemblyLoa
         /// </summary>
         internal static AssemblyLoadInfo Create(string assemblyName, string assemblyFile)
         {
-            ErrorUtilities.VerifyThrow(((assemblyName != null) && (assemblyName.Length > 0)) || ((assemblyFile != null) && (assemblyFile.Length > 0)),
+            ErrorUtilities.VerifyThrow((!string.IsNullOrEmpty(assemblyName)) || (!string.IsNullOrEmpty(assemblyFile)),
                 "We must have either the assembly name or the assembly file/path.");
             ErrorUtilities.VerifyThrow((assemblyName == null) || (assemblyFile == null),
                 "We must not have both the assembly name and the assembly file/path.");
@@ -93,7 +93,7 @@ public override bool Equals(Object obj)
                 return false;
             }
 
-            return ((this.AssemblyName == otherAssemblyInfo.AssemblyName) && (this.AssemblyFile == otherAssemblyInfo.AssemblyFile));
+            return (this.AssemblyName == otherAssemblyInfo.AssemblyName) && (this.AssemblyFile == otherAssemblyInfo.AssemblyFile);
         }
 
         public void Translate(ITranslator translator)
diff --git a/src/Shared/AssemblyNameExtension.cs b/src/Shared/AssemblyNameExtension.cs
index cb8140ced3d..34266b18e39 100644
--- a/src/Shared/AssemblyNameExtension.cs
+++ b/src/Shared/AssemblyNameExtension.cs
@@ -103,7 +103,7 @@ internal AssemblyNameExtension(string assemblyName) : this()
 
         /// <summary>
         /// Construct from a string, but immediately construct a real AssemblyName.
-        /// This will cause an exception to be thrown up front if the assembly name 
+        /// This will cause an exception to be thrown up front if the assembly name
         /// isn't well formed.
         /// </summary>
         /// <param name="assemblyName">
@@ -324,7 +324,7 @@ internal Version Version
         }
 
         /// <summary>
-        /// Is the assembly a complex name or a simple name. A simple name is where only the name is set 
+        /// Is the assembly a complex name or a simple name. A simple name is where only the name is set
         /// a complex name is where the version, culture or publickeytoken is also set
         /// </summary>
         internal bool IsSimpleName
@@ -500,8 +500,7 @@ internal int CompareTo(AssemblyNameExtension that, bool considerRetargetableFlag
                 }
 
                 // Will not return 0 as the this != that check above takes care of the case where they are equal.
-                result = this.Version.CompareTo(that.Version);
-                return result;
+                return this.Version.CompareTo(that.Version);
             }
 
             // We need some final collating order for these, alphabetical by FullName seems as good as any.
@@ -549,7 +548,7 @@ internal int CompareBaseNameTo(AssemblyNameExtension that)
         }
 
         /// <summary>
-        /// An implementation of compare that compares two base 
+        /// An implementation of compare that compares two base
         /// names as quickly as possible.
         /// </summary>
         /// <param name="that"></param>
@@ -717,7 +716,7 @@ private bool EqualsImpl(AssemblyNameExtension that, bool ignoreVersion, bool con
             }
 
             // If that is null then this and that are not equal. Also, this would cause a crash on the next line.
-            if (object.ReferenceEquals(that, null))
+            if (that is null)
             {
                 return false;
             }
@@ -851,7 +850,7 @@ private static AssemblyName GetAssemblyNameFromDisplayName(string displayName)
         }
 
         /// <summary>
-        /// Return a string that has AssemblyName special characters escaped. 
+        /// Return a string that has AssemblyName special characters escaped.
         /// Those characters are Equals(=), Comma(,), Quote("), Apostrophe('), Backslash(\).
         /// </summary>
         /// <remarks>
@@ -900,9 +899,9 @@ internal bool PartialNameCompare(AssemblyNameExtension that, bool considerRetarg
         /// <summary>
         /// Do a partial comparison between two assembly name extensions.
         /// Compare the fields of A and B on the following conditions:
-        /// 1) A.Field has a non null value 
+        /// 1) A.Field has a non null value
         /// 2) The field has been selected in the comparison flags or the default comparison flags are passed in.
-        /// 
+        ///
         /// If A.Field is null then we will not compare A.Field and B.Field even when the comparison flag is set for that field unless skipNullFields is false.
         /// </summary>
         internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFlags comparisonFlags)
@@ -913,9 +912,9 @@ internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFl
         /// <summary>
         /// Do a partial comparison between two assembly name extensions.
         /// Compare the fields of A and B on the following conditions:
-        /// 1) A.Field has a non null value 
+        /// 1) A.Field has a non null value
         /// 2) The field has been selected in the comparison flags or the default comparison flags are passed in.
-        /// 
+        ///
         /// If A.Field is null then we will not compare A.Field and B.Field even when the comparison flag is set for that field unless skipNullFields is false.
         /// </summary>
         internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFlags comparisonFlags, bool considerRetargetableFlag)
@@ -927,7 +926,7 @@ internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFl
             }
 
             // If that is null then this and that are not equal. Also, this would cause a crash on the next line.
-            if (object.ReferenceEquals(that, null))
+            if (that is null)
             {
                 return false;
             }
diff --git a/src/Shared/AssemblyUtilities.cs b/src/Shared/AssemblyUtilities.cs
index f33454caec0..f4194346f88 100644
--- a/src/Shared/AssemblyUtilities.cs
+++ b/src/Shared/AssemblyUtilities.cs
@@ -153,8 +153,7 @@ private static CultureInfo[] GetValidCultures()
         {
             var cultureTypesType = s_cultureInfoGetCultureMethod?.GetParameters().FirstOrDefault()?.ParameterType;
 
-            ErrorUtilities.VerifyThrow(cultureTypesType != null &&
-                                       cultureTypesType.Name == "CultureTypes" &&
+            ErrorUtilities.VerifyThrow(cultureTypesType?.Name == "CultureTypes" &&
                                        Enum.IsDefined(cultureTypesType, "AllCultures"),
                                        "GetCulture is expected to accept CultureTypes.AllCultures");
 
diff --git a/src/Shared/AwaitExtensions.cs b/src/Shared/AwaitExtensions.cs
index 26a26b3988e..7a96844a816 100644
--- a/src/Shared/AwaitExtensions.cs
+++ b/src/Shared/AwaitExtensions.cs
@@ -54,7 +54,7 @@ internal static TaskScheduler OneSTAThreadPerTaskSchedulerInstance
         /// <returns>The awaiter.</returns>
         internal static TaskAwaiter GetAwaiter(this WaitHandle handle)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(handle, "handle");
+            ErrorUtilities.VerifyThrowArgumentNull(handle, nameof(handle));
             return handle.ToTask().GetAwaiter();
         }
 
diff --git a/src/Shared/BinaryTranslator.cs b/src/Shared/BinaryTranslator.cs
index d8bd3da94f8..d48be520168 100644
--- a/src/Shared/BinaryTranslator.cs
+++ b/src/Shared/BinaryTranslator.cs
@@ -201,6 +201,17 @@ public void Translate(ref byte[] byteArray)
                 }
             }
 
+            /// <summary>
+            /// Translates a byte array
+            /// </summary>
+            /// <param name="byteArray">The array to be translated.</param>
+            /// <param name="length">The length of array which will be used in translation. This parameter is not used when reading</param>
+            public void Translate(ref byte[] byteArray, ref int length) 
+            {
+                Translate(ref byteArray);
+                length = byteArray.Length;
+            }
+
             /// <summary>
             /// Translates a string array.
             /// </summary>
@@ -786,8 +797,7 @@ public void Translate(ref string[] array)
                     return;
                 }
 
-                int count = 0;
-                count = array.Length;
+                int count = array.Length;
                 _writer.Write(count);
 
                 for (int i = 0; i < count; i++)
@@ -997,17 +1007,27 @@ public void Translate<T>(ref T value)
             /// </summary>
             /// <param name="byteArray">The byte array to be translated</param>
             public void Translate(ref byte[] byteArray)
+            {
+                var length = byteArray?.Length ?? 0;
+                Translate(ref byteArray, ref length);
+            }
+
+            /// <summary>
+            /// Translates a byte array
+            /// </summary>
+            /// <param name="byteArray">The array to be translated.</param>
+            /// <param name="length">The length of array which will be used in translation</param>
+            public void Translate(ref byte[] byteArray, ref int length) 
             {
                 if (!TranslateNullable(byteArray))
                 {
                     return;
                 }
 
-                int count = byteArray.Length;
-                _writer.Write(count);
-                if (count > 0)
+                _writer.Write(length);
+                if (length > 0)
                 {
-                    _writer.Write(byteArray);
+                    _writer.Write(byteArray, 0, length);
                 }
             }
 
diff --git a/src/Shared/BufferedReadStream.cs b/src/Shared/BufferedReadStream.cs
index e907d980e4a..f3f9b6906b3 100644
--- a/src/Shared/BufferedReadStream.cs
+++ b/src/Shared/BufferedReadStream.cs
@@ -144,7 +144,6 @@ protected override void Dispose(bool disposing)
 
             base.Dispose(disposing);
         }
-
         
     }
 }
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index 7a69513847b..a5c7fb21cdd 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -23,7 +23,7 @@ internal class BuildEnvironmentHelper
 
         /// <summary>
         /// Name of the Visual Studio (and Blend) process.
-        // VS ASP intellisense server fails without Microsoft.VisualStudio.Web.Host. Remove when issue fixed: https://devdiv.visualstudio.com/DevDiv/_workitems/edit/574986
+        /// VS ASP intellisense server fails without Microsoft.VisualStudio.Web.Host. Remove when issue fixed: https://devdiv.visualstudio.com/DevDiv/_workitems/edit/574986
         /// </summary>
         private static readonly string[] s_visualStudioProcess = {"DEVENV", "BLEND", "Microsoft.VisualStudio.Web.Host"};
 
@@ -207,7 +207,6 @@ private static BuildEnvironment TryFromMSBuildAssembly()
             }
 
             return null;
-
         }
 
         private static BuildEnvironment TryFromMSBuildAssemblyUnderVisualStudio(string msbuildAssembly, string msbuildExe, bool allowLegacyToolsVersion = false)
@@ -449,7 +448,6 @@ internal static void ResetInstance_ForUnitTestsOnly(Func<string> getProcessFromR
         private static Func<string, string> s_getEnvironmentVariable = GetEnvironmentVariable;
         private static Func<bool> s_runningTests = CheckIfRunningTests;
 
-
         private static class BuildEnvironmentHelperSingleton
         {
             //¬†Explicit¬†static¬†constructor¬†to¬†tell¬†C#¬†compiler
@@ -473,7 +471,7 @@ internal enum BuildEnvironmentMode
         VisualStudio,
 
         /// <summary>
-        /// Running in a standalone toolset mode. All toolsets and extensions paths are relative to the app 
+        /// Running in a standalone toolset mode. All toolsets and extensions paths are relative to the app
         /// running and not dependent on Visual Studio. (e.g. dotnet CLI, open source clone of our repo)
         /// </summary>
         Standalone,
diff --git a/src/Shared/BuildEventFileInfo.cs b/src/Shared/BuildEventFileInfo.cs
index a25508300de..a16e72ee935 100644
--- a/src/Shared/BuildEventFileInfo.cs
+++ b/src/Shared/BuildEventFileInfo.cs
@@ -70,7 +70,7 @@ internal BuildEventFileInfo(string file, int line, int column)
         internal BuildEventFileInfo(string file, int line, int column, int endLine, int endColumn)
         {
             // Projects that don't have a filename when the are built should use an empty string instead.
-            _file = (file == null) ? String.Empty : file;
+            _file = file ?? String.Empty;
             _line = line;
             _column = column;
             _endLine = endLine;
diff --git a/src/Shared/CanonicalError.cs b/src/Shared/CanonicalError.cs
index b4346085d21..f0c247113f6 100644
--- a/src/Shared/CanonicalError.cs
+++ b/src/Shared/CanonicalError.cs
@@ -316,11 +316,11 @@ internal static Parts Parse(string message)
                 }
 
                 category = match.Groups["CATEGORY"].Value.Trim();
-                if (0 == String.Compare(category, "error", StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(category, "error", StringComparison.OrdinalIgnoreCase))
                 {
                     parsedMessage.category = Parts.Category.Error;
                 }
-                else if (0 == String.Compare(category, "warning", StringComparison.OrdinalIgnoreCase))
+                else if (String.Equals(category, "warning", StringComparison.OrdinalIgnoreCase))
                 {
                     parsedMessage.category = Parts.Category.Warning;
                 }
@@ -354,11 +354,11 @@ internal static Parts Parse(string message)
             parsedMessage.subcategory = match.Groups["SUBCATEGORY"].Value.Trim();
 
             // Next, see if category is something that is recognized.
-            if (0 == String.Compare(category, "error", StringComparison.OrdinalIgnoreCase))
+            if (String.Equals(category, "error", StringComparison.OrdinalIgnoreCase))
             {
                 parsedMessage.category = Parts.Category.Error;
             }
-            else if (0 == String.Compare(category, "warning", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(category, "warning", StringComparison.OrdinalIgnoreCase))
             {
                 parsedMessage.category = Parts.Category.Warning;
             }
diff --git a/src/Shared/CollectionHelpers.cs b/src/Shared/CollectionHelpers.cs
index 516706b0fcf..136c4c52d3f 100644
--- a/src/Shared/CollectionHelpers.cs
+++ b/src/Shared/CollectionHelpers.cs
@@ -40,7 +40,7 @@ internal static List<T> RemoveNulls<T>(List<T> inputs)
         /// </summary>
         internal static bool ContainsValueAndIsEqual(this Dictionary<string, string> dictionary, string key, string value, StringComparison comparer)
         {
-            string valueFromDictionary = null;
+            string valueFromDictionary;
             if (dictionary.TryGetValue(key, out valueFromDictionary))
             {
                 return String.Equals(value, valueFromDictionary, comparer);
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 2bb61d35127..6ef1da20e51 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -7,12 +7,12 @@
 using System.Globalization;
 using System.IO;
 using System.IO.Pipes;
+using System.Reflection;
 using System.Runtime.InteropServices;
 using System.Security.Principal;
 using System.Threading;
 
 using Microsoft.Build.Shared;
-using System.Reflection;
 
 #if !FEATURE_APM
 using System.Threading.Tasks;
@@ -51,7 +51,64 @@ internal enum HandshakeOptions
         /// <summary>
         /// Building with BelowNormal priority
         /// </summary>
-        LowPriority = 16
+        LowPriority = 16,
+
+        /// <summary>
+        /// Building with administrator privileges
+        /// </summary>
+        Administrator = 32,
+
+        /// <summary>
+        /// Is a special node. Special nodes cannot accept normal build requests.
+        /// </summary>
+        Special = 64
+    }
+
+    internal readonly struct Handshake
+    {
+        readonly int options;
+        readonly int salt;
+        readonly int fileVersionMajor;
+        readonly int fileVersionMinor;
+        readonly int fileVersionBuild;
+        readonly int fileVersionPrivate;
+        readonly int sessionId;
+
+        internal Handshake(HandshakeOptions nodeType)
+        {
+            // We currently use 6 bits of this 32-bit integer. Very old builds will instantly reject any handshake that does not start with F5 or 06; slightly old builds always lead with 00.
+            // This indicates in the first byte that we are a modern build.
+            options = (int)nodeType | (((int)CommunicationsUtilities.handshakeVersion) << 24);
+            string handshakeSalt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
+            string toolsDirectory = (nodeType & HandshakeOptions.X64) == HandshakeOptions.X64 ? BuildEnvironmentHelper.Instance.MSBuildToolsDirectory64 : BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32;
+            salt = CommunicationsUtilities.GetHandshakeHashCode(handshakeSalt + toolsDirectory);
+            Version fileVersion = new Version(FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location).FileVersion);
+            fileVersionMajor = fileVersion.Major;
+            fileVersionMinor = fileVersion.Minor;
+            fileVersionBuild = fileVersion.Build;
+            fileVersionPrivate = fileVersion.Revision;
+            sessionId = Process.GetCurrentProcess().SessionId;
+        }
+
+        // This is used as a key, so it does not need to be human readable.
+        public override string ToString()
+        {
+            return String.Format("{0} {1} {2} {3} {4} {5} {6}", options, salt, fileVersionMajor, fileVersionMinor, fileVersionBuild, fileVersionPrivate, sessionId);
+        }
+
+        internal int[] RetrieveHandshakeComponents()
+        {
+            return new int[]
+            {
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(options),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(salt),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMajor),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMinor),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionBuild),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionPrivate),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(sessionId)
+            };
+        }
     }
 
     /// <summary>
@@ -60,19 +117,19 @@ internal enum HandshakeOptions
     static internal class CommunicationsUtilities
     {
         /// <summary>
-        /// The timeout to connect to a node.
+        /// Indicates to the NodeEndpoint that all the various parts of the Handshake have been sent.
         /// </summary>
-        private const int DefaultNodeConnectionTimeout = 900 * 1000; // 15 minutes; enough time that a dev will typically do another build in this time
+        private const int EndOfHandshakeSignal = -0x2a2a2a2a;
 
         /// <summary>
-        /// Flag if we have already calculated the FileVersion hashcode
+        /// The version of the handshake. This should be updated each time the handshake structure is altered.
         /// </summary>
-        private static bool s_fileVersionChecked;
+        internal const byte handshakeVersion = 0x01;
 
         /// <summary>
-        /// A hashcode calculated from the fileversion
+        /// The timeout to connect to a node.
         /// </summary>
-        private static int s_fileVersionHash;
+        private const int DefaultNodeConnectionTimeout = 900 * 1000; // 15 minutes; enough time that a dev will typically do another build in this time
 
         /// <summary>
         /// Whether to trace communications
@@ -102,45 +159,19 @@ static internal int NodeConnectionTimeout
             get { return GetIntegerVariableOrDefault("MSBUILDNODECONNECTIONTIMEOUT", DefaultNodeConnectionTimeout); }
         }
 
+        private static int? _clrVersion = null;
         /// <summary>
-        /// Looks up the file version and caches the hashcode
-        /// This file version hashcode is used in calculating the handshake
+        /// Provides cached value of current CLR version
         /// </summary>
-        private static int FileVersionHash
+        private static int ClrVersion
         {
             get
             {
-                if (!s_fileVersionChecked)
+                if (!_clrVersion.HasValue)
                 {
-                    // We only hash in any complus_installroot value, not a file version.
-                    // This is because in general msbuildtaskhost.exe does not load any assembly that
-                    // the parent process loads, so they can't compare the version of a particular assembly.
-                    // They can't compare their own versions, because if one of them is serviced, they
-                    // won't match any more. The only known incompatibility is between a razzle and non-razzle
-                    // parent and child. COMPLUS_Version can (and typically will) differ legitimately between
-                    // them, so just check COMPLUS_InstallRoot.
-                    string complusInstallRoot = Environment.GetEnvironmentVariable("COMPLUS_INSTALLROOT");
-
-                    // This is easier in .NET 4+:
-                    //  var fileIdentity = typeof(CommunicationsUtilities).GetTypeInfo().Assembly.GetCustomAttribute<AssemblyInformationalVersionAttribute>().InformationalVersion;
-                    // but we need to be 3.5 compatible here to work in MSBuildTaskHost
-                    string fileIdentity = null;
-                    foreach (var attribute in typeof(CommunicationsUtilities).GetTypeInfo().Assembly.GetCustomAttributes(false))
-                    {
-                        if (attribute is AssemblyInformationalVersionAttribute informationalVersionAttribute)
-                        {
-                            fileIdentity = informationalVersionAttribute.InformationalVersion;
-                            break;
-                        }
-                    }
-
-                    ErrorUtilities.VerifyThrow(fileIdentity != null, "Did not successfully retrieve InformationalVersion.");
-
-                    s_fileVersionHash = GetHandshakeHashCode(complusInstallRoot ?? fileIdentity);
-                    s_fileVersionChecked = true;
+                    _clrVersion = typeof(bool).GetTypeInfo().Assembly.GetName().Version.Major;
                 }
-
-                return s_fileVersionHash;
+                return _clrVersion.Value;
             }
         }
 
@@ -291,70 +322,19 @@ internal static void SetEnvironment(IDictionary<string, string> newEnvironment)
             }
         }
 
+#nullable enable
         /// <summary>
-        /// Given a base handshake, generates the real handshake based on e.g. elevation level.  
-        /// </summary>
-        private static long GenerateHostHandshakeFromBase(long baseHandshake)
-        {
-#if FEATURE_SECURITY_PRINCIPAL_WINDOWS
-            // If we are running in elevated privs, we will only accept a handshake from an elevated process as well.
-            WindowsPrincipal principal = new WindowsPrincipal(WindowsIdentity.GetCurrent());
-
-            // Both the client and the host will calculate this separately, and the idea is that if they come out the same
-            // then we can be sufficiently confident that the other side has the same elevation level as us.  This is complementary
-            // to the username check which is also done on connection.
-            if (principal.IsInRole(WindowsBuiltInRole.Administrator))
-            {
-                unchecked
-                {
-                    baseHandshake = baseHandshake ^ 0x5c5c5c5c5c5c5c5c + Process.GetCurrentProcess().SessionId;
-                }
-            }
-#endif
-
-            // Mask out the first byte. Modern builds expect the first byte to be zero to indicate that they are modern
-            // and should be treated as such. Older builds used a non-zero initial byte. See here:
-            // https://github.com/microsoft/msbuild/blob/584ca5f11b28971f5651b4b8de5f173ad1cb2786/src/Shared/NodeEndpointOutOfProcBase.cs#L403.
-            return baseHandshake & 0x00FFFFFFFFFFFFFF;
-        }
-
-        /// <summary>
-        /// Magic number sent by the host to the client during the handshake.
-        /// Derived from the binary timestamp to avoid mixing binary versions.
-        /// </summary>
-        internal static long GetHostHandshake(HandshakeOptions nodeType)
-        {
-            string salt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
-            string toolsDirectory = (nodeType & HandshakeOptions.X64) == HandshakeOptions.X64 ? BuildEnvironmentHelper.Instance.MSBuildToolsDirectory64 : BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32;
-            int nodeHandshakeSalt = GetHandshakeHashCode(salt + toolsDirectory);
-
-            Trace("MSBUILDNODEHANDSHAKESALT=\"{0}\", msbuildDirectory=\"{1}\", nodeType={2}, FileVersionHash={3}", salt, toolsDirectory, nodeType, FileVersionHash);
-
-            // FileVersionHash (32 bits) is shifted 8 bits to avoid session ID collision
-            // HandshakeOptions (5 bits) is shifted just after the FileVersionHash
-            // remaining bits of nodeHandshakeSalt (32 bits truncated to 11) are shifted next
-            //      nodeHandshakeSalt    | HandshakeOptions |             fileVersionHash           | SessionID
-            //  0000 0000 0000 0000 000        0 0000        0000 0000 0000 0000 0000 0000 0000 0000  0000 0000
-            unchecked
-            {
-                ulong baseHandshake = ((ulong)(uint)nodeHandshakeSalt << 45) | ((ulong)(uint)nodeType << 40) | ((ulong)(uint)FileVersionHash << 8);
-                return GenerateHostHandshakeFromBase((long)baseHandshake);
-            }
-        }
-
-        /// <summary>
-        /// Magic number sent by the client to the host during the handshake.
-        /// Munged version of the host handshake.
+        /// Indicate to the client that all elements of the Handshake have been sent.
         /// </summary>
-        internal static long GetClientHandshake(HandshakeOptions hostContext)
+        internal static void WriteEndOfHandshakeSignal(this PipeStream stream)
         {
-            return ~GetHostHandshake(hostContext);
+            stream.WriteIntForHandshake(EndOfHandshakeSignal);
         }
 
         /// <summary>
         /// Extension method to write a series of bytes to a stream
         /// </summary>
-        internal static void WriteLongForHandshake(this PipeStream stream, long value)
+        internal static void WriteIntForHandshake(this PipeStream stream, int value)
         {
             byte[] bytes = BitConverter.GetBytes(value);
 
@@ -365,39 +345,49 @@ internal static void WriteLongForHandshake(this PipeStream stream, long value)
                 Array.Reverse(bytes);
             }
 
-            ErrorUtilities.VerifyThrow(bytes.Length == 8, "Long should be 8 bytes");
+            ErrorUtilities.VerifyThrow(bytes.Length == 4, "Int should be 4 bytes");
 
             stream.Write(bytes, 0, bytes.Length);
         }
 
-        /// <summary>
-        /// Extension method to read a series of bytes from a stream
-        /// </summary>
-        internal static long ReadLongForHandshake(this PipeStream stream
+        internal static void ReadEndOfHandshakeSignal(this PipeStream stream, bool isProvider
 #if NETCOREAPP2_1 || MONO
-            , int handshakeReadTimeout
+            , int timeout
 #endif
             )
         {
-            return stream.ReadLongForHandshake((byte[])null, 0
+            // Accept only the first byte of the EndOfHandshakeSignal
+            int valueRead = stream.ReadIntForHandshake(null
 #if NETCOREAPP2_1 || MONO
-                , handshakeReadTimeout
+            , timeout
 #endif
                 );
+
+            if (valueRead != EndOfHandshakeSignal)
+            {
+                if (isProvider)
+                {
+                    CommunicationsUtilities.Trace("Handshake failed on part {0}. Probably the client is a different MSBuild build.", valueRead);
+                }
+                else
+                {
+                    CommunicationsUtilities.Trace("Expected end of handshake signal but received {0}. Probably the host is a different MSBuild build.", valueRead);
+                }
+                throw new InvalidOperationException();
+            }
         }
 
         /// <summary>
         /// Extension method to read a series of bytes from a stream.
         /// If specified, leading byte matches one in the supplied array if any, returns rejection byte and throws IOException.
         /// </summary>
-        internal static long ReadLongForHandshake(this PipeStream stream, byte[] leadingBytesToReject,
-            byte rejectionByteToReturn
+        internal static int ReadIntForHandshake(this PipeStream stream, byte? byteToAccept
 #if NETCOREAPP2_1 || MONO
             , int timeout
 #endif
             )
         {
-            byte[] bytes = new byte[8];
+            byte[] bytes = new byte[4];
 
 #if NETCOREAPP2_1 || MONO
             if (!NativeMethodsShared.IsWindows)
@@ -437,24 +427,18 @@ byte rejectionByteToReturn
                         throw new IOException(String.Format(CultureInfo.InvariantCulture, "Unexpected end of stream while reading for handshake"));
                     }
 
-                    if (i == 0 && leadingBytesToReject != null)
-                    {
-                        foreach (byte reject in leadingBytesToReject)
-                        {
-                            if (read == reject)
-                            {
-                                stream.WriteByte(rejectionByteToReturn); // disconnect the host
+                    bytes[i] = Convert.ToByte(read);
 
-                                throw new IOException(String.Format(CultureInfo.InvariantCulture, "Client: rejected old host. Received byte {0} but this matched a byte to reject.", bytes[i]));  // disconnect and quit
-                            }
-                        }
+                    if (i == 0 && byteToAccept != null && byteToAccept != bytes[0])
+                    {
+                        stream.WriteIntForHandshake(0x0F0F0F0F);
+                        stream.WriteIntForHandshake(0x0F0F0F0F);
+                        throw new InvalidOperationException(String.Format(CultureInfo.InvariantCulture, "Client: rejected old host. Received byte {0} instead of {1}.", bytes[0], byteToAccept));
                     }
-
-                    bytes[i] = Convert.ToByte(read);
                 }
             }
 
-            long result;
+            int result;
 
             try
             {
@@ -465,7 +449,7 @@ byte rejectionByteToReturn
                     Array.Reverse(bytes);
                 }
 
-                result = BitConverter.ToInt64(bytes, 0 /* start index */);
+                result = BitConverter.ToInt32(bytes, 0 /* start index */);
             }
             catch (ArgumentException ex)
             {
@@ -474,6 +458,7 @@ byte rejectionByteToReturn
 
             return result;
         }
+#nullable disable
 
 #if !FEATURE_APM
         internal static async Task<int> ReadAsync(Stream stream, byte[] buffer, int bytesToRead)
@@ -495,17 +480,19 @@ internal static async Task<int> ReadAsync(Stream stream, byte[] buffer, int byte
         /// <summary>
         /// Given the appropriate information, return the equivalent HandshakeOptions.
         /// </summary>
-        internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit = false, int clrVersion = 0, bool nodeReuse = false, bool lowPriority = false, IDictionary<string, string> taskHostParameters = null)
+        internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit = false, bool nodeReuse = false, bool lowPriority = false, bool specialNode = false, IDictionary<string, string> taskHostParameters = null)
         {
             HandshakeOptions context = taskHost ? HandshakeOptions.TaskHost : HandshakeOptions.None;
 
+            int clrVersion = 0;
+
             // We don't know about the TaskHost. Figure it out.
-            if (taskHost && clrVersion == 0)
+            if (taskHost)
             {
                 // Take the current TaskHost context
                 if (taskHostParameters == null)
                 {
-                    clrVersion = typeof(bool).GetTypeInfo().Assembly.GetName().Version.Major;
+                    clrVersion = ClrVersion;
                     is64Bit = XMakeAttributes.GetCurrentMSBuildArchitecture().Equals(XMakeAttributes.MSBuildArchitectureValues.x64);
                 }
                 else
@@ -517,6 +504,7 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit
                     is64Bit = taskHostParameters[XMakeAttributes.architecture].Equals(XMakeAttributes.MSBuildArchitectureValues.x64);
                 }
             }
+
             if (is64Bit)
             {
                 context |= HandshakeOptions.X64;
@@ -533,6 +521,20 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit
             {
                 context |= HandshakeOptions.LowPriority;
             }
+#if FEATURE_SECURITY_PRINCIPAL_WINDOWS
+            // If we are running in elevated privs, we will only accept a handshake from an elevated process as well.
+            // Both the client and the host will calculate this separately, and the idea is that if they come out the same
+            // then we can be sufficiently confident that the other side has the same elevation level as us.  This is complementary
+            // to the username check which is also done on connection.
+            if (new WindowsPrincipal(WindowsIdentity.GetCurrent()).IsInRole(WindowsBuiltInRole.Administrator))
+            {
+                context |= HandshakeOptions.Administrator;
+            }
+#endif
+            if (specialNode)
+            {
+                context |= HandshakeOptions.Special;
+            }
             return context;
         }
 
@@ -646,5 +648,17 @@ internal static int GetHandshakeHashCode(string fileVersion)
                 }
             }
         }
+
+        internal static int AvoidEndOfHandshakeSignal(int x)
+        {
+            return x == EndOfHandshakeSignal ? ~x : x;
+        }
+
+        internal static string GetRarPipeName(bool nodeReuse, bool lowPriority)
+        {
+            var context = GetHandshakeOptions(taskHost: true, nodeReuse: nodeReuse, lowPriority: lowPriority, specialNode: true);
+            var userName = $"{Environment.UserDomainName}.{Environment.UserName}";
+            return $"MSBuild.RAR.{userName}.{(int)context}";
+        }
     }
 }
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index d2beb125f24..5be780dc59a 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -177,5 +177,6 @@ internal static class ItemMetadataNames
         internal const string PropertiesMetadataName = "Properties";
         internal const string UndefinePropertiesMetadataName = "UndefineProperties";
         internal const string AdditionalPropertiesMetadataName = "AdditionalProperties";
+        internal const string ProjectConfigurationDescription = "ProjectConfigurationDescription";
     }
 }
diff --git a/src/Shared/ConversionUtilities.cs b/src/Shared/ConversionUtilities.cs
index 14cf1d2d866..b2d1c705bae 100644
--- a/src/Shared/ConversionUtilities.cs
+++ b/src/Shared/ConversionUtilities.cs
@@ -70,7 +70,7 @@ internal static string ConvertByteArrayToHex(byte[] bytes)
         /// </summary>
         internal static bool CanConvertStringToBool(string parameterValue)
         {
-            return (ValidBooleanTrue(parameterValue) || ValidBooleanFalse(parameterValue));
+            return ValidBooleanTrue(parameterValue) || ValidBooleanFalse(parameterValue);
         }
 
         /// <summary>
diff --git a/src/Shared/CopyOnWriteDictionary.cs b/src/Shared/CopyOnWriteDictionary.cs
index b884ff4389c..1aec0557596 100644
--- a/src/Shared/CopyOnWriteDictionary.cs
+++ b/src/Shared/CopyOnWriteDictionary.cs
@@ -4,10 +4,14 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using System.Collections.Immutable;
 using System.Diagnostics.CodeAnalysis;
+using System.Linq;
 using System.Runtime.Serialization;
 using Microsoft.Build.Shared;
 
+#nullable enable
+
 namespace Microsoft.Build.Collections
 {
     /// <summary>
@@ -17,14 +21,6 @@ namespace Microsoft.Build.Collections
     /// <typeparam name="K">The key type.</typeparam>
     /// <typeparam name="V">The value type.</typeparam>
     /// <remarks>
-    /// This dictionary works by having a backing dictionary which is ref-counted for each
-    /// COWDictionary which references it.  When a write operation is performed on any
-    /// COWDictionary, we check the reference count on the backing dictionary.  If it is 
-    /// greater than 1, it means any changes we make to it would be visible to other readers.
-    /// Therefore, we clone the backing dictionary and decrement the reference count on the
-    /// original.  From there on we use the cloned dictionary, which now has a reference count
-    /// of 1.
-    ///
     /// Thread safety: for all users, this class is as thread safe as the underlying Dictionary implementation, that is,
     /// safe for concurrent readers or one writer from EACH user. It achieves this by locking itself and cloning before
     /// any write, if it is being shared - i.e., stopping sharing before any writes occur.
@@ -34,31 +30,20 @@ namespace Microsoft.Build.Collections
     /// be run in a separate appdomain.
     /// </comment>
     [Serializable]
-    internal class CopyOnWriteDictionary<K, V> : IDictionary<K, V>, IDictionary
+    internal class CopyOnWriteDictionary<K, V> : IDictionary<K, V>, IDictionary, ISerializable
     {
-#if DEBUG
-        /// <summary>
-        /// When set forces immediate copy
-        /// </summary>
-        private static readonly bool s_forceWrite = (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDFORCECOWCOPY")));
-#endif
-
-        /// <summary>
-        /// The default capacity.
-        /// </summary>
-        private readonly int capacity;
-
         /// <summary>
         /// The backing dictionary.
         /// Lazily created.
         /// </summary>
-        private CopyOnWriteBackingDictionary<K, V> backing;
+        private ImmutableDictionary<K, V> _backing;
 
         /// <summary>
         /// Constructor. Consider supplying a comparer instead.
         /// </summary>
         internal CopyOnWriteDictionary()
         {
+            _backing = ImmutableDictionary<K, V>.Empty;
         }
 
         /// <summary>
@@ -80,19 +65,24 @@ internal CopyOnWriteDictionary(IEqualityComparer<K> keyComparer)
         /// <summary>
         /// Constructor taking a specified comparer for the keys and an initial capacity
         /// </summary>
-        internal CopyOnWriteDictionary(int capacity, IEqualityComparer<K> keyComparer)
+        internal CopyOnWriteDictionary(int capacity, IEqualityComparer<K>? keyComparer)
         {
-            this.capacity = capacity;
-            Comparer = keyComparer;
+            _backing = ImmutableDictionary.Create<K, V>(keyComparer);
         }
 
         /// <summary>
         /// Serialization constructor, for crossing appdomain boundaries
         /// </summary>
-        [SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "info", Justification = "Not needed")]
         [SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "context", Justification = "Not needed")]
         protected CopyOnWriteDictionary(SerializationInfo info, StreamingContext context)
         {
+            object v = info.GetValue(nameof(_backing), typeof(KeyValuePair<K, V>[]));
+
+            object comparer = info.GetValue(nameof(Comparer), typeof(IEqualityComparer<K>));
+
+            var b = ImmutableDictionary.Create<K, V>((IEqualityComparer<K>)comparer);
+
+            _backing = b.AddRange((KeyValuePair<K, V>[])v);
         }
 
         /// <summary>
@@ -100,44 +90,33 @@ protected CopyOnWriteDictionary(SerializationInfo info, StreamingContext context
         /// </summary>
         private CopyOnWriteDictionary(CopyOnWriteDictionary<K, V> that)
         {
-            Comparer = that.Comparer;
-            backing = that.backing;
-            if (backing != null)
-            {
-                lock (((ICollection)backing).SyncRoot)
-                {
-                    backing.AddRef();
-                }
-            }
+            _backing = that._backing;
         }
 
         public CopyOnWriteDictionary(IDictionary<K, V> dictionary)
         {
-            foreach (KeyValuePair<K, V> pair in dictionary)
-            {
-                this[pair.Key] = pair.Value;
-            }
+            _backing = dictionary.ToImmutableDictionary();
         }
 
         /// <summary>
         /// Returns the collection of keys in the dictionary.
         /// </summary>
-        public ICollection<K> Keys => ReadOperation.Keys;
+        public ICollection<K> Keys => ((IDictionary<K, V>)_backing).Keys;
 
         /// <summary>
         /// Returns the collection of values in the dictionary.
         /// </summary>
-        public ICollection<V> Values => ReadOperation.Values;
+        public ICollection<V> Values => ((IDictionary<K, V>)_backing).Values;
 
         /// <summary>
         /// Returns the number of items in the collection.
         /// </summary>
-        public int Count => ReadOperation.Count;
+        public int Count => _backing.Count;
 
         /// <summary>
         /// Returns true if the collection is read-only.
         /// </summary>
-        public bool IsReadOnly => ((IDictionary<K, V>)ReadOperation).IsReadOnly;
+        public bool IsReadOnly => ((IDictionary<K, V>)_backing).IsReadOnly;
 
         /// <summary>
         /// IDictionary implementation
@@ -174,83 +153,13 @@ public CopyOnWriteDictionary(IDictionary<K, V> dictionary)
         /// </summary>
         object ICollection.SyncRoot => this;
 
-        /// <summary>
-        /// A special single dummy instance that always appears empty.
-        /// </summary>
-        internal static CopyOnWriteDictionary<K, V> Dummy { get; } = new CopyOnWriteDictionary<K, V> { _isDummy = true };
-
-        /// <summary>
-        /// Whether this is a dummy instance that always appears empty.
-        /// </summary>
-        internal bool IsDummy
-        {
-            get
-            {
-                if (_isDummy)
-                {
-                    ErrorUtilities.VerifyThrow(backing == null || backing.Count == 0, "count"); // check count without recursion
-                }
-
-                return _isDummy;
-            }
-        }
-
-        private bool _isDummy;
-
         /// <summary>
         /// Comparer used for keys
         /// </summary>
-        internal IEqualityComparer<K> Comparer { get; private set; }
-
-        /// <summary>
-        /// Gets the backing dictionary for reading.
-        /// </summary>
-        private CopyOnWriteBackingDictionary<K, V> ReadOperation
+        internal IEqualityComparer<K> Comparer
         {
-            get
-            {
-                ErrorUtilities.VerifyThrow(!IsDummy || backing == null || backing.Count == 0, "count"); // check count without recursion
-#if DEBUG
-                if (s_forceWrite)
-                {
-                    if (!IsDummy)
-                    {
-                        return WriteOperation;
-                    }
-                }
-#endif
-                if (backing == null)
-                {
-                    return CopyOnWriteBackingDictionary<K, V>.ReadOnlyEmptyInstance;
-                }
-
-                return backing;
-            }
-        }
-
-        /// <summary>
-        /// Gets the backing dictionary for writing.
-        /// </summary>
-        private CopyOnWriteBackingDictionary<K, V> WriteOperation
-        {
-            get
-            {
-                ErrorUtilities.VerifyThrow(!IsDummy, "dummy");
-
-                if (backing == null)
-                {
-                    backing = new CopyOnWriteBackingDictionary<K, V>(capacity, Comparer);
-                }
-                else
-                {
-                    lock (((ICollection)backing).SyncRoot)
-                    {
-                        backing = backing.CloneForWriteIfNecessary();
-                    }
-                }
-
-                return backing;
-            }
+            get => _backing.KeyComparer;
+            private set => _backing = _backing.WithComparers(keyComparer: value);
         }
 
         /// <summary>
@@ -258,28 +167,15 @@ private CopyOnWriteBackingDictionary<K, V> WriteOperation
         /// </summary>
         public V this[K key]
         {
-            get => ReadOperation[key];
+            get => _backing[key];
 
             set
             {
-                if (!IsDummy)
-                {
-                    if (ReadOperation.HasNoClones)
-                    {
-                        WriteOperation[key] = value;
-                    }
-                    else
-                    {
-                        // Try to avoid a clone if it already is present with the same value
-                        if (!ReadOperation.TryGetValue(key, out V existingValue) || !EqualityComparer<V>.Default.Equals(existingValue, value))
-                        {
-                            WriteOperation[key] = value;
-                        }
-                    }
-                }
+                _backing = _backing.SetItem(key, value);
             }
         }
 
+#nullable disable
         /// <summary>
         /// IDictionary implementation
         /// </summary>
@@ -293,16 +189,14 @@ object IDictionary.this[object key]
 
             set => this[(K)key] = (V)value;
         }
+#nullable restore
 
         /// <summary>
         /// Adds a value to the dictionary.
         /// </summary>
         public void Add(K key, V value)
         {
-            if (!IsDummy)
-            {
-                WriteOperation.Add(key, value);
-            }
+            _backing = _backing.SetItem(key, value);
         }
 
         /// <summary>
@@ -310,7 +204,7 @@ public void Add(K key, V value)
         /// </summary>
         public bool ContainsKey(K key)
         {
-            return ReadOperation.ContainsKey(key);
+            return _backing.ContainsKey(key);
         }
 
         /// <summary>
@@ -318,16 +212,11 @@ public bool ContainsKey(K key)
         /// </summary>
         public bool Remove(K key)
         {
-            // Avoid a clone if it's not present
-            if (ReadOperation.HasNoClones || ReadOperation.ContainsKey(key))
-            {
-                if (!IsDummy)
-                {
-                    return WriteOperation.Remove(key);
-                }
-            }
+            ImmutableDictionary<K, V> initial = _backing;
 
-            return false;
+            _backing = _backing.Remove(key);
+
+            return initial != _backing; // whether the removal occured
         }
 
         /// <summary>
@@ -335,7 +224,7 @@ public bool Remove(K key)
         /// </summary>
         public bool TryGetValue(K key, out V value)
         {
-            return ReadOperation.TryGetValue(key, out value);
+            return _backing.TryGetValue(key, out value);
         }
 
         /// <summary>
@@ -343,10 +232,7 @@ public bool TryGetValue(K key, out V value)
         /// </summary>
         public void Add(KeyValuePair<K, V> item)
         {
-            if (!IsDummy)
-            {
-                ((IDictionary<K, V>)WriteOperation).Add(item);
-            }
+            _backing = _backing.SetItem(item.Key, item.Value);
         }
 
         /// <summary>
@@ -354,13 +240,7 @@ public void Add(KeyValuePair<K, V> item)
         /// </summary>
         public void Clear()
         {
-            if (ReadOperation.Count > 0)
-            {
-                if (!IsDummy)
-                {
-                    WriteOperation.Clear();
-                }
-            }
+            _backing = _backing.Clear();
         }
 
         /// <summary>
@@ -368,7 +248,7 @@ public void Clear()
         /// </summary>
         public bool Contains(KeyValuePair<K, V> item)
         {
-            return ((IDictionary<K, V>)ReadOperation).Contains(item);
+            return _backing.Contains(item);
         }
 
         /// <summary>
@@ -376,7 +256,7 @@ public bool Contains(KeyValuePair<K, V> item)
         /// </summary>
         public void CopyTo(KeyValuePair<K, V>[] array, int arrayIndex)
         {
-            ((IDictionary<K, V>)ReadOperation).CopyTo(array, arrayIndex);
+            ((IDictionary<K, V>)_backing).CopyTo(array, arrayIndex);
         }
 
         /// <summary>
@@ -384,16 +264,11 @@ public void CopyTo(KeyValuePair<K, V>[] array, int arrayIndex)
         /// </summary>
         public bool Remove(KeyValuePair<K, V> item)
         {
-            // If it doesn't already contain the key, avoid copying the dictionary.
-            if (ReadOperation.HasNoClones || ReadOperation.ContainsKey(item.Key))
-            {
-                if (!IsDummy)
-                {
-                    return ((IDictionary<K, V>)WriteOperation).Remove(item);
-                }
-            }
+            ImmutableDictionary<K, V> initial = _backing;
+
+            _backing = _backing.Remove(item.Key);
 
-            return false;
+            return initial != _backing; // whether the removal occured
         }
 
         /// <summary>
@@ -401,7 +276,7 @@ public bool Remove(KeyValuePair<K, V> item)
         /// </summary>
         public IEnumerator<KeyValuePair<K, V>> GetEnumerator()
         {
-            return ReadOperation.GetEnumerator();
+            return _backing.GetEnumerator();
         }
 
         /// <summary>
@@ -441,7 +316,7 @@ bool IDictionary.Contains(object key)
         /// </summary>
         IDictionaryEnumerator IDictionary.GetEnumerator()
         {
-            return ((IDictionary)ReadOperation).GetEnumerator();
+            return ((IDictionary)_backing).GetEnumerator();
         }
 
         /// <summary>
@@ -478,113 +353,16 @@ internal CopyOnWriteDictionary<K, V> Clone()
         /// </summary>
         internal bool HasSameBacking(CopyOnWriteDictionary<K, V> other)
         {
-            return ReferenceEquals(other.backing, backing);
+            return ReferenceEquals(other._backing, _backing);
         }
 
-        /// <summary>
-        /// A dictionary which is reference counted to allow several references for read operations, but knows when to clone for
-        /// write operations.
-        /// </summary>
-        /// <typeparam name="K1">The key type.</typeparam>
-        /// <typeparam name="V1">The value type.</typeparam>
-        [Serializable]
-        private class CopyOnWriteBackingDictionary<K1, V1> : Dictionary<K1, V1>
+        public void GetObjectData(SerializationInfo info, StreamingContext context)
         {
-            /// <summary>
-            /// An empty dictionary 
-            /// </summary>
-            [SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Justification = "Error in code analysis.")]
-            private static readonly CopyOnWriteBackingDictionary<K1, V1> s_readOnlyEmptyDictionary = new CopyOnWriteBackingDictionary<K1, V1>();
-
-            /// <summary>
-            /// The reference count. 
-            /// </summary>
-            [SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Justification = "Error in code analysis.")]
-            [NonSerialized]
-            private int _refCount = 1;
-
-            /// <summary>
-            /// Constructor.
-            /// </summary>
-            public CopyOnWriteBackingDictionary(int capacity, IEqualityComparer<K1> comparer)
-                : base(capacity, comparer)
-            {
-                // Tracing.Record("New COWBD");
-            }
-
-            /// <summary>
-            /// Serialization constructor, for crossing appdomain boundaries
-            /// </summary>
-            protected CopyOnWriteBackingDictionary(SerializationInfo info, StreamingContext context)
-                : base(info, context)
-            {
-            }
+            ImmutableDictionary<K, V> snapshot = _backing;
+            KeyValuePair<K, V>[] array = snapshot.ToArray();
 
-            /// <summary>
-            /// Empty constructor.
-            /// </summary>
-            private CopyOnWriteBackingDictionary()
-            {
-            }
-
-            /// <summary>
-            /// Cloning constructor.
-            /// </summary>
-            private CopyOnWriteBackingDictionary(CopyOnWriteBackingDictionary<K1, V1> that)
-                : base(that, that.Comparer)
-            {
-                // Tracing.Record("New COWBD-clone");
-            }
-
-            /// <summary>
-            /// Returns a read-only empty instance.
-            /// </summary>
-            public static CopyOnWriteBackingDictionary<K1, V1> ReadOnlyEmptyInstance => s_readOnlyEmptyDictionary;
-
-            /// <summary>
-            /// Returns true if this collection has no clones.
-            /// </summary>
-            public bool HasNoClones
-            {
-                get
-                {
-                    ErrorUtilities.VerifyThrow(_refCount >= 1, "refCount should not be less than 1.");
-                    return _refCount == 1;
-                }
-            }
-
-            /// <summary>
-            /// Clones backing dictionary if necessary for a write operation.
-            /// </summary>
-            public CopyOnWriteBackingDictionary<K1, V1> CloneForWriteIfNecessary()
-            {
-                if (!HasNoClones)
-                {
-                    _refCount--;
-                    return new CopyOnWriteBackingDictionary<K1, V1>(this);
-                }
-
-                return this;
-            }
-
-            /// <summary>
-            /// Adds a reader-reference to this backing dictionary.
-            /// </summary>
-            public int AddRef()
-            {
-                return ++_refCount;
-            }
-
-            /// <summary>
-            /// Deserialization does not call any constructors, not even
-            /// the parameterless constructor. Therefore since we do not serialize
-            /// this field, we must populate it here.
-            /// </summary>
-            [OnDeserialized]
-            private void OnDeserialized(StreamingContext context)
-            {
-                _refCount = 1;
-            }
+            info.AddValue(nameof(_backing), array);
+            info.AddValue(nameof(Comparer), Comparer);
         }
     }
 }
diff --git a/src/Shared/Debugging/PrintLineDebugger.cs b/src/Shared/Debugging/PrintLineDebugger.cs
index b6f1bf71261..fc5b610c0fe 100644
--- a/src/Shared/Debugging/PrintLineDebugger.cs
+++ b/src/Shared/Debugging/PrintLineDebugger.cs
@@ -63,15 +63,12 @@ NodeMode ScanNodeMode(string input)
 
                     Trace.Assert(!string.IsNullOrEmpty(nodeMode));
 
-                    switch (nodeMode)
+                    return nodeMode switch
                     {
-                        case "1":
-                            return NodeMode.OutOfProcNode;
-                        case "2":
-                            return NodeMode.OutOfProcTaskHostNode;
-                        default:
-                            throw new NotImplementedException();
-                    }
+                        "1" => NodeMode.OutOfProcNode,
+                        "2" => NodeMode.OutOfProcTaskHostNode,
+                        _ => throw new NotImplementedException(),
+                    };
                 }
             });
 
diff --git a/src/Shared/ErrorUtilities.cs b/src/Shared/ErrorUtilities.cs
index 641980fc490..439a8491f96 100644
--- a/src/Shared/ErrorUtilities.cs
+++ b/src/Shared/ErrorUtilities.cs
@@ -767,7 +767,7 @@ internal static void VerifyThrowArgumentInvalidPath(string parameter, string par
         /// </summary>
         internal static void VerifyThrowArgumentLengthIfNotNull(string parameter, string parameterName)
         {
-            if (parameter != null && parameter.Length == 0 && s_throwExceptions)
+            if (parameter?.Length == 0 && s_throwExceptions)
             {
                 throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Shared.ParameterCannotHaveZeroLength", parameterName));
             }
diff --git a/src/Shared/EscapingUtilities.cs b/src/Shared/EscapingUtilities.cs
index 13d43fc0c3f..965175bdbed 100644
--- a/src/Shared/EscapingUtilities.cs
+++ b/src/Shared/EscapingUtilities.cs
@@ -167,9 +167,9 @@ private static string EscapeWithOptionalCaching(string unescapedString, bool cac
             // next, if we're caching, check to see if it's already there.
             if (cache)
             {
-                string cachedEscapedString = null;
                 lock (s_unescapedToEscapedStrings)
                 {
+                    string cachedEscapedString;
                     if (s_unescapedToEscapedStrings.TryGetValue(unescapedString, out cachedEscapedString))
                     {
                         return cachedEscapedString;
@@ -210,7 +210,7 @@ private static bool ContainsReservedCharacters
             string unescapedString
             )
         {
-            return (-1 != unescapedString.IndexOfAny(s_charsToEscape));
+            return -1 != unescapedString.IndexOfAny(s_charsToEscape);
         }
 
         /// <summary>
@@ -233,12 +233,12 @@ string escapedString
                 {
                     // It has either a '%2' or a '%3'.  This is looking very promising.
                     return
-                        (
+
                             (-1 != escapedString.IndexOf("%2a", StringComparison.Ordinal)) ||
                             (-1 != escapedString.IndexOf("%2A", StringComparison.Ordinal)) ||
                             (-1 != escapedString.IndexOf("%3f", StringComparison.Ordinal)) ||
                             (-1 != escapedString.IndexOf("%3F", StringComparison.Ordinal))
-                        );
+                        ;
                 }
             }
             return false;
diff --git a/src/Shared/EventArgsFormatting.cs b/src/Shared/EventArgsFormatting.cs
index 1bd077f3977..f23ffcf69f1 100644
--- a/src/Shared/EventArgsFormatting.cs
+++ b/src/Shared/EventArgsFormatting.cs
@@ -15,6 +15,51 @@ namespace Microsoft.Build.Shared
     /// </summary>
     internal static class EventArgsFormatting
     {
+        /// <summary>
+        /// Format the error event message and all the other event data into
+        /// a single string.
+        /// </summary>
+        /// <param name="e">Error to format</param>
+        /// <param name="showProjectFile"><code>true</code> to show the project file which issued the event, otherwise <code>false</code>.</param>
+        /// <param name="projectConfigurationDescription">Properties to Print along with message</param>
+        /// <returns>The formatted message string.</returns>
+        internal static string FormatEventMessage(BuildErrorEventArgs e, bool showProjectFile, string projectConfigurationDescription)
+        {
+            return FormatEventMessage("error", e.Subcategory, e.Message,
+                            e.Code, e.File, showProjectFile ? e.ProjectFile : null, e.LineNumber, e.EndLineNumber,
+                            e.ColumnNumber, e.EndColumnNumber, e.ThreadId, projectConfigurationDescription);
+        }
+
+        /// <summary>
+        /// Format the warning message and all the other event data into a
+        /// single string.
+        /// </summary>
+        /// <param name="e">Warning to format</param>
+        /// <param name="showProjectFile"><code>true</code> to show the project file which issued the event, otherwise <code>false</code>.</param>
+        /// <param name="projectConfigurationDescription">Properties to Print along with message</param>
+        /// <returns>The formatted message string.</returns>
+        internal static string FormatEventMessage(BuildWarningEventArgs e, bool showProjectFile, string projectConfigurationDescription)
+        {
+            return FormatEventMessage("warning", e.Subcategory, e.Message,
+                            e.Code, e.File, showProjectFile ? e.ProjectFile : null, e.LineNumber, e.EndLineNumber,
+                            e.ColumnNumber, e.EndColumnNumber, e.ThreadId, projectConfigurationDescription);
+        }
+
+        /// <summary>
+        /// Format the message and all the other event data into a
+        /// single string.
+        /// </summary>
+        /// <param name="e">Message to format</param>
+        /// <param name="showProjectFile"><code>true</code> to show the project file which issued the event, otherwise <code>false</code>.</param>
+        /// <param name="projectConfigurationDescription">Properties to Print along with message</param>
+        /// <returns>The formatted message string.</returns>
+        internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile, string projectConfigurationDescription)
+        {
+            return FormatEventMessage("message", e.Subcategory, e.Message,
+                            e.Code, e.File, showProjectFile ? e.ProjectFile : null, e.LineNumber, e.EndLineNumber,
+                            e.ColumnNumber, e.EndColumnNumber, e.ThreadId, projectConfigurationDescription);
+        }
+
         /// <summary>
         /// Format the error event message and all the other event data into
         /// a single string.
@@ -28,7 +73,7 @@ internal static string FormatEventMessage(BuildErrorEventArgs e)
             // "error" should not be localized
             return FormatEventMessage("error", e.Subcategory, e.Message,
                             e.Code, e.File, null, e.LineNumber, e.EndLineNumber,
-                            e.ColumnNumber, e.EndColumnNumber, e.ThreadId);
+                            e.ColumnNumber, e.EndColumnNumber, e.ThreadId, null);
         }
 
         /// <summary>
@@ -45,7 +90,7 @@ internal static string FormatEventMessage(BuildErrorEventArgs e, bool showProjec
             // "error" should not be localized
             return FormatEventMessage("error", e.Subcategory, e.Message,
                 e.Code, e.File, showProjectFile ? e.ProjectFile : null, e.LineNumber, e.EndLineNumber,
-                            e.ColumnNumber, e.EndColumnNumber, e.ThreadId);
+                            e.ColumnNumber, e.EndColumnNumber, e.ThreadId, null);
         }
 
         /// <summary>
@@ -61,7 +106,7 @@ internal static string FormatEventMessage(BuildWarningEventArgs e)
             // "warning" should not be localized
             return FormatEventMessage("warning", e.Subcategory, e.Message,
                 e.Code, e.File, null, e.LineNumber, e.EndLineNumber,
-                           e.ColumnNumber, e.EndColumnNumber, e.ThreadId);
+                           e.ColumnNumber, e.EndColumnNumber, e.ThreadId, null);
         }
 
         /// <summary>
@@ -78,7 +123,7 @@ internal static string FormatEventMessage(BuildWarningEventArgs e, bool showProj
             // "warning" should not be localized
             return FormatEventMessage("warning", e.Subcategory, e.Message,
                 e.Code, e.File, showProjectFile ? e.ProjectFile : null, e.LineNumber, e.EndLineNumber,
-                           e.ColumnNumber, e.EndColumnNumber, e.ThreadId);
+                           e.ColumnNumber, e.EndColumnNumber, e.ThreadId, null);
         }
 
         /// <summary>
@@ -105,7 +150,7 @@ internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProj
 
             // "message" should not be localized
             return FormatEventMessage("message", e.Subcategory, e.Message,
-                e.Code, e.File, showProjectFile ? e.ProjectFile : null, e.LineNumber, e.EndLineNumber, e.ColumnNumber, e.EndColumnNumber, e.ThreadId);
+                e.Code, e.File, showProjectFile ? e.ProjectFile : null, e.LineNumber, e.EndLineNumber, e.ColumnNumber, e.EndColumnNumber, e.ThreadId, null);
         }
 
         /// <summary>
@@ -137,7 +182,7 @@ internal static string FormatEventMessage
             int threadId
         )
         {
-            return FormatEventMessage(category, subcategory, message, code, file, null, lineNumber, endLineNumber, columnNumber, endColumnNumber, threadId);
+            return FormatEventMessage(category, subcategory, message, code, file, null, lineNumber, endLineNumber, columnNumber, endColumnNumber, threadId, null);
         }
 
         /// <summary>
@@ -155,6 +200,7 @@ int threadId
         /// <param name="columnNumber">column number (0 if n/a)</param>
         /// <param name="endColumnNumber">end column number (0 if n/a)</param>
         /// <param name="threadId">thread id</param>
+        /// <param name="logOutputProperties">log output properties</param>
         /// <returns>The formatted message string.</returns>
         internal static string FormatEventMessage
         (
@@ -168,7 +214,8 @@ internal static string FormatEventMessage
             int endLineNumber,
             int columnNumber,
             int endColumnNumber,
-            int threadId
+            int threadId,
+            string logOutputProperties
         )
         {
             StringBuilder format = new StringBuilder();
@@ -181,7 +228,7 @@ int threadId
             }
             */
 
-            if ((file == null) || (file.Length == 0))
+            if (string.IsNullOrEmpty(file))
             {
                 format.Append("MSBUILD : ");    // Should not be localized.
             }
@@ -234,7 +281,7 @@ int threadId
                 }
             }
 
-            if ((subcategory != null) && (subcategory.Length != 0))
+            if (!string.IsNullOrEmpty(subcategory))
             {
                 format.Append("{9} ");
             }
@@ -259,13 +306,21 @@ int threadId
             }
 
             // If the project file was specified, tack that onto the very end.
+            // Check for additional properties that should be output with project file
             if (projectFile != null && !String.Equals(projectFile, file))
             {
-                format.Append(" [{10}]");
+                if (logOutputProperties?.Length > 0)
+                {
+                    format.Append(" [{10}::{11}]");
+                }
+                else
+                {
+                    format.Append(" [{10}]");
+                }
             }
 
             // A null message is allowed and is to be treated as a blank line.
-            if (null == message)
+            if (message == null)
             {
                 message = String.Empty;
             }
@@ -278,12 +333,12 @@ int threadId
 
             for (int i = 0; i < lines.Length; i++)
             {
-                formattedMessage.Append(String.Format(
+                formattedMessage.AppendFormat(
                         CultureInfo.CurrentCulture, finalFormat,
                         threadId, file,
                         lineNumber, columnNumber, category, code,
                         lines[i], endLineNumber, endColumnNumber,
-                        subcategory, projectFile));
+                        subcategory, projectFile, logOutputProperties);
 
                 if (i < (lines.Length - 1))
                 {
@@ -294,7 +349,6 @@ int threadId
             return formattedMessage.ToString();
         }
 
-
         /// <summary>
         /// Splits strings on 'newLines' with tolerance for Everett and Dogfood builds.
         /// </summary>
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 967e012016b..139d39b3bd0 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -186,11 +186,11 @@ internal static bool HasWildcards(string filespec)
         internal static bool HasWildcardsSemicolonItemOrPropertyReferences(string filespec)
         {
             return
-                (
+
                 (-1 != filespec.IndexOfAny(s_wildcardAndSemicolonCharacters)) ||
                 filespec.Contains("$(") ||
                 filespec.Contains("@(")
-                );
+                ;
         }
 
         /// <summary>
@@ -444,9 +444,8 @@ GetFileSystemEntries getFileSystemEntries
 
             string[] parts = path.Split(directorySeparatorCharacters);
             string pathRoot;
-            int startingElement = 0;
-
             bool isUnc = path.StartsWith(s_directorySeparator + s_directorySeparator, StringComparison.Ordinal);
+            int startingElement;
             if (isUnc)
             {
                 pathRoot = s_directorySeparator + s_directorySeparator;
@@ -685,7 +684,6 @@ IEnumerable<string> paths
             }
         }
 
-
         /// <summary>
         /// Checks if the char is a DirectorySeparatorChar or a AltDirectorySeparatorChar
         /// </summary>
@@ -693,7 +691,7 @@ IEnumerable<string> paths
         /// <returns></returns>
         internal static bool IsDirectorySeparator(char c)
         {
-            return (c == Path.DirectorySeparatorChar || c == Path.AltDirectorySeparatorChar);
+            return c == Path.DirectorySeparatorChar || c == Path.AltDirectorySeparatorChar;
         }
         /// <summary>
         /// Removes the current directory converting the file back to relative path 
@@ -867,7 +865,7 @@ private void GetFilesRecursive(
                         continue;
                     }
                 }
-                files = files ?? new List<string>();
+                files ??= new List<string>();
                 files.Add(file);
             }
             // Add all matched files at once to reduce thread contention
@@ -1129,7 +1127,7 @@ out bool isLegalFileSpec
                 FileSpecRegexMinLength == FileSpecRegexParts.FixedDirGroupStart.Length
                 + FileSpecRegexParts.WildcardGroupStart.Length
                 + FileSpecRegexParts.FilenameGroupStart.Length
-                + FileSpecRegexParts.GroupEnd.Length * 3
+                + (FileSpecRegexParts.GroupEnd.Length * 3)
                 + FileSpecRegexParts.EndOfLine.Length,
                 "Checked-in length of known regex components differs from computed length. Update checked-in constant."
             );
@@ -1144,7 +1142,6 @@ out bool isLegalFileSpec
             }
         }
 
-
         /// <summary>
         /// Determine if the filespec is legal according to the following conditions:
         /// 
@@ -1189,7 +1186,6 @@ private static bool HasMisplacedRecursiveOperator(string str)
             return false;
         }
 
-
         /// <summary>
         /// Append the regex equivalents for character sequences in the fixed directory part of a filespec:
         ///
@@ -1867,7 +1863,6 @@ internal string[] GetFiles
             List<string> excludeSpecsUnescaped = null
             )
         {
-
             // For performance. Short-circuit iff there is no wildcard.
             if (!HasWildcards(filespecUnescaped))
             {
@@ -2073,9 +2068,9 @@ out isLegalFileSpec
 
             var searchData = new FilesSearchData(
                 // if using the regular expression, ignore the file pattern
-                (matchWithRegex ? null : filenamePart),
+                matchWithRegex ? null : filenamePart,
                 // if using the file pattern, ignore the regular expression
-                (matchWithRegex ? new Regex(matchFileExpression, RegexOptions.IgnoreCase) : null),
+                matchWithRegex ? new Regex(matchFileExpression, RegexOptions.IgnoreCase) : null,
                 needsRecursion);
 
             result.SearchData = searchData;
@@ -2180,7 +2175,7 @@ private static int SkipCharacters(string aString, int startingIndex, Func<char,
         /// </summary>
         internal static bool IsValidDriveChar(char value)
         {
-            return ((value >= 'A' && value <= 'Z') || (value >= 'a' && value <= 'z'));
+            return (value >= 'A' && value <= 'Z') || (value >= 'a' && value <= 'z');
         }
 
         static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUnescaped, List<string> excludeSpecsUnescaped)
@@ -2189,7 +2184,6 @@ static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUnescaped,
             {
                 foreach (string excludeSpec in excludeSpecsUnescaped)
                 {
-
                     // Try a path equality check first to:
                     // - avoid the expensive regex
                     // - maintain legacy behaviour where an illegal filespec is treated as a normal string
@@ -2289,7 +2283,7 @@ private string[] GetFilesImplementation(
                     var excludeBaseDirectory = excludeState.BaseDirectory;
                     var includeBaseDirectory = state.BaseDirectory;
 
-                    if (string.Compare(excludeBaseDirectory, includeBaseDirectory, StringComparison.OrdinalIgnoreCase) != 0)
+                    if (!string.Equals(excludeBaseDirectory, includeBaseDirectory, StringComparison.OrdinalIgnoreCase))
                     {
                         //  What to do if the BaseDirectory for the exclude search doesn't match the one for inclusion?
                         //  - If paths don't match (one isn't a prefix of the other), then ignore the exclude search.  Examples:
@@ -2376,7 +2370,7 @@ private string[] GetFilesImplementation(
                 }
             }
 
-            if (searchesToExclude != null && searchesToExclude.Count == 0)
+            if (searchesToExclude?.Count == 0)
             {
                 searchesToExclude = null;
             }
diff --git a/src/Shared/FileSystem/CachingFileSystemWrapper.cs b/src/Shared/FileSystem/CachingFileSystemWrapper.cs
index 26682f6968e..c3b3b141f20 100644
--- a/src/Shared/FileSystem/CachingFileSystemWrapper.cs
+++ b/src/Shared/FileSystem/CachingFileSystemWrapper.cs
@@ -12,6 +12,7 @@ internal class CachingFileSystemWrapper : IFileSystem
     {
         private readonly IFileSystem _fileSystem;
         private readonly ConcurrentDictionary<string, bool> _existenceCache = new ConcurrentDictionary<string, bool>();
+        private readonly ConcurrentDictionary<string, DateTime> _lastWriteTimeCache = new ConcurrentDictionary<string, DateTime>();
 
         public CachingFileSystemWrapper(IFileSystem fileSystem)
         {
@@ -23,6 +24,16 @@ public bool DirectoryEntryExists(string path)
             return CachedExistenceCheck(path, p => _fileSystem.DirectoryEntryExists(p));
         }
 
+        public FileAttributes GetAttributes(string path)
+        {
+            return _fileSystem.GetAttributes(path);
+        }
+
+        public DateTime GetLastWriteTimeUtc(string path)
+        {
+            return _lastWriteTimeCache.GetOrAdd(path, p =>_fileSystem.GetLastWriteTimeUtc(p));
+        }
+
         public bool DirectoryExists(string path)
         {
             return CachedExistenceCheck(path, p => _fileSystem.DirectoryExists(p));
@@ -38,6 +49,26 @@ public IEnumerable<string> EnumerateDirectories(string path, string searchPatter
             return _fileSystem.EnumerateDirectories(path, searchPattern, searchOption);
         }
 
+        public TextReader ReadFile(string path)
+        {
+            return _fileSystem.ReadFile(path);
+        }
+
+        public Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share)
+        {
+            return _fileSystem.GetFileStream(path, mode, access, share);
+        }
+
+        public string ReadFileAllText(string path)
+        {
+            return _fileSystem.ReadFileAllText(path);
+        }
+
+        public byte[] ReadFileAllBytes(string path)
+        {
+            return _fileSystem.ReadFileAllBytes(path);
+        }
+
         public IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
         {
             return _fileSystem.EnumerateFiles(path, searchPattern, searchOption);
diff --git a/src/Shared/FileSystem/IFileSystem.cs b/src/Shared/FileSystem/IFileSystem.cs
index 946aae0b286..0ef03e74c65 100644
--- a/src/Shared/FileSystem/IFileSystem.cs
+++ b/src/Shared/FileSystem/IFileSystem.cs
@@ -1,44 +1,47 @@
 Ôªø// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
 using System.Collections.Generic;
 using System.IO;
 
 namespace Microsoft.Build.Shared.FileSystem
 {
-    /// <summary>
-    /// Abstracts away some file system operations
-    /// </summary>
+
+    /*
+     * This is a clone of Microsoft.Build.FileSystem.MSBuildFileSystemBase.
+     * MSBuildFileSystemBase is the public, reference interface. Changes should be made to MSBuildFileSystemBase and cloned in IFileSystem.
+     * Any new code should depend on MSBuildFileSystemBase instead of IFileSystem, if possible.
+     *
+     * MSBuild uses IFileSystem internally and adapts MSBuildFileSystemBase instances received from the outside to IFileSystem.
+     * Ideally there should be only one, public interface. However, such an interface would need to be put into the 
+     * Microsoft.Build.Framework assembly, but that assembly cannot take new types because it breaks some old version of Nuget.exe.
+     * IFileSystem cannot be deleted for the same reason.
+     */
     internal interface IFileSystem
     {
-        /// <summary>
-        /// Returns an enumerable collection of file names that match a search pattern in a specified path, and optionally searches subdirectories.
-        /// </summary>
+        TextReader ReadFile(string path);
+
+        Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share);
+
+        string ReadFileAllText(string path);
+
+        byte[] ReadFileAllBytes(string path);
+
         IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly);
 
-        /// <summary>
-        /// Returns an enumerable collection of directory names that match a search pattern in a specified path, and optionally searches subdirectories.
-        /// </summary>
         IEnumerable<string> EnumerateDirectories(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly);
 
-        /// <summary>
-        /// Returns an enumerable collection of file names and directory names that match a search pattern in a specified path, and optionally searches subdirectories.
-        /// </summary>
         IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly);
 
-        /// <summary>
-        /// Determines whether the given path refers to an existing directory on disk.
-        /// </summary>
+        FileAttributes GetAttributes(string path);
+
+        public DateTime GetLastWriteTimeUtc(string path);
+
         bool DirectoryExists(string path);
 
-        /// <summary>
-        /// Determines whether the given path refers to an existing file on disk.
-        /// </summary>
         bool FileExists(string path);
 
-        /// <summary>
-        /// Determines whether the given path refers to an existing entry in the directory service.
-        /// </summary>
         bool DirectoryEntryExists(string path);
     }
 }
diff --git a/src/Shared/FileSystem/MSBuildOnWindowsFileSystem.cs b/src/Shared/FileSystem/MSBuildOnWindowsFileSystem.cs
index 6819117fbf4..de2658e6324 100644
--- a/src/Shared/FileSystem/MSBuildOnWindowsFileSystem.cs
+++ b/src/Shared/FileSystem/MSBuildOnWindowsFileSystem.cs
@@ -1,55 +1,80 @@
 Ôªø// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
 using System.Collections.Generic;
 using System.IO;
+using System.Reflection;
 
 namespace Microsoft.Build.Shared.FileSystem
 {
     /// <summary>
-    /// Implementation of file system operations directly over the dot net managed layer
+    /// Implementation of file system operations on windows. Combination of native and managed implementations.
+    /// TODO Remove this class and replace with WindowsFileSystem. Test perf to ensure no regressions.
     /// </summary>
-    internal sealed class MSBuildOnWindowsFileSystem : IFileSystem
+    internal class MSBuildOnWindowsFileSystem : IFileSystem
     {
         private static readonly MSBuildOnWindowsFileSystem Instance = new MSBuildOnWindowsFileSystem();
 
-        /// <nodoc/>
         public static MSBuildOnWindowsFileSystem Singleton() => Instance;
 
-        private MSBuildOnWindowsFileSystem()
-        { }
+        protected MSBuildOnWindowsFileSystem() { }
+
+        public TextReader ReadFile(string path)
+        {
+            return ManagedFileSystem.Singleton().ReadFile(path);
+        }
+
+        public Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share)
+        {
+            return ManagedFileSystem.Singleton().GetFileStream(path, mode, access, share);
+        }
+
+        public string ReadFileAllText(string path)
+        {
+            return ManagedFileSystem.Singleton().ReadFileAllText(path);
+        }
+
+        public byte[] ReadFileAllBytes(string path)
+        {
+            return ManagedFileSystem.Singleton().ReadFileAllBytes(path);
+        }
 
-        /// <inheritdoc/>
         public IEnumerable<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption)
         {
             return ManagedFileSystem.Singleton().EnumerateFiles(path, searchPattern, searchOption);
         }
 
-        /// <inheritdoc/>
         public IEnumerable<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption)
         {
             return ManagedFileSystem.Singleton().EnumerateDirectories(path, searchPattern, searchOption);
         }
 
-        /// <inheritdoc/>
         public IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption)
         {
             return ManagedFileSystem.Singleton().EnumerateFileSystemEntries(path, searchPattern, searchOption);
         }
 
-        /// <inheritdoc/>
+        public FileAttributes GetAttributes(string path)
+        {
+            return ManagedFileSystem.Singleton().GetAttributes(path);
+        }
+
+        public DateTime GetLastWriteTimeUtc(string path)
+        {
+            return ManagedFileSystem.Singleton().GetLastWriteTimeUtc(path);
+        }
+
         public bool DirectoryExists(string path)
         {
             return WindowsFileSystem.Singleton().DirectoryExists(path);
         }
 
-        /// <inheritdoc/>
         public bool FileExists(string path)
         {
             return WindowsFileSystem.Singleton().FileExists(path);
         }
 
-        /// <inheritdoc/>
         public bool DirectoryEntryExists(string path)
         {
             return WindowsFileSystem.Singleton().DirectoryEntryExists(path);
diff --git a/src/Shared/FileSystem/ManagedFileSystem.cs b/src/Shared/FileSystem/ManagedFileSystem.cs
index c809822b1df..201a62e7436 100644
--- a/src/Shared/FileSystem/ManagedFileSystem.cs
+++ b/src/Shared/FileSystem/ManagedFileSystem.cs
@@ -1,6 +1,7 @@
 Ôªø// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
 using System.Collections.Generic;
 using System.IO;
 
@@ -9,48 +10,70 @@ namespace Microsoft.Build.Shared.FileSystem
     /// <summary>
     /// Implementation of file system operations directly over the dot net managed layer
     /// </summary>
-    internal sealed class ManagedFileSystem : IFileSystem
+    internal class ManagedFileSystem : IFileSystem
     {
         private static readonly ManagedFileSystem Instance = new ManagedFileSystem();
 
-        /// <nodoc/>
         public static ManagedFileSystem Singleton() => ManagedFileSystem.Instance;
 
-        private ManagedFileSystem()
-        { }
+        protected ManagedFileSystem() { }
 
-        /// <inheritdoc/>
-        public IEnumerable<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption)
+        public TextReader ReadFile(string path)
+        {
+            return new StreamReader(path);
+        }
+
+        public Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share)
+        {
+            return new FileStream(path, mode, access, share);
+        }
+
+        public string ReadFileAllText(string path)
+        {
+            return File.ReadAllText(path);
+        }
+
+        public byte[] ReadFileAllBytes(string path)
+        {
+            return File.ReadAllBytes(path);
+        }
+
+        public virtual IEnumerable<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption)
         {
             return Directory.EnumerateFiles(path, searchPattern, searchOption);
         }
 
-        /// <inheritdoc/>
-        public IEnumerable<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption)
+        public virtual IEnumerable<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption)
         {
             return Directory.EnumerateDirectories(path, searchPattern, searchOption);
         }
 
-        /// <inheritdoc/>
-        public IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption)
+        public virtual IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption)
         {
             return Directory.EnumerateFileSystemEntries(path, searchPattern, searchOption);
         }
 
-        /// <inheritdoc/>
-        public bool DirectoryExists(string path)
+        public FileAttributes GetAttributes(string path)
+        {
+            return File.GetAttributes(path);
+        }
+
+        public virtual DateTime GetLastWriteTimeUtc(string path)
+        {
+            return File.GetLastWriteTimeUtc(path);
+        }
+
+        public virtual bool DirectoryExists(string path)
         {
             return Directory.Exists(path);
         }
 
-        /// <inheritdoc/>
-        public bool FileExists(string path)
+        public virtual bool FileExists(string path)
         {
             return File.Exists(path);
         }
 
-        /// <inheritdoc/>
-        public bool DirectoryEntryExists(string path)
+        public virtual bool DirectoryEntryExists(string path)
         {
             return FileExists(path) || DirectoryExists(path);
         }
diff --git a/src/Shared/FileSystem/WindowsFileSystem.cs b/src/Shared/FileSystem/WindowsFileSystem.cs
index 2b66c993281..9f4e3bf1dda 100644
--- a/src/Shared/FileSystem/WindowsFileSystem.cs
+++ b/src/Shared/FileSystem/WindowsFileSystem.cs
@@ -1,6 +1,7 @@
 Ôªø// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
@@ -22,54 +23,62 @@ internal enum FileArtifactType : byte
     }
 
     /// <summary>
-    /// Windows-specific implementation of file system operations using Windows native invocations
+    /// Windows-specific implementation of file system operations using Windows native invocations.
+    /// TODO For potential extra perf gains, provide native implementations for all IFileSystem methods and stop inheriting from ManagedFileSystem
     /// </summary>
-    internal class WindowsFileSystem : IFileSystem
+    internal class WindowsFileSystem : ManagedFileSystem
     {
         private static readonly WindowsFileSystem Instance = new WindowsFileSystem();
 
-        /// <nodoc/>
-        public static WindowsFileSystem Singleton() => WindowsFileSystem.Instance;
+        public new static WindowsFileSystem Singleton() => WindowsFileSystem.Instance;
 
-        private WindowsFileSystem()
-        { }
+        private WindowsFileSystem(){ }
 
-        /// <inheritdoc/>
-        public IEnumerable<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption)
+        public override IEnumerable<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption)
         {
             return EnumerateFileOrDirectories(path, FileArtifactType.File, searchPattern, searchOption);
         }
 
-        /// <inheritdoc/>
-        public IEnumerable<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption)
+        public override IEnumerable<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption)
         {
             return EnumerateFileOrDirectories(path, FileArtifactType.Directory, searchPattern, searchOption);
         }
 
-        /// <inheritdoc/>
-        public IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption)
+        public override IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption)
         {
             return EnumerateFileOrDirectories(path, FileArtifactType.FileOrDirectory, searchPattern, searchOption);
         }
 
-        /// <inheritdoc/>
-        public bool DirectoryExists(string path)
+        public override bool DirectoryExists(string path)
         {
             return NativeMethodsShared.DirectoryExistsWindows(path);
         }
 
-        /// <inheritdoc/>
-        public bool FileExists(string path)
+        public override bool FileExists(string path)
         {
             return NativeMethodsShared.FileExistsWindows(path);
         }
 
-        /// <inheritdoc/>
-        public bool DirectoryEntryExists(string path)
+        public override bool DirectoryEntryExists(string path)
         {
             return NativeMethodsShared.FileOrDirectoryExistsWindows(path);
         }
 
+        public override DateTime GetLastWriteTimeUtc(string path)
+        {
+            var fileLastWriteTime = NativeMethodsShared.GetLastWriteFileUtcTime(path);
+
+            if (fileLastWriteTime != DateTime.MinValue)
+            {
+                return fileLastWriteTime;
+            }
+            else
+            {
+                NativeMethodsShared.GetLastWriteDirectoryUtcTime(path, out var directoryLastWriteTime);
+                return directoryLastWriteTime;
+            }
+        }
+
         private static IEnumerable<string> EnumerateFileOrDirectories(
             string directoryPath,
             FileArtifactType fileArtifactType,
@@ -113,27 +122,14 @@ private static WindowsNative.EnumerateDirectoryResult CustomEnumerateDirectoryEn
                 {
                     int hr = Marshal.GetLastWin32Error();
                     Debug.Assert(hr != WindowsNative.ErrorFileNotFound);
-
-                    WindowsNative.EnumerateDirectoryStatus findHandleOpenStatus;
-                    switch (hr)
+                    WindowsNative.EnumerateDirectoryStatus findHandleOpenStatus = hr switch
                     {
-                        case WindowsNative.ErrorFileNotFound:
-                            findHandleOpenStatus = WindowsNative.EnumerateDirectoryStatus.SearchDirectoryNotFound;
-                            break;
-                        case WindowsNative.ErrorPathNotFound:
-                            findHandleOpenStatus = WindowsNative.EnumerateDirectoryStatus.SearchDirectoryNotFound;
-                            break;
-                        case WindowsNative.ErrorDirectory:
-                            findHandleOpenStatus = WindowsNative.EnumerateDirectoryStatus.CannotEnumerateFile;
-                            break;
-                        case WindowsNative.ErrorAccessDenied:
-                            findHandleOpenStatus = WindowsNative.EnumerateDirectoryStatus.AccessDenied;
-                            break;
-                        default:
-                            findHandleOpenStatus = WindowsNative.EnumerateDirectoryStatus.UnknownError;
-                            break;
-                    }
-
+                        WindowsNative.ErrorFileNotFound => WindowsNative.EnumerateDirectoryStatus.SearchDirectoryNotFound,
+                        WindowsNative.ErrorPathNotFound => WindowsNative.EnumerateDirectoryStatus.SearchDirectoryNotFound,
+                        WindowsNative.ErrorDirectory => WindowsNative.EnumerateDirectoryStatus.CannotEnumerateFile,
+                        WindowsNative.ErrorAccessDenied => WindowsNative.EnumerateDirectoryStatus.AccessDenied,
+                        _ => WindowsNative.EnumerateDirectoryStatus.UnknownError,
+                    };
                     return new WindowsNative.EnumerateDirectoryResult(directoryPath, findHandleOpenStatus, hr);
                 }
 
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index a02cf5c4582..ca576a58036 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -31,7 +31,6 @@ internal static partial class FileUtilities
         // A list of possible test runners. If the program running has one of these substrings in the name, we assume
         // this is a test harness.
 
-
         // This flag, when set, indicates that we are running tests. Initially assume it's true. It also implies that
         // the currentExecutableOverride is set to a path (that is non-null). Assume this is not initialized when we
         // have the impossible combination of runningTests = false and currentExecutableOverride = null.
@@ -83,7 +82,6 @@ public static bool GetIsFileSystemCaseSensitive()
         /// Copied from https://github.com/dotnet/corefx/blob/056715ff70e14712419d82d51c8c50c54b9ea795/src/Common/src/System/IO/PathInternal.Windows.cs#L61
         /// MSBuild should support the union of invalid path chars across the supported OSes, so builds can have the same behaviour crossplatform: https://github.com/Microsoft/msbuild/issues/781#issuecomment-243942514
         /// </summary>
-
         internal static readonly char[] InvalidPathChars = new char[]
         {
             '|', '\0',
@@ -244,7 +242,7 @@ internal static bool EndsWithSlash(string fileSpec)
         /// <returns>true, if slash</returns>
         internal static bool IsSlash(char c)
         {
-            return ((c == Path.DirectorySeparatorChar) || (c == Path.AltDirectorySeparatorChar));
+            return (c == Path.DirectorySeparatorChar) || (c == Path.AltDirectorySeparatorChar);
         }
 
         /// <summary>
@@ -303,7 +301,7 @@ internal static bool ContainsRelativePathSegments(string path)
                     }
                     else
                     {
-                        i = i + 2;
+                        i += 2;
                         continue;
                     }
                 }
@@ -350,7 +348,6 @@ private static bool IsValidRelativePathBound(char? c)
         /// </summary>
         internal static string NormalizePath(string path)
         {
-
             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));
             string fullPath = GetFullPath(path);
             return FixFilePath(fullPath);
@@ -506,8 +503,8 @@ private static string RemoveQuotes(string path)
             char doubleQuote = '\"';
 
             bool hasQuotes = path.Length > 2
-                && (path[0] == singleQuote && path[endId] == singleQuote
-                || path[0] == doubleQuote && path[endId] == doubleQuote);
+                && ((path[0] == singleQuote && path[endId] == singleQuote)
+                || (path[0] == doubleQuote && path[endId] == doubleQuote));
 
             return hasQuotes ? path.Substring(1, endId - 1) : path;
         }
@@ -545,8 +542,8 @@ private static Span<char> RemoveQuotes(Span<char> path)
             char doubleQuote = '\"';
 
             bool hasQuotes = path.Length > 2
-                && (path[0] == singleQuote && path[endId] == singleQuote
-                || path[0] == doubleQuote && path[endId] == doubleQuote);
+                && ((path[0] == singleQuote && path[endId] == singleQuote)
+                || (path[0] == doubleQuote && path[endId] == doubleQuote));
 
             return hasQuotes ? path.Slice(1, endId - 1) : path;
         }
@@ -579,8 +576,8 @@ internal static bool LooksLikeUnixFilePath(string value, string baseDirectory =
             // Check for actual files or directories under / that get missed by the above logic
             bool shouldCheckFileOrDirectory = !shouldCheckDirectory && value.Length > 0 && value[0] == '/';
 
-            return shouldCheckDirectory && DefaultFileSystem.DirectoryExists(Path.Combine(baseDirectory, value.Substring(0, directoryLength)))
-                || shouldCheckFileOrDirectory && DefaultFileSystem.DirectoryEntryExists(value);
+            return (shouldCheckDirectory && DefaultFileSystem.DirectoryExists(Path.Combine(baseDirectory, value.Substring(0, directoryLength))))
+                || (shouldCheckFileOrDirectory && DefaultFileSystem.DirectoryEntryExists(value));
         }
 
 #if FEATURE_SPAN
@@ -599,8 +596,8 @@ internal static bool LooksLikeUnixFilePath(ReadOnlySpan<char> value, string base
             bool shouldCheckFileOrDirectory = !shouldCheckDirectory && value.Length > 0 && value[0] == '/';
             ReadOnlySpan<char> directory = value.Slice(0, directoryLength);
 
-            return shouldCheckDirectory && DefaultFileSystem.DirectoryExists(Path.Combine(baseDirectory, directory.ToString()))
-                || shouldCheckFileOrDirectory && DefaultFileSystem.DirectoryEntryExists(value.ToString());
+            return (shouldCheckDirectory && DefaultFileSystem.DirectoryExists(Path.Combine(baseDirectory, directory.ToString())))
+                || (shouldCheckFileOrDirectory && DefaultFileSystem.DirectoryEntryExists(value.ToString()));
         }
 #endif
 
@@ -637,7 +634,7 @@ internal static string GetDirectory(string fileSpec)
         /// <returns></returns>
         internal static bool HasExtension(string fileName, string[] allowedExtensions)
         {
-            Debug.Assert(allowedExtensions != null && allowedExtensions.Length > 0);
+            Debug.Assert(allowedExtensions?.Length > 0);
 
             // Easiest way to invoke invalid path chars
             // check, which callers are relying on.
@@ -665,7 +662,6 @@ internal static bool HasExtension(string fileName, string[] allowedExtensions)
         /// </summary>
         internal static string ExecutingAssemblyPath => Path.GetFullPath(AssemblyUtilities.GetAssemblyLocation(typeof(FileUtilities).GetTypeInfo().Assembly));
 
-
         /// <summary>
         /// Determines the full path for the given file-spec.
         /// ASSUMES INPUT IS STILL ESCAPED
@@ -769,7 +765,6 @@ internal static bool PathIsInvalid(string path)
             return path.IndexOfAny(InvalidFileNameChars, lastDirectorySeparator >= 0 ? lastDirectorySeparator + 1 : 0) >= 0;
         }
 
-
         /// <summary>
         /// A variation on File.Delete that will throw ExceptionHandling.NotExpectedException exceptions
         /// </summary>
@@ -914,12 +909,11 @@ internal static bool DirectoryExistsNoThrow(string fullPath, IFileSystem fileSys
 
             try
             {
-                fileSystem = fileSystem ?? DefaultFileSystem;
+                fileSystem ??= DefaultFileSystem;
 
                 return Traits.Instance.CacheFileExistence
                     ? FileExistenceCache.GetOrAdd(fullPath, fileSystem.DirectoryExists)
                     : fileSystem.DirectoryExists(fullPath);
-
             }
             catch
             {
@@ -939,12 +933,11 @@ internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem =
 
             try
             {
-                fileSystem = fileSystem ?? DefaultFileSystem;
+                fileSystem ??= DefaultFileSystem;
 
                 return Traits.Instance.CacheFileExistence
                     ? FileExistenceCache.GetOrAdd(fullPath, fileSystem.FileExists)
                     : fileSystem.FileExists(fullPath);
-
             }
             catch
             {
@@ -964,7 +957,7 @@ internal static bool FileOrDirectoryExistsNoThrow(string fullPath, IFileSystem f
 
             try
             {
-                fileSystem = fileSystem ?? DefaultFileSystem;
+                fileSystem ??= DefaultFileSystem;
 
                 return Traits.Instance.CacheFileExistence
                     ? FileExistenceCache.GetOrAdd(fullPath, fileSystem.DirectoryEntryExists)
@@ -1079,7 +1072,7 @@ private static Uri CreateUriFromPath(string path)
         {
             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));
 
-            Uri pathUri = null;
+            Uri pathUri;
 
             // Try absolute first, then fall back on relative, otherwise it
             // makes some absolute UNC paths like (\\foo\bar) relative ...
@@ -1328,7 +1321,7 @@ internal static StreamReader OpenRead(string path, Encoding encoding = null, boo
         /// </summary>
         internal static string GetDirectoryNameOfFileAbove(string startingDirectory, string fileName, IFileSystem fileSystem = null)
         {
-            fileSystem = fileSystem ?? DefaultFileSystem;
+            fileSystem ??= DefaultFileSystem;
 
             // Canonicalize our starting location
             string lookInDirectory = GetFullPath(startingDirectory);
diff --git a/src/Shared/FileUtilitiesRegex.cs b/src/Shared/FileUtilitiesRegex.cs
index c8be4058ee7..9ab2e9faf9e 100644
--- a/src/Shared/FileUtilitiesRegex.cs
+++ b/src/Shared/FileUtilitiesRegex.cs
@@ -20,10 +20,10 @@ internal static class FileUtilitiesRegex
         private static readonly char _forwardSlash = '/';
 
         /// <summary>
-        /// Indicates whether the specified string follows the pattern drive pattern: "<drive letter>:"
+        /// Indicates whether the specified string follows the pattern drive pattern (e.g. "C:", "D:")
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for drive pattern</param>
+        /// <returns>true if follows the drive pattern, false otherwise</returns>
         internal static bool IsDrivePattern(string pattern)
         {
             // Format must be two characters long: "<drive letter>:"
@@ -32,10 +32,10 @@ internal static bool IsDrivePattern(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified string follows the pattern drive pattern: "<drive letter>:/" or "<drive letter>:\"
+        /// Indicates whether the specified string follows the pattern drive pattern (e.g. "C:/" or "C:\")
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for drive pattern with slash</param>
+        /// <returns>true if follows the drive pattern with slash, false otherwise</returns>
         internal static bool IsDrivePatternWithSlash(string pattern)
         {
             return pattern.Length == 3 &&
@@ -43,10 +43,10 @@ internal static bool IsDrivePatternWithSlash(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified string starts with the drive pattern: "<drive letter>:".
+        /// Indicates whether the specified string starts with the drive pattern (e.g. "C:")
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for drive pattern</param>
+        /// <returns>true if starts with drive pattern, false otherwise</returns>
         internal static bool StartsWithDrivePattern(string pattern)
         {
             // Format dictates a length of at least 2,
@@ -58,10 +58,10 @@ internal static bool StartsWithDrivePattern(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified string starts with the drive pattern: "<drive letter>:/" or "<drive letter>:\".
+        /// Indicates whether the specified string starts with the drive pattern (e.g. "C:/" or "C:\")
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for drive pattern</param>
+        /// <returns>true if starts with drive pattern with slash, false otherwise</returns>
         internal static bool StartsWithDrivePatternWithSlash(string pattern)
         {
             // Format dictates a length of at least 3,
@@ -74,10 +74,10 @@ internal static bool StartsWithDrivePatternWithSlash(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified file-spec comprises exactly "\\<server>\<share>" (with no trailing characters).
+        /// Indicates whether the specified file-spec comprises exactly "\\server\share" (with no trailing characters).
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for Unc pattern</param>
+        /// <returns>true if comprises Unc pattern</returns>
         internal static bool IsUncPattern(string pattern)
         {
             //Return value == pattern.length means:
@@ -88,10 +88,10 @@ internal static bool IsUncPattern(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified file-spec begins with "\\<server>\<share>".
+        /// Indicates whether the specified file-spec begins with "\\server\share".
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for Unc pattern</param>
+        /// <returns>true if starts with Unc pattern</returns>
         internal static bool StartsWithUncPattern(string pattern)
         {
             //Any non -1 value returned means there was a match, therefore is begins with the pattern.
@@ -99,10 +99,10 @@ internal static bool StartsWithUncPattern(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the file-spec begins with a UNC pattern and how long the match is. -1 indicates no match.
+        /// Indicates whether the file-spec begins with a UNC pattern and how long the match is.
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for Unc pattern</param>
+        /// <returns>length of the match, -1 if no match</returns>
         internal static int StartsWithUncPatternMatchLength(string pattern)
         {
             if (!MeetsUncPatternMinimumRequirements(pattern))
@@ -150,10 +150,9 @@ internal static int StartsWithUncPatternMatchLength(string pattern)
 
         /// <summary>
         /// Indicates whether or not the file-spec meets the minimum requirements of a UNC pattern.
-        /// UNC pattern requires a minimum length of 5 and first two characters must be a slash.
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for Unc pattern minimum requirements</param>
+        /// <returns>true if the UNC pattern is a minimum length of 5 and the first two characters are be a slash, false otherwise.</returns>
 #if !NET35
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
 #endif
@@ -165,6 +164,5 @@ internal static bool MeetsUncPatternMinimumRequirements(string pattern)
                 (pattern[1] == _backSlash ||
                 pattern[1] == _forwardSlash);
        }
-
     }
 }
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 7b86e274cdf..772ede5a88c 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -29,7 +29,7 @@ namespace Microsoft.Build.Shared
     internal enum DotNetFrameworkArchitecture
     {
         /// <summary>
-        /// Indicates the .NET Framework that is currently being run under.  
+        /// Indicates the .NET Framework that is currently being run under.
         /// </summary>
         Current = 0,
 
@@ -217,7 +217,7 @@ internal static class FrameworkLocationHelper
 
             // v4.7.1
             CreateDotNetFrameworkSpecForV4(dotNetFrameworkVersion471, visualStudioVersion150),
-            
+
             // v4.7.2
             CreateDotNetFrameworkSpecForV4(dotNetFrameworkVersion472, visualStudioVersion150),
 
@@ -428,13 +428,13 @@ internal static string PathToDotNetFrameworkSdkV20
 
         /// <summary>
         /// Because there is no longer a strong 1:1 mapping between FX versions and SDK
-        /// versions, if we're unable to locate the desired SDK version, we will try to 
+        /// versions, if we're unable to locate the desired SDK version, we will try to
         /// use whichever SDK version is installed by looking at the key pointing to the
         /// "latest" version.
         ///
-        /// This isn't ideal, but it will allow our tasks to function on any of several 
+        /// This isn't ideal, but it will allow our tasks to function on any of several
         /// related SDKs even if they don't have exactly the same versions.
-        /// 
+        ///
         /// NOTE:  This returns the path to the root of the fallback SDK
         /// </summary>
         private static string FallbackDotNetFrameworkSdkInstallPath
@@ -476,15 +476,15 @@ private static string FallbackDotNetFrameworkSdkInstallPath
 
         /// <summary>
         /// Because there is no longer a strong 1:1 mapping between FX versions and SDK
-        /// versions, if we're unable to locate the desired SDK version, we will try to 
+        /// versions, if we're unable to locate the desired SDK version, we will try to
         /// use whichever SDK version is installed by looking at the key pointing to the
         /// "latest" version.
         ///
-        /// This isn't ideal, but it will allow our tasks to function on any of several 
+        /// This isn't ideal, but it will allow our tasks to function on any of several
         /// related SDKs even if they don't have exactly the same versions.
-        /// 
+        ///
         /// NOTE:  This explicitly returns the path to the 3.5 tools (bin) under the fallback
-        /// SDK, to match the data we're pulling from the registry now.  
+        /// SDK, to match the data we're pulling from the registry now.
         /// </summary>
         private static string PathToV35ToolsInFallbackDotNetFrameworkSdk
         {
@@ -507,8 +507,7 @@ private static string PathToV35ToolsInFallbackDotNetFrameworkSdk
                             // Path.Combine leaves no trailing slash, so if we had one before, be sure to add it back in
                             if (endsWithASlash)
                             {
-                                s_pathToV35ToolsInFallbackDotNetFrameworkSdk = s_pathToV35ToolsInFallbackDotNetFrameworkSdk
-                                                                             + Path.DirectorySeparatorChar;
+                                s_pathToV35ToolsInFallbackDotNetFrameworkSdk += Path.DirectorySeparatorChar;
                             }
                         }
                         else
@@ -524,15 +523,15 @@ private static string PathToV35ToolsInFallbackDotNetFrameworkSdk
 
         /// <summary>
         /// Because there is no longer a strong 1:1 mapping between FX versions and SDK
-        /// versions, if we're unable to locate the desired SDK version, we will try to 
+        /// versions, if we're unable to locate the desired SDK version, we will try to
         /// use whichever SDK version is installed by looking at the key pointing to the
         /// "latest" version.
         ///
-        /// This isn't ideal, but it will allow our tasks to function on any of several 
+        /// This isn't ideal, but it will allow our tasks to function on any of several
         /// related SDKs even if they don't have exactly the same versions.
-        /// 
-        /// NOTE:  This explicitly returns the path to the 4.X tools (bin\NetFX 4.0 Tools) 
-        /// under the fallback SDK, to match the data we're pulling from the registry now.  
+        ///
+        /// NOTE:  This explicitly returns the path to the 4.X tools (bin\NetFX 4.0 Tools)
+        /// under the fallback SDK, to match the data we're pulling from the registry now.
         /// </summary>
         private static string PathToV4ToolsInFallbackDotNetFrameworkSdk
         {
@@ -553,7 +552,7 @@ private static string PathToV4ToolsInFallbackDotNetFrameworkSdk
                             // Path.Combine leaves no trailing slash, so if we had one before, be sure to add it back in
                             if (endsWithASlash)
                             {
-                                s_pathToV4ToolsInFallbackDotNetFrameworkSdk = s_pathToV4ToolsInFallbackDotNetFrameworkSdk + "\\";
+                                s_pathToV4ToolsInFallbackDotNetFrameworkSdk += "\\";
                             }
                         }
                         else
@@ -686,7 +685,7 @@ private static bool CheckForFrameworkInstallation(string registryEntryToCheckIns
                 if (NativeMethodsShared.IsWindows)
                 {
                     // If the registry entry is 1 then the framework is installed. Go ahead and find the directory. If it is not 1 then the framework is not installed, return null.
-                    return String.Compare("1", FindRegistryValueUnderKey(registryEntryToCheckInstall, registryValueToCheckInstall), StringComparison.OrdinalIgnoreCase) == 0;
+                    return String.Equals("1", FindRegistryValueUnderKey(registryEntryToCheckInstall, registryValueToCheckInstall), StringComparison.OrdinalIgnoreCase);
                 }
                 // False for non-windows since there is nothing in the registry
                 else
@@ -766,7 +765,7 @@ DotNetFrameworkArchitecture architecture
             else if (indexOfFramework64 == -1 && architecture == DotNetFrameworkArchitecture.Bitness64)
             {
                 // need to add 64 -- since this is a heuristic, we assume that we just need to append.  
-                baseLocation = baseLocation + "64";
+                baseLocation += "64";
             }
             // we don't need to do anything if it's DotNetFrameworkArchitecture.Current.  
 
@@ -850,7 +849,7 @@ internal static string GenerateProgramFiles64()
                 return Path.Combine(NativeMethodsShared.FrameworkBasePath, "xbuild");
             }
 
-            string programFilesX64 = null;
+            string programFilesX64;
             if (string.Equals(programFiles, programFiles32))
             {
                 // either we're in a 32-bit window, or we're on a 32-bit machine.  
@@ -869,7 +868,7 @@ internal static string GenerateProgramFiles64()
         }
 
         /// <summary>
-        /// Generate the path to the program files reference assembly location by taking in the program files special folder and then 
+        /// Generate the path to the program files reference assembly location by taking in the program files special folder and then
         /// using that path to generate the path to the reference assemblies location.
         /// </summary>
         internal static string GenerateProgramFilesReferenceAssemblyRoot()
@@ -892,15 +891,15 @@ internal static string GenerateProgramFilesReferenceAssemblyRoot()
         }
 
         /// <summary>
-        /// Given a ToolsVersion, find the path to the build tools folder for that ToolsVersion. 
+        /// Given a ToolsVersion, find the path to the build tools folder for that ToolsVersion.
         /// </summary>
         /// <param name="toolsVersion">The ToolsVersion to look up</param>
         /// <param name="architecture">Target build tools architecture.</param>
-        /// <returns>The path to the build tools folder for that ToolsVersion, if it exists, or 
+        /// <returns>The path to the build tools folder for that ToolsVersion, if it exists, or
         /// null otherwise</returns>
         internal static string GeneratePathToBuildToolsForToolsVersion(string toolsVersion, DotNetFrameworkArchitecture architecture)
         {
-            if (string.Compare(toolsVersion, MSBuildConstants.CurrentToolsVersion, StringComparison.Ordinal) == 0)
+            if (string.Equals(toolsVersion, MSBuildConstants.CurrentToolsVersion, StringComparison.Ordinal))
             {
                 return GetPathToBuildToolsFromEnvironment(architecture);
             }
@@ -916,7 +915,7 @@ internal static string GeneratePathToBuildToolsForToolsVersion(string toolsVersi
         }
 
         /// <summary>
-        /// Take the parts of the Target framework moniker and formulate the reference assembly path based on the the following pattern:
+        /// Take the parts of the Target framework moniker and formulate the reference assembly path based on the following pattern:
         /// For a framework and version:
         ///     $(TargetFrameworkRootPath)\$(TargetFrameworkIdentifier)\$(TargetFrameworkVersion)
         /// For a subtype:
@@ -945,8 +944,7 @@ internal static string GenerateReferenceAssemblyPath(string targetFrameworkRootP
                     path = Path.Combine(path, frameworkName.Profile);
                 }
 
-                path = Path.GetFullPath(path);
-                return path;
+                return Path.GetFullPath(path);
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
@@ -978,7 +976,7 @@ internal static string RemoveDirectories(string path, int numberOfLevelsToRemove
                 DirectoryInfo fixedPathInfo = new DirectoryInfo(path);
                 for (int i = 0; i < numberOfLevelsToRemove; i++)
                 {
-                    if (fixedPathInfo != null && fixedPathInfo.Parent != null)
+                    if (fixedPathInfo?.Parent != null)
                     {
                         fixedPathInfo = fixedPathInfo.Parent;
                     }
@@ -991,7 +989,7 @@ internal static string RemoveDirectories(string path, int numberOfLevelsToRemove
 
                 if (fixedPath != null && endedWithASlash)
                 {
-                    fixedPath = fixedPath + Path.DirectorySeparatorChar;
+                    fixedPath += Path.DirectorySeparatorChar;
                 }
             }
 
@@ -999,24 +997,21 @@ internal static string RemoveDirectories(string path, int numberOfLevelsToRemove
         }
 
         /// <summary>
-        /// Look up the path to the build tools directory for the requested ToolsVersion in the .exe.config file of this executable 
+        /// Look up the path to the build tools directory for the requested ToolsVersion in the .exe.config file of this executable
         /// </summary>
         private static string GetPathToBuildToolsFromEnvironment(DotNetFrameworkArchitecture architecture)
         {
-            switch (architecture)
+            return architecture switch
             {
-                case DotNetFrameworkArchitecture.Bitness64:
-                    return BuildEnvironmentHelper.Instance.MSBuildToolsDirectory64;
-                case DotNetFrameworkArchitecture.Bitness32:
-                    return BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32;
-                default:
-                    return BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
-            }
+                DotNetFrameworkArchitecture.Bitness64 => BuildEnvironmentHelper.Instance.MSBuildToolsDirectory64,
+                DotNetFrameworkArchitecture.Bitness32 => BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32,
+                _ => BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory,
+            };
         }
 
 #if FEATURE_WIN32_REGISTRY
         /// <summary>
-        /// Look up the path to the build tools directory in the registry for the requested ToolsVersion and requested architecture  
+        /// Look up the path to the build tools directory in the registry for the requested ToolsVersion and requested architecture
         /// </summary>
         private static string GetPathToBuildToolsFromRegistry(string toolsVersion, DotNetFrameworkArchitecture architecture)
         {
@@ -1665,8 +1660,7 @@ public DotNetFrameworkSpecV3(
             public override string GetPathToDotNetFrameworkSdk(VisualStudioSpec visualStudioSpec)
             {
                 string pathToBinRoot = this.GetPathToDotNetFrameworkSdkTools(visualStudioSpec);
-                pathToBinRoot = RemoveDirectories(pathToBinRoot, 1);
-                return pathToBinRoot;
+                return RemoveDirectories(pathToBinRoot, 1);
             }
 
             /// <summary>
diff --git a/src/Shared/IInternable.cs b/src/Shared/IInternable.cs
index f4f810f8f2e..9bfa741e097 100644
--- a/src/Shared/IInternable.cs
+++ b/src/Shared/IInternable.cs
@@ -329,7 +329,7 @@ internal SubstringInternTarget(string target, int startIndex, int length)
         /// </summary>
         /// <param name="other">The string to compare with the target substring.</param>
         /// <returns>True if target substring starts with <paramref name="other"/>, false otherwise.</returns>
-        public bool StartsWithStringByOrdinalComparison(string other) => (String.CompareOrdinal(_target, _startIndex, other, 0, other.Length) == 0);
+        public bool StartsWithStringByOrdinalComparison(string other) => String.CompareOrdinal(_target, _startIndex, other, 0, other.Length) == 0;
 
         /// <summary>
         /// Never reference equals to string.
diff --git a/src/Shared/ITranslator.cs b/src/Shared/ITranslator.cs
index 47b7770b797..6fec218805e 100644
--- a/src/Shared/ITranslator.cs
+++ b/src/Shared/ITranslator.cs
@@ -258,6 +258,13 @@ void Translate<T>(ref T value)
         /// </summary>
         /// <param name="byteArray">The array to be translated.</param>
         void Translate(ref byte[] byteArray);
+        
+        /// <summary>
+        /// Translates a byte array
+        /// </summary>
+        /// <param name="byteArray">The array to be translated.</param>
+        /// <param name="length">The length of array which will be used in translation</param>
+        void Translate(ref byte[] byteArray, ref int length);
 
         /// <summary>
         /// Translates an array of objects implementing INodePacketTranslatable.
diff --git a/src/Shared/InterningBinaryReader.cs b/src/Shared/InterningBinaryReader.cs
index 9a04c4f7ea1..128cdec4826 100644
--- a/src/Shared/InterningBinaryReader.cs
+++ b/src/Shared/InterningBinaryReader.cs
@@ -128,10 +128,7 @@ override public String ReadString()
 
                     charsRead = _decoder.GetChars(rawBuffer, rawPosition, n, charBuffer, 0);
 
-                    if (memoryStream != null)
-                    {
-                        memoryStream.Seek(readLength, SeekOrigin.Current);
-                    }
+                    memoryStream?.Seek(readLength, SeekOrigin.Current);
 
                     if (currPos == 0 && n == stringLength)
                     {
diff --git a/src/Shared/LanguageParser/CSharptokenCharReader.cs b/src/Shared/LanguageParser/CSharptokenCharReader.cs
index 76b3b90c666..23cb8610b18 100644
--- a/src/Shared/LanguageParser/CSharptokenCharReader.cs
+++ b/src/Shared/LanguageParser/CSharptokenCharReader.cs
@@ -132,7 +132,7 @@ internal bool SinkMultipleWhiteSpace()
                 ++count;
             }
 
-            return (count > 0);
+            return count > 0;
         }
     }
 }
diff --git a/src/Shared/LanguageParser/StreamMappedString.cs b/src/Shared/LanguageParser/StreamMappedString.cs
index 71876fbd0ed..af1757d951f 100644
--- a/src/Shared/LanguageParser/StreamMappedString.cs
+++ b/src/Shared/LanguageParser/StreamMappedString.cs
@@ -71,7 +71,8 @@ sealed internal class StreamMappedString
         /// <summary>
         /// Construct.
         /// </summary>
-        /// <param name="binaryStream"></param>
+        /// <param name="binaryStream">The raw binary stream that's being read.</param>
+        /// <param name="forceANSI">When false, try to guess the encoding of binaryStream. When true, force the encoding to ANSI.</param>
         public StreamMappedString(Stream binaryStream, bool forceANSI)
             : this(binaryStream, forceANSI, /* pageSize */ DefaultPageSize)
         {
@@ -80,7 +81,9 @@ public StreamMappedString(Stream binaryStream, bool forceANSI)
         /// <summary>
         /// Construct.
         /// </summary>
-        /// <param name="binaryStream"></param>
+        /// <param name="binaryStream">The raw binary stream that's being read.</param>
+        /// <param name="forceANSI">When false, try to guess the encoding of binaryStream. When true, force the encoding to ANSI.</param>
+        /// <param name="pageSize">Size of pages to use for reading from source file.</param>
         internal StreamMappedString(Stream binaryStream, bool forceANSI, int pageSize)
         {
             _binaryStream = binaryStream;
@@ -92,7 +95,6 @@ internal StreamMappedString(Stream binaryStream, bool forceANSI, int pageSize)
         /// <summary>
         /// Restart the stream reader at the beginning.
         /// </summary>
-        /// <param name="binaryStream"></param>
         private void RestartReader()
         {
             _currentPageNumber = -1;
@@ -161,7 +163,7 @@ public char GetAt(int offset)
             // If null now, then the requested character is out of range.
             if (page == null)
             {
-                throw new ArgumentOutOfRangeException("offset");
+                throw new ArgumentOutOfRangeException(nameof(offset));
             }
 
             // Get the relative offset within the buffer.
@@ -340,7 +342,6 @@ private bool IsZeroLengthStream()
         /// COnvert from absolute offset to relative offset within a particular page.
         /// </summary>
         /// <param name="offset"></param>
-        /// <param name="pageNumber"></param>
         /// <returns></returns>
         private int AbsoluteOffsetToPageOffset(int offset)
         {
@@ -360,7 +361,7 @@ private int PageFromAbsoluteOffset(int offset)
         /// <summary>
         /// Returns true of the given position is passed the end of the file.
         /// </summary>
-        /// <param name="position"></param>
+        /// <param name="offset"></param>
         /// <returns></returns>
         public bool IsPastEnd(int offset)
         {
@@ -377,7 +378,7 @@ public string Substring(int startPosition, int length)
         {
             StringBuilder result = new StringBuilder(length);
 
-            int charactersExtracted = 0;
+            int charactersExtracted;
             for (int i = 0; i < length; i += charactersExtracted)
             {
                 char[] page = GetPage(startPosition + i);
@@ -385,7 +386,7 @@ public string Substring(int startPosition, int length)
                 // If we weren't able to read enough characters then throw an exception.
                 if (page == null)
                 {
-                    throw new ArgumentOutOfRangeException("length");
+                    throw new ArgumentOutOfRangeException(nameof(length));
                 }
 
                 int relativeStartPosition = AbsoluteOffsetToPageOffset(startPosition + i);
diff --git a/src/Shared/LanguageParser/token.cs b/src/Shared/LanguageParser/token.cs
index 5deedb0a4a6..c402fcd1fb6 100644
--- a/src/Shared/LanguageParser/token.cs
+++ b/src/Shared/LanguageParser/token.cs
@@ -59,7 +59,7 @@ internal int Line
          */
         internal bool EqualsIgnoreCase(string compareTo)
         {
-            return (String.Compare(_innerText, compareTo, StringComparison.OrdinalIgnoreCase) == 0);
+            return String.Equals(_innerText, compareTo, StringComparison.OrdinalIgnoreCase);
         }
     }
 
diff --git a/src/Shared/LanguageParser/tokenChar.cs b/src/Shared/LanguageParser/tokenChar.cs
index 2af68997091..5cd32212f98 100644
--- a/src/Shared/LanguageParser/tokenChar.cs
+++ b/src/Shared/LanguageParser/tokenChar.cs
@@ -168,7 +168,7 @@ static internal bool IsOctalDigit(char c)
         {
             if
             (
-                (c >= '0' && c <= '7')
+                c >= '0' && c <= '7'
             )
             {
                 return true;
diff --git a/src/Shared/LanguageParser/tokenCharReader.cs b/src/Shared/LanguageParser/tokenCharReader.cs
index 6e9e3d0f884..aa8aa07d3d4 100644
--- a/src/Shared/LanguageParser/tokenCharReader.cs
+++ b/src/Shared/LanguageParser/tokenCharReader.cs
@@ -122,7 +122,6 @@ internal bool EndOfLines
             get { return _sources.IsPastEnd(_position); }
         }
 
-
         /*
          * Method:  GetCurrentMatchedString
          * 
@@ -158,17 +157,16 @@ private bool Sink(string match, bool ignoreCase)
                 return false;
             }
 
-
             string compare = _sources.Substring(_position, match.Length);
 
             if
             (
-                String.Compare
+                String.Equals
                 (
                     match,
                     compare,
                     (ignoreCase /* ignore case */) ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal
-                ) == 0
+                )
             )
             {
                 Skip(match.Length);
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 4c6d45c21f1..d439204c328 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -114,7 +114,7 @@ private static int GetDefaultPacketVersion()
         {
             Assembly coreAssembly = typeof(object).GetTypeInfo().Assembly;
             Version coreAssemblyVersion = coreAssembly.GetName().Version;
-            return 1000 + coreAssemblyVersion.Major * 10 + coreAssemblyVersion.Minor;
+            return 1000 + (coreAssemblyVersion.Major * 10) + coreAssemblyVersion.Minor;
         }
 #endif
 
diff --git a/src/Shared/MSBuildNameIgnoreCaseComparer.cs b/src/Shared/MSBuildNameIgnoreCaseComparer.cs
index 2ec0b14c481..e5f0f0ad199 100644
--- a/src/Shared/MSBuildNameIgnoreCaseComparer.cs
+++ b/src/Shared/MSBuildNameIgnoreCaseComparer.cs
@@ -93,8 +93,8 @@ public bool Equals(string compareToString, string constrainedString, int start,
                             {
                                 int chx = px[i];
                                 int chy = py[i + start];
-                                chx = chx & 0x00DF; // Extract the uppercase character
-                                chy = chy & 0x00DF; // Extract the uppercase character
+                                chx &= 0x00DF; // Extract the uppercase character
+                                chy &= 0x00DF; // Extract the uppercase character
 
                                 if (chx != chy)
                                 {
@@ -149,7 +149,7 @@ public int GetHashCode(string obj, int start, int length)
                             // the string, and not the null terminator etc.
                             if (length == 1)
                             {
-                                val = val & 0xFFFF;
+                                val &= 0xFFFF;
                             }
 
                             hash1 = ((hash1 << 5) + hash1 + (hash1 >> 27)) ^ val;
@@ -162,7 +162,7 @@ public int GetHashCode(string obj, int start, int length)
                             val = pint[1] & 0x00DF00DF;
                             if (length == 3)
                             {
-                                val = val & 0xFFFF;
+                                val &= 0xFFFF;
                             }
 
                             hash2 = ((hash2 << 5) + hash2 + (hash2 >> 27)) ^ val;
diff --git a/src/Shared/MetadataConversionUtilities.cs b/src/Shared/MetadataConversionUtilities.cs
index bab097bf90c..3804610f600 100644
--- a/src/Shared/MetadataConversionUtilities.cs
+++ b/src/Shared/MetadataConversionUtilities.cs
@@ -31,7 +31,7 @@ out bool metadataFound
             )
         {
             string metadataValue = item.GetMetadata(itemMetadataName);
-            if (metadataValue == null || metadataValue.Length == 0)
+            if (string.IsNullOrEmpty(metadataValue))
             {
                 metadataFound = false;
                 return false;
@@ -63,7 +63,7 @@ internal static bool TryConvertItemMetadataToBool
                 string itemMetadataName
             )
         {
-            bool metadataFound = false;
+            bool metadataFound;
             return TryConvertItemMetadataToBool(item, itemMetadataName, out metadataFound);
         }
     }
diff --git a/src/Shared/NamedPipeUtil.cs b/src/Shared/NamedPipeUtil.cs
index a7f8913e7d7..6daf5d24058 100644
--- a/src/Shared/NamedPipeUtil.cs
+++ b/src/Shared/NamedPipeUtil.cs
@@ -3,11 +3,21 @@
 
 using System;
 using System.IO;
+using System.IO.Pipes;
+using System.Security.AccessControl;
+using System.Security.Principal;
+using System.Threading;
+using Microsoft.Build.Internal;
 
 namespace Microsoft.Build.Shared
 {
     internal static class NamedPipeUtil
     {
+        /// <summary>
+        /// The size of the buffers to use for named pipes
+        /// </summary>
+        private const int PipeBufferSize = 131072;
+
         internal static string GetPipeNameOrPath(string pipeName)
         {
             if (NativeMethodsShared.IsUnixLike)
@@ -25,5 +35,242 @@ internal static string GetPipeNameOrPath(string pipeName)
                 return pipeName;
             }
         }
+
+#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+        //  This code needs to be in a separate method so that we don't try (and fail) to load the Windows-only APIs when JIT-ing the code
+        //  on non-Windows operating systems
+        private static void ValidateRemotePipeSecurityOnWindows(NamedPipeClientStream nodeStream)
+        {
+            SecurityIdentifier identifier = WindowsIdentity.GetCurrent().Owner;
+#if FEATURE_PIPE_SECURITY
+            PipeSecurity remoteSecurity = nodeStream.GetAccessControl();
+#else
+            var remoteSecurity = new PipeSecurity(nodeStream.SafePipeHandle, System.Security.AccessControl.AccessControlSections.Access |
+                System.Security.AccessControl.AccessControlSections.Owner | System.Security.AccessControl.AccessControlSections.Group);
+#endif
+            IdentityReference remoteOwner = remoteSecurity.GetOwner(typeof(SecurityIdentifier));
+            if (remoteOwner != identifier)
+            {
+                CommunicationsUtilities.Trace("The remote pipe owner {0} does not match {1}", remoteOwner.Value, identifier.Value);
+                throw new UnauthorizedAccessException();
+            }
+        }
+#endif
+
+        /// <summary>
+        /// Attempts to connect to the specified process.
+        /// </summary>
+        internal static NamedPipeClientStream TryConnectToProcess(int nodeProcessId, int timeout, Handshake handshake)
+        {
+            string pipeName = GetPipeNameOrPath("MSBuild" + nodeProcessId);
+            return TryConnectToProcess(pipeName, nodeProcessId, timeout, handshake);
+        }
+
+        /// <summary>
+        /// Attempts to connect to the specified process.
+        /// </summary>
+        internal static NamedPipeClientStream TryConnectToProcess(string pipeName, int timeout, Handshake handshake)
+        {
+            return TryConnectToProcess(pipeName, null, timeout, handshake);
+        }
+
+        private static NamedPipeClientStream TryConnectToProcess(string pipeName, int? nodeProcessId, int timeout, Handshake handshake)
+        {
+            NamedPipeClientStream nodeStream = new NamedPipeClientStream(".", pipeName, PipeDirection.InOut, PipeOptions.Asynchronous
+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+                                                                         | PipeOptions.CurrentUserOnly
+#endif
+                                                                         );
+            CommunicationsUtilities.Trace("Attempting connect to PID {0} with pipe {1} with timeout {2} ms", nodeProcessId.HasValue ? nodeProcessId.Value.ToString() : pipeName, pipeName, timeout);
+
+            try
+            {
+                nodeStream.Connect(timeout);
+
+#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+                if (NativeMethodsShared.IsWindows && !NativeMethodsShared.IsMono)
+                {
+                    // Verify that the owner of the pipe is us.  This prevents a security hole where a remote node has
+                    // been faked up with ACLs that would let us attach to it.  It could then issue fake build requests back to
+                    // us, potentially causing us to execute builds that do harmful or unexpected things.  The pipe owner can
+                    // only be set to the user's own SID by a normal, unprivileged process.  The conditions where a faked up
+                    // remote node could set the owner to something else would also let it change owners on other objects, so
+                    // this would be a security flaw upstream of us.
+                    ValidateRemotePipeSecurityOnWindows(nodeStream);
+                }
+#endif
+
+                int[] handshakeComponents = handshake.RetrieveHandshakeComponents();
+                for (int i = 0; i < handshakeComponents.Length; i++)
+                {
+                    CommunicationsUtilities.Trace("Writing handshake part {0} to pipe {1}", i, pipeName);
+                    nodeStream.WriteIntForHandshake(handshakeComponents[i]);
+                }
+
+                // This indicates that we have finished all the parts of our handshake; hopefully the endpoint has as well.
+                nodeStream.WriteEndOfHandshakeSignal();
+
+                CommunicationsUtilities.Trace("Reading handshake from pipe {0}", pipeName);
+
+#if NETCOREAPP2_1 || MONO
+                    nodeStream.ReadEndOfHandshakeSignal(true, timeout);
+#else
+                nodeStream.ReadEndOfHandshakeSignal(true);
+#endif
+
+                // We got a connection.
+                CommunicationsUtilities.Trace("Successfully connected to pipe {0}...!", pipeName);
+                return nodeStream;
+            }
+            catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
+            {
+                // Can be:
+                // UnauthorizedAccessException -- Couldn't connect, might not be a node.
+                // IOException -- Couldn't connect, already in use.
+                // TimeoutException -- Couldn't connect, might not be a node.
+                // InvalidOperationException ‚Äì Couldn‚Äôt connect, probably a different build
+                CommunicationsUtilities.Trace("Failed to connect to pipe {0}. {1}", pipeName, e.Message.TrimEnd());
+
+                // If we don't close any stream, we might hang up the child
+                nodeStream?.Dispose();
+            }
+
+            return null;
+        }
+
+        internal static bool ValidateHandshake(Handshake handshake, NamedPipeServerStream serverStream, int clientConnectTimeout)
+        {
+            // The handshake protocol is a series of int exchanges.  The host sends us a each component, and we
+            // verify it. Afterwards, the host sends an "End of Handshake" signal, to which we respond in kind.
+            // Once the handshake is complete, both sides can be assured the other is ready to accept data.
+
+            bool gotValidConnection = true;
+            try
+            {
+                int[] handshakeComponents = handshake.RetrieveHandshakeComponents();
+                for (int i = 0; i < handshakeComponents.Length; i++)
+                {
+                    int handshakePart = serverStream.ReadIntForHandshake(i == 0 ? (byte?)CommunicationsUtilities.handshakeVersion : null /* this will disconnect a < 16.8 host; it expects leading 00 or F5 or 06. 0x00 is a wildcard */
+#if NETCOREAPP2_1 || MONO
+                            , clientConnectTimeout /* wait a long time for the handshake from this side */
+#endif
+                            );
+
+                    if (handshakePart != handshakeComponents[i])
+                    {
+                        CommunicationsUtilities.Trace("Handshake failed. Received {0} from host not {1}. Probably the host is a different MSBuild build.", handshakePart, handshakeComponents[i]);
+                        serverStream.WriteIntForHandshake(i + 1);
+                        gotValidConnection = false;
+                        break;
+                    }
+                }
+
+                if (gotValidConnection)
+                {
+                    // To ensure that our handshake and theirs have the same number of bytes, receive and send a magic number indicating EOS.
+#if NETCOREAPP2_1 || MONO
+                    serverStream.ReadEndOfHandshakeSignal(false, clientConnectTimeout); /* wait a long time for the handshake from this side */
+#else
+                    serverStream.ReadEndOfHandshakeSignal(false);
+#endif
+                    CommunicationsUtilities.Trace("Successfully connected to parent.");
+                    serverStream.WriteEndOfHandshakeSignal();
+
+#if FEATURE_SECURITY_PERMISSIONS
+                    // We will only talk to a host that was started by the same user as us.  Even though the pipe access is set to only allow this user, we want to ensure they
+                    // haven't attempted to change those permissions out from under us.  This ensures that the only way they can truly gain access is to be impersonating the
+                    // user we were started by.
+                    WindowsIdentity currentIdentity = WindowsIdentity.GetCurrent();
+                    WindowsIdentity clientIdentity = null;
+                    serverStream.RunAsClient(delegate () { clientIdentity = WindowsIdentity.GetCurrent(true); });
+
+                    if (clientIdentity == null || !string.Equals(clientIdentity.Name, currentIdentity.Name, StringComparison.OrdinalIgnoreCase))
+                    {
+                        CommunicationsUtilities.Trace("Handshake failed. Host user is {0} but we were created by {1}.", (clientIdentity == null) ? "<unknown>" : clientIdentity.Name, currentIdentity.Name);
+                        return false;
+                    }
+#endif
+                }
+            }
+            catch (IOException e)
+            {
+                // We will get here when:
+                // 1. The host (OOP main node) connects to us, it immediately checks for user privileges
+                //    and if they don't match it disconnects immediately leaving us still trying to read the blank handshake
+                // 2. The host is too old sending us bits we automatically reject in the handshake
+                // 3. We expected to read the EndOfHandshake signal, but we received something else
+                CommunicationsUtilities.Trace("Client connection failed but we will wait for another connection. Exception: {0}", e.Message);
+
+                gotValidConnection = false;
+            }
+            catch (InvalidOperationException)
+            {
+                gotValidConnection = false;
+            }
+
+            if (!gotValidConnection)
+            {
+                if (serverStream.IsConnected)
+                {
+                    serverStream.Disconnect();
+                }
+                return false;
+            }
+
+            return true;
+        }
+
+        internal static NamedPipeServerStream CreateNamedPipeServer(string pipeName, int? inputBufferSize = null, int? outputBufferSize = null, int maxNumberOfServerInstances = 1, bool allowNewInstances = false)
+        {
+            inputBufferSize ??= PipeBufferSize;
+            outputBufferSize ??= PipeBufferSize;
+
+#if FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR
+            if (!NativeMethodsShared.IsMono)
+            {
+                SecurityIdentifier identifier = WindowsIdentity.GetCurrent().Owner;
+                PipeSecurity security = new PipeSecurity();
+
+                // Restrict access to just this account.  We set the owner specifically here, and on the
+                // pipe client side they will check the owner against this one - they must have identical
+                // SIDs or the client will reject this server.  This is used to avoid attacks where a
+                // hacked server creates a less restricted pipe in an attempt to lure us into using it and 
+                // then sending build requests to the real pipe client (which is the MSBuild Build Manager.)
+
+                PipeAccessRights rights = PipeAccessRights.ReadWrite;
+                if (allowNewInstances)
+                {
+                    rights |= PipeAccessRights.CreateNewInstance;
+                }
+
+                PipeAccessRule rule = new PipeAccessRule(identifier, rights, AccessControlType.Allow);
+                security.AddAccessRule(rule);
+                security.SetOwner(identifier);
+
+                return new NamedPipeServerStream
+                    (
+                    pipeName,
+                    PipeDirection.InOut,
+                    maxNumberOfServerInstances, // Only allow one connection at a time.
+                    PipeTransmissionMode.Byte,
+                    PipeOptions.Asynchronous | PipeOptions.WriteThrough,
+                    inputBufferSize.Value, // Default input buffer
+                    outputBufferSize.Value,  // Default output buffer
+                    security,
+                    HandleInheritability.None
+                );
+            }
+#endif
+            return new NamedPipeServerStream
+            (
+                pipeName,
+                PipeDirection.InOut,
+                maxNumberOfServerInstances, // Only allow one connection at a time.
+                PipeTransmissionMode.Byte,
+                PipeOptions.Asynchronous | PipeOptions.WriteThrough,
+                inputBufferSize.Value, // Default input buffer
+                outputBufferSize.Value  // Default output buffer
+            );
+        }
     }
 }
diff --git a/src/Shared/NativeMethodsShared.cs b/src/Shared/NativeMethodsShared.cs
index 6bc94246966..a8b21a618d8 100644
--- a/src/Shared/NativeMethodsShared.cs
+++ b/src/Shared/NativeMethodsShared.cs
@@ -19,7 +19,6 @@
 using FILETIME = System.Runtime.InteropServices.ComTypes.FILETIME;
 using Microsoft.Build.Utilities;
 
-
 namespace Microsoft.Build.Shared
 {
     /// <summary>
@@ -379,21 +378,15 @@ private class SystemInformationData
             /// <returns></returns>
             private static ProcessorArchitectures ConvertSystemArchitecture(ushort arch)
             {
-                switch (arch)
+                return arch switch
                 {
-                    case PROCESSOR_ARCHITECTURE_INTEL:
-                        return ProcessorArchitectures.X86;
-                    case PROCESSOR_ARCHITECTURE_AMD64:
-                        return ProcessorArchitectures.X64;
-                    case PROCESSOR_ARCHITECTURE_ARM:
-                        return ProcessorArchitectures.ARM;
-                    case PROCESSOR_ARCHITECTURE_IA64:
-                        return ProcessorArchitectures.IA64;
-                    case PROCESSOR_ARCHITECTURE_ARM64:
-                        return ProcessorArchitectures.ARM64;
-                    default:
-                        return ProcessorArchitectures.Unknown;
-                }
+                    PROCESSOR_ARCHITECTURE_INTEL => ProcessorArchitectures.X86,
+                    PROCESSOR_ARCHITECTURE_AMD64 => ProcessorArchitectures.X64,
+                    PROCESSOR_ARCHITECTURE_ARM => ProcessorArchitectures.ARM,
+                    PROCESSOR_ARCHITECTURE_IA64 => ProcessorArchitectures.IA64,
+                    PROCESSOR_ARCHITECTURE_ARM64 => ProcessorArchitectures.ARM64,
+                    _ => ProcessorArchitectures.Unknown,
+                };
             }
 
             /// <summary>
@@ -627,28 +620,25 @@ internal static bool IsWindows
 #endif
         }
 
-#if MONO
+#if !CLR2COMPATIBILITY
         private static bool? _isOSX;
 #endif
+
         /// <summary>
         /// Gets a flag indicating if we are running under Mac OSX
         /// </summary>
         internal static bool IsOSX
         {
-#if MONO
-            get
-            {
-                if (!_isOSX.HasValue)
+#if CLR2COMPATIBILITY
+            get { return false; }
+#else
+            get {
+                if (_isOSX == null)
                 {
-                    _isOSX = File.Exists("/usr/lib/libc.dylib");
+                    _isOSX = RuntimeInformation.IsOSPlatform(OSPlatform.OSX);
                 }
-
                 return _isOSX.Value;
             }
-#elif CLR2COMPATIBILITY
-            get { return false; }
-#else
-            get { return RuntimeInformation.IsOSPlatform(OSPlatform.OSX); }
 #endif
         }
 
@@ -830,9 +820,7 @@ internal static bool GetLastWriteDirectoryUtcTime(string fullPath, out DateTime
                 fileModifiedTimeUtc = DateTime.MinValue;
 
                 WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
-                bool success = false;
-
-                success = GetFileAttributesEx(fullPath, 0, ref data);
+                bool success = GetFileAttributesEx(fullPath, 0, ref data);
                 if (success)
                 {
                     if ((data.fileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
@@ -980,9 +968,7 @@ internal static DateTime GetLastWriteFileUtcTime(string fullPath)
                 }
 
                 WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
-                bool success = false;
-
-                success = NativeMethodsShared.GetFileAttributesEx(fullPath, 0, ref data);
+                bool success = NativeMethodsShared.GetFileAttributesEx(fullPath, 0, ref data);
 
                 if (success && (data.fileAttributes & NativeMethodsShared.FILE_ATTRIBUTE_DIRECTORY) == 0)
                 {
@@ -1031,7 +1017,7 @@ private static DateTime GetContentLastWriteFileUtcTime(string fullPath)
                 if (!handle.IsInvalid)
                 {
                     FILETIME ftCreationTime, ftLastAccessTime, ftLastWriteTime;
-                    if (!GetFileTime(handle, out ftCreationTime, out ftLastAccessTime, out ftLastWriteTime) != true)
+                    if (GetFileTime(handle, out ftCreationTime, out ftLastAccessTime, out ftLastWriteTime))
                     {
                         long fileTime = ((long)(uint)ftLastWriteTime.dwHighDateTime) << 32 |
                                         (long)(uint)ftLastWriteTime.dwLowDateTime;
@@ -1049,7 +1035,7 @@ private static DateTime GetContentLastWriteFileUtcTime(string fullPath)
         /// </summary>
         public static bool HResultSucceeded(int hr)
         {
-            return (hr >= 0);
+            return hr >= 0;
         }
 
         /// <summary>
@@ -1057,7 +1043,7 @@ public static bool HResultSucceeded(int hr)
         /// </summary>
         public static bool HResultFailed(int hr)
         {
-            return (hr < 0);
+            return hr < 0;
         }
 
         /// <summary>
@@ -1088,7 +1074,7 @@ internal static void KillTree(int processIdToKill)
             // Only when you create the process using the Process object
             // does the Process object retain the original handle.
 
-            Process thisProcess = null;
+            Process thisProcess;
             try
             {
                 thisProcess = Process.GetProcessById(processIdToKill);
@@ -1222,7 +1208,7 @@ internal static int GetParentProcessId(int processId)
                 }
             }
 
-            return (ParentID);
+            return ParentID;
         }
 
         /// <summary>
@@ -1590,9 +1576,7 @@ internal static bool DirectoryExists(string fullPath)
         internal static bool DirectoryExistsWindows(string fullPath)
         {
             NativeMethodsShared.WIN32_FILE_ATTRIBUTE_DATA data = new NativeMethodsShared.WIN32_FILE_ATTRIBUTE_DATA();
-            bool success = false;
-
-            success = NativeMethodsShared.GetFileAttributesEx(fullPath, 0, ref data);
+            bool success = NativeMethodsShared.GetFileAttributesEx(fullPath, 0, ref data);
             return success && (data.fileAttributes & NativeMethodsShared.FILE_ATTRIBUTE_DIRECTORY) != 0;
         }
 
@@ -1606,9 +1590,7 @@ internal static bool FileExists(string fullPath)
         internal static bool FileExistsWindows(string fullPath)
         {
             NativeMethodsShared.WIN32_FILE_ATTRIBUTE_DATA data = new NativeMethodsShared.WIN32_FILE_ATTRIBUTE_DATA();
-            bool success = false;
-
-            success = NativeMethodsShared.GetFileAttributesEx(fullPath, 0, ref data);
+            bool success = NativeMethodsShared.GetFileAttributesEx(fullPath, 0, ref data);
             return success && (data.fileAttributes & NativeMethodsShared.FILE_ATTRIBUTE_DIRECTORY) == 0;
         }
 
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 05b8ae7a4a5..9d75da4dbab 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -31,13 +31,10 @@ namespace Microsoft.Build.BackEnd
     internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
     {
         #region Private Data
-
-#if NETCOREAPP2_1 || MONO
         /// <summary>
         /// The amount of time to wait for the client to connect to the host.
         /// </summary>
         private const int ClientConnectTimeout = 60000;
-#endif // NETCOREAPP2_1 || MONO
 
         /// <summary>
         /// The size of the buffers to use for named pipes
@@ -68,7 +65,7 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
 
         /// <summary>
         /// Set when a packet is available in the packet queue
-        /// </summary>      
+        /// </summary>
         private AutoResetEvent _packetAvailable;
 
         /// <summary>
@@ -87,7 +84,7 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
         private INodePacketFactory _packetFactory;
 
         /// <summary>
-        /// The asynchronous packet queue.  
+        /// The asynchronous packet queue.
         /// </summary>
         /// <remarks>
         /// Operations on this queue must be synchronized since it is accessible by multiple threads.
@@ -136,14 +133,14 @@ public LinkStatus LinkStatus
         public void Listen(INodePacketFactory factory)
         {
             ErrorUtilities.VerifyThrow(_status == LinkStatus.Inactive, "Link not inactive.  Status is {0}", _status);
-            ErrorUtilities.VerifyThrowArgumentNull(factory, "factory");
+            ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
             _packetFactory = factory;
 
             InitializeAsyncPacketThread();
         }
 
         /// <summary>
-        /// Causes this node to connect to the matched endpoint.  
+        /// Causes this node to connect to the matched endpoint.
         /// </summary>
         /// <param name="factory">The factory used to create packets.</param>
         public void Connect(INodePacketFactory factory)
@@ -182,56 +179,14 @@ public void SendData(INodePacket packet)
         /// <param name="pipeName">The name of the pipe to which we should connect.</param>
         internal void InternalConstruct(string pipeName)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(pipeName, "pipeName");
+            ErrorUtilities.VerifyThrowArgumentLength(pipeName, nameof(pipeName));
 
             _debugCommunications = (Environment.GetEnvironmentVariable("MSBUILDDEBUGCOMM") == "1");
 
             _status = LinkStatus.Inactive;
             _asyncDataMonitor = new object();
             _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();
-
-#if FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR
-            if (!NativeMethodsShared.IsMono)
-            {
-                SecurityIdentifier identifier = WindowsIdentity.GetCurrent().Owner;
-                PipeSecurity security = new PipeSecurity();
-
-                // Restrict access to just this account.  We set the owner specifically here, and on the
-                // pipe client side they will check the owner against this one - they must have identical
-                // SIDs or the client will reject this server.  This is used to avoid attacks where a
-                // hacked server creates a less restricted pipe in an attempt to lure us into using it and 
-                // then sending build requests to the real pipe client (which is the MSBuild Build Manager.)
-                PipeAccessRule rule = new PipeAccessRule(identifier, PipeAccessRights.ReadWrite, AccessControlType.Allow);
-                security.AddAccessRule(rule);
-                security.SetOwner(identifier);
-
-                _pipeServer = new NamedPipeServerStream
-                    (
-                    pipeName,
-                    PipeDirection.InOut,
-                    1, // Only allow one connection at a time.
-                    PipeTransmissionMode.Byte,
-                    PipeOptions.Asynchronous | PipeOptions.WriteThrough,
-                    PipeBufferSize, // Default input buffer
-                    PipeBufferSize,  // Default output buffer
-                    security,
-                    HandleInheritability.None
-                );
-            }
-            else
-#endif
-            {
-                _pipeServer = new NamedPipeServerStream
-                    (
-                    pipeName,
-                    PipeDirection.InOut,
-                    1, // Only allow one connection at a time.
-                    PipeTransmissionMode.Byte,
-                    PipeOptions.Asynchronous | PipeOptions.WriteThrough,
-                    PipeBufferSize, // Default input buffer
-                    PipeBufferSize  // Default output buffer
-                );
-             }
+            _pipeServer = NamedPipeUtil.CreateNamedPipeServer(pipeName, PipeBufferSize, PipeBufferSize);
         }
 
 #endregion
@@ -239,12 +194,7 @@ internal void InternalConstruct(string pipeName)
         /// <summary>
         /// Returns the host handshake for this node endpoint
         /// </summary>
-        protected abstract long GetHostHandshake();
-
-        /// <summary>
-        /// Returns the client handshake for this node endpoint
-        /// </summary>
-        protected abstract long GetClientHandshake();
+        protected abstract Handshake GetHandshake();
 
         /// <summary>
         /// Updates the current link status if it has changed and notifies any registered delegates.
@@ -296,10 +246,9 @@ private void InternalDisconnect()
         /// <param name="packet">The packet to be transmitted.</param>
         private void EnqueuePacket(INodePacket packet)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(packet, "packet");
-            ErrorUtilities.VerifyThrow(null != _packetQueue, "packetQueue is null");
-            ErrorUtilities.VerifyThrow(null != _packetAvailable, "packetAvailable is null");
-
+            ErrorUtilities.VerifyThrowArgumentNull(packet, nameof(packet));
+            ErrorUtilities.VerifyThrow(_packetQueue != null, "packetQueue is null");
+            ErrorUtilities.VerifyThrow(_packetAvailable != null, "packetAvailable is null");
             _packetQueue.Enqueue(packet);
             _packetAvailable.Set();
         }
@@ -329,8 +278,6 @@ private void InitializeAsyncPacketThread()
         private void PacketPumpProc()
         {
             NamedPipeServerStream localPipeServer = _pipeServer;
-            PipeStream localWritePipe = _pipeServer;
-            PipeStream localReadPipe = _pipeServer;
 
             AutoResetEvent localPacketAvailable = _packetAvailable;
             AutoResetEvent localTerminatePacketPump = _terminatePacketPump;
@@ -340,6 +287,7 @@ private void PacketPumpProc()
             bool gotValidConnection = false;
             while (!gotValidConnection)
             {
+                gotValidConnection = true;
                 DateTime restartWaitTime = DateTime.UtcNow;
 
                 // We only wait to wait the difference between now and the last original start time, in case we have multiple hosts attempting
@@ -352,14 +300,11 @@ private void PacketPumpProc()
                     // Wait for a connection
 #if FEATURE_APM
                     IAsyncResult resultForConnection = localPipeServer.BeginWaitForConnection(null, null);
-#else
-                    Task connectionTask = localPipeServer.WaitForConnectionAsync();
-#endif
                     CommunicationsUtilities.Trace("Waiting for connection {0} ms...", waitTimeRemaining);
-
-#if FEATURE_APM
                     bool connected = resultForConnection.AsyncWaitHandle.WaitOne(waitTimeRemaining, false);
 #else
+                    Task connectionTask = localPipeServer.WaitForConnectionAsync();
+                    CommunicationsUtilities.Trace("Waiting for connection {0} ms...", waitTimeRemaining);
                     bool connected = connectionTask.Wait(waitTimeRemaining);
 #endif
                     if (!connected)
@@ -374,77 +319,14 @@ private void PacketPumpProc()
                     localPipeServer.EndWaitForConnection(resultForConnection);
 #endif
 
-                    // The handshake protocol is a simple long exchange.  The host sends us a long, and we
-                    // respond with another long.  Once the handshake is complete, both sides can be assured the
-                    // other is ready to accept data.
-                    // To avoid mixing client and server builds, the long is the MSBuild binary timestamp.
-
-                    // Compatibility issue here.
-                    // Previous builds of MSBuild 4.0 would exchange just a byte.
-                    // Host would send either 0x5F or 0x60 depending on whether it was the toolset or not respectively.
-                    // Client would return either 0xF5 or 0x06 respectively.
-                    // Therefore an old host on a machine with new clients running will hang, 
-                    // sending a byte and waiting for a byte until it eventually times out;
-                    // because the new client will want 7 more bytes before it returns anything.
-                    // The other way around is not a problem, because the old client would immediately return the (wrong)
-                    // byte on receiving the first byte of the long sent by the new host, and the new host would disconnect.
-                    // To avoid the hang, special case here:
-                    // Make sure our handshakes always start with 00.
-                    // If we received ONLY one byte AND it's 0x5F or 0x60, return 0xFF (it doesn't matter what as long as
-                    // it will cause the host to reject us; new hosts expect 00 and old hosts expect F5 or 06).
-                    try
-                    {
-                        long handshake = localReadPipe.ReadLongForHandshake(/* reject these leads */ new byte[] { 0x5F, 0x60 }, 0xFF /* this will disconnect the host; it expects leading 00 or F5 or 06 */
-#if NETCOREAPP2_1 || MONO
-                            , ClientConnectTimeout /* wait a long time for the handshake from this side */
-#endif
-                            );
-
-#if FEATURE_SECURITY_PERMISSIONS
-                        WindowsIdentity currentIdentity = WindowsIdentity.GetCurrent();
-#endif
-
-                        if (handshake != GetHostHandshake())
-                        {
-                            CommunicationsUtilities.Trace("Handshake failed. Received {0} from host not {1}. Probably the host is a different MSBuild build.", handshake, GetHostHandshake());
-                            localPipeServer.Disconnect();
-                            continue;
-                        }
-
-#if FEATURE_SECURITY_PERMISSIONS
-                        // We will only talk to a host that was started by the same user as us.  Even though the pipe access is set to only allow this user, we want to ensure they
-                        // haven't attempted to change those permissions out from under us.  This ensures that the only way they can truly gain access is to be impersonating the
-                        // user we were started by.
-                        WindowsIdentity clientIdentity = null;
-                        localPipeServer.RunAsClient(delegate () { clientIdentity = WindowsIdentity.GetCurrent(true); });
 
-                        if (clientIdentity == null || !String.Equals(clientIdentity.Name, currentIdentity.Name, StringComparison.OrdinalIgnoreCase))
-                        {
-                            CommunicationsUtilities.Trace("Handshake failed. Host user is {0} but we were created by {1}.", (clientIdentity == null) ? "<unknown>" : clientIdentity.Name, currentIdentity.Name);
-                            localPipeServer.Disconnect();
-                            continue;
-                        }
-#endif
-                    }
-                    catch (IOException e)
+                    Handshake handshake = GetHandshake();
+                    gotValidConnection = NamedPipeUtil.ValidateHandshake(handshake, _pipeServer, ClientConnectTimeout);
+                    if (!gotValidConnection)
                     {
-                        // We will get here when:
-                        // 1. The host (OOP main node) connects to us, it immediately checks for user privileges
-                        //    and if they don't match it disconnects immediately leaving us still trying to read the blank handshake
-                        // 2. The host is too old sending us bits we automatically reject in the handshake
-                        CommunicationsUtilities.Trace("Client connection failed but we will wait for another connection. Exception: {0}", e.Message);
-                        if (localPipeServer.IsConnected)
-                        {
-                            localPipeServer.Disconnect();
-                        }
-
-                        continue;
+                        return;
                     }
 
-                    gotValidConnection = true;
-
-                    CommunicationsUtilities.Trace("Writing handshake to parent");
-                    localWritePipe.WriteLongForHandshake(GetClientHandshake());
                     ChangeLinkStatus(LinkStatus.Active);
                 }
                 catch (Exception e)
@@ -467,8 +349,8 @@ private void PacketPumpProc()
             }
 
             RunReadLoop(
-                new BufferedReadStream(localReadPipe),
-                localWritePipe,
+                new BufferedReadStream(_pipeServer),
+                _pipeServer,
                 localPacketQueue, localPacketAvailable, localTerminatePacketPump);
 
             CommunicationsUtilities.Trace("Ending read loop");
diff --git a/src/Shared/OutOfProcTaskHostTaskResult.cs b/src/Shared/OutOfProcTaskHostTaskResult.cs
index 03fcc964d2c..5bba48c8960 100644
--- a/src/Shared/OutOfProcTaskHostTaskResult.cs
+++ b/src/Shared/OutOfProcTaskHostTaskResult.cs
@@ -61,7 +61,7 @@ internal OutOfProcTaskHostTaskResult(TaskCompleteType result, IDictionary<string
                 result == TaskCompleteType.CrashedDuringExecution ||
                 result == TaskCompleteType.CrashedAfterExecution)
             {
-                ErrorUtilities.VerifyThrowInternalNull(taskException, "taskException");
+                ErrorUtilities.VerifyThrowInternalNull(taskException, nameof(taskException));
             }
 
             if (exceptionMessage != null)
@@ -75,7 +75,7 @@ internal OutOfProcTaskHostTaskResult(TaskCompleteType result, IDictionary<string
                     );
             }
 
-            if (exceptionMessageArgs != null && exceptionMessageArgs.Length > 0)
+            if (exceptionMessageArgs?.Length > 0)
             {
                 ErrorUtilities.VerifyThrow(exceptionMessage != null, "If we have message args, we need a message.");
             }
diff --git a/src/Shared/ProjectErrorUtilities.cs b/src/Shared/ProjectErrorUtilities.cs
index a819f326029..303749fc6fd 100644
--- a/src/Shared/ProjectErrorUtilities.cs
+++ b/src/Shared/ProjectErrorUtilities.cs
@@ -389,7 +389,7 @@ private static void ThrowInvalidProject
             params object[] args
         )
         {
-            ErrorUtilities.VerifyThrowInternalNull(elementLocation, "elementLocation");
+            ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 #if DEBUG
             if (errorSubCategoryResourceName != null)
             {
diff --git a/src/Shared/ProjectFileErrorUtilities.cs b/src/Shared/ProjectFileErrorUtilities.cs
index 9c6f2361554..c311159d878 100644
--- a/src/Shared/ProjectFileErrorUtilities.cs
+++ b/src/Shared/ProjectFileErrorUtilities.cs
@@ -84,7 +84,6 @@ params object[] args
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
-        /// <param name="condition">The condition to check.</param>
         /// <param name="errorSubCategoryResourceName">The resource string for the error sub-category (can be null).</param>
         /// <param name="projectFile">The invalid project file.</param>
         /// <param name="resourceName">The resource string for the error message.</param>
diff --git a/src/Shared/ProjectWriter.cs b/src/Shared/ProjectWriter.cs
index 9a467ad193b..d925f19dea0 100644
--- a/src/Shared/ProjectWriter.cs
+++ b/src/Shared/ProjectWriter.cs
@@ -119,7 +119,7 @@ internal void Initialize(XmlDocument project, XmlDeclaration projectRootElementD
 
             // don't write an XML declaration unless the project already has one or has non-default encoding
             _writeXmlDeclaration = projectRootElementDeclaration != null ||
-                                   _documentEncoding != null && !_documentEncoding.IsUtf8Encoding();
+                                   _documentEncoding?.IsUtf8Encoding() == false;
         }
 
         /// <summary>
diff --git a/src/Shared/QuotingUtilities.cs b/src/Shared/QuotingUtilities.cs
index b2edbf4a3e4..186fb087fa1 100644
--- a/src/Shared/QuotingUtilities.cs
+++ b/src/Shared/QuotingUtilities.cs
@@ -193,7 +193,7 @@ internal static string Unquote(string input, out int doubleQuotesRemoved)
                         break;
 
                     case '"':
-                        unquotedString.Append('\\', (precedingBackslashes / 2));
+                        unquotedString.Append('\\', precedingBackslashes / 2);
                         if ((precedingBackslashes % 2) == 0)
                         {
                             if (isQuoted &&
diff --git a/src/Shared/ReadOnlyCollection.cs b/src/Shared/ReadOnlyCollection.cs
index c0a712ab818..bb362f26f24 100644
--- a/src/Shared/ReadOnlyCollection.cs
+++ b/src/Shared/ReadOnlyCollection.cs
@@ -128,7 +128,7 @@ public bool Contains(T item)
         /// </summary>
         public void CopyTo(T[] array, int arrayIndex)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(array, "array");
+            ErrorUtilities.VerifyThrowArgumentNull(array, nameof(array));
 
             ICollection<T> backingCollection = _backing as ICollection<T>;
             if (backingCollection != null)
@@ -184,7 +184,7 @@ IEnumerator IEnumerable.GetEnumerator()
         /// </summary>
         void ICollection.CopyTo(Array array, int index)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(array, "array");
+            ErrorUtilities.VerifyThrowArgumentNull(array, nameof(array));
 
             int i = index;
             foreach (T entry in _backing)
diff --git a/src/Shared/ReadOnlyEmptyDictionary.cs b/src/Shared/ReadOnlyEmptyDictionary.cs
index ae922b0f73b..020dba0bb72 100644
--- a/src/Shared/ReadOnlyEmptyDictionary.cs
+++ b/src/Shared/ReadOnlyEmptyDictionary.cs
@@ -150,7 +150,7 @@ public V this[K key]
             get
             {
                 // Trigger KeyNotFoundException
-                return (new Dictionary<K, V>()[key]);
+                return new Dictionary<K, V>()[key];
             }
 
             set
diff --git a/src/Shared/RegisteredTaskObjectCacheBase.cs b/src/Shared/RegisteredTaskObjectCacheBase.cs
index 1d8350fd73d..17444232eba 100644
--- a/src/Shared/RegisteredTaskObjectCacheBase.cs
+++ b/src/Shared/RegisteredTaskObjectCacheBase.cs
@@ -60,10 +60,7 @@ public void RegisterTaskObject(object key, object obj, RegisteredTaskObjectLifet
         {
             ConcurrentDictionary<object, object> dict = GetCollectionForLifetime(lifetime, dontCreate: false);
 
-            if (dict != null)
-            {
-                dict.TryAdd(key, obj);
-            }
+            dict?.TryAdd(key, obj);
         }
 
         /// <summary>
@@ -73,10 +70,7 @@ public object GetRegisteredTaskObject(object key, RegisteredTaskObjectLifetime l
         {
             ConcurrentDictionary<object, object> dict = GetCollectionForLifetime(lifetime, dontCreate: true);
             object obj = null;
-            if (dict != null)
-            {
-                dict.TryGetValue(key, out obj);
-            }
+            dict?.TryGetValue(key, out obj);
 
             return obj;
         }
@@ -88,10 +82,7 @@ public object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime life
         {
             ConcurrentDictionary<object, object> dict = GetCollectionForLifetime(lifetime, dontCreate: true);
             object obj = null;
-            if (dict != null)
-            {
-                dict.TryRemove(key, out obj);
-            }
+            dict?.TryRemove(key, out obj);
 
             return obj;
         }
@@ -155,10 +146,7 @@ private static void DisposeObjects(Lazy<ConcurrentDictionary<object, object>> li
                     try
                     {
                         IDisposable disposable = obj as IDisposable;
-                        if (disposable != null)
-                        {
-                            disposable.Dispose();
-                        }
+                        disposable?.Dispose();
                     }
                     catch (Exception ex)
                     {
diff --git a/src/Shared/RegistryHelper.cs b/src/Shared/RegistryHelper.cs
index 49f6e4076dc..53085889348 100644
--- a/src/Shared/RegistryHelper.cs
+++ b/src/Shared/RegistryHelper.cs
@@ -48,7 +48,7 @@ internal static string GetDefaultValue(RegistryKey baseKey, string subkey)
 
             using (RegistryKey key = baseKey.OpenSubKey(subkey))
             {
-                if (key != null && key.ValueCount > 0)
+                if (key?.ValueCount > 0)
                 {
                     value = (string)key.GetValue("");
                 }
diff --git a/src/Shared/ResourceUtilities.cs b/src/Shared/ResourceUtilities.cs
index b380e8f2054..6d42db51002 100644
--- a/src/Shared/ResourceUtilities.cs
+++ b/src/Shared/ResourceUtilities.cs
@@ -38,7 +38,7 @@ internal static class ResourceUtilities
         internal static string ExtractMessageCode(bool msbuildCodeOnly, string message, out string code)
         {
 #if !BUILDINGAPPXTASKS
-            ErrorUtilities.VerifyThrowInternalNull(message, "message");
+            ErrorUtilities.VerifyThrowInternalNull(message, nameof(message));
 #endif
 
             code = null;
@@ -69,7 +69,7 @@ internal static string ExtractMessageCode(bool msbuildCodeOnly, string message,
 
                 code = message.Substring(i, 7);
 
-                i = i + 8;
+                i += 8;
             }
             else
 #endif
@@ -136,7 +136,7 @@ internal static string ExtractMessageCode(bool msbuildCodeOnly, string message,
         /// <returns>The MSBuild F1-help keyword string.</returns>
         private static string GetHelpKeyword(string resourceName)
         {
-            return ("MSBuild." + resourceName);
+            return "MSBuild." + resourceName;
         }
 
 #if !BUILDINGAPPXTASKS
@@ -227,7 +227,7 @@ internal static string FormatString(string unformatted, params object[] args)
             string formatted = unformatted;
 
             // NOTE: String.Format() does not allow a null arguments array
-            if ((args != null) && (args.Length > 0))
+            if ((args?.Length > 0))
             {
 #if DEBUG
 
diff --git a/src/Shared/Resources/xlf/Strings.shared.cs.xlf b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
index 00a783fd1db..da68649da45 100644
--- a/src/Shared/Resources/xlf/Strings.shared.cs.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: Soubor filtru ≈ôe≈°en√≠ v {0} obsahuje projekt {1}, kter√Ω nen√≠ v souboru ≈ôe≈°en√≠ v {2}.</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: JSON v souboru filtru ≈ôe≈°en√≠ {0} m√° nespr√°vn√Ω form√°t.</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: Soubor filtru ≈ôe≈°en√≠ v {0} urƒçuje, ≈æe v {1} se bude nach√°zet soubor ≈ôe≈°en√≠, ale tento soubor neexistuje.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.de.xlf b/src/Shared/Resources/xlf/Strings.shared.de.xlf
index e3bd8284ae0..a50d17cb12b 100644
--- a/src/Shared/Resources/xlf/Strings.shared.de.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.de.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: Die Projektmappenfilter-Datei unter "{0}" enth√§lt das Projekt "{1}", das in der Projektmappendatei unter "{2}" nicht enthalten ist.</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: JSON in der Projektmappenfilter-Datei "{0}" ist falsch formatiert.</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: Die Projektmappenfilter-Datei unter "{0}" gibt an, dass eine Projektmappendatei unter "{1}" vorhanden ist. Diese Datei ist jedoch nicht vorhanden.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.es.xlf b/src/Shared/Resources/xlf/Strings.shared.es.xlf
index 0860cf5f017..826677d1ee6 100644
--- a/src/Shared/Resources/xlf/Strings.shared.es.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.es.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: El archivo de filtro de soluciones en "{0}" incluye el proyecto "{1}", que no est√° en el archivo de soluci√≥n en "{2}".</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: El formato JSON del archivo de filtro de soluciones "{0}" no es correcto.</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: El archivo de filtro de soluciones en "{0}" especifica que habr√° un archivo de soluci√≥n en "{1}", pero ese archivo no existe.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.fr.xlf b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
index b0ee0eaf271..547f7a28e07 100644
--- a/src/Shared/Resources/xlf/Strings.shared.fr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: le fichier de filtre de solution sur "{0}" inclut le projet "{1}", qui ne figure pas dans le fichier solution sur "{2}".</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: les donn√©es JSON du fichier de filtre de solution "{0}" sont dans un format incorrect.</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: le fichier de filtre de solution sur "{0}" sp√©cifie l'existence d'un fichier solution sur "{1}", mais ce fichier n'existe pas.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.it.xlf b/src/Shared/Resources/xlf/Strings.shared.it.xlf
index fa13a591797..d6dd6d83bf3 100644
--- a/src/Shared/Resources/xlf/Strings.shared.it.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.it.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: il file di filtro della soluzione in "{0}" include il progetto "{1}" che non √® presente nel file di soluzione in "{2}".</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: il codice JSON nel file di filtro della soluzione "{0}" non √® formattato correttamente.</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: nel file di filtro della soluzione in "{0}" √® indicata la presenza di un file di soluzione in "{1}", ma tale file non esiste.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ja.xlf b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
index d4c5be36d60..8819383842b 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ja.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
@@ -4,67 +4,47 @@
     <body>
       <trans-unit id="BuildAborted">
         <source>MSB4188: Build was canceled.</source>
-        <target state="new">MSB4188: Build was canceled.</target>
+        <target state="translated">MSB4188: „Éì„É´„Éâ„ÅåÂèñ„ÇäÊ∂à„Åï„Çå„Åæ„Åó„Åü„ÄÇ</target>
         <note>{StrBegin="MSB4188: "} Error when the build stops suddenly for some reason. For example, because a child node died.</note>
       </trans-unit>
       <trans-unit id="BuildEngineCallbacksInTaskHostUnsupported">
         <source>MSB5022: The MSBuild task host does not support running tasks that perform IBuildEngine callbacks. If you wish to perform these operations, please run your task in the core MSBuild process instead.  A task will automatically execute in the task host if the UsingTask has been attributed with a "Runtime" or "Architecture" value, or the task invocation has been attributed with an "MSBuildRuntime" or "MSBuildArchitecture" value, that does not match the current runtime or architecture of MSBuild.</source>
-        <target state="new">MSB5022: The MSBuild task host does not support running tasks that perform IBuildEngine callbacks. If you wish to perform these operations, please run your task in the core MSBuild process instead.  A task will automatically execute in the task host if the UsingTask has been attributed with a "Runtime" or "Architecture" value, or the task invocation has been attributed with an "MSBuildRuntime" or "MSBuildArchitecture" value, that does not match the current runtime or architecture of MSBuild.</target>
+        <target state="translated">MSB5022: MSBuild „Çø„Çπ„ÇØ „Éõ„Çπ„Éà„ÅØ„ÄÅIBuildEngine „Ç≥„Éº„É´„Éê„ÉÉ„ÇØ„ÇíÂÆüË°å„Åô„Çã„Çø„Çπ„ÇØ„ÅÆÂÆüË°å„Çí„Çµ„Éù„Éº„Éà„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ„Åì„Çå„Çâ„ÅÆÊìç‰Ωú„ÇíÂÆüË°å„Åô„ÇãÂ†¥Âêà„ÅØ„ÄÅ„Çø„Çπ„ÇØ„Çí„Ç≥„Ç¢ MSBuild „Éó„É≠„Çª„Çπ„ÅßÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇUsingTask „ÅÆÂ±ûÊÄß„Å®„Åó„Å¶Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Çã "Runtime" „Åæ„Åü„ÅØ "Architecture" „ÅÆÂÄ§„ÄÅ„ÅÇ„Çã„ÅÑ„ÅØ„Çø„Çπ„ÇØÂëº„Å≥Âá∫„Åó„ÅÆÂ±ûÊÄß„Å®„Åó„Å¶Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Çã "MSBuildRuntime" „Åæ„Åü„ÅØ "MSBuildArchitecture" „ÅÆÂÄ§„Åå MSBuild „ÅÆÁèæÂú®„ÅÆ„É©„É≥„Çø„Ç§„É†„Åæ„Åü„ÅØ„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£„Å®‰∏ÄËá¥„Åó„Å™„ÅÑÂ†¥Âêà„ÄÅ„Çø„Çπ„ÇØ„ÅØËá™ÂãïÁöÑ„Å´„Çø„Çπ„ÇØ „Éõ„Çπ„Éà„ÅßÂÆüË°å„Åï„Çå„Åæ„Åô„ÄÇ</target>
         <note>{StrBegin="MSB5022: "} "Runtime", "Architecture", "MSBuildRuntime", and "MSBuildArchitecture" are all attributes in the project file, and thus should not be localized.</note>
       </trans-unit>
       <trans-unit id="BuildStarted">
         <source>Build started.</source>
-        <target state="new">Build started.</target>
+        <target state="translated">„Éì„É´„Éâ„ÇíÈñãÂßã„Åó„Åæ„Åó„Åü„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="ConflictingTaskAssembly">
         <source>MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</source>
-        <target state="new">MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</target>
+        <target state="translated">MSB4008: „Çø„Çπ„ÇØ „Ç¢„Çª„É≥„Éñ„É™ "{0}" „Å´ÂØæ„Åó„Å¶Á´∂Âêà„Åó„Å¶„ÅÑ„Çã„Ç¢„Çª„É≥„Éñ„É™„Åå "{1}" „ÅßË¶ã„Å§„Åã„Çä„Åæ„Åó„Åü„ÄÇ</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
-      <trans-unit id="DirectoryNotFound">
-        <source>Could not find directory path: {0}</source>
-        <target state="new">Could not find directory path: {0}</target>
-        <note>Directory must exist</note>
-      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
-        <target state="new">Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</target>
+        <target state="translated">„Ç§„Éô„É≥„Éà„ÅÆÁ®ÆÈ°û "{0}" „ÅØ .NET „Ç∑„É™„Ç¢„É©„Ç§„Ç∂„Éº„Çí‰ΩøÁî®„Åó„Å¶„Ç∑„É™„Ç¢„É´ÂåñÂèØËÉΩ„Åß„ÅÇ„Çã„Åì„Å®„ÅåÊÉ≥ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åó„Åü„Åå„ÄÅ„Ç∑„É™„Ç¢„É´ÂåñÂèØËÉΩ„Åß„Å™„Åã„Å£„Åü„Åü„ÇÅÁÑ°Ë¶ñ„Åï„Çå„Åæ„Åó„Åü„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="FileLocation">
         <source>{0} ({1},{2})</source>
-        <target state="new">{0} ({1},{2})</target>
+        <target state="translated">{0} ({1},{2})</target>
         <note>A file location to be embedded in a string.</note>
       </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.CouldNotGenerateReferenceAssemblyDirectory">
-        <source>When attempting to generate a reference assembly path from the path "{0}" and the framework moniker "{1}" there was an error. {2}</source>
-        <target state="new">When attempting to generate a reference assembly path from the path "{0}" and the framework moniker "{1}" there was an error. {2}</target>
-        <note>No Error code because this resource will be used in an exception. The error code is discarded if it is included</note>
-      </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersion">
-        <source>.NET Framework version "{0}" is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</source>
-        <target state="new">.NET Framework version "{0}" is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersionForWindowsSdk">
-        <source>.NET Framework version "{0}" is not supported when explicitly targeting the Windows SDK, which is only supported on .NET 4.5 and later.  Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion that is Version45 or above.</source>
-        <target state="new">.NET Framework version "{0}" is not supported when explicitly targeting the Windows SDK, which is only supported on .NET 4.5 and later.  Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion that is Version45 or above.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.UnsupportedVisualStudioVersion">
-        <source>Visual Studio version "{0}" is not supported.  Please specify a value from the enumeration Microsoft.Build.Utilities.VisualStudioVersion.</source>
-        <target state="new">Visual Studio version "{0}" is not supported.  Please specify a value from the enumeration Microsoft.Build.Utilities.VisualStudioVersion.</target>
-        <note />
+      <trans-unit id="ModifyingTaskHostEnvironmentHeader">
+        <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
+        <target state="translated">Ë¶™„Éé„Éº„Éâ„Åã„ÇâÂèó„ÅëÂèñ„Å£„ÅüÁí∞Â¢É„Çí„Çø„Çπ„ÇØ „Éõ„Çπ„Éà„Å´ÈÅ©Áî®„Åô„ÇãÂâç„Å´„ÄÅÊ¨°„ÅÆÂ§âÊõ¥„ÇíË°å„Å£„Å¶„ÅÑ„Åæ„Åô:</target>
+        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
       </trans-unit>
-      <trans-unit id="InvalidLogFileFormat">
-        <source>MSB4233: There was an exception while reading the log file: {0}</source>
-        <target state="new">MSB4233: There was an exception while reading the log file: {0}</target>
-        <note>{StrBegin="MSB4233: "}This is shown when the Binary Logger can't read the log file.</note>
+      <trans-unit id="ModifyingTaskHostEnvironmentVariable">
+        <source>  Setting '{0}' to '{1}' rather than the parent environment's value, '{2}'.</source>
+        <target state="translated">  '{0}' „ÇíË¶™Áí∞Â¢É„ÅÆÂÄ§ '{2}' „Åß„ÅØ„Å™„Åè '{1}' „Å´Ë®≠ÂÆö„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</target>
+        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
       </trans-unit>
       <trans-unit id="InvalidProjectFile">
         <source>MSB4025: The project file could not be loaded. {0}</source>
-        <target state="new">MSB4025: The project file could not be loaded. {0}</target>
+        <target state="translated">MSB4025: „Éó„É≠„Ç∏„Çß„ÇØ„Éà „Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„ÇÅ„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ{0}</target>
         <note>{StrBegin="MSB4025: "}UE: This message is shown when the project file given to the engine cannot be loaded because the filename/path is
     invalid, or due to lack of permissions, or incorrect XML. The project filename is not part of the message because it is
     provided separately to loggers.
@@ -72,236 +52,256 @@
       </trans-unit>
       <trans-unit id="InvalidVerbosity">
         <source>MSB4103: "{0}" is not a valid logger verbosity level.</source>
-        <target state="new">MSB4103: "{0}" is not a valid logger verbosity level.</target>
+        <target state="translated">MSB4103: "{0}" „ÅØÊúâÂäπ„Å™„É≠„Ç¨„ÉºË©≥Á¥∞„É¨„Éô„É´„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</target>
         <note>{StrBegin="MSB4103: "}</note>
       </trans-unit>
       <trans-unit id="MissingProject">
         <source>MSBuild is expecting a valid "{0}" object.</source>
-        <target state="new">MSBuild is expecting a valid "{0}" object.</target>
+        <target state="translated">MSBuild „ÅØÊúâÂäπ„Å™ "{0}" „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÂøÖË¶Å„Å®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</target>
         <note />
       </trans-unit>
-      <trans-unit id="ModifyingTaskHostEnvironmentHeader">
-        <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
-        <target state="new">Making the following modifications to the environment received from the parent node before applying it to the task host:</target>
-        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
+      <trans-unit id="Shared.PathTooLong">
+        <source>Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</source>
+        <target state="translated">„Éë„Çπ: {0} „ÅØ OS „ÅÆ„Éë„Çπ„ÅÆ‰∏äÈôê„ÇíË∂ä„Åà„Å¶„ÅÑ„Åæ„Åô„ÄÇÂÆåÂÖ®‰øÆÈ£æ„ÅÆ„Éï„Ç°„Ç§„É´Âêç„ÅØ {1} ÊñáÂ≠ó‰ª•‰∏ã„Å´„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</target>
+        <note />
       </trans-unit>
-      <trans-unit id="ModifyingTaskHostEnvironmentVariable">
-        <source>  Setting '{0}' to '{1}' rather than the parent environment's value, '{2}'.</source>
-        <target state="new">  Setting '{0}' to '{1}' rather than the parent environment's value, '{2}'.</target>
-        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="translated">MSB5028: "{0}" „ÅÆ„ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥ „Éï„Ç£„É´„Çø„Éº „Éï„Ç°„Ç§„É´„Å´„ÅØ„ÄÅ"{2}" „ÅÆ„ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥ „Éï„Ç°„Ç§„É´„Å´„Å™„ÅÑ„Éó„É≠„Ç∏„Çß„ÇØ„Éà "{1}" „ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="translated">MSB5025: „ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥ „Éï„Ç£„É´„Çø„Éº „Éï„Ç°„Ç§„É´ "{0}" „ÅÆ JSON „ÅÆÂΩ¢Âºè„ÅåÊ≠£„Åó„Åè„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="translated">MSB5026: "{0}" „ÅÆ„ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥ „Éï„Ç£„É´„Çø„Éº „Éï„Ç°„Ç§„É´„Åß„ÅØ„ÄÅ"{1}" „Å´„ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥ „Éï„Ç°„Ç§„É´„ÇíÈÖçÁΩÆ„Åô„Çã„Çà„ÅÜ„Å´ÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ„Åù„ÅÆ„Éï„Ç°„Ç§„É´„ÅØÂ≠òÂú®„Åó„Åæ„Åõ„Çì„ÄÇ</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="UnrecognizedToolsVersion">
+        <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
+        <target state="translated">MSB4132: „ÉÑ„Éº„É´ „Éê„Éº„Ç∏„Éß„É≥ "{0}" „ÅåË™çË≠ò„Åï„Çå„Åæ„Åõ„Çì„ÄÇ‰ΩøÁî®ÂèØËÉΩ„Å™„ÉÑ„Éº„É´ „Éê„Éº„Ç∏„Éß„É≥„ÅØ {1} „Åß„Åô„ÄÇ</target>
+        <note>{StrBegin="MSB4132: "}LOCALIZATION: {1} contains a comma separated list.</note>
       </trans-unit>
       <trans-unit id="NameInvalid">
         <source>MSB5016: The name "{0}" contains an invalid character "{1}".</source>
-        <target state="new">MSB5016: The name "{0}" contains an invalid character "{1}".</target>
+        <target state="translated">MSB5016: ÂêçÂâç "{0}" „ÅØÁÑ°Âäπ„Å™ÊñáÂ≠ó "{1}" „ÇíÂê´„Çì„Åß„ÅÑ„Åæ„Åô„ÄÇ</target>
         <note>{StrBegin="MSB5016: "}</note>
       </trans-unit>
-      <trans-unit id="OM_NotSupportedReadOnlyCollection">
-        <source>This collection is read-only.</source>
-        <target state="new">This collection is read-only.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="Shared.CanNotFindValidMSBuildLocation">
-        <source>MSB5024: Could not determine a valid location to MSBuild. Try running this process from the Developer Command Prompt for Visual Studio.</source>
-        <target state="new">MSB5024: Could not determine a valid location to MSBuild. Try running this process from the Developer Command Prompt for Visual Studio.</target>
-        <note>{StrBegin="MSB5024: "}</note>
-      </trans-unit>
       <trans-unit id="Shared.CannotChangeItemSpecModifiers">
         <source>"{0}" is a reserved item metadata, and cannot be modified or deleted.</source>
-        <target state="new">"{0}" is a reserved item metadata, and cannot be modified or deleted.</target>
+        <target state="translated">"{0}" „ÅØ‰∫àÁ¥Ñ„Åï„Çå„ÅüÈ†ÖÁõÆ„É°„Çø„Éá„Éº„Çø„Åß„Åô„ÄÇÂ§âÊõ¥„Åæ„Åü„ÅØÂâäÈô§„Åô„Çã„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ</target>
         <note>UE: Tasks and OM users are not allowed to remove or change the value of the built-in metadata on items e.g. the meta-data "FullPath", "RelativeDir", etc. are reserved.</note>
       </trans-unit>
       <trans-unit id="Shared.CannotConvertStringToBool">
         <source>The string "{0}" cannot be converted to a boolean (true/false) value.</source>
-        <target state="new">The string "{0}" cannot be converted to a boolean (true/false) value.</target>
+        <target state="translated">ÊñáÂ≠óÂàó "{0}" „Çí„Éñ„Éº„É´ÂÄ§ (true/false) „Å´Â§âÊèõ„Åô„Çã„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.FailedCreatingTempFile">
         <source>MSB5003: Failed to create a temporary file. Temporary files folder is full or its path is incorrect. {0}</source>
-        <target state="new">MSB5003: Failed to create a temporary file. Temporary files folder is full or its path is incorrect. {0}</target>
+        <target state="translated">MSB5003: ‰∏ÄÊôÇ„Éï„Ç°„Ç§„É´„Çí‰ΩúÊàê„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ‰∏ÄÊôÇ„Éï„Ç°„Ç§„É´ „Éï„Ç©„É´„ÉÄ„Éº„Åå„ÅÑ„Å£„Å±„ÅÑ„Åß„ÅÇ„Çã„Åã„ÄÅ„Åæ„Åü„ÅØ„Åù„ÅÆ„Éë„Çπ„ÅåÊ≠£„Åó„Åè„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ{0}</target>
         <note>{StrBegin="MSB5003: "}</note>
       </trans-unit>
       <trans-unit id="Shared.FailedDeletingTempFile">
         <source>MSB5018: Failed to delete the temporary file "{0}". {1}</source>
-        <target state="new">MSB5018: Failed to delete the temporary file "{0}". {1}</target>
+        <target state="translated">MSB5018: ‰∏ÄÊôÇ„Éï„Ç°„Ç§„É´ "{0}" „ÇíÂâäÈô§„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ{1}</target>
         <note>{StrBegin="MSB5018: "}</note>
       </trans-unit>
       <trans-unit id="Shared.InvalidFilespecForTransform">
         <source>The item metadata "%({0})" cannot be applied to the path "{1}". {2}</source>
-        <target state="new">The item metadata "%({0})" cannot be applied to the path "{1}". {2}</target>
+        <target state="translated">È†ÖÁõÆ„É°„Çø„Éá„Éº„Çø "%({0})" „Çí„Éë„Çπ "{1}" „Å´ÈÅ©Áî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇ{2}</target>
         <note>UE: This message is shown when the user tries to perform path manipulations using one of the built-in item metadata e.g. %(RootDir), on an item-spec that's not a valid path. LOCALIZATION: "{2}" is a localized message from a CLR/FX exception.</note>
       </trans-unit>
-      <trans-unit id="Shared.InvalidProjectFile">
-        <source>MSB5019: The project file is malformed: "{0}". {1}</source>
-        <target state="new">MSB5019: The project file is malformed: "{0}". {1}</target>
-        <note>{StrBegin="MSB5019: "}</note>
+      <trans-unit id="TaskNotMarshalByRef">
+        <source>MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</source>
+        <target state="translated">MSB4077: "{0}" „Çø„Çπ„ÇØ„Å´Â±ûÊÄß LoadInSeparateAppDomain „ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅMarshalByRefObject „Åã„ÇâÊ¥æÁîü„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ„Åù„ÅÆ„Çø„Çπ„ÇØ„Åå MarshalByRefObject „Åæ„Åü„ÅØ AppDomainIsolatedTask „Åã„ÇâÊ¥æÁîü„Åó„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</target>
+        <note>{StrBegin="MSB4077: "}LOCALIZATION: &lt;LoadInSeparateAppDomain&gt;, &lt;MarshalByRefObject&gt;, &lt;AppDomainIsolatedTask&gt; should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersion">
+        <source>.NET Framework version "{0}" is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</source>
+        <target state="translated">.NET Framework „ÅÆ„Éê„Éº„Ç∏„Éß„É≥ "{0}" „ÅØ„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇÂàóÊåô Microsoft.Build.Utilities.TargetDotNetFrameworkVersion „Åã„ÇâÂÄ§„ÇíÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersionForWindowsSdk">
+        <source>.NET Framework version "{0}" is not supported when explicitly targeting the Windows SDK, which is only supported on .NET 4.5 and later.  Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion that is Version45 or above.</source>
+        <target state="translated">Windows SDK „ÇíÊòéÁ§∫ÁöÑ„Å´„Çø„Éº„Ç≤„ÉÉ„Éà„Å®„Åô„ÇãÂ†¥Âêà„ÄÅ.NET Framework „ÅÆ„Éê„Éº„Ç∏„Éß„É≥ "{0}" „ÅØ„Çµ„Éù„Éº„Éà„Åï„Çå„Åæ„Åõ„Çì„ÄÇWindows SDK „ÅØ„ÄÅ.NET 4.5 ‰ª•Èôç„Åß„ÅÆ„Åø„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇÂàóÊåô Microsoft.Build.Utilities.TargetDotNetFrameworkVersion „Åã„Çâ Version45 ‰ª•‰∏ä„ÅÆÂÄ§„ÇíÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="FrameworkLocationHelper.UnsupportedVisualStudioVersion">
+        <source>Visual Studio version "{0}" is not supported.  Please specify a value from the enumeration Microsoft.Build.Utilities.VisualStudioVersion.</source>
+        <target state="translated">Visual Studio „ÅÆ„Éê„Éº„Ç∏„Éß„É≥ "{0}" „ÅØ„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇÂàóÊåô Microsoft.Build.Utilities.VisualStudioVersion „Åã„ÇâÂÄ§„ÇíÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="FrameworkLocationHelper.CouldNotGenerateReferenceAssemblyDirectory">
+        <source>When attempting to generate a reference assembly path from the path "{0}" and the framework moniker "{1}" there was an error. {2}</source>
+        <target state="translated">ÂèÇÁÖß„Ç¢„Çª„É≥„Éñ„É™ „Éë„Çπ„Çí„Éë„Çπ "{0}" „Å®„Éï„É¨„Éº„É†„ÉØ„Éº„ÇØ „É¢„Éã„Ç´„Éº "{1}" „Åã„ÇâÁîüÊàê„Åó„Çà„ÅÜ„Å®„Åó„Åü„Å®„Åç„Å´„ÄÅ„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ{2}</target>
+        <note>No Error code because this resource will be used in an exception. The error code is discarded if it is included</note>
+      </trans-unit>
+      <trans-unit id="DirectoryNotFound">
+        <source>Could not find directory path: {0}</source>
+        <target state="translated">„Éá„Ç£„É¨„ÇØ„Éà„É™ „Éë„Çπ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü: {0}</target>
+        <note>Directory must exist</note>
+      </trans-unit>
+      <trans-unit id="UnauthorizedAccess">
+        <source>You do not have access to: {0}</source>
+        <target state="translated">{0} „Å∏„ÅÆ„Ç¢„ÇØ„Çª„ÇπÊ®©„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</target>
+        <note>Directory must have access</note>
+      </trans-unit>
+      <trans-unit id="SubCategoryForSchemaValidationErrors">
+        <source>Schema validation</source>
+        <target state="translated">„Çπ„Ç≠„Éº„Éû„ÅÆÊ§úË®º</target>
+        <note>
+      UE: this fragment is used to describe errors that are caused by schema validation. For example, if a normal error is
+      displayed like this: "MSBUILD : error MSB0000: This is an error.", then an error from schema validation would look like this:
+      "MSBUILD : Schema validation error MSB0000: This is an error."
+      LOCALIZATION: This fragment needs to be localized.
+    </note>
       </trans-unit>
       <trans-unit id="Shared.KillingProcess">
         <source>MSB5002: Terminating the task executable "{0}" because it did not finish within the specified limit of {1} milliseconds.</source>
-        <target state="new">MSB5002: Terminating the task executable "{0}" because it did not finish within the specified limit of {1} milliseconds.</target>
+        <target state="translated">MSB5002: ÂÆüË°åÂèØËÉΩ„Å™„Çø„Çπ„ÇØ "{0}" „ÅØ„ÄÅÊåáÂÆö„Åï„Çå„ÅüÂà∂Èôê ({1} „Éü„É™Áßí) ÂÜÖ„ÅßÂÆå‰∫Ü„Åó„Å™„Åã„Å£„Åü„Åü„ÇÅ„ÄÅÁµÇ‰∫Ü„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</target>
         <note>{StrBegin="MSB5002: "}</note>
       </trans-unit>
-      <trans-unit id="Shared.KillingProcessByCancellation">
-        <source>MSB5021: Terminating the task executable "{0}" and its child processes because the build was canceled.</source>
-        <target state="new">MSB5021: Terminating the task executable "{0}" and its child processes because the build was canceled.</target>
-        <note>{StrBegin="MSB5021: "}</note>
-      </trans-unit>
       <trans-unit id="Shared.ParameterCannotBeNull">
         <source>Parameter "{0}" cannot be null.</source>
-        <target state="new">Parameter "{0}" cannot be null.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="Shared.ParameterCannotHaveInvalidPathChars">
-        <source>Parameter "{0}" with assigned value "{1}" cannot have invalid path or invalid file characters.</source>
-        <target state="new">Parameter "{0}" with assigned value "{1}" cannot have invalid path or invalid file characters.</target>
+        <target state="translated">„Éë„É©„É°„Éº„Çø„Éº "{0}" „Çí null „Å´„Åô„Çã„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.ParameterCannotHaveZeroLength">
         <source>Parameter "{0}" cannot have zero length.</source>
-        <target state="new">Parameter "{0}" cannot have zero length.</target>
+        <target state="translated">„Éë„É©„É°„Éº„Çø„Éº "{0}" „ÅÆÈï∑„Åï„Çí 0 „Å´„Åô„Çã„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.ParametersMustHaveTheSameLength">
         <source>Parameters "{0}" and "{1}" must have the same number of elements.</source>
-        <target state="new">Parameters "{0}" and "{1}" must have the same number of elements.</target>
+        <target state="translated">„Éë„É©„É°„Éº„Çø„Éº "{0}" „Å® "{1}" „ÅÆË¶ÅÁ¥†Êï∞„ÅØÂêå„Åò„Åß„ÅÇ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</target>
         <note />
       </trans-unit>
-      <trans-unit id="Shared.PathTooLong">
-        <source>Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</source>
-        <target state="new">Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="Shared.ProjectFileCouldNotBeLoaded">
-        <source>MSB5020: Could not load the project file: "{0}". {1}</source>
-        <target state="new">MSB5020: Could not load the project file: "{0}". {1}</target>
-        <note>{StrBegin="MSB5020: "}</note>
-      </trans-unit>
       <trans-unit id="Shared.TaskResourceNotFound">
         <source>The resource string "{0}" for the "{1}" task cannot be found. Confirm that the resource name "{0}" is correctly spelled, and the resource exists in the task's assembly.</source>
-        <target state="new">The resource string "{0}" for the "{1}" task cannot be found. Confirm that the resource name "{0}" is correctly spelled, and the resource exists in the task's assembly.</target>
+        <target state="translated">"{1}" „Çø„Çπ„ÇØ„ÅÆ„É™„ÇΩ„Éº„ÇπÊñáÂ≠óÂàó "{0}" „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ„É™„ÇΩ„Éº„ÇπÂêç "{0}" „ÅÆ„Çπ„Éö„É´„ÅåÊ≠£„Åó„ÅÑ„Åì„Å®„ÄÅ„Åä„Çà„Å≥„É™„ÇΩ„Éº„Çπ„Åå„Çø„Çπ„ÇØ„ÅÆ„Ç¢„Çª„É≥„Éñ„É™ÂÜÖ„Å´Â≠òÂú®„Åô„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.TaskResourcesNotRegistered">
         <source>The "{0}" task has not registered its resources. In order to use the "TaskLoggingHelper.FormatResourceString()" method this task needs to register its resources either during construction, or via the "TaskResources" property.</source>
-        <target state="new">The "{0}" task has not registered its resources. In order to use the "TaskLoggingHelper.FormatResourceString()" method this task needs to register its resources either during construction, or via the "TaskResources" property.</target>
+        <target state="translated">"{0}" „Çø„Çπ„ÇØ„ÅÆ„É™„ÇΩ„Éº„Çπ„ÅåÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ"TaskLoggingHelper.FormatResourceString()" „É°„ÇΩ„ÉÉ„Éâ„Çí‰ΩøÁî®„Åô„Çã„Åü„ÇÅ„Å´„ÅØ„ÄÅÊßãÁØâÊôÇ„Å´„ÄÅ„Åæ„Åü„ÅØ "TaskResources" „Éó„É≠„Éë„ÉÜ„Ç£„ÇíÈÄö„Åò„Å¶„ÄÅ„Åì„ÅÆ„Çø„Çπ„ÇØ„ÅÆ„É™„ÇΩ„Éº„Çπ„ÇíÁôªÈå≤„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</target>
         <note>LOCALIZATION: "TaskLoggingHelper.FormatResourceString()" and "TaskResources" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
-        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
-        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterJsonParsingError">
-        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
-        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterMissingSolutionError">
-        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
-        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
       <trans-unit id="SolutionParseDuplicateProject">
         <source>MSB5004: The solution file has two projects named "{0}".</source>
-        <target state="new">MSB5004: The solution file has two projects named "{0}".</target>
+        <target state="translated">MSB5004: „ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥ „Éï„Ç°„Ç§„É´„Å´„ÅØ "{0}" „Å®„ÅÑ„ÅÜÂêçÂâç„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Åå 2 „Å§„ÅÇ„Çä„Åæ„Åô„ÄÇ</target>
         <note>{StrBegin="MSB5004: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidProjectFileNameCharacters">
         <source>MSB5005: Error parsing project section for project "{0}". The project file name "{1}" contains invalid characters.</source>
-        <target state="new">MSB5005: Error parsing project section for project "{0}". The project file name "{1}" contains invalid characters.</target>
+        <target state="translated">MSB5005: „Éó„É≠„Ç∏„Çß„ÇØ„Éà "{0}" „ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà „Çª„ÇØ„Ç∑„Éß„É≥„ÇíËß£Êûê‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆ„Éï„Ç°„Ç§„É´Âêç "{1}" „Å´ÁÑ°Âäπ„Å™ÊñáÂ≠ó„Åå‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</target>
         <note>{StrBegin="MSB5005: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidProjectFileNameEmpty">
         <source>MSB5006: Error parsing project section for project "{0}". The project file name is empty.</source>
-        <target state="new">MSB5006: Error parsing project section for project "{0}". The project file name is empty.</target>
+        <target state="translated">MSB5006: „Éó„É≠„Ç∏„Çß„ÇØ„Éà "{0}" „ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà „Çª„ÇØ„Ç∑„Éß„É≥„ÇíËß£Êûê‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆ„Éï„Ç°„Ç§„É´Âêç„ÅåÁ©∫„Åß„Åô„ÄÇ</target>
         <note>{StrBegin="MSB5006: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidProjectSolutionConfigurationEntry">
         <source>MSB5007: Error parsing the project configuration section in solution file. The entry "{0}" is invalid.</source>
-        <target state="new">MSB5007: Error parsing the project configuration section in solution file. The entry "{0}" is invalid.</target>
+        <target state="translated">MSB5007: „ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥ „Éï„Ç°„Ç§„É´ÂÜÖ„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„ÉàÊßãÊàê„Çª„ÇØ„Ç∑„Éß„É≥„ÇíËß£Êûê‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„Ç®„É≥„Éà„É™ "{0}" „ÅØÁÑ°Âäπ„Åß„Åô„ÄÇ</target>
         <note>{StrBegin="MSB5007: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidSolutionConfigurationEntry">
         <source>MSB5008: Error parsing the solution configuration section in solution file. The entry "{0}" is invalid.</source>
-        <target state="new">MSB5008: Error parsing the solution configuration section in solution file. The entry "{0}" is invalid.</target>
+        <target state="translated">MSB5008: „ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥ „Éï„Ç°„Ç§„É´ÂÜÖ„ÅÆ„ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥ÊßãÊàê„Çª„ÇØ„Ç∑„Éß„É≥„ÇíËß£Êûê‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„Ç®„É≥„Éà„É™ "{0}" „ÅØÁÑ°Âäπ„Åß„Åô„ÄÇ</target>
         <note>{StrBegin="MSB5008: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectError">
         <source>MSB5009: Error parsing the nested project section in solution file.</source>
-        <target state="new">MSB5009: Error parsing the nested project section in solution file.</target>
+        <target state="translated">MSB5009: „ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥ „Éï„Ç°„Ç§„É´ÂÜÖ„ÅÆÂÖ•„ÇåÂ≠ê„Å´„Åï„Çå„Åü„Éó„É≠„Ç∏„Çß„ÇØ„Éà „Çª„ÇØ„Ç∑„Éß„É≥„ÇíËß£Êûê‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ</target>
         <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectUndefinedError">
         <source>MSB5023: Error parsing the nested project section in solution file. A project with the GUID "{0}" is listed as being nested under project "{1}", but does not exist in the solution.</source>
-        <target state="new">MSB5023: Error parsing the nested project section in solution file. A project with the GUID "{0}" is listed as being nested under project "{1}", but does not exist in the solution.</target>
+        <target state="translated">MSB5023: „ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥ „Éï„Ç°„Ç§„É´„ÅÆÂÖ•„ÇåÂ≠ê„Å´„Å™„Å£„Åü„Éó„É≠„Ç∏„Çß„ÇØ„Éà „Çª„ÇØ„Ç∑„Éß„É≥„ÇíËß£Êûê‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇGUID "{0}" „ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅØ„ÄÅ„Éó„É≠„Ç∏„Çß„ÇØ„Éà "{1}" ‰∏ã„Å´ÂÖ•„ÇåÂ≠ê„Å®„Åó„Å¶Ë°®Á§∫„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ„ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥ÂÜÖ„Å´Â≠òÂú®„Åó„Åæ„Åõ„Çì„ÄÇ</target>
         <note>{StrBegin="MSB5023: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNoHeaderError">
         <source>MSB5010: No file format header found.</source>
-        <target state="new">MSB5010: No file format header found.</target>
+        <target state="translated">MSB5010: „Éï„Ç°„Ç§„É´ÂΩ¢Âºè„ÅÆ„Éò„ÉÉ„ÉÄ„Éº„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ</target>
         <note>{StrBegin="MSB5010: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseProjectDepGuidError">
         <source>MSB5011: Parent project GUID not found in "{0}" project dependency section.</source>
-        <target state="new">MSB5011: Parent project GUID not found in "{0}" project dependency section.</target>
+        <target state="translated">MSB5011: Ë¶™„Éó„É≠„Ç∏„Çß„ÇØ„Éà GUID „Åå "{0}" „Éó„É≠„Ç∏„Çß„ÇØ„Éà‰æùÂ≠ò„Çª„ÇØ„Ç∑„Éß„É≥„ÅßË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ</target>
         <note>{StrBegin="MSB5011: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseProjectEofError">
         <source>MSB5012: Unexpected end-of-file reached inside "{0}" project section.</source>
-        <target state="new">MSB5012: Unexpected end-of-file reached inside "{0}" project section.</target>
+        <target state="translated">MSB5012: "{0}" „Éó„É≠„Ç∏„Çß„ÇØ„Éà „Çª„ÇØ„Ç∑„Éß„É≥ÂÜÖ„Åß„ÄÅ‰∫àÊúü„Åó„Å™„ÅÑ EOF „Å´Âà∞ÈÅî„Åó„Åæ„Åó„Åü„ÄÇ</target>
         <note>{StrBegin="MSB5012: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseProjectError">
         <source>MSB5013: Error parsing a project section.</source>
-        <target state="new">MSB5013: Error parsing a project section.</target>
+        <target state="translated">MSB5013: „Éó„É≠„Ç∏„Çß„ÇØ„Éà „Çª„ÇØ„Ç∑„Éß„É≥„ÇíËß£Êûê‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ</target>
         <note>{StrBegin="MSB5013: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseVersionMismatchError">
         <source>MSB5014: File format version is not recognized.  MSBuild can only read solution files between versions {0}.0 and {1}.0, inclusive.</source>
-        <target state="new">MSB5014: File format version is not recognized.  MSBuild can only read solution files between versions {0}.0 and {1}.0, inclusive.</target>
+        <target state="translated">MSB5014: „Éï„Ç°„Ç§„É´ÂΩ¢Âºè„ÅÆ„Éê„Éº„Ç∏„Éß„É≥„ÇíË™çË≠ò„Åß„Åç„Åæ„Åõ„Çì„ÄÇMSBuild „ÅßË™≠„ÅøÂèñ„Çã„Åì„Å®„Åå„Åß„Åç„Çã„ÅÆ„ÅØ„ÄÅ„Éê„Éº„Ç∏„Éß„É≥ {0}.0 ÔΩû {1}.0 „ÅÆ„ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥ „Éï„Ç°„Ç§„É´„Å†„Åë„Åß„Åô„ÄÇ</target>
         <note>{StrBegin="MSB5014: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseWebProjectPropertiesError">
         <source>MSB5015: The properties could not be read from the WebsiteProperties section of the "{0}" project.</source>
-        <target state="new">MSB5015: The properties could not be read from the WebsiteProperties section of the "{0}" project.</target>
+        <target state="translated">MSB5015: "{0}" „Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆ WebsiteProperties „Çª„ÇØ„Ç∑„Éß„É≥„Åã„Çâ„Éó„É≠„Éë„ÉÜ„Ç£„ÇíË™≠„ÅøÂèñ„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ</target>
         <note>{StrBegin="MSB5015: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
-      <trans-unit id="SubCategoryForSchemaValidationErrors">
-        <source>Schema validation</source>
-        <target state="new">Schema validation</target>
-        <note>
-      UE: this fragment is used to describe errors that are caused by schema validation. For example, if a normal error is
-      displayed like this: "MSBUILD : error MSB0000: This is an error.", then an error from schema validation would look like this:
-      "MSBUILD : Schema validation error MSB0000: This is an error."
-      LOCALIZATION: This fragment needs to be localized.
-    </note>
+      <trans-unit id="UnrecognizedSolutionComment">
+        <source>Unrecognized solution version "{0}", attempting to continue.</source>
+        <target state="translated">"{0}" „ÅØË™çË≠ò„Åß„Åç„Å™„ÅÑ„ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥ „Éê„Éº„Ç∏„Éß„É≥„Åß„Åô„ÄÇÁ∂öË°å„ÇíË©¶„Åø„Åæ„Åô„ÄÇ</target>
+        <note />
       </trans-unit>
       <trans-unit id="SubCategoryForSolutionParsingErrors">
         <source>Solution file</source>
-        <target state="new">Solution file</target>
+        <target state="translated">„ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥ „Éï„Ç°„Ç§„É´</target>
         <note>UE: this fragment is used to describe errors found while parsing solution files. For example, if a normal error is
       displayed like this: "MSBUILD : error MSB0000: This is an error.", then an error from solution parsing would look like this:
       "MSBUILD : Solution file error MSB0000: This is an error."
       LOCALIZATION: This fragment needs to be localized.</note>
       </trans-unit>
-      <trans-unit id="TaskNotMarshalByRef">
-        <source>MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</source>
-        <target state="new">MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</target>
-        <note>{StrBegin="MSB4077: "}LOCALIZATION: &lt;LoadInSeparateAppDomain&gt;, &lt;MarshalByRefObject&gt;, &lt;AppDomainIsolatedTask&gt; should not be localized.</note>
+      <trans-unit id="Shared.InvalidProjectFile">
+        <source>MSB5019: The project file is malformed: "{0}". {1}</source>
+        <target state="translated">MSB5019: „Éó„É≠„Ç∏„Çß„ÇØ„Éà „Éï„Ç°„Ç§„É´„ÅÆÂΩ¢Âºè„ÅåÊ≠£„Åó„Åè„ÅÇ„Çä„Åæ„Åõ„Çì: "{0}"„ÄÇ{1}</target>
+        <note>{StrBegin="MSB5019: "}</note>
       </trans-unit>
-      <trans-unit id="UnauthorizedAccess">
-        <source>You do not have access to: {0}</source>
-        <target state="new">You do not have access to: {0}</target>
-        <note>Directory must have access</note>
+      <trans-unit id="Shared.ProjectFileCouldNotBeLoaded">
+        <source>MSB5020: Could not load the project file: "{0}". {1}</source>
+        <target state="translated">MSB5020: „Éó„É≠„Ç∏„Çß„ÇØ„Éà „Éï„Ç°„Ç§„É´ "{0}" „ÇíË™≠„ÅøËæº„ÇÅ„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ{1}</target>
+        <note>{StrBegin="MSB5020: "}</note>
       </trans-unit>
-      <trans-unit id="UnrecognizedSolutionComment">
-        <source>Unrecognized solution version "{0}", attempting to continue.</source>
-        <target state="new">Unrecognized solution version "{0}", attempting to continue.</target>
+      <trans-unit id="Shared.KillingProcessByCancellation">
+        <source>MSB5021: Terminating the task executable "{0}" and its child processes because the build was canceled.</source>
+        <target state="translated">MSB5021: „Éì„É´„Éâ„ÅåÂèñ„ÇäÊ∂à„Åï„Çå„Åü„Åü„ÇÅ„ÄÅÂÆüË°åÂèØËÉΩ„Å™„Çø„Çπ„ÇØ "{0}" „Å®„Åù„ÅÆÂ≠ê„Éó„É≠„Çª„Çπ„ÇíÁµÇ‰∫Ü„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</target>
+        <note>{StrBegin="MSB5021: "}</note>
+      </trans-unit>
+      <trans-unit id="OM_NotSupportedReadOnlyCollection">
+        <source>This collection is read-only.</source>
+        <target state="translated">„Åì„ÅÆ„Ç≥„É¨„ÇØ„Ç∑„Éß„É≥„ÅØË™≠„ÅøÂèñ„ÇäÂ∞ÇÁî®„Åß„Åô„ÄÇ</target>
         <note />
       </trans-unit>
-      <trans-unit id="UnrecognizedToolsVersion">
-        <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
-        <target state="new">MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</target>
-        <note>{StrBegin="MSB4132: "}LOCALIZATION: {1} contains a comma separated list.</note>
+      <trans-unit id="Shared.CanNotFindValidMSBuildLocation">
+        <source>MSB5024: Could not determine a valid location to MSBuild. Try running this process from the Developer Command Prompt for Visual Studio.</source>
+        <target state="translated">MSB5024: MSBuild „Å∏„ÅÆÊúâÂäπ„Å™Â†¥ÊâÄ„ÅåÊ±∫ÂÆö„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇVisual Studio „ÅÆÈñãÁô∫ËÄÖ„Ç≥„Éû„É≥„Éâ „Éó„É≠„É≥„Éó„Éà„Åã„Çâ„Åì„ÅÆ„Éó„É≠„Çª„Çπ„ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</target>
+        <note>{StrBegin="MSB5024: "}</note>
+      </trans-unit>
+      <trans-unit id="InvalidLogFileFormat">
+        <source>MSB4233: There was an exception while reading the log file: {0}</source>
+        <target state="translated">MSB4233: „É≠„Ç∞ „Éï„Ç°„Ç§„É´„ÅÆË™≠„ÅøÂèñ„Çä‰∏≠„Å´‰æãÂ§ñ„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: {0}</target>
+        <note>{StrBegin="MSB4233: "}This is shown when the Binary Logger can't read the log file.</note>
+      </trans-unit>
+      <trans-unit id="Shared.ParameterCannotHaveInvalidPathChars">
+        <source>Parameter "{0}" with assigned value "{1}" cannot have invalid path or invalid file characters.</source>
+        <target state="translated">ÂÄ§ "{1}" „ÅåÂâ≤„ÇäÂΩì„Å¶„Çâ„Çå„Åü„Éë„É©„É°„Éº„Çø„Éº "{0}" „Å´„ÅØ„ÄÅÁÑ°Âäπ„Å™„Éë„Çπ„Åæ„Åü„ÅØÁÑ°Âäπ„Å™„Éï„Ç°„Ç§„É´ÂÜÖ„ÅÆÊñáÂ≠ó„ÇíÊåáÂÆö„Åô„Çã„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ</target>
+        <note />
       </trans-unit>
     </body>
   </file>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ko.xlf b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
index 0a9784913d7..283d44b5076 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ko.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: "{0}"Ïùò ÏÜîÎ£®ÏÖò ÌïÑÌÑ∞ ÌååÏùºÏóê "{2}"Ïùò ÏÜîÎ£®ÏÖò ÌååÏùºÏóê ÏóÜÎäî "{1}" ÌîÑÎ°úÏ†ùÌä∏Í∞Ä Ìè¨Ìï®ÎêòÏñ¥ ÏûàÏäµÎãàÎã§.</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: ÏÜîÎ£®ÏÖò ÌïÑÌÑ∞ ÌååÏùº "{0}"Ïùò Json ÌòïÏãùÏù¥ ÏûòÎ™ªÎêòÏóàÏäµÎãàÎã§.</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: "{0}"Ïùò ÏÜîÎ£®ÏÖò ÌïÑÌÑ∞ ÌååÏùºÏù¥ "{1}"Ïóê ÏÜîÎ£®ÏÖò ÌååÏùºÏù¥ ÏûàÎèÑÎ°ù ÏßÄÏ†ïÌïòÏßÄÎßå, Ìï¥Îãπ ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.pl.xlf b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
index 6d6f964b8a2..394f3cca893 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pl.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: Plik filtru rozwiƒÖzania w lokalizacji ‚Äû{0}‚Äù obejmuje projekt ‚Äû{1}‚Äù, kt√≥ry nie znajduje siƒô w pliku rozwiƒÖzania w lokalizacji ‚Äû{2}‚Äù.</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: Kod JSON w pliku filtru rozwiƒÖzania ‚Äû{0}‚Äù jest niepoprawnie sformatowany.</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: Plik filtru rozwiƒÖzania w lokalizacji ‚Äû{0}‚Äù okre≈õla, ≈ºe plik rozwiƒÖzania bƒôdzie siƒô znajdowa≈Ç w lokalizacji ‚Äû{1}‚Äù, ale ten plik nie istnieje.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
index f2b419f77df..5b91a379052 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: o arquivo de filtro da solu√ß√£o em "{0}" inclui o projeto "{1}" que n√£o est√° no arquivo da solu√ß√£o em "{2}".</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: o JSON no arquivo de filtro da solu√ß√£o "{0}" est√° formatado incorretamente.</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: o arquivo de filtro da solu√ß√£o em "{0}" especifica que haver√° um arquivo de solu√ß√£o em "{1}", mas esse arquivo n√£o existe.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ru.xlf b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
index 111a49830f4..0399406e0a6 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ru.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: —Ñ–∞–π–ª —Ñ–∏–ª—å—Ç—Ä–∞ —Ä–µ—à–µ–Ω–∏—è –≤ "{0}" –≤–∫–ª—é—á–∞–µ—Ç –ø—Ä–æ–µ–∫—Ç "{1}", –∫–æ—Ç–æ—Ä—ã–π –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ —Ñ–∞–π–ª–µ —Ä–µ—à–µ–Ω–∏—è –≤ "{2}".</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: –∫–æ–¥ JSON –≤ —Ñ–∞–π–ª–µ —Ñ–∏–ª—å—Ç—Ä–∞ —Ä–µ—à–µ–Ω–∏—è "{0}" –∏–º–µ–µ—Ç –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç.</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: —Ñ–∞–π–ª —Ñ–∏–ª—å—Ç—Ä–∞ —Ä–µ—à–µ–Ω–∏—è –≤ "{0}" —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Ç–æ, —á—Ç–æ –≤ "{1}" –±—É–¥–µ—Ç –Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è —Ñ–∞–π–ª —Ä–µ—à–µ–Ω–∏—è, –æ–¥–Ω–∞–∫–æ —ç—Ç–æ—Ç —Ñ–∞–π–ª –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.tr.xlf b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
index b0b741a3960..d17522e92d2 100644
--- a/src/Shared/Resources/xlf/Strings.shared.tr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: "{0}" konumundaki √ß√∂z√ºm filtresi dosyasƒ±, "{2}" konumundaki √ß√∂z√ºm dosyasƒ±nda bulunmayan "{1}" projesini i√ßeriyor.</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: "{0}" √ß√∂z√ºm filtresi dosyasƒ±ndaki JSON hatalƒ± bi√ßimlendirilmi≈ü.</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: "{0}" konumundaki √ß√∂z√ºm filtresi dosyasƒ±, "{1}" konumunda bir √ß√∂z√ºm dosyasƒ± olacaƒüƒ±nƒ± belirtiyor, ancak bu dosya mevcut deƒüil.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
index 398938a8677..ada4552472c 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: ‰Ωç‰∫é‚Äú{0}‚ÄùÁöÑËß£ÂÜ≥ÊñπÊ°àÁ≠õÈÄâÂô®Êñá‰ª∂ÂåÖÂê´‚Äú{2}‚ÄùÂ§ÑÁöÑËß£ÂÜ≥ÊñπÊ°àÊñá‰ª∂‰∏≠Ê≤°ÊúâÁöÑÈ°πÁõÆ‚Äú{1}‚Äù„ÄÇ</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: Ëß£ÂÜ≥ÊñπÊ°àÁ≠õÈÄâÂô®Êñá‰ª∂‚Äú{0}‚Äù‰∏≠ÁöÑ JSON ÁöÑÊ†ºÂºè‰∏çÊ≠£Á°Æ„ÄÇ</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: ‰Ωç‰∫é‚Äú{0}‚ÄùÁöÑËß£ÂÜ≥ÊñπÊ°àÁ≠õÈÄâÂô®Êñá‰ª∂ÊåáÂÆö‚Äú{1}‚ÄùÂ§ÑÂ∞ÜÂ≠òÂú®‰∏Ä‰∏™Ëß£ÂÜ≥ÊñπÊ°àÊñá‰ª∂Ôºå‰ΩÜËØ•Êñá‰ª∂‰∏çÂ≠òÂú®„ÄÇ</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
index 418a2c2a06b..93035219c43 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: ‰ΩçÊñº "{0}" ÁöÑËß£Ê±∫ÊñπÊ°àÁØ©ÈÅ∏Ê™îÊ°àÂåÖÂê´Â∞àÊ°à "{1}"ÔºåË©≤Â∞àÊ°à‰∏çÂú®‰ΩçÊñº "{2}" ÁöÑËß£Ê±∫ÊñπÊ°àÊ™îÊ°à‰∏≠„ÄÇ</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: Ëß£Ê±∫ÊñπÊ°àÁØ©ÈÅ∏Ê™îÊ°à "{0}" ‰∏≠ÁöÑ Json Ê†ºÂºè‰∏çÊ≠£Á¢∫„ÄÇ</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: ‰ΩçÊñº "{0}" ÁöÑËß£Ê±∫ÊñπÊ°àÁØ©ÈÅ∏Ê™îÊ°àÊåáÂÆöÂ∞áÊúÉÊúâ‰ΩçÊñº "{1}" ÁöÑËß£Ê±∫ÊñπÊ°àÊ™îÊ°àÔºå‰ΩÜË©≤Ê™îÊ°à‰∏¶‰∏çÂ≠òÂú®„ÄÇ</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/ReuseableStringBuilder.cs b/src/Shared/ReuseableStringBuilder.cs
index 8f295e0b263..fbcaabe7e11 100644
--- a/src/Shared/ReuseableStringBuilder.cs
+++ b/src/Shared/ReuseableStringBuilder.cs
@@ -50,7 +50,7 @@ internal sealed class ReuseableStringBuilder : IDisposable, IInternable
         /// </summary>
         public int Length
         {
-            get { return ((_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length); }
+            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }
             set
             {
                 LazyPrepare();
@@ -80,7 +80,6 @@ string IInternable.ExpensiveConvertToString()
                 _cachedString = ((ReuseableStringBuilder)this).ToString();
             }
             return _cachedString;
-
         }
 
         /// <summary>
diff --git a/src/Shared/StrongNameHelpers.cs b/src/Shared/StrongNameHelpers.cs
index 7d8bbdb6a4b..e3c48eb59bd 100644
--- a/src/Shared/StrongNameHelpers.cs
+++ b/src/Shared/StrongNameHelpers.cs
@@ -143,7 +143,7 @@ public static bool StrongNameKeyInstall(string pwzKeyContainer, IntPtr pbKeyBlob
         public static bool StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob)
         {
             IntPtr ppbSignatureBlob = IntPtr.Zero;
-            int cbSignatureBlob = 0;
+            int cbSignatureBlob;
             return StrongNameSignatureGeneration(pwzFilePath, pwzKeyContainer, pbKeyBlob, cbKeyBlob, ref ppbSignatureBlob, out cbSignatureBlob);
         }
 
@@ -280,7 +280,7 @@ public static bool StrongNameKeyInstall(string pwzKeyContainer, byte[] bKeyBlob,
         public static bool StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, byte[] bKeyBlob, int cbKeyBlob)
         {
             IntPtr ppbSignatureBlob = IntPtr.Zero;
-            int cbSignatureBlob = 0;
+            int cbSignatureBlob;
             return StrongNameSignatureGeneration(pwzFilePath, pwzKeyContainer, bKeyBlob, cbKeyBlob, ref ppbSignatureBlob, out cbSignatureBlob);
         }
 
diff --git a/src/Shared/TaskHostConfiguration.cs b/src/Shared/TaskHostConfiguration.cs
index 9f031270a1f..141528ecc11 100644
--- a/src/Shared/TaskHostConfiguration.cs
+++ b/src/Shared/TaskHostConfiguration.cs
@@ -86,6 +86,7 @@ internal class TaskHostConfiguration : INodePacket
 
         private Dictionary<string, string> _globalParameters;
 
+#if FEATURE_APPDOMAIN
         /// <summary>
         /// Constructor
         /// </summary>
@@ -102,6 +103,25 @@ internal class TaskHostConfiguration : INodePacket
         /// <param name="taskName">Name of the task.</param>
         /// <param name="taskLocation">Location of the assembly the task is to be loaded from.</param>
         /// <param name="taskParameters">Parameters to apply to the task.</param>
+        /// <param name="globalParameters">global properties for the current project.</param>
+#else
+        /// <summary>
+        /// Constructor
+        /// </summary>
+        /// <param name="nodeId">The ID of the node being configured.</param>
+        /// <param name="startupDirectory">The startup directory for the task being executed.</param>
+        /// <param name="buildProcessEnvironment">The set of environment variables to apply to the task execution process.</param>
+        /// <param name="culture">The culture of the thread that will execute the task.</param>
+        /// <param name="uiCulture">The UI culture of the thread that will execute the task.</param>
+        /// <param name="lineNumberOfTask">The line number of the location from which this task was invoked.</param>
+        /// <param name="columnNumberOfTask">The column number of the location from which this task was invoked.</param>
+        /// <param name="projectFileOfTask">The project file from which this task was invoked.</param>
+        /// <param name="continueOnError">Flag to continue with the build after a the task failed</param>
+        /// <param name="taskName">Name of the task.</param>
+        /// <param name="taskLocation">Location of the assembly the task is to be loaded from.</param>
+        /// <param name="taskParameters">Parameters to apply to the task.</param>
+        /// <param name="globalParameters">global properties for the current project.</param>
+#endif
         public TaskHostConfiguration
             (
                 int nodeId,
@@ -122,8 +142,8 @@ public TaskHostConfiguration
                 Dictionary<string, string> globalParameters
             )
         {
-            ErrorUtilities.VerifyThrowInternalLength(taskName, "taskName");
-            ErrorUtilities.VerifyThrowInternalLength(taskLocation, "taskLocation");
+            ErrorUtilities.VerifyThrowInternalLength(taskName, nameof(taskName));
+            ErrorUtilities.VerifyThrowInternalLength(taskLocation, nameof(taskLocation));
 
             _nodeId = nodeId;
             _startupDirectory = startupDirectory;
diff --git a/src/Shared/TaskHostTaskComplete.cs b/src/Shared/TaskHostTaskComplete.cs
index 4a190e217fa..9699bbab4f3 100644
--- a/src/Shared/TaskHostTaskComplete.cs
+++ b/src/Shared/TaskHostTaskComplete.cs
@@ -91,7 +91,7 @@ internal class TaskHostTaskComplete : INodePacket
         /// <param name="buildProcessEnvironment">The build process environment as it was at the end of the task's execution.</param>
         public TaskHostTaskComplete(OutOfProcTaskHostTaskResult result, IDictionary<string, string> buildProcessEnvironment)
         {
-            ErrorUtilities.VerifyThrowInternalNull(result, "result");
+            ErrorUtilities.VerifyThrowInternalNull(result, nameof(result));
 
             _taskResult = result.Result;
             _taskException = result.TaskException;
diff --git a/src/Shared/TaskLoader.cs b/src/Shared/TaskLoader.cs
index 620a0aba57a..5388f15d8e6 100644
--- a/src/Shared/TaskLoader.cs
+++ b/src/Shared/TaskLoader.cs
@@ -34,11 +34,11 @@ internal static class TaskLoader
         /// <returns>true, if specified type is a task</returns>
         internal static bool IsTaskClass(Type type, object unused)
         {
-            return (type.GetTypeInfo().IsClass && !type.GetTypeInfo().IsAbstract && (
+            return type.GetTypeInfo().IsClass && !type.GetTypeInfo().IsAbstract && (
 #if FEATURE_TYPE_GETINTERFACE
-                type.GetTypeInfo().GetInterface("Microsoft.Build.Framework.ITask") != null));
+                type.GetTypeInfo().GetInterface("Microsoft.Build.Framework.ITask") != null);
 #else
-                type.GetInterfaces().Any(interfaceType => interfaceType.FullName == "Microsoft.Build.Framework.ITask")));
+                type.GetInterfaces().Any(interfaceType => interfaceType.FullName == "Microsoft.Build.Framework.ITask"));
 #endif
         }
 
@@ -115,7 +115,7 @@ internal static ITask CreateTask(LoadedType loadedType, string taskName, string
 
 #if FEATURE_APPDOMAIN_UNHANDLED_EXCEPTION
                         // Hook up last minute dumping of any exceptions 
-                        taskAppDomain.UnhandledException += new UnhandledExceptionEventHandler(ExceptionHandling.UnhandledExceptionHandler);
+                        taskAppDomain.UnhandledException += ExceptionHandling.UnhandledExceptionHandler;
 #endif
                     }
                 }
@@ -181,7 +181,7 @@ internal static ITask CreateTask(LoadedType loadedType, string taskName, string
         /// </summary>
         internal static Assembly AssemblyResolver(object sender, ResolveEventArgs args)
         {
-            if ((s_resolverLoadedType != null) && (s_resolverLoadedType.LoadedAssembly != null))
+            if ((s_resolverLoadedType?.LoadedAssembly != null))
             {
                 // Match the name being requested by the resolver with the FullName of the assembly we have loaded
                 if (args.Name.Equals(s_resolverLoadedType.LoadedAssembly.FullName, StringComparison.Ordinal))
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index 97f80cc8b8d..7e27f0e68a2 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -555,7 +555,6 @@ public void LogCommandLine(MessageImportance importance, string commandLine)
                 ErrorUtilities.ThrowInvalidOperation("LoggingBeforeTaskInitialization", e.Message);
             }
 
-
             BuildEngine.LogMessageEvent(e);
         }
 
@@ -572,7 +571,39 @@ public void LogCommandLine(MessageImportance importance, string commandLine)
         /// <exception cref="ArgumentNullException">Thrown when <c>message</c> is null.</exception>
         public void LogError(string message, params object[] messageArgs)
         {
-            LogError(null, null, null, null, 0, 0, 0, 0, message, messageArgs);
+            LogError(null, null, null, null, null, 0, 0, 0, 0, message, messageArgs);
+        }
+
+        /// <summary>
+        /// Logs an error using the specified string and other error details.
+        /// Thread safe.
+        /// </summary>
+        /// <param name="subcategory">Description of the error type (can be null).</param>
+        /// <param name="errorCode">The error code (can be null).</param>
+        /// <param name="helpKeyword">The help keyword for the host IDE (can be null).</param>
+        /// <param name="file">The path to the file containing the error (can be null).</param>
+        /// <param name="lineNumber">The line in the file where the error occurs (set to zero if not available).</param>
+        /// <param name="columnNumber">The column in the file where the error occurs (set to zero if not available).</param>
+        /// <param name="endLineNumber">The last line of a range of lines in the file where the error occurs (set to zero if not available).</param>
+        /// <param name="endColumnNumber">The last column of a range of columns in the file where the error occurs (set to zero if not available).</param>
+        /// <param name="message">The message string.</param>
+        /// <param name="messageArgs">Optional arguments for formatting the message string.</param>
+        /// <exception cref="ArgumentNullException">Thrown when <c>message</c> is null.</exception>
+        public void LogError
+        (
+            string subcategory,
+            string errorCode,
+            string helpKeyword,
+            string file,
+            int lineNumber,
+            int columnNumber,
+            int endLineNumber,
+            int endColumnNumber,
+            string message,
+            params object[] messageArgs
+        )
+        {
+            LogError(subcategory, errorCode, helpKeyword, null, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, messageArgs);
         }
 
         /// <summary>
@@ -588,6 +619,7 @@ public void LogError(string message, params object[] messageArgs)
         /// <param name="endLineNumber">The last line of a range of lines in the file where the error occurs (set to zero if not available).</param>
         /// <param name="endColumnNumber">The last column of a range of columns in the file where the error occurs (set to zero if not available).</param>
         /// <param name="message">The message string.</param>
+        /// <param name="helpLink">A link pointing to more information about the error.</param>
         /// <param name="messageArgs">Optional arguments for formatting the message string.</param>
         /// <exception cref="ArgumentNullException">Thrown when <c>message</c> is null.</exception>
         public void LogError
@@ -595,6 +627,7 @@ public void LogError
             string subcategory,
             string errorCode,
             string helpKeyword,
+            string helpLink,
             string file,
             int lineNumber,
             int columnNumber,
@@ -634,6 +667,7 @@ params object[] messageArgs
                     message,
                     helpKeyword,
                     TaskName,
+                    helpLink,
                     DateTime.UtcNow,
                     messageArgs
                 );
@@ -702,7 +736,7 @@ params object[] messageArgs
             string messageCode;
             string throwAwayMessageBody = ResourceUtilities.ExtractMessageCode(true /* only msbuild codes */, FormatResourceString(messageResourceName, messageArgs), out messageCode);
 
-            ErrorUtilities.VerifyThrow(messageCode == null || messageCode.Length == 0, "Called LogErrorFromResources instead of LogErrorWithCodeFromResources, but message '" + throwAwayMessageBody + "' does have an error code '" + messageCode + "'");
+            ErrorUtilities.VerifyThrow(string.IsNullOrEmpty(messageCode), "Called LogErrorFromResources instead of LogErrorWithCodeFromResources, but message '" + throwAwayMessageBody + "' does have an error code '" + messageCode + "'");
 #endif
 
             LogError
@@ -727,7 +761,7 @@ params object[] messageArgs
         /// 
         /// A task can provide a help keyword prefix either via the Task (or TaskMarshalByRef) base class constructor, or the
         /// Task.HelpKeywordPrefix (or AppDomainIsolatedTask.HelpKeywordPrefix) property.
-        ///    
+        /// 
         /// Thread safe.
         /// </summary>
         /// <param name="messageResourceName">The name of the string resource to load.</param>
@@ -746,7 +780,7 @@ public void LogErrorWithCodeFromResources(string messageResourceName, params obj
         /// 
         /// A task can provide a help keyword prefix either via the Task (or TaskMarshalByRef) base class constructor, or the
         /// Task.HelpKeywordPrefix (or AppDomainIsolatedTask.HelpKeywordPrefix) property.
-        ///    
+        /// 
         /// Thread safe.
         /// </summary>
         /// <param name="subcategoryResourceName">The name of the string resource that describes the error type (can be null).</param>
@@ -922,6 +956,40 @@ public void LogWarning
             string message,
             params object[] messageArgs
         )
+        {
+            LogWarning(subcategory, warningCode, helpKeyword, null, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, messageArgs);
+        }
+
+        /// <summary>
+        /// Logs a warning using the specified string and other warning details.
+        /// Thread safe.
+        /// </summary>
+        /// <param name="subcategory">Description of the warning type (can be null).</param>
+        /// <param name="warningCode">The warning code (can be null).</param>
+        /// <param name="helpKeyword">The help keyword for the host IDE (can be null).</param>
+        /// <param name="helpLink">A link pointing to more information about the warning (can be null).</param>
+        /// <param name="file">The path to the file causing the warning (can be null).</param>
+        /// <param name="lineNumber">The line in the file causing the warning (set to zero if not available).</param>
+        /// <param name="columnNumber">The column in the file causing the warning (set to zero if not available).</param>
+        /// <param name="endLineNumber">The last line of a range of lines in the file causing the warning (set to zero if not available).</param>
+        /// <param name="endColumnNumber">The last column of a range of columns in the file causing the warning (set to zero if not available).</param>
+        /// <param name="message">The message string.</param>
+        /// <param name="messageArgs">Optional arguments for formatting the message string.</param>
+        /// <exception cref="ArgumentNullException">Thrown when <c>message</c> is null.</exception>
+        public void LogWarning
+        (
+            string subcategory,
+            string warningCode,
+            string helpKeyword,
+            string helpLink,
+            string file,
+            int lineNumber,
+            int columnNumber,
+            int endLineNumber,
+            int endColumnNumber,
+            string message,
+            params object[] messageArgs
+        )
         {
             // No lock needed, as BuildEngine methods from v4.5 onwards are thread safe.
             ErrorUtilities.VerifyThrowArgumentNull(message, nameof(message));
@@ -953,6 +1021,7 @@ params object[] messageArgs
                     message,
                     helpKeyword,
                     TaskName,
+                    helpLink,
                     DateTime.UtcNow,
                     messageArgs
                 );
@@ -1036,14 +1105,14 @@ params object[] messageArgs
         }
 
         /// <summary>
-        /// Logs a warning using the specified resource string. 
+        /// Logs a warning using the specified resource string.
         /// If the message has a warning code prefixed to it, the code is extracted and logged with the message. If a help keyword
         /// prefix has been provided, a help keyword for the host IDE is also logged with the message. The help keyword is
         /// composed by appending the string resource name to the prefix.
-        /// 
+        ///
         /// A task can provide a help keyword prefix either via the Task (or TaskMarshalByRef) base class constructor, or the
         /// Task.HelpKeywordPrefix (or AppDomainIsolatedTask.HelpKeywordPrefix) property.
-        /// 
+        ///
         /// Thread safe.
         /// </summary>
         /// <param name="messageResourceName">The name of the string resource to load.</param>
@@ -1055,14 +1124,14 @@ public void LogWarningWithCodeFromResources(string messageResourceName, params o
         }
 
         /// <summary>
-        /// Logs a warning using the specified resource string and other warning details. 
+        /// Logs a warning using the specified resource string and other warning details.
         /// If the message has a warning code, the code is extracted and logged with the message.
         /// If a help keyword prefix has been provided, a help keyword for the host IDE is also logged with the message. The help
         /// keyword is composed by appending the warning message resource string name to the prefix.
-        /// 
+        ///
         /// A task can provide a help keyword prefix either via the Task (or TaskMarshalByRef) base class constructor, or the
         /// Task.HelpKeywordPrefix (or AppDomainIsolatedTask.HelpKeywordPrefix) property.
-        /// 
+        ///
         /// Thread safe.
         /// </summary>
         /// <param name="subcategoryResourceName">The name of the string resource that describes the warning type (can be null).</param>
@@ -1188,8 +1257,8 @@ public bool LogMessagesFromFile(string fileName, MessageImportance messageImport
 
             bool errorsFound;
 
-            // Command-line tools are generally going to emit their output using the current 
-            // codepage, so that it displays correctly in the console window.  
+            // Command-line tools are generally going to emit their output using the current
+            // codepage, so that it displays correctly in the console window.
             using (StreamReader fileStream = FileUtilities.OpenRead(fileName, Encoding.GetEncoding(0))) // HIGHCHAR: Use ANSI for logging messages.
             {
                 errorsFound = LogMessagesFromStream(fileStream, messageImportance);
@@ -1244,7 +1313,7 @@ public bool LogMessageFromText(string lineOfText, MessageImportance messageImpor
             bool isError = false;
             CanonicalError.Parts messageParts = CanonicalError.Parse(lineOfText);
 
-            if (null == messageParts)
+            if (messageParts == null)
             {
                 // Line was not recognized as a canonical error. Log it as a message.
                 LogMessage(messageImportance, lineOfText);
@@ -1255,7 +1324,7 @@ public bool LogMessageFromText(string lineOfText, MessageImportance messageImpor
                 //  Log it as a warning or error.
                 string origin = messageParts.origin;
 
-                if ((origin == null) || (origin.Length == 0))
+                if (string.IsNullOrEmpty(origin))
                 {
                     // Use the task class name as the origin, if none specified.
                     origin = TaskNameUpperCase;
@@ -1329,7 +1398,7 @@ public void LogTelemetry(string eventName, IDictionary<string, string> propertie
 #region AppDomain Code
 
         /// <summary>
-        /// InitializeLifetimeService is called when the remote object is activated. 
+        /// InitializeLifetimeService is called when the remote object is activated.
         /// This method will determine how long the lifetime for the object will be.
         /// Thread safe. However, InitializeLifetimeService and MarkAsInactive should
         /// only be called in that order, together or not at all, and no more than once.
@@ -1365,7 +1434,7 @@ public override object InitializeLifetimeService()
                 // increase the lease time allowing the object to stay in memory
                 _sponsor = new ClientSponsor();
 
-                // When a new lease is requested lets make it last 1 minutes longer. 
+                // When a new lease is requested lets make it last 1 minutes longer.
                 int leaseExtensionTime = 1;
 
                 string leaseExtensionTimeFromEnvironment = Environment.GetEnvironmentVariable("MSBUILDTASKLOGGINGHELPERLEASEEXTENSIONTIME");
diff --git a/src/Shared/TaskLoggingHelperExtension.cs b/src/Shared/TaskLoggingHelperExtension.cs
index 3f1c1528468..fbfe95f875c 100644
--- a/src/Shared/TaskLoggingHelperExtension.cs
+++ b/src/Shared/TaskLoggingHelperExtension.cs
@@ -88,7 +88,7 @@ public ResourceManager TaskSharedResources
         /// <exception cref="InvalidOperationException">Thrown when the <c>TaskResources</c> property of the owner task is not set.</exception>
         override public string FormatResourceString(string resourceName, params object[] args)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(resourceName, "resourceName");
+            ErrorUtilities.VerifyThrowArgumentNull(resourceName, nameof(resourceName));
             ErrorUtilities.VerifyThrowInvalidOperation(TaskResources != null, "Shared.TaskResourcesNotRegistered", TaskName);
             ErrorUtilities.VerifyThrowInvalidOperation(TaskSharedResources != null, "Shared.TaskResourcesNotRegistered", TaskName);
 
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index 31d299b2737..854e55e5623 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -95,7 +95,7 @@ public TaskParameter(object wrappedParameter)
 
             Type wrappedParameterType = wrappedParameter.GetType();
 
-            if ((wrappedParameter as Exception) != null)
+            if (wrappedParameter is Exception)
             {
                 _parameterType = TaskParameterType.Invalid;
                 _wrappedParameter = wrappedParameter;
@@ -274,11 +274,9 @@ internal static TaskParameter FactoryForDeserialization(ITranslator translator)
         private ITaskItem CreateNewTaskItemFrom(ITaskItem copyFrom)
         {
             ITaskItem2 copyFromAsITaskItem2 = copyFrom as ITaskItem2;
-
-            string escapedItemSpec = null;
-            string escapedDefiningProject = null;
-            Dictionary<string, string> escapedMetadata = null;
-
+            string escapedItemSpec;
+            string escapedDefiningProject;
+            Dictionary<string, string> escapedMetadata;
             if (copyFromAsITaskItem2 != null)
             {
                 escapedItemSpec = copyFromAsITaskItem2.EvaluatedIncludeEscaped;
@@ -311,7 +309,7 @@ private ITaskItem CreateNewTaskItemFrom(ITaskItem copyFrom)
                 IDictionary customMetadata = copyFrom.CloneCustomMetadata();
                 escapedMetadata = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
-                if (customMetadata != null && customMetadata.Count > 0)
+                if (customMetadata?.Count > 0)
                 {
                     foreach (string key in customMetadata.Keys)
                     {
@@ -523,7 +521,7 @@ private class TaskParameterTaskItem :
             /// </summary>
             public TaskParameterTaskItem(string escapedItemSpec, string escapedDefiningProject, Dictionary<string, string> escapedMetadata)
             {
-                ErrorUtilities.VerifyThrowInternalNull(escapedItemSpec, "escapedItemSpec");
+                ErrorUtilities.VerifyThrowInternalNull(escapedItemSpec, nameof(escapedItemSpec));
 
                 _escapedItemSpec = escapedItemSpec;
                 _escapedDefiningProject = escapedDefiningProject;
@@ -576,7 +574,7 @@ public int MetadataCount
                 get
                 {
                     int count = (_customEscapedMetadata == null) ? 0 : _customEscapedMetadata.Count;
-                    return (count + FileUtilities.ItemSpecModifiers.All.Length);
+                    return count + FileUtilities.ItemSpecModifiers.All.Length;
                 }
             }
 
@@ -614,13 +612,13 @@ public string GetMetadata(string metadataName)
             /// <param name="metadataValue">The metadata value.</param>
             public void SetMetadata(string metadataName, string metadataValue)
             {
-                ErrorUtilities.VerifyThrowArgumentLength(metadataName, "metadataName");
+                ErrorUtilities.VerifyThrowArgumentLength(metadataName, nameof(metadataName));
 
                 // Non-derivable metadata can only be set at construction time.
                 // That's why this is IsItemSpecModifier and not IsDerivableItemSpecModifier.
                 ErrorUtilities.VerifyThrowArgument(!FileUtilities.ItemSpecModifiers.IsDerivableItemSpecModifier(metadataName), "Shared.CannotChangeItemSpecModifiers", metadataName);
 
-                _customEscapedMetadata = _customEscapedMetadata ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+                _customEscapedMetadata ??= new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
                 _customEscapedMetadata[metadataName] = metadataValue ?? String.Empty;
             }
@@ -631,7 +629,7 @@ public void SetMetadata(string metadataName, string metadataValue)
             /// <param name="metadataName">The name of the metadata to remove.</param>
             public void RemoveMetadata(string metadataName)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(metadataName, "metadataName");
+                ErrorUtilities.VerifyThrowArgumentNull(metadataName, nameof(metadataName));
                 ErrorUtilities.VerifyThrowArgument(!FileUtilities.ItemSpecModifiers.IsItemSpecModifier(metadataName), "Shared.CannotChangeItemSpecModifiers", metadataName);
 
                 if (_customEscapedMetadata == null)
@@ -654,7 +652,7 @@ public void RemoveMetadata(string metadataName)
             /// <param name="destinationItem">The item to copy metadata to.</param>
             public void CopyMetadataTo(ITaskItem destinationItem)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(destinationItem, "destinationItem");
+                ErrorUtilities.VerifyThrowArgumentNull(destinationItem, nameof(destinationItem));
 
                 // also copy the original item-spec under a "magic" metadata -- this is useful for tasks that forward metadata
                 // between items, and need to know the source item where the metadata came from
@@ -721,7 +719,7 @@ public override object InitializeLifetimeService()
             /// </summary>
             string ITaskItem2.GetMetadataValueEscaped(string metadataName)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(metadataName, "metadataName");
+                ErrorUtilities.VerifyThrowArgumentNull(metadataName, nameof(metadataName));
 
                 string metadataValue = null;
 
@@ -736,7 +734,7 @@ string ITaskItem2.GetMetadataValueEscaped(string metadataName)
                     _customEscapedMetadata.TryGetValue(metadataName, out metadataValue);
                 }
 
-                return (metadataValue == null) ? String.Empty : metadataValue;
+                return metadataValue ?? String.Empty;
             }
 
             /// <summary>
diff --git a/src/Shared/TempFileUtilities.cs b/src/Shared/TempFileUtilities.cs
index 8948d8dde99..ae76d151a37 100644
--- a/src/Shared/TempFileUtilities.cs
+++ b/src/Shared/TempFileUtilities.cs
@@ -15,8 +15,8 @@ namespace Microsoft.Build.Shared
     internal static partial class FileUtilities
     {
         /// <summary>
-        /// Generates a unique directory name in the temporary folder.  
-        /// Caller must delete when finished. 
+        /// Generates a unique directory name in the temporary folder.
+        /// Caller must delete when finished.
         /// </summary>
         /// <param name="createDirectory"></param>
         internal static string GetTemporaryDirectory(bool createDirectory = true)
@@ -86,7 +86,7 @@ internal static string GetTemporaryFile(string directory, string extension, bool
 
             try
             {
-                directory = directory ?? Path.GetTempPath();
+                directory ??= Path.GetTempPath();
 
                 Directory.CreateDirectory(directory);
 
@@ -147,6 +147,5 @@ public void Dispose()
                 Directory.Delete(Path, true);
             }
         }
-
     }
 }
diff --git a/src/Shared/ToolsetElement.cs b/src/Shared/ToolsetElement.cs
index 4fb6b9f9f40..4f8451872ab 100644
--- a/src/Shared/ToolsetElement.cs
+++ b/src/Shared/ToolsetElement.cs
@@ -36,7 +36,7 @@ internal static ToolsetConfigurationSection ReadToolsetConfigurationSection(Conf
             // If section definition is present and section is not present, this value is not null
             // If section definition is not present and section is also not present, this value is null
             // If the section definition is not present and section is present, then this value is null
-            if (null != configuration)
+            if (configuration != null)
             {
                 ConfigurationSection msbuildSection = configuration.GetSection("msbuildToolsets");
                 configurationSection = msbuildSection as ToolsetConfigurationSection;
@@ -100,12 +100,12 @@ public string toolsVersion
 
             set
             {
-                base["toolsVersion"] = value;
+                base[nameof(toolsVersion)] = value;
             }
         }
 
         /// <summary>
-        /// Property element collection 
+        /// Property element collection
         /// </summary>
         [ConfigurationProperty("", IsDefaultCollection = true)]
         public PropertyElementCollection PropertyElements
@@ -321,7 +321,7 @@ internal sealed class PropertyElementCollection : ConfigurationElementCollection
 
             /// <summary>
             /// Collection type
-            /// This has to be public as cannot change access modifier when overriding  
+            /// This has to be public as cannot change access modifier when overriding
             /// </summary>
             public override ConfigurationElementCollectionType CollectionType
             {
@@ -610,7 +610,7 @@ private void UpdateToolsVersionMap(ConfigurationElement element)
     /// <summary>
     /// This class is used to programmatically read msbuildToolsets section
     /// in from the configuration file.  An example of application config file:
-    /// 
+    ///
     /// &lt;configuration&gt;
     ///     &lt;msbuildToolsets default="2.0"&gt;
     ///         &lt;toolset toolsVersion="2.0"&gt;
@@ -622,7 +622,7 @@ private void UpdateToolsVersionMap(ConfigurationElement element)
     ///         &lt;/toolset&gt;
     ///     &lt;/msbuildToolsets&gt;
     /// &lt;/configuration&gt;
-    /// 
+    ///
     /// </summary>
     /// <remarks>
     /// Internal for unit testing only
@@ -630,7 +630,7 @@ private void UpdateToolsVersionMap(ConfigurationElement element)
     internal sealed class ToolsetConfigurationSection : ConfigurationSection
     {
         /// <summary>
-        /// toolsVersion element collection 
+        /// toolsVersion element collection
         /// </summary>
         [ConfigurationProperty("", IsDefaultCollection = true)]
         public ToolsetElementCollection Toolsets
@@ -655,7 +655,7 @@ public string Default
                 // Note this means we can't distinguish between the attribute being present but containing
                 // an empty string for its value and the attribute not being present at all.
                 string defaultValue = (string)base["default"];
-                return (String.IsNullOrEmpty(defaultValue) ? null : defaultValue);
+                return String.IsNullOrEmpty(defaultValue) ? null : defaultValue;
             }
 
             set
@@ -678,7 +678,7 @@ public string MSBuildOverrideTasksPath
                 // Note this means we can't distinguish between the attribute being present but containing
                 // an empty string for its value and the attribute not being present at all.
                 string defaultValue = (string)base["msbuildOverrideTasksPath"];
-                return (String.IsNullOrEmpty(defaultValue) ? null : defaultValue);
+                return String.IsNullOrEmpty(defaultValue) ? null : defaultValue;
             }
 
             set
@@ -688,7 +688,7 @@ public string MSBuildOverrideTasksPath
         }
 
         /// <summary>
-        /// DefaultOverrideToolsVersion attribute on msbuildToolsets element, specifying the toolsversion that should be used by 
+        /// DefaultOverrideToolsVersion attribute on msbuildToolsets element, specifying the toolsversion that should be used by
         /// default to build projects with this version of MSBuild.
         /// </summary>
         [ConfigurationProperty("DefaultOverrideToolsVersion")]
@@ -702,12 +702,12 @@ public string DefaultOverrideToolsVersion
                 // Note this means we can't distinguish between the attribute being present but containing
                 // an empty string for its value and the attribute not being present at all.
                 string defaultValue = (string)base["DefaultOverrideToolsVersion"];
-                return (String.IsNullOrEmpty(defaultValue) ? null : defaultValue);
+                return String.IsNullOrEmpty(defaultValue) ? null : defaultValue;
             }
 
             set
             {
-                base["DefaultOverrideToolsVersion"] = value;
+                base[nameof(DefaultOverrideToolsVersion)] = value;
             }
         }
     }
diff --git a/src/Shared/Traits.cs b/src/Shared/Traits.cs
index d2b59ce5c80..0d7768a5ece 100644
--- a/src/Shared/Traits.cs
+++ b/src/Shared/Traits.cs
@@ -136,6 +136,16 @@ internal class EscapeHatches
         /// </summary>
         public readonly bool TruncateTaskInputs = Environment.GetEnvironmentVariable("MSBUILDTRUNCATETASKINPUTS") == "1";
 
+        /// <summary>
+        /// Disables truncation of Condition messages in Tasks/Targets via ExpanderOptions.Truncate.
+        /// </summary>
+        public readonly bool DoNotTruncateConditions = Environment.GetEnvironmentVariable("MSBuildDoNotTruncateConditions") == "1";
+
+        /// <summary>
+        /// Disables skipping full drive/filesystem globs that are behind a false condition.
+        /// </summary>
+        public readonly bool AlwaysEvaluateDangerousGlobs = Environment.GetEnvironmentVariable("MSBuildAlwaysEvaluateDangerousGlobs") == "1";
+
         /// <summary>
         /// Emit events for project imports.
         /// </summary>
@@ -201,7 +211,7 @@ public bool LogTaskInputs
         public readonly bool IgnoreEmptyImports = Environment.GetEnvironmentVariable("MSBUILDIGNOREEMPTYIMPORTS") == "1";
 
         /// <summary>
-        /// Whether to to respect the TreatAsLocalProperty parameter on the Project tag. 
+        /// Whether to respect the TreatAsLocalProperty parameter on the Project tag.
         /// </summary>
         public readonly bool IgnoreTreatAsLocalProperty = Environment.GetEnvironmentVariable("MSBUILDIGNORETREATASLOCALPROPERTY") != null;
 
@@ -271,6 +281,29 @@ public bool LogTaskInputs
         /// </remarks>
         public readonly bool UseMinimalResxParsingInCoreScenarios = Environment.GetEnvironmentVariable("MSBUILDUSEMINIMALRESX") == "1";
 
+        private bool _sdkReferencePropertyExpansionInitialized;
+        private SdkReferencePropertyExpansionMode? _sdkReferencePropertyExpansionValue;
+
+        /// <summary>
+        /// Overrides the default behavior of property expansion on evaluation of a <see cref="Framework.SdkReference"/>.
+        /// </summary>
+        /// <remarks>
+        /// Escape hatch for problems arising from https://github.com/dotnet/msbuild/pull/5552.
+        /// </remarks>
+        public SdkReferencePropertyExpansionMode? SdkReferencePropertyExpansion
+        {
+            get
+            {
+                if (!_sdkReferencePropertyExpansionInitialized)
+                {
+                    _sdkReferencePropertyExpansionValue = ComputeSdkReferencePropertyExpansion();
+                    _sdkReferencePropertyExpansionInitialized = true;
+                }
+
+                return _sdkReferencePropertyExpansionValue;
+            }
+        }
+
         private static bool? ParseNullableBoolFromEnvironmentVariable(string environmentVariable)
         {
             var value = Environment.GetEnvironmentVariable(environmentVariable);
@@ -314,10 +347,58 @@ public bool LogTaskInputs
             return null;
         }
 
+        private static SdkReferencePropertyExpansionMode? ComputeSdkReferencePropertyExpansion()
+        {
+            var mode = Environment.GetEnvironmentVariable("MSBUILD_SDKREFERENCE_PROPERTY_EXPANSION_MODE");
+
+            if (mode == null)
+            {
+                return null;
+            }
+
+            // The following uses StartsWith instead of Equals to enable possible tricks like
+            // the dpiAware "True/PM" trick (see https://devblogs.microsoft.com/oldnewthing/20160617-00/?p=93695)
+            // in the future.
+
+            const StringComparison comparison = StringComparison.OrdinalIgnoreCase;
+
+            if (mode.StartsWith("no", comparison))
+            {
+                return SdkReferencePropertyExpansionMode.NoExpansion;
+            }
+
+            if (mode.StartsWith("default", comparison))
+            {
+                return SdkReferencePropertyExpansionMode.DefaultExpand;
+            }
+
+            if (mode.StartsWith(nameof(SdkReferencePropertyExpansionMode.ExpandUnescape), comparison))
+            {
+                return SdkReferencePropertyExpansionMode.ExpandUnescape;
+            }
+
+            if (mode.StartsWith(nameof(SdkReferencePropertyExpansionMode.ExpandLeaveEscaped), comparison))
+            {
+                return SdkReferencePropertyExpansionMode.ExpandLeaveEscaped;
+            }
+
+            ErrorUtilities.ThrowInternalError($"Invalid escape hatch for SdkReference property expansion: {mode}");
+
+            return null;
+        }
+
         public enum ProjectInstanceTranslationMode
         {
             Full,
             Partial
         }
+
+        public enum SdkReferencePropertyExpansionMode
+        {
+            NoExpansion,
+            DefaultExpand,
+            ExpandUnescape,
+            ExpandLeaveEscaped
+        }
     }
 }
diff --git a/src/Shared/TranslatorHelpers.cs b/src/Shared/TranslatorHelpers.cs
index 20a1a75f2fa..f1cd7166213 100644
--- a/src/Shared/TranslatorHelpers.cs
+++ b/src/Shared/TranslatorHelpers.cs
@@ -21,7 +21,7 @@ internal static class TranslatorHelpers
         /// <typeparam name="T">The reference type.</typeparam>
         /// <param name="translator">The translator</param>
         /// <param name="instance">The value to be translated.</param>
-        /// <param name="factory">The factory method used to instantiate values of type T.</param>
+        /// <param name="valueFactory">The factory method used to instantiate values of type T.</param>
         public static void Translate<T>(
             this ITranslator translator,
             ref T instance,
diff --git a/src/Shared/TypeLoader.cs b/src/Shared/TypeLoader.cs
index b88c90eefdd..7115f9d347f 100644
--- a/src/Shared/TypeLoader.cs
+++ b/src/Shared/TypeLoader.cs
@@ -1,7 +1,6 @@
 Ôªø// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-
 using System;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
@@ -133,7 +132,7 @@ internal static bool IsPartialTypeNameMatch(string typeName1, string typeName2)
             }
             else
             {
-                isPartialMatch = (String.Compare(typeName1, typeName2, StringComparison.OrdinalIgnoreCase) == 0);
+                isPartialMatch = (String.Equals(typeName1, typeName2, StringComparison.OrdinalIgnoreCase));
             }
 
             return isPartialMatch;
@@ -281,7 +280,7 @@ private class AssemblyInfoToLoadedTypes
             internal AssemblyInfoToLoadedTypes(Func<Type, object, bool> typeFilter, AssemblyLoadInfo loadInfo)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(typeFilter, "typefilter");
-                ErrorUtilities.VerifyThrowArgumentNull(loadInfo, "loadInfo");
+                ErrorUtilities.VerifyThrowArgumentNull(loadInfo, nameof(loadInfo));
 
                 _isDesiredType = typeFilter;
                 _assemblyLoadInfo = loadInfo;
@@ -294,7 +293,7 @@ internal AssemblyInfoToLoadedTypes(Func<Type, object, bool> typeFilter, Assembly
             /// </summary>
             internal LoadedType GetLoadedTypeByTypeName(string typeName)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(typeName, "typeName");
+                ErrorUtilities.VerifyThrowArgumentNull(typeName, nameof(typeName));
 
                 // Only one thread should be doing operations on this instance of the object at a time.
 
diff --git a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
index a78ff71ecbd..2c804fa0320 100644
--- a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
+++ b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
@@ -368,25 +368,25 @@ public void CreateAssemblyNameWithNameAndVersionCulturePublicKey()
             extension = new AssemblyNameExtension("A, Version=2.0.0.0, PublicKeyToken=b03f5f7f11d50a3a");
             Assert.Equal("A", extension.Name);
             Assert.True(extension.Version.Equals(new Version("2.0.0.0")));
-            Assert.True(Object.ReferenceEquals(extension.CultureInfo, null));
+            Assert.True(extension.CultureInfo is null);
             Assert.Contains("b03f5f7f11d50a3a", extension.FullName);
 
             extension = new AssemblyNameExtension("A, Culture=en, PublicKeyToken=b03f5f7f11d50a3a");
             Assert.Equal("A", extension.Name);
-            Assert.True(Object.ReferenceEquals(extension.Version, null));
+            Assert.True(extension.Version is null);
             Assert.True(extension.CultureInfo.Equals(new CultureInfo("en")));
             Assert.Contains("b03f5f7f11d50a3a", extension.FullName);
 
             extension = new AssemblyNameExtension("A, PublicKeyToken=b03f5f7f11d50a3a");
             Assert.Equal("A", extension.Name);
-            Assert.True(Object.ReferenceEquals(extension.Version, null));
-            Assert.True(Object.ReferenceEquals(extension.CultureInfo, null));
+            Assert.True(extension.Version is null);
+            Assert.True(extension.CultureInfo is null);
             Assert.Contains("b03f5f7f11d50a3a", extension.FullName);
 
             extension = new AssemblyNameExtension("A");
             Assert.Equal("A", extension.Name);
-            Assert.True(Object.ReferenceEquals(extension.Version, null));
-            Assert.True(Object.ReferenceEquals(extension.CultureInfo, null));
+            Assert.True(extension.Version is null);
+            Assert.True(extension.CultureInfo is null);
         }
 
         /// <summary>
@@ -712,7 +712,6 @@ public void VerifyAssemblyNameExSerialization(string assemblyName)
         [Fact]
         public void VerifyAssemblyNameExSerializationWithRemappedFrom()
         {
-            
             AssemblyNameExtension assemblyNameOriginal = new AssemblyNameExtension("System.Xml, Version=10.0.0.0, Culture=en, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension assemblyRemappedFrom = new AssemblyNameExtension("System.Xml, Version=9.0.0.0, Culture=en, PublicKeyToken=b03f5f7f11d50a3a");
             assemblyRemappedFrom.MarkImmutable();
diff --git a/src/Shared/UnitTests/BuildEventArgsExtension.cs b/src/Shared/UnitTests/BuildEventArgsExtension.cs
index c7ba27feaf2..a98c7a1c991 100644
--- a/src/Shared/UnitTests/BuildEventArgsExtension.cs
+++ b/src/Shared/UnitTests/BuildEventArgsExtension.cs
@@ -29,7 +29,7 @@ public static bool IsEquivalent(this BuildEventArgs args, BuildEventArgs other)
                 return true;
             }
 
-            if (Object.ReferenceEquals(other, null) || Object.ReferenceEquals(args, null))
+            if (other is null || args is null)
             {
                 return false;
             }
diff --git a/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs b/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
index 22e8352e0f0..3299e18f99f 100644
--- a/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
+++ b/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Construction;
 using Xunit;
+using Shouldly;
 
 namespace Microsoft.Build.UnitTests.OM.Collections
 {
@@ -148,22 +149,22 @@ public void OriginalWritesNotVisibleToClones()
         {
             var dictionary = new CopyOnWriteDictionary<string, string>();
             dictionary["test"] = "1";
-            Assert.Equal("1", dictionary["test"]);
+            dictionary["test"].ShouldBe("1");
 
             var clone = dictionary.Clone();
             var clone2 = dictionary.Clone();
 
-            Assert.True(dictionary.HasSameBacking(clone));
-            Assert.True(dictionary.HasSameBacking(clone2));
+            dictionary.HasSameBacking(clone).ShouldBeTrue();
+            dictionary.HasSameBacking(clone2).ShouldBeTrue();
 
             dictionary["test"] = "2";
 
-            Assert.False(dictionary.HasSameBacking(clone));
-            Assert.False(dictionary.HasSameBacking(clone2));
-            Assert.True(clone.HasSameBacking(clone2));
+            dictionary.HasSameBacking(clone).ShouldBeFalse();
+            dictionary.HasSameBacking(clone2).ShouldBeFalse();
+            clone.HasSameBacking(clone2).ShouldBeTrue();
 
-            Assert.Equal("1", clone["test"]);
-            Assert.Equal("1", clone2["test"]);
+            clone["test"].ShouldBe("1");
+            clone2["test"].ShouldBe("1");
         }
 
         /// <summary>
@@ -235,10 +236,10 @@ public void SerializeDeserialize2()
                 formatter.Serialize(stream, dictionary);
                 stream.Position = 0;
 
-                CopyOnWriteDictionary<string, string> dictionary2 = (CopyOnWriteDictionary<string, string>)formatter.Deserialize(stream);
+                CopyOnWriteDictionary<string, string> deserialized = (CopyOnWriteDictionary<string, string>)formatter.Deserialize(stream);
 
-                Assert.Equal(dictionary.Count, dictionary2.Count);
-                Assert.IsType<MSBuildNameIgnoreCaseComparer>(dictionary2.Comparer);
+                deserialized.Count.ShouldBe(dictionary.Count);
+                deserialized.Comparer.ShouldBeOfType<MSBuildNameIgnoreCaseComparer>();
             }
         }
     }
diff --git a/src/Shared/UnitTests/EscapingUtilities_Tests.cs b/src/Shared/UnitTests/EscapingUtilities_Tests.cs
index cecdccab0d3..627de15dff6 100644
--- a/src/Shared/UnitTests/EscapingUtilities_Tests.cs
+++ b/src/Shared/UnitTests/EscapingUtilities_Tests.cs
@@ -46,9 +46,7 @@ public void Escape()
         [Fact]
         public void UnescapeEscape()
         {
-            string text;
-
-            text = "*";
+            string text = "*";
             Assert.Equal(text, EscapingUtilities.UnescapeAll(EscapingUtilities.Escape(text)));
 
             text = "?";
@@ -63,9 +61,7 @@ public void UnescapeEscape()
         [Fact]
         public void EscapeUnescape()
         {
-            string text;
-
-            text = "%2a";
+            string text = "%2a";
             Assert.Equal(text, EscapingUtilities.Escape(EscapingUtilities.UnescapeAll(text)));
 
             text = "%3f";
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index db6f2277c5e..418a51b91db 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -128,7 +128,6 @@ void Verify(string include, string[] excludes, bool shouldHaveNoMatches = false,
             //    of Directory.GetFiles, which is case-sensitive on Unix.
         }
 
-
         /// <summary>
         /// A test data class for providing data to the <see cref="FileMatcherTest.GetFilesComplexGlobbingMatching"/> test.
         /// </summary>
@@ -724,7 +723,6 @@ public void Regress162390()
             );
         }
 
-
         /*
         * Method:  GetLongFileNameForShortLocalPath
         *
@@ -982,7 +980,6 @@ public void ReduceDoubleSlashesBaseline()
             ValidateFileMatch(Path.Combine("**", "*.cs"), "file.cs", true);
         }
 
-
         [Fact]
         public void ReduceDoubleSlashes()
         {
@@ -1091,7 +1088,6 @@ public void Unc()
                 true
                 );
 
-
             ValidateFileMatch
                 (
                 "**",
@@ -1204,7 +1200,6 @@ public void SplitFileSpec()
             ValidateSplitFileSpec("bin\\**\\", "bin\\", "**\\", "");
             ValidateSplitFileSpec("bin\\**\\*", "bin\\", "**\\", "*");
             ValidateSplitFileSpec("**", "", "**\\", "*.*");
-
         }
 
         [Fact]
@@ -1455,7 +1450,6 @@ public void ExcludePatternAndSpecificFiles()
                     @"bin\**",
                     @"Program_old.cs",
                     @"Properties\AssemblyInfo_old.cs"
-
                 },
                 new[]    //  Matching files
                 {
@@ -1857,8 +1851,6 @@ out bool isLegalFileSpec
             isLegalFileSpec.ShouldBe(expectedIsLegalFileSpec);
         }
 
-
-
         #region Support functions.
 
         /// <summary>
@@ -1972,7 +1964,7 @@ private int GetMatchingFiles(string[] candidates, string path, string pattern, I
                             if
                             (
                                 pattern == null ||
-                                String.Compare(pattern, "*.*", StringComparison.OrdinalIgnoreCase) == 0
+                                String.Equals(pattern, "*.*", StringComparison.OrdinalIgnoreCase)
                             )
                             {
                                 ++hits;
@@ -1982,7 +1974,7 @@ private int GetMatchingFiles(string[] candidates, string path, string pattern, I
                             {
                                 string tail = pattern.Substring(1);
                                 string candidateTail = candidate.Substring(candidate.Length - tail.Length);
-                                if (String.Compare(tail, candidateTail, StringComparison.OrdinalIgnoreCase) == 0)
+                                if (String.Equals(tail, candidateTail, StringComparison.OrdinalIgnoreCase))
                                 {
                                     ++hits;
                                     files.Add(FileMatcher.Normalize(candidate));
@@ -1992,11 +1984,11 @@ private int GetMatchingFiles(string[] candidates, string path, string pattern, I
                             {
                                 string leader = pattern.Substring(0, pattern.Length - 4);
                                 string candidateLeader = candidate.Substring(candidate.Length - leader.Length - 4, leader.Length);
-                                if (String.Compare(leader, candidateLeader, StringComparison.OrdinalIgnoreCase) == 0)
+                                if (String.Equals(leader, candidateLeader, StringComparison.OrdinalIgnoreCase))
                                 {
                                     string tail = pattern.Substring(pattern.Length - 2);
                                     string candidateTail = candidate.Substring(candidate.Length - 2);
-                                    if (String.Compare(tail, candidateTail, StringComparison.OrdinalIgnoreCase) == 0)
+                                    if (String.Equals(tail, candidateTail, StringComparison.OrdinalIgnoreCase))
                                     {
                                         ++hits;
                                         files.Add(FileMatcher.Normalize(candidate));
@@ -2042,10 +2034,9 @@ private void GetMatchingDirectories(string[] candidates, string path, string pat
                             int nextSlash = normalizedCandidate.IndexOfAny(FileMatcher.directorySeparatorCharacters, path.Length + 1);
                             if (nextSlash != -1)
                             {
-                                string match;
-
+                                
                                 //UNC paths start with a \\ fragment. Match against \\ when path is empty (i.e., inside the current working directory)
-                                match = normalizedCandidate.StartsWith(@"\\") && string.IsNullOrEmpty(path)
+                                string match = normalizedCandidate.StartsWith(@"\\") && string.IsNullOrEmpty(path)
                                     ? @"\\"
                                     : normalizedCandidate.Substring(0, nextSlash);
 
@@ -2053,7 +2044,7 @@ private void GetMatchingDirectories(string[] candidates, string path, string pat
 
                                 if
                                 (
-                                    String.Compare(pattern, "*.*", StringComparison.OrdinalIgnoreCase) == 0
+                                    String.Equals(pattern, "*.*", StringComparison.OrdinalIgnoreCase)
                                     || pattern == null
                                 )
                                 {
@@ -2067,7 +2058,7 @@ private void GetMatchingDirectories(string[] candidates, string path, string pat
                                 {
                                     string tail = pattern.Substring(1);
                                     string baseMatchTail = baseMatch.Substring(1);
-                                    if (String.Compare(tail, baseMatchTail, StringComparison.OrdinalIgnoreCase) == 0)
+                                    if (String.Equals(tail, baseMatchTail, StringComparison.OrdinalIgnoreCase))
                                     {
                                         directories.Add(FileMatcher.Normalize(match));
                                     }
@@ -2138,7 +2129,6 @@ internal static string Normalize(string path)
                 // Preserve parent-directory markers.
                 normalized = normalized.Replace(@".." + Path.DirectorySeparatorChar, "<:PARENT:>");
 
-
                 // Just get rid of doubles enough to satisfy our test cases.
                 string doubleSeparator = Path.DirectorySeparatorChar.ToString() + Path.DirectorySeparatorChar.ToString();
                 normalized = normalized.Replace(doubleSeparator, Path.DirectorySeparatorChar.ToString());
@@ -2190,7 +2180,6 @@ private bool IsMatchingDirectory(string path, string candidate)
                 return false;
             }
 
-
             /// <summary>
             /// Searches the candidates array for one that matches path
             /// </summary>
@@ -2326,7 +2315,7 @@ private static void MatchDriver(string filespec, string[] excludeFilespecs, stri
                     int timesFound = 0;
                     foreach (string file in normalizedFiles)
                     {
-                        if (String.Compare(file, matchingFile, StringComparison.OrdinalIgnoreCase) == 0)
+                        if (String.Equals(file, matchingFile, StringComparison.OrdinalIgnoreCase))
                         {
                             ++timesFound;
                         }
@@ -2345,7 +2334,7 @@ private static void MatchDriver(string filespec, string[] excludeFilespecs, stri
                     int timesFound = 0;
                     foreach (string file in normalizedFiles)
                     {
-                        if (String.Compare(file, nonmatchingFile, StringComparison.OrdinalIgnoreCase) == 0)
+                        if (String.Equals(file, nonmatchingFile, StringComparison.OrdinalIgnoreCase))
                         {
                             ++timesFound;
                         }
@@ -2358,8 +2347,6 @@ private static void MatchDriver(string filespec, string[] excludeFilespecs, stri
             Assert.Equal(0, mockFileSystem.FileHits3); // "At least one file that was marked untouchable was referenced."
         }
 
-
-
         /// <summary>
         /// Simulate GetFileSystemEntries
         /// </summary>
@@ -2377,7 +2364,6 @@ private static ImmutableArray<string> GetFileSystemEntriesLoopBack(FileMatcher.F
 
         private static FileMatcher loopBackFileMatcher = new FileMatcher(FileSystems.Default, GetFileSystemEntriesLoopBack);
 
-
         private static void ValidateSplitFileSpec
             (
             string filespec,
@@ -2558,6 +2544,14 @@ public FileSystemAdapter(MockFileSystem mockFileSystem)
                 _mockFileSystem = mockFileSystem;
             }
 
+            public TextReader ReadFile(string path) => throw new NotImplementedException();
+
+            public Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share) => throw new NotImplementedException();
+
+            public string ReadFileAllText(string path) => throw new NotImplementedException();
+
+            public byte[] ReadFileAllBytes(string path) => throw new NotImplementedException();
+
             public IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
             {
                 return FileSystems.Default.EnumerateFiles(path, searchPattern, searchOption);
@@ -2573,6 +2567,10 @@ public IEnumerable<string> EnumerateFileSystemEntries(string path, string search
                 return FileSystems.Default.EnumerateFileSystemEntries(path, searchPattern, searchOption);
             }
 
+            public FileAttributes GetAttributes(string path) => throw new NotImplementedException();
+
+            public DateTime GetLastWriteTimeUtc(string path) => throw new NotImplementedException();
+
             public bool DirectoryExists(string path)
             {
                 return _mockFileSystem.DirectoryExists(path);
diff --git a/src/Shared/UnitTests/FileUtilities_Tests.cs b/src/Shared/UnitTests/FileUtilities_Tests.cs
index b9b730401aa..43e2aa4c725 100644
--- a/src/Shared/UnitTests/FileUtilities_Tests.cs
+++ b/src/Shared/UnitTests/FileUtilities_Tests.cs
@@ -273,7 +273,6 @@ public void HasExtension_WhenInvalidFileName_ThrowsArgumentException()
             Assert.Throws<ArgumentException>(() =>
             {
                 FileUtilities.HasExtension("|/", new[] { ".exe" });
-
             });
         }
 
diff --git a/src/Shared/UnitTests/ImmutableDictionary_Tests.cs b/src/Shared/UnitTests/ImmutableDictionary_Tests.cs
new file mode 100644
index 00000000000..e30a8cc75d1
--- /dev/null
+++ b/src/Shared/UnitTests/ImmutableDictionary_Tests.cs
@@ -0,0 +1,258 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+// We don't automatically run these tests against the BCL implementation of ImmutableDictionary as it would require dual-compiling
+// this file. When making changes to this test, though, it is recommended to run them manually by uncommenting the following line.
+// This helps ensure that the real thing has the same behavior that we expect in our implementation.
+//#define _TEST_BCL_IMMUTABLE_DICTIONARY
+
+extern alias MSBuildTaskHost;
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+
+using Shouldly;
+using Xunit;
+
+#if _TEST_BCL_IMMUTABLE_DICTIONARY
+using ImmutableDictionary = System.Collections.Immutable.ImmutableDictionary<string, string>;
+#else
+using ImmutableDictionary = MSBuildTaskHost::System.Collections.Immutable.ImmutableDictionary<string, string>;
+#endif
+
+namespace Microsoft.Build.UnitTests
+{
+    public class ImmutableDictionary_Tests
+    {
+        private readonly ImmutableDictionary _emptyDict = ImmutableDictionary.Empty;
+
+        [Fact]
+        public void SimplesBoolPropertiesReturnExpectedValues()
+        {
+            ((IDictionary)_emptyDict).IsFixedSize.ShouldBeTrue();
+            ((IDictionary)_emptyDict).IsReadOnly.ShouldBeTrue();
+            ((IDictionary)_emptyDict).IsSynchronized.ShouldBeTrue();
+        }
+
+        [Fact]
+        public void CountReturnsExpectedValue()
+        {
+            _emptyDict.Count.ShouldBe(0);
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+            dict.Count.ShouldBe(1);
+            dict = dict.SetItem("Key2", "Value2");
+            dict.Count.ShouldBe(2);
+            dict = dict.Clear();
+            dict.Count.ShouldBe(0);
+        }
+
+        [Fact]
+        public void IndexerReturnsPreviouslySetItem()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+            dict["Key1"].ShouldBe("Value1");
+            ((IDictionary)dict)["Key1"].ShouldBe("Value1");
+            ((IDictionary<string, string>)dict)["Key1"].ShouldBe("Value1");
+        }
+
+        [Fact]
+        public void IndexerThrowsForItemNotPreviouslySet()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+            Should.Throw<KeyNotFoundException>(() => _ = dict["Key2"]);
+            Should.Throw<KeyNotFoundException>(() => _ = ((IDictionary)dict)["Key2"]);
+            Should.Throw<KeyNotFoundException>(() => _ = ((IDictionary<string, string>)dict)["Key2"]);
+        }
+
+        [Fact]
+        public void ContainsReturnsTrueForPeviouslySetItem()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+            dict.Contains(new KeyValuePair<string, string>("Key1", "Value1")).ShouldBeTrue();
+            dict.ContainsKey("Key1").ShouldBeTrue();
+            ((IDictionary)dict).Contains("Key1").ShouldBeTrue();
+        }
+
+        [Fact]
+        public void ContainsReturnsFalseForItemNotPeviouslySet()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+            dict.Contains(new KeyValuePair<string, string>("Key2", "Value2")).ShouldBeFalse();
+            dict.ContainsKey("Key2").ShouldBeFalse();
+            ((IDictionary)dict).Contains("Key2").ShouldBeFalse();
+        }
+
+        [Fact]
+        public void EnumeratorEnumeratesItems()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+
+            IEnumerator<KeyValuePair<string, string>> enumerator1 = dict.GetEnumerator();
+            int i = 0;
+            while (enumerator1.MoveNext())
+            {
+                i++;
+                enumerator1.Current.Key.ShouldBe("Key1");
+                enumerator1.Current.Value.ShouldBe("Value1");
+            }
+            i.ShouldBe(dict.Count);
+
+            IDictionaryEnumerator enumerator2 = ((IDictionary)dict).GetEnumerator();
+            i = 0;
+            while (enumerator2.MoveNext())
+            {
+                i++;
+                enumerator2.Key.ShouldBe("Key1");
+                enumerator2.Value.ShouldBe("Value1");
+            }
+            i.ShouldBe(dict.Count);
+
+            IEnumerator enumerator3 = ((IEnumerable)dict).GetEnumerator();
+            i = 0;
+            while (enumerator3.MoveNext())
+            {
+                i++;
+                KeyValuePair<string, string> entry = (KeyValuePair<string, string>)enumerator3.Current;
+                entry.Key.ShouldBe("Key1");
+                entry.Value.ShouldBe("Value1");
+            }
+            i.ShouldBe(dict.Count);
+        }
+
+        [Fact]
+        public void CopyToCopiesItemsToArray()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+
+            KeyValuePair<string, string>[] array1 = new KeyValuePair<string, string>[1];
+            ((ICollection<KeyValuePair<string, string>>)dict).CopyTo(array1, 0);
+            array1[0].Key.ShouldBe("Key1");
+            array1[0].Value.ShouldBe("Value1");
+
+            array1 = new KeyValuePair<string, string>[2];
+            ((ICollection<KeyValuePair<string, string>>)dict).CopyTo(array1, 1);
+            array1[1].Key.ShouldBe("Key1");
+            array1[1].Value.ShouldBe("Value1");
+
+            DictionaryEntry[] array2 = new DictionaryEntry[1];
+            ((ICollection)dict).CopyTo(array2, 0);
+            array2[0].Key.ShouldBe("Key1");
+            array2[0].Value.ShouldBe("Value1");
+
+            array2 = new DictionaryEntry[2];
+            ((ICollection)dict).CopyTo(array2, 1);
+            array2[1].Key.ShouldBe("Key1");
+            array2[1].Value.ShouldBe("Value1");
+        }
+
+        [Fact]
+        public void CopyToThrowsOnInvalidInput()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+
+            Should.Throw<ArgumentNullException>(() => ((ICollection<KeyValuePair<string, string>>)dict).CopyTo(null, 0));
+            Should.Throw<ArgumentNullException>(() => ((ICollection)dict).CopyTo(null, 0));
+
+            KeyValuePair<string, string>[] array1 = new KeyValuePair<string, string>[1];
+            DictionaryEntry[] array2 = new DictionaryEntry[1];
+            Should.Throw<ArgumentOutOfRangeException>(() => ((ICollection<KeyValuePair<string, string>>)dict).CopyTo(array1, -1));
+            Should.Throw<ArgumentOutOfRangeException>(() => ((ICollection)dict).CopyTo(array1, -1));
+
+            Should.Throw<ArgumentException>(() => ((ICollection<KeyValuePair<string, string>>)dict).CopyTo(array1, 1));
+            Should.Throw<ArgumentException>(() => ((ICollection)dict).CopyTo(array1, 1));
+        }
+
+        [Fact]
+        public void KeysReturnsKeys()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+
+            ICollection<string> keys1 = ((IDictionary<string, string>)dict).Keys;
+            keys1.ShouldBe(new string[] { "Key1" });
+
+            ICollection keys2 = ((IDictionary)dict).Keys;
+            keys2.ShouldBe(new string[] { "Key1" });
+        }
+
+        [Fact]
+        public void ValuesReturnsValues()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+
+            ICollection<string> values1 = ((IDictionary<string, string>)dict).Values;
+            values1.ShouldBe(new string[] { "Value1" });
+
+            ICollection values2 = ((IDictionary)dict).Values;
+            values2.ShouldBe(new string[] { "Value1" });
+        }
+
+        [Fact]
+        public void SetItemReturnsNewInstanceAfterAdding()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+            dict.ShouldNotBeSameAs(_emptyDict);
+        }
+
+        [Fact]
+        public void SetItemReturnsNewInstanceAfterUpdating()
+        {
+            ImmutableDictionary dict1 = _emptyDict.SetItem("Key1", "Value1");
+            ImmutableDictionary dict2 = dict1.SetItem("Key1", "Value2");
+            dict2.ShouldNotBeSameAs(dict1);
+        }
+
+        [Fact]
+        public void SetItemReturnsSameInstanceWhenItemAlreadyExists()
+        {
+            ImmutableDictionary dict1 = _emptyDict.SetItem("Key1", "Value1");
+            ImmutableDictionary dict2 = dict1.SetItem("Key1", "Value1");
+            dict2.ShouldBeSameAs(dict1);
+        }
+
+        [Fact]
+        public void RemoveReturnsNewInstanceAfterDeleting()
+        {
+            ImmutableDictionary dict1 = _emptyDict.SetItem("Key1", "Value1");
+            ImmutableDictionary dict2 = dict1.Remove("Key1");
+            dict2.ShouldNotBeSameAs(dict1);
+        }
+
+        [Fact]
+        public void RemoveReturnsSameInstanceWhenItemDoesNotExist()
+        {
+            ImmutableDictionary dict1 = _emptyDict.SetItem("Key1", "Value1");
+            ImmutableDictionary dict2 = dict1.Remove("Key2");
+            dict2.ShouldBeSameAs(dict1);
+        }
+
+        [Fact]
+        public void ClearReturnsNewInstance()
+        {
+            ImmutableDictionary dict1 = _emptyDict.SetItem("Key1", "Value1");
+            ImmutableDictionary dict2 = dict1.Clear();
+            dict2.ShouldNotBeSameAs(dict1);
+        }
+
+        [Fact]
+        public void WithComparersCreatesNewInstanceWithSpecifiedKeyComparer()
+        {
+            ImmutableDictionary dict1 = _emptyDict.SetItem("Key1", "Value1");
+            ImmutableDictionary dict2 = dict1.WithComparers(StringComparer.OrdinalIgnoreCase);
+            dict2["KEY1"].ShouldBe("Value1");
+        }
+
+        [Fact]
+        public void AddRangeAddsAllItems()
+        {
+            ImmutableDictionary dict = _emptyDict.AddRange(new KeyValuePair<string, string>[]
+            {
+                new KeyValuePair<string, string>("Key1", "Value1"),
+                new KeyValuePair<string, string>("Key2", "Value2")
+            });
+            dict.Count.ShouldBe(2);
+            dict["Key1"].ShouldBe("Value1");
+            dict["Key2"].ShouldBe("Value2");
+        }
+    }
+}
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index b7b47a4e20e..6c62d8044f4 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -3,16 +3,19 @@
 
 using System;
 using System.Collections;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
 using System.Runtime.InteropServices;
 using System.Text;
+using System.Threading;
 using System.Xml;
 
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
+using Microsoft.Build.FileSystem;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
 using Microsoft.Build.Logging;
@@ -70,7 +73,6 @@ internal static string MSBuildAssemblyVersion
             }
         }
 
-
         /// <summary>
         /// Helper method to tell us whether a particular metadata name is an MSBuild well-known metadata
         /// (e.g., "RelativeDir", "FullPath", etc.)
@@ -354,7 +356,7 @@ internal static void AssertItemsMatch(string expectedItemsString, ITaskItem[] ac
                         // If the items are expected to be in the same order, then the expected item
                         // should always be found at index zero, because we remove items from the expected
                         // list as we find them.
-                        if ((expectedItemIndex != 0) && (orderOfItemsShouldMatch))
+                        if ((expectedItemIndex != 0) && orderOfItemsShouldMatch)
                         {
                             outOfOrder = true;
                         }
@@ -431,7 +433,6 @@ internal static void AssertItemHasMetadata(Dictionary<string, string> expected,
             foreach (var key in expected.Keys)
             {
                 item.GetMetadataValue(key).ShouldBe(expected[key]);
-
             }
         }
 
@@ -778,7 +779,6 @@ string newExpectedProjectContents
             Assert.Equal(newExpectedProjectContents, newActualProjectContents); // "Project XML does not match expected XML.  See 'Standard Out' tab for details."
         }
 
-
         private static string s_tempProjectDir;
 
         /// <summary>
@@ -1045,11 +1045,11 @@ internal static string[] GetTempFiles(int number, DateTime lastWriteTime)
         /// <summary>
         /// Get items of item type "i" with using the item xml fragment passed in
         /// </summary>
-        internal static IList<ProjectItem> GetItemsFromFragment(string fragment, bool allItems = false)
+        internal static IList<ProjectItem> GetItemsFromFragment(string fragment, bool allItems = false, bool ignoreCondition = false)
         {
             string content = FormatProjectContentsWithItemGroupFragment(fragment);
 
-            IList<ProjectItem> items = GetItems(content, allItems);
+            IList<ProjectItem> items = GetItems(content, allItems, ignoreCondition);
             return items;
         }
 
@@ -1061,11 +1061,14 @@ internal static IList<ProjectItem> GetItemsFromFragment(string fragment, bool al
         /// <summary>
         /// Get the items of type "i" in the project provided
         /// </summary>
-        internal static IList<ProjectItem> GetItems(string content, bool allItems = false)
+        internal static IList<ProjectItem> GetItems(string content, bool allItems = false, bool ignoreCondition = false)
         {
             var projectXml = ProjectRootElement.Create(XmlReader.Create(new StringReader(CleanupFileContents(content))));
             Project project = new Project(projectXml);
-            IList<ProjectItem> item = Helpers.MakeList(allItems ? project.Items : project.GetItems("i"));
+            IList<ProjectItem> item = Helpers.MakeList(
+                ignoreCondition ?
+                (allItems ? project.ItemsIgnoringCondition : project.GetItemsIgnoringCondition("i")) :
+                (allItems ? project.Items : project.GetItems("i")));
 
             return item;
         }
@@ -1351,7 +1354,7 @@ public static BuildResult BuildProjectFileUsingBuildManager(string projectFile,
         {
             using (var buildManager = new BuildManager())
             {
-                parameters = parameters ?? new BuildParameters();
+                parameters ??= new BuildParameters();
 
                 if (logger != null)
                 {
@@ -1560,7 +1563,7 @@ internal static TransientTestFile CreateProjectFile(
             
             foreach (var defaultTarget in (defaultTargets ?? string.Empty).Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
             {
-                sb.Append($"<Target Name='{defaultTarget}'/>");
+                sb.Append("<Target Name='").Append(defaultTarget).Append("'/>");
             }
 
             sb.Append(extraContent ?? string.Empty);
@@ -1607,7 +1610,7 @@ internal static ProjectGraph CreateProjectGraph(
             IEnumerable<int> entryPoints = null,
             ProjectCollection projectCollection = null)
         {
-            createProjectFile = createProjectFile ?? CreateProjectFile;
+            createProjectFile ??= CreateProjectFile;
 
             var nodes = new Dictionary<int, (bool IsRoot, string ProjectPath)>();
 
@@ -1656,7 +1659,7 @@ bool IsRoot(int node)
             {
                 foreach (var nodeDependencies in dependencyEdges)
                 {
-                    if (nodeDependencies.Value != null && nodeDependencies.Value.Contains(node))
+                    if (nodeDependencies.Value?.Contains(node) == true)
                     {
                         return false;
                     }
@@ -1842,8 +1845,6 @@ internal static string GetSleepCommandTemplate()
                     : "sleep {0}";
         }
 
-
-
         /// <summary>
         /// Break the provided string into an array, on newlines
         /// </summary>
@@ -1898,7 +1899,6 @@ internal class BuildManagerSession : IDisposable
 
             public MockLogger Logger { get; set; }
 
-
             public BuildManagerSession(
                 TestEnvironment env,
                 BuildParameters buildParametersPrototype = null,
@@ -1942,5 +1942,133 @@ public void Dispose()
                 _buildManager.Dispose();
             }
         }
+
+        internal class LoggingFileSystem : MSBuildFileSystemBase
+        {
+            private readonly IFileSystem _wrappingFileSystem;
+            private int _fileSystemCalls;
+
+            public int FileSystemCalls => _fileSystemCalls;
+
+            public ConcurrentDictionary<string, int> ExistenceChecks { get; } = new ConcurrentDictionary<string, int>();
+
+            public LoggingFileSystem(IFileSystem wrappingFileSystem = null)
+            {
+                _wrappingFileSystem = wrappingFileSystem ?? FileSystems.Default;
+            }
+
+            public override TextReader ReadFile(string path)
+            {
+                IncrementCalls(ref _fileSystemCalls);
+
+                return _wrappingFileSystem.ReadFile(path);
+            }
+
+            public override Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share)
+            {
+                IncrementCalls(ref _fileSystemCalls);
+
+                return _wrappingFileSystem.GetFileStream(path, mode, access, share);
+            }
+
+            public override string ReadFileAllText(string path)
+            {
+                IncrementCalls(ref _fileSystemCalls);
+
+                return _wrappingFileSystem.ReadFileAllText(path);
+            }
+
+            public override byte[] ReadFileAllBytes(string path)
+            {
+                IncrementCalls(ref _fileSystemCalls);
+
+                return _wrappingFileSystem.ReadFileAllBytes(path);
+            }
+
+            public override IEnumerable<string> EnumerateFiles(
+                string path,
+                string searchPattern = "*",
+                SearchOption searchOption = SearchOption.TopDirectoryOnly
+            )
+            {
+                IncrementCalls(ref _fileSystemCalls);
+
+                return _wrappingFileSystem.EnumerateFiles(path, searchPattern, searchOption);
+            }
+
+            public override IEnumerable<string> EnumerateDirectories(
+                string path,
+                string searchPattern = "*",
+                SearchOption searchOption = SearchOption.TopDirectoryOnly
+            )
+            {
+                IncrementCalls(ref _fileSystemCalls);
+
+                return _wrappingFileSystem.EnumerateDirectories(path, searchPattern, searchOption);
+            }
+
+            public override IEnumerable<string> EnumerateFileSystemEntries(
+                string path,
+                string searchPattern = "*",
+                SearchOption searchOption = SearchOption.TopDirectoryOnly
+            )
+            {
+                IncrementCalls(ref _fileSystemCalls);
+
+                return _wrappingFileSystem.EnumerateFileSystemEntries(path, searchPattern, searchOption);
+            }
+
+            public override FileAttributes GetAttributes(string path)
+            {
+                IncrementCalls(ref _fileSystemCalls);
+
+                return _wrappingFileSystem.GetAttributes(path);
+            }
+
+            public override DateTime GetLastWriteTimeUtc(string path)
+            {
+                IncrementCalls(ref _fileSystemCalls);
+
+                return _wrappingFileSystem.GetLastWriteTimeUtc(path);
+            }
+
+            public override bool DirectoryExists(string path)
+            {
+                IncrementCalls(ref _fileSystemCalls);
+                IncrementExistenceChecks(path);
+
+                return _wrappingFileSystem.DirectoryExists(path);
+            }
+
+            public override bool FileExists(string path)
+            {
+                IncrementCalls(ref _fileSystemCalls);
+                IncrementExistenceChecks(path);
+
+                return _wrappingFileSystem.FileExists(path);
+            }
+
+            private int _directoryEntryExistsCalls;
+            public int DirectoryEntryExistsCalls => _directoryEntryExistsCalls;
+
+            public override bool FileOrDirectoryExists(string path)
+            {
+                IncrementCalls(ref _fileSystemCalls);
+                IncrementCalls(ref _directoryEntryExistsCalls);
+                IncrementExistenceChecks(path);
+
+                return _wrappingFileSystem.DirectoryEntryExists(path);
+            }
+
+            private void IncrementCalls(ref int incremented)
+            {
+                Interlocked.Increment(ref incremented);
+            }
+
+            private void IncrementExistenceChecks(string path)
+            {
+                ExistenceChecks.AddOrUpdate(path, p => 1, (p, c) => c + 1);
+            }
+        }
     }
 }
diff --git a/src/Shared/UnitTests/ResourceUtilities_Tests.cs b/src/Shared/UnitTests/ResourceUtilities_Tests.cs
index 8fbc9589e8c..69b5dcb7f57 100644
--- a/src/Shared/UnitTests/ResourceUtilities_Tests.cs
+++ b/src/Shared/UnitTests/ResourceUtilities_Tests.cs
@@ -23,61 +23,51 @@ public void ExtractMSBuildCode()
             Assert.Equal("This is a message.", messageOnly);
 
             // no whitespace between colon and message is ok
-            code = null;
             messageOnly = ResourceUtilities.ExtractMessageCode(true /* msbuild code only */, "MSB7007:This is a message.", out code);
             Assert.Equal("MSB7007", code);
             Assert.Equal("This is a message.", messageOnly);
 
             // whitespace before code and after colon is ok
-            code = null;
             messageOnly = ResourceUtilities.ExtractMessageCode(true /* msbuild code only */, "  MSB7007:   This is a message.", out code);
             Assert.Equal("MSB7007", code);
             Assert.Equal("This is a message.", messageOnly);
 
             // whitespace between code and colon is not ok
-            code = null;
             messageOnly = ResourceUtilities.ExtractMessageCode(true /* msbuild code only */, "MSB7007 : This is a message.", out code);
             Assert.Null(code);
             Assert.Equal("MSB7007 : This is a message.", messageOnly);
 
             // whitespace in code is not ok
-            code = null;
             messageOnly = ResourceUtilities.ExtractMessageCode(true /* msbuild code only */, "MSB 7007: This is a message.", out code);
             Assert.Null(code);
             Assert.Equal("MSB 7007: This is a message.", messageOnly);
 
             // code with less than 4 digits is not ok
-            code = null;
             messageOnly = ResourceUtilities.ExtractMessageCode(true /* msbuild code only */, "MSB007: This is a message.", out code);
             Assert.Null(code);
             Assert.Equal("MSB007: This is a message.", messageOnly);
 
             // code without digits is not ok
-            code = null;
             messageOnly = ResourceUtilities.ExtractMessageCode(true /* msbuild code only */, "MSB: This is a message.", out code);
             Assert.Null(code);
             Assert.Equal("MSB: This is a message.", messageOnly);
 
             // code without MSB prefix is not ok
-            code = null;
             messageOnly = ResourceUtilities.ExtractMessageCode(true /* msbuild code only */, "1001: This is a message.", out code);
             Assert.Null(code);
             Assert.Equal("1001: This is a message.", messageOnly);
 
             // digits before MSB prefix is not ok
-            code = null;
             messageOnly = ResourceUtilities.ExtractMessageCode(true /* msbuild code only */, "7001MSB: This is a message.", out code);
             Assert.Null(code);
             Assert.Equal("7001MSB: This is a message.", messageOnly);
 
             // mixing letters and digits is not ok
-            code = null;
             messageOnly = ResourceUtilities.ExtractMessageCode(true /* msbuild code only */, "MSB564B: This is a message.", out code);
             Assert.Null(code);
             Assert.Equal("MSB564B: This is a message.", messageOnly);
 
             // lowercase code is not ok
-            code = null;
             messageOnly = ResourceUtilities.ExtractMessageCode(true /* msbuild code only */, "msb1001: This is a message.", out code);
             Assert.Null(code);
             Assert.Equal("msb1001: This is a message.", messageOnly);
diff --git a/src/Shared/UnitTests/TestData/GlobbingTestData.cs b/src/Shared/UnitTests/TestData/GlobbingTestData.cs
index 4d7418086c6..a0fe1f04247 100644
--- a/src/Shared/UnitTests/TestData/GlobbingTestData.cs
+++ b/src/Shared/UnitTests/TestData/GlobbingTestData.cs
@@ -5,7 +5,6 @@
 
 namespace Microsoft.Build.Engine.UnitTests.Globbing
 {
-    
     public static class GlobbingTestData
     {
         public static IEnumerable<object[]> IncludesAndExcludesWithWildcardsTestData
diff --git a/src/Shared/UnitTests/TypeLoader_Tests.cs b/src/Shared/UnitTests/TypeLoader_Tests.cs
index c186aa064d0..1e123fc26f0 100644
--- a/src/Shared/UnitTests/TypeLoader_Tests.cs
+++ b/src/Shared/UnitTests/TypeLoader_Tests.cs
@@ -288,16 +288,16 @@ private static Type FirstPublicDesiredType(Func<Type, object, bool> filter, stri
 
         private static bool IsLoggerClass(Type type, object unused)
         {
-            return (type.IsClass &&
+            return type.IsClass &&
                 !type.IsAbstract &&
-                (type.GetInterface("ILogger") != null));
+                (type.GetInterface("ILogger") != null);
         }
 
         private static bool IsForwardingLoggerClass(Type type, object unused)
         {
-            return (type.IsClass &&
+            return type.IsClass &&
                 !type.IsAbstract &&
-                (type.GetInterface("IForwardingLogger") != null));
+                (type.GetInterface("IForwardingLogger") != null);
         }
 #endif
     }
diff --git a/src/Shared/UnitTests/XmakeAttributes_Tests.cs b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
index 986b4c288a4..8ceeede623d 100644
--- a/src/Shared/UnitTests/XmakeAttributes_Tests.cs
+++ b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
@@ -60,8 +60,7 @@ public void TestRuntimeValuesMatch()
         [Fact]
         public void TestMergeRuntimeValues()
         {
-            string mergedRuntime = null;
-
+            string mergedRuntime;
             Assert.True(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.currentRuntime, out mergedRuntime));
             Assert.Equal(XMakeAttributes.MSBuildRuntimeValues.clr4, mergedRuntime);
 
@@ -99,11 +98,10 @@ public void TestArchitectureValuesMatch()
         [Fact]
         public void TestMergeArchitectureValues()
         {
-            string mergedArchitecture = null;
-
             string currentArchitecture = EnvironmentUtilities.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x64 : XMakeAttributes.MSBuildArchitectureValues.x86;
             string notCurrentArchitecture = EnvironmentUtilities.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x86 : XMakeAttributes.MSBuildArchitectureValues.x64;
 
+            string mergedArchitecture;
             Assert.True(XMakeAttributes.TryMergeArchitectureValues(XMakeAttributes.MSBuildArchitectureValues.any, XMakeAttributes.MSBuildArchitectureValues.currentArchitecture, out mergedArchitecture));
             Assert.Equal(currentArchitecture, mergedArchitecture);
 
diff --git a/src/Shared/VersionUtilities.cs b/src/Shared/VersionUtilities.cs
index 565ceadeb34..020cee0f7f1 100644
--- a/src/Shared/VersionUtilities.cs
+++ b/src/Shared/VersionUtilities.cs
@@ -67,8 +67,6 @@ internal static SortedDictionary<Version, List<string>> GatherVersionStrings(Ver
         /// <param name="throwException">Should we use Parse to TryParse (parse means we throw an exception, tryparse means we will not).</param>
         internal static Version ConvertToVersion(string version, bool throwException)
         {
-            Version result = null;
-
             if (version.Length > 0 && (version[0] == 'v' || version[0] == 'V'))
             {
                 version = version.Substring(1);
@@ -82,6 +80,7 @@ internal static Version ConvertToVersion(string version, bool throwException)
                 version += ".0";
             }
 
+            Version result;
             if (throwException)
             {
                 result = Version.Parse(version);
diff --git a/src/Shared/VisualStudioLocationHelper.cs b/src/Shared/VisualStudioLocationHelper.cs
index 35792d610fa..b3f5bcb2487 100644
--- a/src/Shared/VisualStudioLocationHelper.cs
+++ b/src/Shared/VisualStudioLocationHelper.cs
@@ -85,7 +85,6 @@ private static ISetupConfiguration GetQuery()
                 // Try to CoCreate the class object.
                 return new SetupConfiguration();
             }
-
             catch (COMException ex) when (ex.ErrorCode == REGDB_E_CLASSNOTREG)
             {
                 // Try to get the class object using app-local call.
diff --git a/src/Shared/WeakStringCache.Concurrent.cs b/src/Shared/WeakStringCache.Concurrent.cs
index bf9c6ed8ca3..bd30282b614 100644
--- a/src/Shared/WeakStringCache.Concurrent.cs
+++ b/src/Shared/WeakStringCache.Concurrent.cs
@@ -26,6 +26,7 @@ public WeakStringCache()
         /// adds the resulting string to the cache, and returns it, setting cacheHit to false.
         /// </summary>
         /// <param name="internable">The internable describing the string we're looking for.</param>
+        /// <param name="cacheHit">true if match found in cache, false otherwise.</param>
         /// <returns>A string matching the given internable.</returns>
         /// <remarks>
         /// This method performs two operations on the underlying ConcurrentDictionary on both cache hit and cache miss.
diff --git a/src/Shared/XmlUtilities.cs b/src/Shared/XmlUtilities.cs
index 103570c4d6e..4670c3805ae 100644
--- a/src/Shared/XmlUtilities.cs
+++ b/src/Shared/XmlUtilities.cs
@@ -49,16 +49,15 @@ internal static XmlElementWithLocation RenameXmlElement(XmlElementWithLocation o
                 newElement.AppendChild(oldElement.FirstChild);
             }
 
-            if (oldElement.ParentNode != null)
-            {
+               
+            
                 // Add the new element in the same place the old element was.
-                oldElement.ParentNode.ReplaceChild(newElement, oldElement);
-            }
+                oldElement.ParentNode?.ReplaceChild(newElement, oldElement);
+            
 
             return newElement;
         }
 
-
         /// <summary>
         /// Verifies that a name is valid for the name of an item, property, or piece of metadata.
         /// If it isn't, throws an ArgumentException indicating the invalid character.
@@ -70,7 +69,7 @@ internal static XmlElementWithLocation RenameXmlElement(XmlElementWithLocation o
         /// <param name="name">name to validate</param>
         internal static void VerifyThrowArgumentValidElementName(string name)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
 
             int firstInvalidCharLocation = LocateFirstInvalidElementNameCharacter(name);
 
@@ -89,7 +88,7 @@ internal static void VerifyThrowArgumentValidElementName(string name)
         /// </remarks>
         internal static void VerifyThrowProjectValidElementName(string name, IElementLocation location)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
             int firstInvalidCharLocation = LocateFirstInvalidElementNameCharacter(name);
 
             if (-1 != firstInvalidCharLocation)
@@ -126,7 +125,7 @@ internal static void VerifyThrowProjectValidElementName(XmlElementWithLocation e
         /// <returns>true, if name is valid</returns>
         internal static bool IsValidElementName(string name)
         {
-            return (LocateFirstInvalidElementNameCharacter(name) == -1);
+            return LocateFirstInvalidElementNameCharacter(name) == -1;
         }
 
         /// <summary>
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index f5f4477693e..8593245ce4f 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -92,8 +92,6 @@ public Miscellaneous(ITestOutputHelper output) : base(output)
         {
         }
 
-
-
         /// <summary>
         /// Let us have the following dependency structure
         ///
@@ -142,8 +140,6 @@ public void CopyLocalDependenciesWhenParentReferenceInGacFalseAllParentsInGac()
             t.ResolvedFiles[0].GetMetadata("CopyLocal").ShouldBe("false", StringCompareShould.IgnoreCase);
         }
 
-
-
         [Fact]
         public void ValidateFrameworkNameError()
         {
@@ -445,7 +441,6 @@ public void Basic()
             assemblyNames[0].SetMetadata(ItemMetadataNames.winMDFile, "NOPE");
             assemblyNames[0].SetMetadata(ItemMetadataNames.winmdImplmentationFile, "IMPL");
 
-
             assemblyNames[1].SetMetadata("Private", "true");
             assemblyNames[2].SetMetadata("Private", "false");
             assemblyNames[4].SetMetadata("Private", "false");
@@ -476,7 +471,7 @@ public void Basic()
             // Process the primary items.
             foreach (ITaskItem item in t.ResolvedFiles)
             {
-                if (String.Compare(item.ItemSpec, Path.Combine(s_myVersion20Path, "System.XML.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(item.ItemSpec, Path.Combine(s_myVersion20Path, "System.XML.dll"), StringComparison.OrdinalIgnoreCase))
                 {
                     systemXmlFound = true;
                     item.GetMetadata("DestinationSubDirectory").ShouldBe("", StringCompareShould.IgnoreCase);
@@ -535,13 +530,13 @@ public void Basic()
                     item.GetMetadata("CopyLocal").ShouldBe("true", StringCompareShould.IgnoreCase);
                     item.GetMetadata("FusionName").ShouldBe("MyMissingAssembly", StringCompareShould.IgnoreCase);
                 }
-                else if (String.Compare(item.ItemSpec, Path.Combine(s_myProjectPath, "System.Xml.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+                else if (String.Equals(item.ItemSpec, Path.Combine(s_myProjectPath, "System.Xml.dll"), StringComparison.OrdinalIgnoreCase))
                 {
                     // The version of System.Xml.dll in C:\MyProject is an older version.
                     // This version is not a match. When want the current version which should have been in a different directory.
                     Assert.True(false, "Wrong version of System.Xml.dll matched--version was wrong");
                 }
-                else if (String.Compare(item.ItemSpec, Path.Combine(s_myProjectPath, "System.Data.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+                else if (String.Equals(item.ItemSpec, Path.Combine(s_myProjectPath, "System.Data.dll"), StringComparison.OrdinalIgnoreCase))
                 {
                     // The version of System.Data.dll in C:\MyProject has an incorrect PKT
                     // This version is not a match.
@@ -592,14 +587,14 @@ public void Basic()
             // Process the satellites.
             foreach (ITaskItem item in t.SatelliteFiles)
             {
-                if (String.Compare(item.ItemSpec, Path.Combine(s_myVersion20Path, "en", "System.XML.resources.pdb"), StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(item.ItemSpec, Path.Combine(s_myVersion20Path, "en", "System.XML.resources.pdb"), StringComparison.OrdinalIgnoreCase))
                 {
                     enSatellitePdbFound = true;
                     Assert.Empty(item.GetMetadata(ItemMetadataNames.imageRuntime));
                     Assert.Empty(item.GetMetadata(ItemMetadataNames.winMDFile));
                     Assert.Empty(item.GetMetadata(ItemMetadataNames.winmdImplmentationFile));
                 }
-                else if (String.Compare(item.ItemSpec, Path.Combine(s_myVersion20Path, "en-GB", "System.XML.resources.pdb"), StringComparison.OrdinalIgnoreCase) == 0)
+                else if (String.Equals(item.ItemSpec, Path.Combine(s_myVersion20Path, "en-GB", "System.XML.resources.pdb"), StringComparison.OrdinalIgnoreCase))
                 {
                     engbSatellitePdbFound = true;
                     Assert.Empty(item.GetMetadata(ItemMetadataNames.imageRuntime));
@@ -729,7 +724,6 @@ public void EmbedInteropTypes()
                 { "false", "false", "false", "false" }     // MyDontCopyLocalAssembly
             };
 
-
             int assembliesCount = (int)EmbedInteropTypes_Indices.EndMarker;
 
             // now let's verify our data structures are all set up correctly
@@ -807,7 +801,6 @@ public void NOPForEmptyItemLists()
             Assert.True(succeeded); // "Expected success."
         }
 
-
         /// <summary>
         /// If no related file extensions are input to RAR, .pdb and .xml should be used
         /// by default.
@@ -1021,7 +1014,6 @@ public void SimulateCreateProjectAgainstWhidbeyWithTrailingSlash()
             SimulateCreateProjectAgainstWhidbeyInternal(ToolLocationHelper.GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version45) + @"\");
         }
 
-
         /// <summary>
         /// Invalid candidate assembly files should not crash
         /// </summary>
@@ -1168,7 +1160,6 @@ public void NonExistentReference()
             Assert.Equal(0, String.Compare(ToolLocationHelper.GetPathToDotNetFrameworkFile("System.Xml.dll", TargetDotNetFrameworkVersion.Version45), t.ResolvedFiles[0].ItemSpec, StringComparison.OrdinalIgnoreCase));
         }
 
-
         /// <summary>
         /// Consider this situation.
         ///
@@ -2027,9 +2018,9 @@ public void GatherVersions10DotNet()
 
             Assert.NotNull(returnedVersions);
             Assert.Equal(3, returnedVersions.Count);
-            Assert.Equal("v1.0", ((string)returnedVersions[0].RegistryKey));
-            Assert.Equal("v1", ((string)returnedVersions[1].RegistryKey));
-            Assert.Equal("v00001.0", ((string)returnedVersions[2].RegistryKey));
+            Assert.Equal("v1.0", (string)returnedVersions[0].RegistryKey);
+            Assert.Equal("v1", (string)returnedVersions[1].RegistryKey);
+            Assert.Equal("v00001.0", (string)returnedVersions[2].RegistryKey);
         }
 
         [Fact]
@@ -2039,10 +2030,10 @@ public void GatherVersions20DotNet()
 
             Assert.NotNull(returnedVersions);
             Assert.Equal(4, returnedVersions.Count);
-            Assert.Equal("v2.0.50727", ((string)returnedVersions[0].RegistryKey));
-            Assert.Equal("v1.0", ((string)returnedVersions[1].RegistryKey));
-            Assert.Equal("v1", ((string)returnedVersions[2].RegistryKey));
-            Assert.Equal("v00001.0", ((string)returnedVersions[3].RegistryKey));
+            Assert.Equal("v2.0.50727", (string)returnedVersions[0].RegistryKey);
+            Assert.Equal("v1.0", (string)returnedVersions[1].RegistryKey);
+            Assert.Equal("v1", (string)returnedVersions[2].RegistryKey);
+            Assert.Equal("v00001.0", (string)returnedVersions[3].RegistryKey);
         }
 
         [Fact]
@@ -2053,13 +2044,13 @@ public void GatherVersions30DotNet()
             Assert.NotNull(returnedVersions);
             Assert.Equal(7, returnedVersions.Count);
 
-            Assert.Equal("v3.0", ((string)returnedVersions[0].RegistryKey));
-            Assert.Equal("v2.0.50727", ((string)returnedVersions[1].RegistryKey));
-            Assert.Equal("v1.0", ((string)returnedVersions[2].RegistryKey));
-            Assert.Equal("v1", ((string)returnedVersions[3].RegistryKey));
-            Assert.Equal("v00001.0", ((string)returnedVersions[4].RegistryKey));
-            Assert.Equal("v3.0SP1", ((string)returnedVersions[5].RegistryKey));
-            Assert.Equal("v3.0 BAZ", ((string)returnedVersions[6].RegistryKey));
+            Assert.Equal("v3.0", (string)returnedVersions[0].RegistryKey);
+            Assert.Equal("v2.0.50727", (string)returnedVersions[1].RegistryKey);
+            Assert.Equal("v1.0", (string)returnedVersions[2].RegistryKey);
+            Assert.Equal("v1", (string)returnedVersions[3].RegistryKey);
+            Assert.Equal("v00001.0", (string)returnedVersions[4].RegistryKey);
+            Assert.Equal("v3.0SP1", (string)returnedVersions[5].RegistryKey);
+            Assert.Equal("v3.0 BAZ", (string)returnedVersions[6].RegistryKey);
         }
 
         [Fact]
@@ -2070,33 +2061,33 @@ public void GatherVersionsVDotNet()
             Assert.NotNull(returnedVersions);
             Assert.Equal(27, returnedVersions.Count);
 
-            Assert.Equal("v5.0", ((string)returnedVersions[0].RegistryKey));
-            Assert.Equal("v5", ((string)returnedVersions[1].RegistryKey));
-            Assert.Equal("v4.0001.0", ((string)returnedVersions[2].RegistryKey));
-            Assert.Equal("v4.1", ((string)returnedVersions[3].RegistryKey));
-            Assert.Equal("v4.0.255.87", ((string)returnedVersions[4].RegistryKey));
-            Assert.Equal("v4.0.255", ((string)returnedVersions[5].RegistryKey));
-            Assert.Equal("v4.0.0000", ((string)returnedVersions[6].RegistryKey));
-            Assert.Equal("v4.0.9999", ((string)returnedVersions[7].RegistryKey));
-            Assert.Equal("v4.0.2116.87", ((string)returnedVersions[8].RegistryKey));
-            Assert.Equal("v4.0.2116", ((string)returnedVersions[9].RegistryKey));
-            Assert.Equal("v4.0", ((string)returnedVersions[10].RegistryKey));
-            Assert.Equal("v3.5", ((string)returnedVersions[11].RegistryKey));
-            Assert.Equal("v3.0", ((string)returnedVersions[12].RegistryKey));
-            Assert.Equal("v2.0.50727", ((string)returnedVersions[13].RegistryKey));
-            Assert.Equal("v1.0", ((string)returnedVersions[14].RegistryKey));
-            Assert.Equal("v1", ((string)returnedVersions[15].RegistryKey));
-            Assert.Equal("v00001.0", ((string)returnedVersions[16].RegistryKey));
-            Assert.Equal("v3.0SP1", ((string)returnedVersions[17].RegistryKey));
-            Assert.Equal("v3.0 BAZ", ((string)returnedVersions[18].RegistryKey));
-            Assert.Equal("v3.5.0.x86chk", ((string)returnedVersions[19].RegistryKey));
-            Assert.Equal("v3.5.1.x86chk", ((string)returnedVersions[20].RegistryKey));
-            Assert.Equal("v3.5.256.x86chk", ((string)returnedVersions[21].RegistryKey));
-            Assert.Equal("v", ((string)returnedVersions[22].RegistryKey));
-            Assert.Equal("V3.5.0.0.0", ((string)returnedVersions[23].RegistryKey));
-            Assert.Equal("V3..", ((string)returnedVersions[24].RegistryKey));
-            Assert.Equal("V-1", ((string)returnedVersions[25].RegistryKey));
-            Assert.Equal("v9999999999999999", ((string)returnedVersions[26].RegistryKey), true);
+            Assert.Equal("v5.0", (string)returnedVersions[0].RegistryKey);
+            Assert.Equal("v5", (string)returnedVersions[1].RegistryKey);
+            Assert.Equal("v4.0001.0", (string)returnedVersions[2].RegistryKey);
+            Assert.Equal("v4.1", (string)returnedVersions[3].RegistryKey);
+            Assert.Equal("v4.0.255.87", (string)returnedVersions[4].RegistryKey);
+            Assert.Equal("v4.0.255", (string)returnedVersions[5].RegistryKey);
+            Assert.Equal("v4.0.0000", (string)returnedVersions[6].RegistryKey);
+            Assert.Equal("v4.0.9999", (string)returnedVersions[7].RegistryKey);
+            Assert.Equal("v4.0.2116.87", (string)returnedVersions[8].RegistryKey);
+            Assert.Equal("v4.0.2116", (string)returnedVersions[9].RegistryKey);
+            Assert.Equal("v4.0", (string)returnedVersions[10].RegistryKey);
+            Assert.Equal("v3.5", (string)returnedVersions[11].RegistryKey);
+            Assert.Equal("v3.0", (string)returnedVersions[12].RegistryKey);
+            Assert.Equal("v2.0.50727", (string)returnedVersions[13].RegistryKey);
+            Assert.Equal("v1.0", (string)returnedVersions[14].RegistryKey);
+            Assert.Equal("v1", (string)returnedVersions[15].RegistryKey);
+            Assert.Equal("v00001.0", (string)returnedVersions[16].RegistryKey);
+            Assert.Equal("v3.0SP1", (string)returnedVersions[17].RegistryKey);
+            Assert.Equal("v3.0 BAZ", (string)returnedVersions[18].RegistryKey);
+            Assert.Equal("v3.5.0.x86chk", (string)returnedVersions[19].RegistryKey);
+            Assert.Equal("v3.5.1.x86chk", (string)returnedVersions[20].RegistryKey);
+            Assert.Equal("v3.5.256.x86chk", (string)returnedVersions[21].RegistryKey);
+            Assert.Equal("v", (string)returnedVersions[22].RegistryKey);
+            Assert.Equal("V3.5.0.0.0", (string)returnedVersions[23].RegistryKey);
+            Assert.Equal("V3..", (string)returnedVersions[24].RegistryKey);
+            Assert.Equal("V-1", (string)returnedVersions[25].RegistryKey);
+            Assert.Equal("v9999999999999999", (string)returnedVersions[26].RegistryKey, true);
         }
 
         [Fact]
@@ -2106,16 +2097,16 @@ public void GatherVersions35DotNet()
 
             Assert.NotNull(returnedVersions);
             Assert.Equal(10, returnedVersions.Count);
-            Assert.Equal("v3.5", ((string)returnedVersions[0].RegistryKey));
-            Assert.Equal("v3.0", ((string)returnedVersions[1].RegistryKey));
-            Assert.Equal("v2.0.50727", ((string)returnedVersions[2].RegistryKey));
-            Assert.Equal("v1.0", ((string)returnedVersions[3].RegistryKey));
-            Assert.Equal("v1", ((string)returnedVersions[4].RegistryKey));
-            Assert.Equal("v00001.0", ((string)returnedVersions[5].RegistryKey));
-            Assert.Equal("v3.5.0.x86chk", ((string)returnedVersions[6].RegistryKey));
-            Assert.Equal("v3.5.1.x86chk", ((string)returnedVersions[7].RegistryKey));
-            Assert.Equal("v3.5.256.x86chk", ((string)returnedVersions[8].RegistryKey));
-            Assert.Equal("V3.5.0.0.0", ((string)returnedVersions[9].RegistryKey));
+            Assert.Equal("v3.5", (string)returnedVersions[0].RegistryKey);
+            Assert.Equal("v3.0", (string)returnedVersions[1].RegistryKey);
+            Assert.Equal("v2.0.50727", (string)returnedVersions[2].RegistryKey);
+            Assert.Equal("v1.0", (string)returnedVersions[3].RegistryKey);
+            Assert.Equal("v1", (string)returnedVersions[4].RegistryKey);
+            Assert.Equal("v00001.0", (string)returnedVersions[5].RegistryKey);
+            Assert.Equal("v3.5.0.x86chk", (string)returnedVersions[6].RegistryKey);
+            Assert.Equal("v3.5.1.x86chk", (string)returnedVersions[7].RegistryKey);
+            Assert.Equal("v3.5.256.x86chk", (string)returnedVersions[8].RegistryKey);
+            Assert.Equal("V3.5.0.0.0", (string)returnedVersions[9].RegistryKey);
         }
 
         [Fact]
@@ -2125,16 +2116,16 @@ public void GatherVersions40DotNet()
 
             Assert.NotNull(returnedVersions);
             Assert.Equal(10, returnedVersions.Count);
-            Assert.Equal("v4.0.9999", ((string)returnedVersions[0].RegistryKey));
-            Assert.Equal("v4.0.2116.87", ((string)returnedVersions[1].RegistryKey));
-            Assert.Equal("v4.0.2116", ((string)returnedVersions[2].RegistryKey));
-            Assert.Equal("v4.0", ((string)returnedVersions[3].RegistryKey));
-            Assert.Equal("v3.5", ((string)returnedVersions[4].RegistryKey));
-            Assert.Equal("v3.0", ((string)returnedVersions[5].RegistryKey));
-            Assert.Equal("v2.0.50727", ((string)returnedVersions[6].RegistryKey));
-            Assert.Equal("v1.0", ((string)returnedVersions[7].RegistryKey));
-            Assert.Equal("v1", ((string)returnedVersions[8].RegistryKey));
-            Assert.Equal("v00001.0", ((string)returnedVersions[9].RegistryKey));
+            Assert.Equal("v4.0.9999", (string)returnedVersions[0].RegistryKey);
+            Assert.Equal("v4.0.2116.87", (string)returnedVersions[1].RegistryKey);
+            Assert.Equal("v4.0.2116", (string)returnedVersions[2].RegistryKey);
+            Assert.Equal("v4.0", (string)returnedVersions[3].RegistryKey);
+            Assert.Equal("v3.5", (string)returnedVersions[4].RegistryKey);
+            Assert.Equal("v3.0", (string)returnedVersions[5].RegistryKey);
+            Assert.Equal("v2.0.50727", (string)returnedVersions[6].RegistryKey);
+            Assert.Equal("v1.0", (string)returnedVersions[7].RegistryKey);
+            Assert.Equal("v1", (string)returnedVersions[8].RegistryKey);
+            Assert.Equal("v00001.0", (string)returnedVersions[9].RegistryKey);
         }
 
         [Fact]
@@ -2144,17 +2135,17 @@ public void GatherVersions400DotNet()
 
             Assert.NotNull(returnedVersions);
             Assert.Equal(11, returnedVersions.Count);
-            Assert.Equal("v4.0.0000", ((string)returnedVersions[0].RegistryKey));
-            Assert.Equal("v4.0.9999", ((string)returnedVersions[1].RegistryKey));
-            Assert.Equal("v4.0.2116.87", ((string)returnedVersions[2].RegistryKey));
-            Assert.Equal("v4.0.2116", ((string)returnedVersions[3].RegistryKey));
-            Assert.Equal("v4.0", ((string)returnedVersions[4].RegistryKey));
-            Assert.Equal("v3.5", ((string)returnedVersions[5].RegistryKey));
-            Assert.Equal("v3.0", ((string)returnedVersions[6].RegistryKey));
-            Assert.Equal("v2.0.50727", ((string)returnedVersions[7].RegistryKey));
-            Assert.Equal("v1.0", ((string)returnedVersions[8].RegistryKey));
-            Assert.Equal("v1", ((string)returnedVersions[9].RegistryKey));
-            Assert.Equal("v00001.0", ((string)returnedVersions[10].RegistryKey));
+            Assert.Equal("v4.0.0000", (string)returnedVersions[0].RegistryKey);
+            Assert.Equal("v4.0.9999", (string)returnedVersions[1].RegistryKey);
+            Assert.Equal("v4.0.2116.87", (string)returnedVersions[2].RegistryKey);
+            Assert.Equal("v4.0.2116", (string)returnedVersions[3].RegistryKey);
+            Assert.Equal("v4.0", (string)returnedVersions[4].RegistryKey);
+            Assert.Equal("v3.5", (string)returnedVersions[5].RegistryKey);
+            Assert.Equal("v3.0", (string)returnedVersions[6].RegistryKey);
+            Assert.Equal("v2.0.50727", (string)returnedVersions[7].RegistryKey);
+            Assert.Equal("v1.0", (string)returnedVersions[8].RegistryKey);
+            Assert.Equal("v1", (string)returnedVersions[9].RegistryKey);
+            Assert.Equal("v00001.0", (string)returnedVersions[10].RegistryKey);
         }
 
         [Fact]
@@ -2165,20 +2156,20 @@ public void GatherVersions41DotNet()
             Assert.NotNull(returnedVersions);
             Assert.Equal(14, returnedVersions.Count);
 
-            Assert.Equal("v4.1", ((string)returnedVersions[0].RegistryKey));
-            Assert.Equal("v4.0.255.87", ((string)returnedVersions[1].RegistryKey));
-            Assert.Equal("v4.0.255", ((string)returnedVersions[2].RegistryKey));
-            Assert.Equal("v4.0.0000", ((string)returnedVersions[3].RegistryKey));
-            Assert.Equal("v4.0.9999", ((string)returnedVersions[4].RegistryKey));
-            Assert.Equal("v4.0.2116.87", ((string)returnedVersions[5].RegistryKey));
-            Assert.Equal("v4.0.2116", ((string)returnedVersions[6].RegistryKey));
-            Assert.Equal("v4.0", ((string)returnedVersions[7].RegistryKey));
-            Assert.Equal("v3.5", ((string)returnedVersions[8].RegistryKey));
-            Assert.Equal("v3.0", ((string)returnedVersions[9].RegistryKey));
-            Assert.Equal("v2.0.50727", ((string)returnedVersions[10].RegistryKey));
-            Assert.Equal("v1.0", ((string)returnedVersions[11].RegistryKey));
-            Assert.Equal("v1", ((string)returnedVersions[12].RegistryKey));
-            Assert.Equal("v00001.0", ((string)returnedVersions[13].RegistryKey));
+            Assert.Equal("v4.1", (string)returnedVersions[0].RegistryKey);
+            Assert.Equal("v4.0.255.87", (string)returnedVersions[1].RegistryKey);
+            Assert.Equal("v4.0.255", (string)returnedVersions[2].RegistryKey);
+            Assert.Equal("v4.0.0000", (string)returnedVersions[3].RegistryKey);
+            Assert.Equal("v4.0.9999", (string)returnedVersions[4].RegistryKey);
+            Assert.Equal("v4.0.2116.87", (string)returnedVersions[5].RegistryKey);
+            Assert.Equal("v4.0.2116", (string)returnedVersions[6].RegistryKey);
+            Assert.Equal("v4.0", (string)returnedVersions[7].RegistryKey);
+            Assert.Equal("v3.5", (string)returnedVersions[8].RegistryKey);
+            Assert.Equal("v3.0", (string)returnedVersions[9].RegistryKey);
+            Assert.Equal("v2.0.50727", (string)returnedVersions[10].RegistryKey);
+            Assert.Equal("v1.0", (string)returnedVersions[11].RegistryKey);
+            Assert.Equal("v1", (string)returnedVersions[12].RegistryKey);
+            Assert.Equal("v00001.0", (string)returnedVersions[13].RegistryKey);
         }
 
         [Fact]
@@ -2189,24 +2180,23 @@ public void GatherVersions410DotNet()
             Assert.NotNull(returnedVersions);
             Assert.Equal(15, returnedVersions.Count);
 
-            Assert.Equal("v4.0001.0", ((string)returnedVersions[0].RegistryKey));
-            Assert.Equal("v4.1", ((string)returnedVersions[1].RegistryKey));
-            Assert.Equal("v4.0.255.87", ((string)returnedVersions[2].RegistryKey));
-            Assert.Equal("v4.0.255", ((string)returnedVersions[3].RegistryKey));
-            Assert.Equal("v4.0.0000", ((string)returnedVersions[4].RegistryKey));
-            Assert.Equal("v4.0.9999", ((string)returnedVersions[5].RegistryKey));
-            Assert.Equal("v4.0.2116.87", ((string)returnedVersions[6].RegistryKey));
-            Assert.Equal("v4.0.2116", ((string)returnedVersions[7].RegistryKey));
-            Assert.Equal("v4.0", ((string)returnedVersions[8].RegistryKey));
-            Assert.Equal("v3.5", ((string)returnedVersions[9].RegistryKey));
-            Assert.Equal("v3.0", ((string)returnedVersions[10].RegistryKey));
-            Assert.Equal("v2.0.50727", ((string)returnedVersions[11].RegistryKey));
-            Assert.Equal("v1.0", ((string)returnedVersions[12].RegistryKey));
-            Assert.Equal("v1", ((string)returnedVersions[13].RegistryKey));
-            Assert.Equal("v00001.0", ((string)returnedVersions[14].RegistryKey));
+            Assert.Equal("v4.0001.0", (string)returnedVersions[0].RegistryKey);
+            Assert.Equal("v4.1", (string)returnedVersions[1].RegistryKey);
+            Assert.Equal("v4.0.255.87", (string)returnedVersions[2].RegistryKey);
+            Assert.Equal("v4.0.255", (string)returnedVersions[3].RegistryKey);
+            Assert.Equal("v4.0.0000", (string)returnedVersions[4].RegistryKey);
+            Assert.Equal("v4.0.9999", (string)returnedVersions[5].RegistryKey);
+            Assert.Equal("v4.0.2116.87", (string)returnedVersions[6].RegistryKey);
+            Assert.Equal("v4.0.2116", (string)returnedVersions[7].RegistryKey);
+            Assert.Equal("v4.0", (string)returnedVersions[8].RegistryKey);
+            Assert.Equal("v3.5", (string)returnedVersions[9].RegistryKey);
+            Assert.Equal("v3.0", (string)returnedVersions[10].RegistryKey);
+            Assert.Equal("v2.0.50727", (string)returnedVersions[11].RegistryKey);
+            Assert.Equal("v1.0", (string)returnedVersions[12].RegistryKey);
+            Assert.Equal("v1", (string)returnedVersions[13].RegistryKey);
+            Assert.Equal("v00001.0", (string)returnedVersions[14].RegistryKey);
         }
 
-
         [Fact]
         public void GatherVersions40255DotNet()
         {
@@ -2214,19 +2204,19 @@ public void GatherVersions40255DotNet()
 
             Assert.NotNull(returnedVersions);
             Assert.Equal(13, returnedVersions.Count);
-            Assert.Equal("v4.0.255.87", ((string)returnedVersions[0].RegistryKey));
-            Assert.Equal("v4.0.255", ((string)returnedVersions[1].RegistryKey));
-            Assert.Equal("v4.0.0000", ((string)returnedVersions[2].RegistryKey));
-            Assert.Equal("v4.0.9999", ((string)returnedVersions[3].RegistryKey));
-            Assert.Equal("v4.0.2116.87", ((string)returnedVersions[4].RegistryKey));
-            Assert.Equal("v4.0.2116", ((string)returnedVersions[5].RegistryKey));
-            Assert.Equal("v4.0", ((string)returnedVersions[6].RegistryKey));
-            Assert.Equal("v3.5", ((string)returnedVersions[7].RegistryKey));
-            Assert.Equal("v3.0", ((string)returnedVersions[8].RegistryKey));
-            Assert.Equal("v2.0.50727", ((string)returnedVersions[9].RegistryKey));
-            Assert.Equal("v1.0", ((string)returnedVersions[10].RegistryKey));
-            Assert.Equal("v1", ((string)returnedVersions[11].RegistryKey));
-            Assert.Equal("v00001.0", ((string)returnedVersions[12].RegistryKey));
+            Assert.Equal("v4.0.255.87", (string)returnedVersions[0].RegistryKey);
+            Assert.Equal("v4.0.255", (string)returnedVersions[1].RegistryKey);
+            Assert.Equal("v4.0.0000", (string)returnedVersions[2].RegistryKey);
+            Assert.Equal("v4.0.9999", (string)returnedVersions[3].RegistryKey);
+            Assert.Equal("v4.0.2116.87", (string)returnedVersions[4].RegistryKey);
+            Assert.Equal("v4.0.2116", (string)returnedVersions[5].RegistryKey);
+            Assert.Equal("v4.0", (string)returnedVersions[6].RegistryKey);
+            Assert.Equal("v3.5", (string)returnedVersions[7].RegistryKey);
+            Assert.Equal("v3.0", (string)returnedVersions[8].RegistryKey);
+            Assert.Equal("v2.0.50727", (string)returnedVersions[9].RegistryKey);
+            Assert.Equal("v1.0", (string)returnedVersions[10].RegistryKey);
+            Assert.Equal("v1", (string)returnedVersions[11].RegistryKey);
+            Assert.Equal("v00001.0", (string)returnedVersions[12].RegistryKey);
         }
 
         [Fact]
@@ -2237,23 +2227,23 @@ public void GatherVersions5DotNet()
             Assert.NotNull(returnedVersions);
             Assert.Equal(17, returnedVersions.Count);
 
-            Assert.Equal("v5.0", ((string)returnedVersions[0].RegistryKey));
-            Assert.Equal("v5", ((string)returnedVersions[1].RegistryKey));
-            Assert.Equal("v4.0001.0", ((string)returnedVersions[2].RegistryKey));
-            Assert.Equal("v4.1", ((string)returnedVersions[3].RegistryKey));
-            Assert.Equal("v4.0.255.87", ((string)returnedVersions[4].RegistryKey));
-            Assert.Equal("v4.0.255", ((string)returnedVersions[5].RegistryKey));
-            Assert.Equal("v4.0.0000", ((string)returnedVersions[6].RegistryKey));
-            Assert.Equal("v4.0.9999", ((string)returnedVersions[7].RegistryKey));
-            Assert.Equal("v4.0.2116.87", ((string)returnedVersions[8].RegistryKey));
-            Assert.Equal("v4.0.2116", ((string)returnedVersions[9].RegistryKey));
-            Assert.Equal("v4.0", ((string)returnedVersions[10].RegistryKey));
-            Assert.Equal("v3.5", ((string)returnedVersions[11].RegistryKey));
-            Assert.Equal("v3.0", ((string)returnedVersions[12].RegistryKey));
-            Assert.Equal("v2.0.50727", ((string)returnedVersions[13].RegistryKey));
-            Assert.Equal("v1.0", ((string)returnedVersions[14].RegistryKey));
-            Assert.Equal("v1", ((string)returnedVersions[15].RegistryKey));
-            Assert.Equal("v00001.0", ((string)returnedVersions[16].RegistryKey));
+            Assert.Equal("v5.0", (string)returnedVersions[0].RegistryKey);
+            Assert.Equal("v5", (string)returnedVersions[1].RegistryKey);
+            Assert.Equal("v4.0001.0", (string)returnedVersions[2].RegistryKey);
+            Assert.Equal("v4.1", (string)returnedVersions[3].RegistryKey);
+            Assert.Equal("v4.0.255.87", (string)returnedVersions[4].RegistryKey);
+            Assert.Equal("v4.0.255", (string)returnedVersions[5].RegistryKey);
+            Assert.Equal("v4.0.0000", (string)returnedVersions[6].RegistryKey);
+            Assert.Equal("v4.0.9999", (string)returnedVersions[7].RegistryKey);
+            Assert.Equal("v4.0.2116.87", (string)returnedVersions[8].RegistryKey);
+            Assert.Equal("v4.0.2116", (string)returnedVersions[9].RegistryKey);
+            Assert.Equal("v4.0", (string)returnedVersions[10].RegistryKey);
+            Assert.Equal("v3.5", (string)returnedVersions[11].RegistryKey);
+            Assert.Equal("v3.0", (string)returnedVersions[12].RegistryKey);
+            Assert.Equal("v2.0.50727", (string)returnedVersions[13].RegistryKey);
+            Assert.Equal("v1.0", (string)returnedVersions[14].RegistryKey);
+            Assert.Equal("v1", (string)returnedVersions[15].RegistryKey);
+            Assert.Equal("v00001.0", (string)returnedVersions[16].RegistryKey);
         }
 
         [Fact]
@@ -2264,23 +2254,23 @@ public void GatherVersionsv5DotNet()
             Assert.NotNull(returnedVersions);
             Assert.Equal(17, returnedVersions.Count);
 
-            Assert.Equal("v5.0", ((string)returnedVersions[0].RegistryKey));
-            Assert.Equal("v5", ((string)returnedVersions[1].RegistryKey));
-            Assert.Equal("v4.0001.0", ((string)returnedVersions[2].RegistryKey));
-            Assert.Equal("v4.1", ((string)returnedVersions[3].RegistryKey));
-            Assert.Equal("v4.0.255.87", ((string)returnedVersions[4].RegistryKey));
-            Assert.Equal("v4.0.255", ((string)returnedVersions[5].RegistryKey));
-            Assert.Equal("v4.0.0000", ((string)returnedVersions[6].RegistryKey));
-            Assert.Equal("v4.0.9999", ((string)returnedVersions[7].RegistryKey));
-            Assert.Equal("v4.0.2116.87", ((string)returnedVersions[8].RegistryKey));
-            Assert.Equal("v4.0.2116", ((string)returnedVersions[9].RegistryKey));
-            Assert.Equal("v4.0", ((string)returnedVersions[10].RegistryKey));
-            Assert.Equal("v3.5", ((string)returnedVersions[11].RegistryKey));
-            Assert.Equal("v3.0", ((string)returnedVersions[12].RegistryKey));
-            Assert.Equal("v2.0.50727", ((string)returnedVersions[13].RegistryKey));
-            Assert.Equal("v1.0", ((string)returnedVersions[14].RegistryKey));
-            Assert.Equal("v1", ((string)returnedVersions[15].RegistryKey));
-            Assert.Equal("v00001.0", ((string)returnedVersions[16].RegistryKey));
+            Assert.Equal("v5.0", (string)returnedVersions[0].RegistryKey);
+            Assert.Equal("v5", (string)returnedVersions[1].RegistryKey);
+            Assert.Equal("v4.0001.0", (string)returnedVersions[2].RegistryKey);
+            Assert.Equal("v4.1", (string)returnedVersions[3].RegistryKey);
+            Assert.Equal("v4.0.255.87", (string)returnedVersions[4].RegistryKey);
+            Assert.Equal("v4.0.255", (string)returnedVersions[5].RegistryKey);
+            Assert.Equal("v4.0.0000", (string)returnedVersions[6].RegistryKey);
+            Assert.Equal("v4.0.9999", (string)returnedVersions[7].RegistryKey);
+            Assert.Equal("v4.0.2116.87", (string)returnedVersions[8].RegistryKey);
+            Assert.Equal("v4.0.2116", (string)returnedVersions[9].RegistryKey);
+            Assert.Equal("v4.0", (string)returnedVersions[10].RegistryKey);
+            Assert.Equal("v3.5", (string)returnedVersions[11].RegistryKey);
+            Assert.Equal("v3.0", (string)returnedVersions[12].RegistryKey);
+            Assert.Equal("v2.0.50727", (string)returnedVersions[13].RegistryKey);
+            Assert.Equal("v1.0", (string)returnedVersions[14].RegistryKey);
+            Assert.Equal("v1", (string)returnedVersions[15].RegistryKey);
+            Assert.Equal("v00001.0", (string)returnedVersions[16].RegistryKey);
         }
 
         [Fact]
@@ -2291,7 +2281,7 @@ public void GatherVersions35x86chkDotNet()
             Assert.NotNull(returnedVersions);
             Assert.Single(returnedVersions);
 
-            Assert.Equal("v3.5.0.x86chk", ((string)returnedVersions[0].RegistryKey));
+            Assert.Equal("v3.5.0.x86chk", (string)returnedVersions[0].RegistryKey);
         }
 #endif
 
@@ -2371,7 +2361,6 @@ private void RemoveAssemblyFoldersExTestConditionRegistryKey()
             }
         }
 
-
         /// <summary>
         /// CandidateAssemblyFiles are extra files passed in through the CandidateAssemblyFiles
         /// that should be considered for matching when search paths contains {CandidateAssemblyFiles}
@@ -2393,7 +2382,6 @@ public void CandidateAssemblyFiles()
             Assert.Equal(Path.Combine(s_myVersion20Path, "System.Xml.dll"), t.ResolvedFiles[0].ItemSpec);
         }
 
-
         /// <summary>
         /// Make sure three part version numbers put on the required target framework do not cause a problem.
         /// </summary>
@@ -2861,7 +2849,6 @@ public void DuplicateEntries()
                 Assert.Empty(errorFileNames); // "Expected no Error file names"
                 Assert.Single(remap);
 
-
                 AssemblyRemapping pair = remap.First<AssemblyRemapping>();
                 Assert.Equal("Remapped", pair.To.Name);
                 Assert.False(pair.To.Retargetable);
@@ -2974,7 +2961,6 @@ public void ToElementButNoFrom()
             }
         }
 
-
         /// <summary>
         /// If a relative file name is passed in through the Assemblies parameter and the search paths contains {RawFileName}
         /// then try to resolve directly to that file name and make it a full path.
@@ -3012,7 +2998,6 @@ public void RawFileNameRelative()
             }
         }
 
-
         /// <summary>
         /// If a relative searchPath is passed in through the search path parameter
         /// then try to resolve the file but make sure it is a full name
@@ -3198,7 +3183,6 @@ public void Regress444793()
             );
         }
 
-
         /// <summary>
         /// If a file name is passed in through the Assemblies parameter and the search paths contains {RawFileName}
         /// then try to resolve directly to that file name.
@@ -3698,7 +3682,6 @@ public void ConflictGeneratesMessageReferencingAssemblyName()
             e.AssertLogContainsMessageFromResource(AssemblyResources.GetString, "ResolveAssemblyReference.FoundConflicts", "D");
         }
 
-
         /// <summary>
         /// Consider this dependency chain:
         ///
@@ -3787,7 +3770,6 @@ public void ConflictWithForeVersionPrimary()
             Assert.True(ContainsItem(t.ResolvedDependencyFiles, s_myLibraries_V2_GDllPath));
         }
 
-
         /// <summary>
         /// Consider this dependency chain:
         ///
@@ -4002,7 +3984,6 @@ public void SpecificVersionAbsent()
             Assert.Empty(t.ResolvedFiles);
         }
 
-
         /// <summary>
         /// Unresolved primary references should result in warnings.
         /// </summary>
@@ -4029,7 +4010,6 @@ public void Regress199998()
             Assert.Equal(1, m.Warnings);
         }
 
-
         /// <summary>
         /// In this case,
         /// - A single primary file reference to simple name "A".
@@ -4267,7 +4247,6 @@ public void SimpleNameWithSpecificVersionFalse()
             Assert.True(ContainsItem(t.ResolvedFiles, @"c:\MyStronglyNamed\A.dll")); // "Expected to find assembly, but didn't."
         }
 
-
         /// <summary>
         /// Consider this situation:
         ///
@@ -4303,7 +4282,6 @@ public void IrrelevantAssemblyNameElement()
             Assert.True(ContainsItem(t.ResolvedFiles, s_myLibraries_V1_DDllPath)); // "Expected to find assembly, but didn't."
         }
 
-
         /// <summary>
         /// Regress EVERETT QFE 626
         /// Consider this dependency chain:
@@ -4359,7 +4337,7 @@ public void RegressQFE626()
 
             foreach (ITaskItem item in t.ResolvedDependencyFiles)
             {
-                if (0 == String.Compare(item.ItemSpec, s_myLibraries_V1_E_EDllPath, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(item.ItemSpec, s_myLibraries_V1_E_EDllPath, StringComparison.OrdinalIgnoreCase))
                 {
                     Assert.Equal("false", item.GetMetadata("CopyLocal"));
                 }
@@ -4422,12 +4400,12 @@ public void Regress265054()
 
             foreach (ITaskItem item in t.ResolvedDependencyFiles)
             {
-                if (0 == String.Compare(item.ItemSpec, s_myLibraries_V1_DDllPath, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(item.ItemSpec, s_myLibraries_V1_DDllPath, StringComparison.OrdinalIgnoreCase))
                 {
                     Assert.Equal("false", item.GetMetadata("CopyLocal"));
                 }
 
-                if (0 == String.Compare(item.ItemSpec, s_myLibraries_V1_E_EDllPath, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(item.ItemSpec, s_myLibraries_V1_E_EDllPath, StringComparison.OrdinalIgnoreCase))
                 {
                     Assert.Equal("true", item.GetMetadata("CopyLocal"));
                 }
@@ -4520,13 +4498,10 @@ public void Regress275161_ScatterAssemblies()
 
             Assert.True(ContainsItem(t.ScatterFiles, @"C:\Regress275161\m1.netmodule")); //                 "Expected to find scatter file m1."
 
-
             Assert.True(ContainsItem(t.ScatterFiles, @"C:\Regress275161\m2.netmodule")); //                 "Expected to find scatter file m2."
 
-
             Assert.True(ContainsItem(t.CopyLocalFiles, @"C:\Regress275161\m1.netmodule")); //                 "Expected to find scatter file m1 in CopyLocalFiles."
 
-
             Assert.True(ContainsItem(t.CopyLocalFiles, @"C:\Regress275161\m2.netmodule")); //                 "Expected to find scatter file m2 in CopyLocalFiles."
         }
 
@@ -4669,7 +4644,6 @@ public void Regress313086_Part2_MscorlibAsRawFilename()
             Assert.Single(t.ResolvedFiles);
         }
 
-
         /// <summary>
         /// If a directory path is passed into AssemblyFiles, then we should warn and continue on.
         /// </summary>
@@ -4748,7 +4722,6 @@ public void RelativeAssemblyFiles()
             }
         }
 
-
         /// <summary>
         /// Behave gracefully if a referenced assembly is inaccessible to the user.
         /// </summary>
@@ -4803,7 +4776,6 @@ public void Regress316906_UnauthorizedAccessViolation_PrimaryFileIsInaccessible(
             Assert.Single(t.ResolvedFiles);
         }
 
-
         /// <summary>
         /// Behave gracefully if a referenced assembly is inaccessible to the user.
         /// </summary>
@@ -4821,7 +4793,6 @@ public void Regress316906_UnauthorizedAccessViolation_PrimaryAsRawFileIsInaccess
             };
             t.SearchPaths = new string[] { "{RawFileName}" };
 
-
             Execute(t);
 
             Assert.Equal(1, e.Warnings); // "One warning expected in this scenario."
@@ -4829,8 +4800,6 @@ public void Regress316906_UnauthorizedAccessViolation_PrimaryAsRawFileIsInaccess
             Assert.Empty(t.ResolvedFiles);
         }
 
-
-
         /// <summary>
         /// If there's a SearhPath like {Registry:,,} then still behave nicely.
         /// </summary>
@@ -4903,7 +4872,6 @@ public void Regress276548_AssemblyNameDifferentThanFusionName()
 
             Execute(t);
 
-
             Assert.Equal(0, e.Warnings); // "One warning expected in this scenario."
             Assert.Equal(0, e.Errors); // "No errors expected in this scenario."
             Assert.Single(t.ResolvedFiles);
@@ -4945,13 +4913,11 @@ public void Regress314573_VeryLongPaths()
 
             Execute(t);
 
-
             Assert.Equal(1, e.Warnings); // "One warning expected in this scenario." // Couldn't find dependencies for {HintPathFromItem}-resolved item.
             Assert.Equal(0, e.Errors); // "No errors expected in this scenario."
             Assert.Empty(t.ResolvedFiles);  // This test used to have 1 here. But that was because the mock GetAssemblyName was not accurately throwing an exception for non-existent files.
         }
 
-
         /// <summary>
         /// Need to be robust in the face of assembly names with special characters.
         /// </summary>
@@ -4974,7 +4940,6 @@ public void Regress265003_EscapedCharactersInFusionName()
             t.Assemblies[1].SetMetadata("HintPath", @"c:\MyEscapedName\__'ASP'dw0024ry.dll");
             t.TargetFrameworkDirectories = new string[] { Path.GetDirectoryName(typeof(object).Module.FullyQualifiedName) };
 
-
             t.SearchPaths = new string[]
             {
                 @"{TargetFrameworkDirectory}",
@@ -4984,7 +4949,6 @@ public void Regress265003_EscapedCharactersInFusionName()
 
             Execute(t);
 
-
             Assert.Equal(0, e.Warnings); // "One warning expected in this scenario."
             Assert.Equal(0, e.Errors); // "No errors expected in this scenario."
             Assert.Equal(2, t.ResolvedFiles.Length);
@@ -5023,7 +4987,6 @@ public void Regress284081_UnescapedCharactersInFusionNameWithHintPath()
 
             Execute(t);
 
-
             Assert.Equal(0, e.Warnings); // "No warning expected in this scenario."
             Assert.Equal(0, e.Errors); // "No errors expected in this scenario."
             Assert.Single(t.ResolvedFiles);
@@ -5147,7 +5110,6 @@ public void Regress354669_HintPathWithTrailingSlash()
 
             t.Assemblies[0].SetMetadata("HintPath", @"C:\Regress354669\");
 
-
             t.SearchPaths = new string[]
             {
                 "{RawFileName}",
@@ -5240,7 +5202,6 @@ public void Regress_DogfoodCLRThrowsFileLoadException()
             Execute(t);
         }
 
-
         /// <summary>
         /// There was a bug in which any file mentioned in the InstalledAssemblyTables was automatically
         /// considered to be a file present in the framework directory. This assumption was originally true,
@@ -5312,7 +5273,6 @@ public void InvalidCharsInInstalledAssemblyTable()
                 new TaskItem("SomeAssembly")
             };
 
-
             t.TargetFrameworkDirectories = new string[] { @"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx" };
             t.InstalledAssemblyTables = new TaskItem[] { new TaskItem("asdfasdfasjr390rjfiogatg~~!@@##$%$%%^&**()") };
 
@@ -5349,7 +5309,6 @@ public void Regress435487_FxFileResolvedByHintPathShouldByCopyLocal()
 
             t.Assemblies[0].SetMetadata("HintPath", @"C:\Regress435487\microsoft.build.engine.dll");
 
-
             t.SearchPaths = new string[]
             {
                 @"{HintPathFromItem}",
@@ -5415,7 +5374,6 @@ public void PartialNameMatchingFromRedist()
                 AssemblyNameExtension Av2 = new AssemblyNameExtension(v2);
                 AssemblyNameExtension Av3 = new AssemblyNameExtension(v3);
 
-
                 AssemblyTableInfo assemblyTableInfo = new AssemblyTableInfo(redistFile, "MyFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { assemblyTableInfo });
                 InstalledAssemblies installedAssemblies = new InstalledAssemblies(redistList);
@@ -5611,7 +5569,6 @@ private static string CreateGenericRedistList()
             return tempFile;
         }
 
-
         [Fact]
         public void GetRedistListPathsFromDisk_ThrowsArgumentNullException()
         {
@@ -5661,7 +5618,6 @@ public void RedistListGenerateBlackListEmptyAssemblyInfoWithRedistAssemblies()
                 List<string> whiteListErrorFileNames = new List<string>();
                 Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[0], whiteListErrors, whiteListErrorFileNames);
 
-
                 // Since there were no white list expect the black list to return null
                 Assert.Empty(blackList); // "Expected to have no assemblies in the black list"
             }
@@ -5768,8 +5724,6 @@ public void RedistListNoSubsetListName()
                    "</FileList >";
                 File.WriteAllText(subsetFile, subsetListContents);
 
-
-
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(subsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
@@ -5868,8 +5822,6 @@ public void RedistListDifferentNameToSubSet()
                    "</FileList >";
                 File.WriteAllText(subsetFile, subsetListContents);
 
-
-
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(subsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
@@ -5987,7 +5939,7 @@ public void RedistListNoAssembliesinRedistList()
         [Fact]
         public void RedistListGenerateBlackListGoodListsSubsetIsSubsetOfRedist()
         {
-            string redistFile = CreateGenericRedistList(); ;
+            string redistFile = CreateGenericRedistList(); 
             string goodSubsetFile = FileUtilities.GetTemporaryFile();
             try
             {
@@ -6240,7 +6192,6 @@ public void SubsetListFinderEmptySubsetToSearchFor()
             Assert.Empty(returnArray); // "Expected the array returned to be 0 length"
         }
 
-
         /// <summary>
         /// Verify that the method will not crash if there are empty string array elements
         /// </summary>
@@ -6554,7 +6505,6 @@ public void TestGenerateFrameworkName()
             installedSubSetTable = null;
             Assert.True(String.IsNullOrEmpty(ResolveAssemblyReference.GenerateSubSetName(null, installedSubSetTable)));
 
-
             targetFrameworks = new string[] { "Client", "Framework" };
             installedSubSetTable = new ITaskItem[] { new TaskItem("c:\\foo\\Mouse.xml"), new TaskItem("D:\\foo\\bar\\Man.xml") };
             Assert.Equal("Client, Framework, Mouse, Man", ResolveAssemblyReference.GenerateSubSetName(targetFrameworks, installedSubSetTable));
@@ -6638,7 +6588,6 @@ public void ReferenceTableDependentItemsInBlackList()
             VerifyReferenceTable(referenceTable, mockEngine, engineAssemblyName, dataAssemblyName, sqlclientAssemblyName, xmlAssemblyName, new string[] { warningMessage });
         }
 
-
         /// <summary>
         /// Testing case  enginePrimary -> dataDependencyReference->sqlDependencyReference
         /// and enginePrimary->sqlDependencyReference: sqlDependencyReference is in black list
@@ -6709,7 +6658,6 @@ public void ReferenceTablePrimaryToPrimaryDependencyWithOneInBlackList()
             xmlPrimaryReference.AddSourceItems(enginePrimaryReference.GetSourceItems());
             xmlPrimaryReference.AddDependee(enginePrimaryReference);
 
-
             InitializeMockEngine(out referenceTable, out mockEngine, out rar);
             AddReferencesToReferenceTable(referenceTable, engineAssemblyName, null, null, xmlAssemblyName, enginePrimaryReference, null, null, xmlPrimaryReference);
 
@@ -6753,7 +6701,6 @@ public void ReferenceTablePrimaryToPrimaryToDependencyWithOneInBlackList()
             xmlPrimaryReference.AddSourceItems(enginePrimaryReference.GetSourceItems());
             xmlPrimaryReference.AddDependee(enginePrimaryReference);
 
-
             dataDependencyReference.FullPath = "FullPath";
             dataDependencyReference.MakeDependentAssemblyReference(xmlPrimaryReference);
 
@@ -6762,7 +6709,6 @@ public void ReferenceTablePrimaryToPrimaryToDependencyWithOneInBlackList()
 
             InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { dataAssemblyName }, out blackList);
 
-
             string subsetName = ResolveAssemblyReference.GenerateSubSetName(new string[] { "Client" }, null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, dataAssemblyName.FullName, subsetName);
             string warningMessage2 = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem2.ItemSpec, dataAssemblyName.FullName, subsetName);
@@ -6821,7 +6767,6 @@ public void ReferenceTableDependentItemsInBlackList3()
             VerifyReferenceTable(referenceTable, mockEngine, engineAssemblyName, dataAssemblyName, sqlclientAssemblyName, xmlAssemblyName, new string[] { warningMessage, warningMessage2 });
         }
 
-
         /// <summary>
         /// Testing case  enginePrimary -> dataDependencyReference->sqlDependencyReference
         /// and xmlPrimary->dataDependencyReference: sqlDependencyReference is in black list
@@ -6914,7 +6859,6 @@ public void ReferenceTableDependentItemsInBlackList5()
 
             InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName, dataAssemblyName }, out blackList);
 
-
             string subsetName = ResolveAssemblyReference.GenerateSubSetName(new string[] { "Client" }, null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, sqlclientAssemblyName.FullName, subsetName);
             string warningMessage2 = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, dataAssemblyName.FullName, subsetName);
@@ -6936,7 +6880,6 @@ public void ReferenceTableDependentItemsInBlackList5()
             table.Clear();
         }
 
-
         /// <summary>
         /// Testing case
         /// enginePrimary -> dataDependencyReference   also enginePrimary->sqlDependencyReference   specific version = true on the primary
@@ -7191,7 +7134,6 @@ private void InitializeMockEngine(out ReferenceTable referenceTable, out MockEng
             referenceTable = MakeEmptyReferenceTable(rar.Log);
         }
 
-
         /// <summary>
         ///Initialize the black list and use it to remove references from the reference table
         /// </summary>
@@ -7236,14 +7178,10 @@ private static void GenerateNewReferences(out Reference enginePrimaryReference,
         public void IgnoreDefaultInstalledSubsetTables()
         {
             string redistListPath = CreateGenericRedistList();
-            string subsetListClientPath = string.Empty;
-            string explicitSubsetListPath = string.Empty;
-
             try
             {
-                subsetListClientPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("v3.5\\SubsetList\\Client.xml", _engineOnlySubset);
-                explicitSubsetListPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("v3.5\\SubsetList\\ExplicitList.xml", _xmlOnlySubset);
-
+                string subsetListClientPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("v3.5\\SubsetList\\Client.xml", _engineOnlySubset);
+                string explicitSubsetListPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("v3.5\\SubsetList\\ExplicitList.xml", _xmlOnlySubset);
                 ResolveAssemblyReference t = new ResolveAssemblyReference();
                 t.BuildEngine = new MockEngine(_output);
                 t.Assemblies = new ITaskItem[] { new TaskItem("Microsoft.Build.Engine"), new TaskItem("System.Xml") };
@@ -7477,7 +7415,6 @@ public void ResolveAssemblyReferenceVerifyFullClientName()
             }
         }
 
-
         /// <summary>
         /// This test will verify when the full client name is passed in and it appears in the TargetFrameworkSubsetList, that the
         /// black list is not used.
@@ -7513,7 +7450,6 @@ public void ResolveAssemblyReferenceVerifyFullClientNameWithSubsetTables()
             }
         }
 
-
         /// <summary>
         /// This test will verify when the full client name is passed in and it appears in the TargetFrameworkSubsetList, that the
         /// black list is not used.
@@ -7753,7 +7689,6 @@ public void Regress397129_HandleInvalidDirectoriesAndFiles_Case2()
 
             t.Assemblies[0].SetMetadata("HintPath", @"||invalidpath||");
 
-
             t.SearchPaths = new string[]
             {
                 @"{HintPathFromItem}"
@@ -7815,7 +7750,6 @@ public void Regress393931_AllowAlternateAssemblyExtensions_Case1()
                 new TaskItem("A")
             };
 
-
             t.SearchPaths = new string[]
             {
                 @"C:\Regress393931"
@@ -7848,7 +7782,6 @@ public void Regress393931_AllowAlternateAssemblyExtensions()
                 new TaskItem("A")
             };
 
-
             t.SearchPaths = new string[]
             {
                 @"C:\Regress393931"
@@ -7899,7 +7832,6 @@ public void SGenDependeicies()
             Assert.True(ContainsItem(t.SerializationAssemblyFiles, @"c:\SGenDependeicies\mycomponent2.XmlSerializers.dll")); // "Expected to find serialization assembly, but didn't."
         }
 
-
         /// <summary>
         /// Consider this dependency chain:
         ///
@@ -8048,8 +7980,8 @@ private int RunTargetFrameworkFilteringTest(string projectTargetFramework)
                     mask = 4;
                 }
                 Assert.NotEqual(0, mask); // "Unexpected assembly in resolved list."
-                Assert.Equal(0, (mask & set)); // "Assembly found twice in resolved list."
-                set = set | mask;
+                Assert.Equal(0, mask & set); // "Assembly found twice in resolved list."
+                set |= mask;
             }
             return set;
         }
@@ -8085,8 +8017,7 @@ public void ReverseAssemblyNameExtensionComparer()
         [Trait("Category", "mono-osx-failing")]
         public void TargetFrameworkFiltering()
         {
-            int resultSet = 0;
-            resultSet = RunTargetFrameworkFilteringTest("3.0");
+            int resultSet = RunTargetFrameworkFilteringTest("3.0");
             Assert.Equal(0x3, resultSet); // "Expected assemblies A & B to be found."
 
             resultSet = RunTargetFrameworkFilteringTest("3.5");
@@ -8283,7 +8214,6 @@ public void VerifyAssemblyInRedistListDiffVersion()
             }
         }
 
-
         /// <summary>
         /// Verify when we ask if an assembly is in the redist list we get the right answer.
         /// The public key is significant and should make the match not work
@@ -8386,9 +8316,6 @@ public void VerifyAssemblyInRedistListDiffSimpleName()
         [Fact]
         public void Verifyp2pAndProfile()
         {
-            // Create a generic redist list with system.xml and microsoft.build.engine.
-            string profileRedistList = String.Empty;
-            string fullRedistList = String.Empty;
             string fullFrameworkDirectory = Path.Combine(Path.GetTempPath(), "Verifyp2pAndProfile");
             string targetFrameworkDirectory = Path.Combine(fullFrameworkDirectory, "Profiles", "Client");
 
@@ -8399,6 +8326,9 @@ public void Verifyp2pAndProfile()
 
             try
             {
+                // Create a generic redist list with system.xml and microsoft.build.engine.
+                string profileRedistList;
+                string fullRedistList;
                 GenerateRedistAndProfileXmlLocations(fullRedistListContents, _engineOnlySubset, out profileRedistList, out fullRedistList, fullFrameworkDirectory, targetFrameworkDirectory);
 
                 ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -8434,9 +8364,6 @@ public void Verifyp2pAndProfile()
         [Fact]
         public void Verifyp2pAndProfile2()
         {
-            // Create a generic redist list with system.xml and microsoft.build.engine.
-            string profileRedistList = String.Empty;
-            string fullRedistList = String.Empty;
             string fullFrameworkDirectory = Path.Combine(Path.GetTempPath(), "Verifyp2pAndProfile");
             string targetFrameworkDirectory = Path.Combine(fullFrameworkDirectory, "Profiles", "Client");
 
@@ -8447,6 +8374,9 @@ public void Verifyp2pAndProfile2()
 
             try
             {
+                // Create a generic redist list with system.xml and microsoft.build.engine.
+                string profileRedistList;
+                string fullRedistList;
                 GenerateRedistAndProfileXmlLocations(fullRedistListContents, _engineOnlySubset, out profileRedistList, out fullRedistList, fullFrameworkDirectory, targetFrameworkDirectory);
 
                 ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -8484,13 +8414,13 @@ public void Verifyp2pAndProfile2()
         [Fact]
         public void VerifyClientProfileRedistListAndProfileList()
         {
-            // Create a generic redist list with system.xml and microsoft.build.engine.
-            string profileRedistList = String.Empty;
-            string fullRedistList = String.Empty;
             string fullFrameworkDirectory = Path.Combine(Path.GetTempPath(), "VerifyClientProfileRedistListAndProfileList");
             string targetFrameworkDirectory = Path.Combine(fullFrameworkDirectory, "Profiles", "Client");
             try
             {
+                // Create a generic redist list with system.xml and microsoft.build.engine.
+                string profileRedistList;
+                string fullRedistList;
                 GenerateRedistAndProfileXmlLocations(_fullRedistListContents, _engineOnlySubset, out profileRedistList, out fullRedistList, fullFrameworkDirectory, targetFrameworkDirectory);
 
                 ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -8531,13 +8461,13 @@ public void VerifyClientProfileRedistListAndProfileList()
         [Fact]
         public void VerifyClientProfileRedistListAndProfileList2()
         {
-            // Create a generic redist list with system.xml and microsoft.build.engine.
-            string profileRedistList = String.Empty;
-            string fullRedistList = String.Empty;
             string fullFrameworkDirectory = Path.Combine(Path.GetTempPath(), "VerifyClientProfileRedistListAndProfileList2");
             string targetFrameworkDirectory = Path.Combine(fullFrameworkDirectory, "Profiles", "Client");
             try
             {
+                // Create a generic redist list with system.xml and microsoft.build.engine.
+                string profileRedistList;
+                string fullRedistList;
                 GenerateRedistAndProfileXmlLocations(_fullRedistListContents, _engineOnlySubset, out profileRedistList, out fullRedistList, fullFrameworkDirectory, targetFrameworkDirectory);
 
                 ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -8579,9 +8509,6 @@ public void VerifyClientProfileRedistListAndProfileList2()
         [Fact]
         public void VerifyAssemblyInGacButNotInProfileIsNotResolved()
         {
-            // Create a generic redist list with system.xml and microsoft.build.engine.
-            string profileRedistList = String.Empty;
-            string fullRedistList = String.Empty;
             string fullFrameworkDirectory = Path.Combine(Path.GetTempPath(), "VerifyAssemblyInGacButNotInProfileIsNotResolved");
             string targetFrameworkDirectory = Path.Combine(fullFrameworkDirectory, "Profiles", "Client");
             useFrameworkFileExists = true;
@@ -8592,6 +8519,9 @@ public void VerifyAssemblyInGacButNotInProfileIsNotResolved()
 
             try
             {
+                // Create a generic redist list with system.xml and microsoft.build.engine.
+                string profileRedistList;
+                string fullRedistList;
                 GenerateRedistAndProfileXmlLocations(fullRedistListContents, _engineOnlySubset, out profileRedistList, out fullRedistList, fullFrameworkDirectory, targetFrameworkDirectory);
 
                 ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -8633,9 +8563,6 @@ public void VerifyAssemblyInGacButNotInProfileIsNotResolved()
         [Fact]
         public void VerifyProfileErrorsAreLogged()
         {
-            // Create a generic redist list with system.xml and microsoft.build.engine.
-            string profileRedistList = String.Empty;
-            string fullRedistList = String.Empty;
             string fullFrameworkDirectory = Path.Combine(Path.GetTempPath(), "VerifyProfileErrorsAreLogged");
             string targetFrameworkDirectory = Path.Combine(fullFrameworkDirectory, "Profiles", "Client");
             try
@@ -8646,6 +8573,9 @@ public void VerifyProfileErrorsAreLogged()
                         "File AssemblyName='Microsoft.Build.Engine' Version='2.0.0.0' PublicKeyToken='b03f5f7f11d50a3a' Culture='Neutral' FileVersion='2.0.50727.208' InGAC='true' >" +
                    "";
 
+                // Create a generic redist list with system.xml and microsoft.build.engine.
+                string profileRedistList;
+                string fullRedistList;
                 GenerateRedistAndProfileXmlLocations(fullRedistListContentsErrors, _engineOnlySubset, out profileRedistList, out fullRedistList, fullFrameworkDirectory, targetFrameworkDirectory);
 
                 ResolveAssemblyReference t = new ResolveAssemblyReference();
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Perf.cs b/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
index 91fec5aa1a1..1f35cf0117a 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
@@ -76,7 +76,7 @@ public void DependeeDirectoryIsProbedForDependency()
                 bool succeeded = Execute(t);
 
                 Assert.True(succeeded);
-                ;
+                
                 uniqueFileExists[s_dependsOnNuGet_NWinMdPath].ShouldBe(1);
                 uniqueFileExists[s_dependsOnNuGet_NDllPath].ShouldBe(1);
                 uniqueFileExists[s_dependsOnNuGet_NExePath].ShouldBe(1);
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index 0ec77ad4895..c2b855a00e7 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -322,7 +322,6 @@ internal void StopIOMonitoringAndAssert_Minimal_IOUse(int ioThreshold = 1)
                 }
             }
 
-
             uniqueFileExists = null;
             uniqueGetAssemblyName = null;
         }
@@ -344,7 +343,6 @@ internal void StopIOMonitoringAndAssert_Zero_IOUse()
                 }
             }
 
-
             // Check for zero IO in GetAssemblyName.
             foreach (var entry in uniqueGetAssemblyName)
             {
@@ -644,11 +642,11 @@ internal static string[] GetFiles(string path, string pattern)
             {
                 string baseDir = Path.GetDirectoryName(file);
 
-                if (0 == String.Compare(baseDir, path, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(baseDir, path, StringComparison.OrdinalIgnoreCase))
                 {
                     string fileExtension = Path.GetExtension(file);
 
-                    if (0 == String.Compare(fileExtension, extension, StringComparison.OrdinalIgnoreCase))
+                    if (String.Equals(fileExtension, extension, StringComparison.OrdinalIgnoreCase))
                     {
                         matches.Add(file);
                     }
@@ -711,36 +709,36 @@ private static bool IsWinMDFile(string fullPath, GetAssemblyRuntimeVersion getAs
             imageRuntimeVersion = getAssemblyRuntimeVersion(fullPath);
             isManagedWinMD = false;
 
-            if (String.Compare(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMD\SampleWindowsRuntimeAndCLR.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMD\SampleWindowsRuntimeAndCLR.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 isManagedWinMD = true;
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
@@ -748,7 +746,7 @@ private static bool IsWinMDFile(string fullPath, GetAssemblyRuntimeVersion getAs
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\FakeSDK\WindowsMetadata\SDKWinMD2.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\FakeSDK\WindowsMetadata\SDKWinMD2.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
@@ -760,11 +758,11 @@ private static bool IsWinMDFile(string fullPath, GetAssemblyRuntimeVersion getAs
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\FakeSDK\WindowsMetadata\SDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\FakeSDK\WindowsMetadata\SDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMDLib\LibWithWinmdAndNoDll.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMDLib\LibWithWinmdAndNoDll.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
@@ -838,10 +836,9 @@ internal static bool FileExists(string path)
                 {
                     uniqueFileExists[lowerPath] = 0;
                 }
-                
-                uniqueFileExists[lowerPath] = uniqueFileExists[lowerPath] + 1;
-            }
 
+                uniqueFileExists[lowerPath]++;
+            }
 
             // First, MyMissingAssembly doesn't exist anywhere.
             if (path.IndexOf("MyMissingAssembly") != -1)
@@ -854,16 +851,14 @@ internal static bool FileExists(string path)
                 path = Path.GetFullPath(path);
             }
 
-
             foreach (string file in s_existentFiles)
             {
-                if (0 == String.Compare(path, file, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(path, file, StringComparison.OrdinalIgnoreCase))
                 {
                     return true;
                 }
             }
 
-
             // Everything else doesn't exist.
             return false;
         }
@@ -885,7 +880,7 @@ internal static bool DirectoryExists(string path)
 
             foreach (string dir in existentDirs)
             {
-                if (0 == String.Compare(path, dir, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(path, dir, StringComparison.OrdinalIgnoreCase))
                 {
                     return true;
                 }
@@ -911,7 +906,7 @@ internal static string[] GetDirectories(string path, string pattern)
 
                 return paths;
             }
-            else if (String.Compare(path, @".", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @".", StringComparison.OrdinalIgnoreCase))
             {
                 // Pretend the current directory has a few subfolders.
                 return new string[] {
@@ -929,75 +924,74 @@ internal static string[] GetDirectories(string path, string pattern)
         /// <returns>Image runtime version</returns>
         internal static string GetRuntimeVersion(string path)
         {
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeAndCLR.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeAndCLR.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return "WindowsRuntime 1.0, CLR V2.0.50727";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleClrOnly.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleClrOnly.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return "CLR V2.0.50727";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleBadWindowsRuntime.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleBadWindowsRuntime.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return "Windows Runtime";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeAndOther.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeAndOther.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return "WindowsRuntime 1.0, Other V2.0.50727";
             }
-
-            else if (String.Compare(path, @"C:\DirectoryContainsOnlyDll\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\DirectoryContainsOnlyDll\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return "V2.0.50727";
             }
-            else if (String.Compare(path, @"C:\DirectoryContainsdllAndWinmd\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\DirectoryContainsdllAndWinmd\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return "V2.0.50727";
             }
-            else if (String.Compare(path, @"C:\DirectoryContainsdllAndWinmd\c.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\DirectoryContainsdllAndWinmd\c.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\DirectoryContainstwoWinmd\a.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\DirectoryContainstwoWinmd\a.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\DirectoryContainstwoWinmd\c.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\DirectoryContainstwoWinmd\c.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return "WindowsRuntime 1.0";
             }
@@ -1053,7 +1047,7 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
 
             if
             (
-                String.Compare(path, @"c:\OldClrBug\MyFileLoadExceptionAssembly.dll", StringComparison.OrdinalIgnoreCase) == 0
+                String.Equals(path, @"c:\OldClrBug\MyFileLoadExceptionAssembly.dll", StringComparison.OrdinalIgnoreCase)
             )
             {
                 // An older LKG of the CLR could throw a FileLoadException if it doesn't recognize
@@ -1063,7 +1057,7 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
 
             if
             (
-                String.Compare(path, @"c:\Regress313086\mscorlib.dll", StringComparison.OrdinalIgnoreCase) == 0
+                String.Equals(path, @"c:\Regress313086\mscorlib.dll", StringComparison.OrdinalIgnoreCase)
             )
             {
                 // This is an mscorlib that returns null for its assembly name.
@@ -1072,7 +1066,7 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
 
             if
             (
-                String.Compare(path, Path.Combine(s_myVersion20Path, "BadImage.dll"), StringComparison.OrdinalIgnoreCase) == 0
+                String.Equals(path, Path.Combine(s_myVersion20Path, "BadImage.dll"), StringComparison.OrdinalIgnoreCase)
             )
             {
                 throw new System.BadImageFormatException(@"The format of the file '" + Path.Combine(s_myVersion20Path, "BadImage.dll") + "' is invalid");
@@ -1080,9 +1074,9 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
 
             if
             (
-                String.Compare(path, Path.Combine(s_myProjectPath, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase) == 0
-                || String.Compare(path, Path.Combine(s_myVersion20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase) == 0
-                || String.Compare(path, Path.Combine(s_myVersionPocket20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase) == 0
+                String.Equals(path, Path.Combine(s_myProjectPath, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase)
+                || String.Equals(path, Path.Combine(s_myVersion20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase)
+                || String.Equals(path, Path.Combine(s_myVersionPocket20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase)
             )
             {
                 // This is an mscorlib.dll with no metadata.
@@ -1091,8 +1085,8 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
 
             if
             (
-                String.Compare(path, Path.Combine(s_myVersion20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase) == 0
-                || String.Compare(path, Path.Combine(s_myVersionPocket20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase) == 0
+                String.Equals(path, Path.Combine(s_myVersion20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase)
+                || String.Equals(path, Path.Combine(s_myVersionPocket20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase)
             )
             {
                 // This is an mscorlib.dll with no metadata.
@@ -1104,129 +1098,129 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
                 throw new FileNotFoundException(path);
             }
 
-            if (String.Compare(path, Path.Combine(s_frameworksPath, "DependsOnFoo45Framework.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_frameworksPath, "DependsOnFoo45Framework.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnFoo45Framework, Version=4.5.0.0, PublicKeyToken=null, Culture=Neutral");
             }
 
-            if (String.Compare(path, Path.Combine(s_frameworksPath, "DependsOnFoo4Framework.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_frameworksPath, "DependsOnFoo4Framework.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnFoo4Framework, Version=4.0.0.0, PublicKeyToken=null, Culture=Neutral");
             }
 
-            if (String.Compare(path, Path.Combine(s_frameworksPath, "DependsOnFoo35Framework.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_frameworksPath, "DependsOnFoo35Framework.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnFoo35Framework, Version=3.5.0.0, PublicKeyToken=null, Culture=Neutral");
             }
 
-            if (String.Compare(path, @"c:\Regress315619\A\MyAssembly.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress315619\A\MyAssembly.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyAssembly, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"c:\Regress315619\B\MyAssembly.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress315619\B\MyAssembly.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyAssembly, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, s_regress442570_ADllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress442570_ADllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089");
             }
-            if (String.Compare(path, @"c:\Regress387218\v1\D.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress387218\v1\D.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("D, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"c:\Regress387218\v2\D.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress387218\v2\D.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("D, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"c:\Regress390219\v1\D.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress390219\v1\D.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("D, Version=1.0.0.0, Culture=fr, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"c:\Regress390219\v2\D.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress390219\v2\D.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("D, Version=2.0.0.0, Culture=en, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"c:\MyStronglyNamed\A.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\MyStronglyNamed\A.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neUtral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"c:\MyNameMismatch\Foo.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\MyNameMismatch\Foo.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Notice the metadata assembly name does not match the base file name.
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neUtral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"c:\MyEscapedName\=A=.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\MyEscapedName\=A=.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Notice the metadata assembly name does not match the base file name.
                 return new AssemblyNameExtension("\\=A\\=, Version=2.0.0.0, Culture=neUtral, PublicKeyToken=b77a5c561934e089", true);
             }
 
-            if (String.Compare(path, @"c:\MyEscapedName\__'ASP'dw0024ry.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\MyEscapedName\__'ASP'dw0024ry.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Notice the metadata assembly name does not match the base file name.
                 return new AssemblyNameExtension("__\\'ASP\\'dw0024ry", true);
             }
 
-            if (String.Compare(path, @"c:\MyInaccessible\A.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\MyInaccessible\A.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate an assembly that throws an UnauthorizedAccessException upon access.
                 throw new UnauthorizedAccessException();
             }
 
-            if (String.Compare(path, Path.Combine(Path.GetTempPath(), @"RawFileNameRelative\System.Xml.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(Path.GetTempPath(), @"RawFileNameRelative\System.Xml.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension(AssemblyRef.SystemXml);
             }
 
-            if (String.Compare(path, Path.Combine(Path.GetTempPath(), @"RelativeAssemblyFiles\System.Xml.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(Path.GetTempPath(), @"RelativeAssemblyFiles\System.Xml.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension(AssemblyRef.SystemXml);
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion20Path, "System.XML.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion20Path, "System.XML.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension(AssemblyRef.SystemXml);
             }
 
             // This is an assembly with an earlier version.
-            if (String.Compare(path, Path.Combine(s_myProjectPath, "System.Xml.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myProjectPath, "System.Xml.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension(AssemblyRef.SystemXml);
             }
 
             // This is an assembly with an incorrect PKT.
-            if (String.Compare(path, Path.Combine(s_myProjectPath, "System.Data.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myProjectPath, "System.Data.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=A77a5c561934e089");
@@ -1238,19 +1232,19 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
                 return new AssemblyNameExtension("MyGacAssembly, Version=9.2.3401.1, Culture=neutral, PublicKeyToken=a6694b450823df78");
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion20Path, "System.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion20Path, "System.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("System, VeRSion=2.0.0.0, Culture=neutRAl, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion40Path, "System.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion40Path, "System.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("System, VeRSion=4.0.0.0, Culture=neutRAl, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion90Path, "System.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion90Path, "System.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("System, VeRSion=9.0.0.0, Culture=neutRAl, PublicKeyToken=b77a5c561934e089");
@@ -1258,7 +1252,7 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
 
             if
             (
-                String.Compare(path, Path.Combine(s_myVersion20Path, "System.Data.dll"), StringComparison.OrdinalIgnoreCase) == 0
+                String.Equals(path, Path.Combine(s_myVersion20Path, "System.Data.dll"), StringComparison.OrdinalIgnoreCase)
             )
             {
                 // Simulate a strongly named assembly.
@@ -1281,70 +1275,66 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
             {
                 return new AssemblyNameExtension("E, Version=0.0.0.0, Culture=neutral, PUBlicKeyToken=null");
             }
-
-
-            if (String.Compare(path, s_unifyMeDll_V05Path, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_unifyMeDll_V05Path, StringComparison.OrdinalIgnoreCase))
             {
                 throw new FileNotFoundException();
             }
 
-            if (String.Compare(path, s_unifyMeDll_V10Path, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_unifyMeDll_V10Path, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("UnifyMe, Version=1.0.0.0, Culture=nEUtral, PublicKeyToken=b77a5c561934e089, ProcessorArchitecture=MSIL");
             }
 
-            if (String.Compare(path, @"C:\Framework\Everett\System.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Framework\Everett\System.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("System, Version=1.0.5000.0, Culture=neutral, PublICKeyToken=" + AssemblyRef.EcmaPublicKey);
             }
 
-            if (String.Compare(path, @"C:\Framework\Whidbey\System.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Framework\Whidbey\System.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=" + AssemblyRef.EcmaPublicKey);
             }
-
-
-            if (String.Compare(path, Path.Combine(s_myApp_V10Path, "DependsOnEverettSystem.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V10Path, "DependsOnEverettSystem.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnEverettSystem, VersION=1.0.5000.0, Culture=neutral, PublicKeyToken=feedbeadbadcadbe");
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V05Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V05Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnUnified, Version=0.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"C:\Regress339786\FolderA\C.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress339786\FolderA\C.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("C, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\Regress339786\FolderB\C.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress339786\FolderB\C.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("C, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V10Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V10Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnUnified, VERSion=1.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V20Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V20Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnUnified, VeRSIon=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V30Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V30Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnUnified, Version=3.0.0.0, Culture=neutral, PublicKEYToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, s_unifyMeDll_V20Path, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_unifyMeDll_V20Path, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("UnifyMe, Version=2.0.0.0, Culture=neutral, PublicKeyTOKEn=b77a5c561934e089");
             }
 
-            if (String.Compare(path, s_unifyMeDll_V30Path, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_unifyMeDll_V30Path, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("UnifyMe, Version=3.0.0.0, Culture=neutral, PublICkeyToken=b77a5c561934e089");
             }
@@ -1364,417 +1354,417 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
                 return new AssemblyNameExtension("G, Version=2.0.0.0, Culture=neutral, PublicKEyToken=aaaaaaaaaaaaaaaa");
             }
 
-            if (String.Compare(path, @"C:\Regress317975\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress317975\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("A, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
-            if (String.Compare(path, @"C:\Regress317975\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress317975\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
-            if (String.Compare(path, @"C:\Regress317975\v2\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress317975\v2\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
             // Set up assembly names for testing target framework version checks
             // Is version 4 and will only depends on 4.0 assemblies
-            if (String.Compare(path, s_40ComponentDependsOnOnlyv4AssembliesDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_40ComponentDependsOnOnlyv4AssembliesDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnOnlyv4Assemblies, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089");
             }
 
             // Is version 9 and will not have any dependencies, will be in the redist list
-            if (String.Compare(path, Path.Combine(s_myComponentsMiscPath, "ReferenceVersion9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsMiscPath, "ReferenceVersion9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("ReferenceVersion9, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089");
             }
 
             // Is a third party assembly which depends on a version 9 assembly
-            if (String.Compare(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOn9, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089");
             }
 
             //A second assembly which depends on version 9 framework assemblies.
-            if (String.Compare(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9Also.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9Also.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOn9Also, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089");
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponents10Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponents10Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOn9, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089");
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponents20Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponents20Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOn9, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089");
             }
 
-            if (String.Compare(path, s_regress444809_ADllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_ADllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("A, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, s_regress444809_V2_ADllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_V2_ADllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, s_regress444809_BDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_BDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("B, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, s_regress444809_CDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_CDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("C, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, s_regress444809_DDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_DDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("D, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\Regress714052\X86\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\X86\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=X86");
             }
-            if (String.Compare(path, @"C:\Regress714052\Mix\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\Mix\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=X86");
             }
-            if (String.Compare(path, @"C:\Regress714052\Mix\a.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\Mix\a.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=MSIL");
             }
 
-            if (String.Compare(path, @"C:\Regress714052\MSIL\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\MSIL\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=MSIL");
             }
 
-            if (String.Compare(path, @"C:\Regress714052\None\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\None\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
-            if (String.Compare(path, @"C:\Regress714052\X86\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\X86\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=X86");
             }
-            if (String.Compare(path, @"C:\Regress714052\Mix\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\Mix\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=X86");
             }
-            if (String.Compare(path, @"C:\Regress714052\Mix\b.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\Mix\b.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=MSIL");
             }
-            if (String.Compare(path, @"C:\Regress714052\MSIL\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\MSIL\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=MSIL");
             }
-            if (String.Compare(path, @"C:\Regress714052\None\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\None\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "V.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "V.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("V, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
-            if (String.Compare(path, Path.Combine(s_myComponents2RootPath, "W.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponents2RootPath, "W.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("W, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "X.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "X.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("X, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "Z.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "Z.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("Z, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "Y.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "Y.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("Y, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "Microsoft.Build.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "Microsoft.Build.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("Microsoft.Build, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "DependsOnMSBuild12.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "DependsOnMSBuild12.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnMSBuild12, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\WinMD\v4\MsCorlib.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\v4\MsCorlib.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("mscorlib, Version=4.0.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"C:\WinMD\v255\MsCorlib.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\v255\MsCorlib.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("mscorlib, Version=255.255.255.255, Culture=Neutral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"C:\WinMD\DotNetAssemblyDependsOnWinMD.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\DotNetAssemblyDependsOnWinMD.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DotNetAssemblyDependsOnWinMD, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\WinMD\DotNetAssemblyDependsOn255WinMD.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\DotNetAssemblyDependsOn255WinMD.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DotNetAssemblyDependsOn255WinMD, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SampleWindowsRuntimeOnly, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnInvalidPeHeader.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnInvalidPeHeader.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnInvalidPeHeader, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnAmd64.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnAmd64.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnAmd64, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnArm.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnArm.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnArm, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnIA64.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnIA64.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnIA64, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnArmv7.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnArmv7.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnArmv7, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnX86.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnX86.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnX86, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnUnknown.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnUnknown.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnUnknown, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnAnyCPUUnknown.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnAnyCPUUnknown.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnAnyCPUUnknown, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("WinMDWithVersion255, Version=255.255.255.255");
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SampleWindowsRuntimeOnly2, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SampleWindowsRuntimeOnly3, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SampleWindowsRuntimeOnly4, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SampleWindowsRuntimeReferencingSystem, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SampleWindowsRuntimeReferencingSystemDNE, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeAndCLR.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeAndCLR.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SampleWindowsRuntimeAndCLR, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\MyWinMDComponents\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\MyWinMDComponents\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyGridWinMD, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\MyWinMDComponents2\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\MyWinMDComponents2\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyGridWinMD, Version=2.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\MyWinMDComponent7s\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\MyWinMDComponent7s\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyGridWinMD, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\MyWinMDComponents9\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\MyWinMDComponents9\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyGridWinMD, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\MyWinMDComponentsVv1\MyGridWinMD2.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\MyWinMDComponentsVv1\MyGridWinMD2.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyGridWinMD2, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\MyWinMDComponentsV1\MyGridWinMD3.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\MyWinMDComponentsV1\MyGridWinMD3.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyGridWinMD3, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\Debug\X86\DebugX86SDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\Debug\X86\DebugX86SDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DebugX86SDKWinMD, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\Debug\Neutral\DebugNeutralSDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\Debug\Neutral\DebugNeutralSDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DebugNeutralSDKWinMD, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\CommonConfiguration\x86\x86SDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\CommonConfiguration\x86\x86SDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("X86SDKWinMD, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\CommonConfiguration\Neutral\NeutralSDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\CommonConfiguration\Neutral\NeutralSDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("NeutralSDKWINMD, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\Debug\X86\DebugX86SDKRA.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\Debug\X86\DebugX86SDKRA.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("Debugx86SDKRA, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\Debug\Neutral\DebugNeutralSDKRA.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\Debug\Neutral\DebugNeutralSDKRA.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DebugNeutralSDKRA, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\CommonConfiguration\x86\x86SDKRA.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\CommonConfiguration\x86\x86SDKRA.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("X86SDKRA, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\CommonConfiguration\Neutral\NeutralSDKRA.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\CommonConfiguration\Neutral\NeutralSDKRA.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("NeutralSDKRA, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\Debug\X86\SDKReference.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\Debug\X86\SDKReference.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SDKReference, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainsOnlyDll\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainsOnlyDll\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("A, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainsdllAndWinmd\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainsdllAndWinmd\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("b, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainsdllAndWinmd\c.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainsdllAndWinmd\c.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("C, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainstwoWinmd\a.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainstwoWinmd\a.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("A, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainstwoWinmd\c.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainstwoWinmd\c.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("C, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (string.Compare(path, @"c:\assemblyfromconfig\folder_x64\assemblyfromconfig_common.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(path, @"c:\assemblyfromconfig\folder_x64\assemblyfromconfig_common.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("assemblyfromconfig_common, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=AMD64");
             }
 
-            if (string.Compare(path, @"c:\assemblyfromconfig\folder_x86\assemblyfromconfig_common.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(path, @"c:\assemblyfromconfig\folder_x86\assemblyfromconfig_common.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("assemblyfromconfig_common, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=X86");
             }
 
-            if (string.Compare(path, @"c:\assemblyfromconfig\folder5010x64\v5assembly.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(path, @"c:\assemblyfromconfig\folder5010x64\v5assembly.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("v5assembly, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=AMD64");
             }
 
-            if (string.Compare(path, @"c:\assemblyfromconfig\folder501000x86\v5assembly.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(path, @"c:\assemblyfromconfig\folder501000x86\v5assembly.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("v5assembly, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=X86");
             }
 
-            if (string.Compare(path, s_dependsOnNuGet_ADllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(path, s_dependsOnNuGet_ADllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
-            if (string.Compare(path, s_nugetCache_N_Lib_NDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(path, s_nugetCache_N_Lib_NDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("N, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
@@ -1783,7 +1773,6 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
             return new AssemblyNameExtension(defaultName);
         }
 
-
         /// <summary>
         /// Cached implementation. Given an assembly name, crack it open and retrieve the list of dependent
         /// assemblies and  the list of scatter files.
@@ -1861,7 +1850,7 @@ string path
         /// <returns>The array of dependent assembly names.</returns>
         internal static AssemblyNameExtension[] GetDependencies(string path)
         {
-            if (String.Compare(path, Path.Combine(s_frameworksPath, "IndirectDependsOnFoo4Framework.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_frameworksPath, "IndirectDependsOnFoo4Framework.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1869,7 +1858,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_frameworksPath, "IndirectDependsOnFoo45Framework.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_frameworksPath, "IndirectDependsOnFoo45Framework.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1877,7 +1866,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_frameworksPath, "IndirectDependsOnFoo35Framework.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_frameworksPath, "IndirectDependsOnFoo35Framework.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1885,7 +1874,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_regress454863_ADllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress454863_ADllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1893,7 +1882,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1901,7 +1890,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress313747\Microsoft.Office.Interop.Excel.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress313747\Microsoft.Office.Interop.Excel.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1909,7 +1898,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress313747\MS.Internal.Test.Automation.Office.Excel.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress313747\MS.Internal.Test.Automation.Office.Excel.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1917,7 +1906,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"c:\Regress387218\A.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress387218\A.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1925,7 +1914,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"c:\Regress387218\B.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress387218\B.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1933,7 +1922,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"c:\Regress390219\A.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress390219\A.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1941,7 +1930,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"c:\Regress390219\B.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress390219\B.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1949,7 +1938,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1957,7 +1946,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress313747\Microsoft.Office.Interop.Excel.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress313747\Microsoft.Office.Interop.Excel.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1965,7 +1954,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress313747\MS.Internal.Test.Automation.Office.Excel.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress313747\MS.Internal.Test.Automation.Office.Excel.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1973,7 +1962,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"c:\OldClrBug\DependsMyFileLoadExceptionAssembly.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\OldClrBug\DependsMyFileLoadExceptionAssembly.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1981,7 +1970,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"c:\Regress563286\DependsOnBadImage.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress563286\DependsOnBadImage.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1989,17 +1978,17 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"c:\MyInaccessible\A.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\MyInaccessible\A.dll", StringComparison.OrdinalIgnoreCase))
             {
                 throw new UnauthorizedAccessException();
             }
 
-            if (String.Compare(path, @"c:\Regress313086\mscorlib.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress313086\mscorlib.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[] { };
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion20Path, "System.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion20Path, "System.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2007,7 +1996,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\DotNetAssemblyDependsOnWinMD.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\DotNetAssemblyDependsOnWinMD.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2015,7 +2004,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\DotNetAssemblyDependsOn255WinMD.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\DotNetAssemblyDependsOn255WinMD.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2023,7 +2012,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeAndClr.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeAndClr.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                  {
@@ -2031,7 +2020,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                  };
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                  {
@@ -2039,7 +2028,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                  };
             }
 
-            if (String.Compare(path, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2047,7 +2036,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2055,7 +2044,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2066,7 +2055,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2075,7 +2064,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2084,7 +2073,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2095,8 +2084,8 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
 
             if
             (
-                String.Compare(path, Path.Combine(s_myVersion20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase) == 0
-                || String.Compare(path, Path.Combine(s_myVersionPocket20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase) == 0
+                String.Equals(path, Path.Combine(s_myVersion20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase)
+                || String.Equals(path, Path.Combine(s_myVersionPocket20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase)
             )
             {
                 return new AssemblyNameExtension[]
@@ -2104,14 +2093,14 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"MyRelativeAssembly.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"MyRelativeAssembly.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myAppRootPath, "DependsOnSimpleA.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myAppRootPath, "DependsOnSimpleA.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2119,7 +2108,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress312873\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress312873\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2127,7 +2116,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress339786\FolderA\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress339786\FolderA\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2135,7 +2124,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress339786\FolderB\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress339786\FolderB\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2143,7 +2132,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress317975\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress317975\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2151,7 +2140,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\myassemblies\My.Assembly.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\myassemblies\My.Assembly.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2159,7 +2148,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "MyGrid.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "MyGrid.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2167,16 +2156,14 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\MyRawDropControls\MyRawDropControl.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\MyRawDropControls\MyRawDropControl.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
                     new AssemblyNameExtension("mscorlib, VeRsIon=2.0.0.0, Culture=neuTRal, PublicKeyToken=b77a5c561934e089")
                 };
             }
-
-
-            if (String.Compare(path, s_myLibraries_ADllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_myLibraries_ADllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2184,7 +2171,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_myLibraries_TDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_myLibraries_TDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2192,7 +2179,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_myLibraries_BDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_myLibraries_BDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2201,7 +2188,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_myLibraries_V1_DDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_myLibraries_V1_DDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2209,7 +2196,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_myLibraries_V2_DDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_myLibraries_V2_DDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2217,14 +2204,14 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_myLibraries_V1_E_EDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_myLibraries_V1_E_EDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V05Path, "DependsOnWeaklyNamedUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V05Path, "DependsOnWeaklyNamedUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2232,7 +2219,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V10Path, "DependsOnEverettSystem.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V10Path, "DependsOnEverettSystem.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2240,7 +2227,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V05Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V05Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2248,7 +2235,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V10Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V10Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2256,7 +2243,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V20Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V20Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2264,7 +2251,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V30Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V30Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2272,14 +2259,14 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_myMissingAssemblyAbsPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_myMissingAssemblyAbsPath, StringComparison.OrdinalIgnoreCase))
             {
                 throw new FileNotFoundException(path);
             }
 
             // Set up assembly names for testing target framework version checks
             // Is version 4 and will only depends on 4.0 assemblies
-            if (String.Compare(path, s_40ComponentDependsOnOnlyv4AssembliesDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_40ComponentDependsOnOnlyv4AssembliesDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2288,7 +2275,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
             }
 
             // Is version 9 and will not have any dependencies, will be in the redist list
-            if (String.Compare(path, Path.Combine(s_myComponentsMiscPath, "ReferenceVersion9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsMiscPath, "ReferenceVersion9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2298,7 +2285,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
             }
 
             // Is a third party assembly which depends on a version 9 assembly
-            if (String.Compare(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2308,7 +2295,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
             }
 
             //A second assembly which depends on version 9 framework assemblies.
-            if (String.Compare(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9Also.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9Also.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2316,7 +2303,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponents10Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponents10Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2324,7 +2311,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponents20Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponents20Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2332,7 +2319,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_regress444809_CDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_CDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2341,7 +2328,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_regress444809_BDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_BDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2349,7 +2336,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_regress444809_DDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_DDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2357,7 +2344,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "V.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "V.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2365,12 +2352,12 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponents2RootPath, "W.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponents2RootPath, "W.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[] { };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "X.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "X.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2378,12 +2365,12 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "Z.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "Z.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[] { };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "Y.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "Y.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2391,12 +2378,12 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "Microsoft.Build.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "Microsoft.Build.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[] { };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "DependsOnMSBuild12.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "DependsOnMSBuild12.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2404,7 +2391,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion20Path, "System.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion20Path, "System.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension[]
@@ -2413,7 +2400,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion40Path, "System.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion40Path, "System.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension[]
@@ -2422,7 +2409,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion90Path, "System.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion90Path, "System.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension[]
@@ -2431,7 +2418,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainsOnlyDll\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainsOnlyDll\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension[]
@@ -2440,7 +2427,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainsdllAndWinmd\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainsdllAndWinmd\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension[]
@@ -2449,13 +2436,13 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainsdllAndWinmd\c.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainsdllAndWinmd\c.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension[0];
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainstwoWinmd\a.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainstwoWinmd\a.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension[]
@@ -2464,7 +2451,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainstwoWinmd\c.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainstwoWinmd\c.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[0];
             }
@@ -2474,7 +2461,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 return new AssemblyNameExtension[0];
             }
 
-            if (String.Compare(path, s_portableDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_portableDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a portable assembly with a reference to System.Runtime
                 return new AssemblyNameExtension[]
@@ -2483,7 +2470,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_netstandardLibraryDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_netstandardLibraryDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a .NET Standard assembly
                 return new AssemblyNameExtension[]
@@ -2492,7 +2479,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_dependsOnNuGet_ADllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_dependsOnNuGet_ADllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2536,89 +2523,89 @@ private static IEnumerable<string> GetRegistrySubKeyNames(RegistryKey baseKey, s
         {
             if (baseKey == Registry.CurrentUser)
             {
-                if (String.Compare(subKey, @"Software\Regress714052", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\X86", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\X86", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\MSIL", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\MSIL", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\Mix", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\Mix", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\Mix\Mix", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\Mix\Mix", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\None", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\None", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\X86\X86", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\X86\X86", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\None\None", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\None\None", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "", "vBogusVersion", "v1.a.2.3", "v1.0", "v3.0", "v2.0.50727", "v2.0.x86chk", "RandomJunk" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "ZControlA", "ZControlB", "Infragistics.GridControl.1.0", "Infragistics.MyHKLMControl.1.0", "Infragistics.MyControlWithFutureTargetNDPVersion.1.0", "Infragistics.MyControlWithPastTargetNDPVersion.1.0", "Infragistics.MyControlWithServicePack.1.0" };
                 }
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.x86chk\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.x86chk\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "RawDropControls" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v3.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v3.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "Infragistics.MyControlWithFutureTargetNDPVersion.1.0" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "Infragistics.MyNDP1Control.1.0", "Infragistics.MyControlWithPastTargetNDPVersion.1.0" };
                 }
 
                 if
                 (
-                    String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.GridControl.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v3.0\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyNDP1Control.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.x86chk\AssemblyFoldersEx\RawDropControls", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlA", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlB", StringComparison.OrdinalIgnoreCase) == 0
+                    String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.GridControl.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v3.0\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyNDP1Control.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.x86chk\AssemblyFoldersEx\RawDropControls", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlA", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlB", StringComparison.OrdinalIgnoreCase)
                 )
                 {
                     return new string[] { };
@@ -2626,39 +2613,39 @@ private static IEnumerable<string> GetRegistrySubKeyNames(RegistryKey baseKey, s
 
                 if
                 (
-                    String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0", StringComparison.OrdinalIgnoreCase) == 0
+                    String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0", StringComparison.OrdinalIgnoreCase)
                 )
                 {
                     // This control has a service pack
                     return new string[] { "sp1", "sp2" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "v2.0.3600" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "PocketPC" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "AFETestDeviceControl" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "1234" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\Microsoft SDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\Microsoft SDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "Windows" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\Microsoft SDKs\Windows", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\Microsoft SDKs\Windows", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "7.0", "8.0", "v8.0", "9.0" };
                 }
@@ -2666,105 +2653,105 @@ private static IEnumerable<string> GetRegistrySubKeyNames(RegistryKey baseKey, s
 
             if (baseKey == Registry.LocalMachine)
             {
-                if (String.Compare(subKey, @"Software\Regress714052", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "v2.0.0" };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "A", "B" };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\A", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\A", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\B", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\B", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\X86", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\X86", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "X86" };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\MSIL", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\MSIL", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "MSIL" };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\None", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\None", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "None" };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\Mix", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\Mix", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "Mix" };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\Mix\Mix", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\Mix\Mix", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\X86\X86", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\X86\X86", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\None\None", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\None\None", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "vBogusVersion", "v2.0.50727" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "Infragistics.FancyControl.1.0", "Infragistics.MyHKLMControl.1.0" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.FancyControl.1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.FancyControl.1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "v2.0.3600" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "PocketPC" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\Microsoft SDKs\Windows", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\Microsoft SDKs\Windows", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "8.0" };
                 }
@@ -2785,41 +2772,41 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
         {
             if (baseKey == Registry.CurrentUser)
             {
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlA", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlA", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\MyComponentsA";
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlB", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlB", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\MyComponentsB";
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.GridControl.1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.GridControl.1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\MyComponents";
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.x86chk\AssemblyFoldersEx\RawDropControls", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.x86chk\AssemblyFoldersEx\RawDropControls", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\MyRawDropControls";
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\MyComponents\HKCU Components";
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v3.0\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v3.0\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return s_myComponentsV30Path;
                 }
 
                 if
                 (
-                    String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0", StringComparison.OrdinalIgnoreCase) == 0
+                    String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0", StringComparison.OrdinalIgnoreCase)
                 )
                 {
                     return s_myComponentsV20Path;
@@ -2827,7 +2814,7 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
 
                 if
                 (
-                    String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0", StringComparison.OrdinalIgnoreCase) == 0
+                    String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0", StringComparison.OrdinalIgnoreCase)
                 )
                 {
                     return @"C:\MyComponentBase";
@@ -2835,7 +2822,7 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
 
                 if
                 (
-                    String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0\sp1", StringComparison.OrdinalIgnoreCase) == 0
+                    String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0\sp1", StringComparison.OrdinalIgnoreCase)
                 )
                 {
                     return @"C:\MyComponentServicePack1";
@@ -2843,7 +2830,7 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
 
                 if
                 (
-                    String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0\sp2", StringComparison.OrdinalIgnoreCase) == 0
+                    String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0\sp2", StringComparison.OrdinalIgnoreCase)
                 )
                 {
                     return @"C:\MyComponentServicePack2";
@@ -2851,18 +2838,18 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
 
                 if
                 (
-                    String.Compare(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyNDP1Control.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0
+                    String.Equals(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyNDP1Control.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase)
                 )
                 {
                     return s_myComponentsV10Path;
                 }
 
-                if (String.Compare(subKey, @"SOFTWARE\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"SOFTWARE\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\V1Control";
                 }
-                if (String.Compare(subKey, @"SOFTWARE\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl\1234", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"SOFTWARE\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl\1234", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\V1ControlSP1";
                 }
@@ -2870,44 +2857,44 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
 
             if (baseKey == Registry.LocalMachine)
             {
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.FancyControl.1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.FancyControl.1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\MyComponents\HKLM Components";
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\MyComponents\HKLM Components";
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\B", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\B", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\Regress714052\X86";
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\A", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\A", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\Regress714052\MSIL";
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\X86\X86", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\X86\X86", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\Regress714052\X86";
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\Mix\Mix", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\Mix\Mix", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\Regress714052\Mix";
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\Regress714052\MSIL";
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\Regress714052\MSIL";
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\None\None", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\None\None", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\Regress714052\None";
                 }
@@ -2957,7 +2944,7 @@ protected static bool ContainsItem(ITaskItem[] items, string spec)
         {
             foreach (ITaskItem item in items)
             {
-                if (0 == String.Compare(item.ItemSpec, spec, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(item.ItemSpec, spec, StringComparison.OrdinalIgnoreCase))
                 {
                     return true;
                 }
diff --git a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
index f21876d03c3..d9daab826d4 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
@@ -114,7 +114,7 @@ public void HighVersionDoesntExist()
 
             t.BuildEngine = engine;
             t.Assemblies = assemblyNames;
-                t.SearchPaths = new string[] { s_myApp_V10Path, @"C:\Framework\Everett" }; ;
+                t.SearchPaths = new string[] { s_myApp_V10Path, @"C:\Framework\Everett" }; 
 
             bool succeeded = Execute(t);
 
diff --git a/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs b/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs
index 41ba25b30b3..d82ce671a45 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs
@@ -700,7 +700,7 @@ private void VerifyImplementationArchitecture(string winmdName, string targetPro
             Assert.Equal(@"WindowsRuntime 1.0", t.ResolvedFiles[0].GetMetadata(ItemMetadataNames.imageRuntime));
             Assert.True(bool.Parse(t.ResolvedFiles[0].GetMetadata(ItemMetadataNames.winMDFile)));
 
-            string fullMessage = null;
+            string fullMessage;
             if (implementationFileArch.Equals("Unknown"))
             {
                 fullMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ResolveAssemblyReference.UnknownProcessorArchitecture", @"C:\WinMDArchVerification\" + winmdName + ".dll", @"C:\WinMDArchVerification\" + winmdName + ".winmd", NativeMethods.IMAGE_FILE_MACHINE_R4000.ToString("X", CultureInfo.InvariantCulture));
diff --git a/src/Tasks.UnitTests/AssignProjectConfiguration_Tests.cs b/src/Tasks.UnitTests/AssignProjectConfiguration_Tests.cs
index 349ae0014ca..f00fc18dd4f 100644
--- a/src/Tasks.UnitTests/AssignProjectConfiguration_Tests.cs
+++ b/src/Tasks.UnitTests/AssignProjectConfiguration_Tests.cs
@@ -49,7 +49,7 @@ private void TestResolveHelper(string itemSpec, string projectGuid, string packa
                 (resolvedProjectWithConfiguration == null) ? string.Empty : resolvedProjectWithConfiguration.GetMetadata("FullConfiguration"));
 
             Assert.Equal(expectedResult, result);
-            if (result == true)
+            if (result)
             {
                 Assert.Equal(expectedFullConfiguration, resolvedProjectWithConfiguration.GetMetadata("FullConfiguration"));
                 Assert.Equal(expectedConfiguration, resolvedProjectWithConfiguration.GetMetadata("Configuration"));
@@ -292,23 +292,20 @@ private void TestUnresolvedReferencesHelper(ArrayList projectRefs, Hashtable pre
         [Fact]
         public void TestUnresolvedReferences()
         {
-            Hashtable unresolvedProjects = null;
-            Hashtable resolvedProjects = null;
-            Hashtable projectConfigurations = null;
-            ArrayList projectRefs = null;
-
-            projectRefs = new ArrayList();
+            ArrayList projectRefs = new ArrayList();
             projectRefs.Add(ResolveNonMSBuildProjectOutput_Tests.CreateReferenceItem("MCDep1.vcproj", "{2F6BBCC3-7111-4116-A68B-000000000000}",
                 "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}", "MCDep1"));
             projectRefs.Add(ResolveNonMSBuildProjectOutput_Tests.CreateReferenceItem("MCDep2.vcproj", "{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}",
                 "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}", "MCDep2"));
 
             // 1. multiple projects, none resolvable
-            projectConfigurations = new Hashtable();
+            Hashtable projectConfigurations = new Hashtable();
             projectConfigurations.Add("{11111111-1111-1111-1111-111111111111}", @"Config1|Win32");
             projectConfigurations.Add("{11111111-1111-1111-1111-111111111112}", @"Config2|AnyCPU");
             projectConfigurations.Add("{11111111-1111-1111-1111-111111111113}", @"Config3|AnyCPU");
 
+            Hashtable unresolvedProjects;
+            Hashtable resolvedProjects;
             TestUnresolvedReferencesHelper(projectRefs, projectConfigurations, out unresolvedProjects, out resolvedProjects);
 
             Assert.Empty(resolvedProjects); // "No resolved refs expected for case 1"
diff --git a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
index 72e60aa3539..8d0a7300c85 100644
--- a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
+++ b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
@@ -223,7 +223,6 @@ public void EmptyLanguage()
             mockLogger.AssertLogContains(String.Format(unformattedMessage, "Language"));
         }
 
-
         /// <summary>
         /// Verify we get an error if a the Type attribute is set but it is empty
         /// </summary>
@@ -509,7 +508,7 @@ public void BuildTaskSimpleCodeFactoryTestExtraUsing()
                     </Project>";
 
             MockLogger mockLogger = Helpers.BuildProjectWithNewOMExpectSuccess(projectFileContents);
-            string linqString = System.Linq.Expressions.ExpressionType.Add.ToString();
+            string linqString = nameof(System.Linq.Expressions.ExpressionType.Add);
             mockLogger.AssertLogContains(linqString + ":Hello, World!");
         }
 
@@ -539,7 +538,6 @@ public void BuildTaskDateCodeFactory()
                         </Target>
                     </Project>";
 
-
             MockLogger mockLogger = Helpers.BuildProjectWithNewOMExpectSuccess(projectFileContents);
             mockLogger.AssertLogContains("Current Date and Time:");
             mockLogger.AssertLogDoesntContain("[[]]");
@@ -876,7 +874,6 @@ public bool Execute()
             mockLogger.AssertLogContains(unformattedMessage);
         }
 
-
         /// <summary>
         /// Verify we get an error if a the Type attribute is set but it is empty
         /// </summary>
diff --git a/src/Tasks.UnitTests/CommandLine_Support.cs b/src/Tasks.UnitTests/CommandLine_Support.cs
index bf3e66cb713..af5b932a48d 100644
--- a/src/Tasks.UnitTests/CommandLine_Support.cs
+++ b/src/Tasks.UnitTests/CommandLine_Support.cs
@@ -43,7 +43,7 @@ static internal bool CallValidateParameters(ToolTask task)
          */
         private static string[] Parse(string cl)
         {
-            int emptySplits = 0;
+            int emptySplits;
             string[] pieces = (string[])QuotingUtilities.SplitUnquoted(cl, int.MaxValue, false, true, out emptySplits, ' ', '\n').ToArray(typeof(string));
             return pieces;
         }
@@ -175,10 +175,10 @@ bool useResponseFile
                     // Skip anything shorter than the compare string.
                     continue;
                 }
-                if (String.Compare(s.Substring(0, startsWith.Length), startsWith, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(s.Substring(0, startsWith.Length), startsWith, StringComparison.OrdinalIgnoreCase))
                 {
                     // If this doesn't match the 'except' then this is an error.
-                    if (String.Compare(s, except, StringComparison.Ordinal) != 0)
+                    if (!String.Equals(s, except, StringComparison.Ordinal))
                     {
                         msg += String.Format(" Found something!\r\n");
                         Console.WriteLine(msg);
@@ -262,8 +262,7 @@ internal static void ValidateEquals(ToolTaskExtension t, string lookFor, bool us
                 t.AddCommandLineCommands(b);
 
             string cl = b.ToString();
-            string msg;
-            msg = String.Format("Command-line = [{0}]\r\n", cl);
+            string msg = String.Format("Command-line = [{0}]\r\n", cl);
             msg += String.Format("Expected     = [{0}]\r\n", lookFor);
 
             if (cl != lookFor)
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 69c943c4551..edd0c80b6e4 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -40,16 +40,16 @@ public bool UseSingleThreadedCopy
         private int _parallelismThreadCount = DefaultParallelismThreadCount;
 
         /// <summary>
-        /// Temporarily save off the value of MSBUILDALWAYSOVERWRITEREADONLYFILES, so that we can run 
+        /// Temporarily save off the value of MSBUILDALWAYSOVERWRITEREADONLYFILES, so that we can run
         /// the tests isolated from the current state of the environment, but put it back how it belongs
-        /// once we're done. 
+        /// once we're done.
         /// </summary>
         private readonly string _alwaysOverwriteReadOnlyFiles;
 
         /// <summary>
-        /// Temporarily save off the value of MSBUILDALWAYSRETRY, so that we can run 
+        /// Temporarily save off the value of MSBUILDALWAYSRETRY, so that we can run
         /// the tests isolated from the current state of the environment, but put it back how it belongs
-        /// once we're done. 
+        /// once we're done.
         /// </summary>
         private readonly string _alwaysRetry;
 
@@ -57,7 +57,7 @@ public bool UseSingleThreadedCopy
 
         /// <summary>
         /// There are a couple of environment variables that can affect the operation of the Copy
-        /// task.  Make sure none of them are set. 
+        /// task.  Make sure none of them are set.
         /// </summary>
         public Copy_Tests(ITestOutputHelper testOutputHelper)
         {
@@ -72,7 +72,7 @@ public Copy_Tests(ITestOutputHelper testOutputHelper)
         }
 
         /// <summary>
-        /// Restore the environment variables we cleared out at the beginning of the test. 
+        /// Restore the environment variables we cleared out at the beginning of the test.
         /// </summary>
         public void Dispose()
         {
@@ -189,7 +189,7 @@ public void DoNotNormallyCopyOverReadOnlyFile()
         }
 
         /// <summary>
-        /// If MSBUILDALWAYSOVERWRITEREADONLYFILES is set, then overwrite read-only even when 
+        /// If MSBUILDALWAYSOVERWRITEREADONLYFILES is set, then overwrite read-only even when
         /// OverwriteReadOnlyFiles is false
         /// </summary>
         [Fact]
@@ -256,7 +256,7 @@ public void CopyOverReadOnlyFileEnvironmentOverride()
         }
 
         /// <summary>
-        /// If MSBUILDALWAYSRETRY is set, keep retrying the copy. 
+        /// If MSBUILDALWAYSRETRY is set, keep retrying the copy.
         /// </summary>
         [Fact]
         [Trait("Category", "mono-osx-failing")]
@@ -451,8 +451,8 @@ public void CopyOverReadOnlyFileParameterIsSetWithDestinationFolder()
                 string destinationContent2 = File.ReadAllText(destination2);
                 Assert.Equal("This is a source file2.", destinationContent2);
 
-                Assert.NotEqual(FileAttributes.ReadOnly, (File.GetAttributes(destination1) & FileAttributes.ReadOnly));
-                Assert.NotEqual(FileAttributes.ReadOnly, (File.GetAttributes(destination2) & FileAttributes.ReadOnly));
+                Assert.NotEqual(FileAttributes.ReadOnly, File.GetAttributes(destination1) & FileAttributes.ReadOnly);
+                Assert.NotEqual(FileAttributes.ReadOnly, File.GetAttributes(destination2) & FileAttributes.ReadOnly);
 
                 ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries
             }
@@ -1011,7 +1011,7 @@ internal class CopyMonitor
         }
 
         /// <summary>
-        /// CopiedFiles should only include files that were successfully copied 
+        /// CopiedFiles should only include files that were successfully copied
         /// (or skipped), not files for which there was an error.
         /// </summary>
         [Fact]
@@ -1547,7 +1547,7 @@ public void CopyWithDuplicatesUsingFiles()
         }
 
         /// <summary>
-        /// DestinationFiles should only include files that were successfully copied 
+        /// DestinationFiles should only include files that were successfully copied
         /// (or skipped), not files for which there was an error.
         /// </summary>
         [Fact]
@@ -1604,7 +1604,7 @@ public void DestinationFilesLengthNotEqualSourceFilesLength()
 
         /// <summary>
         /// If the destination path is too long, the task should not bubble up
-        /// the System.IO.PathTooLongException 
+        /// the System.IO.PathTooLongException
         /// </summary>
         [Fact]
         [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
@@ -1648,7 +1648,7 @@ public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
 
         /// <summary>
         /// If the source path is too long, the task should not bubble up
-        /// the System.IO.PathTooLongException 
+        /// the System.IO.PathTooLongException
         /// </summary>
         [Fact]
         [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
@@ -1769,7 +1769,7 @@ public void FailureWithNoRetries()
                 UseHardlinksIfPossible = UseHardLinks,
                 UseSymboliclinksIfPossible = UseSymbolicLinks,
             };
-            
+
             var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
             bool result = t.Execute(copyFunctor.Copy, _parallelismThreadCount);
 
@@ -1813,7 +1813,7 @@ public void DefaultNoHardlink()
             {
                 RetryDelayMilliseconds = 1,  // speed up tests!
             };
-            
+
             Assert.False(t.UseHardlinksIfPossible);
         }
 
diff --git a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
index 363cc04a965..9a77edb3002 100644
--- a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
@@ -16,7 +16,6 @@ namespace Microsoft.Build.UnitTests
 {
     sealed public class CreateCSharpManifestResourceName_Tests
     {
-
         private readonly ITestOutputHelper _testOutput;
 
         public CreateCSharpManifestResourceName_Tests(ITestOutputHelper output)
@@ -82,7 +81,6 @@ public void Regress172107()
                     null
                 );
 
-
             MemoryStream m = new MemoryStream();
             m.Write(new byte[] { 0x64, 0xc3, 0x61, 0x2e, 0x43, 0x6c, 0x61, 0x73, 0x73 }, 0, 9); // d√Éa.Class in ANSI
             m.Flush();
@@ -97,8 +95,6 @@ public void Regress172107()
             Assert.Equal(className, result);
         }
 
-
-
         /// <summary>
         /// Test for a namespace that has UTF8 characters but there's no BOM at the start.
         ///
@@ -456,7 +452,6 @@ public void DependentUponConvention_DoesNotApplyToNonResx(bool explicitlySpecify
             }
         }
 
-
         /// <summary>
         /// Opt into DependentUpon convention and load the expected file properly when the file is in a subfolder.
         /// </summary>
@@ -796,7 +791,7 @@ class MyForm
         /// <returns>The Stream</returns>
         private Stream CreateFileStream(string path, FileMode mode, FileAccess access)
         {
-            if (String.Compare(path, "SR1.strings", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, "SR1.strings", StringComparison.OrdinalIgnoreCase))
             {
                 return StreamHelpers.StringToStream("namespace MyStuff.Namespace { class Class {} }");
             }
diff --git a/src/Tasks.UnitTests/CreateItem_Tests.cs b/src/Tasks.UnitTests/CreateItem_Tests.cs
index 2bc06e46f48..73a1efadd6c 100644
--- a/src/Tasks.UnitTests/CreateItem_Tests.cs
+++ b/src/Tasks.UnitTests/CreateItem_Tests.cs
@@ -183,8 +183,6 @@ public void RecursiveDirOutOfProc()
 
             ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine("Subdir", "Bar.txt"), "bar");
 
-            env.SetEnvironmentVariable("MSBUILDTARGETRESULTCOMPRESSIONTHRESHOLD", "0");
-
             BuildRequestData data = new BuildRequestData(projectFileFullPath, new Dictionary<string, string>(), null, new string[] { "Repro" }, null);
             BuildParameters parameters = new BuildParameters
             {
diff --git a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
index aac9f57f6c6..ce70c6c1a2f 100644
--- a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
@@ -16,7 +16,6 @@ namespace Microsoft.Build.UnitTests
 {
     sealed public class CreateVisualBasicManifestResourceName_Tests
     {
-
         private readonly ITestOutputHelper _testOutput;
 
         public CreateVisualBasicManifestResourceName_Tests(ITestOutputHelper output)
@@ -411,7 +410,7 @@ End Class
         /// <returns>The Stream</returns>
         private Stream CreateFileStream(string path, FileMode mode, FileAccess access)
         {
-            if (String.Compare(path, "SR1.strings", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, "SR1.strings", StringComparison.OrdinalIgnoreCase))
             {
                 return StreamHelpers.StringToStream(
 @"
diff --git a/src/Tasks.UnitTests/FileStateTests.cs b/src/Tasks.UnitTests/FileStateTests.cs
index 2c3654655f6..0c7ed064dbf 100644
--- a/src/Tasks.UnitTests/FileStateTests.cs
+++ b/src/Tasks.UnitTests/FileStateTests.cs
@@ -342,7 +342,7 @@ public void ReadOnlyReset()
         public void ExistsButDirectory()
         {
             Assert.Equal(new FileInfo(Path.GetTempPath()).Exists, new FileState(Path.GetTempPath()).FileExists);
-            Assert.True((new FileState(Path.GetTempPath()).IsDirectory));
+            Assert.True(new FileState(Path.GetTempPath()).IsDirectory);
         }
 
         [Fact]
diff --git a/src/Tasks.UnitTests/GetReferencePaths_Tests.cs b/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
index f8375e81d89..03a50d12ec5 100644
--- a/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
+++ b/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
@@ -328,7 +328,6 @@ public void TestGeneralFrameworkMonikerGoodWithFrameworkInFallbackPaths()
                 Assert.Equal(".NET Framework 4.1", displayName);
             }
         }
-
     }
 }
 #endif
diff --git a/src/Tasks.UnitTests/MSBuild_Tests.cs b/src/Tasks.UnitTests/MSBuild_Tests.cs
index 52973541190..05200fcfac9 100644
--- a/src/Tasks.UnitTests/MSBuild_Tests.cs
+++ b/src/Tasks.UnitTests/MSBuild_Tests.cs
@@ -404,7 +404,6 @@ static void Main(string[] args)
                 }
                 ");
 
-
             // -------------------------------------------------------
             // TeamBuild.proj
             // -------------------------------------------------------
@@ -550,7 +549,6 @@ public void DifferentGlobalPropertiesWithoutDefault()
             }
         }
 
-
         /// <summary>
         /// Check if passing different global properties via metadata works
         /// </summary>
@@ -606,7 +604,6 @@ public void DifferentGlobalPropertiesWithBlanks()
             }
         }
 
-
         /// <summary>
         /// Check if passing different global properties via metadata works
         /// </summary>
@@ -711,7 +708,6 @@ public void DifferentAdditionalPropertiesWithDefault()
             }
         }
 
-
         /// <summary>
         /// Check if passing additional global properties via metadata works
         /// </summary>
@@ -770,7 +766,6 @@ public void DifferentAdditionalPropertiesWithGlobalProperties()
             }
         }
 
-
         /// <summary>
         /// Check if passing additional global properties via metadata works
         /// </summary>
@@ -1433,7 +1428,7 @@ public void MSBuildTaskPassesTaskIdToSpawnedBuilds()
 
                 var expectedTaskId = logger.TaskStartedEvents.First(t => t.TaskName == "MSBuild").BuildEventContext.TaskId;
                 var actualTaskId = logger.ProjectStartedEvents
-                    .Where(p => p.ParentProjectBuildEventContext != null && p.ParentProjectBuildEventContext.TaskId > 0)
+                    .Where(p => p.ParentProjectBuildEventContext?.TaskId > 0)
                     .First()
                     .ParentProjectBuildEventContext.TaskId;
 
@@ -1469,7 +1464,7 @@ public void CustomTaskWithBuildProjectFilePassesTaskId()
 
                 var expectedTaskId = logger.TaskStartedEvents.First(t => t.TaskName == nameof(BuildProjectFileTask)).BuildEventContext.TaskId;
                 var actualTaskId = logger.ProjectStartedEvents
-                    .Where(p => p.ParentProjectBuildEventContext != null && p.ParentProjectBuildEventContext.TaskId > 0)
+                    .Where(p => p.ParentProjectBuildEventContext?.TaskId > 0)
                     .First()
                     .ParentProjectBuildEventContext.TaskId;
 
diff --git a/src/Tasks.UnitTests/MockTypeInfo.cs b/src/Tasks.UnitTests/MockTypeInfo.cs
index 24925449ae8..e81e2638b43 100644
--- a/src/Tasks.UnitTests/MockTypeInfo.cs
+++ b/src/Tasks.UnitTests/MockTypeInfo.cs
@@ -392,11 +392,11 @@ public void GetFuncDesc(int index, out IntPtr ppFuncDesc)
             {
                 ELEMDESC elemDesc = new ELEMDESC();
                 elemDesc.tdesc = _definedFunctions[index].parameters[i].CreateTypeDesc(
-                    new IntPtr(index * s_HREF_FUNCSPARAM_OFFSET_PERFUNC + i + s_HREF_FUNCSPARAM_OFFSET), _memoryHelper);
+                    new IntPtr((index * s_HREF_FUNCSPARAM_OFFSET_PERFUNC) + i + s_HREF_FUNCSPARAM_OFFSET), _memoryHelper);
 
                 Marshal.StructureToPtr(
                     elemDesc,
-                    new IntPtr(funcDesc.lprgelemdescParam.ToInt64() + i * Marshal.SizeOf<ELEMDESC>()),
+                    new IntPtr(funcDesc.lprgelemdescParam.ToInt64() + (i * Marshal.SizeOf<ELEMDESC>())),
                     false);
             }
 
diff --git a/src/Tasks.UnitTests/Move_Tests.cs b/src/Tasks.UnitTests/Move_Tests.cs
index c5a56f24f1e..298548b0fbf 100644
--- a/src/Tasks.UnitTests/Move_Tests.cs
+++ b/src/Tasks.UnitTests/Move_Tests.cs
@@ -29,7 +29,7 @@ public void BasicMove()
                 using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))
                     sw.Write("This is a source temp file.");
                 FileInfo file = new FileInfo(sourceFile);
-                file.Attributes = file.Attributes | FileAttributes.ReadOnly; // mark read only
+                file.Attributes |= FileAttributes.ReadOnly; // mark read only
 
                 ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
                 ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
@@ -71,7 +71,7 @@ public void BasicMoveOverwriteReadOnlyFilesTrue()
                 using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))
                     sw.Write("This is a source temp file.");
                 FileInfo file = new FileInfo(sourceFile);
-                file.Attributes = file.Attributes | FileAttributes.ReadOnly; // mark read only
+                file.Attributes |= FileAttributes.ReadOnly; // mark read only
 
                 ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
                 ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
@@ -98,7 +98,7 @@ public void BasicMoveOverwriteReadOnlyFilesTrue()
                 if (File.Exists(sourceFile))
                 {
                     FileInfo file = new FileInfo(sourceFile);
-                    file.Attributes = file.Attributes & ~FileAttributes.ReadOnly; // mark read only
+                    file.Attributes &= ~FileAttributes.ReadOnly; // mark read only
                     File.Delete(sourceFile);
                 }
 
@@ -206,7 +206,7 @@ public void MoveOverExistingFileReadOnlyNoOverwrite()
                 ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
 
                 FileInfo file = new FileInfo(destinationFile);
-                file.Attributes = file.Attributes | FileAttributes.ReadOnly; // mark destination read only
+                file.Attributes |= FileAttributes.ReadOnly; // mark destination read only
 
                 Move t = new Move();
                 t.BuildEngine = new MockEngine(true /* log to console */);
@@ -230,7 +230,7 @@ public void MoveOverExistingFileReadOnlyNoOverwrite()
                 File.Delete(sourceFile);
 
                 FileInfo file = new FileInfo(destinationFile);
-                file.Attributes = file.Attributes ^ FileAttributes.ReadOnly; // mark destination writable only
+                file.Attributes ^= FileAttributes.ReadOnly; // mark destination writable only
                 File.Delete(destinationFile);
             }
         }
@@ -301,7 +301,7 @@ public void MoveOverExistingFileOverwriteReadOnly()
                 ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
 
                 FileInfo file = new FileInfo(destinationFile);
-                file.Attributes = file.Attributes & ~FileAttributes.ReadOnly; // mark not read only
+                file.Attributes &= ~FileAttributes.ReadOnly; // mark not read only
 
                 Move t = new Move();
                 t.OverwriteReadOnlyFiles = true;
@@ -349,7 +349,7 @@ public void MoveOverExistingFileOverwriteReadOnlyOverWriteReadOnlyFilesTrue()
                 ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
 
                 FileInfo file = new FileInfo(destinationFile);
-                file.Attributes = file.Attributes | FileAttributes.ReadOnly; // mark read only
+                file.Attributes |= FileAttributes.ReadOnly; // mark read only
 
                 Move t = new Move();
                 t.OverwriteReadOnlyFiles = true;
diff --git a/src/Tasks.UnitTests/ResolveComReference_Tests.cs b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
index 41bedd6cf66..ffac905d430 100644
--- a/src/Tasks.UnitTests/ResolveComReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
@@ -38,7 +38,7 @@ private TaskItem SetupTaskItem()
 
         private void AssertReference(ITaskItem item, bool valid, string attribute)
         {
-            string missingOrInvalidAttribute = null;
+            string missingOrInvalidAttribute;
             Assert.Equal(ResolveComReference.VerifyReferenceMetadataForNameItem(item, out missingOrInvalidAttribute), valid);
             Assert.Equal(missingOrInvalidAttribute, attribute);
         }
@@ -218,7 +218,7 @@ public void CheckTaskItemToTypeLibAttr()
         }
 
         /// <summary>
-        /// Helper function for creating a ComReferenceInfo object using an existing TaskInfo object and 
+        /// Helper function for creating a ComReferenceInfo object using an existing TaskInfo object and
         /// typelib name/path. The type lib pointer will obviously not be initialized, so this object cannot
         /// be used in any code that uses it.
         /// </summary>
@@ -293,45 +293,45 @@ public void CheckIsExistingProjectReference()
 
             // find the Ax ref, matching with any type of reference - should NOT find it
             bool retValue = rcr.IsExistingProjectReference(axAttr, null, out ComReferenceInfo referenceInfo);
-            Assert.True(retValue == false && referenceInfo == null); // "ActiveX ref should NOT be found for any type of ref"
+            Assert.True(!retValue && referenceInfo == null); // "ActiveX ref should NOT be found for any type of ref"
 
             // find the Ax ref, matching with aximp types - should find it
             retValue = rcr.IsExistingProjectReference(axAttr, ComReferenceTypes.aximp, out referenceInfo);
-            Assert.True(retValue == true && referenceInfo == axRefInfo); // "ActiveX ref should be found for aximp ref types"
+            Assert.True(retValue && referenceInfo == axRefInfo); // "ActiveX ref should be found for aximp ref types"
 
             // find the Ax ref, matching with tlbimp types - should NOT find it
             retValue = rcr.IsExistingProjectReference(axAttr, ComReferenceTypes.tlbimp, out referenceInfo);
-            Assert.True(retValue == false && referenceInfo == null); // "ActiveX ref should NOT be found for tlbimp ref types"
+            Assert.True(!retValue && referenceInfo == null); // "ActiveX ref should NOT be found for tlbimp ref types"
 
 
             // find the Tlb ref, matching with any type of reference - should find it
             retValue = rcr.IsExistingProjectReference(tlbAttr, null, out referenceInfo);
-            Assert.True(retValue == true && referenceInfo == tlbRefInfo); // "Tlb ref should be found for any type of ref"
+            Assert.True(retValue && referenceInfo == tlbRefInfo); // "Tlb ref should be found for any type of ref"
 
             // find the Tlb ref, matching with tlbimp types - should find it
             retValue = rcr.IsExistingProjectReference(tlbAttr, ComReferenceTypes.tlbimp, out referenceInfo);
-            Assert.True(retValue == true && referenceInfo == tlbRefInfo); // "Tlb ref should be found for tlbimp ref types"
+            Assert.True(retValue && referenceInfo == tlbRefInfo); // "Tlb ref should be found for tlbimp ref types"
 
             // find the Tlb ref, matching with pia types - should NOT find it
             retValue = rcr.IsExistingProjectReference(tlbAttr, ComReferenceTypes.primary, out referenceInfo);
-            Assert.True(retValue == false && referenceInfo == null); // "Tlb ref should NOT be found for primary ref types"
+            Assert.True(!retValue && referenceInfo == null); // "Tlb ref should NOT be found for primary ref types"
 
 
             // find the Pia ref, matching with any type of reference - should find it
             retValue = rcr.IsExistingProjectReference(piaAttr, null, out referenceInfo);
-            Assert.True(retValue == true && referenceInfo == piaRefInfo); // "Pia ref should be found for any type of ref"
+            Assert.True(retValue && referenceInfo == piaRefInfo); // "Pia ref should be found for any type of ref"
 
             // find the Pia ref, matching with pia types - should find it
             retValue = rcr.IsExistingProjectReference(piaAttr, ComReferenceTypes.primary, out referenceInfo);
-            Assert.True(retValue == true && referenceInfo == piaRefInfo); // "Pia ref should be found for pia ref types"
+            Assert.True(retValue && referenceInfo == piaRefInfo); // "Pia ref should be found for pia ref types"
 
             // find the Pia ref, matching with pia types - should NOT find it
             retValue = rcr.IsExistingProjectReference(piaAttr, ComReferenceTypes.aximp, out referenceInfo);
-            Assert.True(retValue == false && referenceInfo == null); // "Pia ref should NOT be found for aximp ref types"
+            Assert.True(!retValue && referenceInfo == null); // "Pia ref should NOT be found for aximp ref types"
 
             // try to find a non existing reference
             retValue = rcr.IsExistingProjectReference(notInProjectAttr, null, out referenceInfo);
-            Assert.True(retValue == false && referenceInfo == null); // "not in project ref should not be found"
+            Assert.True(!retValue && referenceInfo == null); // "not in project ref should not be found"
         }
 
         /// <summary>
@@ -356,19 +356,19 @@ public void CheckIsExistingDependencyReference()
 
             // find the Ax ref - should find it
             bool retValue = rcr.IsExistingDependencyReference(axAttr, out ComReferenceInfo referenceInfo);
-            Assert.True(retValue == true && referenceInfo == axRefInfo); // "ActiveX ref should be found"
+            Assert.True(retValue && referenceInfo == axRefInfo); // "ActiveX ref should be found"
 
             // find the Tlb ref - should find it
             retValue = rcr.IsExistingDependencyReference(tlbAttr, out referenceInfo);
-            Assert.True(retValue == true && referenceInfo == tlbRefInfo); // "Tlb ref should be found"
+            Assert.True(retValue && referenceInfo == tlbRefInfo); // "Tlb ref should be found"
 
             // find the Pia ref - should find it
             retValue = rcr.IsExistingDependencyReference(piaAttr, out referenceInfo);
-            Assert.True(retValue == true && referenceInfo == piaRefInfo); // "Pia ref should be found"
+            Assert.True(retValue && referenceInfo == piaRefInfo); // "Pia ref should be found"
 
             // try to find a non existing reference - should not find it
             retValue = rcr.IsExistingDependencyReference(notInProjectAttr, out referenceInfo);
-            Assert.True(retValue == false && referenceInfo == null); // "not in project ref should not be found"
+            Assert.True(!retValue && referenceInfo == null); // "not in project ref should not be found"
 
             // Now, try to resolve a non-existent ComAssemblyReference. 
             string path;
@@ -378,7 +378,7 @@ public void CheckIsExistingDependencyReference()
         }
 
         /// <summary>
-        /// ResolveComReference automatically adds missing tlbimp references for aximp references. 
+        /// ResolveComReference automatically adds missing tlbimp references for aximp references.
         /// This test verifies we actually create the missing references.
         /// </summary>
         [Fact]
@@ -518,18 +518,18 @@ public void CheckSetCopyLocalToFalseOnEmbedInteropTypesAssemblies()
                 }
 
                 // if Private is missing, by default GAC items are CopyLocal=false, non GAC CopyLocal=true
-                Assert.Equal(nonGacNoPrivate.GetMetadata(ItemMetadataNames.copyLocal), (enabledNoPIA ? "false" : "true"));
+                Assert.Equal(nonGacNoPrivate.GetMetadata(ItemMetadataNames.copyLocal), enabledNoPIA ? "false" : "true");
 
-                Assert.Equal(gacNoPrivate.GetMetadata(ItemMetadataNames.copyLocal), (enabledNoPIA ? "false" : "false"));
+                Assert.Equal(gacNoPrivate.GetMetadata(ItemMetadataNames.copyLocal), enabledNoPIA ? "false" : "false");
 
                 // if Private is set, it takes precedence
-                Assert.Equal(nonGacPrivateFalse.GetMetadata(ItemMetadataNames.copyLocal), (enabledNoPIA ? "false" : "false"));
+                Assert.Equal(nonGacPrivateFalse.GetMetadata(ItemMetadataNames.copyLocal), enabledNoPIA ? "false" : "false");
 
-                Assert.Equal(gacPrivateFalse.GetMetadata(ItemMetadataNames.copyLocal), (enabledNoPIA ? "false" : "false"));
+                Assert.Equal(gacPrivateFalse.GetMetadata(ItemMetadataNames.copyLocal), enabledNoPIA ? "false" : "false");
 
-                Assert.Equal(nonGacPrivateTrue.GetMetadata(ItemMetadataNames.copyLocal), (enabledNoPIA ? "false" : "true"));
+                Assert.Equal(nonGacPrivateTrue.GetMetadata(ItemMetadataNames.copyLocal), enabledNoPIA ? "false" : "true");
 
-                Assert.Equal(gacPrivateTrue.GetMetadata(ItemMetadataNames.copyLocal), (enabledNoPIA ? "false" : "true"));
+                Assert.Equal(gacPrivateTrue.GetMetadata(ItemMetadataNames.copyLocal), enabledNoPIA ? "false" : "true");
             }
         }
 
@@ -610,10 +610,9 @@ public void TestCheckForConflictingReferences()
             Assert.True(rcr.CheckForConflictingReferences());
             Assert.Equal(3, rcr.allProjectRefs.Count);
 
-            ComReferenceInfo referenceInfo;
-
+            
             // duplicate refs should not be treated as conflicts
-            referenceInfo = new ComReferenceInfo(tlbRefInfo);
+            ComReferenceInfo referenceInfo = new ComReferenceInfo(tlbRefInfo);
             rcr.allProjectRefs.Add(referenceInfo);
             referenceInfo = new ComReferenceInfo(axRefInfo);
             rcr.allProjectRefs.Add(referenceInfo);
@@ -646,10 +645,10 @@ public void TestCheckForConflictingReferences()
 
         /// <summary>
         /// In order to make ResolveComReferences multitargetable, two properties, ExecuteAsTool
-        /// and SdkToolsPath were added.  In order to have correct behavior when using pre-4.0 
+        /// and SdkToolsPath were added.  In order to have correct behavior when using pre-4.0
         /// toolsversions, ExecuteAsTool must default to true, and the paths to the tools will be the
-        /// v3.5 path.  It is difficult to verify the tool paths in a unit test, however, so 
-        /// this was done by ad hoc testing and will be maintained by the dev suites.  
+        /// v3.5 path.  It is difficult to verify the tool paths in a unit test, however, so
+        /// this was done by ad hoc testing and will be maintained by the dev suites.
         /// </summary>
         [Fact]
         public void MultiTargetingDefaultSetCorrectly()
@@ -662,7 +661,7 @@ public void MultiTargetingDefaultSetCorrectly()
         /// <summary>
         /// When calling AxImp.exe directly, the runtime-callable wrapper needs to be
         /// passed via the /rcw switch, so RCR needs to make sure that the ax reference knows about
-        /// its corresponding TLB wrapper. 
+        /// its corresponding TLB wrapper.
         /// </summary>
         [Fact]
         public void AxReferenceKnowsItsRCWCreateTlb()
@@ -673,7 +672,7 @@ public void AxReferenceKnowsItsRCWCreateTlb()
         /// <summary>
         /// When calling AxImp.exe directly, the runtime-callable wrapper needs to be
         /// passed via the /rcw switch, so RCR needs to make sure that the ax reference knows about
-        /// its corresponding TLB wrapper. 
+        /// its corresponding TLB wrapper.
         /// </summary>
         [Fact]
         public void AxReferenceKnowsItsRCWCreateTlb_IncludeVersion()
@@ -684,7 +683,7 @@ public void AxReferenceKnowsItsRCWCreateTlb_IncludeVersion()
         /// <summary>
         /// When calling AxImp.exe directly, the runtime-callable wrapper needs to be
         /// passed via the /rcw switch, so RCR needs to make sure that the ax reference knows about
-        /// its corresponding TLB wrapper. 
+        /// its corresponding TLB wrapper.
         /// </summary>
         [Fact]
         public void AxReferenceKnowsItsRCWTlbExists()
@@ -695,7 +694,7 @@ public void AxReferenceKnowsItsRCWTlbExists()
         /// <summary>
         /// When calling AxImp.exe directly, the runtime-callable wrapper needs to be
         /// passed via the /rcw switch, so RCR needs to make sure that the ax reference knows about
-        /// its corresponding TLB wrapper. 
+        /// its corresponding TLB wrapper.
         ///
         /// Tests that still works when IncludeVersionInInteropName = true
         /// </summary>
@@ -708,7 +707,7 @@ public void AxReferenceKnowsItsRCWTlbExists_IncludeVersion()
         /// <summary>
         /// When calling AxImp.exe directly, the runtime-callable wrapper needs to be
         /// passed via the /rcw switch, so RCR needs to make sure that the ax reference knows about
-        /// its corresponding TLB wrapper. 
+        /// its corresponding TLB wrapper.
         /// </summary>
         [Fact]
         public void AxReferenceKnowsItsRCWPiaExists()
@@ -719,7 +718,7 @@ public void AxReferenceKnowsItsRCWPiaExists()
         /// <summary>
         /// When calling AxImp.exe directly, the runtime-callable wrapper needs to be
         /// passed via the /rcw switch, so RCR needs to make sure that the ax reference knows about
-        /// its corresponding TLB wrapper. 
+        /// its corresponding TLB wrapper.
         ///
         /// Tests that still works when IncludeVersionInInteropName = true
         /// </summary>
@@ -732,8 +731,8 @@ public void AxReferenceKnowsItsRCWPiaExists_IncludeVersion()
         private enum RcwStyle { GenerateTlb, PreexistingTlb, PreexistingPia };
 
         /// <summary>
-        /// Helper method that will new up an AX and matching TLB reference, and verify that the AX reference 
-        /// sets its RCW appropriately. 
+        /// Helper method that will new up an AX and matching TLB reference, and verify that the AX reference
+        /// sets its RCW appropriately.
         /// </summary>
         private void CheckAxReferenceRCWTlbExists(RcwStyle rcwStyle, bool includeVersionInInteropName)
         {
diff --git a/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs b/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
index 5e3385a4c34..c53ea765754 100644
--- a/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
@@ -46,7 +46,7 @@ private void TestVerifyReferenceAttributesHelper(string itemSpec, string project
             ITaskItem reference = CreateReferenceItem(itemSpec, projectGuid, package, name);
 
             ResolveNonMSBuildProjectOutput rvpo = new ResolveNonMSBuildProjectOutput();
-            string missingAttr = null;
+            string missingAttr;
             bool result = rvpo.VerifyReferenceAttributes(reference, out missingAttr);
 
             string message = string.Format("Reference \"{0}\" [project \"{1}\", package \"{2}\", name \"{3}\"], " +
@@ -55,7 +55,7 @@ private void TestVerifyReferenceAttributesHelper(string itemSpec, string project
                 expectedMissingAttribute, missingAttr);
 
             Assert.Equal(result, expectedResult);
-            if (result == false)
+            if (!result)
             {
                 Assert.Equal(missingAttr, expectedMissingAttribute);
             }
@@ -107,7 +107,7 @@ private void TestResolveHelper(string itemSpec, string projectGuid, string packa
                 itemSpec, projectGuid, package, name, xmlString, expectedResult, result, expectedPath, resolvedPath);
 
             Assert.Equal(result, expectedResult);
-            if (result == true)
+            if (result)
             {
                 Assert.Equal(resolvedPath.ItemSpec, expectedPath);
             }
@@ -208,9 +208,7 @@ public void TestManagedCheck()
             Hashtable unresolvedOutputs = null;
             Hashtable resolvedOutputs = null;
             Hashtable projectOutputs = null;
-            ArrayList projectRefs = null;
-
-            projectRefs = new ArrayList();
+            ArrayList projectRefs = new ArrayList();
             projectRefs.Add(CreateReferenceItem("MCDep1.vcproj", "{2F6BBCC3-7111-4116-A68B-000000000000}",
                 "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}", "MCDep1"));
             projectRefs.Add(CreateReferenceItem("MCDep2.vcproj", "{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}",
@@ -237,23 +235,20 @@ public void TestManagedCheck()
         [Trait("Category", "mono-osx-failing")]
         public void TestUnresolvedReferences()
         {
-            Hashtable unresolvedOutputs = null;
-            Hashtable resolvedOutputs = null;
-            Hashtable projectOutputs = null;
-            ArrayList projectRefs = null;
-
-            projectRefs = new ArrayList();
+            ArrayList projectRefs = new ArrayList();
             projectRefs.Add(CreateReferenceItem("MCDep1.vcproj", "{2F6BBCC3-7111-4116-A68B-000000000000}",
                 "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}", "MCDep1"));
             projectRefs.Add(CreateReferenceItem("MCDep2.vcproj", "{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}",
                 "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}", "MCDep2"));
 
             // 1. multiple project refs, none resolvable
-            projectOutputs = new Hashtable();
+            Hashtable projectOutputs = new Hashtable();
             projectOutputs.Add("{11111111-1111-1111-1111-111111111111}", Path.Combine("obj", "wrong.dll"));
             projectOutputs.Add("{11111111-1111-1111-1111-111111111112}", Path.Combine("obj", "wrong2.dll"));
             projectOutputs.Add("{11111111-1111-1111-1111-111111111113}", Path.Combine("obj", "wrong3.dll"));
 
+            Hashtable unresolvedOutputs;
+            Hashtable resolvedOutputs;
             TestUnresolvedReferencesHelper(projectRefs, projectOutputs, out unresolvedOutputs, out resolvedOutputs);
 
             Assert.Empty(resolvedOutputs); // "No resolved refs expected for case 1"
diff --git a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
index 7271638e319..538d017b87b 100644
--- a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
@@ -100,14 +100,13 @@ public void ParseDependsOnString()
         [Fact]
         public void GetUnResolvedDependentSDKs()
         {
-            string[] result = null;
             HashSet<SDKReference> resolvedSDKsEmpty = new HashSet<SDKReference>();
             List<string> dependentSDKsEmpty = new List<string>();
 
             HashSet<SDKReference> resolvedSDKs = new HashSet<SDKReference>() { new SDKReference(new TaskItem(), "bar", "1.0"), new SDKReference(new TaskItem(), "foo", "1.0"), new SDKReference(new TaskItem(), "Newt", "1.0") };
             List<string> dependentSDKs = new List<string>() { "bar, Version=1.0", "bar, Version=2.0", "baz, Version=2.0", "CannotParseMeAsSDK", "newt, version=1.0" };
 
-            result = ResolveSDKReference.GetUnresolvedDependentSDKs(resolvedSDKsEmpty, dependentSDKsEmpty);
+            string[] result = ResolveSDKReference.GetUnresolvedDependentSDKs(resolvedSDKsEmpty, dependentSDKsEmpty);
             Assert.Empty(result);
 
             result = ResolveSDKReference.GetUnresolvedDependentSDKs(new HashSet<SDKReference>(), dependentSDKs);
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
index 307649ce8b6..655a31544a6 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
@@ -396,11 +396,11 @@ public void ForceSomeOutOfDate()
             }
             finally
             {
-                if (null != firstResx) File.Delete(firstResx);
-                if (null != secondResx) File.Delete(secondResx);
-                if (null != cache) File.Delete(cache);
-                if (null != firstResx) File.Delete(Path.ChangeExtension(firstResx, ".resources"));
-                if (null != secondResx) File.Delete(Path.ChangeExtension(secondResx, ".resources"));
+                if (firstResx != null) File.Delete(firstResx);
+                if (secondResx != null) File.Delete(secondResx);
+                if (cache != null) File.Delete(cache);
+                if (firstResx != null) File.Delete(Path.ChangeExtension(firstResx, ".resources"));
+                if (secondResx != null) File.Delete(Path.ChangeExtension(secondResx, ".resources"));
             }
         }
 
@@ -626,8 +626,8 @@ public void NothingOutOfDateExceptAdditionalInput()
             {
                 if (resxFile != null) File.Delete(resxFile);
                 if (resourcesFile != null) File.Delete(resourcesFile);
-                if (additionalInputs != null && additionalInputs[0] != null && File.Exists(additionalInputs[0].ItemSpec)) File.Delete(additionalInputs[0].ItemSpec);
-                if (additionalInputs != null && additionalInputs[1] != null && File.Exists(additionalInputs[1].ItemSpec)) File.Delete(additionalInputs[1].ItemSpec);
+                if (additionalInputs?[0] != null && File.Exists(additionalInputs[0].ItemSpec)) File.Delete(additionalInputs[0].ItemSpec);
+                if (additionalInputs?[1] != null && File.Exists(additionalInputs[1].ItemSpec)) File.Delete(additionalInputs[1].ItemSpec);
             }
         }
 
@@ -1190,10 +1190,8 @@ public void TextToResourcesBadFormat()
                 // another invalid escape, this one more serious, "unsupported or invalid escape character"
                 new string[] {   @"foo=\ujjjjbar", "MSB3569"},
             };
-
-            GenerateResource t = null;
-            string textFile = null;
-
+            GenerateResource t;
+            string textFile;
             foreach (string[] test in tests)
             {
                 t = Utilities.CreateTaskOutOfProc(_output);
@@ -1274,10 +1272,10 @@ public void FailedResXReader()
             }
             finally
             {
-                if (null != resxFile1) File.Delete(resxFile1);
-                if (null != resxFile2) File.Delete(resxFile2);
-                if (null != resourcesFile1) File.Delete(resourcesFile1);
-                if (null != resourcesFile2) File.Delete(resourcesFile2);
+                if (resxFile1 != null) File.Delete(resxFile1);
+                if (resxFile2 != null) File.Delete(resxFile2);
+                if (resourcesFile1 != null) File.Delete(resourcesFile1);
+                if (resourcesFile2 != null) File.Delete(resourcesFile2);
             }
         }
 
@@ -1334,10 +1332,10 @@ public void FailedResXReaderWithAllOutputResourcesSpecified()
             }
             finally
             {
-                if (null != resxFile1) File.Delete(resxFile1);
-                if (null != resxFile2) File.Delete(resxFile2);
-                if (null != resourcesFile1) File.Delete(resourcesFile1);
-                if (null != resourcesFile2) File.Delete(resourcesFile2);
+                if (resxFile1 != null) File.Delete(resxFile1);
+                if (resxFile2 != null) File.Delete(resxFile2);
+                if (resourcesFile1 != null) File.Delete(resourcesFile1);
+                if (resourcesFile2 != null) File.Delete(resourcesFile2);
             }
         }
 
@@ -1419,8 +1417,8 @@ public void InvalidStateFile()
             }
             finally
             {
-                if (null != resxFile) File.Delete(resxFile);
-                if (null != resourcesFile) File.Delete(resourcesFile);
+                if (resxFile != null) File.Delete(resxFile);
+                if (resourcesFile != null) File.Delete(resourcesFile);
             }
         }
 
@@ -1511,7 +1509,7 @@ public void InvalidReference()
                 Assert.False(result);
 
                 // Should have not written any files
-                Assert.True(t.FilesWritten != null && t.FilesWritten.Length == 0);
+                Assert.True(t.FilesWritten?.Length == 0);
                 Assert.False(File.Exists(resourcesFile));
             }
             finally
@@ -1651,8 +1649,7 @@ public void FilesWrittenSet()
 
             Utilities.ExecuteTask(t);
 
-            int i = 0;
-
+            int i;
             for (i = 0; i < 4; i++)
             {
                 Assert.Equal(t.FilesWritten[i].ItemSpec, t.OutputResources[i].ItemSpec);
@@ -2121,10 +2118,10 @@ public void StronglyTypedResourceWithMoreThanOneInputResourceFile()
             }
             finally
             {
-                if (null != resxFile) File.Delete(resxFile);
-                if (null != resxFile2) File.Delete(resxFile2);
-                if (null != resxFile) File.Delete(Path.ChangeExtension(resxFile, ".resources"));
-                if (null != resxFile2) File.Delete(Path.ChangeExtension(resxFile2, ".resources"));
+                if (resxFile != null) File.Delete(resxFile);
+                if (resxFile2 != null) File.Delete(resxFile2);
+                if (resxFile != null) File.Delete(Path.ChangeExtension(resxFile, ".resources"));
+                if (resxFile2 != null) File.Delete(Path.ChangeExtension(resxFile2, ".resources"));
             }
         }
 
@@ -2269,7 +2266,7 @@ public void StronglyTypedResourceFilenameWithoutLanguage()
             }
             finally
             {
-                if (null != txtFile) File.Delete(txtFile);
+                if (txtFile != null) File.Delete(txtFile);
             }
         }
 
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index b3c46b3889b..2beea1736da 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -364,7 +364,6 @@ public void ForceOutOfDateByDeletion()
             Utilities.AssertLogContainsResource(t2, "GenerateResource.ResourceNotFound", t2.Sources[0].ItemSpec);
         }
 
-
         /// <summary>
         ///  Force out-of-date with ShouldRebuildResgenOutputFile on the linked file
         /// </summary>
@@ -803,7 +802,6 @@ public void NothingOutOfDateExceptReference()
 
                 File.GetLastWriteTime(incrementalUpToDate.OutputResources[0].ItemSpec).ShouldBe(firstWriteTime);
 
-
                 _output.WriteLine("** Touch the reference, and repeat, it should now rebuild");
                 DateTime newTime = DateTime.Now + new TimeSpan(0, 1, 0);
                 File.SetLastWriteTime(localSystemDll, newTime);
@@ -890,8 +888,8 @@ public void NothingOutOfDateExceptAdditionalInput()
             {
                 if (resxFile != null) File.Delete(resxFile);
                 if (resourcesFile != null) File.Delete(resourcesFile);
-                if (additionalInputs != null && additionalInputs[0] != null && File.Exists(additionalInputs[0].ItemSpec)) File.Delete(additionalInputs[0].ItemSpec);
-                if (additionalInputs != null && additionalInputs[1] != null && File.Exists(additionalInputs[1].ItemSpec)) File.Delete(additionalInputs[1].ItemSpec);
+                if (additionalInputs?[0] != null && File.Exists(additionalInputs[0].ItemSpec)) File.Delete(additionalInputs[0].ItemSpec);
+                if (additionalInputs?[1] != null && File.Exists(additionalInputs[1].ItemSpec)) File.Delete(additionalInputs[1].ItemSpec);
             }
         }
 
@@ -1164,15 +1162,13 @@ public void StronglyTypedResourcesOutOfDate()
             string resxFile = null;
             string resourcesFile = null;
             string strFile = null;
-            string stateFile = null;
-
             try
             {
                 GenerateResource t = Utilities.CreateTask(_output);
                 resxFile = Utilities.WriteTestResX(false, null, null);
                 resourcesFile = Utilities.GetTempFileName(".resources");
                 strFile = Path.ChangeExtension(resourcesFile, ".cs"); // STR filename should be generated from output not input filename
-                stateFile = Utilities.GetTempFileName(".cache");
+                string stateFile = Utilities.GetTempFileName(".cache");
 
                 // Make sure the .cs file isn't already there.
                 File.Delete(strFile);
@@ -1455,7 +1451,6 @@ public void StronglyTypedResourcesEmitTypeIntoClass()
                 generatedSource.ShouldNotContain("object MyString", "Strongly-typed resource accessor is returning type `object` instead of `string`");
                 generatedSource.ShouldContain("static string MyString");
                 generatedSource.ShouldMatch("//.*Looks up a localized string similar to MyValue", "Couldn't find a comment in the usual format for a string resource.");
-
             }
             finally
             {
@@ -1471,7 +1466,6 @@ public void StronglyTypedResourcesEmitTypeIntoClass()
             }
         }
 
-
         /// <summary>
         ///  STR with resource namespace yields proper output, message (CS)
         /// </summary>
@@ -1543,10 +1537,8 @@ public void TextToResourcesBadFormat()
                 // another invalid escape, this one more serious, "unsupported or invalid escape character"
                 new string[] {   @"foo=\ujjjjbar", "MSB3569"},
             };
-
-            GenerateResource t = null;
-            string textFile = null;
-
+            GenerateResource t;
+            string textFile;
             foreach (string[] test in tests)
             {
                 t = Utilities.CreateTask(_output);
@@ -1623,10 +1615,10 @@ public void FailedResXReader()
             }
             finally
             {
-                if (null != resxFile1) File.Delete(resxFile1);
-                if (null != resxFile2) File.Delete(resxFile2);
-                if (null != resourcesFile1) File.Delete(resourcesFile1);
-                if (null != resourcesFile2) File.Delete(resourcesFile2);
+                if (resxFile1 != null) File.Delete(resxFile1);
+                if (resxFile2 != null) File.Delete(resxFile2);
+                if (resourcesFile1 != null) File.Delete(resourcesFile1);
+                if (resourcesFile2 != null) File.Delete(resourcesFile2);
             }
         }
 
@@ -1680,10 +1672,10 @@ public void FailedResXReaderWithAllOutputResourcesSpecified()
             }
             finally
             {
-                if (null != resxFile1) File.Delete(resxFile1);
-                if (null != resxFile2) File.Delete(resxFile2);
-                if (null != resourcesFile1) File.Delete(resourcesFile1);
-                if (null != resourcesFile2) File.Delete(resourcesFile2);
+                if (resxFile1 != null) File.Delete(resxFile1);
+                if (resxFile2 != null) File.Delete(resxFile2);
+                if (resourcesFile1 != null) File.Delete(resourcesFile1);
+                if (resourcesFile2 != null) File.Delete(resourcesFile2);
             }
         }
 
@@ -1764,8 +1756,8 @@ public void InvalidStateFile()
             }
             finally
             {
-                if (null != resxFile) File.Delete(resxFile);
-                if (null != resourcesFile) File.Delete(resourcesFile);
+                if (resxFile != null) File.Delete(resxFile);
+                if (resourcesFile != null) File.Delete(resourcesFile);
             }
         }
 
@@ -1882,7 +1874,7 @@ public void InvalidReference()
                 Assert.False(result);
 
                 // Should have not written any files
-                Assert.True(t.FilesWritten != null && t.FilesWritten.Length == 0);
+                Assert.True(t.FilesWritten?.Length == 0);
                 Assert.False(File.Exists(resourcesFile));
             }
             finally
@@ -2020,7 +2012,7 @@ public void FilesWrittenSet()
 
             Utilities.ExecuteTask(t);
 
-            int i = 0;
+            int i;
 
             // should be four files written, not including the tlogs
             for (i = 0; i < 4; i++)
@@ -2494,10 +2486,10 @@ public void StronglyTypedResourceWithMoreThanOneInputResourceFile()
             }
             finally
             {
-                if (null != resxFile) File.Delete(resxFile);
-                if (null != resxFile2) File.Delete(resxFile2);
-                if (null != resxFile) File.Delete(Path.ChangeExtension(resxFile, ".resources"));
-                if (null != resxFile2) File.Delete(Path.ChangeExtension(resxFile2, ".resources"));
+                if (resxFile != null) File.Delete(resxFile);
+                if (resxFile2 != null) File.Delete(resxFile2);
+                if (resxFile != null) File.Delete(Path.ChangeExtension(resxFile, ".resources"));
+                if (resxFile2 != null) File.Delete(Path.ChangeExtension(resxFile2, ".resources"));
             }
         }
 
@@ -2636,7 +2628,7 @@ public void StronglyTypedResourceFilenameWithoutLanguage()
             }
             finally
             {
-                if (null != txtFile) File.Delete(txtFile);
+                if (txtFile != null) File.Delete(txtFile);
             }
         }
 
@@ -3279,16 +3271,12 @@ public void ResxValueNewlines(string newline)
             string resxDataName = "DataWithNewline";
             string data = "<data name=\"" + resxDataName + "\">" + newline +
                 "<value>" + resxValue + "</value>" + newline + "</data>";
-
-            string resxFile = null;
-
             GenerateResource t = Utilities.CreateTask(_output);
             t.StateFile = new TaskItem(Utilities.GetTempFileName(".cache"));
 
             try
             {
-                resxFile = Utilities.WriteTestResX(false, null, data);
-
+                string resxFile = Utilities.WriteTestResX(false, null, data);
                 t.Sources = new ITaskItem[] { new TaskItem(resxFile) };
 
                 Utilities.ExecuteTask(t);
@@ -3315,7 +3303,6 @@ public void ResxValueNewlines(string newline)
             }
             finally
             {
-
                 File.Delete(t.Sources[0].ItemSpec);
                 foreach (ITaskItem item in t.FilesWritten)
                 {
@@ -3373,7 +3360,6 @@ GenerateResource ExecuteTask()
                 Utilities.FileUpdated(resourcesFile, initialWriteTime).ShouldBeFalse();
             }
         }
-
     }
 }
 
@@ -3399,7 +3385,7 @@ public static DateTime MoveBackTimestamp(string fileName, int minutes)
         /// </summary>
         public static bool FileUpdated(string fileName, DateTime previousWriteTime)
         {
-            return (File.GetLastWriteTime(fileName) > previousWriteTime);
+            return File.GetLastWriteTime(fileName) > previousWriteTime;
         }
 
         /// <summary>
@@ -3468,7 +3454,7 @@ public static string CreateBasicResourcesFile(bool useResX, ITestOutputHelper ou
         {
             GenerateResource t = CreateTask(output);
 
-            string sourceFile = null;
+            string sourceFile;
             if (useResX)
                 sourceFile = WriteTestResX(false, null, null);
             else
@@ -3498,7 +3484,7 @@ public static void ExecuteTask(GenerateResource t)
             bool success = t.Execute();
             Assert.True(success);
 
-            if (t.OutputResources != null && t.OutputResources[0] != null && t.Sources[0] != null)
+            if (t.OutputResources?[0] != null && t.Sources[0] != null)
             {
                 File.GetLastWriteTime(t.OutputResources[0].ItemSpec).ShouldBeGreaterThanOrEqualTo(File.GetLastWriteTime(t.Sources[0].ItemSpec), $"we're talking here about {t.OutputResources[0].ItemSpec} and {t.Sources[0].ItemSpec}");
             }
@@ -3890,12 +3876,11 @@ public static void STRNamespaceTestHelper(string strLanguage, string resourcesNa
                     Assert.Contains("namespace " + classNamespace.ToLower(), Utilities.ReadFileContent(STRFile).ToLower());
                 }
 
-
                 // Verify log is as expected
                 Utilities.AssertLogContainsResource(t, "GenerateResource.ProcessingFile", textFile, resourcesFile);
                 Utilities.AssertLogContainsResource(t, "GenerateResource.ReadResourceMessage", 4, textFile);
 
-                string typeName = null;
+                string typeName;
                 if (t.StronglyTypedNamespace != null)
                     typeName = t.StronglyTypedNamespace + ".";
                 else
diff --git a/src/Tasks.UnitTests/ResourceHandling/ResGen_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/ResGen_Tests.cs
index 2c1410b61be..a98e8a261b0 100644
--- a/src/Tasks.UnitTests/ResourceHandling/ResGen_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/ResGen_Tests.cs
@@ -317,7 +317,7 @@ public void References()
             t.References = references.ToArray();
 
             commandLineLength = CommandLine.GetCommandLine(t, false).Length;
-            Assert.Equal(commandLineLength, (maxCommandLineLength + 1));
+            Assert.Equal(commandLineLength, maxCommandLineLength + 1);
 
             ExecuteTaskAndVerifyLogContainsErrorFromResource
             (
diff --git a/src/Tasks.UnitTests/ResourceHandling/ResXHelper.cs b/src/Tasks.UnitTests/ResourceHandling/ResXHelper.cs
index 3bf41699346..62414fb64cf 100644
--- a/src/Tasks.UnitTests/ResourceHandling/ResXHelper.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/ResXHelper.cs
@@ -139,6 +139,5 @@ read any of the formats listed below.
 
         private const string FinalBoilerplate = @"</root>
 ";
-
     }
 }
diff --git a/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs b/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
index d2756b09680..96ccee06a50 100644
--- a/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
+++ b/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
@@ -155,6 +155,5 @@ protected internal override void AddResponseFileCommands(CommandLineBuilderExten
                 base.AddResponseFileCommands(commandLine);
             }
         }
-
     }
 }
diff --git a/src/Tasks.UnitTests/Touch_Tests.cs b/src/Tasks.UnitTests/Touch_Tests.cs
index c866e0189dd..df6124e73f8 100644
--- a/src/Tasks.UnitTests/Touch_Tests.cs
+++ b/src/Tasks.UnitTests/Touch_Tests.cs
@@ -111,8 +111,7 @@ private static FileAttributes GetAttributes(string path)
 
             if (path == myreadonly_txt)
             {
-                a = System.IO.FileAttributes.ReadOnly;
-                return a;
+                return System.IO.FileAttributes.ReadOnly;
             }
 
             Assert.True(false, "Unexpected file attributes: " + path);
diff --git a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
index 9e7f41c1eb8..635ccde3e29 100644
--- a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
+++ b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
@@ -619,7 +619,10 @@ public void OneAttributePositionalAndNamedParams()
             string content = File.ReadAllText(task.OutputFile.ItemSpec);
             Console.WriteLine(content);
 
-            CheckContentCSharp(content, @"[assembly: AssemblyTrademarkAttribute(""Microsoft"", Date=""2009"", Copyright=""(C)"")]");
+            // NOTE: order here is defined by dictionary traversal order and may change
+            // based on implementation details there, but named parameters can have different
+            // orders so that's ok.
+            CheckContentCSharp(content, @"[assembly: AssemblyTrademarkAttribute(""Microsoft"", Copyright=""(C)"", Date=""2009"")]");
 
             File.Delete(task.OutputFile.ItemSpec);
         }
diff --git a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
index 7e96b14814a..ab6b6c95d2b 100644
--- a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
+++ b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
@@ -12,7 +12,6 @@
 
 namespace Microsoft.Build.Tasks.UnitTests
 {
-
     public sealed class WriteLinesToFile_Tests
     {
         private readonly ITestOutputHelper _output;
diff --git a/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs b/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
index 8b062bace39..f5f983078e7 100644
--- a/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
@@ -605,7 +605,7 @@ public void TestGenerateReversible()
             object[] attributes = pi.GetCustomAttributes(true);
             foreach (object attribute in attributes)
             {
-                Assert.Equal("/Br", (attribute.GetType().GetProperty("SwitchName").GetValue(attribute, null).ToString()));
+                Assert.Equal("/Br", attribute.GetType().GetProperty("SwitchName").GetValue(attribute, null).ToString());
             }
         }
 
@@ -623,7 +623,7 @@ public void TestGenerateNonreversible()
             object[] attributes = pi.GetCustomAttributes(true);
             foreach (object attribute in attributes)
             {
-                Assert.Equal("/Bn", (attribute.GetType().GetProperty("SwitchName").GetValue(attribute, null).ToString()));
+                Assert.Equal("/Bn", attribute.GetType().GetProperty("SwitchName").GetValue(attribute, null).ToString());
             }
         }
 
@@ -641,7 +641,7 @@ public void TestGenerateStrings()
             object[] attributes = pi.GetCustomAttributes(true);
             foreach (object attribute in attributes)
             {
-                Assert.Equal("/Bs", (attribute.GetType().GetProperty("SwitchName").GetValue(attribute, null).ToString()));
+                Assert.Equal("/Bs", attribute.GetType().GetProperty("SwitchName").GetValue(attribute, null).ToString());
             }
         }
 
@@ -659,7 +659,7 @@ public void TestGenerateIntegers()
             object[] attributes = pi.GetCustomAttributes(true);
             foreach (object attribute in attributes)
             {
-                Assert.Equal("/Bi", (attribute.GetType().GetProperty("SwitchName").GetValue(attribute, null).ToString()));
+                Assert.Equal("/Bi", attribute.GetType().GetProperty("SwitchName").GetValue(attribute, null).ToString());
             }
         }
 
@@ -680,7 +680,7 @@ public void TestGenerateStringArrays()
                 PropertyInfo documentationAttribute = attribute.GetType().GetProperty("SwitchName");
                 if (documentationAttribute != null)
                 {
-                    Assert.Equal("/Bsa", (attribute.GetType().GetProperty("SwitchName").GetValue(attribute, null).ToString()));
+                    Assert.Equal("/Bsa", attribute.GetType().GetProperty("SwitchName").GetValue(attribute, null).ToString());
                 }
                 else
                 {
diff --git a/src/Tasks.UnitTests/XmlPoke_Tests.cs b/src/Tasks.UnitTests/XmlPoke_Tests.cs
index a77409a28fc..b57cd585398 100644
--- a/src/Tasks.UnitTests/XmlPoke_Tests.cs
+++ b/src/Tasks.UnitTests/XmlPoke_Tests.cs
@@ -16,6 +16,7 @@
 using System.Text;
 using System.Xml;
 using Xunit;
+using Shouldly;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -111,6 +112,22 @@ public void PokeChildren()
             Assert.Equal("Testing", testNodes?.First().InnerText);
         }
 
+        [Fact]
+        public void PokeAttributeWithCondition()
+        {
+            const string original = "b";
+            const string value = "x";
+            const string queryTemplate = "/class/variable[@Name='{0}']/@Name";
+
+            XmlDocument xmlDocument = ExecuteXmlPoke(query: string.Format(queryTemplate, original), value: value);
+
+            List<XmlAttribute> nodes = xmlDocument.SelectNodes(string.Format(queryTemplate, value))?.Cast<XmlAttribute>().ToList();
+
+            nodes?.Count.ShouldBe(1, $"There should be 1 <class /> element with an AccessModifier attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            nodes?[0].Value.ShouldBe(value);
+        }
+
         [Fact]
         public void PokeMissingParams()
         {
diff --git a/src/Tasks.UnitTests/XslTransformation_Tests.cs b/src/Tasks.UnitTests/XslTransformation_Tests.cs
index 9aaecf85ef9..d08e6867a74 100644
--- a/src/Tasks.UnitTests/XslTransformation_Tests.cs
+++ b/src/Tasks.UnitTests/XslTransformation_Tests.cs
@@ -527,7 +527,7 @@ public void CompiledDllWithType()
                 t.BuildEngine = engine;
                 t.OutputPaths = outputPaths;
                 t.XmlContent = _xmlDocument;
-                xslCompiledPath.ItemSpec = xslCompiledPath.ItemSpec + ";xslt";
+                xslCompiledPath.ItemSpec += ";xslt";
                 t.XslCompiledDllPath = xslCompiledPath;
                 Assert.Equal(xslCompiledPath.ItemSpec, t.XslCompiledDllPath.ItemSpec);
                 Assert.True(t.Execute()); // "XsltComiledDll1 execution should've passed"
@@ -648,7 +648,7 @@ public void MissingXmlFile()
                 XslTransformation t = new XslTransformation();
                 t.BuildEngine = engine;
                 t.OutputPaths = outputPaths;
-                xmlPaths[0].ItemSpec = xmlPaths[0].ItemSpec + "bad";
+                xmlPaths[0].ItemSpec += "bad";
                 t.XmlInputPaths = xmlPaths;
                 t.XslInputPath = xslPath;
                 Console.WriteLine(engine.Log);
@@ -678,7 +678,7 @@ public void MissingXsltFile()
                 t.BuildEngine = engine;
                 t.OutputPaths = outputPaths;
                 t.XmlInputPaths = xmlPaths;
-                xslPath.ItemSpec = xslPath.ItemSpec + "bad";
+                xslPath.ItemSpec += "bad";
                 t.XslInputPath = xslPath;
                 Assert.False(t.Execute()); // "This test should've failed (bad xslt)."
                 Console.WriteLine(engine.Log);
@@ -707,7 +707,7 @@ public void MissingCompiledDllFile()
                 t.BuildEngine = engine;
                 t.OutputPaths = outputPaths;
                 t.XmlContent = _xmlDocument;
-                xslCompiledPath.ItemSpec = xslCompiledPath.ItemSpec + "bad;xslt";
+                xslCompiledPath.ItemSpec += "bad;xslt";
                 t.XslCompiledDllPath = xslCompiledPath;
                 Assert.False(t.Execute()); // "XsltComiledDllBad execution should've failed"
                 Console.WriteLine(engine.Log);
@@ -1126,16 +1126,12 @@ private void Compile(string inputFile, string outputFile)
 
             // Create TypeBuilder and compile the stylesheet into it
             TypeBuilder typeBldr = modBldr.DefineType(CompiledQueryName, TypeAttributes.Public | TypeAttributes.Abstract | TypeAttributes.Sealed | TypeAttributes.BeforeFieldInit);
-
-            CompilerErrorCollection errors = null;
             try
             {
-                using (XmlReader reader = XmlReader.Create(sourceUri, readerSettings))
-                {
-                    errors = XslCompiledTransform.CompileToType(
-                        reader, xsltSettings, xmlResolver, false, typeBldr, scriptAsmPath
-                    );
-                }
+                using XmlReader reader = XmlReader.Create(sourceUri, readerSettings);
+                CompilerErrorCollection errors = XslCompiledTransform.CompileToType(reader, xsltSettings,
+                                                                                    xmlResolver, false, typeBldr,
+                                                                                    scriptAsmPath);
             }
             catch (Exception e)
             {
diff --git a/src/Tasks/AppConfig/AppConfig.cs b/src/Tasks/AppConfig/AppConfig.cs
index ce4f0954256..88df2dd738b 100644
--- a/src/Tasks/AppConfig/AppConfig.cs
+++ b/src/Tasks/AppConfig/AppConfig.cs
@@ -95,7 +95,7 @@ internal void Read(XmlReader reader)
         /// <returns></returns>
         internal static bool StringEquals(string a, string b)
         {
-            return String.Compare(a, b, StringComparison.OrdinalIgnoreCase) == 0;
+            return String.Equals(a, b, StringComparison.OrdinalIgnoreCase);
         }
     }
 }
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
index dc63978daaf..ab6b685ba91 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
@@ -187,6 +187,7 @@ private void LazyInitialize()
         /// Resolve a reference to a specific file name.
         /// </summary>
         /// <param name="assemblyName">The assemblyname of the reference.</param>
+        /// <param name="sdkName">The sdkname of the reference.</param>
         /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
         /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
         /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
@@ -307,11 +308,11 @@ internal AssemblyFoldersExCache(AssemblyFoldersEx assemblyFoldersEx, FileExists
             {
                 var lockobject = new Object();
 
-                Parallel.ForEach(assemblyFoldersEx, assemblyFolder =>
+                Parallel.ForEach(assemblyFoldersEx.UniqueDirectoryPaths, assemblyFolder =>
                 {
-                    if (FileUtilities.DirectoryExistsNoThrow(assemblyFolder.DirectoryPath))
+                    if (FileUtilities.DirectoryExistsNoThrow(assemblyFolder))
                     {
-                        string[] files = Directory.GetFiles(assemblyFolder.DirectoryPath, "*.*", SearchOption.TopDirectoryOnly);
+                        string[] files = Directory.GetFiles(assemblyFolder, "*.*", SearchOption.TopDirectoryOnly);
 
                         lock (lockobject)
                         {
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
index 992cd1ba6fd..dced5e5453e 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
@@ -18,6 +18,8 @@ internal class AssemblyFoldersResolver : Resolver
         /// <param name="searchPathElement"></param>
         /// <param name="getAssemblyName"></param>
         /// <param name="fileExists"></param>
+        /// <param name="getRuntimeVersion"></param>
+        /// <param name="targetedRuntimeVesion"></param>
         public AssemblyFoldersResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
             : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
         {
@@ -27,6 +29,7 @@ public AssemblyFoldersResolver(string searchPathElement, GetAssemblyName getAsse
         /// Resolve a reference to a specific file name.
         /// </summary>
         /// <param name="assemblyName">The assemblyname of the reference.</param>
+        /// <param name="sdkName">The sdk name of the reference.</param>
         /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
         /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
         /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
diff --git a/src/Tasks/AssemblyDependency/AssemblyInformation.cs b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
index 5acebabb7eb..b7c394ebe42 100644
--- a/src/Tasks/AssemblyDependency/AssemblyInformation.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
@@ -558,7 +558,7 @@ internal static string GetRuntimeVersion(string path)
                 {
                     runtimeVersion = new StringBuilder(bufferLength);
                     hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out _);
-                    bufferLength = bufferLength * 2;
+                    bufferLength *= 2;
                 } while (hresult == NativeMethodsShared.ERROR_INSUFFICIENT_BUFFER);
 
                 if (hresult == NativeMethodsShared.S_OK)
diff --git a/src/Tasks/AssemblyDependency/AssemblyResolution.cs b/src/Tasks/AssemblyDependency/AssemblyResolution.cs
index e9cc3fafc42..f2fe396824f 100644
--- a/src/Tasks/AssemblyDependency/AssemblyResolution.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyResolution.cs
@@ -99,6 +99,7 @@ out userRequestedSpecificFile
             return null;
         }
 
+#if FEATURE_WIN32_REGISTRY
         /// <summary>
         /// Compile search paths into an array of resolvers.
         /// </summary>
@@ -118,6 +119,24 @@ out userRequestedSpecificFile
         /// <param name="getAssemblyPathInGac"></param>
         /// <param name="log"></param>
         /// <returns></returns>
+#else
+        /// <summary>
+        /// Compile search paths into an array of resolvers.
+        /// </summary>
+        /// <param name="buildEngine"></param>
+        /// <param name="searchPaths"></param>
+        /// <param name="candidateAssemblyFiles">Paths to assembly files mentioned in the project.</param>
+        /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64, the processor architecture being targetted.</param>
+        /// <param name="frameworkPaths">Paths to FX folders.</param>
+        /// <param name="fileExists"></param>
+        /// <param name="getAssemblyName"></param>
+        /// <param name="installedAssemblies"></param>
+        /// <param name="getRuntimeVersion"></param>
+        /// <param name="targetedRuntimeVersion"></param>
+        /// <param name="getAssemblyPathInGac"></param>
+        /// <param name="log"></param>
+        /// <returns></returns>
+#endif
         public static Resolver[] CompileSearchPaths
         (
             IBuildEngine buildEngine,
@@ -147,29 +166,29 @@ TaskLoggingHelper log
 
                 // Was {HintPathFromItem} specified? If so, take the Item's
                 // HintPath property.
-                if (0 == String.Compare(basePath, AssemblyResolutionConstants.hintPathSentinel, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(basePath, AssemblyResolutionConstants.hintPathSentinel, StringComparison.OrdinalIgnoreCase))
                 {
                     resolvers[p] = new HintPathResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
                 }
-                else if (0 == String.Compare(basePath, AssemblyResolutionConstants.frameworkPathSentinel, StringComparison.OrdinalIgnoreCase))
+                else if (String.Equals(basePath, AssemblyResolutionConstants.frameworkPathSentinel, StringComparison.OrdinalIgnoreCase))
                 {
                     resolvers[p] = new FrameworkPathResolver(frameworkPaths, installedAssemblies, searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
                 }
-                else if (0 == String.Compare(basePath, AssemblyResolutionConstants.rawFileNameSentinel, StringComparison.OrdinalIgnoreCase))
+                else if (String.Equals(basePath, AssemblyResolutionConstants.rawFileNameSentinel, StringComparison.OrdinalIgnoreCase))
                 {
                     resolvers[p] = new RawFilenameResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
                 }
-                else if (0 == String.Compare(basePath, AssemblyResolutionConstants.candidateAssemblyFilesSentinel, StringComparison.OrdinalIgnoreCase))
+                else if (String.Equals(basePath, AssemblyResolutionConstants.candidateAssemblyFilesSentinel, StringComparison.OrdinalIgnoreCase))
                 {
                     resolvers[p] = new CandidateAssemblyFilesResolver(candidateAssemblyFiles, searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
                 }
 #if FEATURE_GAC
-                else if (0 == String.Compare(basePath, AssemblyResolutionConstants.gacSentinel, StringComparison.OrdinalIgnoreCase))
+                else if (String.Equals(basePath, AssemblyResolutionConstants.gacSentinel, StringComparison.OrdinalIgnoreCase))
                 {
                     resolvers[p] = new GacResolver(targetProcessorArchitecture, searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion, getAssemblyPathInGac);
                 }
 #endif
-                else if (0 == String.Compare(basePath, AssemblyResolutionConstants.assemblyFoldersSentinel, StringComparison.OrdinalIgnoreCase))
+                else if (String.Equals(basePath, AssemblyResolutionConstants.assemblyFoldersSentinel, StringComparison.OrdinalIgnoreCase))
                 {
                     resolvers[p] = new AssemblyFoldersResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
                 }
diff --git a/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs b/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
index 066901110f3..eb126f0656a 100644
--- a/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
+++ b/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
@@ -26,6 +26,8 @@ internal class CandidateAssemblyFilesResolver : Resolver
         /// <param name="searchPathElement"></param>
         /// <param name="getAssemblyName"></param>
         /// <param name="fileExists"></param>
+        /// <param name="getRuntimeVersion"></param>
+        /// <param name="targetedRuntimeVesion"></param>
         public CandidateAssemblyFilesResolver(string[] candidateAssemblyFiles, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
             : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false)
         {
diff --git a/src/Tasks/AssemblyDependency/CopyLocalState.cs b/src/Tasks/AssemblyDependency/CopyLocalState.cs
index ffc77ba7845..5f0cdbf64e0 100644
--- a/src/Tasks/AssemblyDependency/CopyLocalState.cs
+++ b/src/Tasks/AssemblyDependency/CopyLocalState.cs
@@ -36,7 +36,7 @@ internal enum CopyLocalState
         NoBecausePrerequisite,
 
         /// <summary>
-        /// The Reference should be CopyLocal='false' because the the Private attribute is set to 'false' in the project. 
+        /// The Reference should be CopyLocal='false' because the Private attribute is set to 'false' in the project.
         /// </summary>
         NoBecauseReferenceItemHadMetadata,
 
diff --git a/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs b/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
index e361f78e0ed..bfee4b6dc71 100644
--- a/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
+++ b/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
@@ -88,7 +88,7 @@ internal static AssemblyNameExtension GetHighestVersionInRedist(InstalledAssembl
         {
             AssemblyNameExtension assemblyNameToUse = assemblyName;
 
-            if ((assemblyNameToUse.Version == null && installedAssemblies != null))
+            if (assemblyNameToUse.Version == null && installedAssemblies != null)
             {
                 // If there are multiple entries in the redist list for this assembly, let's
                 // pick the one with the highest version and resolve it.
@@ -97,7 +97,7 @@ internal static AssemblyNameExtension GetHighestVersionInRedist(InstalledAssembl
                     var current = new AssemblyNameExtension(a.FullName);
 
                     // If the current version is higher than the previously looked at.
-                    if (current.Version != null && current.Version.CompareTo(assemblyNameToUse.Version) > 0)
+                    if (current.Version?.CompareTo(assemblyNameToUse.Version) > 0)
                     {
                         // Only compare the Culture and the public key token, the simple names will ALWAYS be the same and the version we do not care about.
                         if (assemblyName.PartialNameCompare(current, PartialComparisonFlags.Culture | PartialComparisonFlags.PublicKeyToken))
diff --git a/src/Tasks/AssemblyDependency/GacResolver.cs b/src/Tasks/AssemblyDependency/GacResolver.cs
index a8b77e6a55a..16342d58a31 100644
--- a/src/Tasks/AssemblyDependency/GacResolver.cs
+++ b/src/Tasks/AssemblyDependency/GacResolver.cs
@@ -43,7 +43,7 @@ public GacResolver(System.Reflection.ProcessorArchitecture targetProcessorArchit
         /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
         /// <param name="executableExtensions">Allowed executable extensions.</param>
         /// <param name="hintPath">The item's hintpath value.</param>
-        /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the <AssemblyFolderKey> on the reference in the project.</param>
+        /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
         /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
         /// <param name="foundPath">The path where the file was found.</param>
         /// <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
diff --git a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
index 567e98ca889..96b53b98a28 100644
--- a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
+++ b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
@@ -113,7 +113,6 @@ public override bool Execute()
                     {
                         writeOutput = false;
                     }
-
                 }
                 catch(System.Xml.XmlException)
                 {
@@ -121,7 +120,6 @@ public override bool Execute()
                 }
             }
 
-
             if (AppConfigFile != null)
             {
                 AppConfigFile.CopyMetadataTo(OutputAppConfigFile);
@@ -148,7 +146,7 @@ public override bool Execute()
         /// </summary>
         private static bool IsMatch(AssemblyName suggestedRedirect, string name, string culture, string publicKeyToken)
         {
-            if (String.Compare(suggestedRedirect.Name, name, StringComparison.OrdinalIgnoreCase) != 0)
+            if (!String.Equals(suggestedRedirect.Name, name, StringComparison.OrdinalIgnoreCase))
             {
                 return false;
             }
@@ -168,7 +166,7 @@ private static bool IsMatch(AssemblyName suggestedRedirect, string name, string
             }
 
             if (!String.IsNullOrEmpty(culture) &&
-                String.Compare(cultureString, culture, StringComparison.OrdinalIgnoreCase) != 0)
+                !String.Equals(cultureString, culture, StringComparison.OrdinalIgnoreCase))
             {
                 return false;
             }
@@ -181,7 +179,7 @@ private static bool IsMatch(AssemblyName suggestedRedirect, string name, string
         /// </summary>
         private static bool ByteArrayMatchesString(Byte[] a, string s)
         {
-            return String.Compare(ResolveAssemblyReference.ByteArrayToString(a), s, StringComparison.OrdinalIgnoreCase) != 0;
+            return !String.Equals(ResolveAssemblyReference.ByteArrayToString(a), s, StringComparison.OrdinalIgnoreCase);
         }
 
         /// <summary>
@@ -351,7 +349,7 @@ private XDocument LoadAppConfig(ITaskItem appConfigItem)
         /// </summary>
         private IDictionary<AssemblyName, string> ParseSuggestedRedirects()
         {
-            ErrorUtilities.VerifyThrow(SuggestedRedirects != null && SuggestedRedirects.Length > 0, "This should not be called if there is no suggested redirect.");
+            ErrorUtilities.VerifyThrow(SuggestedRedirects?.Length > 0, "This should not be called if there is no suggested redirect.");
 
             var map = new Dictionary<AssemblyName, string>();
             foreach (var redirect in SuggestedRedirects)
diff --git a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
index bd27d48ab41..b0da1661f29 100644
--- a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
+++ b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
@@ -34,6 +34,12 @@ internal static class GlobalAssemblyCache
         /// </summary>
         /// <param name="assemblyName">The assembly name.</param>
         /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64.</param>
+        /// <param name="getRuntimeVersion">Delegate to get the clr version of the file.</param>
+        /// <param name="targetedRuntime">Version of the targetted runtime.</param>
+        /// <param name="fileExists">Delegate to check whether the file exists.</param>
+        /// <param name="getPathFromFusionName">Delegate to get path to a file based on the fusion name.</param>
+        /// <param name="getGacEnumerator">Delegate to get the enumerator which will enumerate over the GAC.</param>
+        /// <param name="specificVersion">Whether to check for a specific version.</param>
         /// <returns>The path to the assembly. Empty if none exists.</returns>
         private static string GetLocationImpl(AssemblyNameExtension assemblyName, string targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntime, FileExists fileExists, GetPathFromFusionName getPathFromFusionName, GetGacEnumerator getGacEnumerator, bool specificVersion)
         {
@@ -128,7 +134,7 @@ private static SortedDictionary<Version, SortedDictionary<AssemblyNameExtension,
                         {
                             if (targetedRuntime.CompareTo(runtimeVersion) >= 0 || specificVersion)
                             {
-                                SortedDictionary<AssemblyNameExtension, string> assembliesWithRuntime = null;
+                                SortedDictionary<AssemblyNameExtension, string> assembliesWithRuntime;
                                 assembliesWithValidRuntimes.TryGetValue(runtimeVersion, out assembliesWithRuntime);
 
                                 // Create a new list if one does not exist.
@@ -211,7 +217,11 @@ private static string CheckForFullFusionNameInGac(AssemblyNameExtension assembly
         /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64.</param>
         /// <param name="getRuntimeVersion">Delegate to get the runtime version from a file path</param>
         /// <param name="targetedRuntimeVersion">What version of the runtime are we targeting</param>
-        /// <param name="fullFusionName">Are we guranteed to have a full fusion name. This really can only happen if we have already resolved the assembly</param>
+        /// <param name="fullFusionName">Are we guaranteed to have a full fusion name. This really can only happen if we have already resolved the assembly</param>
+        /// <param name="fileExists">Delegate to check whether the file exists.</param>
+        /// <param name="getPathFromFusionName">Delegate to get path to a file based on the fusion name.</param>
+        /// <param name="getGacEnumerator">Delegate to get the enumerator which will enumerate over the GAC.</param>
+        /// <param name="specificVersion">Whether to check for a specific version.</param>
         /// <returns>The path to the assembly. Empty if none exists.</returns>
         internal static string GetLocation
         (
@@ -232,11 +242,16 @@ bool specificVersion
         /// <summary>
         /// Given a strong name, find its path in the GAC.
         /// </summary>
+        /// <param name="buildEngine">The build engine</param>
         /// <param name="strongName">The strong name.</param>
         /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64.</param>
         /// <param name="getRuntimeVersion">Delegate to get the runtime version from a file path</param>
         /// <param name="targetedRuntimeVersion">What version of the runtime are we targeting</param>
         /// <param name="fullFusionName">Are we guranteed to have a full fusion name. This really can only happen if we have already resolved the assembly</param>
+        /// <param name="fileExists">Delegate to check whether the file exists.</param>
+        /// <param name="getPathFromFusionName">Delegate to get path to a file based on the fusion name.</param>
+        /// <param name="getGacEnumerator">Delegate to get the enumerator which will enumerate over the GAC.</param>
+        /// <param name="specificVersion">Whether to check for a specific version.</param>
         /// <returns>The path to the assembly. Empty if none exists.</returns>
         internal static string GetLocation
         (
@@ -284,10 +299,10 @@ bool specificVersion
             }
 
             // A delegate was not passed in to use the default one
-            getPathFromFusionName = getPathFromFusionName ?? pathFromFusionName;
+            getPathFromFusionName ??= pathFromFusionName;
 
             // A delegate was not passed in to use the default one
-            getGacEnumerator = getGacEnumerator ?? gacEnumerator;
+            getGacEnumerator ??= gacEnumerator;
 
             // If we have no processor architecture set then we can tryout a number of processor architectures.
             string location;
diff --git a/src/Tasks/AssemblyDependency/Reference.cs b/src/Tasks/AssemblyDependency/Reference.cs
index 69e0aeeea4f..c9761c6d469 100644
--- a/src/Tasks/AssemblyDependency/Reference.cs
+++ b/src/Tasks/AssemblyDependency/Reference.cs
@@ -240,7 +240,6 @@ internal void RemoveDependency(Reference dependencyToRemove)
             _dependencies.Remove(dependencyToRemove);
         }
 
-
         /// <summary>
         /// Get the dependee references for this reference.
         ///  This is collection of References.
@@ -494,7 +493,7 @@ internal string FullPath
                     _fileNameWithoutExtension = null;
                     _directoryName = null;
 
-                    if (_fullPath == null || _fullPath.Length == 0)
+                    if (string.IsNullOrEmpty(_fullPath))
                     {
                         _scatterFiles = Array.Empty<string>();
                         _satelliteFiles = new List<string>();
@@ -522,7 +521,7 @@ internal string DirectoryName
         {
             get
             {
-                if ((_directoryName == null || _directoryName.Length == 0) && (_fullPath != null && _fullPath.Length != 0))
+                if ((string.IsNullOrEmpty(_directoryName)) && (!string.IsNullOrEmpty(_fullPath)))
                 {
                     _directoryName = Path.GetDirectoryName(_fullPath);
                     if (_directoryName.Length == 0)
@@ -542,7 +541,7 @@ internal string FileNameWithoutExtension
         {
             get
             {
-                if ((_fileNameWithoutExtension == null || _fileNameWithoutExtension.Length == 0) && (_fullPath != null && _fullPath.Length != 0))
+                if ((string.IsNullOrEmpty(_fileNameWithoutExtension)) && (!string.IsNullOrEmpty(_fullPath)))
                 {
                     _fileNameWithoutExtension = Path.GetFileNameWithoutExtension(_fullPath);
                 }
@@ -557,7 +556,7 @@ internal string FullPathWithoutExtension
         {
             get
             {
-                if ((_fullPathWithoutExtension == null || _fullPathWithoutExtension.Length == 0) && (_fullPath != null && _fullPath.Length != 0))
+                if ((string.IsNullOrEmpty(_fullPathWithoutExtension)) && (!string.IsNullOrEmpty(_fullPath)))
                 {
                     _fullPathWithoutExtension = Path.Combine(DirectoryName, FileNameWithoutExtension);
                 }
@@ -565,7 +564,6 @@ internal string FullPathWithoutExtension
             }
         }
 
-
         /// <summary>
         /// This is the HintPath from the source item. This is used to resolve the assembly.
         /// </summary>
@@ -611,7 +609,7 @@ internal ITaskItem PrimarySourceItem
                 ErrorUtilities.VerifyThrow(
                     !(IsPrimary && _primarySourceItem == null), "A primary reference must have a primary source item.");
                 ErrorUtilities.VerifyThrow(
-                    (IsPrimary || _primarySourceItem == null), "Only a primary reference can have a primary source item.");
+                    IsPrimary || _primarySourceItem == null, "Only a primary reference can have a primary source item.");
 
                 return _primarySourceItem;
             }
@@ -884,7 +882,7 @@ string executableExtension
             _primarySourceItem = sourceItem;
             SDKName = sourceItem.GetMetadata("SDKName");
 
-            if (executableExtension != null && executableExtension.Length > 0)
+            if (!string.IsNullOrEmpty(executableExtension))
             {
                 // Set the expected extension.
                 SetExecutableExtension(executableExtension);
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 344c40c092d..3c03605de6c 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -145,9 +145,9 @@ internal sealed class ReferenceTable
         private readonly ConcurrentDictionary<string, AssemblyMetadata> _assemblyMetadataCache;
 
         /// <summary>
-        /// When we exclude an assembly from resolution because it is part of out exclusion list we need to let the user know why this is. 
-        /// There can be a number of reasons each for un-resolving a reference, these reasons are encapsulated by a different black list. We need to log a specific message 
-        /// depending on which black list we have found the offending assembly in. This delegate allows one to tie a set of logging messages to a black list so that when we 
+        /// When we exclude an assembly from resolution because it is part of out exclusion list we need to let the user know why this is.
+        /// There can be a number of reasons each for un-resolving a reference, these reasons are encapsulated by a different black list. We need to log a specific message
+        /// depending on which black list we have found the offending assembly in. This delegate allows one to tie a set of logging messages to a black list so that when we
         /// discover an assembly in the black list we can log the correct message.
         /// </summary>
         internal delegate void LogExclusionReason(bool displayPrimaryReferenceMessage, AssemblyNameExtension assemblyName, Reference reference, ITaskItem referenceItem, string targetedFramework);
@@ -158,6 +158,7 @@ internal sealed class ReferenceTable
         // PEHeader
         private const int PEHEADER = 0x00004550;
 
+#if FEATURE_WIN32_REGISTRY
         /// <summary>
         /// Construct.
         /// </summary>
@@ -180,10 +181,10 @@ internal sealed class ReferenceTable
         /// <param name="getAssemblyMetadata">Delegate used for finding dependencies of a file.</param>
         /// <param name="getRegistrySubKeyNames">Used to get registry subkey names.</param>
         /// <param name="getRegistrySubKeyDefaultValue">Used to get registry default values.</param>
+        /// <param name="openBaseKey"></param>
         /// <param name="unresolveFrameworkAssembliesFromHigherFrameworks"></param>
         /// <param name="assemblyMetadataCache">Cache of metadata already read from paths.</param>
         /// <param name="allowedAssemblyExtensions"></param>
-        /// <param name="openBaseKey"></param>
         /// <param name="getRuntimeVersion"></param>
         /// <param name="targetedRuntimeVersion"></param>
         /// <param name="projectTargetFramework"></param>
@@ -198,6 +199,45 @@ internal sealed class ReferenceTable
         /// <param name="readMachineTypeFromPEHeader"></param>
         /// <param name="warnOrErrorOnTargetArchitectureMismatch"></param>
         /// <param name="ignoreFrameworkAttributeVersionMismatch"></param>
+#else
+        /// <summary>
+        /// Construct.
+        /// </summary>
+        /// <param name="buildEngine"></param>
+        /// <param name="findDependencies">If true, then search for dependencies.</param>
+        /// <param name="findSatellites">If true, then search for satellite files.</param>
+        /// <param name="findSerializationAssemblies">If true, then search for serialization assembly files.</param>
+        /// <param name="findRelatedFiles">If true, then search for related files.</param>
+        /// <param name="searchPaths">Paths to search for dependent assemblies on.</param>
+        /// <param name="relatedFileExtensions"></param>
+        /// <param name="candidateAssemblyFiles">List of literal assembly file names to be considered when SearchPaths has {CandidateAssemblyFiles}.</param>
+        /// <param name="resolvedSDKItems">Resolved sdk items</param>
+        /// <param name="frameworkPaths">Path to the FX.</param>
+        /// <param name="installedAssemblies">Installed assembly XML tables.</param>
+        /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64, the processor architecture being targetted.</param>
+        /// <param name="fileExists">Delegate used for checking for the existence of a file.</param>
+        /// <param name="directoryExists">Delegate used for files.</param>
+        /// <param name="getDirectories">Delegate used for getting directories.</param>
+        /// <param name="getAssemblyName">Delegate used for getting assembly names.</param>
+        /// <param name="getAssemblyMetadata">Delegate used for finding dependencies of a file.</param>
+        /// <param name="unresolveFrameworkAssembliesFromHigherFrameworks"></param>
+        /// <param name="assemblyMetadataCache">Cache of metadata already read from paths.</param>
+        /// <param name="allowedAssemblyExtensions"></param>
+        /// <param name="getRuntimeVersion"></param>
+        /// <param name="targetedRuntimeVersion"></param>
+        /// <param name="projectTargetFramework"></param>
+        /// <param name="targetFrameworkMoniker"></param>
+        /// <param name="log"></param>
+        /// <param name="latestTargetFrameworkDirectories"></param>
+        /// <param name="copyLocalDependenciesWhenParentReferenceInGac"></param>
+        /// <param name="doNotCopyLocalIfInGac"></param>
+        /// <param name="getAssemblyPathInGac"></param>
+        /// <param name="isWinMDFile"></param>
+        /// <param name="ignoreVersionForFrameworkReferences"></param>
+        /// <param name="readMachineTypeFromPEHeader"></param>
+        /// <param name="warnOrErrorOnTargetArchitectureMismatch"></param>
+        /// <param name="ignoreFrameworkAttributeVersionMismatch"></param>
+#endif
         internal ReferenceTable
         (
             IBuildEngine buildEngine,
@@ -378,7 +418,6 @@ internal void AddReference(AssemblyNameExtension assemblyName, Reference referen
             References[assemblyName] = reference;
         }
 
-
         /// <summary>
         /// Find the reference that corresponds to the given path.
         /// </summary>
@@ -526,8 +565,7 @@ ITaskItem referenceAssemblyName
             AssemblyNameExtension assemblyName = null;
             string fusionName = referenceAssemblyName.GetMetadata(ItemMetadataNames.fusionName);
             bool result = MetadataConversionUtilities.TryConvertItemMetadataToBool(referenceAssemblyName, ItemMetadataNames.IgnoreVersionForFrameworkReference, out bool metadataFound);
-            bool ignoreVersionForFrameworkReference = false;
-
+            bool ignoreVersionForFrameworkReference;
             if (metadataFound)
             {
                 ignoreVersionForFrameworkReference = result;
@@ -542,7 +580,7 @@ ITaskItem referenceAssemblyName
             // Figure out the specific version value.
             bool wantSpecificVersion = MetadataConversionUtilities.TryConvertItemMetadataToBool(referenceAssemblyName, ItemMetadataNames.specificVersion, out bool foundSpecificVersionMetadata);
 
-            bool isSimpleName = (assemblyName != null && assemblyName.IsSimpleName);
+            bool isSimpleName = (assemblyName?.IsSimpleName == true);
 
             // Create the reference.
             var reference = new Reference(_isWinMDFile, _fileExists, _getRuntimeVersion);
@@ -588,7 +626,6 @@ ITaskItem referenceAssemblyName
                 }
             }
 
-
             // Embed Interop Types aka "NOPIAs" support is not available for Fx < 4.0
             // So, we just ignore this setting on down-level platforms
             if (_projectTargetFramework != null && _projectTargetFramework >= s_targetFrameworkVersion_40)
@@ -1008,7 +1045,7 @@ out FrameworkName frameworkName
 
             var dependencies = new List<AssemblyNameExtension>(dependentAssemblies?.Length ?? 0);
 
-            if (dependentAssemblies != null && dependentAssemblies.Length > 0)
+            if (dependentAssemblies?.Length > 0)
             {
                 // Re-map immediately so that to the sytem we actually got the remapped version when reading the manifest.
                 for (int i = 0; i < dependentAssemblies.Length; i++)
@@ -1048,7 +1085,7 @@ out FrameworkName frameworkName
         }
 
         /// <summary>
-        /// Given an enumerator of pre-unified assembly names, return an enumerator of unified 
+        /// Given an enumerator of pre-unified assembly names, return an enumerator of unified
         /// assembly names.
         /// </summary>
         private IEnumerable<UnifiedAssemblyName> GetUnifiedAssemblyNames
@@ -1195,10 +1232,10 @@ private static bool IsPseudoAssembly(string name)
         }
 
         /// <summary>
-        /// Based on the set of parent assemblies we want to add their directories to the list of resolvers so that 
+        /// Based on the set of parent assemblies we want to add their directories to the list of resolvers so that
         /// if the dependency is sitting beside the assembly which requires it then we will resolve the assembly from that location first.
-        /// 
-        /// The only time we do not want to do this is if the parent assembly came from the GAC or AssemblyFoldersEx then we want the assembly 
+        ///
+        /// The only time we do not want to do this is if the parent assembly came from the GAC or AssemblyFoldersEx then we want the assembly
         /// to be found using those resolvers so that our GAC and AssemblyFolders checks later on will work on those assemblies.
         /// </summary>
         internal static void CalculateParentAssemblyDirectories(List<string> parentReferenceFolders, Reference parentReference)
@@ -1226,7 +1263,7 @@ internal static void CalculateParentAssemblyDirectories(List<string> parentRefer
         }
 
         /// <summary>
-        /// Given an unresolved reference (one that we don't know the full name for yet), figure out the 
+        /// Given an unresolved reference (one that we don't know the full name for yet), figure out the
         /// full name. Should only be called on references that haven't been resolved yet--otherwise, its
         /// a perf problem.
         /// </summary>
@@ -1390,7 +1427,7 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
                     ICollection<ITaskItem> dependees = assemblyReference.GetSourceItems();
 
                     // Need to deal with dependencies, this can also include primary references who are dependencies themselves and are in the black list
-                    if (!assemblyReference.IsPrimary || (assemblyReference.IsPrimary && isMarkedForExclusion && (dependees != null && dependees.Count > 1)))
+                    if (!assemblyReference.IsPrimary || (assemblyReference.IsPrimary && isMarkedForExclusion && (dependees?.Count > 1)))
                     {
                         // Does the assembly have specific version true, or does any of its primary parent references have specific version true.
                         // This is checked because, if an assembly is in the black list, the only way it can possibly be allowed is if
@@ -1433,7 +1470,7 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
 
         /// <summary>
         /// References usually only contains who they depend on, they do not know who depends on them. Given a reference
-        /// A we cannot inspect A to find out that B,C,D depend on it. This method will traverse the references and build up this other direction of the graph, 
+        /// A we cannot inspect A to find out that B,C,D depend on it. This method will traverse the references and build up this other direction of the graph,
         /// therefore we will be able to know given reference A, that B,C,D depend on it.
         /// </summary>
         private static void AddToDependencyGraph(Dictionary<Reference, List<ReferenceAssemblyExtensionPair>> dependencyGraph, AssemblyNameExtension assemblyName, Reference assemblyReference)
@@ -1534,7 +1571,7 @@ internal AssemblyNameExtension GetReferenceFromItemSpec(string itemSpec)
         }
 
         /// <summary>
-        /// Go through the dependency graph and make sure that for a reference to remove that we get rid of all dependency assemblies which are not referenced by any other 
+        /// Go through the dependency graph and make sure that for a reference to remove that we get rid of all dependency assemblies which are not referenced by any other
         /// assembly. The remove reference list should contain ALL primary references which should be removed because they, or one of their dependencies is in the black list.
         /// </summary>
         /// <param name="removedReference">Reference to remove dependencies for</param>
@@ -1579,7 +1616,7 @@ private static void RemoveDependencies(Reference removedReference, Dictionary<As
         /// Searches the table for references that haven't been resolved to their full file names and
         /// for dependencies that haven't yet been found.
         ///
-        /// If any are found, they're resolved and then dependencies are found. Then the process is repeated 
+        /// If any are found, they're resolved and then dependencies are found. Then the process is repeated
         /// until nothing is left unresolved.
         /// </summary>
         /// <param name="remappedAssembliesValue">The table of remapped assemblies.</param>
@@ -1634,7 +1671,6 @@ private void ComputeClosure()
                     ErrorUtilities.VerifyThrow(dependencyIterations < maxIterations, "Maximum iterations exceeded while looking for dependencies.");
                 } while (moreDependencies);
 
-
                 // If everything is either resolved or unresolvable, then we can quit.
                 // Otherwise, loop again.
                 moreResolvable = false;
@@ -1773,7 +1809,7 @@ private void ResolveAssemblyFilenames()
         }
 
         /// <summary>
-        /// This methods looks for conflicts between assemblies and attempts to 
+        /// This methods looks for conflicts between assemblies and attempts to
         /// resolve them.
         /// </summary>
         private void ResolveConflictsBetweenReferences(Dictionary<string, List<AssemblyNameReference>> baseNameToReferences)
@@ -1812,7 +1848,7 @@ private void ResolveConflictsBetweenReferences(List<AssemblyNameReference> assem
         }
 
         /// <summary>
-        /// Based on the closure, get a table of ideal remappings needed to 
+        /// Based on the closure, get a table of ideal remappings needed to
         /// produce zero conflicts.
         /// </summary>
         internal void ResolveConflicts
@@ -1865,7 +1901,7 @@ out List<AssemblyNameReference> conflictingReferences
                     }
 
                     byte[] pkt = assemblyName.GetPublicKeyToken();
-                    if (pkt != null && pkt.Length > 0)
+                    if (pkt?.Length > 0)
                     {
                         AssemblyName baseKey = assemblyName.AssemblyName.CloneIfPossible();
                         Version version = baseKey.Version;
@@ -1923,8 +1959,8 @@ out List<AssemblyNameReference> conflictingReferences
         }
 
         /// <summary>
-        /// If a reference is a higher version than what exists in the redist list of the target framework then 
-        /// this reference needs to be marked as excluded so that it is not not allowed to be referenced. 
+        /// If a reference is a higher version than what exists in the redist list of the target framework then
+        /// this reference needs to be marked as excluded so that it is not allowed to be referenced.
         /// 
         /// If the user needs this reference then they need to set specific version to true.
         /// </summary>
@@ -1981,12 +2017,12 @@ private bool InLatestRedistList(AssemblyNameExtension assemblyName)
 
         /// <summary>
         /// Get the redist list which corresponds to the highest target framework for a given target framework moniker.
-        /// 
+        ///
         /// This is done in two ways:
         ///  First, if the latestTargetFrameworkDirectories parameter is passed into RAR those directories will be used to get the redist list
-        ///  regardless of the target framework moniker. 
-        ///  
-        /// Second, if latest Target Framework Directories is not passed in then we ask the ToollocationHelper for the highest target framework which has 
+        ///  regardless of the target framework moniker.
+        ///
+        /// Second, if latest Target Framework Directories is not passed in then we ask the ToollocationHelper for the highest target framework which has
         /// a TargetFrameworkIdentifier which matches the passed in TargetFrameworkMoniker.
         /// </summary>
         private Tuple<RedistList, string> GetHighestVersionFullFrameworkForTFM(FrameworkNameVersioning targetFrameworkMoniker)
@@ -2005,7 +2041,7 @@ private Tuple<RedistList, string> GetHighestVersionFullFrameworkForTFM(Framework
 
                         // The latestTargetFrameworkDirectories can be passed into RAR, if they are then use those directories rather than 
                         // getting a list by looking at the file system.
-                        if (_latestTargetFrameworkDirectories != null && _latestTargetFrameworkDirectories.Length > 0)
+                        if (_latestTargetFrameworkDirectories?.Length > 0)
                         {
                             referenceAssemblyDirectories = new List<string>(_latestTargetFrameworkDirectories);
                             otherFrameworkName = String.Join(";", _latestTargetFrameworkDirectories);
@@ -2019,7 +2055,7 @@ private Tuple<RedistList, string> GetHighestVersionFullFrameworkForTFM(Framework
                             }
                         }
 
-                        if (referenceAssemblyDirectories != null && referenceAssemblyDirectories.Count > 0)
+                        if (referenceAssemblyDirectories?.Count > 0)
                         {
                             var seenFrameworkDirectories = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                             var assemblyTableInfos = new List<AssemblyTableInfo>();
@@ -2050,7 +2086,7 @@ private Tuple<RedistList, string> GetHighestVersionFullFrameworkForTFM(Framework
         }
 
         /// <summary>
-        /// Based on a target framework moniker, get the set of reference assembly directories which 
+        /// Based on a target framework moniker, get the set of reference assembly directories which
         /// correspond to the highest version of the target framework identifier property on the target framework moniker.
         /// </summary>
         private static IList<string> GetHighestVersionReferenceAssemblyDirectories(FrameworkNameVersioning targetFrameworkMoniker, out FrameworkNameVersioning highestVersionMoniker)
@@ -2069,7 +2105,7 @@ private static IList<string> GetHighestVersionReferenceAssemblyDirectories(Frame
             }
             return referenceAssemblyDirectories;
         }
-        
+
         /// <summary>
         /// Is the assemblyName in the current redist list and does it have a version number which is higher than what is in the current redist list.
         /// This may happen if someone passes in a p2p reference whcih is a framework assembly which is a higher version than what is in the redist list.
@@ -2105,7 +2141,7 @@ internal bool MarkReferenceForExclusionDueToHigherThanCurrentFramework(AssemblyN
                 // Check assemblies versions when target framework version is less than 4.5
 
                 // Make sure the version is higher than the version in the redist. 
-                bool higherThanCurrentRedistList = (reference.ReferenceVersion != null && reference.ExclusionListLoggingProperties.HighestVersionInRedist != null)
+                bool higherThanCurrentRedistList = reference.ReferenceVersion != null && reference.ExclusionListLoggingProperties.HighestVersionInRedist != null
                                                    && reference.ReferenceVersion.CompareTo(reference.ExclusionListLoggingProperties.HighestVersionInRedist) > 0;
 
                 if (higherThanCurrentRedistList)
@@ -2150,7 +2186,7 @@ internal bool MarkReferenceForExclusionDueToHigherThanCurrentFrameworkAttribute(
 
             return haveMarkedReference;
         }
-        
+
         /// <summary>
         /// Build a table of simple names mapped to assemblyname+reference.
         /// </summary>
@@ -2196,7 +2232,6 @@ Dictionary<string, List<AssemblyNameReference>> baseNameToReferences
                 if (baseNameToReferences[baseName].Count == 1)
                 {
                     baseNameToReferences.Remove(baseName);
-
                 }
             }
         }
@@ -2298,7 +2333,7 @@ out _
                     }
                 }
             }
-            
+
             // Remove the one chosen.
             int victor = 1 - victim;
 
@@ -2339,12 +2374,14 @@ private static bool IsAssemblyRemovedFromDotNetFramework(AssemblyNameExtension a
         }
 
         /// <summary>
-        /// Get unification information for the given assembly name. 
+        /// Get unification information for the given assembly name.
         /// </summary>
         /// <param name="assemblyName">The assembly name.</param>
         /// <param name="unifiedVersion">The new version of the assembly to use.</param>
         /// <param name="unificationReason">The reason this reference was unified.</param>
         /// <param name="isPrerequisite">True if this is a prereq assembly.</param>
+        /// <param name="isRedistRoot">May be true, false or null. Null means there was no IsRedistRoot in the redist list.</param>
+        /// <param name="redistName">Name of the corresponding Resist specified in the redist list.</param>
         /// <returns>True if there was a unification.</returns>
         private bool UnifyAssemblyNameVersions
         (
@@ -2414,7 +2451,6 @@ out redistName
                 }
             }
 
-
             return false;
         }
 
@@ -2456,6 +2492,8 @@ private bool CompareAssembliesIgnoringVersion(AssemblyName a, AssemblyName b)
         /// <param name="dependencyFiles">Dependent references fully resolved.</param>
         /// <param name="relatedFiles">Related files like .xmls and .pdbs.</param>
         /// <param name="satelliteFiles">Satellite files.</param>
+        /// <param name="serializationAssemblyFiles">Serialization assembly files.</param>
+        /// <param name="scatterFiles">Receives the list of associated scatter files.</param>
         /// <param name="copyLocalFiles">All copy-local files out of primaryFiles+dependencyFiles+relatedFiles+satelliteFiles.</param>
         internal void GetReferenceItems
         (
@@ -2586,7 +2624,7 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>
                 referenceItem.SetMetadata(ItemMetadataNames.redist, reference.RedistName);
             }
 
-            if (Reference.IsFrameworkFile(reference.FullPath, _frameworkPaths) || (_installedAssemblies != null && _installedAssemblies.FrameworkAssemblyEntryInRedist(assemblyName)))
+            if (Reference.IsFrameworkFile(reference.FullPath, _frameworkPaths) || (_installedAssemblies?.FrameworkAssemblyEntryInRedist(assemblyName) == true))
             {
                 if (!IsAssemblyRemovedFromDotNetFramework(assemblyName, reference.FullPath, _frameworkPaths, _installedAssemblies))
                 {
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 211537b094f..fd70c667752 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -17,6 +17,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks.AssemblyDependency;
+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Client;
 using Microsoft.Build.Utilities;
 
 using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
@@ -31,12 +32,12 @@ namespace Microsoft.Build.Tasks
     public class ResolveAssemblyReference : TaskExtension
     {
         /// <summary>
-        /// key assembly used to trigger inclusion of facade references. 
+        /// key assembly used to trigger inclusion of facade references.
         /// </summary>
         private const string SystemRuntimeAssemblyName = "System.Runtime";
 
         /// <summary>
-        /// additional key assembly used to trigger inclusion of facade references. 
+        /// additional key assembly used to trigger inclusion of facade references.
         /// </summary>
         private const string NETStandardAssemblyName = "netstandard";
 
@@ -129,11 +130,11 @@ public bool UnresolveFrameworkAssembliesFromHigherFrameworks
 
         /// <summary>
         /// If there is a mismatch between the targetprocessor architecture and the architecture of a primary reference.
-        /// 
-        /// When this is error,  an error will be logged. 
-        /// 
+        ///
+        /// When this is error,  an error will be logged.
+        ///
         /// When this is warn, if there is a mismatch between the targetprocessor architecture and the architecture of a primary reference a warning will be logged.
-        /// 
+        ///
         /// When this is none, no error or warning will be logged.
         /// </summary>
         public string WarnOrErrorOnTargetArchitectureMismatch
@@ -156,12 +157,12 @@ public string WarnOrErrorOnTargetArchitectureMismatch
         ///
         /// Optional attributes are:
         ///     bool Private [default=true] -- means 'CopyLocal'
-        ///     string FusionName -- the simple or strong fusion name for this item. If this 
+        ///     string FusionName -- the simple or strong fusion name for this item. If this
         ///         attribute is present it can save time since the assembly file won't need
         ///         to be opened to get the fusion name.
         ///     bool ExternallyResolved [default=false] -- indicates that the reference and its
         ///        dependencies are resolved by an external system (commonly from nuget assets) and
-        ///        so several steps can be skipped as an optimization: finding dependencies, 
+        ///        so several steps can be skipped as an optimization: finding dependencies,
         ///        satellite assemblies, etc.
         /// </summary>
         public ITaskItem[] AssemblyFiles
@@ -171,9 +172,9 @@ public ITaskItem[] AssemblyFiles
         }
 
         /// <summary>
-        /// The list of directories which contain the redist lists for the most current 
+        /// The list of directories which contain the redist lists for the most current
         /// framework which can be targeted on the machine. If this is not set
-        /// Then we will looks for the highest framework installed on the machine 
+        /// Then we will looks for the highest framework installed on the machine
         /// for a given target framework identifier and use that.
         /// </summary>
         public string[] LatestTargetFrameworkDirectories
@@ -205,6 +206,11 @@ public bool IgnoreTargetFrameworkAttributeVersionMismatch
             }
         }
 
+        /// <summary>
+        /// Indicates if ResolveAssemblyReference task should be run in its own node or not.
+        /// </summary>
+        public bool UseResolveAssemblyReferenceService { get; set; }
+
         /// <summary>
         /// Force dependencies to be walked even when a reference is marked with ExternallyResolved=true
         /// metadata.
@@ -241,26 +247,26 @@ public string[] TargetFrameworkSubsets
         ///
         /// Optional attributes are:
         ///     bool Private [default=true] -- means 'CopyLocal'
-        ///     string HintPath [default=''] -- location of file name to consider as a reference, 
+        ///     string HintPath [default=''] -- location of file name to consider as a reference,
         ///         used when {HintPathFromItem} is one of the paths in SearchPaths.
-        ///     bool SpecificVersion [default=absent] -- 
-        ///         when true, the exact fusionname in the Include must be matched. 
+        ///     bool SpecificVersion [default=absent] --
+        ///         when true, the exact fusionname in the Include must be matched.
         ///         when false, any assembly with the same simple name will be a match.
-        ///         when absent, then look at the value in Include. 
+        ///         when absent, then look at the value in Include.
         ///           If its a simple name then behave as if specific version=false.
-        ///           If its a strong name name then behave as if specific version=true.
-        ///     string ExecutableExtension [default=absent] -- 
+        ///           If its a strong name then behave as if specific version=true.
+        ///     string ExecutableExtension [default=absent] --
         ///         when present, the resolved assembly must have this extension.
         ///         when absent, .dll is considered and then .exe for each directory looked at.
-        ///     string SubType -- only items with empty SubTypes will be considered. Items 
+        ///     string SubType -- only items with empty SubTypes will be considered. Items
         ///         with non-empty subtypes will be ignored.
-        ///     string AssemblyFolderKey [default=absent] -- supported for legacy AssemblyFolder 
+        ///     string AssemblyFolderKey [default=absent] -- supported for legacy AssemblyFolder
         ///         resolution. This key can have a value like 'hklm\vendor folder'. When set, only
         ///         this particular assembly folder key will be used.
         ///            This is to support the scenario in VSWhidey#357946 in which there are multiple
         ///            side-by-side libraries installed and the user wants to pick an exact version.
-        ///     bool EmbedInteropTyeps [default=absent] -- 
-        ///         when true, we should treat this assembly as if it has no dependencies and should 
+        ///     bool EmbedInteropTyeps [default=absent] --
+        ///         when true, we should treat this assembly as if it has no dependencies and should
         ///         be completely embedded into the target assembly.
         /// </summary>
         public ITaskItem[] Assemblies
@@ -293,9 +299,9 @@ public ITaskItem[] ResolvedSDKReferences
         }
 
         /// <summary>
-        /// Path to the target frameworks directory. Required to figure out CopyLocal status 
+        /// Path to the target frameworks directory. Required to figure out CopyLocal status
         /// for resulting items.
-        /// If not present, then no resulting items will be deemed CopyLocal='true' unless they explicity 
+        /// If not present, then no resulting items will be deemed CopyLocal='true' unless they explicity
         /// have a Private='true' attribute on their source item.
         /// </summary>
         public string[] TargetFrameworkDirectories
@@ -306,14 +312,14 @@ public string[] TargetFrameworkDirectories
 
         /// <summary>
         /// A list of XML files that contain assemblies that are expected to be installed on the target machine.
-        /// 
+        ///
         /// Format of the file is like:
-        /// 
+        ///
         ///     <FileList Redist="Microsoft-Windows-CLRCoreComp" >
         ///         <File AssemblyName="System" Version="2.0.0.0" PublicKeyToken="b77a5c561934e089" Culture="neutral" ProcessorArchitecture="MSIL" FileVersion="2.0.40824.0" InGAC="true" />
         ///         etc.
         ///     </FileList>
-        /// 
+        ///
         /// When present, assemblies from this list will be candidates to automatically "unify" from prior versions up to
         /// the version listed in the XML. Also, assemblies with InGAC='true' will be considered prerequisites and will be CopyLocal='false'
         /// unless explicitly overridden.
@@ -332,16 +338,16 @@ public ITaskItem[] InstalledAssemblyTables
 
         /// <summary>
         /// A list of XML files that contain assemblies that are expected to be in the target subset
-        /// 
+        ///
         /// Format of the file is like:
-        /// 
+        ///
         ///     <FileList Redist="ClientSubset" >
         ///         <File AssemblyName="System" Version="2.0.0.0" PublicKeyToken="b77a5c561934e089" Culture="neutral" ProcessorArchitecture="MSIL" FileVersion="2.0.40824.0" InGAC="true" />
         ///         etc.
         ///     </FileList>
-        /// 
+        ///
         /// Items in this list may optionally specify the "FrameworkDirectory" metadata to associate an InstalledAssemblySubsetTable
-        /// with a particular framework directory. 
+        /// with a particular framework directory.
         /// If there is only a single TargetFrameworkDirectories element, then any items in this list missing the
         /// "FrameworkDirectory" metadata will be treated as though this metadata is set to the lone (unique) value passed
         /// to TargetFrameworkDirectories.
@@ -358,19 +364,19 @@ public ITaskItem[] InstalledAssemblySubsetTables
 
         /// <summary>
         /// A list of XML files that contain the full framework for the profile.
-        /// 
-        /// Normally nothing is passed in here, this is for the cases where the location of the xml file for the full framework 
+        ///
+        /// Normally nothing is passed in here, this is for the cases where the location of the xml file for the full framework
         /// is not under a RedistList folder.
-        /// 
+        ///
         /// Format of the file is like:
-        /// 
+        ///
         ///     <FileList Redist="MatchingRedistListName" >
         ///         <File AssemblyName="System" Version="2.0.0.0" PublicKeyToken="b77a5c561934e089" Culture="neutral" ProcessorArchitecture="MSIL" FileVersion="2.0.40824.0" InGAC="true" />
         ///         etc.
         ///     </FileList>
-        /// 
+        ///
         /// Items in this list must specify the "FrameworkDirectory" metadata to associate an redist list
-        /// with a particular framework directory. If the association is not made an error will be logged. The reason is, 
+        /// with a particular framework directory. If the association is not made an error will be logged. The reason is,
         /// The logic in rar assumes if a FrameworkDirectory is not set it will use the target framework directory.
         /// </summary>
         public ITaskItem[] FullFrameworkAssemblyTables
@@ -385,7 +391,7 @@ public ITaskItem[] FullFrameworkAssemblyTables
 
         /// <summary>
         /// [default=false]
-        /// Boolean property to control whether or not the task should look for and use additional installed 
+        /// Boolean property to control whether or not the task should look for and use additional installed
         /// assembly tables (a.k.a Redist Lists) found in the RedistList directory underneath the provided
         /// TargetFrameworkDirectories.
         /// </summary>
@@ -397,7 +403,7 @@ public bool IgnoreDefaultInstalledAssemblyTables
 
         /// <summary>
         /// [default=false]
-        /// Boolean property to control whether or not the task should look for and use additional installed 
+        /// Boolean property to control whether or not the task should look for and use additional installed
         /// assembly subset tables (a.k.a Subset Lists) found in the SubsetList directory underneath the provided
         /// TargetFrameworkDirectories.
         /// </summary>
@@ -417,14 +423,14 @@ public bool IgnoreVersionForFrameworkReferences
         }
 
         /// <summary>
-        /// The preferred target processor architecture. Used for resolving {GAC} references. 
+        /// The preferred target processor architecture. Used for resolving {GAC} references.
         /// Should be like x86, IA64 or AMD64.
-        /// 
+        ///
         /// This is the order of preference:
         /// (1) Assemblies in the GAC that match the supplied ProcessorArchitecture.
         /// (2) Assemblies in the GAC that have ProcessorArchitecture=MSIL
         /// (3) Assemblies in the GAC that have no ProcessorArchitecture.
-        /// 
+        ///
         /// If absent, then only consider assemblies in the GAC that have ProcessorArchitecture==MSIL or
         /// no ProcessorArchitecture (these are pre-Whidbey assemblies).
         /// </summary>
@@ -510,7 +516,6 @@ public string[] AllowedAssemblyExtensions
             set { _allowedAssemblyExtensions = value; }
         }
 
-
         /// <summary>
         /// [default=.pdb;.xml]
         /// These are the extensions that will be considered when looking for related files.
@@ -521,7 +526,6 @@ public string[] AllowedRelatedFileExtensions
             set { _relatedFileExtensions = value; }
         }
 
-
         /// <summary>
         /// If this file name is passed in, then we parse it as an app.config file and extract bindingRedirect mappings. These mappings are used in the dependency
         /// calculation process to remap versions of assemblies.
@@ -577,23 +581,22 @@ public bool AutoUnify
             set { _autoUnify = value; }
         }
 
-
         /// <summary>
-        ///  When determining if a dependency should be copied locally one of the checks done is to see if the 
-        ///  parent reference in the project file has the Private metadata set or not. If that metadata is set then 
-        ///  We will use that for the dependency as well. 
-        ///  
-        /// However, if the metadata is not set then the dependency will go through the same checks as the parent reference. 
+        ///  When determining if a dependency should be copied locally one of the checks done is to see if the
+        ///  parent reference in the project file has the Private metadata set or not. If that metadata is set then
+        ///  We will use that for the dependency as well.
+        ///
+        /// However, if the metadata is not set then the dependency will go through the same checks as the parent reference.
         /// One of these checks is to see if the reference is in the GAC. If a reference is in the GAC then we will not copy it locally
         /// as it is assumed it will be in the gac on the target machine as well. However this only applies to that specific reference and not its dependencies.
-        /// 
+        ///
         /// This means a reference in the project file may be copy local false due to it being in the GAC but the dependencies may still be copied locally because they are not in the GAC.
         /// This is the default behavior for RAR and causes the default value for this property to be true.
-        /// 
-        /// When this property is false we will still check project file references to see if they are in the GAC and set their copy local state as appropriate. 
-        /// However for dependencies we will not only check to see if they are in the GAC but we will also check to see if the parent reference from the project file is in the GAC. 
+        ///
+        /// When this property is false we will still check project file references to see if they are in the GAC and set their copy local state as appropriate.
+        /// However for dependencies we will not only check to see if they are in the GAC but we will also check to see if the parent reference from the project file is in the GAC.
         /// If the parent reference from the project file is in the GAC then we will not copy the dependency locally.
-        /// 
+        ///
         /// NOTE: If there are multiple parent reference and ANY of them does not come from the GAC then we will set copy local to true.
         /// </summary>
         public bool CopyLocalDependenciesWhenParentReferenceInGac
@@ -719,9 +722,9 @@ public string TargetFrameworkMonikerDisplayName
         }
 
         /// <summary>
-        /// Provide a set of names which if seen in the TargetFrameworkSubset list will cause the ignoring 
+        /// Provide a set of names which if seen in the TargetFrameworkSubset list will cause the ignoring
         /// of TargetFrameworkSubsets.
-        /// 
+        ///
         /// Full, Complete
         /// </summary>
         public string[] FullTargetFrameworkSubsetNames
@@ -758,7 +761,7 @@ public string ProfileName
 
         /// <summary>
         /// Set of folders which containd a RedistList directory which represent the full framework for a given client profile.
-        /// An example would be 
+        /// An example would be
         /// %programfiles%\reference assemblies\microsoft\framework\v4.0
         /// </summary>
         public string[] FullFrameworkFolders
@@ -799,9 +802,9 @@ public ITaskItem[] ResolvedFiles
         ///     string FusionName - the fusion name for this dependency.
         ///     string ResolvedFrom - the literal search path that this file was resolved from.
         ///     bool IsRedistRoot - Whether or not this assembly is the representative for an entire redist.
-        ///         'true' means the assembly is representative of an entire redist and should be indicated as 
+        ///         'true' means the assembly is representative of an entire redist and should be indicated as
         ///         an application dependency in an application manifest.
-        ///         'false' means the assembly is internal to a redist and should not be part of the 
+        ///         'false' means the assembly is internal to a redist and should not be part of the
         ///         application manifest.
         ///     string Redist - The name (if any) of the redist that contains this assembly.
         /// Does not include first order primary references--this list is in ResolvedFiles.
@@ -825,10 +828,10 @@ public ITaskItem[] RelatedFiles
         }
 
         /// <summary>
-        /// Any satellite files found. These will be CopyLocal=true iff the reference or dependency 
+        /// Any satellite files found. These will be CopyLocal=true iff the reference or dependency
         /// that caused this item to exist is CopyLocal=true.
         ///     bool CopyLocal - whether the given reference should be copied to the output directory.
-        ///     string DestinationSubDirectory - the relative destination directory that this file 
+        ///     string DestinationSubDirectory - the relative destination directory that this file
         ///       should be copied to. This is mainly for satellites.
         /// </summary>
         [Output]
@@ -838,7 +841,7 @@ public ITaskItem[] SatelliteFiles
         }
 
         /// <summary>
-        /// Any XML serialization assemblies found. These will be CopyLocal=true iff the reference or dependency 
+        /// Any XML serialization assemblies found. These will be CopyLocal=true iff the reference or dependency
         /// that caused this item to exist is CopyLocal=true.
         ///     bool CopyLocal - whether the given reference should be copied to the output directory.
         /// </summary>
@@ -870,9 +873,9 @@ public ITaskItem[] CopyLocalFiles
         }
 
         /// <summary>
-        /// Regardless of the value of AutoUnify, returns one item for every distinct conflicting assembly 
-        /// identity--including culture and PKT--that was found that did not have a suitable bindingRedirect 
-        /// entry in the ApplicationConfigurationFile. 
+        /// Regardless of the value of AutoUnify, returns one item for every distinct conflicting assembly
+        /// identity--including culture and PKT--that was found that did not have a suitable bindingRedirect
+        /// entry in the ApplicationConfigurationFile.
         ///
         /// Each returned ITaskItem will have the following values:
         ///  ItemSpec - the full fusion name of the assembly family with empty version=0.0.0.0
@@ -919,7 +922,6 @@ public String DependsOnNETStandard
             private set;
         }
 
-
         #endregion
         #region Logging
 
@@ -1134,9 +1136,9 @@ quiet at the engine level.
                         if (assemblyFoldersEx != null && _showAssemblyFoldersExLocations.TryGetValue(r.SearchPath, out messageImportance))
                         {
                             Log.LogMessageFromResources(messageImportance, "ResolveAssemblyReference.AssemblyFoldersExSearchLocations", r.SearchPath);
-                            foreach (AssemblyFoldersExInfo info in assemblyFoldersEx)
+                            foreach (var path in assemblyFoldersEx.UniqueDirectoryPaths)
                             {
-                                Log.LogMessageFromResources(messageImportance, "ResolveAssemblyReference.EightSpaceIndent", info.DirectoryPath);
+                                Log.LogMessageFromResources(messageImportance, "ResolveAssemblyReference.EightSpaceIndent", path);
                             }
                         }
                     }
@@ -1422,7 +1424,6 @@ private void LogInputs()
                     Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", latestFolder);
                 }
 
-
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "ProfileTablesLocation");
                 foreach (ITaskItem profileTable in FullFrameworkAssemblyTables)
                 {
@@ -1436,11 +1437,11 @@ private void LogInputs()
         /// Log a specific item metadata.
         /// </summary>
         /// <param name="item"></param>
-        /// <param name="attribute"></param>
+        /// <param name="metadataName"></param>
         private void LogAttribute(ITaskItem item, string metadataName)
         {
             string metadataValue = item.GetMetadata(metadataName);
-            if (metadataValue != null && metadataValue.Length > 0)
+            if (!string.IsNullOrEmpty(metadataValue))
             {
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.EightSpaceIndent", Log.FormatResourceString("ResolveAssemblyReference.LogAttributeFormat", metadataName, metadataValue));
             }
@@ -1572,7 +1573,7 @@ private void LogReferenceErrors(Reference reference, MessageImportance importanc
         /// <param name="importance">The importance of the message.</param>
         private void LogFullName(Reference reference, MessageImportance importance)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(reference, "reference");
+            ErrorUtilities.VerifyThrowArgumentNull(reference, nameof(reference));
 
             if (reference.IsResolved)
             {
@@ -1586,6 +1587,7 @@ private void LogFullName(Reference reference, MessageImportance importance)
         /// show information about them.
         /// </summary>
         /// <param name="reference">The reference.</param>
+        /// <param name="fusionName">The fusion name.</param>
         /// <param name="importance">The importance of the message.</param>
         private void LogAssembliesConsideredAndRejected(Reference reference, string fusionName, MessageImportance importance)
         {
@@ -1616,7 +1618,6 @@ private void LogAssembliesConsideredAndRejected(Reference reference, string fusi
                         }
                     }
 
-
                     // If this is a new search location, then show the message.
                     if (lastSearchPath != location.SearchPath)
                     {
@@ -1784,7 +1785,6 @@ private void LogCopyLocalState(Reference reference, MessageImportance importance
             }
         }
 
-
         /// <summary>
         /// Log a message about the imageruntime information.
         /// </summary>
@@ -1921,6 +1921,7 @@ private List<DependentAssembly> GetAssemblyRemappingsFromAppConfig()
         #endregion
         #region ITask Members
 
+#if FEATURE_WIN32_REGISTRY
         /// <summary>
         /// Execute the task.
         /// </summary>
@@ -1932,7 +1933,28 @@ private List<DependentAssembly> GetAssemblyRemappingsFromAppConfig()
         /// <param name="getRegistrySubKeyNames">Used to get registry subkey names.</param>
         /// <param name="getRegistrySubKeyDefaultValue">Used to get registry default values.</param>
         /// <param name="getLastWriteTime">Delegate used to get the last write time.</param>
+        /// <param name="getRuntimeVersion">Delegate used to get the runtime version.</param>
+        /// <param name="openBaseKey">Key object to open.</param>
+        /// <param name="getAssemblyPathInGac">Delegate to get assembly path in the GAC.</param>
+        /// <param name="isWinMDFile">Delegate used for checking whether it is a WinMD file.</param>
+        /// <param name="readMachineTypeFromPEHeader">Delegate use to read machine type from PE Header</param>
+        /// <returns>True if there was success.</returns>
+#else
+        /// <summary>
+        /// Execute the task.
+        /// </summary>
+        /// <param name="fileExists">Delegate used for checking for the existence of a file.</param>
+        /// <param name="directoryExists">Delegate used for checking for the existence of a directory.</param>
+        /// <param name="getDirectories">Delegate used for finding directories.</param>
+        /// <param name="getAssemblyName">Delegate used for finding fusion names of assemblyFiles.</param>
+        /// <param name="getAssemblyMetadata">Delegate used for finding dependencies of a file.</param>
+        /// <param name="getLastWriteTime">Delegate used to get the last write time.</param>
+        /// <param name="getRuntimeVersion">Delegate used to get the runtime version.</param>
+        /// <param name="getAssemblyPathInGac">Delegate to get assembly path in the GAC.</param>
+        /// <param name="isWinMDFile">Delegate used for checking whether it is a WinMD file.</param>
+        /// <param name="readMachineTypeFromPEHeader">Delegate use to read machine type from PE Header</param>
         /// <returns>True if there was success.</returns>
+#endif
         internal bool Execute
         (
             FileExists fileExists,
@@ -1997,7 +2019,6 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                         }
                     }
 
-
                     // Validate the contents of the InstalledAssemblyTables parameter.
                     AssemblyTableInfo[] installedAssemblyTableInfo = GetInstalledAssemblyTableInfo(_ignoreDefaultInstalledAssemblyTables, _installedAssemblyTables, new GetListPath(RedistList.GetRedistListPathsFromDisk), TargetFrameworkDirectories);
                     AssemblyTableInfo[] whiteListSubsetTableInfo = null;
@@ -2005,7 +2026,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     InstalledAssemblies installedAssemblies = null;
                     RedistList redistList = null;
 
-                    if (installedAssemblyTableInfo != null && installedAssemblyTableInfo.Length > 0)
+                    if (installedAssemblyTableInfo?.Length > 0)
                     {
                         redistList = RedistList.GetRedistList(installedAssemblyTableInfo);
                     }
@@ -2022,7 +2043,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     List<string> whiteListErrorFilesNames = new List<string>();
 
                     // Check for partial success in GetRedistList and log any tolerated exceptions.
-                    if (redistList != null && redistList.Count > 0 || targetingProfile || ShouldUseSubsetBlackList())
+                    if (redistList?.Count > 0 || targetingProfile || ShouldUseSubsetBlackList())
                     {
                         // If we are not targeting a dev 10 profile and we have the required components to generate a orcas style subset, do so
                         if (!targetingProfile && ShouldUseSubsetBlackList())
@@ -2030,7 +2051,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                             // Based in the target framework subset names find the paths to the files
                             SubsetListFinder whiteList = new SubsetListFinder(_targetFrameworkSubsets);
                             whiteListSubsetTableInfo = GetInstalledAssemblyTableInfo(IgnoreDefaultInstalledAssemblySubsetTables, InstalledAssemblySubsetTables, new GetListPath(whiteList.GetSubsetListPathsFromDisk), TargetFrameworkDirectories);
-                            if (whiteListSubsetTableInfo.Length > 0 && (redistList != null && redistList.Count > 0))
+                            if (whiteListSubsetTableInfo.Length > 0 && (redistList?.Count > 0))
                             {
                                 blackList = redistList.GenerateBlackList(whiteListSubsetTableInfo, whiteListErrors, whiteListErrorFilesNames);
                             }
@@ -2074,7 +2095,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                             }
                         }
 
-                        if (redistList != null && redistList.Count > 0)
+                        if (redistList?.Count > 0)
                         {
                             installedAssemblies = new InstalledAssemblies(redistList);
                         }
@@ -2212,7 +2233,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                         try
                         {
                             excludedReferencesExist = false;
-                            if (redistList != null && redistList.Count > 0)
+                            if (redistList?.Count > 0)
                             {
                                 excludedReferencesExist = dependencyTable.MarkReferencesForExclusion(blackList);
                             }
@@ -2228,7 +2249,6 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                             dependencyTable.RemoveReferencesMarkedForExclusion(true /* Remove the reference and do not warn*/, subsetOrProfileName);
                         }
 
-
                         // Based on the closure, get a table of ideal remappings needed to 
                         // produce zero conflicts.
                         dependencyTable.ResolveConflicts
@@ -2251,7 +2271,7 @@ out autoUnifiedRemappedAssemblyReferences
                         try
                         {
                             excludedReferencesExist = false;
-                            if (redistList != null && redistList.Count > 0)
+                            if (redistList?.Count > 0)
                             {
                                 excludedReferencesExist = dependencyTable.MarkReferencesForExclusion(blackList);
                             }
@@ -2325,7 +2345,7 @@ out _copyLocalFiles
                             {
                                 // if we're finding dependencies and a given reference was not marked as ExternallyResolved
                                 // then its use of System.Runtime/.netstandard would already have been identified above.
-                                continue; 
+                                continue;
                             }
 
                             var rawDependencies = GetDependencies(resolvedReference, fileExists, getAssemblyMetadata, assemblyMetadataCache);
@@ -2458,15 +2478,15 @@ out _copyLocalFiles
         private AssemblyNameExtension[] GetDependencies(Reference resolvedReference, FileExists fileExists, GetAssemblyMetadata getAssemblyMetadata, ConcurrentDictionary<string, AssemblyMetadata> assemblyMetadataCache)
         {
             AssemblyNameExtension[] result = null;
-            if (resolvedReference != null && resolvedReference.IsPrimary && !resolvedReference.IsBadImage)
+            if (resolvedReference?.IsPrimary == true && !resolvedReference.IsBadImage)
             {
-                System.Runtime.Versioning.FrameworkName frameworkName = null;
-                string[] scatterFiles = null;
                 try
                 {
                     // in case of P2P that have not build the reference can be resolved but file does not exist on disk. 
                     if (fileExists(resolvedReference.FullPath))
                     {
+                        FrameworkNameVersioning frameworkName;
+                        string[] scatterFiles;
                         getAssemblyMetadata(resolvedReference.FullPath, assemblyMetadataCache, out result, out scatterFiles, out frameworkName);
                     }
                 }
@@ -2500,7 +2520,6 @@ private static IReadOnlyCollection<DependentAssembly> CombineRemappedAssemblies(
             return combined;
         }
 
-
         /// <summary>
         /// If a targeted runtime is passed in use that, if none is passed in then we need to use v2.0.50727
         /// since the common way this would be empty is if we were using RAR as an override task.
@@ -2529,6 +2548,7 @@ internal static Version SetTargetedRuntimeVersion(string targetedRuntimeVersionR
         /// <param name="installedAssemblyTableInfo">Installed assembly info of the profile redist lists</param>
         /// <param name="fullRedistAssemblyTableInfo">Installed assemblyInfo for the full framework redist lists</param>
         /// <param name="blackList">Generated exclusion list</param>
+        /// <param name="fullFrameworkRedistList">Redist list which will contain the full framework redist list.</param>
         private void HandleProfile(AssemblyTableInfo[] installedAssemblyTableInfo, out AssemblyTableInfo[] fullRedistAssemblyTableInfo, out Dictionary<string, string> blackList, out RedistList fullFrameworkRedistList)
         {
             // Redist list which will contain the full framework redist list.
@@ -2703,12 +2723,11 @@ private void DumpTargetProfileLists(AssemblyTableInfo[] installedAssemblyTableIn
             }
         }
 
-
         /// <summary>
         /// Determine if a black list should be used or not
-        /// 
+        ///
         /// The black list should only be used if there are TargetFrameworkSubsets to use or TargetFrameworkProfiles.
-        /// 
+        ///
         /// 1) If we find a Full or equivalent marker in the list of subsets passed in we do not want to generate a black list even if installedAssemblySubsets are passed in
         /// 2) If we are ignoring the default installed subset tables and we have not passed in any additional subset tables, we do not want to generate a black list
         /// 3) If no targetframework subsets were passed in and no additional subset tables were passed in, we do not want to generate a blacklist
@@ -2756,7 +2775,7 @@ private bool ShouldUseSubsetBlackList()
         /// Populates the suggested redirects output parameter.
         /// </summary>
         /// <param name="idealAssemblyRemappings">The list of ideal remappings.</param>
-        /// <param name="idealAssemblyRemappedReferences">The list of of references to ideal assembly remappings.</param>
+        /// <param name="idealAssemblyRemappedReferences">The list of references to ideal assembly remappings.</param>
         private void PopulateSuggestedRedirects(List<DependentAssembly> idealAssemblyRemappings, List<AssemblyNameReference> idealAssemblyRemappedReferences)
         {
             var holdSuggestedRedirects = new List<ITaskItem>();
@@ -2771,7 +2790,7 @@ private void PopulateSuggestedRedirects(List<DependentAssembly> idealAssemblyRem
                     List<AssemblyNameExtension> conflictVictims = reference.GetConflictVictims();
 
                     // Skip any remapping that has no conflict victims since a redirect will not help.
-                    if (null == conflictVictims || 0 == conflictVictims.Count)
+                    if (conflictVictims == null || 0 == conflictVictims.Count)
                     {
                         continue;
                     }
@@ -2824,7 +2843,7 @@ private AssemblyTableInfo[] GetInstalledAssemblyTableInfo(bool ignoreInstalledAs
 
                 if (String.IsNullOrEmpty(frameworkDirectory))
                 {
-                    if (TargetFrameworkDirectories != null && TargetFrameworkDirectories.Length == 1)
+                    if (TargetFrameworkDirectories?.Length == 1)
                     {
                         // Exactly one TargetFrameworkDirectory, so assume it's related to this
                         // InstalledAssemblyTable.
@@ -2991,6 +3010,37 @@ private string GetAssemblyPathInGac(AssemblyNameExtension assemblyName, SystemPr
         /// <returns>True if there was success.</returns>
         public override bool Execute()
         {
+            if (UseResolveAssemblyReferenceService && BuildEngine is IRarBuildEngine rarBuildEngine)
+            {
+                using var client = new RarClient(rarBuildEngine);
+
+                var connected = client.Connect();
+                if (!connected)
+                {
+                    Log.LogMessageFromResources(MessageImportance.Low, "RarCouldntConnect");
+                    bool nodeCreated = false;
+                    try
+                    {
+                        nodeCreated = client.CreateNode();
+                    }
+                    catch (Exception e)
+                    {
+                        Log.LogWarningFromException(e);
+                    }
+
+                    if (nodeCreated)
+                    {
+                        connected = client.Connect(5000);
+                    }
+                }
+
+                if (connected)
+                {
+                    // Client is connected to the RAR node, we can execute RAR task remotely
+                    // return client.Execute(); // TODO: Let it do something.
+                }
+            }
+
             return Execute
             (
                 new FileExists(p => FileUtilities.FileExistsNoThrow(p)),
diff --git a/src/Tasks/AssemblyDependency/Resolver.cs b/src/Tasks/AssemblyDependency/Resolver.cs
index 7cbbcefaa82..be72b128729 100644
--- a/src/Tasks/AssemblyDependency/Resolver.cs
+++ b/src/Tasks/AssemblyDependency/Resolver.cs
@@ -139,6 +139,7 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected
         /// <param name="assemblyName">The assembly name to look up.</param>
         /// <param name="isPrimaryProjectReference">True if this is a primary reference directly from the project file.</param>
         /// <param name="wantSpecificVersion">Whether the version needs to match exactly or loosely.</param>
+        /// <param name="allowMismatchBetweenFusionNameAndFileName">Whether to allow naming mismatch.</param>
         /// <param name="pathToCandidateAssembly">Path to a possible file.</param>
         /// <param name="searchLocation">Information about why the candidate file didn't match</param>
         protected bool FileMatchesAssemblyName
@@ -160,7 +161,7 @@ ResolutionSearchLocation searchLocation
             if (!allowMismatchBetweenFusionNameAndFileName)
             {
                 string candidateBaseName = Path.GetFileNameWithoutExtension(pathToCandidateAssembly);
-                if (String.Compare(assemblyName?.Name, candidateBaseName, StringComparison.CurrentCultureIgnoreCase) != 0)
+                if (!String.Equals(assemblyName?.Name, candidateBaseName, StringComparison.CurrentCultureIgnoreCase))
                 {
                     if (searchLocation != null)
                     {
@@ -178,7 +179,7 @@ ResolutionSearchLocation searchLocation
                 }
             }
 
-            bool isSimpleAssemblyName = assemblyName != null && assemblyName.IsSimpleName;
+            bool isSimpleAssemblyName = assemblyName?.IsSimpleName == true;
 
             if (fileExists(pathToCandidateAssembly))
             {
@@ -241,8 +242,8 @@ ResolutionSearchLocation searchLocation
                         }
                     }
 
-                    bool matchedSpecificVersion = (wantSpecificVersion && assemblyName != null && assemblyName.Equals(targetAssemblyName));
-                    bool matchPartialName = !wantSpecificVersion && assemblyName != null && assemblyName.PartialNameCompare(targetAssemblyName);
+                    bool matchedSpecificVersion = (wantSpecificVersion && assemblyName?.Equals(targetAssemblyName) == true);
+                    bool matchPartialName = !wantSpecificVersion && assemblyName?.PartialNameCompare(targetAssemblyName) == true;
 
                     if (matchedSpecificVersion || matchPartialName)
                     {
@@ -284,6 +285,7 @@ ResolutionSearchLocation searchLocation
         /// </summary>
         /// <param name="assemblyName">The assembly name to look up.</param>
         /// <param name="isPrimaryProjectReference">True if this is a primary reference directly from the project file.</param>
+        /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
         /// <param name="executableExtensions">The possible filename extensions of the assembly. Must be one of these or its no match.</param>
         /// <param name="directory">the directory to look in</param>
         /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
@@ -348,7 +350,7 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected
                             AssemblyNameExtension foundAssembly = getAssemblyName(fullPath);
 
                             // If the processor architecture does not match the we should continue to see if there is a better match.
-                            if (foundAssembly != null && foundAssembly.AssemblyName.ProcessorArchitecture == ProcessorArchitecture.MSIL)
+                            if (foundAssembly?.AssemblyName.ProcessorArchitecture == ProcessorArchitecture.MSIL)
                             {
                                 return fullPath;
                             }
@@ -371,7 +373,7 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected
                     {
                         foreach (string executableExtension in executableExtensions)
                         {
-                            if (String.Compare(executableExtension, weakNameBaseExtension, StringComparison.CurrentCultureIgnoreCase) == 0)
+                            if (String.Equals(executableExtension, weakNameBaseExtension, StringComparison.CurrentCultureIgnoreCase))
                             {
                                 string fullPath = Path.Combine(directory, weakNameBase);
                                 var extensionlessAssemblyName = new AssemblyNameExtension(weakNameBaseFileName);
diff --git a/src/Tasks/AssignCulture.cs b/src/Tasks/AssignCulture.cs
index 096efe5a0b7..f424e70f516 100644
--- a/src/Tasks/AssignCulture.cs
+++ b/src/Tasks/AssignCulture.cs
@@ -169,7 +169,7 @@ public override bool Execute()
                 {
                     Debug.Assert(false, "Unexpected exception in AssignCulture.Execute. " + 
                         "Please log a MSBuild bug specifying the steps to reproduce the problem. " + 
-                        e.Message);
+                        e);
                     throw;
                 }
 #endif
diff --git a/src/Tasks/AssignProjectConfiguration.cs b/src/Tasks/AssignProjectConfiguration.cs
index 7c4f8841a24..d69c23af424 100644
--- a/src/Tasks/AssignProjectConfiguration.cs
+++ b/src/Tasks/AssignProjectConfiguration.cs
@@ -43,7 +43,7 @@ public string DefaultToVcxPlatformMapping
             set
             {
                 _defaultToVcxPlatformMapping = value;
-                if (_defaultToVcxPlatformMapping != null && _defaultToVcxPlatformMapping.Length == 0)
+                if (_defaultToVcxPlatformMapping?.Length == 0)
                 {
                     _defaultToVcxPlatformMapping = null;
                 }
@@ -83,7 +83,7 @@ public string VcxToDefaultPlatformMapping
             {
                 _vcxToDefaultPlatformMapping = value;
 
-                if (_vcxToDefaultPlatformMapping != null && _vcxToDefaultPlatformMapping.Length == 0)
+                if (_vcxToDefaultPlatformMapping?.Length == 0)
                 {
                     _vcxToDefaultPlatformMapping = null;
                 }
diff --git a/src/Tasks/AssignTargetPath.cs b/src/Tasks/AssignTargetPath.cs
index 4c9f16e77c4..ffb085cfcf6 100644
--- a/src/Tasks/AssignTargetPath.cs
+++ b/src/Tasks/AssignTargetPath.cs
@@ -66,7 +66,7 @@ public override bool Execute()
                     (String.Compare(
                         fullRootPath, 0,
                         currentDirectory, 0,
-                        (fullRootPath.Length - 1) /* don't compare trailing slash */,
+                        fullRootPath.Length - 1 /* don't compare trailing slash */,
                         StringComparison.OrdinalIgnoreCase) == 0);
 
                 for (int i = 0; i < Files.Length; ++i)
diff --git a/src/Tasks/AxReference.cs b/src/Tasks/AxReference.cs
index 95136153fbc..2b7b15cd61a 100644
--- a/src/Tasks/AxReference.cs
+++ b/src/Tasks/AxReference.cs
@@ -22,6 +22,7 @@ internal class AxReference : AxTlbBaseReference
         /// internal constructor
         /// </summary>
         /// <param name="taskLoggingHelper">task logger instance used for logging</param>
+        /// <param name="silent">true if this task should log only errors, no warnings or messages; false otherwise</param>
         /// <param name="resolverCallback">callback interface for resolving dependent COM refs/NET assemblies</param>
         /// <param name="referenceInfo">cached reference information (typelib pointer, original task item, typelib name etc.)</param>
         /// <param name="itemName">reference name (for better logging experience)</param>
@@ -29,9 +30,10 @@ internal class AxReference : AxTlbBaseReference
         /// <param name="delaySign">delay sign wrappers?</param>
         /// <param name="keyFile">file containing public/private keys</param>
         /// <param name="keyContainer">container name for public/private keys</param>
-        /// <param name="executeAsTool">True if GenerateWrapper() should generate the wrapper out-of-proc using aximp.exe</param>
+        /// <param name="includeTypeLibVersionInName">True if the interop name should include the typelib's version</param>
         /// <param name="sdkToolsPath">Path to the SDK tools directory where aximp.exe can be found</param>
         /// <param name="buildEngine">BuildEngine of parent task; needed for logging purposes when generating wrapper out-of-proc</param>
+        /// <param name="environmentVariables">Array of equals-separated pairs of environment variables that should be passed to the spawned executable, in addition to (or selectively overriding) the regular environment block.</param>
         internal AxReference(TaskLoggingHelper taskLoggingHelper, bool silent, IComReferenceResolver resolverCallback, ComReferenceInfo referenceInfo, string itemName, string outputDirectory,
             bool delaySign, string keyFile, string keyContainer, bool includeTypeLibVersionInName, string sdkToolsPath, IBuildEngine buildEngine, string[] environmentVariables)
             : base(taskLoggingHelper, silent, resolverCallback, referenceInfo, itemName, outputDirectory, delaySign, keyFile, keyContainer, includeTypeLibVersionInName, true /* always execute as tool */, sdkToolsPath, buildEngine, environmentVariables)
@@ -56,7 +58,6 @@ protected override string GetWrapperFileNameInternal(string typeLibName)
         /// </summary>
         internal bool GenerateWrapper(out ComReferenceWrapperInfo wrapperInfo)
         {
-            wrapperInfo = null;
 
             // The tool gets the public key for itself, but we get it here anyway to
             // give nice messages in errors cases.
diff --git a/src/Tasks/AxTlbBaseReference.cs b/src/Tasks/AxTlbBaseReference.cs
index 39f3871bcf1..d0aa26be0fd 100644
--- a/src/Tasks/AxTlbBaseReference.cs
+++ b/src/Tasks/AxTlbBaseReference.cs
@@ -24,6 +24,7 @@ internal abstract class AxTlbBaseReference : ComReference
         /// internal constructor
         /// </summary>
         /// <param name="taskLoggingHelper">task logger instance used for logging</param>
+        /// <param name="silent">true if this task should log only errors, no warnings or messages; false otherwise</param>
         /// <param name="resolverCallback">callback interface for resolving dependent COM refs/NET assemblies</param>
         /// <param name="referenceInfo">cached reference information (typelib pointer, original task item, typelib name etc.)</param>
         /// <param name="itemName">reference name (for better logging experience)</param>
@@ -31,9 +32,11 @@ internal abstract class AxTlbBaseReference : ComReference
         /// <param name="delaySign">delay sign wrappers?</param>
         /// <param name="keyFile">file containing public/private keys</param>
         /// <param name="keyContainer">container name for public/private keys</param>
+        /// <param name="includeTypeLibVersionInName">True if the interop name should include the typelib's version</param>
         /// <param name="executeAsTool">True if GenerateWrapper() should generate the wrapper out-of-proc using aximp.exe or tlbimp.exe</param>
         /// <param name="toolPath">Path to the SDK tools directory where aximp.exe or tlbimp.exe can be found</param>
         /// <param name="buildEngine">BuildEngine of parent task; needed for logging purposes when generating wrapper out-of-proc</param>
+        /// <param name="environmentVariables">Array of equals-separated pairs of environment variables that should be passed to the spawned executable, in addition to (or selectively overriding) the regular environment block.</param>
         internal AxTlbBaseReference(TaskLoggingHelper taskLoggingHelper, bool silent, IComReferenceResolver resolverCallback, ComReferenceInfo referenceInfo, string itemName, string outputDirectory, bool delaySign, string keyFile, string keyContainer, bool includeTypeLibVersionInName, bool executeAsTool, string toolPath, IBuildEngine buildEngine, string[] environmentVariables)
             : base(taskLoggingHelper, silent, referenceInfo, itemName)
         {
@@ -176,7 +179,7 @@ protected virtual bool IsWrapperUpToDate(ComReferenceWrapperInfo wrapperInfo, Da
                 wrapperInfo.assembly = null;
             }
 
-            return (wrapperInfo.assembly != null);
+            return wrapperInfo.assembly != null;
         }
 
         /// <summary>
@@ -245,8 +248,6 @@ internal static string GetWrapperFileName(string interopDllHeader, string typeLi
         /// </summary>
         internal void GetAndValidateStrongNameKey(out StrongNameKeyPair keyPair, out byte[] publicKey)
         {
-            keyPair = null;
-            publicKey = null;
 
             // get key pair/public key
             StrongNameUtils.GetStrongNameKey(Log, KeyFile, KeyContainer, out keyPair, out publicKey);
diff --git a/src/Tasks/AxTlbBaseTask.cs b/src/Tasks/AxTlbBaseTask.cs
index 06937af99a7..56d376df3e4 100644
--- a/src/Tasks/AxTlbBaseTask.cs
+++ b/src/Tasks/AxTlbBaseTask.cs
@@ -105,9 +105,7 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens
         /// <returns>A string containing the full path of this tool, or null if the tool was not found</returns>
         protected override string GenerateFullPathToTool()
         {
-            string pathToTool = null;
-
-            pathToTool = SdkToolsPathUtility.GeneratePathToTool
+            string pathToTool = SdkToolsPathUtility.GeneratePathToTool
             (
                 SdkToolsPathUtility.FileInfoExists,
                 Utilities.ProcessorArchitecture.CurrentProcessArchitecture,
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index 036f9aee7d7..c3ecc2aac73 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -95,7 +95,7 @@ public string Path
             get => _path;
             set
             {
-                if (!_fInitialized || string.Compare(_path, value, StringComparison.OrdinalIgnoreCase) != 0)
+                if (!_fInitialized || !string.Equals(_path, value, StringComparison.OrdinalIgnoreCase))
                 {
                     _path = value;
                     Refresh();
@@ -510,7 +510,7 @@ private void Refresh()
                 StringBuilder productsOrder = new StringBuilder();
                 foreach (Product p in Products)
                 {
-                    productsOrder.Append(p.ProductCode + Environment.NewLine);
+                    productsOrder.Append(p.ProductCode).Append(Environment.NewLine);
                 }
                 DumpStringToFile(productsOrder.ToString(), "BootstrapperInstallOrder.txt", false);
             }
@@ -597,7 +597,7 @@ private void RefreshProducts()
                         int nStartIndex = packagePath.Length;
                         if ((strSubDirectory.ToCharArray())[nStartIndex] == System.IO.Path.DirectorySeparatorChar)
                         {
-                            nStartIndex = nStartIndex + 1;
+                            nStartIndex++;
                         }
 
                         ExploreDirectory(strSubDirectory.Substring(nStartIndex), rootElement, packagePath);
@@ -1460,7 +1460,7 @@ private bool BuildPackages(BuildSettings settings, XmlElement configElement, Res
                     }
 
                     if ((packageFileSource != null) && (packageFileDestination != null) &&
-                        ((packageFileCopy == null) || (String.Compare(packageFileCopy.Value, "False", StringComparison.InvariantCulture) != 0)))
+                        ((packageFileCopy == null) || (!String.Equals(packageFileCopy.Value, "False", StringComparison.InvariantCulture))))
                     {
                         // if this is the key for an external check, we will add it to the Resource Updater instead of copying the file
                         XmlNode subNode = null;
@@ -1612,7 +1612,7 @@ private static void ClearReadOnlyAttribute(string strFileName)
             FileAttributes attribs = File.GetAttributes(strFileName);
             if ((attribs & FileAttributes.ReadOnly) != 0)
             {
-                attribs = attribs & (~FileAttributes.ReadOnly);
+                attribs &= (~FileAttributes.ReadOnly);
                 File.SetAttributes(strFileName, attribs);
             }
         }
@@ -1945,8 +1945,7 @@ public static string XmlToConfigurationFile(XmlNode input)
                         {
                             // HACKHACK
                             string str = r.ReadToEnd();
-                            str = str.Replace("%NEWLINE%", Environment.NewLine);
-                            return str;
+                            return str.Replace("%NEWLINE%", Environment.NewLine);
                         }
                     }
                 }
@@ -2092,7 +2091,7 @@ private bool AddVerificationInformation(XmlNode packageFileNode, string fileSour
                     }
 
                     // If the public key in the file doesn't match the public key on disk, issue a build warning
-                    if (publicKey == null || !publicKey.ToLowerInvariant().Equals(publicKeyAttribute.Value.ToLowerInvariant()))
+                    if (publicKey?.Equals(publicKeyAttribute.Value, StringComparison.OrdinalIgnoreCase) == false)
                     {
                         results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.DifferingPublicKeys", PUBLICKEY_ATTRIBUTE, builder.Name, fileSource));
                     }
@@ -2105,7 +2104,7 @@ private bool AddVerificationInformation(XmlNode packageFileNode, string fileSour
                     ReplaceAttribute(packageFileNode, HASH_ATTRIBUTE, fileHash);
 
                     // If the public key in the file doesn't match the public key on disk, issue a build warning
-                    if (!fileHash.ToLowerInvariant().Equals(hashAttribute.Value.ToLowerInvariant()))
+                    if (!fileHash.Equals(hashAttribute.Value, StringComparison.OrdinalIgnoreCase))
                     {
                         results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.DifferingPublicKeys", "Hash", builder.Name, fileSource));
                     }
diff --git a/src/Tasks/BootstrapperUtil/Product.cs b/src/Tasks/BootstrapperUtil/Product.cs
index 93fd74ef4ae..542b9749106 100644
--- a/src/Tasks/BootstrapperUtil/Product.cs
+++ b/src/Tasks/BootstrapperUtil/Product.cs
@@ -213,7 +213,7 @@ internal XmlValidationResults GetPackageValidationResults(string culture)
             return ValidationResults?.PackageResults(culture);
         }
 
-        internal bool ValidationPassed => ValidationResults == null || ValidationResults.ValidationPassed;
+        internal bool ValidationPassed => ValidationResults?.ValidationPassed != false;
 
         internal ProductValidationResults ValidationResults { get; }
     }
diff --git a/src/Tasks/BootstrapperUtil/Util.cs b/src/Tasks/BootstrapperUtil/Util.cs
index 8cdc63b3a37..5afd9397329 100644
--- a/src/Tasks/BootstrapperUtil/Util.cs
+++ b/src/Tasks/BootstrapperUtil/Util.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.Globalization;
 using System.IO;
+using Microsoft.Build.Shared;
 using Microsoft.Win32;
 
 namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
@@ -19,6 +20,7 @@ internal static class Util
         private const string REGISTRY_DEFAULTPATH = "Path";
 
         private const string BOOTSTRAPPER_REGISTRY_ADDITIONAL_PACKAGE_PATHS_KEYNAME = "AdditionalPackagePaths";
+        private const string BOOTSTRAPPER_MSBUILD_ADDITIONAL_PACKAGES_PATH = "Microsoft\\VisualStudio\\BootstrapperPackages";
 
         private static string s_defaultPath;
         private static List<string> s_additionalPackagePaths;
@@ -182,6 +184,15 @@ public static List<string> AdditionalPackagePaths
                         }
                     }
 
+                    if (!string.IsNullOrEmpty(BuildEnvironmentHelper.Instance.MSBuildExtensionsPath))
+                    {
+                        string msbuildExtensionPackagesPath = Path.Combine(BuildEnvironmentHelper.Instance.MSBuildExtensionsPath, BOOTSTRAPPER_MSBUILD_ADDITIONAL_PACKAGES_PATH);
+                        if (Directory.Exists(msbuildExtensionPackagesPath))
+                        {
+                            additionalPackagePaths.Add(msbuildExtensionPackagesPath);
+                        }
+                    }
+
                     s_additionalPackagePaths = additionalPackagePaths;
                 }
 
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index 322979edfbb..990ee217fee 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -31,7 +31,7 @@ public class CodeTaskFactory : ITaskFactory
         /// This dictionary keeps track of custom references to compiled assemblies.  The in-memory assembly is loaded from a byte
         /// stream and as such its dependencies cannot be found unless they are in the MSBuild.exe directory or the GAC.  They
         /// cannot be found even if they are already loaded in the AppDomain.  This dictionary knows the FullName of the assembly
-        /// and a reference to the assembly itself.  In the <see cref="CurrentDomainOnAssemblyResolve"/> handler, the dictionary 
+        /// and a reference to the assembly itself.  In the <see cref="CurrentDomainOnAssemblyResolve"/> handler, the dictionary
         /// is used to return the loaded assemblies as a way to allow custom references that are not in the normal assembly Load
         /// context.
         /// </summary>
@@ -71,7 +71,7 @@ private static Assembly CurrentDomainOnAssemblyResolve(object sender, ResolveEve
         private static readonly ConcurrentDictionary<FullTaskSpecification, Assembly> s_compiledTaskCache = new ConcurrentDictionary<FullTaskSpecification, Assembly>();
 
         /// <summary>
-        /// The default assemblies to reference when compiling inline code. 
+        /// The default assemblies to reference when compiling inline code.
         /// </summary>
         private static List<string> s_defaultReferencedAssemblies;
 
@@ -81,7 +81,7 @@ private static Assembly CurrentDomainOnAssemblyResolve(object sender, ResolveEve
         private List<string> _referencedAssemblies;
 
         /// <summary>
-        /// Merged set of namespaces (default + specified) 
+        /// Merged set of namespaces (default + specified)
         /// </summary>
         private List<string> _usingNamespaces;
 
@@ -151,7 +151,7 @@ private static Assembly CurrentDomainOnAssemblyResolve(object sender, ResolveEve
         public Type TaskType { get; private set; }
 
         /// <summary>
-        /// The assemblies that the codetaskfactory should reference by default. 
+        /// The assemblies that the codetaskfactory should reference by default.
         /// </summary>
         private static List<string> DefaultReferencedAssemblies
         {
@@ -624,7 +624,7 @@ private bool HasInvalidChildNodes(XmlNode parentNode, XmlNodeType[] allowedNodeT
         }
 
         /// <summary>
-        /// Add a reference assembly to the list of references passed to the compiler. We will try and load the assembly to make sure it is found 
+        /// Add a reference assembly to the list of references passed to the compiler. We will try and load the assembly to make sure it is found
         /// before sending it to the compiler. The reason we load here is that we will be using it in this appdomin anyways as soon as we are going to compile, which should be right away.
         /// </summary>
         [SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", MessageId = "System.Reflection.Assembly.LoadWithPartialName", Justification = "Necessary since we don't have the full assembly name. ")]
diff --git a/src/Tasks/ComReference.cs b/src/Tasks/ComReference.cs
index 8c9c1718c32..ffa0fb88171 100644
--- a/src/Tasks/ComReference.cs
+++ b/src/Tasks/ComReference.cs
@@ -236,7 +236,6 @@ internal static void GetFuncDescForDescIndex(ITypeInfo typeInfo, int funcIndex,
         /// </summary>
         internal static bool GetTypeLibNameForITypeLib(TaskLoggingHelper log, bool silent, ITypeLib typeLib, string typeLibId, out string typeLibName)
         {
-            typeLibName = "";
 
             // see if the type library supports ITypeLib2
             if (!(typeLib is ITypeLib2 typeLib2))
@@ -254,7 +253,7 @@ internal static bool GetTypeLibNameForITypeLib(TaskLoggingHelper log, bool silen
 
                 // if returned namespace is null or its type is not System.String, fall back to the default 
                 // way of getting the type lib name (just to be safe)
-                if (data == null || string.Compare(data.GetType().ToString(), "system.string", StringComparison.OrdinalIgnoreCase) != 0)
+                if (data == null || !string.Equals(data.GetType().ToString(), "system.string", StringComparison.OrdinalIgnoreCase))
                 {
                     typeLibName = Marshal.GetTypeLibName(typeLib);
                     return true;
@@ -265,7 +264,7 @@ internal static bool GetTypeLibNameForITypeLib(TaskLoggingHelper log, bool silen
 
                 if (typeLibName.Length >= 4)
                 {
-                    if (string.Compare(typeLibName.Substring(typeLibName.Length - 4), ".dll", StringComparison.OrdinalIgnoreCase) == 0)
+                    if (string.Equals(typeLibName.Substring(typeLibName.Length - 4), ".dll", StringComparison.OrdinalIgnoreCase))
                     {
                         typeLibName = typeLibName.Substring(0, typeLibName.Length - 4);
                     }
@@ -328,6 +327,7 @@ internal static bool GetTypeLibNameForTypeLibAttrs(TaskLoggingHelper log, bool s
         /// Strips type library number from a type library path (for example, "ref.dll\2" becomes "ref.dll")
         /// </summary>
         /// <param name="typeLibPath">type library path with possible typelib number appended to it</param>
+        /// <param name="fileExists">Delegate to check whether the file exists</param>
         /// <returns>proper file path to the type library</returns>
         internal static string StripTypeLibNumberFromPath(string typeLibPath, FileExists fileExists)
         {
@@ -452,7 +452,7 @@ internal static bool GetPathOfTypeLib(TaskLoggingHelper log, bool silent, ref TY
                 return false;
             }
 
-            if (typeLibPath != null && typeLibPath.Length > 0)
+            if (!string.IsNullOrEmpty(typeLibPath))
             {
                 // We have to check for NULL here because QueryPathOfRegTypeLib() returns
                 // a BSTR with a NULL character appended to it.
diff --git a/src/Tasks/ComReferenceInfo.cs b/src/Tasks/ComReferenceInfo.cs
index 85e8cc3e3e2..9e433200cdd 100644
--- a/src/Tasks/ComReferenceInfo.cs
+++ b/src/Tasks/ComReferenceInfo.cs
@@ -134,7 +134,7 @@ internal bool InitializeWithTypeLibAttrs(TaskLoggingHelper log, bool silent, TYP
         /// </summary>
         internal bool InitializeWithPath(TaskLoggingHelper log, bool silent, string path, ITaskItem originalTaskItem, string targetProcessorArchitecture)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(path, "path");
+            ErrorUtilities.VerifyThrowArgumentNull(path, nameof(path));
 
             this.taskItem = originalTaskItem;
 
diff --git a/src/Tasks/ComReferenceTypes.cs b/src/Tasks/ComReferenceTypes.cs
index c6b553c19ee..ecb520e3a25 100644
--- a/src/Tasks/ComReferenceTypes.cs
+++ b/src/Tasks/ComReferenceTypes.cs
@@ -20,7 +20,7 @@ internal static class ComReferenceTypes
         /// </summary>
         internal static bool IsTlbImp(string refType)
         {
-            return (string.Compare(refType, ComReferenceTypes.tlbimp, StringComparison.OrdinalIgnoreCase) == 0);
+            return string.Equals(refType, ComReferenceTypes.tlbimp, StringComparison.OrdinalIgnoreCase);
         }
 
         /// <summary>
@@ -28,7 +28,7 @@ internal static bool IsTlbImp(string refType)
         /// </summary>
         internal static bool IsAxImp(string refType)
         {
-            return (string.Compare(refType, ComReferenceTypes.aximp, StringComparison.OrdinalIgnoreCase) == 0);
+            return string.Equals(refType, ComReferenceTypes.aximp, StringComparison.OrdinalIgnoreCase);
         }
 
         /// <summary>
@@ -36,7 +36,7 @@ internal static bool IsAxImp(string refType)
         /// </summary>
         internal static bool IsPia(string refType)
         {
-            return (string.Compare(refType, ComReferenceTypes.primary, StringComparison.OrdinalIgnoreCase) == 0);
+            return string.Equals(refType, ComReferenceTypes.primary, StringComparison.OrdinalIgnoreCase);
         }
 
         /// <summary>
@@ -44,7 +44,7 @@ internal static bool IsPia(string refType)
         /// </summary>
         internal static bool IsPiaOrTlbImp(string refType)
         {
-            return (string.Compare(refType, ComReferenceTypes.primaryortlbimp, StringComparison.OrdinalIgnoreCase) == 0);
+            return string.Equals(refType, ComReferenceTypes.primaryortlbimp, StringComparison.OrdinalIgnoreCase);
         }
     }
 }
diff --git a/src/Tasks/CommandLineBuilderExtension.cs b/src/Tasks/CommandLineBuilderExtension.cs
index d2b8ba10fc7..eebdbc4f11a 100644
--- a/src/Tasks/CommandLineBuilderExtension.cs
+++ b/src/Tasks/CommandLineBuilderExtension.cs
@@ -70,7 +70,7 @@ string parameterName
             {
                 bool value = (bool)obj;
                 // Do not quote - or + as they are part of the switch
-                AppendSwitchUnquotedIfNotNull(switchName, (value ? "+" : "-"));
+                AppendSwitchUnquotedIfNotNull(switchName, value ? "+" : "-");
             }
         }
 
@@ -107,7 +107,7 @@ string choice2
             if (obj != null)
             {
                 bool value = (bool)obj;
-                AppendSwitchUnquotedIfNotNull(switchName, (value ? choice1 : choice2));
+                AppendSwitchUnquotedIfNotNull(switchName, value ? choice1 : choice2);
             }
         }
 
@@ -267,7 +267,7 @@ internal void AppendSwitchIfNotNull
                             if (!string.IsNullOrEmpty(metadataValue))
                             {
                                 // Treat attribute as a boolean flag?
-                                if (treatAsFlags == null || treatAsFlags[i] == false)
+                                if (treatAsFlags == null || !treatAsFlags[i])
                                 {
                                     // Not a boolean flag.
                                     CommandLine.Append(',');
@@ -286,7 +286,7 @@ internal void AppendSwitchIfNotNull
                             }
                             else
                             {
-                                if (treatAsFlags == null || treatAsFlags[i] == false)
+                                if (treatAsFlags == null || !treatAsFlags[i])
                                 {
                                     // If the caller of this method asked us to add metadata
                                     // A, B, and C, and metadata A doesn't exist on the item,
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index dd7906d532b..013176c94be 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -695,7 +695,7 @@ private bool DoCopyIfNecessary(FileState sourceFileState, FileState destinationF
                 // We only do the cheap check for identicalness here, we try the more expensive check
                 // of comparing the fullpaths of source and destination to see if they are identical,
                 // in the exception handler lower down.
-                else if (0 != String.Compare(
+                else if (!String.Equals(
                              sourceFileState.Name,
                              destinationFileState.Name,
                              StringComparison.OrdinalIgnoreCase))
@@ -892,7 +892,7 @@ private static bool PathsAreIdentical(string source, string destination)
             string fullSourcePath = Path.GetFullPath(source);
             string fullDestinationPath = Path.GetFullPath(destination);
             StringComparison filenameComparison = NativeMethodsShared.IsWindows ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal;
-            return (0 == String.Compare(fullSourcePath, fullDestinationPath, filenameComparison));
+            return String.Equals(fullSourcePath, fullDestinationPath, filenameComparison);
         }
 
     	private static int GetParallelismFromEnvironment()
diff --git a/src/Tasks/CreateCSharpManifestResourceName.cs b/src/Tasks/CreateCSharpManifestResourceName.cs
index f1692f87c1c..af7321ea80e 100644
--- a/src/Tasks/CreateCSharpManifestResourceName.cs
+++ b/src/Tasks/CreateCSharpManifestResourceName.cs
@@ -12,7 +12,7 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// Base class for task that determines the appropriate manifest resource name to 
+    /// Base class for task that determines the appropriate manifest resource name to
     /// assign to a given resx or other resource.
     /// </summary>
     public class CreateCSharpManifestResourceName : CreateManifestResourceName
@@ -20,8 +20,8 @@ public class CreateCSharpManifestResourceName : CreateManifestResourceName
         protected override string SourceFileExtension => ".cs";
 
         /// <summary>
-        /// Utility function for creating a C#-style manifest name from 
-        /// a resource name. 
+        /// Utility function for creating a C#-style manifest name from
+        /// a resource name.
         /// </summary>
         /// <param name="fileName">The file name of the dependent (usually a .resx)</param>
         /// <param name="linkFileName">The file name of the dependent (usually a .resx)</param>
@@ -64,7 +64,7 @@ The reason is that CreateManifestName can't be static because it is an
         }
 
         /// <summary>
-        /// Utility function for creating a C#-style manifest name from 
+        /// Utility function for creating a C#-style manifest name from
         /// a resource name. Note that this function attempts to emulate the
         /// Everret implementation of this code which can be found by searching for
         /// ComputeNonWFCResourceName() or ComputeWFCResourceName() in
@@ -102,7 +102,7 @@ TaskLoggingHelper log
             Culture.ItemCultureInfo info = Culture.GetItemCultureInfo(embeddedFileName, dependentUponFileName);
 
             // If the item has a culture override, respect that. 
-            if (!String.IsNullOrEmpty(culture))
+            if (!string.IsNullOrEmpty(culture))
             {
                 info.culture = culture;
             }
@@ -126,7 +126,7 @@ TaskLoggingHelper log
                     // Append the culture if there is one.        
                     if (!string.IsNullOrEmpty(info.culture))
                     {
-                        manifestName.Append(".").Append(info.culture);
+                        manifestName.Append('.').Append(info.culture);
                     }
                 }
             }
@@ -139,25 +139,30 @@ TaskLoggingHelper log
                 // Empty namespaces are allowed.
                 if (!string.IsNullOrEmpty(rootNamespace))
                 {
-                    manifestName.Append(rootNamespace).Append(".");
+                    manifestName.Append(rootNamespace).Append('.');
                 }
 
-                // Replace spaces in the directory name with underscores. Needed for compatibility with Everett.
-                // Note that spaces in the file name itself are preserved.
-                string everettCompatibleDirectoryName = MakeValidEverettIdentifier(Path.GetDirectoryName(info.cultureNeutralFilename));
-
                 // only strip extension for .resx and .restext files
-
                 string sourceExtension = Path.GetExtension(info.cultureNeutralFilename);
+                string directoryName = Path.GetDirectoryName(info.cultureNeutralFilename);
+
+                // append the directory name
+                manifestName.Append(MakeValidEverettIdentifier(directoryName));
                 if (
-                        (0 == String.Compare(sourceExtension, ".resx", StringComparison.OrdinalIgnoreCase))
+                        string.Equals(sourceExtension, resxFileExtension, StringComparison.OrdinalIgnoreCase)
                         ||
-                        (0 == String.Compare(sourceExtension, ".restext", StringComparison.OrdinalIgnoreCase))
+                        string.Equals(sourceExtension, restextFileExtension, StringComparison.OrdinalIgnoreCase)
                         ||
-                        (0 == String.Compare(sourceExtension, ".resources", StringComparison.OrdinalIgnoreCase))
+                        string.Equals(sourceExtension, resourcesFileExtension, StringComparison.OrdinalIgnoreCase)
                     )
                 {
-                    manifestName.Append(Path.Combine(everettCompatibleDirectoryName, Path.GetFileNameWithoutExtension(info.cultureNeutralFilename)));
+                    if (!string.IsNullOrEmpty(directoryName))
+                    {
+                        manifestName.Append('.');
+                    }
+
+                    // append the file name without extension
+                    manifestName.Append(Path.GetFileNameWithoutExtension(info.cultureNeutralFilename));
 
                     // Replace all '\' with '.'
                     manifestName.Replace(Path.DirectorySeparatorChar, '.');
@@ -166,18 +171,23 @@ TaskLoggingHelper log
                     // Append the culture if there is one.        
                     if (!string.IsNullOrEmpty(info.culture))
                     {
-                        manifestName.Append(".").Append(info.culture);
+                        manifestName.Append('.').Append(info.culture);
                     }
 
                     // If the original extension was .resources, add it back
-                    if (String.Equals(sourceExtension, ".resources", StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(sourceExtension, resourcesFileExtension, StringComparison.OrdinalIgnoreCase))
                     {
                         manifestName.Append(sourceExtension);
                     }
                 }
                 else
                 {
-                    manifestName.Append(Path.Combine(everettCompatibleDirectoryName, Path.GetFileName(info.cultureNeutralFilename)));
+                    if (!string.IsNullOrEmpty(directoryName))
+                    {
+                        manifestName.Append('.');
+                    }
+
+                    manifestName.Append(Path.GetFileName(info.cultureNeutralFilename));
 
                     // Replace all '\' with '.'
                     manifestName.Replace(Path.DirectorySeparatorChar, '.');
@@ -206,7 +216,7 @@ TaskLoggingHelper log
         protected override bool IsSourceFile(string fileName)
         {
             string extension = Path.GetExtension(fileName);
-            return (String.Compare(extension, ".cs", StringComparison.OrdinalIgnoreCase) == 0);
+            return string.Equals(extension, SourceFileExtension, StringComparison.OrdinalIgnoreCase);
         }
     }
 }
diff --git a/src/Tasks/CreateItem.cs b/src/Tasks/CreateItem.cs
index 472f4e0c5a8..cb7bd833620 100644
--- a/src/Tasks/CreateItem.cs
+++ b/src/Tasks/CreateItem.cs
@@ -99,7 +99,7 @@ private List<ITaskItem> CreateOutputItems(Dictionary<string, string> metadataTab
                 )
                 {
                     ITaskItem newItem = i;
-                    if (null != metadataTable)
+                    if (metadataTable != null)
                     {
                         foreach (KeyValuePair<string, string> nameAndValue in metadataTable)
                         {
diff --git a/src/Tasks/CreateManifestResourceName.cs b/src/Tasks/CreateManifestResourceName.cs
index bd2d61c9f29..f53eee09666 100644
--- a/src/Tasks/CreateManifestResourceName.cs
+++ b/src/Tasks/CreateManifestResourceName.cs
@@ -21,6 +21,9 @@ namespace Microsoft.Build.Tasks
     public abstract class CreateManifestResourceName : TaskExtension
     {
         #region Properties
+        internal const string resxFileExtension = ".resx";
+        internal const string restextFileExtension = ".restext";
+        internal const string resourcesFileExtension = ".resources";
 
         private ITaskItem[] _resourceFiles;
 
@@ -61,7 +64,6 @@ public ITaskItem[] ResourceFiles
         /// The resulting manifest names.
         /// </summary>
         /// <value></value>
-
         [Output]
         public ITaskItem[] ManifestResourceNames { get; private set; }
 
@@ -157,7 +159,7 @@ CreateFileStream createFileStream
                     // If not, fall back onto the extension.
                     if (string.IsNullOrEmpty(fileType))
                     {
-                        isResxFile = Path.GetExtension(fileName) == ".resx";
+                        isResxFile = Path.GetExtension(fileName) == resxFileExtension;
                     }
 
                     // If opted into convention and no DependentUpon metadata and is a resx file, reference "<filename>.<ext>" (.cs or .vb) if it exists.
@@ -234,8 +236,8 @@ CreateFileStream createFileStream
                     // Add a LogicalName metadata to Non-Resx resources
                     // LogicalName isn't used for Resx resources because the ManifestResourceName metadata determines the filename of the 
                     // .resources file which then is used as the embedded resource manifest name                    
-                    if (String.IsNullOrEmpty(ResourceFilesWithManifestResourceNames[i].GetMetadata("LogicalName")) &&
-                        String.Equals(ResourceFilesWithManifestResourceNames[i].GetMetadata("Type"), "Non-Resx", StringComparison.OrdinalIgnoreCase))
+                    if (string.IsNullOrEmpty(ResourceFilesWithManifestResourceNames[i].GetMetadata("LogicalName")) &&
+                        string.Equals(ResourceFilesWithManifestResourceNames[i].GetMetadata("Type"), "Non-Resx", StringComparison.OrdinalIgnoreCase))
                     {
                         ResourceFilesWithManifestResourceNames[i].SetMetadata("LogicalName", manifestName);
                     }
@@ -296,38 +298,25 @@ private static bool IsValidEverettIdChar(char c)
         /// <summary>
         /// Make a folder subname into an Everett-compatible identifier 
         /// </summary>
-        private static string MakeValidEverettSubFolderIdentifier(string subName)
+        private static void MakeValidEverettSubFolderIdentifier(StringBuilder builder, string subName)
         {
             ErrorUtilities.VerifyThrowArgumentNull(subName, nameof(subName));
 
-            if (subName.Length == 0)
-            {
-                return subName;
-            }
-
-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the
-            // original - if the first character is an invalid first identifier character but a valid subsequent one,
-            // we prepend an underscore to it.
-            var everettId = new StringBuilder(subName.Length + 1);
+            if (string.IsNullOrEmpty(subName)) { return; }
 
             // the first character has stronger restrictions than the rest
-            if (!IsValidEverettIdFirstChar(subName[0]))
+            if (IsValidEverettIdFirstChar(subName[0]))
             {
-                // if the first character is not even a valid subsequent character, replace it with an underscore
-                if (!IsValidEverettIdChar(subName[0]))
-                {
-                    everettId.Append('_');
-                }
-                // if it is a valid subsequent character, prepend an underscore to it
-                else
-                {
-                    everettId.Append('_');
-                    everettId.Append(subName[0]);
-                }
+                builder.Append(subName[0]);
             }
             else
             {
-                everettId.Append(subName[0]);
+                builder.Append('_');
+                if (IsValidEverettIdChar(subName[0]))
+                {
+                    // if it is a valid subsequent character, prepend an underscore to it
+                    builder.Append(subName[0]);
+                }
             }
 
             // process the rest of the subname
@@ -335,47 +324,44 @@ private static string MakeValidEverettSubFolderIdentifier(string subName)
             {
                 if (!IsValidEverettIdChar(subName[i]))
                 {
-                    everettId.Append('_');
+                    builder.Append('_');
                 }
                 else
                 {
-                    everettId.Append(subName[i]);
+                    builder.Append(subName[i]);
                 }
             }
-
-            return everettId.ToString();
         }
 
         /// <summary>
         /// Make a folder name into an Everett-compatible identifier
         /// </summary>
-        internal static string MakeValidEverettFolderIdentifier(string name)
+        internal static void MakeValidEverettFolderIdentifier(StringBuilder builder, string name)
         {
             ErrorUtilities.VerifyThrowArgumentNull(name, nameof(name));
 
-            // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the
-            // original - if the name is a single underscore we add another underscore to it
-            var everettId = new StringBuilder(name.Length + 1);
+            if (string.IsNullOrEmpty(name)) { return; }
+
+            // store the original length for use later
+            int length = builder.Length;
 
             // split folder name into subnames separated by '.', if any
             string[] subNames = name.Split(MSBuildConstants.DotChar);
 
             // convert each subname separately
-            everettId.Append(MakeValidEverettSubFolderIdentifier(subNames[0]));
+            MakeValidEverettSubFolderIdentifier(builder, subNames[0]);
 
             for (int i = 1; i < subNames.Length; i++)
             {
-                everettId.Append('.');
-                everettId.Append(MakeValidEverettSubFolderIdentifier(subNames[i]));
+                builder.Append('.');
+                MakeValidEverettSubFolderIdentifier(builder, subNames[i]);
             }
 
             // folder name cannot be a single underscore - add another underscore to it
-            if (everettId.ToString() == "_")
+            if ((builder.Length - length) == 1 && builder[length] == '_')
             {
-                everettId.Append('_');
+                builder.Append('_');
             }
-
-            return everettId.ToString();
         }
 
         /// <summary>
@@ -385,6 +371,7 @@ internal static string MakeValidEverettFolderIdentifier(string name)
         public static string MakeValidEverettIdentifier(string name)
         {
             ErrorUtilities.VerifyThrowArgumentNull(name, nameof(name));
+            if (string.IsNullOrEmpty(name)) { return name; }
 
             var everettId = new StringBuilder(name.Length);
 
@@ -392,12 +379,12 @@ public static string MakeValidEverettIdentifier(string name)
             string[] subNames = name.Split(MSBuildConstants.ForwardSlashBackslash);
 
             // convert every folder name
-            everettId.Append(MakeValidEverettFolderIdentifier(subNames[0]));
+            MakeValidEverettFolderIdentifier(everettId, subNames[0]);
 
             for (int i = 1; i < subNames.Length; i++)
             {
                 everettId.Append('.');
-                everettId.Append(MakeValidEverettFolderIdentifier(subNames[i]));
+                MakeValidEverettFolderIdentifier(everettId, subNames[i]);
             }
 
             return everettId.ToString();
diff --git a/src/Tasks/CreateVisualBasicManifestResourceName.cs b/src/Tasks/CreateVisualBasicManifestResourceName.cs
index a8bcf32e475..4d656ba43ee 100644
--- a/src/Tasks/CreateVisualBasicManifestResourceName.cs
+++ b/src/Tasks/CreateVisualBasicManifestResourceName.cs
@@ -10,7 +10,7 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// Base class for task that determines the appropriate manifest resource name to 
+    /// Base class for task that determines the appropriate manifest resource name to
     /// assign to a given resx or other resource.
     /// </summary>
     public class CreateVisualBasicManifestResourceName : CreateManifestResourceName
@@ -18,8 +18,8 @@ public class CreateVisualBasicManifestResourceName : CreateManifestResourceName
         protected override string SourceFileExtension => ".vb";
 
         /// <summary>
-        /// Utility function for creating a VB-style manifest name from 
-        /// a resource name. 
+        /// Utility function for creating a VB-style manifest name from
+        /// a resource name.
         /// </summary>
         /// <param name="fileName">The file name of the dependent (usually a .resx)</param>
         /// <param name="linkFileName">The file name of the dependent (usually a .resx)</param>
@@ -62,7 +62,7 @@ The reason is that CreateManifestName can't be static because it is an
         }
 
         /// <summary>
-        /// Utility function for creating a VB-style manifest name from 
+        /// Utility function for creating a VB-style manifest name from
         /// a resource name. Note that this function attempts to emulate the
         /// Everret implementation of this code which can be found by searching for
         /// ComputeNonWFCResourceName() or ComputeWFCResourceName() in
@@ -99,7 +99,7 @@ TaskLoggingHelper log
             Culture.ItemCultureInfo info = Culture.GetItemCultureInfo(embeddedFileName, dependentUponFileName);
 
             // If the item has a culture override, respect that. 
-            if (!String.IsNullOrEmpty(culture))
+            if (!string.IsNullOrEmpty(culture))
             {
                 info.culture = culture;
             }
@@ -120,17 +120,16 @@ TaskLoggingHelper log
                 {
                     if (!string.IsNullOrEmpty(rootNamespace))
                     {
-                        manifestName.Append(rootNamespace).Append(".").Append(result.Name);
-                    }
-                    else
-                    {
-                        manifestName.Append(result.Name);
+                        manifestName.Append(rootNamespace).Append('.');
                     }
 
+                    manifestName.Append(result.Name);
+
+
                     // Append the culture if there is one.        
                     if (!string.IsNullOrEmpty(info.culture))
                     {
-                        manifestName.Append(".").Append(info.culture);
+                        manifestName.Append('.').Append(info.culture);
                     }
                 }
             }
@@ -143,17 +142,17 @@ TaskLoggingHelper log
                 // Empty namespaces are allowed.
                 if (!string.IsNullOrEmpty(rootNamespace))
                 {
-                    manifestName.Append(rootNamespace).Append(".");
+                    manifestName.Append(rootNamespace).Append('.');
                 }
 
                 // only strip extension for .resx and .restext files
                 string sourceExtension = Path.GetExtension(info.cultureNeutralFilename);
                 if (
-                        (0 == String.Compare(sourceExtension, ".resx", StringComparison.OrdinalIgnoreCase))
+                        string.Equals(sourceExtension, resxFileExtension, StringComparison.OrdinalIgnoreCase)
                         ||
-                        (0 == String.Compare(sourceExtension, ".restext", StringComparison.OrdinalIgnoreCase))
+                        string.Equals(sourceExtension, restextFileExtension, StringComparison.OrdinalIgnoreCase)
                         ||
-                        (0 == String.Compare(sourceExtension, ".resources", StringComparison.OrdinalIgnoreCase))
+                        string.Equals(sourceExtension, resourcesFileExtension, StringComparison.OrdinalIgnoreCase)
                     )
                 {
                     manifestName.Append(Path.GetFileNameWithoutExtension(info.cultureNeutralFilename));
@@ -161,11 +160,11 @@ TaskLoggingHelper log
                     // Append the culture if there is one.        
                     if (!string.IsNullOrEmpty(info.culture))
                     {
-                        manifestName.Append(".").Append(info.culture);
+                        manifestName.Append('.').Append(info.culture);
                     }
 
                     // If the original extension was .resources, add it back
-                    if (String.Equals(sourceExtension, ".resources", StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(sourceExtension, resourcesFileExtension, StringComparison.OrdinalIgnoreCase))
                     {
                         manifestName.Append(sourceExtension);
                     }
@@ -197,8 +196,7 @@ TaskLoggingHelper log
         protected override bool IsSourceFile(string fileName)
         {
             string extension = Path.GetExtension(fileName);
-
-            return (String.Compare(extension, ".vb", StringComparison.OrdinalIgnoreCase) == 0);
+            return string.Equals(extension, SourceFileExtension, StringComparison.OrdinalIgnoreCase);
         }
     }
 }
diff --git a/src/Tasks/Culture.cs b/src/Tasks/Culture.cs
index 30b61bd2c5b..6dc32800ee3 100644
--- a/src/Tasks/Culture.cs
+++ b/src/Tasks/Culture.cs
@@ -36,7 +36,7 @@ string dependentUponFilename
             info.culture = null;
             string parentName = dependentUponFilename ?? String.Empty;
 
-            if (0 == String.Compare(Path.GetFileNameWithoutExtension(parentName),
+            if (String.Equals(Path.GetFileNameWithoutExtension(parentName),
                                    Path.GetFileNameWithoutExtension(name),
                                    StringComparison.OrdinalIgnoreCase))
             {
@@ -57,7 +57,7 @@ string dependentUponFilename
 
                 // See if this is a valid culture name.
                 bool validCulture = false;
-                if ((cultureName != null) && (cultureName.Length > 1))
+                if ((cultureName?.Length > 1))
                 {
                     // ... strip the "." to make "en-US"
                     cultureName = cultureName.Substring(1);
diff --git a/src/Tasks/Delegate.cs b/src/Tasks/Delegate.cs
index f9363684e4b..563f6c39e0e 100644
--- a/src/Tasks/Delegate.cs
+++ b/src/Tasks/Delegate.cs
@@ -22,6 +22,7 @@ namespace Microsoft.Build.Tasks
     /// File SetAttributes delegate
     /// </summary>
     /// <param name="path">The path to set attributes for.</param>
+    /// <param name="attributes">The actual file attributes.</param>
     internal delegate void SetAttributes(string path, FileAttributes attributes);
 
     /// <summary>
@@ -82,8 +83,10 @@ namespace Microsoft.Build.Tasks
     /// assemblies and  the list of scatter files.
     /// </summary>
     /// <param name="path">Path to the assembly.</param>
+    /// <param name="assemblyMetadataCache">Assembly metadata cache.</param>
     /// <param name="dependencies">Receives the list of dependencies.</param>
     /// <param name="scatterFiles">Receives the list of associated scatter files.</param>
+    /// <param name="frameworkNameAttribute">The framework name</param>
     internal delegate void GetAssemblyMetadata
     (
         string path,
diff --git a/src/Tasks/DependencyFile.cs b/src/Tasks/DependencyFile.cs
index 67b4b936a7c..f8306894c3b 100644
--- a/src/Tasks/DependencyFile.cs
+++ b/src/Tasks/DependencyFile.cs
@@ -79,7 +79,7 @@ internal bool HasFileChanged()
             FileInfo info = FileUtilities.GetFileInfoNoThrow(filename);
 
             // Obviously if the file no longer exists then we are not up to date.
-            if (info == null || !info.Exists)
+            if (info?.Exists != true)
             {
                 return true;
             }
diff --git a/src/Tasks/DownloadFile.cs b/src/Tasks/DownloadFile.cs
index f3cbccfde1d..1f9181ec72e 100644
--- a/src/Tasks/DownloadFile.cs
+++ b/src/Tasks/DownloadFile.cs
@@ -131,6 +131,7 @@ private async Task<bool> ExecuteAsync()
         /// Attempts to download the file.
         /// </summary>
         /// <param name="uri">The parsed <see cref="Uri"/> of the request.</param>
+        /// <param name="cancellationToken">The cancellation token for the task.</param>
         private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)
         {
             // The main reason to use HttpClient vs WebClient is because we can pass a message handler for unit tests to mock
diff --git a/src/Tasks/Error.cs b/src/Tasks/Error.cs
index cfaa4fcd28a..8cec712ea53 100644
--- a/src/Tasks/Error.cs
+++ b/src/Tasks/Error.cs
@@ -21,7 +21,7 @@ public sealed class Error : TaskExtension
 
         /// <summary>
         /// Relevant file if any.
-        /// If none is provided, the file containing the Error 
+        /// If none is provided, the file containing the Error
         /// task will be used.
         /// </summary>
         public string File { get; set; }
@@ -31,13 +31,18 @@ public sealed class Error : TaskExtension
         /// </summary>
         public string HelpKeyword { get; set; }
 
+        /// <summary>
+        /// A link pointing to more information about the error
+        /// </summary>
+        public string HelpLink { get; set; }
+
         /// <summary>
         /// Main task method
         /// </summary>
         /// <returns></returns>
         public override bool Execute()
         {
-            Log.LogError(null, Code, HelpKeyword, File, 0, 0, 0, 0, Text ?? TaskResources.GetString("ErrorAndWarning.EmptyMessage"));
+            Log.LogError(null, Code, HelpKeyword, HelpLink, File, 0, 0, 0, 0, Text ?? TaskResources.GetString("ErrorAndWarning.EmptyMessage"));
 
             // careful to return false. Otherwise the build would continue.
             return false;
diff --git a/src/Tasks/ErrorFromResources.cs b/src/Tasks/ErrorFromResources.cs
index 596fc974f4c..83c5f106d6a 100644
--- a/src/Tasks/ErrorFromResources.cs
+++ b/src/Tasks/ErrorFromResources.cs
@@ -51,7 +51,7 @@ public override bool Execute()
                 string message = ResourceUtilities.ExtractMessageCode(false /* all codes */, Log.FormatResourceString(Resource, Arguments), out string errorCode);
 
                 // If the user specifies a code, that should override. 
-                Code = Code ?? errorCode;
+                Code ??= errorCode;
 
                 Log.LogError(null, Code, HelpKeyword, File, 0, 0, 0, 0, message);
             }
diff --git a/src/Tasks/Exec.cs b/src/Tasks/Exec.cs
index 35db2490c74..df817422bfd 100644
--- a/src/Tasks/Exec.cs
+++ b/src/Tasks/Exec.cs
@@ -617,7 +617,6 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens
 
                 commandLine.AppendFileNameIfNotNull(batchFileForCommandLine);
             }
-            
         }
 
         #endregion
diff --git a/src/Tasks/FileIO/GetFileHash.cs b/src/Tasks/FileIO/GetFileHash.cs
index 39ad392e8f8..0a6095e5d58 100644
--- a/src/Tasks/FileIO/GetFileHash.cs
+++ b/src/Tasks/FileIO/GetFileHash.cs
@@ -115,15 +115,12 @@ public override bool Execute()
 
         internal static string EncodeHash(HashEncoding encoding, byte[] hash)
         {
-            switch (encoding)
+            return encoding switch
             {
-                case Tasks.HashEncoding.Hex:
-                    return ConversionUtilities.ConvertByteArrayToHex(hash);
-                case Tasks.HashEncoding.Base64:
-                    return Convert.ToBase64String(hash);
-                default:
-                    throw new NotImplementedException();
-            }
+                Tasks.HashEncoding.Hex => ConversionUtilities.ConvertByteArrayToHex(hash),
+                Tasks.HashEncoding.Base64 => Convert.ToBase64String(hash),
+                _ => throw new NotImplementedException(),
+            };
         }
 
         internal static bool TryParseHashEncoding(string value, out HashEncoding encoding)
diff --git a/src/Tasks/FileState.cs b/src/Tasks/FileState.cs
index f6e8010e4e9..c979b21be5b 100644
--- a/src/Tasks/FileState.cs
+++ b/src/Tasks/FileState.cs
@@ -148,7 +148,6 @@ public FileDirInfo(string filename)
                             IsReadOnly = fileInfo.IsReadOnly;
                             LastWriteTimeUtc = fileInfo.LastWriteTimeUtc;
                             Length = fileInfo.Length;
-
                         }
                         else
                         {
@@ -162,7 +161,6 @@ public FileDirInfo(string filename)
                                 IsReadOnly = false;
                                 LastWriteTimeUtc = directoryInfo.LastWriteTimeUtc;
                             }
-
                         }
                     }
                 }
diff --git a/src/Tasks/GenerateManifestBase.cs b/src/Tasks/GenerateManifestBase.cs
index 1e78ee56ee2..7aa4cfd5f95 100644
--- a/src/Tasks/GenerateManifestBase.cs
+++ b/src/Tasks/GenerateManifestBase.cs
@@ -28,7 +28,6 @@ private enum DependencyType { Install, Prerequisite };
         protected abstract bool OnManifestResolved(Manifest manifest);
         protected abstract Type GetObjectType();
 
-
         protected GenerateManifestBase() : base(AssemblyResources.PrimaryResources, "MSBuild.")
         {
         }
@@ -92,24 +91,14 @@ protected internal AssemblyReference AddAssemblyFromItem(ITaskItem item)
                 return null;
             }
 
-            AssemblyReferenceType referenceType;
             AssemblyType assemblyType = GetItemAssemblyType(item);
-            switch (assemblyType)
+            AssemblyReferenceType referenceType = assemblyType switch
             {
-                case AssemblyType.Managed:
-                    referenceType = AssemblyReferenceType.ManagedAssembly;
-                    break;
-                case AssemblyType.Native:
-                    referenceType = AssemblyReferenceType.NativeAssembly;
-                    break;
-                case AssemblyType.Satellite:
-                    referenceType = AssemblyReferenceType.ManagedAssembly;
-                    break;
-                default:
-                    referenceType = AssemblyReferenceType.Unspecified;
-                    break;
-            }
-
+                AssemblyType.Managed => AssemblyReferenceType.ManagedAssembly,
+                AssemblyType.Native => AssemblyReferenceType.NativeAssembly,
+                AssemblyType.Satellite => AssemblyReferenceType.ManagedAssembly,
+                _ => AssemblyReferenceType.Unspecified,
+            };
             DependencyType dependencyType = GetItemDependencyType(item);
             AssemblyReference assembly;
             if (dependencyType == DependencyType.Install)
@@ -252,12 +241,12 @@ private AssemblyIdentity CreateAssemblyIdentity(AssemblyIdentity baseIdentity, A
                     // Don't need publicKeyToken attribute for non-ClickOnce case
                     publicKeyToken = null;
                     // Language attribute should be omitted if neutral
-                    if (String.Compare(culture, "neutral", StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(culture, "neutral", StringComparison.OrdinalIgnoreCase))
                     {
                         culture = null;
                     }
                     // WinXP loader doesn't understand "msil"
-                    if (String.Compare(_processorArchitecture, "msil", StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(_processorArchitecture, "msil", StringComparison.OrdinalIgnoreCase))
                     {
                         _processorArchitecture = null;
                     }
@@ -330,7 +319,7 @@ protected internal FileReference FindFileFromItem(ITaskItem item)
             }
             foreach (FileReference file in _manifest.FileReferences)
             {
-                if (String.Compare(targetPath, file.TargetPath, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(targetPath, file.TargetPath, StringComparison.OrdinalIgnoreCase))
                 {
                     return file;
                 }
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index cb87f14e533..5fc96169dcf 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -50,7 +50,6 @@ namespace Microsoft.Build.Tasks
     public sealed partial class GenerateResource : TaskExtension
     {
 
-
 #region Fields
 
         // This cache helps us track the linked resource files listed inside of a resx resource file
@@ -627,7 +626,7 @@ private void GenerateResGenCommandLineWithoutResources(CommandLineBuilderExtensi
         {
             // Throw an internal error, since this method should only ever get called by other aspects of this task, not
             // anything that the user touches.
-            ErrorUtilities.VerifyThrowInternalNull(resGenCommand, "resGenCommand");
+            ErrorUtilities.VerifyThrowInternalNull(resGenCommand, nameof(resGenCommand));
 
             // append the /useSourcePath flag if requested.
             if (UseSourcePath)
@@ -692,7 +691,6 @@ public override bool Execute()
                     Sources = newSources.ToArray();
                 }
 
-
                 // If there are no sources to process, just return (with success) and report the condition.
                 if ((Sources == null) || (Sources.Length == 0))
                 {
@@ -836,7 +834,7 @@ public override bool Execute()
                             this.StronglyTypedClassName = process.StronglyTypedClassName; // in case a default was chosen
                             this.StronglyTypedFileName = process.StronglyTypedFilename;   // in case a default was chosen
                             _stronglyTypedResourceSuccessfullyCreated = process.StronglyTypedResourceSuccessfullyCreated;
-                            if (null != process.UnsuccessfullyCreatedOutFiles)
+                            if (process.UnsuccessfullyCreatedOutFiles != null)
                             {
                                 foreach (string item in process.UnsuccessfullyCreatedOutFiles)
                                 {
@@ -957,7 +955,7 @@ private bool IsDangerous(String filename)
                 internetSecurityManager = (IInternetSecurityManager)Activator.CreateInstance(iismType);
             }
 
-            Int32 zone = 0;
+            int zone;
             internetSecurityManager.MapUrlToZone(Path.GetFullPath(filename), out zone, 0);
             if (zone < ZoneInternet)
             {
@@ -1069,7 +1067,7 @@ private bool ComputePathToResGen()
             {
                 _resgenPath = ToolLocationHelper.GetPathToDotNetFrameworkSdkFile("resgen.exe", TargetDotNetFrameworkVersion.Version35);
 
-                if (null == _resgenPath && ExecuteAsTool)
+                if (_resgenPath == null && ExecuteAsTool)
                 {
                     Log.LogErrorWithCodeFromResources("General.PlatformSDKFileNotFound", "resgen.exe",
                         ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(TargetDotNetFrameworkVersion.Version35),
@@ -1087,7 +1085,7 @@ private bool ComputePathToResGen()
                     ExecuteAsTool);
             }
 
-            if (null == _resgenPath && !ExecuteAsTool)
+            if (_resgenPath == null && !ExecuteAsTool)
             {
                 // if Resgen.exe is not installed, just use the filename
                 _resgenPath = String.Empty;
@@ -1136,13 +1134,13 @@ private bool GenerateResourcesUsingResGen(List<ITaskItem> inputsToProcess, List<
 #endif
         }
 
-
 #if FEATURE_RESGEN
         /// <summary>
         /// Given an instance of the ResGen task with everything but the strongly typed
         /// resource-related parameters filled out, execute the task and return the result
         /// </summary>
-        /// <param name="resGen">The task to execute.</param>
+        /// <param name="inputsToProcess">Input files to give to resgen.exe.</param>
+        /// <param name="outputsToProcess">Output files to give to resgen.exe.</param>
         private bool TransformResourceFilesUsingResGen(List<ITaskItem> inputsToProcess, List<ITaskItem> outputsToProcess)
         {
             ErrorUtilities.VerifyThrow(inputsToProcess.Count != 0, "There should be resource files to process");
@@ -1177,7 +1175,6 @@ private bool TransformResourceFilesUsingResGen(List<ITaskItem> inputsToProcess,
             else
             {
                 int initialResourceIndex = 0;
-                int numberOfResourcesToAdd = 0;
                 bool doneProcessingResources = false;
                 CommandLineBuilderExtension resourcelessCommandBuilder = new CommandLineBuilderExtension();
                 string resourcelessCommand = null;
@@ -1191,7 +1188,7 @@ private bool TransformResourceFilesUsingResGen(List<ITaskItem> inputsToProcess,
 
                 while (!doneProcessingResources)
                 {
-                    numberOfResourcesToAdd = CalculateResourceBatchSize(inputsToProcess, outputsToProcess, resourcelessCommand, initialResourceIndex);
+                    int numberOfResourcesToAdd = CalculateResourceBatchSize(inputsToProcess, outputsToProcess, resourcelessCommand, initialResourceIndex);
                     ResGen resGen = CreateResGenTaskWithDefaultParameters();
 
                     resGen.InputFiles = inputsToProcess.GetRange(initialResourceIndex, numberOfResourcesToAdd).ToArray();
@@ -1246,7 +1243,7 @@ private int CalculateResourceBatchSize(List<ITaskItem> inputsToProcess, List<ITa
                 i++;
             }
 
-            int numberOfResourcesToAdd = 0;
+            int numberOfResourcesToAdd;
             if (currentCommand.Length <= s_maximumCommandLength)
             {
                 // We've successfully added all the rest.
@@ -1265,7 +1262,8 @@ private int CalculateResourceBatchSize(List<ITaskItem> inputsToProcess, List<ITa
         /// Given an instance of the ResGen task with everything but the strongly typed
         /// resource-related parameters filled out, execute the task and return the result
         /// </summary>
-        /// <param name="resGen">The task to execute.</param>
+        /// <param name="inputsToProcess">Input files to give to resgen.exe.</param>
+        /// <param name="outputsToProcess">Output files to give to resgen.exe.</param>
         private bool GenerateStronglyTypedResourceUsingResGen(List<ITaskItem> inputsToProcess, List<ITaskItem> outputsToProcess)
         {
             ErrorUtilities.VerifyThrow(inputsToProcess.Count == 1 && outputsToProcess.Count == 1, "For STR, there should only be one input and one output.");
@@ -1302,7 +1300,6 @@ private bool GenerateStronglyTypedResourceUsingResGen(List<ITaskItem> inputsToPr
         /// Factoring out the setting of the default parameters to the
         /// ResGen task.
         /// </summary>
-        /// <param name="resGen"></param>
         private ResGen CreateResGenTaskWithDefaultParameters()
         {
             ResGen resGen = new ResGen();
@@ -1391,7 +1388,7 @@ private void GetResourcesToProcess(out List<ITaskItem> inputsToProcess, out List
                     // However, our cache will sometimes record all the info we need (for incremental builds).
                     string sourceFileName = Sources[i].ItemSpec;
                     ResGenDependencies.PortableLibraryFile library = _cache.TryGetPortableLibraryInfo(sourceFileName);
-                    if (library != null && library.AllOutputFilesAreUpToDate())
+                    if (library?.AllOutputFilesAreUpToDate() == true)
                     {
                         AppendCachedOutputTaskItems(library, cachedOutputFiles);
                     }
@@ -1442,7 +1439,7 @@ private void GetResourcesToProcess(out List<ITaskItem> inputsToProcess, out List
         /// <summary>
         /// Given a cached portable library that is up to date, create ITaskItems to represent the output of the task, as if we did real work.
         /// </summary>
-        /// <param name="library">The portable library cache entry to extract output files & metadata from.</param>
+        /// <param name="library">The portable library cache entry to extract output files and metadata from.</param>
         /// <param name="cachedOutputFiles">List of output files produced from the cache.</param>
         private void AppendCachedOutputTaskItems(ResGenDependencies.PortableLibraryFile library, List<ITaskItem> cachedOutputFiles)
         {
@@ -1741,7 +1738,6 @@ private void UpdateNewestUncorrelatedInputWriteTime()
         /// needed, it should always err on the side of returning 'true'. This
         /// is because a separate AppDomain, while slow to create, is always safe.
         /// </summary>
-        /// <param name="sources">The list of .resx files.</param>
         /// <returns></returns>
         private bool NeedSeparateAppDomain()
         {
@@ -1755,15 +1751,15 @@ private bool NeedSeparateAppDomain()
             {
                 string extension = Path.GetExtension(source.ItemSpec);
 
-                if (String.Compare(extension, ".resources.dll", StringComparison.OrdinalIgnoreCase) == 0 ||
-                    String.Compare(extension, ".dll", StringComparison.OrdinalIgnoreCase) == 0 ||
-                    String.Compare(extension, ".exe", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(extension, ".resources.dll", StringComparison.OrdinalIgnoreCase) ||
+                    String.Equals(extension, ".dll", StringComparison.OrdinalIgnoreCase) ||
+                    String.Equals(extension, ".exe", StringComparison.OrdinalIgnoreCase))
                 {
                     return true;
                 }
 
-                if (String.Compare(extension, ".resx", StringComparison.OrdinalIgnoreCase) == 0 ||
-                    String.Compare(extension, ".resw", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(extension, ".resx", StringComparison.OrdinalIgnoreCase) ||
+                    String.Equals(extension, ".resw", StringComparison.OrdinalIgnoreCase))
                 {
                     XmlReader reader = null;
                     string name = null;
@@ -1836,7 +1832,7 @@ private bool NeedSeparateAppDomain()
                                             (
                                                 MessageImportance.Low,
                                                 "GenerateResource.SeparateAppDomainBecauseOfType",
-                                                (name == null) ? String.Empty : name,
+                                                name ?? String.Empty,
                                                 typeName,
                                                 source.ItemSpec,
                                                 ((IXmlLineInfo)reader).LineNumber
@@ -1882,7 +1878,7 @@ private bool NeedSeparateAppDomain()
                                             (
                                                 MessageImportance.Low,
                                                 "GenerateResource.SeparateAppDomainBecauseOfMimeType",
-                                                (name == null) ? String.Empty : name,
+                                                name ?? String.Empty,
                                                 mimeType,
                                                 source.ItemSpec,
                                                 ((IXmlLineInfo)reader).LineNumber
@@ -1928,7 +1924,7 @@ private bool NeedSeparateAppDomain()
                                         MessageImportance.Low,
                                         "GenerateResource.SeparateAppDomainBecauseOfErrorDeserializingLineNumber",
                                         source.ItemSpec,
-                                        (name == null) ? String.Empty : name,
+                                        name ?? String.Empty,
                                         ((IXmlLineInfo)reader).LineNumber,
                                         e.Message
                                     );
@@ -2028,7 +2024,7 @@ private bool DetermineWhetherSerializedObjectLoads(string data)
             {
                 object result = binaryFormatter.Deserialize(memoryStream);
 
-                return (result != null);
+                return result != null;
             }
         }
 
@@ -2160,7 +2156,7 @@ private void RecordFilesWritten()
             }
 
             // Add any state file
-            if (StateFile != null && StateFile.ItemSpec.Length > 0)
+            if (StateFile?.ItemSpec.Length > 0)
             {
                 // It's possible the file wasn't actually written (eg the path was invalid)
                 // We can't easily tell whether that happened here, and I think it's fine to add it anyway.
@@ -2173,8 +2169,7 @@ private void RecordFilesWritten()
             {
                 if (StronglyTypedFileName == null)
                 {
-                    CodeDomProvider provider = null;
-
+                    CodeDomProvider provider;
                     if (ProcessResourceFiles.TryCreateCodeDomProvider(Log, StronglyTypedLanguage, out provider))
                     {
                         StronglyTypedFileName = ProcessResourceFiles.GenerateDefaultStronglyTypedFilename(
@@ -2196,7 +2191,7 @@ private void ReadStateFile()
             // just doesn't exist, then this method will return a brand new cache object.
 
             // This method eats IO Exceptions
-            _cache = ResGenDependencies.DeserializeCache((StateFile == null) ? null : StateFile.ItemSpec, UseSourcePath, Log);
+            _cache = ResGenDependencies.DeserializeCache(StateFile?.ItemSpec, UseSourcePath, Log);
             ErrorUtilities.VerifyThrow(_cache != null, "We did not create a cache!");
         }
 
@@ -2208,7 +2203,7 @@ private void WriteStateFile()
             if (_cache.IsDirty)
             {
                 // And now we serialize the cache to save our resgen linked file resolution for later use.
-                _cache.SerializeCache((StateFile == null) ? null : StateFile.ItemSpec, Log);
+                _cache.SerializeCache(StateFile?.ItemSpec, Log);
             }
         }
     }
@@ -2361,7 +2356,7 @@ internal ArrayList UnsuccessfullyCreatedOutFiles
         {
             get
             {
-                if (null == _unsuccessfullyCreatedOutFiles)
+                if (_unsuccessfullyCreatedOutFiles == null)
                 {
                     _unsuccessfullyCreatedOutFiles = new ArrayList();
                 }
@@ -2431,7 +2426,7 @@ internal void Run(
 #if !FEATURE_ASSEMBLYLOADCONTEXT
             // If references were passed in, we will have to give the ResxResourceReader an object
             // by which it can resolve types that are referenced from within the .RESX.
-            if ((_assemblyFiles != null) && (_assemblyFiles.Length > 0))
+            if ((_assemblyFiles?.Length > 0))
             {
                 _typeResolver = new AssemblyNamesTypeResolutionService(_assemblyFiles);
             }
@@ -2509,7 +2504,7 @@ internal Assembly ResolveAssembly(object sender, ResolveEventArgs args)
 
                     if (candidateAssemblyName != null)
                     {
-                        if (String.Compare(requestedAssemblyName.Name, candidateAssemblyName.Name, StringComparison.CurrentCultureIgnoreCase) == 0)
+                        if (String.Equals(requestedAssemblyName.Name, candidateAssemblyName.Name, StringComparison.CurrentCultureIgnoreCase))
                         {
                             return Assembly.UnsafeLoadFrom(_assemblyFiles[i].ItemSpec);
                         }
@@ -2563,7 +2558,7 @@ private void PopulateAssemblyNames()
         /// </summary>
         /// <remarks>Uses the input and output file extensions to determine their format</remarks>
         /// <param name="inFile">Input resources file</param>
-        /// <param name="outFile">Output resources file</param>
+        /// <param name="outFileOrDir">Output resources file or directory</param>
         /// <returns>True if conversion was successful, otherwise false</returns>
         private bool ProcessFile(string inFile, string outFileOrDir)
         {
@@ -2782,7 +2777,7 @@ e is SerializationException ||
                 }
 
                 if (currentOutputDirectory != null &&
-                    currentOutputDirectoryAlreadyExisted == false)
+                    !currentOutputDirectoryAlreadyExisted)
                 {
                     // Do not annoy the user by removing an empty directory we did not create.
                     try
@@ -2849,7 +2844,7 @@ private string EnsurePathIsShortEnough(string currentOutputFile, string currentO
             // reliably with cmd's dir command either (depending on whether you use absolute or relative paths
             // and whether there are quotes around the name).
             const int EffectiveMaxPath = 258;   // Everything <= EffectiveMaxPath should work well.
-            bool success = false;
+            bool success;
             try
             {
                 currentOutputFile = Path.GetFullPath(currentOutputFile);
@@ -2920,8 +2915,7 @@ private void RemoveCorruptedFile(string filename)
         /// <returns>Resources format</returns>
         private Format GetFormat(string filename)
         {
-            string extension = String.Empty;
-
+            string extension;
             try
             {
                 extension = Path.GetExtension(filename);
@@ -2932,23 +2926,23 @@ private Format GetFormat(string filename)
                 return Format.Error;
             }
 
-            if (String.Compare(extension, ".txt", StringComparison.OrdinalIgnoreCase) == 0 ||
-                String.Compare(extension, ".restext", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(extension, ".txt", StringComparison.OrdinalIgnoreCase) ||
+                String.Equals(extension, ".restext", StringComparison.OrdinalIgnoreCase))
             {
                 return Format.Text;
             }
-            else if (String.Compare(extension, ".resx", StringComparison.OrdinalIgnoreCase) == 0 ||
-                     String.Compare(extension, ".resw", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(extension, ".resx", StringComparison.OrdinalIgnoreCase) ||
+                     String.Equals(extension, ".resw", StringComparison.OrdinalIgnoreCase))
             {
                 return Format.XML;
             }
-            else if (String.Compare(extension, ".resources.dll", StringComparison.OrdinalIgnoreCase) == 0 ||
-                     String.Compare(extension, ".dll", StringComparison.OrdinalIgnoreCase) == 0 ||
-                     String.Compare(extension, ".exe", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(extension, ".resources.dll", StringComparison.OrdinalIgnoreCase) ||
+                     String.Equals(extension, ".dll", StringComparison.OrdinalIgnoreCase) ||
+                     String.Equals(extension, ".exe", StringComparison.OrdinalIgnoreCase))
             {
                 return Format.Assembly;
             }
-            else if (String.Compare(extension, ".resources", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(extension, ".resources", StringComparison.OrdinalIgnoreCase))
             {
                 return Format.Binary;
             }
@@ -3255,6 +3249,8 @@ internal void ReadAssemblyResources(String name, String outFileOrDir)
         /// <param name="name">Assembly's file name</param>
         /// <param name="assemblyName">AssemblyName of this assembly</param>
         /// <param name="culture">Assembly's CultureInfo</param>
+        /// <param name="a">The actual Assembly</param>
+        /// <param name="mainAssembly">Whether this is the main assembly</param>
         private NeutralResourcesLanguageAttribute CheckAssemblyCultureInfo(String name, AssemblyName assemblyName, CultureInfo culture, Assembly a, bool mainAssembly)
         {
             NeutralResourcesLanguageAttribute neutralResourcesLanguageAttribute = null;
@@ -3303,6 +3299,7 @@ private static bool ContainsProperlyNamedResourcesFiles(Assembly a, bool mainAss
         /// <summary>
         /// Write resources from the resources ArrayList to the specified output file
         /// </summary>
+        /// <param name="reader">Reader information</param>
         /// <param name="filename">Output resources file</param>
         private void WriteResources(ReaderInfo reader, String filename)
         {
@@ -3321,7 +3318,6 @@ private void WriteResources(ReaderInfo reader, String filename)
 #endif
                     break;
 
-
                 case Format.Assembly:
                     _logger.LogErrorFromResources("GenerateResource.CannotWriteAssembly", filename);
                     break;
@@ -3411,12 +3407,13 @@ private bool HaveSystemResourcesExtensionsReference
         /// <summary>
         /// Create a strongly typed resource class
         /// </summary>
+        /// <param name="reader">Reader information</param>
         /// <param name="outFile">Output resource filename, for defaulting the class filename</param>
         /// <param name="inputFileName">Input resource filename, for error messages</param>
+        /// <param name="sourceFile">The generated strongly typed filename</param>
         private void CreateStronglyTypedResources(ReaderInfo reader, String outFile, String inputFileName, out String sourceFile)
         {
-            CodeDomProvider provider = null;
-
+            CodeDomProvider provider;
             if (!TryCreateCodeDomProvider(_logger, _stronglyTypedLanguage, out provider))
             {
                 sourceFile = null;
@@ -3498,6 +3495,7 @@ public static string GenerateDefaultStronglyTypedFilename(CodeDomProvider provid
         /// Broken out here so it can be called from GenerateResource class.
         /// Not a true "TryXXX" method, as it still throws if it encounters an exception it doesn't expect.
         /// </comments>
+        /// <param name="logger">Logger helper.</param>
         /// <param name="stronglyTypedLanguage">The language to create a provider for.</param>
         /// <param name="provider">The provider in question, if one is successfully created.</param>
         /// <returns>True if the provider was successfully created, false otherwise.</returns>
@@ -3527,6 +3525,7 @@ public static bool TryCreateCodeDomProvider(TaskLoggingHelper logger, string str
         /// <summary>
         /// Read resources from an XML or binary format file
         /// </summary>
+        /// <param name="readerInfo">Reader info</param>
         /// <param name="reader">Appropriate IResourceReader</param>
         /// <param name="fileName">Filename, for error messages</param>
         private void ReadResources(ReaderInfo readerInfo, IResourceReader reader, String fileName)
@@ -3547,6 +3546,7 @@ private void ReadResources(ReaderInfo readerInfo, IResourceReader reader, String
         /// <summary>
         /// Read resources from a text format file
         /// </summary>
+        /// <param name="reader">Reader info</param>
         /// <param name="fileName">Input resources filename</param>
         private void ReadTextResources(ReaderInfo reader, String fileName)
         {
@@ -3612,7 +3612,7 @@ private void ReadTextResources(ReaderInfo reader, String fileName)
                     // sign.  Deal with it.
                     if (name[name.Length - 1] == ' ')
                     {
-                        name.Length = name.Length - 1;
+                        name.Length--;
                     }
                     ch = sr.Read(); // move past =
                     // If it exists, move past the first space after the equals sign.
@@ -3718,11 +3718,11 @@ private void ReadTextResources(ReaderInfo reader, String fileName)
             }
         }
 
-
         /// <summary>
         /// Write resources to an XML or binary format resources file.
         /// </summary>
         /// <remarks>Closes writer automatically</remarks>
+        /// <param name="reader">Reader information</param>
         /// <param name="writer">Appropriate IResourceWriter</param>
         private void WriteResources(ReaderInfo reader,
             IResourceWriter writer)
@@ -3763,6 +3763,7 @@ private void WriteResources(ReaderInfo reader,
         /// <summary>
         /// Write resources to a text format resources file
         /// </summary>
+        /// <param name="reader">Reader information</param>
         /// <param name="fileName">Output resources file</param>
         private void WriteTextResources(ReaderInfo reader, String fileName)
         {
@@ -3796,6 +3797,7 @@ private void WriteTextResources(ReaderInfo reader, String fileName)
         /// <summary>
         /// Add a resource from a text file to the internal data structures
         /// </summary>
+        /// <param name="reader">Reader information</param>
         /// <param name="name">Resource name</param>
         /// <param name="value">Resource value</param>
         /// <param name="inputFileName">Input file for messages</param>
@@ -3820,10 +3822,10 @@ private void AddResource(ReaderInfo reader, IResource entry, String inputFileNam
             reader.resourcesHashTable.Add(entry.Name, entry);
         }
 
-
         /// <summary>
         /// Add a resource from an XML or binary format file to the internal data structures
         /// </summary>
+        /// <param name="reader">Reader info</param>
         /// <param name="name">Resource name</param>
         /// <param name="value">Resource value</param>
         /// <param name="inputFileName">Input file for messages</param>
@@ -3934,7 +3936,7 @@ internal int LinePosition
         }
 
         /// <summary>
-        /// For flow of control & passing sufficient error context back
+        /// For flow of control and passing sufficient error context back
         /// from ReadTextResources
         /// </summary>
         [Serializable]
@@ -4014,6 +4016,7 @@ public Assembly GetAssembly(AssemblyName name)
         /// Not implemented.  Not called by the ResxResourceReader.
         /// </summary>
         /// <param name="name"></param>
+        /// <param name="throwOnError"></param>
         /// <returns></returns>
         public Assembly GetAssembly(AssemblyName name, bool throwOnError)
         {
diff --git a/src/Tasks/GenerateTrustInfo.cs b/src/Tasks/GenerateTrustInfo.cs
index a8e07666114..7a922908366 100644
--- a/src/Tasks/GenerateTrustInfo.cs
+++ b/src/Tasks/GenerateTrustInfo.cs
@@ -65,7 +65,7 @@ public override bool Execute()
             {
                 // If it's a known zone and the user add additional permission to it.
                 if (!String.IsNullOrEmpty(TargetZone)
-                    && trustInfo.PermissionSet != null && trustInfo.PermissionSet.Count > 0
+                    && trustInfo.PermissionSet?.Count > 0
                     && !String.Equals(TargetZone, Custom, StringComparison.OrdinalIgnoreCase))
                 {
                     Log.LogErrorFromResources("GenerateManifest.KnownTargetZoneCannotHaveAdditionalPermissionType");
diff --git a/src/Tasks/GetInstalledSDKLocations.cs b/src/Tasks/GetInstalledSDKLocations.cs
index 880a2f62f0b..e5e8195e1f8 100644
--- a/src/Tasks/GetInstalledSDKLocations.cs
+++ b/src/Tasks/GetInstalledSDKLocations.cs
@@ -149,7 +149,7 @@ public override bool Execute()
 
             var outputItems = new List<ITaskItem>();
 
-            if (installedSDKs != null && installedSDKs.Count > 0)
+            if (installedSDKs?.Count > 0)
             {
                 Log.LogMessageFromResources(MessageImportance.Low, "GetInstalledSDKs.FoundSDKs", installedSDKs.Count);
                 Log.LogMessageFromResources(MessageImportance.Low, "GetInstalledSDKs.ListInstalledSDKs");
diff --git a/src/Tasks/GetReferenceAssemblyPaths.cs b/src/Tasks/GetReferenceAssemblyPaths.cs
index e5201d9b62b..408bf6f3435 100644
--- a/src/Tasks/GetReferenceAssemblyPaths.cs
+++ b/src/Tasks/GetReferenceAssemblyPaths.cs
@@ -192,7 +192,7 @@ public override bool Execute()
             {
                 _tfmPaths = GetPaths(RootPath, TargetFrameworkFallbackSearchPaths, moniker);
 
-                if (_tfmPaths != null && _tfmPaths.Count > 0)
+                if (_tfmPaths?.Count > 0)
                 {
                     TargetFrameworkMonikerDisplayName = ToolLocationHelper.GetDisplayNameForTargetFrameworkDirectory(_tfmPaths[0], moniker);
                 }
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index 4393c520267..43b7d8ffcd9 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -110,7 +110,7 @@ public ITaskItem[] ResolvedSDKReferences
         }
 
         /// <summary>
-        /// Extensions which should be considered reference files, we will look for 
+        /// Extensions which should be considered reference files, we will look for
         /// the files in the order they are specified in the array.
         /// </summary>
         public string[] ReferenceExtensions
@@ -240,7 +240,7 @@ internal bool Execute(GetAssemblyName getAssemblyName, GetAssemblyRuntimeVersion
             {
                 // Filter out all references tagged as RuntimeReferenceOnly 
                 IEnumerable<ITaskItem> filteredResolvedSDKReferences = ResolvedSDKReferences.Where(
-                    sdkReference => !(MetadataConversionUtilities.TryConvertItemMetadataToBool(sdkReference, "RuntimeReferenceOnly"))
+                    sdkReference => !MetadataConversionUtilities.TryConvertItemMetadataToBool(sdkReference, "RuntimeReferenceOnly")
                 );
 
                 PopulateReferencesForSDK(filteredResolvedSDKReferences);
@@ -367,7 +367,7 @@ private void FindReferences(ITaskItem resolvedSDKReference, string sdkIdentity,
                 // If the SDK is manifest driven we want to grab them from the ApiContracts in the manifest if possible- will only happen if TargetSdk is identified
                 string[] manifestReferencePaths = GetReferencePathsFromManifest(resolvedSDKReference);
 
-                if (manifestReferencePaths != null && manifestReferencePaths.Length > 0)
+                if (manifestReferencePaths?.Length > 0)
                 {
                     // Found ApiContract references, use those
                     foreach (string manifestReferencePath in manifestReferencePaths)
@@ -481,7 +481,7 @@ private void GenerateOutputItems()
                             outputItem.SetMetadata(ItemMetadataNames.imageRuntime, referenceInfo.ImageRuntime);
                         }
 
-                        if (referenceInfo != null && referenceInfo.IsWinMD)
+                        if (referenceInfo?.IsWinMD == true)
                         {
                             outputItem.SetMetadata(ItemMetadataNames.winMDFile, "true");
 
@@ -606,7 +606,7 @@ private void GatherReferenceAssemblies(HashSet<ResolvedReferenceAssembly> resolv
         }
 
         /// <summary>
-        /// Gather the redist files from from the redist directory.
+        /// Gather the redist files from the redist directory.
         /// </summary>
         private void GatherRedistFiles(HashSet<ResolvedRedistFile> resolvedRedistFiles, ITaskItem sdkReference, string redistFilePath, SDKInfo info)
         {
@@ -1011,7 +1011,7 @@ internal SDKInfo GetCacheFileInfoFromSDK(string sdkRootDirectory, string[] sdkMa
                 directoriesToHash.AddRange(referenceDirectories);
                 directoriesToHash.AddRange(redistDirectories);
 
-                if (sdkManifestReferences != null && sdkManifestReferences.Length > 0)
+                if (sdkManifestReferences?.Length > 0)
                 {
                     // Manifest driven- get the info from the known list
                     PopulateReferencesDictionaryFromManifestPaths(directoryToFileList, references, sdkManifestReferences);
@@ -1078,7 +1078,7 @@ private static void PopulateRedistDictionaryFromPaths(ConcurrentDictionary<strin
             }
 
             /// <summary>
-            /// Is the assembly list cache file up to date. 
+            /// Is the assembly list cache file up to date.
             /// This is done by comparing the last write time of the cache file to the last write time of the code.
             /// If our code is newer than the last write time of the cache file then there may be some different serialization used so we should say it is out of date and just regenerate it.
             /// </summary>
diff --git a/src/Tasks/Hash.cs b/src/Tasks/Hash.cs
index a81e5e2048c..c822fa90f90 100644
--- a/src/Tasks/Hash.cs
+++ b/src/Tasks/Hash.cs
@@ -42,7 +42,7 @@ public class Hash : TaskExtension
         /// </summary>
         public override bool Execute()
         {
-            if (ItemsToHash != null && ItemsToHash.Length > 0)
+            if (ItemsToHash?.Length > 0)
             {
                 using (var sha1 = SHA1.Create())
                 {
@@ -90,9 +90,8 @@ private int ComputeStringSize(ITaskItem[] itemsToHash)
                 totalItemSize += item.ItemSpec.Length;
             }
 
-            var separatorSize = itemsToHash.Length - 1;
-
-            return totalItemSize + separatorSize;
+            // Add one ItemSeparatorCharacter per item
+            return totalItemSize + itemsToHash.Length;
         }
     }
 }
diff --git a/src/Tasks/LockCheck.cs b/src/Tasks/LockCheck.cs
index 9b343227cef..6624a318f53 100644
--- a/src/Tasks/LockCheck.cs
+++ b/src/Tasks/LockCheck.cs
@@ -284,43 +284,21 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]
 
         private static Exception GetException(int res, string apiName, string message)
         {
-            string reason;
-            switch (res)
+            string reason = res switch
             {
-                case ERROR_ACCESS_DENIED:
-                    reason = "Access is denied.";
-                    break;
-                case ERROR_SEM_TIMEOUT:
-                    reason = "A Restart Manager function could not obtain a Registry write mutex in the allotted time. " +
-                             "A system restart is recommended because further use of the Restart Manager is likely to fail.";
-                    break;
-                case ERROR_BAD_ARGUMENTS:
-                    reason = "One or more arguments are not correct. This error value is returned by the Restart Manager " +
-                             "function if a NULL pointer or 0 is passed in a parameter that requires a non-null and non-zero value.";
-                    break;
-                case ERROR_MAX_SESSIONS_REACHED:
-                    reason = "The maximum number of sessions has been reached.";
-                    break;
-                case ERROR_WRITE_FAULT:
-                    reason = "An operation was unable to read or write to the registry.";
-                    break;
-                case ERROR_OUTOFMEMORY:
-                    reason = "A Restart Manager operation could not complete because not enough memory was available.";
-                    break;
-                case ERROR_CANCELLED:
-                    reason = "The current operation is canceled by user.";
-                    break;
-                case ERROR_MORE_DATA:
-                    reason = "More data is available.";
-                    break;
-                case ERROR_INVALID_HANDLE:
-                    reason = "No Restart Manager session exists for the handle supplied.";
-                    break;
-                default:
-                    reason = $"0x{res:x8}";
-                    break;
-            }
-
+                ERROR_ACCESS_DENIED => "Access is denied.",
+                ERROR_SEM_TIMEOUT => "A Restart Manager function could not obtain a Registry write mutex in the allotted time. " +
+   "A system restart is recommended because further use of the Restart Manager is likely to fail.",
+                ERROR_BAD_ARGUMENTS => "One or more arguments are not correct. This error value is returned by the Restart Manager " +
+"function if a NULL pointer or 0 is passed in a parameter that requires a non-null and non-zero value.",
+                ERROR_MAX_SESSIONS_REACHED => "The maximum number of sessions has been reached.",
+                ERROR_WRITE_FAULT => "An operation was unable to read or write to the registry.",
+                ERROR_OUTOFMEMORY => "A Restart Manager operation could not complete because not enough memory was available.",
+                ERROR_CANCELLED => "The current operation is canceled by user.",
+                ERROR_MORE_DATA => "More data is available.",
+                ERROR_INVALID_HANDLE => "No Restart Manager session exists for the handle supplied.",
+                _ => $"0x{res:x8}",
+            };
             throw new Win32Exception(res, $"{message} ({apiName}() error {res}: {reason})");
         }
     }
diff --git a/src/Tasks/MSBuild.cs b/src/Tasks/MSBuild.cs
index 88abe02d007..de2da27930b 100644
--- a/src/Tasks/MSBuild.cs
+++ b/src/Tasks/MSBuild.cs
@@ -199,7 +199,7 @@ public override bool Execute()
             }
 
             // We have been asked to unescape all escaped characters before processing
-            if (TargetAndPropertyListSeparators != null && TargetAndPropertyListSeparators.Length > 0)
+            if (TargetAndPropertyListSeparators?.Length > 0)
             {
                 ExpandAllTargetsAndProperties();
             }
diff --git a/src/Tasks/ManifestUtil/ApplicationManifest.cs b/src/Tasks/ManifestUtil/ApplicationManifest.cs
index 655ac5b8e9b..1f0e1cc3d6a 100644
--- a/src/Tasks/ManifestUtil/ApplicationManifest.cs
+++ b/src/Tasks/ManifestUtil/ApplicationManifest.cs
@@ -194,7 +194,6 @@ public bool IsClickOnceManifest
             set => _isClickOnceManifest = value;
         }
 
-
         /// <summary>
         /// Specifies the maximum allowable length of a file path in a ClickOnce application deployment.
         /// If this value is specified, then the length of each file path in the application is checked against this limit.
@@ -414,7 +413,7 @@ private void ValidateCom()
             {
                 if (assembly.ReferenceType == AssemblyReferenceType.NativeAssembly && !assembly.IsPrerequisite && !String.IsNullOrEmpty(assembly.ResolvedPath))
                 {
-                    ComInfo[] comInfoArray = ManifestReader.GetComInfo(assembly.ResolvedPath); ;
+                    ComInfo[] comInfoArray = ManifestReader.GetComInfo(assembly.ResolvedPath); 
                     if (comInfoArray != null)
                     {
                         foreach (ComInfo comInfo in comInfoArray)
@@ -632,7 +631,7 @@ private void ValidateReferencesForClickOnceApplication()
                     {
                         targetPathList.Add(key, false);
                     }
-                    else if (targetPathList[key] == false)
+                    else if (!targetPathList[key])
                     {
                         OutputMessages.AddWarningMessage("GenerateManifest.DuplicateTargetPath", assembly.ToString());
                         targetPathList[key] = true; // only warn once per path
@@ -675,7 +674,7 @@ private void ValidateReferencesForClickOnceApplication()
                     {
                         targetPathList.Add(key, false);
                     }
-                    else if (targetPathList[key] == false)
+                    else if (!targetPathList[key])
                     {
                         OutputMessages.AddWarningMessage("GenerateManifest.DuplicateTargetPath", file.TargetPath);
                         targetPathList[key] = true; // only warn once per path
@@ -705,7 +704,7 @@ private void ValidateReferenceForPartialTrust(AssemblyReference assembly, TrustI
             }
             else
             {
-                if (assembly.AssemblyIdentity != null && assembly.AssemblyIdentity.IsInFramework(Constants.DotNetFrameworkIdentifier, TargetFrameworkVersion))
+                if (assembly.AssemblyIdentity?.IsInFramework(Constants.DotNetFrameworkIdentifier, TargetFrameworkVersion) == true)
                 {
                     // if the binary is targeting v4.0 and it has the transparent attribute then we may allow partially trusted callers.
                     if (assembly.IsPrimary
diff --git a/src/Tasks/ManifestUtil/AssemblyIdentity.cs b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
index 0c09b3e58d9..772c790c23e 100644
--- a/src/Tasks/ManifestUtil/AssemblyIdentity.cs
+++ b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
@@ -404,7 +404,7 @@ public bool IsInFramework(string frameworkIdentifier, string frameworkVersion)
             string fullName = GetFullName(FullNameFlags.Default);
             foreach (RedistList list in redistDictionary.Values)
             {
-                if (list != null && list.IsFrameworkAssembly(fullName))
+                if (list?.IsFrameworkAssembly(fullName) == true)
                 {
                     return true;
                 }
@@ -433,23 +433,23 @@ public string GetFullName(FullNameFlags flags)
             var sb = new StringBuilder(_name);
             if (!String.IsNullOrEmpty(_version))
             {
-                sb.Append(String.Format(CultureInfo.InvariantCulture, ", Version={0}", _version));
+                sb.AppendFormat(CultureInfo.InvariantCulture, ", Version={0}", _version);
             }
             if (!String.IsNullOrEmpty(_culture))
             {
-                sb.Append(String.Format(CultureInfo.InvariantCulture, ", Culture={0}", _culture));
+                sb.AppendFormat(CultureInfo.InvariantCulture, ", Culture={0}", _culture);
             }
             if (!String.IsNullOrEmpty(_publicKeyToken))
             {
-                sb.Append(String.Format(CultureInfo.InvariantCulture, ", PublicKeyToken={0}", _publicKeyToken));
+                sb.AppendFormat(CultureInfo.InvariantCulture, ", PublicKeyToken={0}", _publicKeyToken);
             }
             if (!String.IsNullOrEmpty(_processorArchitecture) && (flags & FullNameFlags.ProcessorArchitecture) != 0)
             {
-                sb.Append(String.Format(CultureInfo.InvariantCulture, ", ProcessorArchitecture={0}", _processorArchitecture));
+                sb.AppendFormat(CultureInfo.InvariantCulture, ", ProcessorArchitecture={0}", _processorArchitecture);
             }
             if (!String.IsNullOrEmpty(_type) && (flags & FullNameFlags.Type) != 0)
             {
-                sb.Append(String.Format(CultureInfo.InvariantCulture, ", Type={0}", _type));
+                sb.AppendFormat(CultureInfo.InvariantCulture, ", Type={0}", _type);
             }
             return sb.ToString();
         }
diff --git a/src/Tasks/ManifestUtil/AssemblyReference.cs b/src/Tasks/ManifestUtil/AssemblyReference.cs
index bebb3b3b03f..81c741db55d 100644
--- a/src/Tasks/ManifestUtil/AssemblyReference.cs
+++ b/src/Tasks/ManifestUtil/AssemblyReference.cs
@@ -85,7 +85,7 @@ internal bool IsVirtual
             {
                 if (AssemblyIdentity == null)
                     return false;
-                if (String.Compare(AssemblyIdentity.Name, Constants.CLRPlatformAssemblyName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(AssemblyIdentity.Name, Constants.CLRPlatformAssemblyName, StringComparison.OrdinalIgnoreCase))
                     return true;
                 else
                     return false;
@@ -102,7 +102,6 @@ public AssemblyReferenceType ReferenceType
             set { _referenceType = value; }
         }
 
-
         /// <summary>
         /// True if the reference is specified in the project file, false if it is added to the manifest as a result
         /// of computing the closure of all project references.
diff --git a/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs b/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs
index e09397b053a..2b81f70979d 100644
--- a/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs
+++ b/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs
@@ -79,10 +79,10 @@ public AssemblyReference Find(string name)
             }
             foreach (AssemblyReference a in _list)
             {
-                if (a.AssemblyIdentity != null && String.Compare(
+                if (a.AssemblyIdentity != null && String.Equals(
                         name,
                         a.AssemblyIdentity.Name,
-                        StringComparison.OrdinalIgnoreCase) == 0)
+                        StringComparison.OrdinalIgnoreCase))
                 {
                     return a;
                 }
@@ -156,7 +156,7 @@ public AssemblyReference FindTargetPath(string targetPath)
             }
             foreach (AssemblyReference a in _list)
             {
-                if (String.Compare(targetPath, a.TargetPath, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(targetPath, a.TargetPath, StringComparison.OrdinalIgnoreCase))
                 {
                     return a;
                 }
diff --git a/src/Tasks/ManifestUtil/CngLightup.cs b/src/Tasks/ManifestUtil/CngLightup.cs
index d89603de45a..bdc2bc26723 100644
--- a/src/Tasks/ManifestUtil/CngLightup.cs
+++ b/src/Tasks/ManifestUtil/CngLightup.cs
@@ -48,16 +48,13 @@ internal static partial class CngLightup
             typeof(object).Assembly.GetType(RSAEncryptionPaddingTypeName, false);
 
         private static readonly object s_pkcs1SignaturePadding =
-            s_rsaSignaturePaddingType == null ? null :
-            s_rsaSignaturePaddingType.GetProperty("Pkcs1", BindingFlags.Static | BindingFlags.Public).GetValue(null);
+            s_rsaSignaturePaddingType?.GetProperty("Pkcs1", BindingFlags.Static | BindingFlags.Public).GetValue(null);
 
         private static readonly object s_pkcs1EncryptionPadding =
-            s_rsaEncryptionPaddingType == null ? null :
-            s_rsaEncryptionPaddingType.GetProperty("Pkcs1", BindingFlags.Static | BindingFlags.Public).GetValue(null);
+            s_rsaEncryptionPaddingType?.GetProperty("Pkcs1", BindingFlags.Static | BindingFlags.Public).GetValue(null);
 
         private static readonly object s_oaepSha1EncryptionPadding =
-            s_rsaEncryptionPaddingType == null ? null :
-            s_rsaEncryptionPaddingType.GetProperty("OaepSHA1", BindingFlags.Static | BindingFlags.Public).GetValue(null);
+            s_rsaEncryptionPaddingType?.GetProperty("OaepSHA1", BindingFlags.Static | BindingFlags.Public).GetValue(null);
 
         private static readonly Lazy<bool> s_preferRsaCng = new Lazy<bool>(DetectRsaCngSupport);
 
diff --git a/src/Tasks/ManifestUtil/ComImporter.cs b/src/Tasks/ManifestUtil/ComImporter.cs
index 1f4766a09dc..107adb290e2 100644
--- a/src/Tasks/ManifestUtil/ComImporter.cs
+++ b/src/Tasks/ManifestUtil/ComImporter.cs
@@ -7,6 +7,9 @@
 using System.Globalization;
 using System.Resources;
 using System.Runtime.InteropServices;
+#if RUNTIME_TYPE_NETCORE
+using System.Runtime.InteropServices.ComTypes;
+#endif
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
 {
@@ -46,7 +49,11 @@ public ComImporter(string path, OutputMessageCollection outputMessages, string o
             catch (COMException) { }
 
 #pragma warning disable 618
+#if RUNTIME_TYPE_NETCORE
+            ITypeLib tlib = (ITypeLib)obj;
+#else
             UCOMITypeLib tlib = (UCOMITypeLib)obj;
+#endif
             if (tlib != null)
             {
                 IntPtr typeLibAttrPtr = IntPtr.Zero;
@@ -67,7 +74,11 @@ public ComImporter(string path, OutputMessageCollection outputMessages, string o
                     tlib.GetTypeInfoType(i, out TYPEKIND tkind);
                     if (tkind == TYPEKIND.TKIND_COCLASS)
                     {
+#if RUNTIME_TYPE_NETCORE
+                        tlib.GetTypeInfo(i, out ITypeInfo tinfo);
+#else
                         tlib.GetTypeInfo(i, out UCOMITypeInfo tinfo);
+#endif
 
                         IntPtr tinfoAttrPtr = IntPtr.Zero;
                         tinfo.GetTypeAttr(out tinfoAttrPtr);
diff --git a/src/Tasks/ManifestUtil/DeployManifest.cs b/src/Tasks/ManifestUtil/DeployManifest.cs
index da358580c54..0e726a88a57 100644
--- a/src/Tasks/ManifestUtil/DeployManifest.cs
+++ b/src/Tasks/ManifestUtil/DeployManifest.cs
@@ -137,7 +137,7 @@ private static FrameworkNameVersioning GetInstallableFrameworkName(FrameworkName
 
             IList<string> referenceAssemblyPaths = GetPathToReferenceAssemblies(frameworkName);
 
-            if (referenceAssemblyPaths != null && referenceAssemblyPaths.Count > 0)
+            if (referenceAssemblyPaths?.Count > 0)
             {
                 // the first one in the list is the reference assembly path for the requested TFM
                 string referenceAssemblyPath = referenceAssemblyPaths[0];
@@ -177,9 +177,7 @@ private static FrameworkNameVersioning GetInstallableFrameworkName(FrameworkName
         private static string GetRedistListFilePath(string referenceAssemblyPath)
         {
             string redistListPath = Path.Combine(referenceAssemblyPath, _redistListFolder);
-            redistListPath = Path.Combine(redistListPath, _redistListFile);
-
-            return redistListPath;
+            return Path.Combine(redistListPath, _redistListFile);
         }
 
         private static IList<string> GetPathToReferenceAssemblies(FrameworkNameVersioning targetFrameworkMoniker)
@@ -232,7 +230,6 @@ private static string GetInstallableFramework(string redistListFilePath)
             return installableFramework;
         }
 
-
         private static CompatibleFramework GetSubsetCompatFramework(FrameworkNameVersioning frameworkName)
         {
             CompatibleFramework compat = GetFullCompatFramework(frameworkName);
@@ -411,7 +408,7 @@ public string MinimumRequiredVersion
         internal override void OnAfterLoad()
         {
             base.OnAfterLoad();
-            if (_entryPoint == null && AssemblyReferences != null && AssemblyReferences.Count > 0)
+            if (_entryPoint == null && AssemblyReferences?.Count > 0)
             {
                 _entryPoint = AssemblyReferences[0];
                 _entryPoint.ReferenceType = AssemblyReferenceType.ClickOnceManifest;
@@ -594,8 +591,7 @@ private void ValidateEntryPoint()
                         }
                         else
                         {
-                            if (entryPointManifest.FileAssociations != null &&
-                                entryPointManifest.FileAssociations.Count > 0)
+                            if (entryPointManifest.FileAssociations?.Count > 0)
                             {
                                 OutputMessages.AddErrorMessage("GenerateManifest.FileAssociationsNotInstalled");
                             }
diff --git a/src/Tasks/ManifestUtil/FileReference.cs b/src/Tasks/ManifestUtil/FileReference.cs
index 1b46df71c7b..69c418bb40a 100644
--- a/src/Tasks/ManifestUtil/FileReference.cs
+++ b/src/Tasks/ManifestUtil/FileReference.cs
@@ -83,7 +83,7 @@ internal bool ImportComComponent(string path, OutputMessageCollection outputMess
         [XmlIgnore]
         public bool IsDataFile
         {
-            get => String.Compare(_writeableType, "applicationData", StringComparison.OrdinalIgnoreCase) == 0;
+            get => String.Equals(_writeableType, "applicationData", StringComparison.OrdinalIgnoreCase);
             set => _writeableType = value ? "applicationData" : null;
         }
 
@@ -365,12 +365,12 @@ public bool Versioned
         {
             get
             {
-                if (String.Compare(_versioned, "yes", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(_versioned, "yes", StringComparison.OrdinalIgnoreCase))
                 {
                     return true;
                 }
 
-                if (String.Compare(_versioned, "no", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(_versioned, "no", StringComparison.OrdinalIgnoreCase))
                 {
                     return false;
                 }
diff --git a/src/Tasks/ManifestUtil/FileReferenceCollection.cs b/src/Tasks/ManifestUtil/FileReferenceCollection.cs
index d044fba2cbc..25be81c3805 100644
--- a/src/Tasks/ManifestUtil/FileReferenceCollection.cs
+++ b/src/Tasks/ManifestUtil/FileReferenceCollection.cs
@@ -79,7 +79,7 @@ public FileReference FindTargetPath(string targetPath)
             }
             foreach (FileReference f in _list)
             {
-                if (String.Compare(targetPath, f.TargetPath, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(targetPath, f.TargetPath, StringComparison.OrdinalIgnoreCase))
                 {
                     return f;
                 }
diff --git a/src/Tasks/ManifestUtil/Manifest.cs b/src/Tasks/ManifestUtil/Manifest.cs
index d6c882667d7..13a69ff34fc 100644
--- a/src/Tasks/ManifestUtil/Manifest.cs
+++ b/src/Tasks/ManifestUtil/Manifest.cs
@@ -424,21 +424,13 @@ private void UpdateAssemblyReference(AssemblyReference a, string targetFramework
 
             if (a.AssemblyIdentity == null)
             {
-                switch (a.ReferenceType)
+                a.AssemblyIdentity = a.ReferenceType switch
                 {
-                    case AssemblyReferenceType.ClickOnceManifest:
-                        a.AssemblyIdentity = AssemblyIdentity.FromManifest(a.ResolvedPath);
-                        break;
-                    case AssemblyReferenceType.ManagedAssembly:
-                        a.AssemblyIdentity = AssemblyIdentity.FromManagedAssembly(a.ResolvedPath);
-                        break;
-                    case AssemblyReferenceType.NativeAssembly:
-                        a.AssemblyIdentity = AssemblyIdentity.FromNativeAssembly(a.ResolvedPath);
-                        break;
-                    default:
-                        a.AssemblyIdentity = AssemblyIdentity.FromFile(a.ResolvedPath);
-                        break;
-                }
+                    AssemblyReferenceType.ClickOnceManifest => AssemblyIdentity.FromManifest(a.ResolvedPath),
+                    AssemblyReferenceType.ManagedAssembly => AssemblyIdentity.FromManagedAssembly(a.ResolvedPath),
+                    AssemblyReferenceType.NativeAssembly => AssemblyIdentity.FromNativeAssembly(a.ResolvedPath),
+                    _ => AssemblyIdentity.FromFile(a.ResolvedPath),
+                };
             }
 
             if (!a.IsPrerequisite)
@@ -597,7 +589,7 @@ private void ValidateReferences()
                     {
                         identityList.Add(key, false);
                     }
-                    else if (identityList[key] == false)
+                    else if (!identityList[key])
                     {
                         OutputMessages.AddWarningMessage("GenerateManifest.DuplicateAssemblyIdentity", identity);
                         identityList[key] = true; // only warn once per identity
diff --git a/src/Tasks/ManifestUtil/MetadataReader.cs b/src/Tasks/ManifestUtil/MetadataReader.cs
index be17ffc5e97..c7238f82e74 100644
--- a/src/Tasks/ManifestUtil/MetadataReader.cs
+++ b/src/Tasks/ManifestUtil/MetadataReader.cs
@@ -5,9 +5,256 @@
 using System.Diagnostics.CodeAnalysis;
 using System.Runtime.InteropServices;
 using System.Collections.Specialized;
+#if RUNTIME_TYPE_NETCORE
+using System.Collections.Generic;
+using System.IO;
+using System.Reflection;
+using System.Reflection.Metadata;
+using System.Reflection.PortableExecutable;
+#endif
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
 {
+#if RUNTIME_TYPE_NETCORE
+    internal class MetadataReader : IDisposable
+    {
+        private StringDictionary _attributes;
+        private List<string> _customAttributes;
+
+        private FileStream _assemblyStream;
+        private PEReader _peReader;
+        private System.Reflection.Metadata.MetadataReader _reader;
+
+        private MetadataReader(string path)
+        {
+            try
+            {
+                _assemblyStream = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Delete | FileShare.Read);
+                if (_assemblyStream != null)
+                {
+                    _peReader = new PEReader(_assemblyStream, PEStreamOptions.LeaveOpen);
+                    if (_peReader != null)
+                    {
+                        if (_peReader.HasMetadata)
+                        {
+                            _reader = _peReader.GetMetadataReader();
+                        }
+                    }
+                }
+            }
+            catch(Exception)
+            {
+                Close();
+            }
+        }
+
+        public static MetadataReader Create(string path)
+        {
+            var r = new MetadataReader(path);
+            return r._reader != null ? r : null;
+        }
+
+        public bool HasAssemblyAttribute(string name)
+        {
+            if (_customAttributes == null)
+            {
+                lock (this)
+                {
+                    if (_customAttributes == null)
+                    {
+                        ImportCustomAttributesNames();
+                    }
+                }
+            }
+
+            return _customAttributes.Contains(name);
+        }
+
+        public string Name => Attributes[nameof(Name)];
+        public string Version => Attributes[nameof(Version)];
+        public string PublicKeyToken => Attributes[nameof(PublicKeyToken)];
+        public string Culture => Attributes[nameof(Culture)];
+        public string ProcessorArchitecture => Attributes[nameof(ProcessorArchitecture)];
+
+        private void ImportCustomAttributesNames()
+        {
+            _customAttributes = new List<string>();
+
+            AssemblyDefinition def = _reader.GetAssemblyDefinition();
+
+            CustomAttributeHandleCollection col = def.GetCustomAttributes();
+            foreach (CustomAttributeHandle handle in col)
+            {
+                EntityHandle ctorHandle = _reader.GetCustomAttribute(handle).Constructor;
+                if (ctorHandle.Kind != HandleKind.MemberReference)
+                    continue;
+
+                EntityHandle mHandle = _reader.GetMemberReference((MemberReferenceHandle)ctorHandle).Parent;
+                if (mHandle.Kind != HandleKind.TypeReference)
+                    continue;
+
+                string type = GetTypeName((TypeReferenceHandle)mHandle);
+
+                _customAttributes.Add(type);
+            }
+        }
+
+        private StringDictionary Attributes
+        {
+            get
+            {
+                if (_attributes == null)
+                {
+                    lock (this)
+                    {
+                        if (_attributes == null)
+                        {
+                            ImportAttributes();
+                        }
+                    }
+                }
+
+                return _attributes;
+            }
+        }
+
+        private string GetTypeName(TypeReferenceHandle handle)
+        {
+            TypeReference reference = _reader.GetTypeReference(handle);
+
+            // We don't need the type reference scope.
+
+            return reference.Namespace.IsNil
+                ? _reader.GetString(reference.Name)
+                : _reader.GetString(reference.Namespace) + "." + _reader.GetString(reference.Name);
+        }
+
+        private void ImportAttributes()
+        {
+            AssemblyDefinition ad = _reader.GetAssemblyDefinition();
+
+            string name = _reader.GetString(ad.Name);
+            string version = ad.Version.ToString();
+            string publicKeyToken = GetPublicKeyToken();
+            string culture = _reader.GetString(ad.Culture);
+            if (String.IsNullOrEmpty(culture))
+            {
+                culture = "neutral";
+            }
+            string processorArchitecture = GetProcessorArchitecture();
+
+            _attributes = new StringDictionary
+            {
+                { "Name", name },
+                { "Version", version },
+                { "PublicKeyToken", publicKeyToken },
+                { "Culture", culture },
+                { "ProcessorArchitecture", processorArchitecture }
+            };
+        }
+
+        private string GetPublicKeyToken()
+        {
+            string publicKeyToken = null;
+
+            AssemblyDefinition ad = _reader.GetAssemblyDefinition();
+            BlobReader br = _reader.GetBlobReader(ad.PublicKey);
+            byte[] pk = br.ReadBytes(br.Length);
+            if (pk.Length != 0)
+            {
+                AssemblyName an = new AssemblyName();
+                an.SetPublicKey(pk);
+                byte[] pkt = an.GetPublicKeyToken();
+
+                publicKeyToken = BitConverter.ToString(pkt).Replace("-","");
+            }
+
+            if (!String.IsNullOrEmpty(publicKeyToken))
+                publicKeyToken = publicKeyToken.ToUpperInvariant();
+
+            return publicKeyToken;
+        }
+
+        private string GetProcessorArchitecture()
+        {
+            string processorArchitecture = "unknown";
+
+            if (_peReader.PEHeaders == null ||
+                _peReader.PEHeaders.CoffHeader == null)
+            {
+                return processorArchitecture;
+            }
+
+            Machine machine = _peReader.PEHeaders.CoffHeader.Machine;
+            CorHeader corHeader = _peReader.PEHeaders.CorHeader;
+            if (corHeader != null)
+            {
+                CorFlags corFlags = corHeader.Flags;
+                if ((corFlags & CorFlags.ILLibrary) != 0)
+                {
+                    processorArchitecture = "msil";
+                }
+                else
+                {
+                    switch (machine)
+                    {
+                        case Machine.I386:
+                            // "x86" only if corflags "requires" but not "prefers" x86
+                            if ((corFlags & CorFlags.Requires32Bit) != 0 &&
+                                (corFlags & CorFlags.Prefers32Bit) == 0)
+                            {
+                                processorArchitecture = "x86";
+                            }
+                            else
+                            {
+                                processorArchitecture = "msil";
+                            }
+                            break;
+                        case Machine.IA64:
+                            processorArchitecture = "ia64";
+                            break;
+                        case Machine.Amd64:
+                            processorArchitecture = "amd64";
+                            break;
+                        case Machine.Arm:
+                            processorArchitecture = "arm";
+                            break;
+                        case Machine.Arm64:
+                            processorArchitecture = "arm64";
+                            break;
+                        default:
+                            break;
+                    }
+                }
+            }
+
+            return processorArchitecture;
+        }
+
+        public void Close()
+        {
+            if (_peReader != null)
+            {
+                _peReader.Dispose();
+            }
+
+            if (_assemblyStream != null)
+            {
+                _assemblyStream.Close();
+            }
+
+            _attributes = null;
+            _reader = null;
+            _peReader = null;
+            _assemblyStream = null;
+        }
+
+        void IDisposable.Dispose()
+        {
+            Close();
+        }
+    }
+#else
     internal class MetadataReader : IDisposable
     {
         private readonly string _path;
@@ -42,7 +289,7 @@ public bool HasAssemblyAttribute(string name)
         {
             _assemblyImport.GetAssemblyFromScope(out uint assemblyScope);
             IMetaDataImport2 import2 = (IMetaDataImport2)_assemblyImport;
-            IntPtr valuePtr = IntPtr.Zero;
+            IntPtr valuePtr;
             import2.GetCustomAttributeByName(assemblyScope, name, out valuePtr, out uint valueLen);
             return valueLen != 0;
         }
@@ -151,4 +398,5 @@ private interface IMetaDataDispenser
             int OpenScopeOnMemory();
         }
     }
+#endif
 }
diff --git a/src/Tasks/ManifestUtil/NativeMethods.cs b/src/Tasks/ManifestUtil/NativeMethods.cs
index 7b9131a90e7..e18eef1ebeb 100644
--- a/src/Tasks/ManifestUtil/NativeMethods.cs
+++ b/src/Tasks/ManifestUtil/NativeMethods.cs
@@ -12,6 +12,8 @@ internal static class NativeMethods
         public static readonly IntPtr RT_MANIFEST = new IntPtr(24);
         [DllImport("Kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
         public static extern IntPtr LoadLibraryExW(string strFileName, IntPtr hFile, UInt32 ulFlags);
+        [DllImport("Kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
+        public static extern int SetDllDirectoryW(string strPathName);
         [DllImport("Kernel32.dll", SetLastError = true)]
         public static extern bool FreeLibrary(IntPtr hModule);
         [DllImport("Kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
diff --git a/src/Tasks/ManifestUtil/PathUtil.cs b/src/Tasks/ManifestUtil/PathUtil.cs
index 1e7ca804b4e..6d6e0a57085 100644
--- a/src/Tasks/ManifestUtil/PathUtil.cs
+++ b/src/Tasks/ManifestUtil/PathUtil.cs
@@ -100,7 +100,7 @@ public static bool IsPEFile(string path)
             }
 
             // if first two bytes are "MZ" then we're looking at an .exe or a .dll not a .manifest
-            return ((buffer[0] == 0x4D) && (buffer[1] == 0x5A));
+            return (buffer[0] == 0x4D) && (buffer[1] == 0x5A);
         }
 
         public static bool IsProgramFile(string path)
@@ -112,7 +112,7 @@ public static bool IsProgramFile(string path)
 
         public static bool IsUncPath(string path)
         {
-            Uri u = null;
+            Uri u;
             if (!Uri.TryCreate(path, UriKind.Absolute, out u) || u == null)
                 return false;
             return u.IsUnc;
diff --git a/src/Tasks/ManifestUtil/RSAPKCS1SHA256SignatureDescription.cs b/src/Tasks/ManifestUtil/RSAPKCS1SHA256SignatureDescription.cs
index 011248735db..6fde99029e6 100644
--- a/src/Tasks/ManifestUtil/RSAPKCS1SHA256SignatureDescription.cs
+++ b/src/Tasks/ManifestUtil/RSAPKCS1SHA256SignatureDescription.cs
@@ -13,7 +13,11 @@ public sealed class RSAPKCS1SHA256SignatureDescription : SignatureDescription
         public RSAPKCS1SHA256SignatureDescription()
         {
             KeyAlgorithm = typeof(RSACryptoServiceProvider).FullName;
+#if RUNTIME_TYPE_NETCORE
+            DigestAlgorithm = typeof(SHA256).FullName;
+#else
             DigestAlgorithm = typeof(SHA256Cng).FullName;
+#endif
             FormatterAlgorithm = typeof(RSAPKCS1SignatureFormatter).FullName;
             DeformatterAlgorithm = typeof(RSAPKCS1SignatureDeformatter).FullName;
         }
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index 2a08073279d..d9a1b9721fb 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -32,16 +32,23 @@ namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
     [ComVisible(false)]
     public static class SecurityUtilities
     {
+#if RUNTIME_TYPE_NETCORE
+        // Partial trust and permission sets are not supported by .NET Core.
+#else
         private const string PermissionSetsFolder = "PermissionSets";
         private const string LocalIntranet = "LocalIntranet";
         private const string Internet = "Internet";
         private const string Custom = "Custom";
+#endif
         private const string ToolName = "signtool.exe";
+#if !RUNTIME_TYPE_NETCORE
         private const int Fx2MajorVersion = 2;
         private const int Fx3MajorVersion = 3;
+#endif
         private static readonly Version s_dotNet40Version = new Version("4.0");
         private static readonly Version s_dotNet45Version = new Version("4.5");
 
+#if !RUNTIME_TYPE_NETCORE
         private const string InternetPermissionSetXml = "<PermissionSet class=\"System.Security.PermissionSet\" version=\"1\" ID=\"Custom\" SameSite=\"site\">\n" +
                                                           "<IPermission class=\"System.Security.Permissions.FileDialogPermission, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\" version=\"1\" Access=\"Open\" />\n" +
                                                           "<IPermission class=\"System.Security.Permissions.IsolatedStorageFilePermission, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\" version=\"1\" Allowed=\"ApplicationIsolationByUser\" UserQuota=\"512000\" />\n" +
@@ -112,15 +119,12 @@ internal static PermissionSet ComputeZonePermissionSetHelper(string targetZone,
 
         private static PermissionSet GetNamedPermissionSetFromZone(string targetZone, string targetFrameworkMoniker)
         {
-            switch (targetZone)
+            return targetZone switch
             {
-                case LocalIntranet:
-                    return GetNamedPermissionSet(LocalIntranet, targetFrameworkMoniker);
-                case Internet:
-                    return GetNamedPermissionSet(Internet, targetFrameworkMoniker);
-                default:
-                    throw new ArgumentException(String.Empty /* no message */, nameof(targetZone));
-            }
+                LocalIntranet => GetNamedPermissionSet(LocalIntranet, targetFrameworkMoniker),
+                Internet => GetNamedPermissionSet(Internet, targetFrameworkMoniker),
+                _ => throw new ArgumentException(String.Empty /* no message */, nameof(targetZone)),
+            };
         }
 
         private static PermissionSet GetNamedPermissionSet(string targetZone, string targetFrameworkMoniker)
@@ -140,15 +144,15 @@ private static PermissionSet GetNamedPermissionSet(string targetZone, string tar
 
             if (majorVersion == Fx2MajorVersion)
             {
-                return XmlToPermissionSet((GetXmlElement(targetZone, majorVersion)));
+                return XmlToPermissionSet(GetXmlElement(targetZone, majorVersion));
             }
             else if (majorVersion == Fx3MajorVersion)
             {
-                return XmlToPermissionSet((GetXmlElement(targetZone, majorVersion)));
+                return XmlToPermissionSet(GetXmlElement(targetZone, majorVersion));
             }
             else
             {
-                return XmlToPermissionSet((GetXmlElement(targetZone, fn)));
+                return XmlToPermissionSet(GetXmlElement(targetZone, fn));
             }
         }
 
@@ -235,19 +239,12 @@ private static XmlElement GetXmlElement(string targetZone, FrameworkNameVersioni
         [SuppressMessage("Microsoft.Security.Xml", "CA3057: DoNotUseLoadXml.")]
         private static XmlElement GetCurrentCLRPermissions(string targetZone)
         {
-            SecurityZone zone;
-            switch (targetZone)
+            var zone = targetZone switch
             {
-                case LocalIntranet:
-                    zone = SecurityZone.Intranet;
-                    break;
-                case Internet:
-                    zone = SecurityZone.Internet;
-                    break;
-                default:
-                    throw new ArgumentException(String.Empty /* no message */, nameof(targetZone));
-            }
-
+                LocalIntranet => SecurityZone.Intranet,
+                Internet => SecurityZone.Internet,
+                _ => throw new ArgumentException(String.Empty /* no message */, nameof(targetZone)),
+            };
             var evidence = new Evidence(new EvidenceBase[] { new Zone(zone), new System.Runtime.Hosting.ActivationArguments(new System.ApplicationIdentity("")) }, null);
 
             PermissionSet sandbox = SecurityManager.GetStandardSandbox(evidence);
@@ -267,20 +264,12 @@ private static XmlElement GetCurrentCLRPermissions(string targetZone)
 
         private static XmlElement GetXmlElement(string targetZone, int majorVersion)
         {
-            XmlDocument doc;
-
-            switch (majorVersion)
+            XmlDocument doc = majorVersion switch
             {
-                case Fx2MajorVersion:
-                    doc = CreateXmlDocV2(targetZone);
-                    break;
-                case Fx3MajorVersion:
-                    doc = CreateXmlDocV3(targetZone);
-                    break;
-                default:
-                    throw new ArgumentException(String.Empty /* no message */, nameof(majorVersion));
-            }
-
+                Fx2MajorVersion => CreateXmlDocV2(targetZone),
+                Fx3MajorVersion => CreateXmlDocV3(targetZone),
+                _ => throw new ArgumentException(String.Empty /* no message */, nameof(majorVersion)),
+            };
             XmlElement rootElement = doc.DocumentElement;
 
             return rootElement;
@@ -481,6 +470,7 @@ public static PermissionSet XmlToPermissionSet(XmlElement element)
             }
             return ps;
         }
+#endif
 
         /// <summary>
         /// Signs a ClickOnce manifest or PE file.
@@ -561,7 +551,7 @@ private static bool UseSha256Algorithm(X509Certificate2 cert)
         /// <param name="cert">The certificate to be used to sign the file.</param>
         /// <param name="timestampUrl">URL that specifies an address of a time stamping server.</param>
         /// <param name="path">Path of the file to sign with the certificate.</param>
-        /// <remarks>This function can only sign a PE file if the X509Certificate2 parameter represents a certificate in the 
+        /// <remarks>This function can only sign a PE file if the X509Certificate2 parameter represents a certificate in the
         /// current user's personal certificate store.</remarks>
         public static void SignFile(X509Certificate2 cert, Uri timestampUrl, string path)
         {
@@ -598,8 +588,14 @@ private static void SignFileInternal(X509Certificate2 cert, Uri timestampUrl, st
             }
             else
             {
-                using(RSA rsa = CngLightup.GetRSAPrivateKey(cert))
-                {                    
+#if RUNTIME_TYPE_NETCORE
+                IntPtr hModule = IntPtr.Zero;
+
+                using (RSA rsa = cert.GetRSAPrivateKey())
+#else
+                using (RSA rsa = CngLightup.GetRSAPrivateKey(cert))
+#endif
+                {
                     if (rsa == null)
                         throw new ApplicationException(resources.GetString("SecurityUtil.OnlyRSACertsAreAllowed"));
                     try
@@ -622,6 +618,20 @@ private static void SignFileInternal(X509Certificate2 cert, Uri timestampUrl, st
                             signer = new CmiManifestSigner2(rsa, cert, useSha256);
                         }
 
+#if RUNTIME_TYPE_NETCORE
+                        // Manifest signing uses .NET FX APIs, implemented in clr.dll.
+                        // Load the library explicitly.
+
+                        string clrDllDir = Path.Combine(
+                                Environment.GetFolderPath(Environment.SpecialFolder.Windows),
+                                "Microsoft.NET",
+                                Environment.Is64BitProcess ? "Framework64" : "Framework",
+                                "v4.0.30319");
+
+                        NativeMethods.SetDllDirectoryW(clrDllDir);
+                        hModule = NativeMethods.LoadLibraryExW(Path.Combine(clrDllDir, "clr.dll"), IntPtr.Zero, NativeMethods.LOAD_LIBRARY_AS_DATAFILE);
+                        // No need to check hModule - Sign() method will quickly fail if we did not load clr.dll
+#endif
                         if (timestampUrl == null)
                             manifest.Sign(signer);
                         else
@@ -637,6 +647,17 @@ private static void SignFileInternal(X509Certificate2 cert, Uri timestampUrl, st
                         }
                         throw new ApplicationException(ex.Message, ex);
                     }
+#if RUNTIME_TYPE_NETCORE
+                    finally
+                    {
+                        if (hModule != IntPtr.Zero)
+                        {
+                            NativeMethods.FreeLibrary(hModule);
+                        }
+
+                        NativeMethods.SetDllDirectoryW(null);
+                    }
+#endif
                 }
             }
         }
@@ -659,8 +680,8 @@ private static void SignPEFile(X509Certificate2 cert, Uri timestampUrl, string p
             }
         }
 
-        private static void SignPEFileInternal(X509Certificate2 cert, Uri timestampUrl, 
-                                               string path, System.Resources.ResourceManager resources, 
+        private static void SignPEFileInternal(X509Certificate2 cert, Uri timestampUrl,
+                                               string path, System.Resources.ResourceManager resources,
                                                bool useSha256, bool useRFC3161Timestamp)
         {
             var startInfo = new ProcessStartInfo(
@@ -712,21 +733,21 @@ internal static string GetCommandLineParameters(string certThumbprint, Uri times
             var commandLine = new StringBuilder();
             if (useSha256)
             {
-                commandLine.Append(String.Format(CultureInfo.InvariantCulture, "sign /fd sha256 /sha1 {0} ", certThumbprint));
+                commandLine.AppendFormat(CultureInfo.InvariantCulture, "sign /fd sha256 /sha1 {0} ", certThumbprint);
             }
             else
             {
-                commandLine.Append(String.Format(CultureInfo.InvariantCulture, "sign /sha1 {0} ", certThumbprint));
+                commandLine.AppendFormat(CultureInfo.InvariantCulture, "sign /sha1 {0} ", certThumbprint);
             }
 
             if (timestampUrl != null)
             {
-                commandLine.Append(String.Format(CultureInfo.InvariantCulture, 
-                                                "{0} {1} ", 
-                                                useRFC3161Timestamp ? "/tr" : "/t", 
-                                                timestampUrl.ToString()));
+                commandLine.AppendFormat(CultureInfo.InvariantCulture,
+                                                "{0} {1} ",
+                                                useRFC3161Timestamp ? "/tr" : "/t",
+                                                timestampUrl.ToString());
             }
-            commandLine.Append(string.Format(CultureInfo.InvariantCulture, "\"{0}\"", path));
+            commandLine.AppendFormat(CultureInfo.InvariantCulture, "\"{0}\"", path);
             return commandLine.ToString();
         }
 
diff --git a/src/Tasks/ManifestUtil/TrustInfo.cs b/src/Tasks/ManifestUtil/TrustInfo.cs
index e5a0d7aa194..c4d0460087f 100644
--- a/src/Tasks/ManifestUtil/TrustInfo.cs
+++ b/src/Tasks/ManifestUtil/TrustInfo.cs
@@ -21,12 +21,16 @@ namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
     [ComVisible(false)]
     public sealed class TrustInfo
     {
+#if !RUNTIME_TYPE_NETCORE
+        // Partial trust and permission sets are not supported by .NET Core.
+        // SameSite evaluation is conditioned on .NET FX but always done in .NET Core code.
         private PermissionSet _inputPermissionSet;
+        private PermissionSet _outputPermissionSet;
+        private bool _sameSiteChanged;
+#endif
         private XmlDocument _inputTrustInfoDocument;
         private bool _isFullTrust = true;
-        private PermissionSet _outputPermissionSet;
         private string _sameSiteSetting = "site";
-        private bool _sameSiteChanged;
 
         private void AddSameSiteAttribute(XmlElement permissionSetElement)
         {
@@ -45,10 +49,12 @@ private void AddSameSiteAttribute(XmlElement permissionSetElement)
         /// </summary>
         public void Clear()
         {
+#if !RUNTIME_TYPE_NETCORE
             _inputPermissionSet = null;
+            _outputPermissionSet = null;
+#endif
             _inputTrustInfoDocument = null;
             _isFullTrust = true;
-            _outputPermissionSet = null;
         }
 
         private void FixupPermissionSetElement(XmlElement permissionSetElement)
@@ -115,26 +121,26 @@ private void FixupPermissionSetElement(XmlElement permissionSetElement)
                 return;
             }
 
-            XmlAttribute idrefAttribute = null;
             XmlElement defaultAssemblyRequestElement = (XmlElement)permissionSetElement.ParentNode.SelectSingleNode(XPaths.defaultAssemblyRequestElement, nsmgr);
             if (defaultAssemblyRequestElement == null)
             {
                 defaultAssemblyRequestElement = document.CreateElement(XmlUtil.TrimPrefix(XPaths.defaultAssemblyRequestElement), XmlNamespaces.asmv2);
                 permissionSetElement.ParentNode.AppendChild(defaultAssemblyRequestElement);
             }
-            idrefAttribute = (XmlAttribute)permissionSetElement.Attributes.GetNamedItem(XmlUtil.TrimPrefix(XPaths.permissionSetReferenceAttribute));
+            XmlAttribute idrefAttribute = (XmlAttribute)permissionSetElement.Attributes.GetNamedItem(XmlUtil.TrimPrefix(XPaths.permissionSetReferenceAttribute));
             if (idrefAttribute == null)
             {
                 idrefAttribute = document.CreateAttribute(XmlUtil.TrimPrefix(XPaths.permissionSetReferenceAttribute));
                 defaultAssemblyRequestElement.Attributes.Append(idrefAttribute);
             }
 
-            if (String.Compare(idAttribute.Value, idrefAttribute.Value, StringComparison.Ordinal) != 0)
+            if (!String.Equals(idAttribute.Value, idrefAttribute.Value, StringComparison.Ordinal))
             {
                 idrefAttribute.Value = idAttribute.Value;
             }
         }
 
+#if !RUNTIME_TYPE_NETCORE
         private PermissionSet GetInputPermissionSet()
         {
             if (_inputPermissionSet == null)
@@ -161,6 +167,7 @@ private PermissionSet GetInputPermissionSet()
             }
             return _inputPermissionSet;
         }
+#endif
 
         private XmlElement GetInputPermissionSetElement()
         {
@@ -200,7 +207,6 @@ private static XmlElement GetRequestedPrivilegeElement(XmlElement inputRequested
             //      <requestedExecutionLevel level="asInvoker" />
             //  </requestedPrivileges>
 
-
             // we always create a requestedPrivilege node to put into the generated TrustInfo document
             //
             XmlElement requestedPrivilegeElement = document.CreateElement(XmlUtil.TrimPrefix(XPaths.requestedPrivilegeElement), XmlNamespaces.asmv3);
@@ -232,7 +238,7 @@ private static XmlElement GetRequestedPrivilegeElement(XmlElement inputRequested
                 //  here so we can allow the passed-in node to override it if there is a comment present
                 //
                 System.Resources.ResourceManager resources = new System.Resources.ResourceManager("Microsoft.Build.Tasks.Core.Strings.ManifestUtilities", typeof(SecurityUtilities).Module.Assembly);
-                commentString = resources.GetString("TrustInfo.RequestedExecutionLevelComment"); ;
+                commentString = resources.GetString("TrustInfo.RequestedExecutionLevelComment"); 
             }
             else
             {
@@ -252,7 +258,7 @@ private static XmlElement GetRequestedPrivilegeElement(XmlElement inputRequested
                     //  keep the default null value which means we will not create one in the
                     //  output document)
                     //
-                    if (previousNode != null && previousNode.NodeType == XmlNodeType.Comment)
+                    if (previousNode?.NodeType == XmlNodeType.Comment)
                     {
                         commentString = ((XmlComment)previousNode).Data;
                     }
@@ -329,6 +335,7 @@ private XmlElement GetPermissionSetElement(XmlDocument document)
             return permissionSetElement;
         }
 
+#if !RUNTIME_TYPE_NETCORE
         private PermissionSet GetOutputPermissionSet()
         {
             if (_outputPermissionSet == null)
@@ -351,6 +358,7 @@ private XmlDocument GetOutputPermissionSetDocument()
 
             return outputDocument;
         }
+#endif
 
         /// <summary>
         /// Determines whether the application has permission to call unmanaged code.
@@ -359,6 +367,10 @@ public bool HasUnmanagedCodePermission
         {
             get
             {
+#if RUNTIME_TYPE_NETCORE
+                // Always use full-trust on .NET Core.
+                return true;
+#else
                 PermissionSet ps = GetOutputPermissionSet();
                 if (ps == null)
                 {
@@ -367,6 +379,7 @@ public bool HasUnmanagedCodePermission
                 var ups = new PermissionSet(PermissionState.None);
                 ups.AddPermission(new SecurityPermission(SecurityPermissionFlag.UnmanagedCode));
                 return ps.Intersect(ups) != null;
+#endif
             }
         }
 
@@ -377,12 +390,20 @@ public bool IsFullTrust
         {
             get
             {
+#if RUNTIME_TYPE_NETCORE
+                // Always use full-trust on .NET Core.
+               return true;
+#else
                 GetInputPermissionSet();
                 return _isFullTrust;
+#endif
             }
+#if !RUNTIME_TYPE_NETCORE
             set => _isFullTrust = value;
+#endif
         }
 
+#if !RUNTIME_TYPE_NETCORE
         /// <summary>
         /// Gets or sets the permission set object for the application trust.
         /// </summary>
@@ -391,6 +412,7 @@ public PermissionSet PermissionSet
             get => GetOutputPermissionSet();
             set => _outputPermissionSet = value ?? throw new ArgumentNullException("PermissionSet cannot be set to null.");
         }
+#endif
 
         /// <summary>
         /// Determines whether to preserve partial trust permission when the full trust flag is set.
@@ -467,7 +489,17 @@ private void ReadTrustInfo(string xml)
             _inputTrustInfoDocument.LoadXml(xml);
             XmlElement psElement = GetInputPermissionSetElement();
             XmlAttribute unrestrictedAttribute = (XmlAttribute)psElement.Attributes.GetNamedItem(XmlUtil.TrimPrefix(XPaths.unrestrictedAttribute));
+#if RUNTIME_TYPE_NETCORE
+            // Partial trust is not supported on .NET Core.
+            // Fail if loaded manifest does not specify full-trust.
+            // It can happen if manifest is manually modifed.
+            if (unrestrictedAttribute == null || (false == Boolean.Parse(unrestrictedAttribute.Value)))
+            {
+                throw new ArgumentException("Partial trust is not supported.");
+            }
+#else
             _isFullTrust = unrestrictedAttribute != null && Boolean.Parse(unrestrictedAttribute.Value);
+#endif
             XmlAttribute sameSiteAttribute = (XmlAttribute)psElement.Attributes.GetNamedItem(XmlUtil.TrimPrefix(XPaths.sameSiteAttribute));
             if (sameSiteAttribute != null)
                 _sameSiteSetting = sameSiteAttribute.Value;
@@ -482,7 +514,9 @@ public string SameSiteAccess
             set
             {
                 _sameSiteSetting = value;
+#if !RUNTIME_TYPE_NETCORE
                 _sameSiteChanged = true;
+#endif
             }
         }
 
@@ -544,6 +578,14 @@ public void Write(Stream output)
 
                 // If permission set was not altered, just write out what was read in...
                 MemoryStream m = new MemoryStream();
+#if RUNTIME_TYPE_NETCORE
+                // Simpler code on .NET Core - due to no support for custom permission sets.
+                XmlElement permissionSetElement = outputDocument.DocumentElement;
+                FixupPermissionSetElement(permissionSetElement);
+
+                outputDocument.Save(m);
+                m.Position = 0;
+#else
                 if (_outputPermissionSet == null && !_sameSiteChanged)
                 {
                     XmlElement permissionSetElement = outputDocument.DocumentElement;
@@ -573,6 +615,7 @@ public void Write(Stream output)
                         m.Position = 0;
                     }
                 }
+#endif
 
                 // Wrap <PermissionSet> in a <TrustInfo> section
                 Stream s = tempPrivilegeDocument != null ? XmlUtil.XslTransform(trustInfoResource2, m, new DictionaryEntry("defaultRequestedPrivileges", tempPrivilegeDocument)) : XmlUtil.XslTransform(trustInfoResource2, m);
@@ -668,6 +711,32 @@ public void WriteManifest(Stream input, Stream output)
                 assemblyElement.AppendChild(trustInfoElement);
             }
 
+#if RUNTIME_TYPE_NETCORE
+            // Partial trust and permission sets are not supported on .NET Core.
+            // Consequently we do not support updating permissionSet element.
+            XmlElement securityElement = (XmlElement)trustInfoElement.SelectSingleNode(XPaths.securityElement, nsmgr);
+            if (securityElement == null)
+            {
+                securityElement = document.CreateElement(XmlUtil.TrimPrefix(XPaths.securityElement), XmlNamespaces.asmv2);
+                trustInfoElement.AppendChild(securityElement);
+            }
+            XmlElement applicationRequestMinimumElement = (XmlElement)securityElement.SelectSingleNode(XPaths.applicationRequestMinimumElement, nsmgr);
+            if (applicationRequestMinimumElement == null)
+            {
+                applicationRequestMinimumElement = document.CreateElement(XmlUtil.TrimPrefix(XPaths.applicationRequestMinimumElement), XmlNamespaces.asmv2);
+                securityElement.AppendChild(applicationRequestMinimumElement);
+            }
+
+            XmlNodeList permissionSetNodes = applicationRequestMinimumElement.SelectNodes(XPaths.permissionSetElement, nsmgr);
+            foreach (XmlNode permissionSetNode in permissionSetNodes)
+                applicationRequestMinimumElement.RemoveChild(permissionSetNode);
+
+            XmlElement fullTrustPermissionSetElement = document.CreateElement(XmlUtil.TrimPrefix(XPaths.permissionSetElement), XmlNamespaces.asmv2);
+            XmlAttribute unrestrictedAttribute = document.CreateAttribute(XmlUtil.TrimPrefix(XPaths.unrestrictedAttribute), XmlNamespaces.asmv2);
+            unrestrictedAttribute.Value = "true";
+            applicationRequestMinimumElement.AppendChild(fullTrustPermissionSetElement);
+            FixupPermissionSetElement(fullTrustPermissionSetElement);
+#else
             // If we have an input trustinfo document and no output specified then just copy the input to the output
             if (_inputTrustInfoDocument != null && _outputPermissionSet == null && !_sameSiteChanged)
             {
@@ -700,6 +769,7 @@ public void WriteManifest(Stream input, Stream output)
                 applicationRequestMinimumElement.AppendChild(permissionSetElement);
                 FixupPermissionSetElement(permissionSetElement);
             }
+#endif
 
             // Truncate any contents that may be in the file
             if (output.Length > 0)
diff --git a/src/Tasks/ManifestUtil/Util.cs b/src/Tasks/ManifestUtil/Util.cs
index d0f293057ea..ad3315a7604 100644
--- a/src/Tasks/ManifestUtil/Util.cs
+++ b/src/Tasks/ManifestUtil/Util.cs
@@ -29,6 +29,10 @@ internal static class Util
         private static StreamWriter s_logFileWriter;
         // Major, Minor, Build and Revision of CLR v2.0
         private static readonly int[] s_clrVersion2 = { 2, 0, 50727, 0 };
+#if RUNTIME_TYPE_NETCORE
+        // Major, Minor, Build and Revision of CLR v4.0
+        private static readonly int[] s_clrVersion4 = { 4, 0, 30319, 0 };
+#endif
 
         #region " Platform <-> ProcessorArchitecture mapping "
         // Note: These two arrays are parallel and must correspond to one another.
@@ -110,7 +114,13 @@ public static string GetAssemblyPath()
         public static string GetClrVersion()
         {
             Version v = Environment.Version;
+#if RUNTIME_TYPE_NETCORE
+            // This is a version of ClickOnce .NET FX target runtime, which cannot be obtained in .NET (Core) process.
+            // Set to .NET FX v4 runtime as the ony one supported for manifest generation in .NET (Core) process.
+            v = new Version(s_clrVersion4[0], s_clrVersion4[1], s_clrVersion4[2], s_clrVersion4[3]);
+#else
             v = new Version(v.Major, v.Minor, v.Build, 0);
+#endif
             return v.ToString();
         }
 
@@ -125,7 +135,13 @@ public static string GetClrVersion(string targetFrameworkVersion)
                 return GetClrVersion();
 
             Version clrVersion;
+#if RUNTIME_TYPE_NETCORE
+            // This is a version of ClickOnce .NET FX target runtime, which cannot be obtained in .NET (Core) process.
+            // Set to .NET FX v4 runtime as the ony one supported for manifest generation in .NET (Core) process.
+            Version currentVersion = new Version(s_clrVersion4[0], s_clrVersion4[1], s_clrVersion4[2], s_clrVersion4[3]);
+#else
             Version currentVersion = Environment.Version;
+#endif
             Version frameworkVersion = GetTargetFrameworkVersion(targetFrameworkVersion);
 
             // for FX 4.0 or above use the current version.
@@ -135,7 +151,12 @@ public static string GetClrVersion(string targetFrameworkVersion)
             }
             else
             {
+#if RUNTIME_TYPE_NETCORE
+                // Set to .NET FX v4 runtime as the ony one supported for manifest generation in .NET (Core) process.
+                clrVersion = new Version(s_clrVersion4[0], s_clrVersion4[1], s_clrVersion4[2], s_clrVersion4[3]);
+#else
                 clrVersion = new Version(s_clrVersion2[0], s_clrVersion2[1], s_clrVersion2[2], s_clrVersion2[3]);
+#endif
             }
             return clrVersion.ToString();
         }
@@ -314,7 +335,7 @@ internal static bool IsValidFrameworkVersion(string value)
         public static string PlatformToProcessorArchitecture(string platform)
         {
             for (int i = 0; i < s_platforms.Length; ++i)
-                if (String.Compare(platform, s_platforms[i], StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(platform, s_platforms[i], StringComparison.OrdinalIgnoreCase))
                     return s_processorArchitectures[i];
             return null;
         }
@@ -510,7 +531,6 @@ int IComparer.Compare(object obj1, object obj2)
         }
         #endregion
 
-
         public static Version ConvertFrameworkVersionToString(string version)
         {
             if (version.StartsWith("v", StringComparison.OrdinalIgnoreCase))
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index d7a6ae38e71..1ce309689be 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -66,7 +66,6 @@ internal static class Win32
         internal const int TRUST_E_EXPLICIT_DISTRUST = unchecked((int)0x800B0111);
         internal const int CERT_E_CHAINING = unchecked((int)0x800B010A);
 
-
         // Values for dwFlags of CertVerifyAuthenticodeLicense.
         internal const int AXL_REVOCATION_NO_CHECK = unchecked((int)0x00000001);
         internal const int AXL_REVOCATION_CHECK_END_CERT_ONLY = unchecked((int)0x00000002);
@@ -275,8 +274,13 @@ private void init()
             CryptoConfig.AddAlgorithm(typeof(RSAPKCS1SHA256SignatureDescription),
                                Sha256SignatureMethodUri);
 
+#if RUNTIME_TYPE_NETCORE
+            CryptoConfig.AddAlgorithm(typeof(SHA256Managed),
+                               Sha256DigestMethod);
+#else
             CryptoConfig.AddAlgorithm(typeof(System.Security.Cryptography.SHA256Cng),
                                Sha256DigestMethod);
+#endif
         }
 
         private static XmlElement FindIdElement(XmlElement context, string idValue)
@@ -325,9 +329,7 @@ private SignedCmiManifest2() { }
 
         internal SignedCmiManifest2(XmlDocument manifestDom, bool useSha256)
         {
-            if (manifestDom == null)
-                throw new ArgumentNullException("manifestDom");
-            _manifestDom = manifestDom;
+            _manifestDom = manifestDom ?? throw new ArgumentNullException(nameof(manifestDom));
             _useSha256 = useSha256;
         }
 
@@ -345,7 +347,7 @@ internal void Sign(CmiManifestSigner2 signer, string timeStampUrl)
             // Signer cannot be null.
             if (signer == null || signer.StrongNameKey == null)
             {
-                throw new ArgumentNullException("signer");
+                throw new ArgumentNullException(nameof(signer));
             }
 
             // Remove existing SN signature.
@@ -465,6 +467,7 @@ private static void RemoveExistingSignature(XmlDocument manifestDom)
         /// As for official guidance ‚Äì I‚Äôm not sure of any.    For workarounds though, if you‚Äôre using the Microsoft software CSPs, they share the underlying key store.  You can get the key container name from your RSA object, then open up a new RSA object with the same key container name but with PROV_RSA_AES.   At that point, you should be able to use SHA-2 algorithms.
         /// </summary>
         /// <param name="oldCsp"></param>
+        /// <param name="useSha256">Whether to use sha256</param>
         /// <returns></returns>
         [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Cryptographic.Standard", "CA5358:RSAProviderNeeds2048bitKey", Justification = "SHA1 is retained for compatibility reasons as an option in VisualStudio signing page and consequently in the trust manager, default is SHA2.")]
         internal static RSACryptoServiceProvider GetFixedRSACryptoServiceProvider(RSACryptoServiceProvider oldCsp, bool useSha256)
@@ -514,7 +517,7 @@ private static void ReplacePublicKeyToken(XmlDocument manifestDom, AsymmetricAlg
             byte[] cspPublicKeyBlob;
 
             if(snKey is RSACryptoServiceProvider){
-                cspPublicKeyBlob = (GetFixedRSACryptoServiceProvider((RSACryptoServiceProvider)snKey, useSha256)).ExportCspBlob(false);            
+                cspPublicKeyBlob = (GetFixedRSACryptoServiceProvider((RSACryptoServiceProvider)snKey, useSha256)).ExportCspBlob(false);
                 if (cspPublicKeyBlob == null || cspPublicKeyBlob.Length == 0)
                 {
                     throw new CryptographicException(Win32.NTE_BAD_KEY);
@@ -682,8 +685,8 @@ private static XmlDocument CreateLicenseDom(CmiManifestSigner2 signer, XmlElemen
             XmlElement manifestInformationNode = licenseDom.SelectSingleNode("r:license/r:grant/as:ManifestInformation", nsm) as XmlElement;
 
             manifestInformationNode.SetAttribute("Hash", hash.Length == 0 ? "" : BytesToHexString(hash, 0, hash.Length));
-            manifestInformationNode.SetAttribute("Description", signer.Description == null ? "" : signer.Description);
-            manifestInformationNode.SetAttribute("Url", signer.DescriptionUrl == null ? "" : signer.DescriptionUrl);
+            manifestInformationNode.SetAttribute("Description", signer.Description ?? "");
+            manifestInformationNode.SetAttribute("Url", signer.DescriptionUrl ?? "");
 
             XmlElement authenticodePublisherNode = licenseDom.SelectSingleNode("r:license/r:grant/as:AuthenticodePublisher/as:X509SubjectName", nsm) as XmlElement;
             authenticodePublisherNode.InnerText = signer.Certificate.SubjectName.Name;
@@ -694,7 +697,11 @@ private static XmlDocument CreateLicenseDom(CmiManifestSigner2 signer, XmlElemen
         private static void AuthenticodeSignLicenseDom(XmlDocument licenseDom, CmiManifestSigner2 signer, string timeStampUrl, bool useSha256)
         {
             // Make sure it is RSA, as this is the only one Fusion will support.
+#if RUNTIME_TYPE_NETCORE
+            RSA rsaPrivateKey = signer.Certificate.GetRSAPrivateKey();
+#else
             RSA rsaPrivateKey = CngLightup.GetRSAPrivateKey(signer.Certificate);
+#endif
             if (rsaPrivateKey == null)
             {
                 throw new NotSupportedException();
@@ -756,7 +763,7 @@ private static void AuthenticodeSignLicenseDom(XmlDocument licenseDom, CmiManife
             issuerNode.AppendChild(licenseDom.ImportNode(xmlDigitalSignature, true));
 
             // Time stamp it if requested.
-            if (timeStampUrl != null && timeStampUrl.Length != 0)
+            if (!string.IsNullOrEmpty(timeStampUrl))
             {
                 TimestampSignedLicenseDom(licenseDom, timeStampUrl, useSha256);
             }
@@ -1049,12 +1056,12 @@ internal CmiManifestSigner2(AsymmetricAlgorithm strongNameKey) :
         internal CmiManifestSigner2(AsymmetricAlgorithm strongNameKey, X509Certificate2 certificate, bool useSha256)
         {
             if (strongNameKey == null)
-                throw new ArgumentNullException("strongNameKey");
+                throw new ArgumentNullException(nameof(strongNameKey));
 
 #if (true) // BUGBUG: Fusion only supports RSA. Do we throw if not RSA???
             RSA rsa = strongNameKey as RSA;
             if (rsa == null)
-                throw new ArgumentNullException("strongNameKey");
+                throw new ArgumentNullException(nameof(strongNameKey));
 #endif
             _strongNameKey = strongNameKey;
             _certificate = certificate;
diff --git a/src/Tasks/Message.cs b/src/Tasks/Message.cs
index 0d6fc93f403..88b6dca9f84 100644
--- a/src/Tasks/Message.cs
+++ b/src/Tasks/Message.cs
@@ -47,7 +47,7 @@ public override bool Execute()
         {
             MessageImportance messageImportance;
 
-            if ((Importance == null) || (Importance.Length == 0))
+            if (string.IsNullOrEmpty(Importance))
             {
                 messageImportance = MessageImportance.Normal;
             }
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 42b7444e5c2..831cce4639b 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -215,6 +215,12 @@
     <Compile Include="..\Shared\LanguageParser\VisualBasictokenizer.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Shared\CommunicationsUtilities.cs">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
+    <Compile Include="..\Shared\XMakeAttributes.cs">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="AppConfig\*.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -329,6 +335,9 @@
     <Compile Include="AssignTargetPath.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="BootstrapperUtil\*.cs">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="CallTarget.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -339,6 +348,12 @@
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="ResourceHandling\*.cs" />
+    <Compile Include="ResolveAssemblyReferences\Client\RarClient.cs" />
+    <Compile Include="ResolveAssemblyReferences\Contract\IResolveAssemblyReferenceTaskHandler.cs" />
+    <Compile Include="ResolveAssemblyReferences\RpcUtils.cs" />
+    <Compile Include="ResolveAssemblyReferences\Server\RarController.cs" />
+    <Compile Include="ResolveAssemblyReferences\Services\RarTaskHandler.cs" />
+    <Compile Include="ResolveAssemblyReferences\Server\ServerMutex.cs" />
     <Compile Include="ResolveComReference.cs" />
     <Compile Include="BuildCacheDisposeWrapper.cs" />
     <Compile Include="DownloadFile.cs" />
@@ -407,6 +422,15 @@
     <Compile Include="FxCopExclusions\Microsoft.Build.Tasks.Suppressions.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="GenerateApplicationManifest.cs" Condition="'$(MonoBuild)' != 'true'">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
+    <Compile Include="GenerateDeploymentManifest.cs" Condition="'$(MonoBuild)' != 'true'">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
+    <Compile Include="GenerateManifestBase.cs" Condition="'$(MonoBuild)' != 'true'">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="GenerateResource.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -459,6 +483,9 @@
     <Compile Include="MakeDir.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="ManifestUtil\*.cs" Exclude="ManifestUtil\CngLightup.cs" Condition="'$(MonoBuild)' != 'true'">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="Message.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -483,6 +510,9 @@
     <Compile Include="ResolveKeySource.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="ResolveManifestFiles.cs" Condition="'$(MonoBuild)' != 'true'">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="ResolveNonMSBuildProjectOutput.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -557,9 +587,6 @@
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="AxTlbBaseTask.cs" />
-    <Compile Include="BootstrapperUtil\*.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="ComDependencyWalker.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -585,18 +612,9 @@
     <Compile Include="FormatUrl.cs" Condition="'$(MonoBuild)' != 'true'">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="GenerateApplicationManifest.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="GenerateBootstrapper.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="GenerateDeploymentManifest.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="GenerateManifestBase.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="GenerateTrustInfo.cs" Condition="'$(MonoBuild)' != 'true'">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -611,11 +629,11 @@
     <Compile Include="Interop.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="RCWForCurrentContext.cs" />
-    <Compile Include="LC.cs" Condition="'$(MonoBuild)' != 'true'">
+    <Compile Include="ManifestUtil\CngLightup.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="ManifestUtil\*.cs" Condition="'$(MonoBuild)' != 'true'">
+    <Compile Include="RCWForCurrentContext.cs" />
+    <Compile Include="LC.cs" Condition="'$(MonoBuild)' != 'true'">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="PiaReference.cs">
@@ -628,9 +646,6 @@
     <Compile Include="ResolveComReferenceCache.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="ResolveManifestFiles.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="ResolveNativeReference.cs" Condition="'$(MonoBuild)' != 'true'">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -980,6 +995,8 @@
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Reflection.Metadata" />
     <PackageReference Include="System.Resources.Extensions" />
+    <PackageReference Include="StreamJsonRpc" />
+    <PackageReference Include="Newtonsoft.Json" />
   </ItemGroup>
 
   <!-- Tasks need to mimic redistributing the compilers, so add references to both full framework and .net core -->
@@ -999,7 +1016,11 @@
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
     <PackageReference Include="System.CodeDom" />
     <PackageReference Include="System.Reflection.TypeExtensions" />
+    <PackageReference Include="System.Runtime.InteropServices" />
+    <PackageReference Include="System.Security.Cryptography.Pkcs" />
+    <PackageReference Include="System.Security.Cryptography.Xml" />
     <PackageReference Include="System.Security.Permissions" />
+    <PackageReference Include="System.Security.Principal.Windows" />
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
 
     <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index 0c5e0242a92..51ef08021b0 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -21,13 +21,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <Import Project="$(CustomBeforeMicrosoftCommonCrossTargetingTargets)" Condition="'$(CustomBeforeMicrosoftCommonCrossTargetingTargets)' != '' and Exists('$(CustomBeforeMicrosoftCommonCrossTargetingTargets)')"/>
 
   <Target Name="GetTargetFrameworks"
+          DependsOnTargets="GetTargetFrameworksWithPlatformFromInnerBuilds"
           Returns="@(_ThisProjectBuildMetadata)">
+
+    <Error Condition="'$(IsCrossTargetingBuild)' != 'true'"
+           Text="Internal MSBuild error: CrossTargeting GetTargetFrameworks target should only be used in cross targeting (outer) build" />
+    
     <ItemGroup>
       <_ThisProjectBuildMetadata Include="$(MSBuildProjectFullPath)">
-        <TargetFrameworks Condition="'$(TargetFrameworks)' != ''">$(TargetFrameworks)</TargetFrameworks>
-        <TargetFrameworks Condition="'$(TargetFrameworks)' == ''">$(TargetFramework)</TargetFrameworks>
-        <HasSingleTargetFramework>true</HasSingleTargetFramework>
-        <HasSingleTargetFramework Condition="'$(IsCrossTargetingBuild)' == 'true'">false</HasSingleTargetFramework>
+        <TargetFrameworks>@(_TargetFrameworkInfo)</TargetFrameworks>
+        <TargetFrameworkMonikers>@(_TargetFrameworkInfo->'%(TargetFrameworkMonikers)')</TargetFrameworkMonikers>
+        <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>
+
+        <HasSingleTargetFramework>false</HasSingleTargetFramework>
+
         <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->
         <IsRidAgnostic>false</IsRidAgnostic>
         <IsRidAgnostic Condition=" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
@@ -46,6 +53,18 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </ItemGroup>
   </Target>
 
+  <Target Name="GetTargetFrameworksWithPlatformFromInnerBuilds"
+          DependsOnTargets="_ComputeTargetFrameworkItems">
+
+    <MSBuild Projects="@(_InnerBuildProjects)"
+             Condition="'@(_InnerBuildProjects)' != '' "
+             Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework"
+             BuildInParallel="$(BuildInParallel)">
+      <Output ItemName="_TargetFrameworkInfo" TaskParameter="TargetOutputs" />
+    </MSBuild>
+
+  </Target>
+
   <!--
   ============================================================
                                        DispatchToInnerBuilds
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 9f6a5fae91d..1b0aa167c3c 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -96,7 +96,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <TargetPlatformWinMDLocation Condition="'$(TargetPlatformWinMDLocation)' == '' and Exists('$(TargetPlatformSdkMetadataLocation)')">$(TargetPlatformSdkMetadataLocation)</TargetPlatformWinMDLocation>
     <UseOSWinMdReferences Condition="'$(UseOSWinMdReferences)' == '' and ('$(TargetPlatformWinMDLocation)' == '' and '$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' &gt; '7.0')">true</UseOSWinMdReferences>
     <TargetPlatformWinMDLocation Condition="'$(UseOsWinMdReferences)' == 'true'">$(WinDir)\System32\WinMetadata</TargetPlatformWinMDLocation>
-    <TargetPlatformMoniker Condition="'$(TargetPlatformMoniker)' == ''">$(TargetPlatformIdentifier),Version=$(TargetPlatformVersion)</TargetPlatformMoniker>
+    <TargetPlatformMoniker Condition="'$(TargetPlatformMoniker)' == '' and '$(TargetPlatformIdentifier)' != '' and '$(TargetPlatformVersion)' != ''">$(TargetPlatformIdentifier),Version=$(TargetPlatformVersion)</TargetPlatformMoniker>
     <TargetPlatformDisplayName Condition="'$(TargetPlatformDisplayName)' == ''">$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPlatformSDKDisplayName($(TargetPlatformIdentifier), $(TargetPlatformVersion)))</TargetPlatformDisplayName>
   </PropertyGroup>
 
@@ -123,6 +123,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     -->
 
   <PropertyGroup>
+    <GenerateFullPaths Condition="'$(GenerateFullPaths)' == ''">true</GenerateFullPaths>
     <!-- Ensure any OutputPath has a trailing slash, so it can be concatenated -->
     <OutputPath Condition="'$(OutputPath)' != '' and !HasTrailingSlash('$(OutputPath)')">$(OutputPath)\</OutputPath>
     <AssemblyName Condition=" '$(AssemblyName)'=='' ">$(MSBuildProjectName)</AssemblyName>
@@ -1652,11 +1653,26 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </ItemGroup>
 
     <!-- For each reference, get closest match -->
+
+    <!-- Pass the CurrentProjectTargetPlatform parameter to the task only if GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter is true.  This means
+         that we are using a version of NuGet which supports that parameter on this task. -->
+    
     <GetReferenceNearestTargetFrameworkTask AnnotatedProjectReferences="@(_ProjectReferenceTargetFrameworkPossibilities)"
                                             CurrentProjectTargetFramework="$(ReferringTargetFrameworkForProjectReferences)"
+                                            CurrentProjectTargetPlatform="$(TargetPlatformMoniker)"
                                             CurrentProjectName="$(MSBuildProjectName)"
                                             FallbackTargetFrameworks="$(AssetTargetFallback)"
-                                            Condition="'@(_ProjectReferenceTargetFrameworkPossibilities->Count())' != '0' and '$(ReferringTargetFrameworkForProjectReferences)' != ''">
+                                            Condition="'@(_ProjectReferenceTargetFrameworkPossibilities->Count())' != '0' and '$(ReferringTargetFrameworkForProjectReferences)' != ''
+                                                        And '$(GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter)' == 'true'">
+      <Output ItemName="AnnotatedProjects" TaskParameter="AssignedProjects" />
+    </GetReferenceNearestTargetFrameworkTask>
+
+    <GetReferenceNearestTargetFrameworkTask AnnotatedProjectReferences="@(_ProjectReferenceTargetFrameworkPossibilities)"
+                                            CurrentProjectTargetFramework="$(ReferringTargetFrameworkForProjectReferences)"
+                                            CurrentProjectName="$(MSBuildProjectName)"
+                                            FallbackTargetFrameworks="$(AssetTargetFallback)"
+                                            Condition="'@(_ProjectReferenceTargetFrameworkPossibilities->Count())' != '0' and '$(ReferringTargetFrameworkForProjectReferences)' != ''
+                                                        And '$(GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter)' != 'true'">
       <Output ItemName="AnnotatedProjects" TaskParameter="AssignedProjects" />
     </GetReferenceNearestTargetFrameworkTask>
 
@@ -1696,20 +1712,41 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </Target>
 
   <Target Name="GetTargetFrameworks"
+          DependsOnTargets="GetTargetFrameworksWithPlatformForSingleTargetFramework"
           Returns="@(_ThisProjectBuildMetadata)">
+
+    <Error Condition="'$(IsCrossTargetingBuild)' == 'true'"
+           Text="Internal MSBuild error: Non-CrossTargeting GetTargetFrameworks target should not be used in cross targeting (outer) build" />
+
     <ItemGroup>
       <_ThisProjectBuildMetadata Include="$(MSBuildProjectFullPath)">
-        <TargetFrameworks Condition="'$(TargetFrameworks)' != ''">$(TargetFrameworks)</TargetFrameworks>
-        <TargetFrameworks Condition="'$(TargetFrameworks)' == ''">$(TargetFramework)</TargetFrameworks>
+        <TargetFrameworks>@(_TargetFrameworkInfo)</TargetFrameworks>
+        <TargetFrameworkMonikers>@(_TargetFrameworkInfo->'%(TargetFrameworkMonikers)')</TargetFrameworkMonikers>
+        <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>
+
         <HasSingleTargetFramework>true</HasSingleTargetFramework>
-        <HasSingleTargetFramework Condition="'$(IsCrossTargetingBuild)' == 'true'">false</HasSingleTargetFramework>
+        
         <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->
-      <IsRidAgnostic>false</IsRidAgnostic>
-      <IsRidAgnostic Condition=" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
+        <IsRidAgnostic>false</IsRidAgnostic>
+        <IsRidAgnostic Condition=" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
       </_ThisProjectBuildMetadata>
     </ItemGroup>
   </Target>
 
+  <Target Name="GetTargetFrameworksWithPlatformForSingleTargetFramework"
+        Returns="@(_TargetFrameworkInfo)">
+
+    <ItemGroup>
+      <_TargetFrameworkInfo Include="$(TargetFramework)">
+        <TargetFrameworks>$(TargetFramework)</TargetFrameworks>
+        <TargetFrameworkMonikers>$(TargetFrameworkMoniker)</TargetFrameworkMonikers>
+        <TargetPlatformMonikers>$(TargetPlatformMoniker)</TargetPlatformMonikers>
+        <TargetPlatformMonikers Condition="'$(TargetPlatformMoniker)' == ''">None</TargetPlatformMonikers>
+      </_TargetFrameworkInfo>
+    </ItemGroup>
+
+  </Target>
+
   <!--
     ============================================================
                                     GetTargetFrameworkProperties
@@ -2121,6 +2158,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         IgnoreTargetFrameworkAttributeVersionMismatch ="$(ResolveAssemblyReferenceIgnoreTargetFrameworkAttributeVersionMismatch)"
         FindDependenciesOfExternallyResolvedReferences="$(FindDependenciesOfExternallyResolvedReferences)"
         ContinueOnError="$(ContinueOnError)"
+        UseResolveAssemblyReferenceService="$(UseResolveAssemblyReferenceService)"
         Condition="'@(Reference)'!='' or '@(_ResolvedProjectReferencePaths)'!='' or '@(_ExplicitReference)' != ''"
         >
 
@@ -4922,7 +4960,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     -->
   <Target
        Name="IncrementalClean"
-       DependsOnTargets="_CleanGetCurrentAndPriorFileWrites">
+       DependsOnTargets="$(IncrementalCleanDependsOn);_CleanGetCurrentAndPriorFileWrites">
 
     <!-- Subtract list of files produced in prior builds from list of files produced in this build. -->
     <ItemGroup>
diff --git a/src/Tasks/Microsoft.Managed.After.targets b/src/Tasks/Microsoft.Managed.After.targets
index 243c49179e2..a5dfd1da0ff 100644
--- a/src/Tasks/Microsoft.Managed.After.targets
+++ b/src/Tasks/Microsoft.Managed.After.targets
@@ -43,10 +43,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <_MainReferenceTarget Condition="'$(_MainReferenceTarget)' == ''">GetTargetPath</_MainReferenceTarget>
 
     <ProjectReferenceTargetsForBuildInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForBuildInOuterBuild)</ProjectReferenceTargetsForBuildInOuterBuild>
-    <ProjectReferenceTargetsForBuild>$(_MainReferenceTarget);GetNativeManifest;$(_RecursiveTargetForContentCopying);$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
+    <ProjectReferenceTargetsForBuild>$(_MainReferenceTarget);GetNativeManifest;$(_RecursiveTargetForContentCopying);GetTargetFrameworksWithPlatformForSingleTargetFramework;$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
 
     <ProjectReferenceTargetsForCleanInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForCleanInOuterBuild)</ProjectReferenceTargetsForCleanInOuterBuild>
-    <ProjectReferenceTargetsForClean>Clean;$(ProjectReferenceTargetsForClean)</ProjectReferenceTargetsForClean>
+    <ProjectReferenceTargetsForClean>Clean;GetTargetFrameworksWithPlatformForSingleTargetFramework;$(ProjectReferenceTargetsForClean)</ProjectReferenceTargetsForClean>
 
     <ProjectReferenceTargetsForRebuildInOuterBuild>$(ProjectReferenceTargetsForCleanInOuterBuild);$(ProjectReferenceTargetsForBuildInOuterBuild);$(ProjectReferenceTargetsForRebuildInOuterBuild)</ProjectReferenceTargetsForRebuildInOuterBuild>
     <ProjectReferenceTargetsForRebuild>$(ProjectReferenceTargetsForClean);$(ProjectReferenceTargetsForBuild);$(ProjectReferenceTargetsForRebuild)</ProjectReferenceTargetsForRebuild>
diff --git a/src/Tasks/Move.cs b/src/Tasks/Move.cs
index a9136d0a089..8e64b2f7038 100644
--- a/src/Tasks/Move.cs
+++ b/src/Tasks/Move.cs
@@ -180,7 +180,7 @@ private static void MakeWriteableIfReadOnly(string file)
             var info = new FileInfo(file);
             if ((info.Attributes & FileAttributes.ReadOnly) != 0)
             {
-                info.Attributes = info.Attributes & ~FileAttributes.ReadOnly;
+                info.Attributes &= ~FileAttributes.ReadOnly;
             }
         }
 
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index 71d2fd91fa4..a4e4fd164a2 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -1324,20 +1324,17 @@ internal enum AssemblyComparisonResult
         #region Methods
 #if FEATURE_HANDLEPROCESSCORRUPTEDSTATEEXCEPTIONS
         /// <summary>
-        /// Given a pointer to a metadata blob, read the string parameter from it.  Returns true if 
-        /// a valid string was constructed and false otherwise.  
-        /// 
-        /// Adapted from bizapps\server\designers\models\packagemodel\nativemethods.cs (TryReadStringArgument) and 
+        /// Given a pointer to a metadata blob, read the string parameter from it.  Returns true if
+        /// a valid string was constructed and false otherwise.
+        ///
+        /// Adapted from bizapps\server\designers\models\packagemodel\nativemethods.cs (TryReadStringArgument) and
         /// the original ARD implementation in vsproject\compsvcspkg\enumcomplus.cpp (GetStringCustomAttribute)
         /// This code was taken from the vsproject\ReferenceManager\Providers\NativeMethods.cs
         /// </summary>
         [HandleProcessCorruptedStateExceptions]
         internal static unsafe bool TryReadMetadataString(string fullPath, IntPtr attrData, uint attrDataSize, out string strValue)
         {
-            IntPtr attrDataPostProlog = IntPtr.Zero;
             int attrDataOffset = 0;
-            int strLen = 0;
-            int i = 0;
             strValue = null;
 
             try
@@ -1354,8 +1351,9 @@ internal static unsafe bool TryReadMetadataString(string fullPath, IntPtr attrDa
                 if ((attrDataSize >= 4) && (Marshal.ReadInt16(attrData, attrDataOffset) == 1))
                 {
                     int preReadOffset = 2; // pass the prolog
-                    attrDataPostProlog = attrData + preReadOffset;
+                    IntPtr attrDataPostProlog = attrData + preReadOffset;
 
+                    int strLen;
                     // Get the offset at which the uncompressed data starts, and the 
                     // length of the uncompressed data.
                     attrDataOffset = CorSigUncompressData(attrDataPostProlog, out strLen);
@@ -1368,6 +1366,7 @@ internal static unsafe bool TryReadMetadataString(string fullPath, IntPtr attrDa
                         {
                             // Read in the uncompressed data
                             byte[] bytes = new byte[(int)strLen];
+                            int i;
                             for (i = 0; i < strLen; i++)
                             {
                                 bytes[i] = Marshal.ReadByte(attrDataPostProlog, attrDataOffset + i);
@@ -1398,14 +1397,14 @@ internal static unsafe bool TryReadMetadataString(string fullPath, IntPtr attrDa
                 return false;
             }
 
-            return (strValue != null);
+            return strValue != null;
         }
 #endif
         /// <summary>
-        /// Returns the number of bytes that compressed data -- the length of the uncompressed 
-        /// data -- takes up, and has an out value of the length of the string.  
-        /// 
-        /// Decompression algorithm stolen from ndp\clr\src\toolbox\mdbg\corapi\metadata\cormetadata.cs, which 
+        /// Returns the number of bytes that compressed data -- the length of the uncompressed
+        /// data -- takes up, and has an out value of the length of the string.
+        ///
+        /// Decompression algorithm stolen from ndp\clr\src\toolbox\mdbg\corapi\metadata\cormetadata.cs, which
         /// was translated from the base implementation in ndp\clr\src\inc\cor.h
         /// This code was taken from the vsproject\ReferenceManager\Providers\NativeMethods.cs
         /// </summary>
@@ -1432,12 +1431,12 @@ internal static unsafe int CorSigUncompressData(IntPtr data, out int uncompresse
             // Medium.  
             else if ((*bytes & 0xC0) == 0x80)  // 10?? ????    
             {
-                uncompressedDataLength = (int)(((*bytes & 0x3f) << 8 | *(bytes + 1)));
+                uncompressedDataLength = (int)((*bytes & 0x3f) << 8 | *(bytes + 1));
                 count = 2;
             }
             else if ((*bytes & 0xE0) == 0xC0)      // 110? ????    
             {
-                uncompressedDataLength = (int)(((*bytes & 0x1f) << 24 | *(bytes + 1) << 16 | *(bytes + 2) << 8 | *(bytes + 3)));
+                uncompressedDataLength = (int)((*bytes & 0x1f) << 24 | *(bytes + 1) << 16 | *(bytes + 2) << 8 | *(bytes + 3));
                 count = 4;
             }
 
diff --git a/src/Tasks/RCWForCurrentContext.cs b/src/Tasks/RCWForCurrentContext.cs
index 601bc5336f7..0511c385cb1 100644
--- a/src/Tasks/RCWForCurrentContext.cs
+++ b/src/Tasks/RCWForCurrentContext.cs
@@ -74,13 +74,12 @@ public RCWForCurrentContext(T rcw)
         /// Call this helper if your managed object is really an RCW to a COM object
         /// and that COM object was created in a different apartment from where it is being accessed
         /// </summary>
-        /// <param name="rcw">An RCW object created in the original apartment context.</param>
         /// <returns>A new RCW created in the current apartment context</returns>
         public T RCW
         {
             get
             {
-                if (null == _rcwForCurrentCtx)
+                if (_rcwForCurrentCtx == null)
                 {
                     throw new ObjectDisposedException("RCWForCurrentCtx");
                 }
@@ -109,7 +108,7 @@ private void CleanupComObject()
         {
             try
             {
-                if (null != _rcwForCurrentCtx &&
+                if (_rcwForCurrentCtx != null &&
                     _shouldReleaseRCW &&
                     Marshal.IsComObject(_rcwForCurrentCtx))
                 {
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index 9bc15d0aed2..9da5c32a396 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -29,7 +29,7 @@ namespace Microsoft.Build.Tasks
     /// Framework version dependencies to the current Framework version.
     /// This list is also used by the deployment system to exclude Framework
     /// dependencies from customer deployment packages.
-    /// </summary>    
+    /// </summary>
     internal sealed class RedistList
     {
         // List of cached RedistList objects, the key is a semi-colon delimited list of data file paths
@@ -66,7 +66,7 @@ internal sealed class RedistList
 
         // List of cached BlackList RedistList objects, the key is a semi-colon delimited list of data file paths
         private readonly ConcurrentDictionary<string, Dictionary<string, string>> _cachedBlackList = new ConcurrentDictionary<string, Dictionary<string, string>>(StringComparer.OrdinalIgnoreCase);
-        
+
         /***************Fields which are only set in the constructor and should not be modified by the class. **********************/
         // Array of errors encountered while reading files.
         private readonly ReadOnlyCollection<Exception> _errors;
@@ -165,12 +165,12 @@ public bool IsFrameworkAssembly(string assemblyName)
         public bool IsPrerequisiteAssembly(string assemblyName)
         {
             AssemblyEntry entry = GetUnifiedAssemblyEntry(assemblyName);
-            return entry != null && entry.InGAC;
+            return entry?.InGAC == true;
         }
 
         /// <summary>
-        /// If there was a remapping entry in the redist list list then remap the passed in assemblynameextension 
-        /// if not just return the original one. 
+        /// If there was a remapping entry in the redist list then remap the passed in assemblynameextension
+        /// if not just return the original one.
         /// </summary>
         public AssemblyNameExtension RemapAssembly(AssemblyNameExtension extensionToRemap)
         {
@@ -482,24 +482,26 @@ internal IEnumerable<AssemblyEntry> FindAssemblyNameFromSimpleName(string simple
         }
 
         /// <summary>
-        /// This method will take a list of AssemblyTableInfo and generate a black list by subtracting the 
-        /// assemblies listed in the WhiteList from the RedistList. 
-        /// 
+        /// This method will take a list of AssemblyTableInfo and generate a black list by subtracting the
+        /// assemblies listed in the WhiteList from the RedistList.
+        ///
         /// 1) If there are assemblies in the redist list and one or more client subset files are read in with matching names then
         ///    the subtraction will take place. If there were no matching redist lists read in the black list will be empty.
-        ///    
+        ///
         /// 2) If the subset has a matching name but there are no files inside of it then the black list will contain ALL files in the redist list.
-        /// 
+        ///
         /// 3) If the redist list assembly has a null or empty redist name or the subset list has a null or empty subset name they will not be used for black list generation.
         ///
         /// When generating the blacklist, we will first see if the black list is in the appdomain wide cache
         /// so that we do not regenerate one for multiple calls using the same whiteListAssemblyTableInfo.
-        /// 
+        ///
         /// </summary>
         /// <param name="whiteListAssemblyTableInfo">List of paths to white list xml files</param>
-        /// <returns>A dictionary containing the full assembly names of black listed assemblies as the key, and null as the value. 
+        /// <param name="whiteListErrors">List of white listed errors</param>
+        /// <param name="whiteListErrorFileNames">List of white listed error file names</param>
+        /// <returns>A dictionary containing the full assembly names of black listed assemblies as the key, and null as the value.
         ///          If there is no assemblies in the redist list null is returned.
-        /// </returns> 
+        /// </returns>
         internal Dictionary<string, string> GenerateBlackList(AssemblyTableInfo[] whiteListAssemblyTableInfo, List<Exception> whiteListErrors, List<string> whiteListErrorFileNames)
         {
             // Return null if there are no assemblies in the redist list.
@@ -621,6 +623,10 @@ internal Dictionary<string, string> GenerateBlackList(AssemblyTableInfo[] whiteL
         /// XML formatting issues will recorded in the 'errors' collection.
         /// </summary>
         /// <param name="assemblyTableInfo">Information about the redistlist file.</param>
+        /// <param name="assembliesList">List of assembly from installed assembly table.</param>
+        /// <param name="errorsList">Error list.</param>
+        /// <param name="errorFilenamesList">Error filename list.</param>
+        /// <param name="remapEntries">Assembly remaping.</param>
         /// <returns>Redist name of the redist list just read in</returns>
         internal static string ReadFile(AssemblyTableInfo assemblyTableInfo, List<AssemblyEntry> assembliesList, List<Exception> errorsList, List<string> errorFilenamesList, List<AssemblyRemapping> remapEntries)
         {
@@ -833,7 +839,7 @@ private static AssemblyEntry ReadFileListEntry(AssemblyTableInfo assemblyTableIn
             }
 
             bool isValidEntry = !string.IsNullOrEmpty(name) && (!fullFusionNameRequired || (fullFusionNameRequired && !string.IsNullOrEmpty(version) && !string.IsNullOrEmpty(publicKeyToken) && !string.IsNullOrEmpty(culture)));
-            Debug.Assert(isValidEntry, string.Format(CultureInfo.InvariantCulture, "Missing attribute in redist file: {0}, line #{1}", path, 
+            Debug.Assert(isValidEntry, string.Format(CultureInfo.InvariantCulture, "Missing attribute in redist file: {0}, line #{1}", path,
                 reader is IXmlLineInfo ? ((IXmlLineInfo)reader).LineNumber : 0));
             AssemblyEntry newEntry = null;
             if (isValidEntry)
@@ -928,7 +934,7 @@ public int CompareTo(object obj)
     }
 
     /// <summary>
-    /// Provide a mechanism to determine where the subset white lists are located by searching the target framework folders 
+    /// Provide a mechanism to determine where the subset white lists are located by searching the target framework folders
     /// for a list of provided subset list names.
     /// </summary>
     internal class SubsetListFinder
@@ -958,8 +964,8 @@ internal class SubsetListFinder
         /// This class takes in a list of subset names to look for and provides a method to search the target framework directories to see if those
         /// files exist.
         /// </summary>
-        /// <param name="subsetToSearchFor">String array of subset names, ie  Client, Net, MySubset. This may be null or empty if no subsets were requested to be 
-        /// found in the target framework directories. This can happen if the the subsets are instead passed in as InstalledDefaultSubsetTables</param>
+        /// <param name="subsetToSearchFor">String array of subset names, ie  Client, Net, MySubset. This may be null or empty if no subsets were requested to be
+        /// found in the target framework directories. This can happen if the subsets are instead passed in as InstalledDefaultSubsetTables</param>
         internal SubsetListFinder(string[] subsetToSearchFor)
         {
             ErrorUtilities.VerifyThrowArgumentNull(subsetToSearchFor, nameof(subsetToSearchFor));
diff --git a/src/Tasks/RegisterAssembly.cs b/src/Tasks/RegisterAssembly.cs
index ecd34871a69..3fdf14ffd43 100644
--- a/src/Tasks/RegisterAssembly.cs
+++ b/src/Tasks/RegisterAssembly.cs
@@ -72,7 +72,7 @@ public override bool Execute()
 
             AssemblyRegistrationCache cacheFile = null;
 
-            if ((AssemblyListFile != null) && (AssemblyListFile.ItemSpec.Length > 0))
+            if ((AssemblyListFile?.ItemSpec.Length > 0))
             {
                 cacheFile = (AssemblyRegistrationCache)StateFileBase.DeserializeCache(AssemblyListFile.ItemSpec, Log, typeof(AssemblyRegistrationCache)) ??
                             new AssemblyRegistrationCache();
@@ -89,7 +89,7 @@ public override bool Execute()
                         string tlbPath;
 
                         // if the type lib path is not supplied, generate default one
-                        if ((TypeLibFiles[i] != null) && (TypeLibFiles[i].ItemSpec.Length > 0))
+                        if ((TypeLibFiles[i]?.ItemSpec.Length > 0))
                         {
                             tlbPath = TypeLibFiles[i].ItemSpec;
                         }
diff --git a/src/Tasks/ResGen.cs b/src/Tasks/ResGen.cs
index 08df15001b4..49ba98efc05 100644
--- a/src/Tasks/ResGen.cs
+++ b/src/Tasks/ResGen.cs
@@ -457,7 +457,7 @@ protected override bool ValidateParameters()
             /// <returns>True if the array is null or has length zero</returns>
             private static bool IsNullOrEmpty(ITaskItem[] value)
             {
-                return (value == null || value.Length == 0);
+                return value == null || value.Length == 0;
             }
 
             /// <summary>
@@ -538,7 +538,7 @@ private string GenerateResGenFullPath()
             /// </summary>
             private void GenerateResGenCommands(CommandLineBuilderExtension resGenArguments, bool useForResponseFile)
             {
-                resGenArguments = resGenArguments ?? new CommandLineBuilderExtension();
+                resGenArguments ??= new CommandLineBuilderExtension();
 
                 if (IsNullOrEmpty(OutputFiles))
                 {
@@ -577,7 +577,7 @@ private void GenerateResGenCommands(CommandLineBuilderExtension resGenArguments,
                     resGenArguments.AppendSwitch("/compile" + (useForResponseFile ? "\n" : String.Empty));
 
                     // append the resources to compile
-                    if (InputFiles != null && InputFiles.Length > 0)
+                    if (InputFiles?.Length > 0)
                     {
                         ITaskItem[] inputFiles = InputFiles;
                         ITaskItem[] outputFiles = OutputFiles;
diff --git a/src/Tasks/ResGenDependencies.cs b/src/Tasks/ResGenDependencies.cs
index e174d3e8f0d..3632a916d83 100644
--- a/src/Tasks/ResGenDependencies.cs
+++ b/src/Tasks/ResGenDependencies.cs
@@ -61,7 +61,7 @@ internal string BaseLinkedFileDirectory
                 }
                 if ((value == null && baseLinkedFileDirectory != null) ||
                      (value != null && baseLinkedFileDirectory == null) ||
-                     (String.Compare(baseLinkedFileDirectory, value, StringComparison.OrdinalIgnoreCase) != 0))
+                     (!String.Equals(baseLinkedFileDirectory, value, StringComparison.OrdinalIgnoreCase)))
                 {
                     // Ok, this is slightly complicated.  Changing the base directory in any manner may
                     // result in changes to how we find .resx files.  Therefore, we must clear our out
@@ -132,7 +132,7 @@ internal PortableLibraryFile TryGetPortableLibraryInfo(string libraryPath)
 
             // The file is in our cache.  Make sure it's up to date.  If not, discard
             // this entry from the cache and rebuild all the state at a later point.
-            if (retVal != null && retVal.HasFileChanged())
+            if (retVal?.HasFileChanged() == true)
             {
                 portableLibraries.RemoveDependencyFile(libraryPath);
                 _isDirty = true;
@@ -252,7 +252,7 @@ private static string[] GetLinkedFiles(string filename, string baseLinkedFileDir
                         // contains the .resx file as the path from which it should resolve
                         // relative paths. So we should base our timestamp/existence checking
                         // on the same switch & resolve in the same manner as ResGen.
-                        resxReader.BasePath = (baseLinkedFileDirectory == null) ? Path.GetDirectoryName(filename) : baseLinkedFileDirectory;
+                        resxReader.BasePath = baseLinkedFileDirectory ?? Path.GetDirectoryName(filename);
 
                         foreach (DictionaryEntry dictEntry in resxReader)
                         {
diff --git a/src/Tasks/ResolveAssemblyReferences/Client/RarClient.cs b/src/Tasks/ResolveAssemblyReferences/Client/RarClient.cs
new file mode 100644
index 00000000000..f35dc0f61b4
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/Client/RarClient.cs
@@ -0,0 +1,75 @@
+Ôªø// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.IO.Pipes;
+using Microsoft.Build.Eventing;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
+using StreamJsonRpc;
+
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Client
+{
+    internal sealed class RarClient : IDisposable
+    {
+        /// <summary>
+        /// Default connection timeout for connection to the pipe. Timeout is in millisecond.
+        /// </summary>
+        private const int DefaultConnectionTimeout = 300;
+        private readonly IRarBuildEngine _rarBuildEngine;
+        private NamedPipeClientStream _clientStream;
+
+        public RarClient(IRarBuildEngine rarBuildEngine)
+        {
+            _rarBuildEngine = rarBuildEngine;
+        }
+
+        internal bool Connect() => Connect(DefaultConnectionTimeout);
+
+        internal bool Connect(int timeout)
+        {
+            if (_clientStream != null)
+                return true;
+
+            string pipeName = _rarBuildEngine.GetRarPipeName();
+
+            MSBuildEventSource.Log.ResolveAssemblyReferenceNodeConnectStart();
+            NamedPipeClientStream stream = _rarBuildEngine.GetRarClientStream(pipeName, timeout);
+            MSBuildEventSource.Log.ResolveAssemblyReferenceNodeConnectStop();
+
+            if (stream == null)
+                return false; // We couldn't connect
+
+            _clientStream = stream;
+            return true;
+        }
+
+        internal bool CreateNode()
+        {
+            return _rarBuildEngine.CreateRarNode();
+        }
+
+        internal object Execute()
+        {
+            throw new NotImplementedException();
+            //using IResolveAssemblyReferenceTaskHandler client = GetRpcClient();
+
+            // TODO: Find out if there is any possibility of awaiting it.
+            //return client.GetNumber(parameter).GetAwaiter().GetResult();
+        }
+
+        private IResolveAssemblyReferenceTaskHandler GetRpcClient()
+        {
+            ErrorUtilities.VerifyThrowInternalErrorUnreachable(_clientStream != null);
+
+            IJsonRpcMessageHandler handler = RpcUtils.GetRarMessageHandler(_clientStream);
+            return JsonRpc.Attach<IResolveAssemblyReferenceTaskHandler>(handler);
+        }
+
+        public void Dispose()
+        {
+            _clientStream?.Dispose();
+        }
+    }
+}
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/IResolveAssemblyReferenceTaskHandler.cs b/src/Tasks/ResolveAssemblyReferences/Contract/IResolveAssemblyReferenceTaskHandler.cs
new file mode 100644
index 00000000000..0b6387394f1
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/IResolveAssemblyReferenceTaskHandler.cs
@@ -0,0 +1,12 @@
+Ôªø// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
+{
+    internal interface IResolveAssemblyReferenceTaskHandler : IDisposable
+    {
+    }
+}
diff --git a/src/Tasks/ResolveAssemblyReferences/RpcUtils.cs b/src/Tasks/ResolveAssemblyReferences/RpcUtils.cs
new file mode 100644
index 00000000000..e8d2d17e995
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/RpcUtils.cs
@@ -0,0 +1,19 @@
+Ôªø// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System.IO;
+
+using Nerdbank.Streams;
+using StreamJsonRpc;
+
+#nullable enable
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences
+{
+    internal static class RpcUtils
+    {
+        internal static IJsonRpcMessageHandler GetRarMessageHandler(Stream stream)
+        {
+            return new LengthHeaderMessageHandler(stream.UsePipe(), new MessagePackFormatter());
+        }
+    }
+}
diff --git a/src/Tasks/ResolveAssemblyReferences/Server/RarController.cs b/src/Tasks/ResolveAssemblyReferences/Server/RarController.cs
new file mode 100644
index 00000000000..2852a7d620f
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/Server/RarController.cs
@@ -0,0 +1,171 @@
+Ôªø// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.IO;
+using System.IO.Pipes;
+using System.Threading;
+using System.Threading.Tasks;
+
+using Microsoft.Build.Framework;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Services;
+using Microsoft.VisualStudio.Threading;
+
+using StreamJsonRpc;
+
+#nullable enable
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Server
+{
+    internal sealed class RarController : IRarController
+    {
+        /// <summary>
+        /// The amount of time to wait for the validation of connection.
+        /// </summary>
+        private const int ValidationTimeout = 60000;
+
+        /// <summary>
+        /// Name of <see cref="NamedPipeServerStream"/>
+        /// </summary>
+        private readonly string _pipeName;
+
+        /// <summary>
+        /// Handshake used for validation of incoming connections
+        /// </summary>
+        private readonly Handshake _handshake;
+
+
+        /// <summary>
+        /// Factory callback to NamedPipeUtils.CreateNamedPipeServer
+        /// 1. arg: pipe name
+        /// 2. arg: input buffer size
+        /// 3. arg: input buffer size
+        /// 4. arg. number of allow clients
+        /// 5. arg. add right to CreateNewInstance
+        /// </summary>
+        private readonly Func<string, int?, int?, int, bool, NamedPipeServerStream> _namedPipeServerFactory;
+
+        /// <summary>
+        /// Callback to validate the handshake.
+        /// 1. arg: expected handshake
+        /// 2. arg: named pipe over which we should validate the handshake
+        /// 3. arg: timeout for validation
+        /// </summary>
+        private readonly Func<Handshake, NamedPipeServerStream, int, bool> _validateHandshakeCallback;
+
+        /// <summary>
+        /// Handler for all incoming tasks
+        /// </summary>
+        private readonly IResolveAssemblyReferenceTaskHandler _resolveAssemblyReferenceTaskHandler;
+
+        /// <summary>
+        /// Timeout for incoming connections
+        /// </summary>
+        private readonly TimeSpan Timeout = TimeSpan.FromMinutes(15);
+
+        public RarController(
+            string pipeName,
+            Handshake handshake,
+            Func<string, int?, int?, int, bool, NamedPipeServerStream> namedPipeServerFactory,
+            Func<Handshake, NamedPipeServerStream, int, bool> validateHandshakeCallback,
+            TimeSpan? timeout = null)
+            : this(pipeName,
+                  handshake,
+                  namedPipeServerFactory,
+                  validateHandshakeCallback,
+                  timeout: timeout,
+                  resolveAssemblyReferenceTaskHandler: new RarTaskHandler())
+        {
+        }
+
+        internal RarController(
+            string pipeName,
+            Handshake handshake,
+            Func<string, int?, int?, int, bool, NamedPipeServerStream> namedPipeServerFactory,
+            Func<Handshake, NamedPipeServerStream, int, bool> validateHandshakeCallback,
+            IResolveAssemblyReferenceTaskHandler resolveAssemblyReferenceTaskHandler,
+            TimeSpan? timeout = null)
+        {
+            _pipeName = pipeName;
+            _handshake = handshake;
+            _namedPipeServerFactory = namedPipeServerFactory;
+            _validateHandshakeCallback = validateHandshakeCallback;
+            _resolveAssemblyReferenceTaskHandler = resolveAssemblyReferenceTaskHandler;
+
+            if (timeout.HasValue)
+            {
+                Timeout = timeout.Value;
+            }
+        }
+
+        public async Task<int> StartAsync(CancellationToken cancellationToken = default)
+        {
+
+            using ServerMutex mutex = new ServerMutex(_pipeName);
+            if (!mutex.IsLocked)
+            {
+                return 1;
+            }
+
+            using CancellationTokenSource cancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
+            CancellationToken token = cancellationTokenSource.Token;
+
+            while (!token.IsCancellationRequested)
+            {
+                // server will dispose stream too.
+                NamedPipeServerStream serverStream = GetStream(_pipeName);
+                await serverStream.WaitForConnectionAsync(token).ConfigureAwait(false);
+
+                if (!_validateHandshakeCallback(_handshake, serverStream, ValidationTimeout))
+                    continue;
+
+                // Connected! Refresh timeout for incoming request
+                cancellationTokenSource.CancelAfter(Timeout);
+
+                _ = HandleClientAsync(serverStream, token).ConfigureAwait(false);
+            }
+
+            return 0;
+        }
+
+        private async Task HandleClientAsync(Stream serverStream, CancellationToken cancellationToken = default)
+        {
+            using JsonRpc server = GetRpcServer(serverStream, _resolveAssemblyReferenceTaskHandler);
+            server.StartListening();
+
+            try
+            {
+                await server.Completion.WithCancellation(cancellationToken).ConfigureAwait(false);
+            }
+            catch (ConnectionLostException)
+            {
+                // Some problem with connection, let's ignore it.
+                // All other exceptions are issue though
+            }
+        }
+
+        private JsonRpc GetRpcServer(Stream stream, IResolveAssemblyReferenceTaskHandler handler)
+        {
+            IJsonRpcMessageHandler serverHandler = RpcUtils.GetRarMessageHandler(stream);
+            JsonRpc rpc = new JsonRpc(serverHandler, handler);
+            return rpc;
+        }
+
+        /// <summary>
+        /// Instantiates an endpoint to act as a client
+        /// </summary>
+        /// <param name="pipeName">The name of the pipe to which we should connect.</param>
+        private NamedPipeServerStream GetStream(string pipeName)
+        {
+            ErrorUtilities.VerifyThrow(_namedPipeServerFactory != null, "Stream factory is not set");
+
+            return _namedPipeServerFactory!(pipeName,
+                null, // Use default size
+                null, // Use default size
+                NamedPipeServerStream.MaxAllowedServerInstances,
+                true);
+        }
+    }
+}
diff --git a/src/Tasks/ResolveAssemblyReferences/Server/ServerMutex.cs b/src/Tasks/ResolveAssemblyReferences/Server/ServerMutex.cs
new file mode 100644
index 00000000000..081904175c3
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/Server/ServerMutex.cs
@@ -0,0 +1,46 @@
+Ôªø// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Threading;
+
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Server
+{
+    internal sealed class ServerMutex : IDisposable
+    {
+        private readonly Mutex _mutex;
+        public bool IsLocked { get; private set; }
+        public bool IsDisposed { get; private set; }
+
+        public ServerMutex(string name)
+        {
+            _mutex = new Mutex(true, name, out bool createdNew);
+            IsLocked = createdNew;
+        }
+
+        public bool Wait(int timeout)
+        {
+            return _mutex.WaitOne(timeout);
+        }
+
+
+        public void Dispose()
+        {
+
+            if (IsDisposed)
+                return;
+            IsDisposed = true;
+
+            try
+            {
+                if (IsLocked)
+                    _mutex.ReleaseMutex();
+            }
+            finally
+            {
+                _mutex.Dispose();
+                IsLocked = false;
+            }
+        }
+    }
+}
diff --git a/src/Tasks/ResolveAssemblyReferences/Services/RarTaskHandler.cs b/src/Tasks/ResolveAssemblyReferences/Services/RarTaskHandler.cs
new file mode 100644
index 00000000000..90e9ca795de
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/Services/RarTaskHandler.cs
@@ -0,0 +1,18 @@
+Ôªø// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Threading.Tasks;
+
+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
+
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Services
+{
+    internal class RarTaskHandler : IResolveAssemblyReferenceTaskHandler
+    {
+        public void Dispose()
+        {
+            // For RPC dispose
+        }
+    }
+}
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index 63fef7d822d..2fd1310d355 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -327,7 +327,7 @@ public override bool Execute()
 
             _timestampCache = (ResolveComReferenceCache)StateFileBase.DeserializeCache(StateFile, Log, typeof(ResolveComReferenceCache));
 
-            if (_timestampCache == null || (_timestampCache != null && !_timestampCache.ToolPathsMatchCachePaths(_tlbimpPath, _aximpPath)))
+            if (_timestampCache?.ToolPathsMatchCachePaths(_tlbimpPath, _aximpPath) != true)
             {
                 if (!Silent)
                 {
@@ -442,7 +442,7 @@ public override bool Execute()
             }
             finally
             {
-                if ((_timestampCache != null) && _timestampCache.Dirty)
+                if ((_timestampCache?.Dirty == true))
                 {
                     _timestampCache.SerializeCache(StateFile, Log);
                 }
@@ -490,7 +490,7 @@ private bool ComputePathToTlbImp()
             {
                 _tlbimpPath = GetPathToSDKFileWithCurrentlyTargetedArchitecture("TlbImp.exe", TargetDotNetFrameworkVersion.Version35, VisualStudioVersion.VersionLatest);
 
-                if (null == _tlbimpPath && ExecuteAsTool)
+                if (_tlbimpPath == null && ExecuteAsTool)
                 {
                     Log.LogErrorWithCodeFromResources("General.PlatformSDKFileNotFound", "TlbImp.exe",
                         ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(TargetDotNetFrameworkVersion.Version35, VisualStudioVersion.VersionLatest),
@@ -502,7 +502,7 @@ private bool ComputePathToTlbImp()
                 _tlbimpPath = SdkToolsPathUtility.GeneratePathToTool(SdkToolsPathUtility.FileInfoExists, TargetProcessorArchitecture, SdkToolsPath, "TlbImp.exe", Log, ExecuteAsTool);
             }
 
-            if (null == _tlbimpPath && !ExecuteAsTool)
+            if (_tlbimpPath == null && !ExecuteAsTool)
             {
                 // if TlbImp.exe is not installed, just use the filename
                 _tlbimpPath = "TlbImp.exe";
@@ -539,7 +539,7 @@ private bool ComputePathToAxImp()
                 // We want to use the copy of AxImp corresponding to our targeted architecture if possible.  
                 _aximpPath = GetPathToSDKFileWithCurrentlyTargetedArchitecture("AxImp.exe", targetAxImpVersion, VisualStudioVersion.VersionLatest);
 
-                if (null == _aximpPath)
+                if (_aximpPath == null)
                 {
                     Log.LogErrorWithCodeFromResources("General.PlatformSDKFileNotFound", "AxImp.exe",
                         ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(targetAxImpVersion, VisualStudioVersion.VersionLatest),
@@ -1165,7 +1165,7 @@ bool IComReferenceResolver.ResolveNetAssemblyReference(string assemblyName, out
 
             for (int i = 0; i < ResolvedAssemblyReferences.GetLength(0); i++)
             {
-                if (String.Compare(Path.GetFileName(ResolvedAssemblyReferences[i].ItemSpec), assemblyName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(Path.GetFileName(ResolvedAssemblyReferences[i].ItemSpec), assemblyName, StringComparison.OrdinalIgnoreCase))
                 {
                     assemblyPath = ResolvedAssemblyReferences[i].ItemSpec;
                     return true;
@@ -1308,6 +1308,7 @@ internal IEnumerable<string> GetResolvedAssemblyReferenceItemSpecs()
         /// <param name="outputDirectory">Directory the interop DLL should be written to</param>
         /// <param name="refName">Name of reference</param>
         /// <param name="topLevelRef">True if this is a top-level reference</param>
+        /// <param name="dependencyPaths">List of dependency paths for that reference</param>
         /// <param name="wrapperInfo">Information about wrapper locations</param>
         /// <returns>True if the reference was already found or successfully generated, false otherwise.</returns>
         internal bool ResolveComReferenceTlb(ComReferenceInfo referenceInfo, string outputDirectory, string refName, bool topLevelRef, List<string> dependencyPaths, out ComReferenceWrapperInfo wrapperInfo)
@@ -1333,7 +1334,7 @@ internal bool ResolveComReferenceTlb(ComReferenceInfo referenceInfo, string outp
                     {
                         // conflicting typelib names for different typelibs? generate a temporary wrapper
                         if (!ComReference.AreTypeLibAttrEqual(referenceInfo.attr, projectRefInfo.attr) &&
-                            String.Compare(referenceInfo.typeLibName, projectRefInfo.typeLibName, StringComparison.OrdinalIgnoreCase) == 0)
+                            String.Equals(referenceInfo.typeLibName, projectRefInfo.typeLibName, StringComparison.OrdinalIgnoreCase))
                         {
                             isTemporary = true;
                         }
@@ -1619,7 +1620,7 @@ internal void SetCopyLocalToFalseOnGacOrNoPIAAssemblies(List<ITaskItem> outputTa
                 if (_projectTargetFramework != null && (_projectTargetFramework >= s_targetFrameworkVersion_40))
                 {
                     if ((embedInteropTypesMetadata != null) &&
-                        (String.Compare(embedInteropTypesMetadata, "true", StringComparison.OrdinalIgnoreCase) == 0))
+                        (String.Equals(embedInteropTypesMetadata, "true", StringComparison.OrdinalIgnoreCase)))
                     {
                         // Embed Interop Types forces CopyLocal to false
                         taskItem.SetMetadata(ItemMetadataNames.copyLocal, "false");
@@ -1631,7 +1632,7 @@ internal void SetCopyLocalToFalseOnGacOrNoPIAAssemblies(List<ITaskItem> outputTa
 
                 // if Private is not set on the original item, we set CopyLocal to false for GAC items 
                 // and true for non-GAC items
-                if ((privateMetadata == null) || (privateMetadata.Length == 0))
+                if (string.IsNullOrEmpty(privateMetadata))
                 {
                     if (String.Compare(taskItem.ItemSpec, 0, gacPath, 0, gacPath.Length, StringComparison.OrdinalIgnoreCase) == 0)
                     {
diff --git a/src/Tasks/ResolveKeySource.cs b/src/Tasks/ResolveKeySource.cs
index bc9b0393007..f6741aa36d2 100644
--- a/src/Tasks/ResolveKeySource.cs
+++ b/src/Tasks/ResolveKeySource.cs
@@ -84,7 +84,6 @@ private static UInt64 HashFromBlob(byte[] data)
             return result;
         }
 
-
         private bool ResolveAssemblyKey()
         {
             bool pfxSuccess = true;
@@ -102,7 +101,7 @@ private bool ResolveAssemblyKey()
                 }
                 if (pfxSuccess)
                 {
-                    if (0 != String.Compare(keyFileExtension, pfxFileExtension, StringComparison.OrdinalIgnoreCase))
+                    if (!String.Equals(keyFileExtension, pfxFileExtension, StringComparison.OrdinalIgnoreCase))
                     {
                         ResolvedKeyFile = KeyFile;
                     }
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index 3b10b04bd42..ab41808f881 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -17,7 +17,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// This task resolves items in the build process (built, dependencies, satellites,
     /// content, debug symbols, documentation, etc.) to files for manifest generation.
-    /// </Summary>
+    /// </summary>
     /// <comment>
     /// This task executes following steps:
     ///   (1) Filter out Framework assemblies
@@ -630,7 +630,7 @@ private bool IsFiltered(ITaskItem item)
                 return true;
             }
 
-            if (identity != null && identity.IsInFramework(Constants.DotNetFrameworkIdentifier, TargetFrameworkVersion))
+            if (identity?.IsInFramework(Constants.DotNetFrameworkIdentifier, TargetFrameworkVersion) == true)
             {
                 return true;
             }
diff --git a/src/Tasks/ResolveNativeReference.cs b/src/Tasks/ResolveNativeReference.cs
index 0170382a0a6..e6e3958fbed 100644
--- a/src/Tasks/ResolveNativeReference.cs
+++ b/src/Tasks/ResolveNativeReference.cs
@@ -82,7 +82,7 @@ private class ItemSpecComparerClass : IComparer
             int IComparer.Compare(Object taskItem1, Object taskItem2)
             {
                 // simply calls string.Compare on the item specs of the items
-                return (string.Compare(((ITaskItem)taskItem1).ItemSpec, ((ITaskItem)taskItem2).ItemSpec, StringComparison.OrdinalIgnoreCase));
+                return string.Compare(((ITaskItem)taskItem1).ItemSpec, ((ITaskItem)taskItem2).ItemSpec, StringComparison.OrdinalIgnoreCase);
             }
         }
         #endregion
@@ -144,7 +144,7 @@ public override bool Execute()
                     }
                     catch (Exception)
                     {
-                        Debug.Assert(false, "Unexpected exception in ResolveNativeReference.Execute. " + 
+                        Debug.Assert(false, "Unexpected exception in ResolveNativeReference.Execute. " +
                             "Please log a MSBuild bug specifying the steps to reproduce the problem.");
                         throw;
                     }
diff --git a/src/Tasks/ResolveNonMSBuildProjectOutput.cs b/src/Tasks/ResolveNonMSBuildProjectOutput.cs
index 9c527a294b2..790fe7fab92 100644
--- a/src/Tasks/ResolveNonMSBuildProjectOutput.cs
+++ b/src/Tasks/ResolveNonMSBuildProjectOutput.cs
@@ -11,14 +11,14 @@
 namespace Microsoft.Build.Tasks
 {
     /// <remarks>
-    /// This task determines the output files for non-MSBuild project references. We look inside 
+    /// This task determines the output files for non-MSBuild project references. We look inside
     /// a special property set by the VS IDE for the list of project guids and their associated outputs.
     /// While there's nothing that would prevent resolution of MSBuild projects in this task, the IDE
     /// only pre-resolves non-MSBuild projects so that we can separate MSBuild project references from
     /// non-MSBuild ones and return the list of MSBuild projects as UnresolvedProjectReferences.
-    /// Then we can use more powerful MSBuild mechanisms to manipulate just the MSBuild project 
-    /// references (i.e. calling into specific targets of references to get the manifest file name) 
-    /// which would not be possible with a mixed list of MSBuild & non-MSBuild references.
+    /// Then we can use more powerful MSBuild mechanisms to manipulate just the MSBuild project
+    /// references (i.e. calling into specific targets of references to get the manifest file name)
+    /// which would not be possible with a mixed list of MSBuild and non-MSBuild references.
     /// </remarks>
     public class ResolveNonMSBuildProjectOutput : ResolveProjectBase
     {
@@ -155,9 +155,10 @@ public override bool Execute()
         #region Methods
 
         /// <summary>
-        /// Given a project reference task item and an XML document containing pre-resolved output paths, 
+        /// Given a project reference task item and an XML document containing pre-resolved output paths,
         /// find the output path for that task item.
         /// </summary>
+        /// <param name="projectRef">project reference to resolve</param>
         /// <param name="resolvedPath">resulting ITaskItem containing the resolved path</param>
         /// <returns>true if resolved successfully</returns>
         internal bool ResolveProject(ITaskItem projectRef, out ITaskItem resolvedPath)
diff --git a/src/Tasks/ResolveSDKReference.cs b/src/Tasks/ResolveSDKReference.cs
index 85618b0140b..51ddc6acde9 100644
--- a/src/Tasks/ResolveSDKReference.cs
+++ b/src/Tasks/ResolveSDKReference.cs
@@ -140,7 +140,7 @@ public string TargetPlatformIdentifier
         {
             get
             {
-                _targetPlatformIdentifier = _targetPlatformIdentifier ?? String.Empty;
+                _targetPlatformIdentifier ??= String.Empty;
                 return _targetPlatformIdentifier;
             }
 
@@ -155,7 +155,7 @@ public string ProjectName
         {
             get
             {
-                _projectName = _projectName ?? String.Empty;
+                _projectName ??= String.Empty;
                 return _projectName;
             }
 
@@ -241,7 +241,7 @@ private Version TargetPlatformAsVersion
         {
             get
             {
-                _targetPlatformVersion = _targetPlatformVersion ?? s_defaultTargetPlatformVersion;
+                _targetPlatformVersion ??= s_defaultTargetPlatformVersion;
                 return _targetPlatformVersion;
             }
 
@@ -1381,7 +1381,7 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
 
                                 // If we have not seen this architecture before (and it has a compatible configuration with what we are targeting) then add it. 
                                 // Also, replace the entry if we have already added an entry for a non configuration specific entry and we now have a configuration specific entry that matches what we are targeting.
-                                if ((configurationComponent == null && !containsKey) || (configurationComponent != null && configurationComponent.Equals(sdkConfiguration, StringComparison.OrdinalIgnoreCase)))
+                                if ((configurationComponent == null && !containsKey) || (configurationComponent?.Equals(sdkConfiguration, StringComparison.OrdinalIgnoreCase) == true))
                                 {
                                     AddStatusMessage("ResolveSDKReference.FoundAppxLocation", appxLocation.Key + "=" + appxLocation.Value);
 
diff --git a/src/Tasks/ResourceHandling/MSBuildResXReader.cs b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
index d2d62c26564..06437e4493b 100644
--- a/src/Tasks/ResourceHandling/MSBuildResXReader.cs
+++ b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
@@ -264,7 +264,7 @@ private static void AddLinkedResource(string resxFilename, bool pathsRelativeToB
         /// </summary>
         /// <remarks>
         /// We can't hard-code byte[] type name due to version number
-        /// updates & potential whitespace issues with ResX files.
+        /// updates and potential whitespace issues with ResX files.
         ///
         /// Comment and logic from https://github.com/dotnet/winforms/blob/16b192389b377c647ab3d280130781ab1a9d3385/src/System.Windows.Forms/src/System/Resources/ResXDataNode.cs#L411-L416
         /// </remarks>
@@ -347,6 +347,5 @@ internal static string[] ParseResxFileRefString(string stringValue)
             }
             return result;
         }
-
     }
 }
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index 8a5c363976b..9fe38b21d0f 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -2935,4 +2935,7 @@
         error codes, because those exceptions should ideally be caught at a higher scope and logged with a wrapper message that
         DOES have an error code.
   -->
+  <data name="RarCouldntConnect" xml:space="preserve">
+    <value>Couldn't connect to the RAR node, starting a new one.</value>
+  </data>
 </root>
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index a1798d0b2c0..b171796dc7c 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -1417,6 +1417,11 @@
         <target state="translated">Vlastnost StopOnFirstFailure nebude m√≠t ≈æ√°dn√Ω √∫ƒçinek, jsou-li splnƒõny v≈°echny n√°sleduj√≠c√≠ podm√≠nky: 1) syst√©m pracuje v re≈æimu v√≠ce proces≈Ø, 2) vlastnost BuildInParallel m√° hodnotu True, 3) vlastnost RunEachTargetSeparately m√° hodnotu False.</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="RarCouldntConnect">
+        <source>Couldn't connect to the RAR node, starting a new one.</source>
+        <target state="new">Couldn't connect to the RAR node, starting a new one.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: Nelze ƒç√≠st ≈ô√°dky ze souboru {0}. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index e1ab948f4a1..89578baaba2 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -1278,7 +1278,7 @@
       </trans-unit>
       <trans-unit id="GenerateResource.MainAssemblyMissingNeutralResourcesLanguage">
         <source>MSB3817: The assembly "{0}" does not have a NeutralResourcesLanguageAttribute on it. To be used in an app package, portable libraries must define a NeutralResourcesLanguageAttribute on their main assembly (ie, the one containing code, not a satellite assembly).</source>
-        <target state="translated">MSB3817: F√ºr die Assembly "{0}" ist kein NeutralResourcesLanguageAttribute angegeben. F√ºr die Verwendung in einem App-Paket m√ºssen portable Bibliotheken ein NeutralResourcesLanguageAttribute f√ºr ihre Hauptassembly (die Assembly mit Code, keine Satellitenassembly) angeben.</target>
+        <target state="translated">MSB3817: F√ºr die Assembly "{0}" ist kein NeutralResourcesLanguageAttribute angegeben. F√ºr die Verwendung in einem App-Paket m√ºssen portierbare Bibliotheken ein NeutralResourcesLanguageAttribute f√ºr ihre Hauptassembly (die Assembly mit Code, keine Satellitenassembly) angeben.</target>
         <note>{StrBegin="MSB3817: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.ExecuteAsToolAndExtractResWNotSupported">
@@ -1417,6 +1417,11 @@
         <target state="translated">StopOnFirstFailure hat keine Auswirkungen, wenn die folgenden Bedingungen alle gelten: 1) Das System wird im Mehrprozessmodus ausgef√ºhrt. 2) Die BuildInParallel-Eigenschaft ist TRUE. 3) Die RunEachTargetSeparately-Eigenschaft ist FALSE.</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="RarCouldntConnect">
+        <source>Couldn't connect to the RAR node, starting a new one.</source>
+        <target state="new">Couldn't connect to the RAR node, starting a new one.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: Die Zeilen aus der Datei "{0}" konnten nicht gelesen werden. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.en.xlf b/src/Tasks/Resources/xlf/Strings.en.xlf
index 76bf8ba1679..6a3d5806ba8 100644
--- a/src/Tasks/Resources/xlf/Strings.en.xlf
+++ b/src/Tasks/Resources/xlf/Strings.en.xlf
@@ -1462,6 +1462,11 @@
         <target state="new">StopOnFirstFailure will have no effect when the following conditions are all present: 1) The system is running in multiple process mode 2) The BuildInParallel property is true. 3) The RunEachTargetSeparately property is false.</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="RarCouldntConnect">
+        <source>Couldn't connect to the RAR node, starting a new one.</source>
+        <target state="new">Couldn't connect to the RAR node, starting a new one.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="new">MSB3501: Could not read lines from file "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 2dcef957d51..1f0c1ed2ae5 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -1417,6 +1417,11 @@
         <target state="translated">StopOnFirstFailure no surtir√° efecto si se dan todas las condiciones siguientes: 1) El sistema se ejecuta en modo de proceso m√∫ltiple. 2) La propiedad BuildInParallel es true. 3) La propiedad RunEachTargetSeparately es false.</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="RarCouldntConnect">
+        <source>Couldn't connect to the RAR node, starting a new one.</source>
+        <target state="new">Couldn't connect to the RAR node, starting a new one.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: No se pudieron leer las l√≠neas del archivo "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index ae2bcb64137..593b3c2d101 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -1417,6 +1417,11 @@
         <target state="translated">StopOnFirstFailure reste sans effet dans les conditions suivantes¬†: 1) Le syst√®me s'ex√©cute en mode multiprocessus. 2) La propri√©t√© BuildInParallel a la valeur true. 3) La propri√©t√© RunEachTargetSeparately a la valeur false.</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="RarCouldntConnect">
+        <source>Couldn't connect to the RAR node, starting a new one.</source>
+        <target state="new">Couldn't connect to the RAR node, starting a new one.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: Impossible de lire les lignes dans le fichier "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 6dd8dc13afb..bde5690037c 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -1417,6 +1417,11 @@
         <target state="translated">StopOnFirstFailure non avr√† alcun effetto in presenza di tutte le condizioni seguenti: 1) il sistema √® in esecuzione in modalit√† a pi√π processi 2) la propriet√† BuildInParallel √® true. 3) la propriet√† RunEachTargetSeparately √® false.</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="RarCouldntConnect">
+        <source>Couldn't connect to the RAR node, starting a new one.</source>
+        <target state="new">Couldn't connect to the RAR node, starting a new one.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: non √® stato possibile leggere le righe dal file "{0}". {1}</target>
@@ -2300,7 +2305,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="translated">MSB3474: l'attivit√† "{0}" non √® supportata nella versione .NET Core di MSBuild. Usare il pacchetto dello strumento Microsoft per la generazione di serializzatori XML. Per altre informazioni, vedere https://go.microsoft.com/fwlink/?linkid=858594.</target>
+        <target state="translated">MSB3474: l'attivit√† "{0}" non √® supportata nella versione .NET Core di MSBuild. Usare il pacchetto dello strumento del generatore di serializzatori XML Microsoft. Per altre informazioni, vedere https://go.microsoft.com/fwlink/?linkid=858594.</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index 84d0fd3f898..262252ade00 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -1278,7 +1278,7 @@
       </trans-unit>
       <trans-unit id="GenerateResource.MainAssemblyMissingNeutralResourcesLanguage">
         <source>MSB3817: The assembly "{0}" does not have a NeutralResourcesLanguageAttribute on it. To be used in an app package, portable libraries must define a NeutralResourcesLanguageAttribute on their main assembly (ie, the one containing code, not a satellite assembly).</source>
-        <target state="translated">MSB3817: „Ç¢„Çª„É≥„Éñ„É™ "{0}" „Å´„ÅØ NeutralResourcesLanguageAttribute „ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥ „Éë„ÉÉ„Ç±„Éº„Ç∏ÂÜÖ„Åß‰ΩøÁî®„Åô„Çã„Å´„ÅØ„ÄÅ„Éù„Éº„Çø„Éñ„É´ „É©„Ç§„Éñ„É©„É™„Åß„É°„Ç§„É≥„ÅÆ„Ç¢„Çª„É≥„Éñ„É™ („Åü„Å®„Åà„Å∞„ÄÅ„Çµ„ÉÜ„É©„Ç§„Éà „Ç¢„Çª„É≥„Éñ„É™„Åß„ÅØ„Å™„Åè„ÄÅ„Ç≥„Éº„Éâ„ÇíÂê´„Çì„Åß„ÅÑ„Çã„ÇÇ„ÅÆ) „Å´ÂØæ„Åó„Å¶ NeutralResourcesLanguageAttribute „ÇíÂÆöÁæ©„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</target>
+        <target state="translated">MSB3817: „Ç¢„Çª„É≥„Éñ„É™ "{0}" „Å´„ÅØ NeutralResourcesLanguageAttribute „ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥ „Éë„ÉÉ„Ç±„Éº„Ç∏ÂÜÖ„Åß‰ΩøÁî®„Åô„Çã„Å´„ÅØ„ÄÅÁßªÊ§çÂèØËÉΩ„Å™„É©„Ç§„Éñ„É©„É™„Åß„É°„Ç§„É≥„ÅÆ„Ç¢„Çª„É≥„Éñ„É™ („Åü„Å®„Åà„Å∞„ÄÅ„Çµ„ÉÜ„É©„Ç§„Éà „Ç¢„Çª„É≥„Éñ„É™„Åß„ÅØ„Å™„Åè„ÄÅ„Ç≥„Éº„Éâ„ÇíÂê´„Çì„Åß„ÅÑ„Çã„ÇÇ„ÅÆ) „Å´ÂØæ„Åó„Å¶ NeutralResourcesLanguageAttribute „ÇíÂÆöÁæ©„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</target>
         <note>{StrBegin="MSB3817: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.ExecuteAsToolAndExtractResWNotSupported">
@@ -1417,6 +1417,11 @@
         <target state="translated">StopOnFirstFailure „ÅØ„ÄÅÊ¨°„ÅÆ„Åô„Åπ„Å¶„ÅÆÊù°‰ª∂„Å´Ë©≤ÂΩì„Åô„ÇãÂ†¥Âêà„Å´ÁÑ°Âäπ„Å®„Å™„Çä„Åæ„Åô„ÄÇ1) „Ç∑„Çπ„ÉÜ„É†„Åå„Éû„É´„ÉÅ„Éó„É≠„Çª„ÉÉ„Çµ „É¢„Éº„Éâ„ÅßÂÆüË°å„Åï„Çå„Å¶„ÅÑ„Çã„ÄÇ2) BuildInParallel „Éó„É≠„Éë„ÉÜ„Ç£„Åå true „Å´Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Çã„ÄÇ3) RunEachTargetSeparately „Éó„É≠„Éë„ÉÜ„Ç£„Åå false „Å´Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Çã„ÄÇ</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="RarCouldntConnect">
+        <source>Couldn't connect to the RAR node, starting a new one.</source>
+        <target state="new">Couldn't connect to the RAR node, starting a new one.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: „Éï„Ç°„Ç§„É´ "{0}" „Åã„Çâ„ÅÆË°å„ÇíË™≠„ÅøÂèñ„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ{1}</target>
@@ -2300,7 +2305,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="translated">MSB3474: „Çø„Çπ„ÇØ "{0}" „ÅØ„ÄÅMSBuild „ÅÆ .NET Core „Éê„Éº„Ç∏„Éß„É≥„Åß„ÅØ„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ‰ª£„Çè„Çä„Å´ Microsoft XML Serializer Generator „Éë„ÉÉ„Ç±„Éº„Ç∏„Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇË©≥Á¥∞„Å´„Å§„ÅÑ„Å¶„ÅØ„ÄÅhttps://go.microsoft.com/fwlink/?linkid=858594 „Çí„ÅîË¶ß„Åè„Å†„Åï„ÅÑ„ÄÇ</target>
+        <target state="translated">MSB3474: „Çø„Çπ„ÇØ "{0}" „ÅØ„ÄÅMSBuild „ÅÆ .NET Core „Éê„Éº„Ç∏„Éß„É≥„Åß„ÅØ„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ‰ª£„Çè„Çä„Å´ Microsoft XML Serializer „Ç∏„Çß„Éç„É¨„Éº„Çø„Éº „Éë„ÉÉ„Ç±„Éº„Ç∏„Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇË©≥Á¥∞„Å´„Å§„ÅÑ„Å¶„ÅØ„ÄÅhttps://go.microsoft.com/fwlink/?linkid=858594 „Çí„ÅîË¶ß„Åè„Å†„Åï„ÅÑ„ÄÇ</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 8226fd59601..66e70e94abd 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -1417,6 +1417,11 @@
         <target state="translated">Îã§Ïùå Ï°∞Í±¥Ïù¥ Î™®Îëê Ï∂©Ï°±ÎêòÎ©¥ StopOnFirstFailureÍ∞Ä Ìö®Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§. 1) ÏãúÏä§ÌÖúÏù¥ Îã§Ï§ë ÌîÑÎ°úÏÑ∏Ïä§ Î™®ÎìúÏóêÏÑú Ïã§Ìñâ Ï§ëÏûÖÎãàÎã§. 2) BuildInParallel ÏÜçÏÑ±Ïù¥ trueÏûÖÎãàÎã§. 3) RunEachTargetSeparately ÏÜçÏÑ±Ïù¥ falseÏûÖÎãàÎã§.</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="RarCouldntConnect">
+        <source>Couldn't connect to the RAR node, starting a new one.</source>
+        <target state="new">Couldn't connect to the RAR node, starting a new one.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: "{0}" ÌååÏùºÏóêÏÑú Ï§ÑÏùÑ ÏùΩÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 7eb22e26920..e622142e07a 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -1417,6 +1417,11 @@
         <target state="translated">Dzia≈Çanie funkcji StopOnFirstFailure nie przyniesie efektu, je≈õli bƒôdƒÖ spe≈Çnione wszystkie nastƒôpujƒÖce warunki: 1) System dzia≈Ça w trybie wieloprocesowym. 2) W≈Ça≈õciwo≈õƒá BuildInParallel ma warto≈õƒá true. 3) W≈Ça≈õciwo≈õƒá RunEachTargetSeparately ma warto≈õƒá false.</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="RarCouldntConnect">
+        <source>Couldn't connect to the RAR node, starting a new one.</source>
+        <target state="new">Couldn't connect to the RAR node, starting a new one.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: Nie mo≈ºna odczytaƒá wierszy z pliku ‚Äû{0}‚Äù. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index 5b593c3af62..41d31d7e125 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -1417,6 +1417,11 @@
         <target state="translated">StopOnFirstFailure n√£o ter√° efeito quando estas condi√ß√µes existirem: 1) O sistema estiver sendo executado no modo de processamento m√∫ltiplo 2) A propriedade BuildInParallel for true. 3) A propriedade RunEachTargetSeparately for false.</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="RarCouldntConnect">
+        <source>Couldn't connect to the RAR node, starting a new one.</source>
+        <target state="new">Couldn't connect to the RAR node, starting a new one.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: N√£o foi poss√≠vel ler linhas do arquivo "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 30b2198656b..2ce32973f25 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -1417,6 +1417,11 @@
         <target state="translated">StopOnFirstFailure –±—É–¥–µ—Ç –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è –ø—Ä–∏ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–º —Å–æ–±–ª—é–¥–µ–Ω–∏–∏ —Å–ª–µ–¥—É—é—â–∏—Ö —É—Å–ª–æ–≤–∏–π: 1) —Å–∏—Å—Ç–µ–º–∞ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –≤ —Ä–µ–∂–∏–º–µ —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –ø—Ä–æ—Ü–µ—Å—Å–∞–º–∏; 2) —Å–≤–æ–π—Å—Ç–≤–æ BuildInParallel –∏–º–µ–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ true; 3) —Å–≤–æ–π—Å—Ç–≤–æ RunEachTargetSeparately –∏–º–µ–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ false.</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="RarCouldntConnect">
+        <source>Couldn't connect to the RAR node, starting a new one.</source>
+        <target state="new">Couldn't connect to the RAR node, starting a new one.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å —Å—Ç—Ä–æ–∫–∏ –∏–∑ —Ñ–∞–π–ª–∞ "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 14c98e5c23c..88a70cb7279 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -1417,6 +1417,11 @@
         <target state="translated">≈ûu ko≈üullarƒ±n t√ºm√º doƒüru olduƒüunda StopOnFirstFailure etkisiz olur: 1) Sistem √ßoklu i≈ülem modunda √ßalƒ±≈üƒ±yorsa. 2) BuildInParallel √∂zelliƒüi true ise. 3) RunEachTargetSeparately √∂zelliƒüi false ise.</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="RarCouldntConnect">
+        <source>Couldn't connect to the RAR node, starting a new one.</source>
+        <target state="new">Couldn't connect to the RAR node, starting a new one.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: "{0}" dosyasƒ±ndaki satƒ±rlar okunamadƒ±. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index de2b681c56e..c9055d2694c 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -1417,6 +1417,11 @@
         <target state="translated">Â¶ÇÊûúÊª°Ë∂≥‰ª•‰∏ãÊâÄÊúâÊù°‰ª∂ÔºåStopOnFirstFailure Â∞Ü‰∏çËµ∑‰ªª‰Ωï‰ΩúÁî®: 1) Á≥ªÁªüÂú®Â§öËøõÁ®ãÊ®°Âºè‰∏ãËøêË°å„ÄÇ2) BuildInParallel Â±ûÊÄß‰∏∫ true„ÄÇ3) RunEachTargetSeparately Â±ûÊÄß‰∏∫ false„ÄÇ</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="RarCouldntConnect">
+        <source>Couldn't connect to the RAR node, starting a new one.</source>
+        <target state="new">Couldn't connect to the RAR node, starting a new one.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: Êú™ËÉΩ‰ªéÊñá‰ª∂‚Äú{0}‚ÄùËØªÂèñÂëΩ‰ª§Ë°å„ÄÇ{1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index e5178f7427d..71104cddb3e 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -1417,6 +1417,11 @@
         <target state="translated">Áï∂‰∏ãÂàóÊ¢ù‰ª∂ÂÖ®ÈÉ®ÊàêÁ´ãÊôÇÔºåStopOnFirstFailure Â∞áÊ≤íÊúâ‰ΩúÁî®: 1) Á≥ªÁµ±Ê≠£Âú®Â§öËôïÁêÜÁ®ãÂ∫èÊ®°Âºè‰∏≠Âü∑Ë°å 2) BuildInParallel Â±¨ÊÄßÁÇ∫ true„ÄÇ3) RunEachTargetSeparately Â±¨ÊÄßÁÇ∫ false„ÄÇ</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="RarCouldntConnect">
+        <source>Couldn't connect to the RAR node, starting a new one.</source>
+        <target state="new">Couldn't connect to the RAR node, starting a new one.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: ÁÑ°Ê≥ïÂæûÊ™îÊ°à "{0}" ËÆÄÂèñË°å„ÄÇ{1}</target>
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryTaskInfo.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryTaskInfo.cs
index c8e480c3f46..90237fd0920 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryTaskInfo.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryTaskInfo.cs
@@ -41,7 +41,7 @@ internal sealed class RoslynCodeTaskFactoryTaskInfo : IEquatable<RoslynCodeTaskF
         /// <inheritdoc cref="IEquatable{T}.Equals(T)"/>
         public bool Equals(RoslynCodeTaskFactoryTaskInfo other)
         {
-            if (ReferenceEquals(null, other))
+            if (other is null)
             {
                 return false;
             }
diff --git a/src/Tasks/SdkToolsPathUtility.cs b/src/Tasks/SdkToolsPathUtility.cs
index cf37031dcda..c9efaf7cde9 100644
--- a/src/Tasks/SdkToolsPathUtility.cs
+++ b/src/Tasks/SdkToolsPathUtility.cs
@@ -10,8 +10,8 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// This class will provide the ability for classes given an SdkToolsPath and their tool name to find that tool. 
-    /// The tool will be looked for either under the SDKToolPath passed into the task or as fallback to look for the toolname using the toolslocation helper. 
+    /// This class will provide the ability for classes given an SdkToolsPath and their tool name to find that tool.
+    /// The tool will be looked for either under the SDKToolPath passed into the task or as fallback to look for the toolname using the toolslocation helper.
     /// </summary>
     internal static class SdkToolsPathUtility
     {
@@ -38,10 +38,10 @@ internal static FileExists FileInfoExists
 
         /// <summary>
         /// This method will take a sdkToolsPath and a toolName and return the path to the tool if it is found and exists.
-        /// 
+        ///
         /// First the method will try and find the tool under the sdkToolsPath taking into account the current processor architecture
         /// If the tool could not be found the method will try and find the tool under the sdkToolsPath (which should point to the x86 sdk directory).
-        /// 
+        ///
         /// Finally if the method has not found the tool yet it will fallback and use the toolslocation helper method to try and find the tool.
         /// </summary>
         /// <returns>Path including the toolName of the tool if found, null if it is not found</returns>
@@ -54,25 +54,15 @@ internal static string GeneratePathToTool(FileExists fileExists, string currentA
                 string processorSpecificToolDirectory;
                 try
                 {
-                    switch (currentArchitecture)
+                    processorSpecificToolDirectory = currentArchitecture switch
                     {
                         // There may not be an arm directory so we will fall back to the x86 tool location
                         // but if there is then we should try and use it.
-                        case ProcessorArchitecture.ARM:
-                            processorSpecificToolDirectory = Path.Combine(sdkToolsPath, "arm");
-                            break;
-                        case ProcessorArchitecture.AMD64:
-                            processorSpecificToolDirectory = Path.Combine(sdkToolsPath, "x64");
-                            break;
-                        case ProcessorArchitecture.IA64:
-                            processorSpecificToolDirectory = Path.Combine(sdkToolsPath, "ia64");
-                            break;
-                        case ProcessorArchitecture.X86:
-                        default:
-                            processorSpecificToolDirectory = sdkToolsPath;
-                            break;
-                    }
-
+                        ProcessorArchitecture.ARM => Path.Combine(sdkToolsPath, "arm"),
+                        ProcessorArchitecture.AMD64 => Path.Combine(sdkToolsPath, "x64"),
+                        ProcessorArchitecture.IA64 => Path.Combine(sdkToolsPath, "ia64"),
+                        _ => sdkToolsPath,
+                    };
                     pathToTool = Path.Combine(processorSpecificToolDirectory, toolName);
 
                     if (!fileExists(pathToTool))
@@ -120,7 +110,7 @@ internal static string GeneratePathToTool(FileExists fileExists, string currentA
             // Fall back and see if we can find it with the toolsLocation helper methods. This is not optimal because 
             // the location they are looking at is based on when the Microsoft.Build.Utilities.dll was compiled
             // but it is better than nothing.
-            if (null == pathToTool || !fileExists(pathToTool))
+            if (pathToTool == null || !fileExists(pathToTool))
             {
                 pathToTool = FindSDKToolUsingToolsLocationHelper(toolName);
 
diff --git a/src/Tasks/StrongNameUtils.cs b/src/Tasks/StrongNameUtils.cs
index d14ea996ebd..4abdc57311a 100644
--- a/src/Tasks/StrongNameUtils.cs
+++ b/src/Tasks/StrongNameUtils.cs
@@ -233,7 +233,6 @@ internal static StrongNameLevel GetAssemblyStrongNameLevel(string assemblyPath)
                 if (fileHandle != NativeMethods.InvalidIntPtr)
                 {
                     NativeMethods.CloseHandle(fileHandle);
-                    fileHandle = NativeMethods.InvalidIntPtr;
                 }
             }
 
diff --git a/src/Tasks/System.Design.cs b/src/Tasks/System.Design.cs
index ff9adc9c4b8..8ff555870e0 100644
--- a/src/Tasks/System.Design.cs
+++ b/src/Tasks/System.Design.cs
@@ -9,7 +9,6 @@
 using System.Threading;
 using System.Security.Permissions;
 
-
 using System.ComponentModel;
 
 namespace Microsoft.Build.Tasks
@@ -62,13 +61,11 @@ protected override string GetLocalizedString(string value)
         }
     }
 
-
     /// <summary>
     ///    AutoGenerated resource class. Usage:
     ///
     ///        string s = SR.GetString(SR.MyIdenfitier);
     /// </summary>
-
     internal sealed class SR
     {
         internal const string ClassDocComment = "ClassDocComment";
@@ -135,12 +132,12 @@ public static string GetString(string name, params object[] args)
                 return null;
             string res = sys._resources.GetString(name, SR.Culture);
 
-            if (args != null && args.Length > 0)
+            if (args?.Length > 0)
             {
                 for (int i = 0; i < args.Length; i++)
                 {
                     String value = args[i] as String;
-                    if (value != null && value.Length > 1024)
+                    if (value?.Length > 1024)
                     {
                         args[i] = value.Substring(0, 1024 - 3) + "...";
                     }
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index 88421155661..9c98656c05c 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -38,7 +38,6 @@ internal sealed class SystemState
         /// </summary>
         private Hashtable instanceLocalFileStateCache = new Hashtable(StringComparer.OrdinalIgnoreCase);
 
-
         /// <summary>
         /// LastModified information is purely instance-local. It doesn't make sense to
         /// cache this for long periods of time since there's no way (without actually 
@@ -53,7 +52,6 @@ internal sealed class SystemState
         /// </summary>
         private Dictionary<string, bool> instanceLocalDirectoryExists = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
 
-
         /// <summary>
         /// GetDirectories information is also purely instance-local. This information
         /// is only considered good for the lifetime of the task (or whatever) that owns 
@@ -404,8 +402,7 @@ public SystemState()
         /// This is used to optimize IO in the case of files requested from one 
         /// of the FX folders.
         /// </summary>
-        /// <param name="providedFrameworkPaths"></param>
-        /// <param name="installedAssemblyTables"></param>
+        /// <param name="installedAssemblyTableInfos"></param>
         internal void SetInstalledAssemblyInformation
         (
             AssemblyTableInfo[] installedAssemblyTableInfos
@@ -507,7 +504,6 @@ private FileState GetFileState(string path)
             upToDateLocalFileStateCache.TryGetValue(path, out FileState state);
             if (state == null)
             {   // We haven't seen this file this ResolveAssemblyReference session
-
                 state = ComputeFileStateFromCachesAndDisk(path);
                 upToDateLocalFileStateCache[path] = state;
             }
diff --git a/src/Tasks/TlbImp.cs b/src/Tasks/TlbImp.cs
index dbcd83aae6f..6269f060134 100644
--- a/src/Tasks/TlbImp.cs
+++ b/src/Tasks/TlbImp.cs
@@ -12,7 +12,7 @@ public sealed partial class ResolveComReference
     {
         /// <summary>
         /// Passed to the "Transform" property on the TlbImp task to indicate
-        /// what transforms, if any, to apply to the type library during 
+        /// what transforms, if any, to apply to the type library during
         /// assembly generation
         /// </summary>
         internal enum TlbImpTransformFlags
@@ -35,7 +35,7 @@ internal enum TlbImpTransformFlags
         }
 
         /// <summary>
-        /// Defines the "TlbImp" MSBuild task, which enables using TlbImp.exe 
+        /// Defines the "TlbImp" MSBuild task, which enables using TlbImp.exe
         /// to generate assemblies from type libraries.
         /// </summary>
         internal class TlbImp : AxTlbBaseTask
@@ -237,7 +237,7 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens
                 commandLine.AppendFileNameIfNotNull(TypeLibName);
 
                 // options
-                commandLine.AppendSwitchIfNotNull("/asmversion:", (AssemblyVersion != null) ? AssemblyVersion.ToString() : null);
+                commandLine.AppendSwitchIfNotNull("/asmversion:", AssemblyVersion?.ToString());
                 commandLine.AppendSwitchIfNotNull("/namespace:", AssemblyNamespace);
                 commandLine.AppendSwitchIfNotNull("/machine:", Machine);
                 commandLine.AppendWhenTrue("/noclassmembers", Bag, "PreventClassMembers");
@@ -296,46 +296,38 @@ private TlbImpTransformFlags GetTlbImpTransformFlagsParameterWithDefault(string
             }
 
             /// <summary>
-            /// Verifies that an allowed combination of TlbImpTransformFlags has been 
+            /// Verifies that an allowed combination of TlbImpTransformFlags has been
             /// passed to the Transform property.
             /// </summary>
             /// <returns>True if Transform is valid and false otherwise</returns>
             private bool ValidateTransformFlags()
             {
                 // Any flag on its own is fine ...
-                switch (Transform)
+                return Transform switch
                 {
-                    case TlbImpTransformFlags.None:
-                        return true;
-                    case TlbImpTransformFlags.SerializableValueClasses:
-                        return true;
-                    case TlbImpTransformFlags.TransformDispRetVals:
-                        return true;
-                }
-
-                // ... But any and all other combinations of flags are disallowed.
-                return false;
+                    TlbImpTransformFlags.None => true,
+                    TlbImpTransformFlags.SerializableValueClasses => true,
+                    TlbImpTransformFlags.TransformDispRetVals => true,
+                    // ... But any and all other combinations of flags are disallowed.
+                    _ => false,
+                };
             }
 
             /// <summary>
-            /// Converts a given flag to the equivalent parameter passed to the /transform: 
+            /// Converts a given flag to the equivalent parameter passed to the /transform:
             /// option of tlbimp.exe
             /// </summary>
             /// <param name="flags">The TlbImpTransformFlags being converted</param>
             /// <returns>A string that can be passed to /transform: on the command line</returns>
             private static string ConvertTransformFlagsToCommandLineCommand(TlbImpTransformFlags flags)
             {
-                switch (flags)
+                return flags switch
                 {
-                    case TlbImpTransformFlags.None:
-                        return null;
-                    case TlbImpTransformFlags.SerializableValueClasses:
-                        return "SerializableValueClasses";
-                    case TlbImpTransformFlags.TransformDispRetVals:
-                        return "DispRet";
-                }
-
-                return null;
+                    TlbImpTransformFlags.None => null,
+                    TlbImpTransformFlags.SerializableValueClasses => "SerializableValueClasses",
+                    TlbImpTransformFlags.TransformDispRetVals => "DispRet",
+                    _ => null,
+                };
             }
 
             #endregion // ToolTask Members
diff --git a/src/Tasks/TlbReference.cs b/src/Tasks/TlbReference.cs
index 5cf76a06636..c6cc0e606b9 100644
--- a/src/Tasks/TlbReference.cs
+++ b/src/Tasks/TlbReference.cs
@@ -34,16 +34,23 @@ internal class TlbReference : AxTlbBaseReference, ITypeLibImporterNotifySink
         /// internal constructor
         /// </summary>
         /// <param name="taskLoggingHelper">task logger instance used for logging</param>
+        /// <param name="silent">true if this task should log only errors, no warnings or messages; false otherwise</param>
         /// <param name="resolverCallback">callback interface for resolving dependent COM refs/NET assemblies</param>
+        /// <param name="referenceFiles">List of referenc files</param>
         /// <param name="referenceInfo">cached reference information (typelib pointer, original task item, typelib name etc.)</param>
         /// <param name="itemName">reference name (for better logging experience)</param>
         /// <param name="outputDirectory">directory we should write the wrapper to</param>
+        /// <param name="hasTemporaryWrapper">Whether it has a temporary wrapper</param>
         /// <param name="delaySign">delay sign wrappers?</param>
         /// <param name="keyFile">file containing public/private keys</param>
         /// <param name="keyContainer">container name for public/private keys</param>
+        /// <param name="noClassMembers">Whether it has no class members</param>
+        /// <param name="targetProcessorArchitecture">Architecture to seek.</param>
+        /// <param name="includeTypeLibVersionInName">True if the interop name should include the typelib's version</param>
         /// <param name="executeAsTool">True if GenerateWrapper() should generate the wrapper out-of-proc using tlbimp.exe</param>
         /// <param name="sdkToolsPath">Path to the SDK tools directory where tlbimp.exe can be found</param>
         /// <param name="buildEngine">BuildEngine of parent task; needed for logging purposes when generating wrapper out-of-proc</param>
+        /// <param name="environmentVariables">Array of equals-separated pairs of environment variables that should be passed to the spawned executable, in addition to (or selectively overriding) the regular environment block.</param>
         internal TlbReference(TaskLoggingHelper taskLoggingHelper, bool silent, IComReferenceResolver resolverCallback, IEnumerable<string> referenceFiles, ComReferenceInfo referenceInfo, string itemName, string outputDirectory, bool hasTemporaryWrapper,
             bool delaySign, string keyFile, string keyContainer, bool noClassMembers, string targetProcessorArchitecture, bool includeTypeLibVersionInName, bool executeAsTool, string sdkToolsPath, IBuildEngine buildEngine, string[] environmentVariables)
             : base(taskLoggingHelper, silent, resolverCallback, referenceInfo, itemName, outputDirectory, delaySign, keyFile, keyContainer, includeTypeLibVersionInName, executeAsTool, sdkToolsPath, buildEngine, environmentVariables)
@@ -171,7 +178,7 @@ internal bool GenerateWrapper(out ComReferenceWrapperInfo wrapperInfo)
                     // that the set of references will also contain the file that is meant to be written here (when reference resolution
                     // found the file in the output folder). We need to filter out this case.
                     var fullPathToOutput = Path.GetFullPath(wrapperPath); // Current directory is the directory of the project file.
-                    tlbImp.ReferenceFiles = _referenceFiles.Where(rf => String.Compare(fullPathToOutput, rf, StringComparison.OrdinalIgnoreCase) != 0).ToArray();
+                    tlbImp.ReferenceFiles = _referenceFiles.Where(rf => !String.Equals(fullPathToOutput, rf, StringComparison.OrdinalIgnoreCase)).ToArray();
                 }
 
                 switch (_targetProcessorArchitecture)
diff --git a/src/Tasks/ToolTaskExtension.cs b/src/Tasks/ToolTaskExtension.cs
index d9c1238bb32..8969d15bb55 100644
--- a/src/Tasks/ToolTaskExtension.cs
+++ b/src/Tasks/ToolTaskExtension.cs
@@ -49,7 +49,7 @@ internal ToolTaskExtension() :
         /// <summary>
         /// Whether this ToolTaskExtension has logged any errors
         /// </summary>
-        protected override bool HasLoggedErrors => (Log.HasLoggedErrors || base.HasLoggedErrors);
+        protected override bool HasLoggedErrors => Log.HasLoggedErrors || base.HasLoggedErrors;
 
         /// <summary>
         /// Gets the collection of parameters used by the derived task class.
@@ -91,7 +91,6 @@ protected internal int GetIntParameterWithDefault(string parameterName, int defa
         /// Will only be called if the task returned a non empty string from GetResponseFileCommands
         /// Called after ValidateParameters, SkipTaskExecution and GetResponseFileCommands
         /// </summary>
-        /// <param name="responseFilePath">full path to the temporarily created response file</param>
         /// <returns></returns>
         protected override string GenerateResponseFileCommands()
         {
diff --git a/src/Tasks/UnregisterAssembly.cs b/src/Tasks/UnregisterAssembly.cs
index 928fb7aecce..cbcde5d8ef8 100644
--- a/src/Tasks/UnregisterAssembly.cs
+++ b/src/Tasks/UnregisterAssembly.cs
@@ -78,7 +78,7 @@ public override bool Execute()
                 for (int i = 0; i < Assemblies.Length; i++)
                 {
                     // if the type lib path is not supplied, generate default one
-                    if (TypeLibFiles != null && TypeLibFiles[i] != null && TypeLibFiles[i].ItemSpec.Length > 0)
+                    if (TypeLibFiles?[i]?.ItemSpec.Length > 0)
                     {
                         cacheFile.AddEntry(Assemblies[i].ItemSpec, TypeLibFiles[i].ItemSpec);
                     }
@@ -142,7 +142,7 @@ public override bool Execute()
         /// </summary>
         private bool Unregister(string assemblyPath, string typeLibPath)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(typeLibPath, "typeLibPath");
+            ErrorUtilities.VerifyThrowArgumentNull(typeLibPath, nameof(typeLibPath));
 
             Log.LogMessageFromResources(MessageImportance.Low, "UnregisterAssembly.UnregisteringAssembly", assemblyPath);
 
diff --git a/src/Tasks/Warning.cs b/src/Tasks/Warning.cs
index a1cba5bb65b..06db03f94ce 100644
--- a/src/Tasks/Warning.cs
+++ b/src/Tasks/Warning.cs
@@ -21,7 +21,7 @@ public sealed class Warning : TaskExtension
 
         /// <summary>
         /// Relevant file if any.
-        /// If none is provided, the file containing the Warning 
+        /// If none is provided, the file containing the Warning
         /// task will be used.
         /// </summary>
         public string File { get; set; }
@@ -31,13 +31,18 @@ public sealed class Warning : TaskExtension
         /// </summary>
         public string HelpKeyword { get; set; }
 
+        /// <summary>
+        /// A link pointing to more information about the warning
+        /// </summary>
+        public string HelpLink { get; set; }
+
         /// <summary>
         /// Main task method
         /// </summary>
         /// <returns></returns>
         public override bool Execute()
         {
-            Log.LogWarning(null, Code, HelpKeyword, File, 0, 0, 0, 0, Text ?? TaskResources.GetString("ErrorAndWarning.EmptyMessage"));
+            Log.LogWarning(null, Code, HelpKeyword, HelpLink, File, 0, 0, 0, 0, Text ?? TaskResources.GetString("ErrorAndWarning.EmptyMessage"));
 
             return true;
         }
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index acaa9cb6dd3..71be097965b 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -102,7 +102,7 @@ public override bool Execute()
                     OutputFile = new TaskItem(Path.Combine(OutputDirectory.ItemSpec, OutputFile.ItemSpec));
                 }
 
-                OutputFile = OutputFile ?? new TaskItem(FileUtilities.GetTemporaryFile(OutputDirectory.ItemSpec, extension));
+                OutputFile ??= new TaskItem(FileUtilities.GetTemporaryFile(OutputDirectory.ItemSpec, extension));
 
                 File.WriteAllText(OutputFile.ItemSpec, code); // Overwrites file if it already exists (and can be overwritten)
             }
diff --git a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
index 2ca1d976b8d..41d74bb1934 100644
--- a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
@@ -327,8 +327,8 @@ internal bool HasSwitch(string propertyName)
         }
 
         /// <summary>
-        /// Returns true if the property exists (regardless of whether it is 
-        /// set or not) and false otherwise. 
+        /// Returns true if the property exists (regardless of whether it is
+        /// set or not) and false otherwise.
         /// </summary>
         internal bool PropertyExists(string propertyName)
         {
@@ -526,10 +526,10 @@ private string GatherArguments(string parentSwitch, ICollection<Tuple<string, bo
                     {
                         if (!String.IsNullOrEmpty(retVal))
                         {
-                            retVal = retVal + separator;
+                            retVal += separator;
                         }
 
-                        retVal = retVal + argSwitch.Value;
+                        retVal += argSwitch.Value;
                     }
                     else
                     {
diff --git a/src/Tasks/XamlTaskFactory/RelationsParser.cs b/src/Tasks/XamlTaskFactory/RelationsParser.cs
index 50f1c3872cd..aaf6072e5a0 100644
--- a/src/Tasks/XamlTaskFactory/RelationsParser.cs
+++ b/src/Tasks/XamlTaskFactory/RelationsParser.cs
@@ -109,7 +109,7 @@ internal class RelationsParser
         private const string switchAttribute = "SWITCH";
 
         #endregion
-        
+
         #region Properties
 
         /// <summary>
@@ -474,7 +474,6 @@ private static bool ParseSwitch(XmlNode node, Dictionary<string, SwitchRelations
                             }
                         }
                     }
-
                     else if (String.Equals(child.Name, includedPlatformType, StringComparison.OrdinalIgnoreCase))
                     {
                         foreach (XmlAttribute attrib in child.Attributes)
@@ -530,7 +529,7 @@ private static bool ParseSwitch(XmlNode node, Dictionary<string, SwitchRelations
         }
 
         /// <summary>
-        /// Gets all the attributes assigned in the xml file for this parameter or all of the nested switches for 
+        /// Gets all the attributes assigned in the xml file for this parameter or all of the nested switches for
         /// this parameter group
         /// </summary>
         private static SwitchRelations ObtainAttributes(XmlNode node, SwitchRelations switchGroup)
@@ -573,7 +572,7 @@ private void LogError(string messageResourceName, params object[] messageArgs)
         }
 
         /// <summary>
-        /// An XML document can have many root nodes, but usually we want the single root 
+        /// An XML document can have many root nodes, but usually we want the single root
         /// element. Callers can test each root node in turn with this method, until it returns
         /// true.
         /// </summary>
@@ -583,13 +582,13 @@ private static bool IsXmlRootElement(XmlNode node)
         {
             // "A Document node can have the following child node types: XmlDeclaration,
             // Element (maximum of one), ProcessingInstruction, Comment, and DocumentType."
-            return (
+            return
                    (node.NodeType != XmlNodeType.Comment) &&
                    (node.NodeType != XmlNodeType.Whitespace) &&
                    (node.NodeType != XmlNodeType.XmlDeclaration) &&
                    (node.NodeType != XmlNodeType.ProcessingInstruction) &&
                    (node.NodeType != XmlNodeType.DocumentType)
-                   );
+                   ;
         }
     }
 }
diff --git a/src/Tasks/XamlTaskFactory/TaskGenerator.cs b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
index ad88b5c4039..b0aeb1c7198 100644
--- a/src/Tasks/XamlTaskFactory/TaskGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
@@ -420,7 +420,7 @@ internal CodeCompileUnit GenerateCode()
         }
 
         /// <summary>
-        /// Generates a method called "AddDefaultsToActiveSwitchList" that takes all of the properties that have 
+        /// Generates a method called "AddDefaultsToActiveSwitchList" that takes all of the properties that have
         /// default values and adds them to the active switch list
         /// </summary>
         private void GenerateDefaultSetProperties(CodeTypeDeclaration taskClass)
@@ -469,7 +469,7 @@ private void GenerateDefaultSetProperties(CodeTypeDeclaration taskClass)
         }
 
         /// <summary>
-        /// Generates a method called "AddFallbacksToActiveSwitchList" that takes all of the properties that 
+        /// Generates a method called "AddFallbacksToActiveSwitchList" that takes all of the properties that
         /// are not set but have fallbacks and adds the fallbacks to the active list if they are set.
         /// </summary>
         private void GenerateFallbacks(CodeTypeDeclaration taskClass)
@@ -992,7 +992,7 @@ private bool ContainsCurrentPlatform(string SwitchValue)
         }
 
         /// <summary>
-        /// This method generates overrides array 
+        /// This method generates overrides array
         /// </summary>
         private void GenerateOverrides(Property property, CodeMemberProperty propertyName)
         {
@@ -1171,7 +1171,7 @@ private void GenerateRelations(CodeTypeDeclaration taskClass)
                     if (switchRelations.Value.Requires.Count > 0)
                     {
                         var checkRequired = new CodeConditionStatement { Condition = null };
-                        
+
                         foreach (string required in switchRelations.Value.Requires)
                         {
                             if (checkRequired.Condition != null)
diff --git a/src/Tasks/XamlTaskFactory/TaskParser.cs b/src/Tasks/XamlTaskFactory/TaskParser.cs
index e99eb57997d..ad7d411177f 100644
--- a/src/Tasks/XamlTaskFactory/TaskParser.cs
+++ b/src/Tasks/XamlTaskFactory/TaskParser.cs
@@ -177,7 +177,7 @@ internal bool ParseXamlDocument(TextReader reader, string desiredRule)
             ErrorUtilities.VerifyThrowArgumentLength(desiredRule, nameof(desiredRule));
 
             object rootObject = XamlServices.Load(reader);
-            if (null != rootObject)
+            if (rootObject != null)
             {
                 XamlTypes.ProjectSchemaDefinitions schemas = rootObject as XamlTypes.ProjectSchemaDefinitions;
                 if (schemas != null)
@@ -387,7 +387,7 @@ private bool ParseParameter(XamlTypes.BaseProperty baseProperty, LinkedList<Prop
                 propertyToAdd.Arguments.Add(arg);
             }
 
-            if (argumentDependencyLookup != null && !argumentDependencyLookup.ContainsKey(propertyToAdd.Name))
+            if (argumentDependencyLookup?.ContainsKey(propertyToAdd.Name) == false)
             {
                 argumentDependencyLookup.Add(propertyToAdd.Name, propertyToAdd);
             }
@@ -473,8 +473,8 @@ private static Property ObtainAttributes(XamlTypes.BaseProperty baseProperty, Pr
 
             if (intProperty != null)
             {
-                parameter.Max = intProperty.MaxValue != null ? intProperty.MaxValue.ToString() : null;
-                parameter.Min = intProperty.MinValue != null ? intProperty.MinValue.ToString() : null;
+                parameter.Max = intProperty.MaxValue?.ToString();
+                parameter.Min = intProperty.MinValue?.ToString();
             }
 
             if (boolProperty != null)
diff --git a/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs b/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
index bbd77b0b8a2..a6483ae584e 100644
--- a/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
+++ b/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
@@ -234,7 +234,7 @@ internal void ValidateOverrides()
             {
                 foreach (KeyValuePair<string, string> overridePair in overriddenSwitch.Value.Overrides)
                 {
-                    if (String.Equals(overridePair.Key, (overriddenSwitch.Value.Type == CommandLineToolSwitchType.Boolean && overriddenSwitch.Value.BooleanValue == false) ? overriddenSwitch.Value.ReverseSwitchValue.TrimStart('/') : overriddenSwitch.Value.SwitchValue.TrimStart('/'), StringComparison.OrdinalIgnoreCase))
+                    if (String.Equals(overridePair.Key, (overriddenSwitch.Value.Type == CommandLineToolSwitchType.Boolean && !overriddenSwitch.Value.BooleanValue) ? overriddenSwitch.Value.ReverseSwitchValue.TrimStart('/') : overriddenSwitch.Value.SwitchValue.TrimStart('/'), StringComparison.OrdinalIgnoreCase))
                     {
                         foreach (KeyValuePair<string, CommandLineToolSwitch> overrideTarget in ActiveToolSwitches)
                         {
@@ -245,7 +245,7 @@ internal void ValidateOverrides()
                                     overriddenSwitches.Add(overrideTarget.Key);
                                     break;
                                 }
-                                else if ((overrideTarget.Value.Type == CommandLineToolSwitchType.Boolean) && (overrideTarget.Value.BooleanValue == false) && String.Equals(overrideTarget.Value.ReverseSwitchValue.TrimStart('/'), overridePair.Value, StringComparison.OrdinalIgnoreCase))
+                                else if ((overrideTarget.Value.Type == CommandLineToolSwitchType.Boolean) && (!overrideTarget.Value.BooleanValue) && String.Equals(overrideTarget.Value.ReverseSwitchValue.TrimStart('/'), overridePair.Value, StringComparison.OrdinalIgnoreCase))
                                 {
                                     overriddenSwitches.Add(overrideTarget.Key);
                                     break;
diff --git a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
index 7466911e233..679d22d00a1 100644
--- a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
+++ b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
@@ -83,8 +83,8 @@ public Type TaskType
         /// </summary>
         public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> taskParameters, string taskElementContents, IBuildEngine taskFactoryLoggingHost)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(taskName, "taskName");
-            ErrorUtilities.VerifyThrowArgumentNull(taskParameters, "taskParameters");
+            ErrorUtilities.VerifyThrowArgumentNull(taskName, nameof(taskName));
+            ErrorUtilities.VerifyThrowArgumentNull(taskParameters, nameof(taskParameters));
 
             var log = new TaskLoggingHelper(taskFactoryLoggingHost, taskName)
             {
@@ -176,7 +176,7 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> ta
 
                     if (debugXamlTask)
                     {
-                        errorList.AppendLine(String.Format(Thread.CurrentThread.CurrentUICulture, "({0},{1}) {2}", error.Line, error.Column, error.ErrorText));
+                        errorList.AppendFormat(Thread.CurrentThread.CurrentUICulture, "({0},{1}) {2}", error.Line, error.Column, error.ErrorText).AppendLine();
                     }
                     else
                     {
@@ -211,7 +211,7 @@ public ITask CreateTask(IBuildEngine taskFactoryLoggingHost)
         /// </remarks>
         public void CleanupTask(ITask task)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(task, "task");
+            ErrorUtilities.VerifyThrowArgumentNull(task, nameof(task));
         }
 
         /// <summary>
diff --git a/src/Tasks/XmlPoke.cs b/src/Tasks/XmlPoke.cs
index e2d3876868a..8f42cfe910c 100644
--- a/src/Tasks/XmlPoke.cs
+++ b/src/Tasks/XmlPoke.cs
@@ -170,11 +170,13 @@ public override bool Execute()
             }
 
             XPathNodeIterator iter = nav.Select(expr);
+            int count = 0;
 
             while (iter.MoveNext())
             {
                 try
                 {
+                    count++;
                     iter.Current.InnerXml = _value.ItemSpec;
                     Log.LogMessageFromResources(MessageImportance.Low, "XmlPoke.Replaced", iter.Current.Name, _value.ItemSpec);
                 }
@@ -190,9 +192,9 @@ public override bool Execute()
                 }
             }
 
-            Log.LogMessageFromResources(MessageImportance.Normal, "XmlPoke.Count", iter.Count);
+            Log.LogMessageFromResources(MessageImportance.Normal, "XmlPoke.Count", count);
 
-            if (iter.Count > 0)
+            if (count > 0)
             {
 #if RUNTIME_TYPE_NETCORE
                 using (Stream stream = File.Create(_xmlInputPath.ItemSpec))
diff --git a/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs b/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
index 80543f08545..562468ff8ec 100644
--- a/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
+++ b/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
@@ -467,7 +467,6 @@ public void TestVerifyThrowElse()
             }
            );
         }
-
         
     }
 
diff --git a/src/Utilities.UnitTests/MuxLogger_Tests.cs b/src/Utilities.UnitTests/MuxLogger_Tests.cs
index f4bdda15924..21fcfb9f78c 100644
--- a/src/Utilities.UnitTests/MuxLogger_Tests.cs
+++ b/src/Utilities.UnitTests/MuxLogger_Tests.cs
@@ -313,14 +313,12 @@ public void RegisteringLoggerDuringBuildThrowsException()
 
                     // This call should throw an InvalidOperationException
                     muxLogger.RegisterLogger(submission.SubmissionId, mockLogger);
-
                 }
                 finally
                 {
                     buildManager.EndBuild();
                 }
             });
-
         }
 
         /// <summary>
diff --git a/src/Utilities.UnitTests/PlatformManifest_Tests.cs b/src/Utilities.UnitTests/PlatformManifest_Tests.cs
index 8e0e38be62d..79522881a6c 100644
--- a/src/Utilities.UnitTests/PlatformManifest_Tests.cs
+++ b/src/Utilities.UnitTests/PlatformManifest_Tests.cs
@@ -54,7 +54,7 @@ public void EmptyManifestLocation()
         }
 
         /// <summary>
-        /// Should get a read error when the manifest location is valid but doesn't have a 
+        /// Should get a read error when the manifest location is valid but doesn't have a
         /// file named Platform.xml
         /// </summary>
         [Fact]
@@ -80,7 +80,7 @@ public void ManifestLocationHasNoPlatformXml()
         }
 
         /// <summary>
-        /// Should get a read error when trying to read an invalid manifest file. 
+        /// Should get a read error when trying to read an invalid manifest file.
         /// </summary>
         [Fact]
         public void InvalidManifest()
@@ -94,7 +94,7 @@ public void InvalidManifest()
         }
 
         /// <summary>
-        /// Verify that a simple PlatformManifest can be successfully constructed. 
+        /// Verify that a simple PlatformManifest can be successfully constructed.
         /// </summary>
         [Fact]
         public void SimpleValidManifest()
@@ -114,8 +114,8 @@ public void SimpleValidManifest()
         }
 
         /// <summary>
-        /// Verify that a simple PlatformManifest can be successfully constructed, even if it's missing 
-        /// some fields. 
+        /// Verify that a simple PlatformManifest can be successfully constructed, even if it's missing
+        /// some fields.
         /// </summary>
         [Fact]
         public void SimpleValidManifestWithMissingFriendlyName()
@@ -135,8 +135,8 @@ public void SimpleValidManifestWithMissingFriendlyName()
         }
 
         /// <summary>
-        /// Platform manifest with a dependent platform missing some information. 
-        /// NOTE: probably ought to be an error. 
+        /// Platform manifest with a dependent platform missing some information.
+        /// NOTE: probably ought to be an error.
         /// </summary>
         [Fact]
         public void DependentPlatformMissingName()
@@ -188,8 +188,8 @@ public void MultipleDependentPlatforms()
         }
 
         /// <summary>
-        /// Platform manifest with a contract missing some information. 
-        /// NOTE: technically probably ought to be an error. 
+        /// Platform manifest with a contract missing some information.
+        /// NOTE: technically probably ought to be an error.
         /// </summary>
         [Fact]
         public void ContractMissingVersion()
@@ -218,7 +218,7 @@ public void ContractMissingVersion()
         }
 
         /// <summary>
-        /// Verify a platform manifest with API contracts. 
+        /// Verify a platform manifest with API contracts.
         /// </summary>
         [Fact]
         public void MultipleContracts()
@@ -301,8 +301,8 @@ public void VersionedContentTrueFlagReturnsTrue()
         }
 
         /// <summary>
-        /// Wrapper around PlatformManifest that creates one with the specified content in 
-        /// the temporary directory and deletes it on disposal. 
+        /// Wrapper around PlatformManifest that creates one with the specified content in
+        /// the temporary directory and deletes it on disposal.
         /// </summary>
         private sealed class TemporaryPlatformManifest : IDisposable
         {
diff --git a/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs b/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
index 77964a82a4e..990979c8840 100644
--- a/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
+++ b/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
@@ -14,24 +14,15 @@ public class ProcessorArchitectureTests
     {
         internal static string ProcessorArchitectureIntToString()
         {
-            switch (NativeMethodsShared.ProcessorArchitecture)
+            return NativeMethodsShared.ProcessorArchitecture switch
             {
-                case NativeMethodsShared.ProcessorArchitectures.X86:
-                    return ProcessorArchitecture.X86;
-
-                case NativeMethodsShared.ProcessorArchitectures.X64:
-                    return ProcessorArchitecture.AMD64;
-
-                case NativeMethodsShared.ProcessorArchitectures.IA64:
-                    return ProcessorArchitecture.IA64;
-
-                case NativeMethodsShared.ProcessorArchitectures.ARM:
-                    return ProcessorArchitecture.ARM;
-
+                NativeMethodsShared.ProcessorArchitectures.X86 => ProcessorArchitecture.X86,
+                NativeMethodsShared.ProcessorArchitectures.X64 => ProcessorArchitecture.AMD64,
+                NativeMethodsShared.ProcessorArchitectures.IA64 => ProcessorArchitecture.IA64,
+                NativeMethodsShared.ProcessorArchitectures.ARM => ProcessorArchitecture.ARM,
                 // unknown architecture? return null
-                default:
-                    return null;
-            }
+                _ => null,
+            };
         }
 
         [Fact]
@@ -73,7 +64,7 @@ public void ValidateConvertDotNetFrameworkArchitectureToProcessorArchitecture()
                     procArchitecture = ToolLocationHelper.ConvertDotNetFrameworkArchitectureToProcessorArchitecture(Utilities.DotNetFrameworkArchitecture.Bitness64);
 
                     //We should also allow NULL if the machine is true x86 only.
-                    bool isValidResult = procArchitecture == null || procArchitecture.Equals(ProcessorArchitecture.AMD64) || procArchitecture.Equals(ProcessorArchitecture.IA64);
+                    bool isValidResult = procArchitecture?.Equals(ProcessorArchitecture.AMD64) != false || procArchitecture.Equals(ProcessorArchitecture.IA64);
 
                     isValidResult.ShouldBeTrue();
                     break;
diff --git a/src/Utilities.UnitTests/TaskItem_Tests.cs b/src/Utilities.UnitTests/TaskItem_Tests.cs
index 124ef58cb6b..04e90914861 100644
--- a/src/Utilities.UnitTests/TaskItem_Tests.cs
+++ b/src/Utilities.UnitTests/TaskItem_Tests.cs
@@ -180,7 +180,6 @@ public void CheckMetadataCount()
             t.MetadataCount.ShouldBe(FileUtilities.ItemSpecModifiers.All.Length + 1);
         }
 
-
         [Fact]
         public void NonexistentRequestFullPath()
         {
@@ -380,13 +379,22 @@ public void RemoteTaskItem()
                     itemsInThisAppDomain[i].ItemSpec.ShouldBe(creator.CreatedTaskItems[i].ItemSpec);
                     itemsInThisAppDomain[i].MetadataCount.ShouldBe(creator.CreatedTaskItems[i].MetadataCount + 1);
 
+                    Dictionary<string, string> creatorMetadata = new Dictionary<string, string>(creator.CreatedTaskItems[i].MetadataCount);
                     foreach (string metadatum in creator.CreatedTaskItems[i].MetadataNames)
+                    {
+                        creatorMetadata[metadatum] = creator.CreatedTaskItems[i].GetMetadata(metadatum);
+                    }
+
+                    Dictionary<string, string> metadataInThisAppDomain = new Dictionary<string, string>(itemsInThisAppDomain[i].MetadataCount);
+                    foreach (string metadatum in itemsInThisAppDomain[i].MetadataNames)
                     {
                         if (!string.Equals("OriginalItemSpec", metadatum))
                         {
-                            itemsInThisAppDomain[i].GetMetadata(metadatum).ShouldBe(creator.CreatedTaskItems[i].GetMetadata(metadatum));
+                            metadataInThisAppDomain[metadatum] = itemsInThisAppDomain[i].GetMetadata(metadatum);
                         }
                     }
+
+                    metadataInThisAppDomain.ShouldBe(creatorMetadata, ignoreOrder: true);
                 }
             }
             finally
@@ -420,7 +428,7 @@ public ITaskItem[] CreatedTaskItems
             /// </summary>
             public void Run(string[] includes, IDictionary<string, string> metadataToAdd)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(includes, "includes");
+                ErrorUtilities.VerifyThrowArgumentNull(includes, nameof(includes));
 
                 CreatedTaskItems = new TaskItem[includes.Length];
 
diff --git a/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs b/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
index 2be4f4b4d2e..bf5eeb2a250 100644
--- a/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
+++ b/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
@@ -25,61 +25,51 @@ public void CheckMessageCode()
             messageOnly.ShouldBe("This is a message.");
 
             // whitespace before code and after colon is ok
-            messageOnly = null;
             code = t.Log.ExtractMessageCode("  AL001:   This is a message.", out messageOnly);
             code.ShouldBe("AL001");
             messageOnly.ShouldBe("This is a message.");
 
             // whitespace after colon is not ok
-            messageOnly = null;
             code = t.Log.ExtractMessageCode("AL001 : This is a message.", out messageOnly);
             code.ShouldBeNull();
             messageOnly.ShouldBe("AL001 : This is a message.");
 
             // big code is ok
-            messageOnly = null;
             code = t.Log.ExtractMessageCode("  RESGEN7905001:   This is a message.", out messageOnly);
             code.ShouldBe("RESGEN7905001");
             messageOnly.ShouldBe("This is a message.");
 
             // small code is ok
-            messageOnly = null;
             code = t.Log.ExtractMessageCode("R7: This is a message.", out messageOnly);
             code.ShouldBe("R7");
             messageOnly.ShouldBe("This is a message.");
 
             // lowercase code is ok
-            messageOnly = null;
             code = t.Log.ExtractMessageCode("alink3456: This is a message.", out messageOnly);
             code.ShouldBe("alink3456");
             messageOnly.ShouldBe("This is a message.");
 
             // whitespace in code is not ok
-            messageOnly = null;
             code = t.Log.ExtractMessageCode("  RES 7905:   This is a message.", out messageOnly);
             code.ShouldBeNull();
             messageOnly.ShouldBe("  RES 7905:   This is a message.");
 
             // only digits in code is not ok
-            messageOnly = null;
             code = t.Log.ExtractMessageCode("7905: This is a message.", out messageOnly);
             code.ShouldBeNull();
             messageOnly.ShouldBe("7905: This is a message.");
 
             // only letters in code is not ok
-            messageOnly = null;
             code = t.Log.ExtractMessageCode("ALINK: This is a message.", out messageOnly);
             code.ShouldBeNull();
             messageOnly.ShouldBe("ALINK: This is a message.");
 
             // digits before letters in code is not ok
-            messageOnly = null;
             code = t.Log.ExtractMessageCode("6780ALINK: This is a message.", out messageOnly);
             code.ShouldBeNull();
             messageOnly.ShouldBe("6780ALINK: This is a message.");
 
             // mixing digits and letters in code is not ok
-            messageOnly = null;
             code = t.Log.ExtractMessageCode("LNK658A: This is a message.", out messageOnly);
             code.ShouldBeNull();
             messageOnly.ShouldBe("LNK658A: This is a message.");
@@ -210,7 +200,7 @@ nor is this
             }
             finally
             {
-                if (null != file) File.Delete(file);
+                if (file != null) File.Delete(file);
             }
         }
 
diff --git a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
index 45f8705a621..f8554d8b18e 100644
--- a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
+++ b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
@@ -18,8 +18,6 @@
 using Microsoft.Win32;
 #endif
 
-
-
 using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
 using UtilitiesDotNetFrameworkArchitecture = Microsoft.Build.Utilities.DotNetFrameworkArchitecture;
 using SharedDotNetFrameworkArchitecture = Microsoft.Build.Shared.DotNetFrameworkArchitecture;
@@ -717,17 +715,11 @@ public void TestGetPathToBuildToolsFile()
         {
             string net20Path = ToolLocationHelper.GetPathToDotNetFrameworkFile("MSBuild.exe", TargetDotNetFrameworkVersion.Version20);
 
-            if (net20Path != null)
-            {
-                net20Path.ShouldBe(ToolLocationHelper.GetPathToBuildToolsFile("MSBuild.exe", "2.0"));
-            }
+            net20Path?.ShouldBe(ToolLocationHelper.GetPathToBuildToolsFile("MSBuild.exe", "2.0"));
 
             string net35Path = ToolLocationHelper.GetPathToDotNetFrameworkFile("MSBuild.exe", TargetDotNetFrameworkVersion.Version35);
 
-            if (net35Path != null)
-            {
-                net35Path.ShouldBe(ToolLocationHelper.GetPathToBuildToolsFile("MSBuild.exe", "3.5"));
-            }
+            net35Path?.ShouldBe(ToolLocationHelper.GetPathToBuildToolsFile("MSBuild.exe", "3.5"));
 
             ToolLocationHelper.GetPathToDotNetFrameworkFile("MSBuild.exe", TargetDotNetFrameworkVersion.Version40).ShouldBe(ToolLocationHelper.GetPathToBuildToolsFile("MSBuild.exe", "4.0"));
 
@@ -754,7 +746,6 @@ public void TestGetPathToBuildToolsFile_32Bit()
             ToolLocationHelper.GetPathToDotNetFrameworkFile("msbuild.exe", TargetDotNetFrameworkVersion.Version40, UtilitiesDotNetFrameworkArchitecture.Bitness32).ShouldBe(
                     ToolLocationHelper.GetPathToBuildToolsFile("msbuild.exe", "4.0", UtilitiesDotNetFrameworkArchitecture.Bitness32));
 
-
             var toolsPath32 = ProjectCollection.GlobalProjectCollection.GetToolset(ObjectModelHelpers.MSBuildDefaultToolsVersion).Properties["MSBuildToolsPath32"];
             string tv12path = Path.Combine(Path.GetFullPath(toolsPath32.EvaluatedValue), "msbuild.exe");
 
@@ -834,7 +825,6 @@ public void TestGetDotNetFrameworkSdkRootRegistryKey()
             Should.Throw<ArgumentException>( () => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version46, VisualStudioVersion.Version120) );
             ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version46, VisualStudioVersion.Version140).ShouldBe(fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK46);
 
-
             // v4.6.1
             Should.Throw<ArgumentException>( () => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version461, VisualStudioVersion.Version100) );
             Should.Throw<ArgumentException>( () => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version461, VisualStudioVersion.Version110) );
@@ -1728,7 +1718,6 @@ public void GetPathToReferenceAssembliesWithRootGoodWithChain()
             string framework39redistDirectory = Path.Combine(framework39Directory, "RedistList");
             string framework39RedistList = Path.Combine(framework39redistDirectory, "FrameworkList.xml");
 
-
             try
             {
                 Directory.CreateDirectory(framework41redistDirectory);
@@ -1739,7 +1728,6 @@ public void GetPathToReferenceAssembliesWithRootGoodWithChain()
                 File.WriteAllText(framework40RedistList, redistString40);
                 File.WriteAllText(framework41RedistList, redistString41);
 
-
                 FrameworkNameVersioning frameworkName = new FrameworkNameVersioning("MyFramework", new Version("4.1"));
                 IList<string> directories = ToolLocationHelper.GetPathToReferenceAssemblies(tempDirectory, frameworkName);
 
@@ -1823,7 +1811,6 @@ public void DisplayNameGeneration()
             }
         }
 
-
         /// <summary>
         /// Make sure we do not crash if there is a circular reference in the redist lists, we should only have a path in our reference assembly list once.
         ///
@@ -1859,7 +1846,6 @@ public void GetPathToReferenceAssembliesWithRootCircularReference()
                 File.WriteAllText(framework40RedistList, redistString40);
                 File.WriteAllText(framework41RedistList, redistString41);
 
-
                 FrameworkNameVersioning frameworkName = new FrameworkNameVersioning("MyFramework", new Version("4.1"));
                 IList<string> directories = ToolLocationHelper.GetPathToReferenceAssemblies(tempDirectory, frameworkName);
 
@@ -1973,12 +1959,10 @@ public void GetPathToReferenceAssembliesDefaultLocationNullFrameworkName()
         [Trait("Category", "mono-osx-failing")]
         public void GetPathToReferenceAssembliesDefaultLocation45()
         {
-            FrameworkNameVersioning frameworkName = null;
-            IList<string> directories = null;
             if (ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version45) != null)
             {
-                frameworkName = new FrameworkNameVersioning(".NETFramework", new Version("4.5"));
-                directories = ToolLocationHelper.GetPathToReferenceAssemblies(frameworkName);
+                FrameworkNameVersioning frameworkName = new FrameworkNameVersioning(".NETFramework", new Version("4.5"));
+                IList<string> directories = ToolLocationHelper.GetPathToReferenceAssemblies(frameworkName);
                 directories.Count.ShouldBe(1); // "Expected the method to return one path."
 
                 string referenceAssemblyPath = ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version45);
@@ -2132,7 +2116,6 @@ public void LegacyFramework30WithNo20Installed()
             list[1].ShouldBe(LegacyFrameworkTestHelper.DotNet30FrameworkPath, StringCompareShould.IgnoreCase);
         }
 
-
         /// <summary>
         /// Verify when 35 is simulated to be installed that the method returns the 3.5 directory
         /// </summary>
@@ -2170,7 +2153,6 @@ public void LegacyFramework35NotInstalled()
             list.Count.ShouldBe(0);
         }
 
-
         /// <summary>
         /// Verify when 35 reference assembly are simulated to not be installed that the method returns an empty list
         /// </summary>
@@ -2796,7 +2778,7 @@ public void GetPathToReferenceAssembliesWithNullTargetFrameworkFallbackSearchPat
 
         private static string CreateNewFrameworkAndGetAssembliesPath(TestEnvironment env, string frameworkName, string frameworkVersion, string rootDir)
         {
-            string frameworkListXml = null;
+            string frameworkListXml;
             if (NativeMethodsShared.IsMono)
             {
                 // Mono uses an extra attribute to point to the location of the corresponding
@@ -3382,7 +3364,6 @@ public void VerifySDKManifest()
 
                 string manifestFile = Path.Combine(manifestPath, "SDKManifest.xml");
 
-
                 string manifestPlatformSDK = @"
                 <FileList
                     DisplayName = ""Windows""
@@ -3450,7 +3431,6 @@ public void VerifySDKManifest()
                     </File>
                 </FileList>";
 
-
                 File.WriteAllText(manifestFile, manifestExtensionSDK);
                 sdkManifest = new SDKManifest(manifestPath);
 
@@ -3830,7 +3810,6 @@ public void VerifyGetInstalledSDKLocations3()
                     folderKey.SetValue("", Path.Combine(testDirectoryRoot, platformDirectory));
                 }
 
-
                 if (Directory.Exists(testDirectoryRoot))
                 {
                     FileUtilities.DeleteDirectoryNoThrow(testDirectoryRoot, true);
@@ -4237,7 +4216,6 @@ public void VerifyFindRootFolderWhereAllFilesExist()
             ToolLocationHelper.FindRootFolderWhereAllFilesExist(@"c:<>;" + roots, "file1.txt").ShouldBe(rootDirectories[0]); // should ignore invalid dir
         }
 
-
 #if FEATURE_REGISTRY_SDKS
         /// <summary>
         /// Verify that the GetPlatformSDKPropsFileLocation method can be correctly called for pre-OneCore SDKs during evaluation time as a msbuild function.
@@ -4697,52 +4675,52 @@ private static IEnumerable<string> GetRegistrySubKeyNames(RegistryKey baseKey, s
         {
             if (baseKey == Registry.CurrentUser)
             {
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "Windows", "MyPlatform" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "v1.0", "1.0" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "MyAssembly" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\1.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\1.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "MyAssembly" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "v1.1", "1.0", "2.0", "3.0" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\1.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\1.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "2.0" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "4.0", "5.0", "6.0", "9.0" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "MyAssembly" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\5.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\5.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { string.Empty };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "1.0" };
                 }
@@ -4750,22 +4728,22 @@ private static IEnumerable<string> GetRegistrySubKeyNames(RegistryKey baseKey, s
 
             if (baseKey == Registry.LocalMachine)
             {
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "Windows" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "v2.0" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "MyAssembly" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "3.0" };
                 }
@@ -4785,54 +4763,54 @@ private string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string subKey)
         {
             if (baseKey == Registry.CurrentUser)
             {
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly\1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly\1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "Windows\\v1.0\\ExtensionSDKs\\MyAssembly\\1.0");
                 }
 
                 // This has a v in the sdk version and should not be found but we need a real path in case it is so it will show up in the returned list and fail the test.
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly\v1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly\v1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "Windows\\v1.0\\ExtensionSDKs\\MyAssembly\\1.0");
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\1.0\ExtensionSDKs\MyAssembly\2.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\1.0\ExtensionSDKs\MyAssembly\2.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "Windows\\1.0\\ExtensionSDKs\\MyAssembly\\2.0");
                 }
 
                 // This has a set of bad char in the returned directory so it should not be allowed.
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly\3.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly\3.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return _fakeStructureRoot + @"\Windows\1.0\ExtensionSDKs\MyAssembly\<>?/";
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\5.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\5.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "MyPlatform\\5.0");
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "SomeOtherPlace\\MyPlatformOtherLocation\\4.0");
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\6.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\6.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "Windows Kits\\6.0");
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\9.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\9.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "MyPlatform\\9.0");
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0\ExtensionSDKs\MyAssembly\1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0\ExtensionSDKs\MyAssembly\1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "SomeOtherPlace\\MyPlatformOtherLocation\\4.0\\ExtensionSDKs\\MyAssembly\\1.0");
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "Windows\\1.0");
                 }
@@ -4840,12 +4818,12 @@ private string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string subKey)
 
             if (baseKey == Registry.LocalMachine)
             {
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0\ExtensionSDKs\MyAssembly\3.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0\ExtensionSDKs\MyAssembly\3.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "Windows\\2.0\\ExtensionSDKs\\MyAssembly\\3.0");
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "Windows\\2.0");
                 }
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index 78c523c03ed..d8c69b18f9e 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -856,6 +856,5 @@ protected override string GenerateCommandLineCommands()
                 return $"echo ≈Ço≈Ç > {OutputPath}";
             }
         }
-
     }
 }
diff --git a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
index a1654a3ea8e..9558f9098ea 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
@@ -900,8 +900,7 @@ public void FileTrackerFileIsExcludedFromDependencies()
                                       ? tempPath
                                       : FileUtilities.EnsureTrailingSlash(
                                           NativeMethodsShared.GetLongFilePath(tempPath).ToUpperInvariant());
-            string testFile;
-
+            
             // We don't want to be including these as dependencies or outputs:
             // 1. Files under %USERPROFILE%\Application Data in XP and %USERPROFILE%\AppData\Roaming in Vista and later.
             // 2. Files under %USERPROFILE%\Local Settings\Application Data in XP and %USERPROFILE%\AppData\Local in Vista and later.
@@ -910,7 +909,7 @@ public void FileTrackerFileIsExcludedFromDependencies()
             //    located under AppData, they would not be compacted out correctly otherwise).
 
             // This file's NOT excluded from dependencies
-            testFile = @"c:\foo\bar\baz";
+            string testFile = @"c:\foo\bar\baz";
             Assert.False(FileTracker.FileIsExcludedFromDependencies(testFile));
 
             // This file IS excluded from dependencies
@@ -1408,7 +1407,7 @@ public void InProcTrackingStartProcessFindStrNullCommandLine()
                 startInfo.hStdInput = BackEndNativeMethods.InvalidHandle;
                 startInfo.hStdOutput = BackEndNativeMethods.InvalidHandle;
                 startInfo.dwFlags = BackEndNativeMethods.STARTFUSESTDHANDLES;
-                dwCreationFlags = dwCreationFlags | BackEndNativeMethods.CREATENOWINDOW;
+                dwCreationFlags |= BackEndNativeMethods.CREATENOWINDOW;
 
                 BackEndNativeMethods.SECURITY_ATTRIBUTES pSec = new BackEndNativeMethods.SECURITY_ATTRIBUTES();
                 BackEndNativeMethods.SECURITY_ATTRIBUTES tSec = new BackEndNativeMethods.SECURITY_ATTRIBUTES();
@@ -2226,7 +2225,6 @@ public void LaunchMultipleOfSameTool_DifferentContexts()
             {
                 FileUtilities.DeleteDirectoryNoThrow(testDir, true);
             }
-
         }
 
         [Fact(Skip = "Needs investigation")]
@@ -2393,7 +2391,7 @@ private static void LaunchDuplicateToolsAndVerifyTlogExistsForEach(string tlogPa
                 startInfo.hStdInput = BackEndNativeMethods.InvalidHandle;
                 startInfo.hStdOutput = BackEndNativeMethods.InvalidHandle;
                 startInfo.dwFlags = BackEndNativeMethods.STARTFUSESTDHANDLES;
-                dwCreationFlags = dwCreationFlags | BackEndNativeMethods.CREATENOWINDOW;
+                dwCreationFlags |= BackEndNativeMethods.CREATENOWINDOW;
 
                 BackEndNativeMethods.SECURITY_ATTRIBUTES pSec = new BackEndNativeMethods.SECURITY_ATTRIBUTES();
                 BackEndNativeMethods.SECURITY_ATTRIBUTES tSec = new BackEndNativeMethods.SECURITY_ATTRIBUTES();
diff --git a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
index 6dceadcfa27..5c80c03cc29 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
@@ -12,8 +12,6 @@
 using Microsoft.Build.Utilities;
 using Xunit;
 
-
-
 #pragma warning disable 0219
 
 #if FEATURE_FILE_TRACKER
@@ -1212,7 +1210,7 @@ public void MultipleCanonicalCLMissingOutputDependencyRemoved()
             compactOutputs.SaveTlog(delegate (string fullTrackedPath)
             {
                 // We need to answer the question "should fullTrackedPath be included in the TLog?"
-                return (string.Compare(fullTrackedPath, missing, StringComparison.OrdinalIgnoreCase) != 0);
+                return !string.Equals(fullTrackedPath, missing, StringComparison.OrdinalIgnoreCase);
             });
 
             // Read the Tlogs back in..
@@ -1235,7 +1233,6 @@ public void MultipleCanonicalCLMissingOutputDependencyRemoved()
             Assert.Empty(outofDate);
         }
 
-
         [Fact]
         public void MultipleCanonicalCLMissingInputDependencyRemoved()
         {
@@ -1282,7 +1279,7 @@ public void MultipleCanonicalCLMissingInputDependencyRemoved()
             d.SaveTlog(delegate (string fullTrackedPath)
             {
                 // We need to answer the question "should fullTrackedPath be included in the TLog?"
-                return (string.Compare(fullTrackedPath, missing, StringComparison.OrdinalIgnoreCase) != 0);
+                return !string.Equals(fullTrackedPath, missing, StringComparison.OrdinalIgnoreCase);
             });
 
             // read the tlog back in again
@@ -1302,7 +1299,6 @@ public void MultipleCanonicalCLMissingInputDependencyRemoved()
             Assert.Empty(outofdate);
         }
 
-
         [Fact]
         public void MultiplePrimaryCanonicalCL()
         {
@@ -1959,7 +1955,6 @@ public void MultipleRootedCLAcrossTlogs2()
             Assert.True(outofdate[0].ItemSpec == Path.Combine("TestFiles", "one.cpp"));
         }
 
-
         [Fact]
         public void OutputSingleCanonicalCL()
         {
@@ -2412,7 +2407,6 @@ public void OutputCLMinimalRebuildOptimization()
                 Path.GetFullPath(Path.Combine("TestFiles", "three.obj")),
             });
 
-
             // Represent our tracked and computed outputs
             CanonicalTrackedOutputFiles outputs = new CanonicalTrackedOutputFiles(DependencyTestHelper.MockTask, DependencyTestHelper.ItemArray(new TaskItem(Path.Combine("TestFiles", "one.write.tlog"))));
 
@@ -2507,7 +2501,6 @@ public void OutputCLMinimalRebuildOptimizationComputed()
                 Path.GetFullPath(Path.Combine("TestFiles", "three.obj")),
             });
 
-
             // Represent our tracked and computed outputs
             CanonicalTrackedOutputFiles outputs = new CanonicalTrackedOutputFiles(DependencyTestHelper.MockTask, DependencyTestHelper.ItemArray(new TaskItem(Path.Combine("TestFiles", "one.write.tlog"))));
 
@@ -3529,7 +3522,6 @@ public void FlatTrackingDataInputOrOutputNewerThanTracking()
             // We should be out of date inputs & outputs vs tracking (since we wrote the files after the tracking logs)
             Assert.False(FlatTrackingData.IsUpToDate(DependencyTestHelper.MockTask.Log, UpToDateCheckType.InputOrOutputNewerThanTracking, inputs, outputs));
 
-
             // Touch the tracking logs so that are more recent that any of the inputs
             Thread.Sleep(_sleepTimeMilliseconds);
             File.SetLastWriteTime(Path.Combine("TestFiles", "one.read.tlog"), DateTime.Now);
diff --git a/src/Utilities/CommandLineBuilder.cs b/src/Utilities/CommandLineBuilder.cs
index 64c4bf0430a..8e7953b699f 100644
--- a/src/Utilities/CommandLineBuilder.cs
+++ b/src/Utilities/CommandLineBuilder.cs
@@ -109,7 +109,6 @@ public CommandLineBuilder(bool quoteHyphensOnCommandLine, bool useNewLineSeparat
         /// <returns></returns>
         public override string ToString() => CommandLine.ToString();
 
-
         // Use if escaping of hyphens is supposed to take place
         private static readonly string s_allowedUnquotedRegexNoHyphen =
                          "^"                             // Beginning of line
@@ -401,7 +400,7 @@ public void AppendFileNamesIfNotNull(string[] fileNames, string delimiter)
         {
             ErrorUtilities.VerifyThrowArgumentNull(delimiter, nameof(delimiter));
 
-            if (fileNames != null && fileNames.Length > 0)
+            if (fileNames?.Length > 0)
             {
                 // Don't let injection attackers escape from our quotes by sticking in
                 // their own quotes. Quotes are illegal.
@@ -436,7 +435,7 @@ public void AppendFileNamesIfNotNull(ITaskItem[] fileItems, string delimiter)
         {
             ErrorUtilities.VerifyThrowArgumentNull(delimiter, nameof(delimiter));
 
-            if (fileItems != null && fileItems.Length > 0)
+            if (fileItems?.Length > 0)
             {
                 // Don't let injection attackers escape from our quotes by sticking in
                 // their own quotes. Quotes are illegal.
@@ -572,7 +571,7 @@ public void AppendSwitchIfNotNull(string switchName, string[] parameters, string
             ErrorUtilities.VerifyThrowArgumentNull(switchName, nameof(switchName));
             ErrorUtilities.VerifyThrowArgumentNull(delimiter, nameof(delimiter));
 
-            if (parameters != null && parameters.Length > 0)
+            if (parameters?.Length > 0)
             {
                 AppendSwitch(switchName);
                 bool first = true;
@@ -604,7 +603,7 @@ public void AppendSwitchIfNotNull(string switchName, ITaskItem[] parameters, str
             ErrorUtilities.VerifyThrowArgumentNull(switchName, nameof(switchName));
             ErrorUtilities.VerifyThrowArgumentNull(delimiter, nameof(delimiter));
 
-            if (parameters != null && parameters.Length > 0)
+            if (parameters?.Length > 0)
             {
                 AppendSwitch(switchName);
                 bool first = true;
@@ -683,7 +682,7 @@ public void AppendSwitchUnquotedIfNotNull(string switchName, string[] parameters
             ErrorUtilities.VerifyThrowArgumentNull(switchName, nameof(switchName));
             ErrorUtilities.VerifyThrowArgumentNull(delimiter, nameof(delimiter));
 
-            if (parameters != null && parameters.Length > 0)
+            if (parameters?.Length > 0)
             {
                 AppendSwitch(switchName);
                 bool first = true;
@@ -714,7 +713,7 @@ public void AppendSwitchUnquotedIfNotNull(string switchName, ITaskItem[] paramet
             ErrorUtilities.VerifyThrowArgumentNull(switchName, nameof(switchName));
             ErrorUtilities.VerifyThrowArgumentNull(delimiter, nameof(delimiter));
 
-            if (parameters != null && parameters.Length > 0)
+            if (parameters?.Length > 0)
             {
                 AppendSwitch(switchName);
                 bool first = true;
diff --git a/src/Utilities/MuxLogger.cs b/src/Utilities/MuxLogger.cs
index 145aee2eb51..b6abb5f011d 100644
--- a/src/Utilities/MuxLogger.cs
+++ b/src/Utilities/MuxLogger.cs
@@ -1230,7 +1230,7 @@ private void RaiseAnyEvent(object sender, BuildEventArgs buildEvent)
                     // logger is registered without a ProjectFinished handler, but does have an Any handler (as the mock logger does) then we would end up
                     // sending the BuildFinished event before the ProjectFinished event got processed in the Any handler.
                     ProjectFinishedEventArgs projectFinishedEvent = buildEvent as ProjectFinishedEventArgs;
-                    if (projectFinishedEvent != null && buildEvent.BuildEventContext != null && buildEvent.BuildEventContext.Equals(_firstProjectStartedEventContext))
+                    if (projectFinishedEvent != null && buildEvent.BuildEventContext?.Equals(_firstProjectStartedEventContext) == true)
                     {
                         string message = projectFinishedEvent.Succeeded ? ResourceUtilities.GetResourceString("MuxLogger_BuildFinishedSuccess") : ResourceUtilities.GetResourceString("MuxLogger_BuildFinishedFailure");
                         RaiseBuildFinishedEvent(sender, new BuildFinishedEventArgs(message, null, projectFinishedEvent.Succeeded));
diff --git a/src/Utilities/ProcessorArchitecture.cs b/src/Utilities/ProcessorArchitecture.cs
index abdced9c21f..0b12a2ceb81 100644
--- a/src/Utilities/ProcessorArchitecture.cs
+++ b/src/Utilities/ProcessorArchitecture.cs
@@ -55,36 +55,16 @@ public static class ProcessorArchitecture
         /// <returns>null if unknown architecture or error, one of the known architectures otherwise</returns>
         private static string GetCurrentProcessArchitecture()
         {
-            string architecture;
-
-            switch (NativeMethodsShared.ProcessorArchitecture)
+            string architecture = NativeMethodsShared.ProcessorArchitecture switch
             {
-                case NativeMethodsShared.ProcessorArchitectures.X86:
-                    architecture = X86;
-                    break;
-
-                case NativeMethodsShared.ProcessorArchitectures.X64:
-                    architecture = AMD64;
-                    break;
-
-                case NativeMethodsShared.ProcessorArchitectures.IA64:
-                    architecture = IA64;
-                    break;
-
-                case NativeMethodsShared.ProcessorArchitectures.ARM:
-                    architecture = ARM;
-                    break;
-
-                case NativeMethodsShared.ProcessorArchitectures.ARM64:
-                    architecture = ARM64;
-                    break;
-
+                NativeMethodsShared.ProcessorArchitectures.X86 => X86,
+                NativeMethodsShared.ProcessorArchitectures.X64 => AMD64,
+                NativeMethodsShared.ProcessorArchitectures.IA64 => IA64,
+                NativeMethodsShared.ProcessorArchitectures.ARM => ARM,
+                NativeMethodsShared.ProcessorArchitectures.ARM64 => ARM64,
                 // unknown architecture? return null
-                default:
-                    architecture = null;
-                    break;
-            }
-
+                _ => null,
+            };
             return architecture;
         }
     }
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index a7c19160911..429a215a58a 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -264,7 +264,7 @@ string metadataValue
             ErrorUtilities.VerifyThrowArgument(!FileUtilities.ItemSpecModifiers.IsDerivableItemSpecModifier(metadataName),
                 "Shared.CannotChangeItemSpecModifiers", metadataName);
 
-            _metadata = _metadata ?? new CopyOnWriteDictionary<string, string>(MSBuildNameIgnoreCaseComparer.Default);
+            _metadata ??= new CopyOnWriteDictionary<string, string>(MSBuildNameIgnoreCaseComparer.Default);
 
             _metadata[metadataName] = metadataValue ?? string.Empty;
         }
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 82cd4cc9d4a..d23703a8938 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -125,7 +125,7 @@ public enum TargetDotNetFrameworkVersion
     }
 
     /// <summary>
-    /// Used to specify the version of Visual Studio from which to select associated 
+    /// Used to specify the version of Visual Studio from which to select associated
     /// tools for some methods of ToolLocationHelper
     /// </summary>
     public enum VisualStudioVersion
@@ -168,7 +168,7 @@ public enum VisualStudioVersion
     public enum DotNetFrameworkArchitecture
     {
         /// <summary>
-        /// Indicates the .NET Framework that is currently being run under.  
+        /// Indicates the .NET Framework that is currently being run under.
         /// </summary>
         Current = 0,
 
@@ -208,7 +208,7 @@ public static class ToolLocationHelper
         private static Dictionary<string, IList<string>> s_cachedReferenceAssemblyPaths;
 
         /// <summary>
-        /// Cache the frameworkName of the highest version of a framework given its root path and identifier. 
+        /// Cache the frameworkName of the highest version of a framework given its root path and identifier.
         /// This is to optimize calls to GetHighestVersionOfTargetFramework
         /// </summary>
         private static Dictionary<string, FrameworkNameVersioning> s_cachedHighestFrameworkNameForTargetFrameworkIdentifier;
@@ -231,7 +231,7 @@ public static class ToolLocationHelper
         private static Dictionary<string, string> s_cachedTargetFrameworkDisplayNames;
 
         /// <summary>
-        /// Cache the set of target platform references for a particular combination of inputs.  For legacy 
+        /// Cache the set of target platform references for a particular combination of inputs.  For legacy
         /// target platforms, this is just grabbing all winmds from the References\CommonConfiguration\Neutral
         /// folder; for OneCore-based platforms, this involves reading the list from Platform.xml and synthesizing
         /// the locations.
@@ -279,14 +279,14 @@ public static class ToolLocationHelper
         #region Public methods
 
         /// <summary>
-        /// The current ToolsVersion. 
+        /// The current ToolsVersion.
         /// </summary>
         public static string CurrentToolsVersion => MSBuildConstants.CurrentToolsVersion;
 
 #if FEATURE_WIN32_REGISTRY
         /// <summary>
         /// Get a sorted list of AssemblyFoldersExInfo which contain information about what directories the 3rd party assemblies are registered under for use during build and design time.
-        /// 
+        ///
         /// This method will enumerate the AssemblyFoldersEx registry location and return a list of AssemblyFoldersExInfo in the same order in which
         /// they will be searched during both design and build time for reference assemblies.
         /// </summary>
@@ -314,7 +314,6 @@ public static IList<AssemblyFoldersExInfo> GetAssemblyFoldersExInfo(string regis
 
             AssemblyFoldersEx assemblyFoldersEx = new AssemblyFoldersEx(registryRoot, targetFrameworkVersion, registryKeySuffix, osVersion, platform, new GetRegistrySubKeyNames(RegistryHelper.GetSubKeyNames), new GetRegistrySubKeyDefaultValue(RegistryHelper.GetDefaultValue), targetProcessorArchitecture, new OpenBaseKey(RegistryHelper.OpenBaseKey));
 
-
             var assemblyFolders = new List<AssemblyFoldersExInfo>();
             assemblyFolders.AddRange(assemblyFoldersEx);
             return assemblyFolders;
@@ -517,8 +516,8 @@ public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string t
                     (
                         string.IsNullOrEmpty(platform.TargetPlatformIdentifier)
                         ||
-                        platform.TargetPlatformIdentifier.Equals(targetPlatformIdentifier, StringComparison.OrdinalIgnoreCase)
-                        && platform.TargetPlatformVersion <= targetPlatformVersion
+                        (platform.TargetPlatformIdentifier.Equals(targetPlatformIdentifier, StringComparison.OrdinalIgnoreCase)
+                        && platform.TargetPlatformVersion <= targetPlatformVersion)
                     )
                     && platform.ExtensionSDKs.ContainsKey(sdkMoniker))
                 .OrderByDescending<TargetPlatformSDK, Version>(platform => platform.TargetPlatformVersion)
@@ -808,7 +807,7 @@ public static string GetPlatformSDKPropsFileLocation(string sdkIdentifier, strin
         /// <param name="targetPlatformMinVersion">The min version of the targeted platform</param>
         /// <param name="targetPlatformVersion">The version of the targeted platform</param>
         /// <param name="diskRoots">List of disk roots to search for sdks within</param>
-        /// <param name="registryRoot">Registry root to look for sdks within</param> 
+        /// <param name="registryRoot">Registry root to look for sdks within</param>
         /// <returns>Location of the target platform SDK props file without .props filename</returns>
         public static string GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot)
         {
@@ -939,7 +938,6 @@ public static string[] GetPlatformOrFrameworkExtensionSdkReferences
                 string targetPlatformVersion
             )
         {
-
             lock (s_locker)
             {
                 if (s_cachedExtensionSdkReferences == null)
@@ -967,8 +965,8 @@ string targetPlatformVersion
 
                     if (matchingSdk.ExtensionSDKs.TryGetValue(extensionSdkMoniker, out string extensionSdkPath)
                         ||
-                        s_cachedExtensionSdks.TryGetValue(extensionDiskRoots, out matchingSdk)
-                        && matchingSdk.ExtensionSDKs.TryGetValue(extensionSdkMoniker, out extensionSdkPath))
+                        (s_cachedExtensionSdks.TryGetValue(extensionDiskRoots, out matchingSdk)
+                        && matchingSdk.ExtensionSDKs.TryGetValue(extensionSdkMoniker, out extensionSdkPath)))
                     {
                         ExtensionSDK extensionSdk = new ExtensionSDK(extensionSdkMoniker, extensionSdkPath);
                         if (extensionSdk.SDKType == SDKType.Framework || extensionSdk.SDKType == SDKType.Platform)
@@ -998,7 +996,7 @@ string targetPlatformVersion
         private static string GetPlatformVersion(TargetPlatformSDK targetSdk, string targetPlatformIdentifier, string targetPlatformVersion)
         {
             string platformKey = TargetPlatformSDK.GetSdkKey(targetPlatformIdentifier, targetPlatformVersion);
-            if (TryGetPlatformManifest(targetSdk, platformKey, out var manifest) && manifest != null && manifest.VersionedContent)
+            if (TryGetPlatformManifest(targetSdk, platformKey, out var manifest) && manifest?.VersionedContent == true)
             {
                 return manifest.PlatformVersion;
             }
@@ -1009,7 +1007,7 @@ private static string GetPlatformVersion(TargetPlatformSDK targetSdk, string tar
         }
 
         /// <summary>
-        /// Gathers the set of platform winmds based on the assumption that they come from 
+        /// Gathers the set of platform winmds based on the assumption that they come from
         /// an SDK that is specified solely by TPI / TPV.
         /// </summary>
         private static string[] GetLegacyTargetPlatformReferences(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot)
@@ -1058,7 +1056,7 @@ private static string[] GetLegacyTargetPlatformReferences(string targetPlatformI
         }
 
         /// <summary>
-        /// Gathers the set of platform winmds for a particular {SDKI, SDKV, TPI, TPMinV, TPV} combination, 
+        /// Gathers the set of platform winmds for a particular {SDKI, SDKV, TPI, TPMinV, TPV} combination,
         /// based on the assumption that it is an SDK that has both {SDKI, SDKV} and TP* specifiers.
         /// </summary>
         private static string[] GetTargetPlatformReferencesFromManifest
@@ -1186,7 +1184,7 @@ private static bool TryGetPlatformManifest(TargetPlatformSDK matchingSdk, string
         /// <param name="sdkVersion">The verision of the SDK</param>
         /// <param name="targetPlatformIdentifier">The identifier of the targeted platform</param>
         /// <param name="targetPlatformMinVersion">The min version of the targeted platform</param>
-        /// <param name="targetPlatformVersion">The version of the targeted platform</param> 
+        /// <param name="targetPlatformVersion">The version of the targeted platform</param>
         /// <param name="folderName">The content folder name under SDK path</param>
         /// <param name="diskRoot">An optional disk root to search.  A value should only be passed from a unit test.</param>
         /// <returns>The SDK content folder path</returns>
@@ -1296,12 +1294,12 @@ public static string GetPlatformSDKLocation(string targetPlatformIdentifier, str
         }
 
         /// <summary>
-        /// Given a target platform identifier and version, get the display name for that platform SDK. 
+        /// Given a target platform identifier and version, get the display name for that platform SDK.
         /// </summary>
         public static string GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion) => GetPlatformSDKDisplayName(targetPlatformIdentifier, targetPlatformVersion, null, null);
 
         /// <summary>
-        /// Given a target platform identifier and version, get the display name for that platform SDK. 
+        /// Given a target platform identifier and version, get the display name for that platform SDK.
         /// </summary>
         public static string GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot)
         {
@@ -1381,7 +1379,7 @@ public static string GetLatestSDKTargetPlatformVersion(string sdkIdentifier, str
                 }
             }
 
-            if (availablePlatformVersions != null && availablePlatformVersions.Count > 0)
+            if (availablePlatformVersions?.Count > 0)
             {
                 return availablePlatformVersions.OrderByDescending(x => x).FirstOrDefault().ToString();
             }
@@ -1517,9 +1515,9 @@ public static string FindRootFolderWhereAllFilesExist(string possibleRoots, stri
 
             return string.Empty;
         }
-        
+
         /// <summary>
-        /// Tries to parse the "version" out of a platformMoniker. 
+        /// Tries to parse the "version" out of a platformMoniker.
         /// </summary>
         /// <param name="platformMoniker">PlatformMoniker, in the form "PlatformName, Version=version"</param>
         /// <param name="platformVersion">The version of the platform, if the parse was successful - Else set to null</param>
@@ -1549,8 +1547,8 @@ private static bool TryParsePlatformVersion(string platformMoniker, out Version
         }
 
         /// <summary>
-        /// Given a target platform identifier and version and locations in which to search, find the TargetPlatformSDK 
-        /// object that matches.  
+        /// Given a target platform identifier and version and locations in which to search, find the TargetPlatformSDK
+        /// object that matches.
         /// </summary>
         private static TargetPlatformSDK GetMatchingPlatformSDK(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string multiPlatformDiskRoots, string registryRoot)
         {
@@ -1577,7 +1575,7 @@ private static TargetPlatformSDK GetMatchingPlatformSDK(string targetPlatformIde
         }
 
         /// <summary>
-        /// Given a target platform identifier and version and locations in which to search, find the TargetPlatformSDK 
+        /// Given a target platform identifier and version and locations in which to search, find the TargetPlatformSDK
         /// object that matches.
         /// </summary>
         private static TargetPlatformSDK GetMatchingPlatformSDK(string targetPlatformIdentifier, Version targetPlatformVersion, string[] diskRoots, string[] multiPlatformDiskRoots, string registryRoot)
@@ -1604,7 +1602,7 @@ private static TargetPlatformSDK GetMatchingPlatformSDK(string targetPlatformIde
         }
 
         /// <summary>
-        /// Given a target platform identifier and version, generate a reasonable default display name. 
+        /// Given a target platform identifier and version, generate a reasonable default display name.
         /// </summary>
         /// <param name="targetPlatformIdentifier"></param>
         /// <param name="targetPlatformVersion"></param>
@@ -1638,9 +1636,9 @@ public static string PathToSystem
 
         /// <summary>
         /// Returns the full name of the .NET Framework SDK root registry key.  When targeting .NET 3.5 or
-        /// above, looks in the locations associated with Visual Studio 2010.  If you wish to target the 
-        /// .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override that 
-        /// specifies a VisualStudioVersion. 
+        /// above, looks in the locations associated with Visual Studio 2010.  If you wish to target the
+        /// .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override that
+        /// specifies a VisualStudioVersion.
         /// </summary>
         /// <param name="version">Version of the targeted .NET Framework</param>
         public static string GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion version) => GetDotNetFrameworkSdkRootRegistryKey(version, VisualStudioVersion.VersionLatest);
@@ -1658,10 +1656,10 @@ public static string GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkV
         }
 
         /// <summary>
-        /// Name of the value of GetDotNetFrameworkRootRegistryKey that contains the SDK install root path. When 
-        /// targeting .NET 3.5 or above, looks in the locations associated with Visual Studio 2010.  If you wish 
-        /// to target the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override 
-        /// that specifies a VisualStudioVersion. 
+        /// Name of the value of GetDotNetFrameworkRootRegistryKey that contains the SDK install root path. When
+        /// targeting .NET 3.5 or above, looks in the locations associated with Visual Studio 2010.  If you wish
+        /// to target the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override
+        /// that specifies a VisualStudioVersion.
         /// </summary>
         /// <param name="version">Version of the targeted .NET Framework</param>
         public static string GetDotNetFrameworkSdkInstallKeyValue(TargetDotNetFrameworkVersion version) => GetDotNetFrameworkSdkInstallKeyValue(version, VisualStudioVersion.VersionLatest);
@@ -1686,7 +1684,7 @@ public static string GetDotNetFrameworkSdkInstallKeyValue(TargetDotNetFrameworkV
         public static string GetPathToDotNetFramework(TargetDotNetFrameworkVersion version) => GetPathToDotNetFramework(version, UtilitiesDotNetFrameworkArchitecture.Current);
 
         /// <summary>
-        /// Get a fully qualified path to the framework's root directory. 
+        /// Get a fully qualified path to the framework's root directory.
         /// </summary>
         /// <param name="version">Version of the targeted .NET Framework</param>
         /// <param name="architecture">Desired architecture, or DotNetFrameworkArchitecture.Current for the architecture this process is currently running under.</param>
@@ -1699,19 +1697,19 @@ public static string GetPathToDotNetFramework(TargetDotNetFrameworkVersion versi
         }
 
         /// <summary>
-        /// Returns the path to the "bin" directory of the latest .NET Framework SDK. When targeting .NET 3.5 
-        /// or above, looks in the locations associated with Visual Studio 2010.  If you wish to target 
-        /// the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override 
-        /// that specifies a VisualStudioVersion. 
+        /// Returns the path to the "bin" directory of the latest .NET Framework SDK. When targeting .NET 3.5
+        /// or above, looks in the locations associated with Visual Studio 2010.  If you wish to target
+        /// the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override
+        /// that specifies a VisualStudioVersion.
         /// </summary>
         /// <returns>Path string.</returns>
         public static string GetPathToDotNetFrameworkSdk() => GetPathToDotNetFrameworkSdk(TargetDotNetFrameworkVersion.Latest);
 
         /// <summary>
-        /// Returns the path to the "bin" directory of the .NET Framework SDK. When targeting .NET 3.5 
-        /// or above, looks in the locations associated with Visual Studio 2010.  If you wish to target 
-        /// the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override 
-        /// that specifies a VisualStudioVersion. 
+        /// Returns the path to the "bin" directory of the .NET Framework SDK. When targeting .NET 3.5
+        /// or above, looks in the locations associated with Visual Studio 2010.  If you wish to target
+        /// the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override
+        /// that specifies a VisualStudioVersion.
         /// </summary>
         /// <param name="version">Version of the targeted .NET Framework</param>
         /// <returns>Path string.</returns>
@@ -1803,7 +1801,7 @@ public static string GetPathToStandardLibraries(string targetFrameworkIdentifier
         /// <param name="targetFrameworkProfile">Profile being targeted</param>
         /// <param name="platformTarget">What is the targeted platform, this is used to determine where we should look for the standard libraries. Note, this parameter is only used for .net frameworks less than 4.0</param>
         /// <param name="targetFrameworkRootPath">Root directory where the target framework will be looked for. Uses default path if this is null</param>
-        /// <param name="targetFrameworkFallbackSearchPaths">';' separated list of paths that are looked up if the the framework cannot be found in @targetFrameworkRootPath</param>
+        /// <param name="targetFrameworkFallbackSearchPaths">';' separated list of paths that are looked up if the framework cannot be found in @targetFrameworkRootPath</param>
         /// <exception cref="ArgumentNullException">When the frameworkName is null</exception>
         /// <returns>Collection of reference assembly locations.</returns>
         public static string GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths)
@@ -1903,7 +1901,7 @@ public static IList<string> GetPathToReferenceAssemblies(string targetFrameworkI
         /// <param name="targetFrameworkVersion">Version being targeted</param>
         /// <param name="targetFrameworkProfile">Profile being targeted</param>
         /// <param name="targetFrameworkRootPath">Root directory which will be used to calculate the reference assembly path. The references assemblies will be
-        /// <param name="targetFrameworkFallbackSearchPaths">';' separated list of paths that are looked up if the the framework cannot be found in @targetFrameworkRootPath</param>
+        /// <param name="targetFrameworkFallbackSearchPaths">';' separated list of paths that are looked up if the framework cannot be found in @targetFrameworkRootPath</param>
         /// generated in the following way TargetFrameworkRootPath\TargetFrameworkIdentifier\TargetFrameworkVersion\SubType\TargetFrameworkSubType.
         /// Uses the default path if this is null.
         /// </param>
@@ -1921,7 +1919,6 @@ public static IList<string> GetPathToReferenceAssemblies(string targetFrameworkI
             return GetPathToReferenceAssemblies(targetFrameworkRootPath, targetFrameworkFallbackSearchPaths, targetFrameworkName);
         }
 
-
         /// <summary>
         /// Returns the paths to the reference assemblies location for the given target framework.
         /// This method will assume the requested ReferenceAssemblyRoot path will be the ProgramFiles directory specified by Environment.SpecialFolder.ProgramFiles
@@ -2164,7 +2161,6 @@ private static IList<string> HandleLegacy20(VersionToPath PathToDotNetFramework)
             return referencePaths;
         }
 
-
         /// <summary>
         /// Returns the paths to the reference assemblies location for the given framework version relative to a given targetFrameworkRoot.
         /// The method will not check to see if the path exists or not.
@@ -2172,7 +2168,7 @@ private static IList<string> HandleLegacy20(VersionToPath PathToDotNetFramework)
         /// <param name="targetFrameworkRootPath">Root directory which will be used to calculate the reference assembly path. The references assemblies will be
         /// generated in the following way TargetFrameworkRootPath\TargetFrameworkIdentifier\TargetFrameworkVersion\SubType\TargetFrameworkSubType.
         /// </param>
-        /// <param name="targetFrameworkFallbackSearchPaths">';' separated list of paths that are looked up if the the framework cannot be found in @targetFrameworkRootPath</param>
+        /// <param name="targetFrameworkFallbackSearchPaths">';' separated list of paths that are looked up if the framework cannot be found in @targetFrameworkRootPath</param>
         /// <param name="frameworkName">A frameworkName class which represents a TargetFrameworkMoniker. This cannot be null.</param>
         /// <returns>Collection of reference assembly locations.</returns>
         public static IList<string> GetPathToReferenceAssemblies(string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths, FrameworkNameVersioning frameworkName)
@@ -2267,7 +2263,7 @@ public static IList<string> GetPathToReferenceAssemblies(string targetFrameworkR
         }
 
         /// <summary>
-        /// Figures out a display name given the target framework details. 
+        /// Figures out a display name given the target framework details.
         /// This is the equivalent of the target framework moniker, but for display.
         /// If one cannot be found from the redist list file, a synthesized one is returned, so there is always a display name.
         /// </summary>
@@ -2301,7 +2297,7 @@ public static string GetDisplayNameForTargetFrameworkDirectory(string targetFram
 
             displayNameBuilder.Append(frameworkName.Identifier);
             displayNameBuilder.Append(" ");
-            displayNameBuilder.Append("v" + frameworkName.Version.ToString());
+            displayNameBuilder.Append('v').Append(frameworkName.Version.ToString());
 
             if (!string.IsNullOrEmpty(frameworkName.Profile))
             {
@@ -2945,7 +2941,7 @@ private static void ExtractSdkDiskRootsFromEnvironment(List<string> diskRoots, s
         }
 
         /// <summary>
-        /// Get the disk roots to search for both platform and extension sdks in. The environment variable can 
+        /// Get the disk roots to search for both platform and extension sdks in. The environment variable can
         /// override the defaults.
         /// </summary>
         /// <returns></returns>
@@ -2956,7 +2952,7 @@ private static List<string> GetTargetPlatformMonikerDiskRoots(string[] diskRoots
             ExtractSdkDiskRootsFromEnvironment(sdkDiskRoots, sdkDirectoryRootsFromEnvironment);
             if (sdkDiskRoots.Count == 0)
             {
-                if (diskRoots != null && diskRoots.Length > 0)
+                if (diskRoots?.Length > 0)
                 {
                     ErrorUtilities.DebugTraceMessage("GetTargetPlatformMonikerDiskRoots", "Passed in DiskRoots '{0}'", string.Join(";", diskRoots));
                     sdkDiskRoots.AddRange(diskRoots);
@@ -2973,7 +2969,7 @@ private static List<string> GetTargetPlatformMonikerDiskRoots(string[] diskRoots
         }
 
         /// <summary>
-        /// Get the disk roots to search for multi platform extension sdks in. The environment variable can 
+        /// Get the disk roots to search for multi platform extension sdks in. The environment variable can
         /// override the defaults.
         /// </summary>
         private static List<string> GetExtensionSdkDiskRoots(string[] diskRoots)
@@ -2981,7 +2977,7 @@ private static List<string> GetExtensionSdkDiskRoots(string[] diskRoots)
             var sdkDiskRoots = new List<string>();
             string sdkDirectoryRootsFromEnvironment = Environment.GetEnvironmentVariable("MSBUILDMULTIPLATFORMSDKREFERENCEDIRECTORY");
             ExtractSdkDiskRootsFromEnvironment(sdkDiskRoots, sdkDirectoryRootsFromEnvironment);
-            if (sdkDiskRoots.Count == 0 && diskRoots != null && diskRoots.Length > 0)
+            if (sdkDiskRoots.Count == 0 && diskRoots?.Length > 0)
             {
                 ErrorUtilities.DebugTraceMessage("GetMultiPlatformSdkDiskRoots", "Passed in DiskRoots '{0}'", string.Join(";", diskRoots));
                 sdkDiskRoots.AddRange(diskRoots);
@@ -2997,7 +2993,7 @@ private static List<string> GetExtensionSdkDiskRoots(string[] diskRoots)
         /// <returns></returns>
         private static string GetTargetPlatformMonikerRegistryRoots(string registryRootLocation)
         {
-            ErrorUtilities.DebugTraceMessage("GetTargetPlatformMonikerRegistryRoots", "RegistryRoot passed in '{0}'", registryRootLocation != null ? registryRootLocation : string.Empty);
+            ErrorUtilities.DebugTraceMessage("GetTargetPlatformMonikerRegistryRoots", "RegistryRoot passed in '{0}'", registryRootLocation ?? string.Empty);
 
             string disableRegistryForSDKLookup = Environment.GetEnvironmentVariable("MSBUILDDISABLEREGISTRYFORSDKLOOKUP");
             // If we are not disabling the registry for platform sdk lookups then lets look in the default location.
@@ -3020,12 +3016,11 @@ private static string GetTargetPlatformMonikerRegistryRoots(string registryRootL
                 ErrorUtilities.DebugTraceMessage("GetTargetPlatformMonikerRegistryRoots", "MSBUILDDISABLEREGISTRYFORSDKLOOKUP is set registry sdk lookup is disabled");
             }
 
-
             return registryRoot;
         }
 
         /// <summary>
-        /// Given a platform SDK object, populate its supported platforms. 
+        /// Given a platform SDK object, populate its supported platforms.
         /// </summary>
         private static void GatherPlatformsForSdk(TargetPlatformSDK sdk)
         {
@@ -3091,7 +3086,7 @@ private static void GatherPlatformsForSdk(TargetPlatformSDK sdk)
         }
 
         /// <summary>
-        /// Take the path to a reference assembly directory which contains a RedistList folder which then contains a FrameworkList.xml file. 
+        /// Take the path to a reference assembly directory which contains a RedistList folder which then contains a FrameworkList.xml file.
         /// We will read in the xml file and determine if it has an IncludedFramework element in the redist list. If it does it will calculate
         /// the path where the next link in the chain should be and return that path.
         /// Also, when reading the redist list, if any display name is found it will be cached, keyed off the path passed in.
@@ -3104,8 +3099,8 @@ internal static string ChainReferenceAssemblyPath(string targetFrameworkDirector
             lock (s_locker)
             {
                 // Cache the results of the chain search so that we do not have to do an expensive read more than once per process per redist list.
-                s_chainedReferenceAssemblyPath = s_chainedReferenceAssemblyPath ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-                s_cachedTargetFrameworkDisplayNames = s_cachedTargetFrameworkDisplayNames ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+                s_chainedReferenceAssemblyPath ??= new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+                s_cachedTargetFrameworkDisplayNames ??= new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
                 if (s_chainedReferenceAssemblyPath.TryGetValue(path, out string cachedPath))
                 {
@@ -3250,9 +3245,9 @@ internal static string ChainReferenceAssemblyPath(string targetFrameworkDirector
 
         /// <summary>
         /// Get a fully qualified path to a file in the latest .NET Framework SDK. Error if the .NET Framework SDK can't be found.
-        /// When targeting .NET 3.5 or above, looks in the locations associated with Visual Studio 2010.  If you wish to 
-        /// target the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override that 
-        /// specifies a VisualStudioVersion. 
+        /// When targeting .NET 3.5 or above, looks in the locations associated with Visual Studio 2010.  If you wish to
+        /// target the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override that
+        /// specifies a VisualStudioVersion.
         /// </summary>
         /// <param name="fileName">File name to locate in the .NET Framework SDK directory</param>
         /// <returns>Path string.</returns>
@@ -3260,9 +3255,9 @@ internal static string ChainReferenceAssemblyPath(string targetFrameworkDirector
 
         /// <summary>
         /// Get a fully qualified path to a file in the .NET Framework SDK. Error if the .NET Framework SDK can't be found.
-        /// When targeting .NET 3.5 or above, looks in the locations associated with Visual Studio 2010.  If you wish to 
-        /// target the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override that 
-        /// specifies a VisualStudioVersion. 
+        /// When targeting .NET 3.5 or above, looks in the locations associated with Visual Studio 2010.  If you wish to
+        /// target the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override that
+        /// specifies a VisualStudioVersion.
         /// </summary>
         /// <param name="fileName">File name to locate in the .NET Framework SDK directory</param>
         /// <param name="version">Version of the targeted .NET Framework</param>
@@ -3318,8 +3313,8 @@ public static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotN
         /// <param name="version">Version of the targeted .NET Framework</param>
         /// <param name="visualStudioVersion">Version of Visual Studio</param>
         /// <param name="architecture">The required architecture of the requested file.</param>
-        /// <param name="canFallBackIfNecessary">If true, will follow the fallback pattern -- from requested architecture, to 
-        /// current architecture, to x86.  Otherwise, if the requested architecture path doesn't exist, that's it -- no path 
+        /// <param name="canFallBackIfNecessary">If true, will follow the fallback pattern -- from requested architecture, to
+        /// current architecture, to x86.  Otherwise, if the requested architecture path doesn't exist, that's it -- no path
         /// will be returned.</param>
         /// <returns></returns>
         private static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion, UtilitiesDotNetFrameworkArchitecture architecture, bool canFallBackIfNecessary)
@@ -3354,7 +3349,7 @@ private static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDot
         }
 
         /// <summary>
-        /// Gets the path to a sdk exe based on the processor architecture and the provided bin directory path. 
+        /// Gets the path to a sdk exe based on the processor architecture and the provided bin directory path.
         /// If the fileName cannot be found in the pathToSDK after the processor architecture has been taken into account a null is returned.
         /// </summary>
         internal static string GetPathToDotNetFrameworkSdkFile(string fileName, string pathToSdk, string processorArchitecture)
@@ -3409,22 +3404,17 @@ internal static string ConvertDotNetFrameworkArchitectureToProcessorArchitecture
                     return ProcessorArchitecture.X86;
                 case DotNetFrameworkArchitecture.Bitness64:
                     // We need to know which 64-bit architecture we're on.
-                    switch (NativeMethodsShared.ProcessorArchitectureNative)
+                    return NativeMethodsShared.ProcessorArchitectureNative switch
                     {
-                        case NativeMethodsShared.ProcessorArchitectures.X64:
-                            return ProcessorArchitecture.AMD64;
-                        case NativeMethodsShared.ProcessorArchitectures.IA64:
-                            return ProcessorArchitecture.IA64;
+                        NativeMethodsShared.ProcessorArchitectures.X64 => ProcessorArchitecture.AMD64,
+                        NativeMethodsShared.ProcessorArchitectures.IA64 => ProcessorArchitecture.IA64,
                         // Error, OK, we're trying to get the 64-bit path on a 32-bit machine.
                         // That ... doesn't make sense. 
-                        case NativeMethodsShared.ProcessorArchitectures.X86:
-                            return null;
-                        case NativeMethodsShared.ProcessorArchitectures.ARM:
-                            return null;
+                        NativeMethodsShared.ProcessorArchitectures.X86 => null,
+                        NativeMethodsShared.ProcessorArchitectures.ARM => null,
                         // unknown architecture? return null
-                        default:
-                            return null;
-                    }
+                        _ => null,
+                    };
                 case DotNetFrameworkArchitecture.Current:
                     return ProcessorArchitecture.CurrentProcessArchitecture;
             }
@@ -3434,8 +3424,8 @@ internal static string ConvertDotNetFrameworkArchitectureToProcessorArchitecture
         }
 
         /// <summary>
-        /// Returns the path to the Windows SDK for the desired .NET Framework and Visual Studio version.  Note that 
-        /// this is only supported for a targeted .NET Framework version of 4.5 and above. 
+        /// Returns the path to the Windows SDK for the desired .NET Framework and Visual Studio version.  Note that
+        /// this is only supported for a targeted .NET Framework version of 4.5 and above.
         /// </summary>
         /// <param name="version">Target .NET Framework version</param>
         /// <param name="visualStudioVersion">Version of Visual Studio associated with the SDK.</param>
@@ -3445,8 +3435,8 @@ public static string GetPathToWindowsSdk(TargetDotNetFrameworkVersion version, V
             => FrameworkLocationHelper.GetPathToWindowsSdk(TargetDotNetFrameworkVersionToSystemVersion(version));
 
         /// <summary>
-        /// Returns the path to a file in the Windows SDK for the desired .NET Framework and Visual Studio version.  Note that 
-        /// this is only supported for a targeted .NET Framework version of 4.5 and above. 
+        /// Returns the path to a file in the Windows SDK for the desired .NET Framework and Visual Studio version.  Note that
+        /// this is only supported for a targeted .NET Framework version of 4.5 and above.
         /// </summary>
         /// <param name="fileName">The name of the file being requested.</param>
         /// <param name="version">Target .NET Framework version.</param>
@@ -3463,8 +3453,8 @@ public static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFramew
             );
 
         /// <summary>
-        /// Returns the path to a file in the Windows SDK for the desired .NET Framework and Visual Studio version and the desired 
-        /// architecture.  Note that this is only supported for a targeted .NET Framework version of 4.5 and above. 
+        /// Returns the path to a file in the Windows SDK for the desired .NET Framework and Visual Studio version and the desired
+        /// architecture.  Note that this is only supported for a targeted .NET Framework version of 4.5 and above.
         /// </summary>
         /// <param name="fileName">The name of the file being requested.</param>
         /// <param name="version">Target .NET Framework version.</param>
@@ -3482,8 +3472,8 @@ public static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFramew
             );
 
         /// <summary>
-        /// Returns the path to a file in the Windows SDK for the desired .NET Framework and Visual Studio version and the desired 
-        /// architecture.  Note that this is only supported for a targeted .NET Framework version of 4.5 and above. 
+        /// Returns the path to a file in the Windows SDK for the desired .NET Framework and Visual Studio version and the desired
+        /// architecture.  Note that this is only supported for a targeted .NET Framework version of 4.5 and above.
         /// </summary>
         /// <param name="fileName">The name of the file being requested.</param>
         /// <param name="version">Target .NET Framework version.</param>
@@ -3526,7 +3516,7 @@ private static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFrame
         }
 
         /// <summary>
-        /// Gets the path to a sdk exe based on the processor architecture and the provided bin directory path. 
+        /// Gets the path to a sdk exe based on the processor architecture and the provided bin directory path.
         /// If the fileName cannot be found in the pathToSDK after the processor architecture has been taken into account a null is returned.
         /// </summary>
         [Obsolete("Consider using GetPlatformSDKLocationFile instead")]
@@ -3579,38 +3569,34 @@ private static string GetPathToWindowsSdkFile(string fileName, string pathToSdk,
         /// <returns>The tools path folder of the appropriate ToolsVersion if it exists, otherwise null.</returns>
         public static string GetPathToBuildTools(string toolsVersion, UtilitiesDotNetFrameworkArchitecture architecture)
         {
-            switch (toolsVersion)
+            return toolsVersion switch
             {
-                case "2.0":
-                    return GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version20, architecture);
-                case "3.5":
-                    return GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version35, architecture);
-                case "4.0":
-                    return GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version40, architecture);
-            }
-
-            // Doesn't map to an existing .NET Framework, so let's grab it out of the toolset.
-            return FrameworkLocationHelper.GeneratePathToBuildToolsForToolsVersion(toolsVersion, ConvertToSharedDotNetFrameworkArchitecture(architecture));
+                "2.0" => GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version20, architecture),
+                "3.5" => GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version35, architecture),
+                "4.0" => GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version40, architecture),
+                // Doesn't map to an existing .NET Framework, so let's grab it out of the toolset.
+                _ => FrameworkLocationHelper.GeneratePathToBuildToolsForToolsVersion(toolsVersion, ConvertToSharedDotNetFrameworkArchitecture(architecture)),
+            };
         }
 
         /// <summary>
-        /// Given the name of a file and a ToolsVersion, return the path to that file in the MSBuild 
+        /// Given the name of a file and a ToolsVersion, return the path to that file in the MSBuild
         /// tools path for that ToolsVersion
         /// </summary>
         /// <param name="fileName">The file to find the path to</param>
         /// <param name="toolsVersion">The ToolsVersion in which to find the file</param>
-        /// <returns>The path to the file in the tools path folder of the appropriate ToolsVersion if it 
+        /// <returns>The path to the file in the tools path folder of the appropriate ToolsVersion if it
         /// exists, otherwise null.</returns>
         public static string GetPathToBuildToolsFile(string fileName, string toolsVersion) => GetPathToBuildToolsFile(fileName, toolsVersion, UtilitiesDotNetFrameworkArchitecture.Current);
 
         /// <summary>
-        /// Given the name of a file and a ToolsVersion, return the path to that file in the MSBuild 
+        /// Given the name of a file and a ToolsVersion, return the path to that file in the MSBuild
         /// tools path for that ToolsVersion
         /// </summary>
         /// <param name="fileName">The file to find the path to</param>
         /// <param name="toolsVersion">The ToolsVersion in which to find the file</param>
         /// <param name="architecture">The architecture of the build tools file to get</param>
-        /// <returns>The path to the file in the tools path folder of the appropriate ToolsVersion if it 
+        /// <returns>The path to the file in the tools path folder of the appropriate ToolsVersion if it
         /// exists, otherwise null.</returns>
         public static string GetPathToBuildToolsFile(string fileName, string toolsVersion, UtilitiesDotNetFrameworkArchitecture architecture)
         {
@@ -3690,9 +3676,8 @@ public static IList<string> GetSupportedTargetFrameworks()
             return s_targetFrameworkMonikers;
         }
 
-
         /// <summary>
-        /// This method will return the highest version of a target framework moniker based on the identifier. This method will only 
+        /// This method will return the highest version of a target framework moniker based on the identifier. This method will only
         /// find full frameworks, this means no profiles will be returned.
         /// </summary>
         public static FrameworkNameVersioning HighestVersionOfTargetFrameworkIdentifier(string targetFrameworkRootDirectory, string frameworkIdentifier)
@@ -3742,8 +3727,8 @@ public static FrameworkNameVersioning HighestVersionOfTargetFrameworkIdentifier(
         #region private methods
 
         /// <summary>
-        /// Converts a member of the Microsoft.Build.Utilities.DotNetFrameworkArchitecture enum to the equivalent member of the 
-        /// Microsoft.Build.Shared.DotNetFrameworkArchitecture enum. 
+        /// Converts a member of the Microsoft.Build.Utilities.DotNetFrameworkArchitecture enum to the equivalent member of the
+        /// Microsoft.Build.Shared.DotNetFrameworkArchitecture enum.
         /// </summary>
         private static SharedDotNetFrameworkArchitecture ConvertToSharedDotNetFrameworkArchitecture(UtilitiesDotNetFrameworkArchitecture architecture)
         {
@@ -3812,8 +3797,8 @@ internal static IList<string> GetFrameworkIdentifiers(string frameworkReferenceR
                 {
                     if (programFilesReferenceAssemblyLocationFound &&
                         (
-                            string.Compare(folder.Name, FrameworkLocationHelper.dotNetFrameworkVersionFolderPrefixV30, StringComparison.OrdinalIgnoreCase) == 0
-                            || string.Compare(folder.Name, FrameworkLocationHelper.dotNetFrameworkVersionFolderPrefixV35, StringComparison.OrdinalIgnoreCase) == 0
+                            string.Equals(folder.Name, FrameworkLocationHelper.dotNetFrameworkVersionFolderPrefixV30, StringComparison.OrdinalIgnoreCase)
+                            || string.Equals(folder.Name, FrameworkLocationHelper.dotNetFrameworkVersionFolderPrefixV35, StringComparison.OrdinalIgnoreCase)
                         )
                        )
                     {
@@ -3821,7 +3806,7 @@ internal static IList<string> GetFrameworkIdentifiers(string frameworkReferenceR
                         continue;
                     }
 
-                    if (string.Compare(folder.Name, FrameworkLocationHelper.dotNetFrameworkIdentifier, StringComparison.OrdinalIgnoreCase) == 0)
+                    if (string.Equals(folder.Name, FrameworkLocationHelper.dotNetFrameworkIdentifier, StringComparison.OrdinalIgnoreCase))
                     {
                         bFoundDotNetFrameworkIdentifier = true;
                     }
@@ -3830,10 +3815,9 @@ internal static IList<string> GetFrameworkIdentifiers(string frameworkReferenceR
                 }
             }
 
-
-            if (programFilesReferenceAssemblyLocationFound && bFoundDotNetFrameworkIdentifier == false)
+            if (programFilesReferenceAssemblyLocationFound && !bFoundDotNetFrameworkIdentifier)
             {
-                if (bAddDotNetFrameworkIdentifier == false)
+                if (!bAddDotNetFrameworkIdentifier)
                 {
                     // special case for .NETFramework v2.0 - check also in the framework path because v20 does not have reference
                     // assembly folders
@@ -3853,11 +3837,9 @@ internal static IList<string> GetFrameworkIdentifiers(string frameworkReferenceR
                 }
             }
 
-
             return frameworkIdentifiers;
         }
 
-
         /// <summary>
         /// Gets the installed versions for a given framework
         /// </summary>
@@ -3878,7 +3860,7 @@ private static IList<string> GetFrameworkVersions(string frameworkReferenceRoot,
             //backward compatibility with orcas
             //In case of orcas .NETFramework v3.0, v3.5 - the version folders are directly under the frameworkReferenceRoot
             //first check here
-            if (string.Compare(frameworkIdentifier, FrameworkLocationHelper.dotNetFrameworkIdentifier, StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(frameworkIdentifier, FrameworkLocationHelper.dotNetFrameworkIdentifier, StringComparison.OrdinalIgnoreCase))
             {
                 IList<string> versions = GetFx35AndEarlierVersions(frameworkReferenceRoot);
                 if (versions.Count > 0)
@@ -3900,7 +3882,7 @@ private static IList<string> GetFrameworkVersions(string frameworkReferenceRoot,
                     //only add if the version folder name is of the right format
                     if (folder.Name.Length >= 4 && folder.Name.StartsWith("v", StringComparison.OrdinalIgnoreCase))
                     {
-                        Version ver = null;
+                        Version ver;
                         if (Version.TryParse(folder.Name.Substring(1), out ver))
                         {
                             frameworkVersions.Add(folder.Name);
@@ -3942,8 +3924,7 @@ private static IList<string> GetFrameworkProfiles(string frameworkReferenceRoot,
 
             var frameworkProfiles = new List<string>();
 
-            string frameworkProfilePath = null;
-            frameworkProfilePath = Path.Combine(frameworkReferenceRoot, frameworkIdentifier);
+            string frameworkProfilePath = Path.Combine(frameworkReferenceRoot, frameworkIdentifier);
             frameworkProfilePath = Path.Combine(frameworkProfilePath, frameworkVersion);
             frameworkProfilePath = Path.Combine(frameworkProfilePath, "Profiles");
 
@@ -3955,7 +3936,7 @@ private static IList<string> GetFrameworkProfiles(string frameworkReferenceRoot,
                     Version ver = VersionUtilities.ConvertToVersion(frameworkVersion);
                     // check if profile is installed correctly
                     IList<string> refAssemblyPaths = GetPathToReferenceAssemblies(new FrameworkNameVersioning(frameworkIdentifier, ver, subType.Name));
-                    if (refAssemblyPaths != null && refAssemblyPaths.Count > 0)
+                    if (refAssemblyPaths?.Count > 0)
                     {
                         frameworkProfiles.Add(subType.Name);
                     }
@@ -3965,7 +3946,6 @@ private static IList<string> GetFrameworkProfiles(string frameworkReferenceRoot,
             return frameworkProfiles;
         }
 
-
         /// <summary>
         /// returns the .NETFramework versions lessthanOrEqualTo 3.5 installed in the machine
         /// Only returns Fx versions lessthanOrEqualTo 3.5 if DNFx3.5 is installed
@@ -3977,8 +3957,7 @@ private static IList<string> GetFx35AndEarlierVersions(string frameworkReference
             IList<string> versions = new List<string>();
 
             // only return v35 and earlier versions if .NetFx35 is installed
-            string dotNetFx35Path = null;
-            dotNetFx35Path = GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version35);
+            string dotNetFx35Path = GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version35);
 
             if (dotNetFx35Path != null)
             {
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 365066c0e9d..93ec1767db9 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -458,7 +458,7 @@ private string ComputePathToTool()
                 pathToTool = Path.Combine(ToolPath, ToolExe);
             }
 
-            if (string.IsNullOrWhiteSpace(pathToTool) || ToolPath == null && !FileSystems.Default.FileExists(pathToTool))
+            if (string.IsNullOrWhiteSpace(pathToTool) || (ToolPath == null && !FileSystems.Default.FileExists(pathToTool)))
             {
                 // Otherwise, try to find the tool ourselves.
                 pathToTool = GenerateFullPathToTool();
@@ -607,7 +607,7 @@ string responseFileSwitch
 
             // Generally we won't set a working directory, and it will use the current directory
             string workingDirectory = GetWorkingDirectory();
-            if (null != workingDirectory)
+            if (workingDirectory != null)
             {
                 startInfo.WorkingDirectory = workingDirectory;
             }
@@ -615,7 +615,7 @@ string responseFileSwitch
             // Old style environment overrides
 #pragma warning disable 0618 // obsolete
             Dictionary<string, string> envOverrides = EnvironmentOverride;
-            if (null != envOverrides)
+            if (envOverrides != null)
             {
                 foreach (KeyValuePair<string, string> entry in envOverrides)
                 {
@@ -1307,7 +1307,7 @@ public override bool Execute()
                 {
                     string[] nameValuePair = entry.Split(s_equalsSplitter, 2);
 
-                    if (nameValuePair.Length == 1 || nameValuePair.Length == 2 && nameValuePair[0].Length == 0)
+                    if (nameValuePair.Length == 1 || (nameValuePair.Length == 2 && nameValuePair[0].Length == 0))
                     {
                         LogPrivate.LogErrorWithCodeFromResources("ToolTask.InvalidEnvironmentParameter", nameValuePair[0]);
                         return false;
@@ -1367,7 +1367,6 @@ public override bool Execute()
                     }
                     else
                     {
-
                         Encoding encoding;
 
                         if (Traits.Instance.EscapeHatches.AvoidUnicodeWhenWritingToolTaskBatch)
@@ -1454,7 +1453,7 @@ public override bool Execute()
                 // Old style environment overrides
 #pragma warning disable 0618 // obsolete
                 Dictionary<string, string> envOverrides = EnvironmentOverride;
-                if (null != envOverrides)
+                if (envOverrides != null)
                 {
                     foreach (KeyValuePair<string, string> entry in envOverrides)
                     {
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
index 5351c673e7c..c9a38c060cc 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
@@ -23,7 +23,7 @@ internal static class CanonicalTrackedFilesHelper
         internal static bool RootContainsAllSubRootComponents(string compositeRoot, string compositeSubRoot)
         {
             // If the two are identical, then clearly all keys are present
-            if (string.Compare(compositeRoot, compositeSubRoot, StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(compositeRoot, compositeSubRoot, StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
@@ -93,7 +93,7 @@ private static bool FilesExistAndRecordRequestedWriteTime(ICollection<ITaskItem>
                         break;
                     }
 
-                    if (getNewest && lastWriteTime > requestedTime || !getNewest && lastWriteTime < requestedTime)
+                    if ((getNewest && lastWriteTime > requestedTime) || (!getNewest && lastWriteTime < requestedTime))
                     {
                         requestedTime = lastWriteTime;
                         requestedFilename = item.ItemSpec;
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index be7d6f571f5..86b3892f2a2 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -381,9 +381,9 @@ private ITaskItem[] ComputeSourcesNeedingCompilationFromCompositeRootingMarker(b
             // now that we have our dependencies, we need to check if any of them are newer than the outputs.
             DateTime newestSourceDependencyTime;
             DateTime oldestOutputTime;
-            string newestSourceDependencyFile = string.Empty;
             string oldestOutputFile = string.Empty;
 
+            string newestSourceDependencyFile;
             if (
                 CanonicalTrackedFilesHelper.FilesExistAndRecordNewestWriteTime(sourcesNeedingCompilationList, _log, out newestSourceDependencyTime, out newestSourceDependencyFile) &&
                 CanonicalTrackedFilesHelper.FilesExistAndRecordOldestWriteTime(_outputFileGroup, _log, out oldestOutputTime, out oldestOutputFile)
@@ -424,7 +424,7 @@ private ITaskItem[] ComputeSourcesNeedingCompilationFromCompositeRootingMarker(b
         /// </summary>
         private void SourceDependenciesForOutputRoot(Dictionary<string, ITaskItem> sourceDependencies, string sourceKey, ITaskItem[] filesToIgnore)
         {
-            bool thereAreFilesToIgnore = filesToIgnore != null && filesToIgnore.Length > 0;
+            bool thereAreFilesToIgnore = filesToIgnore?.Length > 0;
 
             if (DependencyTable.TryGetValue(sourceKey, out Dictionary<string, string> dependencies))
             {
@@ -797,7 +797,6 @@ private void ConstructDependencyTable()
                                                 break;
                                             }
 
-
                                             tlogEntry = tlog.ReadLine();
                                         }
                                     }
@@ -867,7 +866,7 @@ public void SaveTlog(DependencyFilter includeInTLog)
         {
             // If there are no tlog files, then this will be a clean build
             // so there is no need to write a new tlog
-            if (_tlogFiles != null && _tlogFiles.Length > 0)
+            if (_tlogFiles?.Length > 0)
             {
                 string tLogRootingMarker = DependencyTableCache.FormatNormalizedTlogRootingMarker(_tlogFiles);
 
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
index 7ca96f897c0..f69120d591e 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
@@ -93,7 +93,7 @@ private void InternalConstruct(ITask ownerTask, ITaskItem[] tlogFiles, bool cons
         /// </summary>
         private void ConstructOutputTable()
         {
-            string tLogRootingMarker = null;
+            string tLogRootingMarker;
             try
             {
                 // construct a rooting marker from the tlog files
diff --git a/src/Utilities/TrackedDependencies/DependencyTableCache.cs b/src/Utilities/TrackedDependencies/DependencyTableCache.cs
index da70034829f..0767897c772 100644
--- a/src/Utilities/TrackedDependencies/DependencyTableCache.cs
+++ b/src/Utilities/TrackedDependencies/DependencyTableCache.cs
@@ -175,7 +175,7 @@ private static string NormalizeTlogPath(string tlogPath)
                 if (i >= 0)
                 {
                     // If we bailed out early, add everything else before reversing the filename itself
-                    normalizedTlogPath.Append(tlogPath.Substring(0, i + 1));
+                    normalizedTlogPath.Append(tlogPath, 0, i + 1);
                 }
 
                 // now add the reversed filename
@@ -208,7 +208,7 @@ public bool Equals(ITaskItem x, ITaskItem y)
                     return true;
                 }
 
-                if (ReferenceEquals(x, null) || ReferenceEquals(y, null))
+                if (x is null || y is null)
                 {
                     return false;
                 }
diff --git a/src/Utilities/TrackedDependencies/FileTracker.cs b/src/Utilities/TrackedDependencies/FileTracker.cs
index 6d20cad9feb..15d8417f515 100644
--- a/src/Utilities/TrackedDependencies/FileTracker.cs
+++ b/src/Utilities/TrackedDependencies/FileTracker.cs
@@ -289,10 +289,10 @@ public static bool FileIsUnderPath(string fileName, string path)
         /// <param name="outputs">ITaskItem array of outputs.</param>
         public static string FormatRootingMarker(ITaskItem[] sources, ITaskItem[] outputs)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(sources, "sources");
+            ErrorUtilities.VerifyThrowArgumentNull(sources, nameof(sources));
 
             // So we don't have to deal with null checks.
-            outputs = outputs ?? Array.Empty<ITaskItem>();
+            outputs ??= Array.Empty<ITaskItem>();
 
             var rootSources = new List<string>(sources.Length + outputs.Length);
 
@@ -641,7 +641,7 @@ public static string TrackerArguments(string command, string arguments, string d
         /// <returns>Process instance</returns>
         public static Process StartProcess(string command, string arguments, ExecutableType toolType, string dllName, string intermediateDirectory, string rootFiles, string cancelEventName)
         {
-            dllName = dllName ?? GetFileTrackerPath(toolType);
+            dllName ??= GetFileTrackerPath(toolType);
 
             string fullArguments = TrackerArguments(command, arguments, dllName, intermediateDirectory, rootFiles, cancelEventName);
             return Process.Start(GetTrackerPath(toolType), fullArguments);
@@ -727,10 +727,7 @@ internal static void LogMessageFromResources(TaskLoggingHelper Log, MessageImpor
         internal static void LogMessage(TaskLoggingHelper Log, MessageImportance importance, string message, params object[] messageArgs)
         {
             // Only log when we have been passed a TaskLoggingHelper
-            if (Log != null)
-            {
-                Log.LogMessage(importance, message, messageArgs);
-            }
+            Log?.LogMessage(importance, message, messageArgs);
         }
 
         /// <summary>
@@ -743,10 +740,7 @@ internal static void LogMessage(TaskLoggingHelper Log, MessageImportance importa
         internal static void LogWarningWithCodeFromResources(TaskLoggingHelper Log, string messageResourceName, params object[] messageArgs)
         {
             // Only log when we have been passed a TaskLoggingHelper
-            if (Log != null)
-            {
-                Log.LogWarningWithCodeFromResources(messageResourceName, messageArgs);
-            }
+            Log?.LogWarningWithCodeFromResources(messageResourceName, messageArgs);
         }
 
         #endregion
diff --git a/src/Utilities/TrackedDependencies/FlatTrackingData.cs b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
index 88b60b0dfc8..f69c68b7a08 100644
--- a/src/Utilities/TrackedDependencies/FlatTrackingData.cs
+++ b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
@@ -223,8 +223,6 @@ public FlatTrackingData(ITaskItem[] tlogFiles, ITaskItem[] tlogFilesToIgnore, Da
             InternalConstruct(null, tlogFiles, tlogFilesToIgnore, false, missingFileTimeUtc, excludedInputPaths);
         }
 
-
-
         /// <summary>
         /// Constructor
         /// </summary>
@@ -613,7 +611,7 @@ private void RecordEntryDetails(string tlogEntry, bool populateTable)
         [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "TLog", Justification = "Has now shipped as public API; plus it's unclear whether 'Tlog' or 'TLog' is the preferred casing")]
         public void SaveTlog(DependencyFilter includeInTLog)
         {
-            if (TlogFiles != null && TlogFiles.Length > 0)
+            if (TlogFiles?.Length > 0)
             {
                 string tLogRootingMarker = DependencyTableCache.FormatNormalizedTlogRootingMarker(TlogFiles);
 
@@ -678,7 +676,6 @@ public DateTime GetLastWriteTimeUtc(string file)
             return fileModifiedTimeUtc;
         }
 
-
         #endregion
 
         #region Static Methods
@@ -848,7 +845,6 @@ public static void FinalizeTLogs(bool trackedOperationsSucceeded, ITaskItem[] re
             // Read the output table, skipping missing files
             FlatTrackingData outputs = new FlatTrackingData(writeTLogNames, true);
 
-
             // If we failed we need to clean the Tlogs
             if (!trackedOperationsSucceeded)
             {
@@ -872,7 +868,7 @@ public static void FinalizeTLogs(bool trackedOperationsSucceeded, ITaskItem[] re
 
                 // In addition to temporary file removal, an optional set of files to remove may be been supplied
 
-                if (trackedFilesToRemoveFromTLogs != null && trackedFilesToRemoveFromTLogs.Length > 0)
+                if (trackedFilesToRemoveFromTLogs?.Length > 0)
                 {
                     IDictionary<string, ITaskItem> trackedFilesToRemove = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);
 
diff --git a/src/Utilities/TrackedDependencies/TrackedDependencies.cs b/src/Utilities/TrackedDependencies/TrackedDependencies.cs
index 802f2164d3a..414a572d4d5 100644
--- a/src/Utilities/TrackedDependencies/TrackedDependencies.cs
+++ b/src/Utilities/TrackedDependencies/TrackedDependencies.cs
@@ -71,7 +71,7 @@ internal static bool ItemsExist(ITaskItem[] files)
         {
             bool allExist = true;
 
-            if (files != null && files.Length > 0)
+            if (files?.Length > 0)
             {
                 foreach (ITaskItem item in files)
                 {
diff --git a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/AssemblyFixtureAttribute.cs b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/AssemblyFixtureAttribute.cs
index 30635a19eaa..a8b28069581 100644
--- a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/AssemblyFixtureAttribute.cs
+++ b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/AssemblyFixtureAttribute.cs
@@ -21,5 +21,4 @@ public enum Scope
             Method
         }
     }
-
 }
diff --git a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestCollectionRunnerWithAssemblyFixture.cs b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestCollectionRunnerWithAssemblyFixture.cs
index f6dc321638b..0d1f5b5c31d 100644
--- a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestCollectionRunnerWithAssemblyFixture.cs
+++ b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestCollectionRunnerWithAssemblyFixture.cs
@@ -24,13 +24,8 @@ public XunitTestCollectionRunnerWithAssemblyFixture(Dictionary<Type, object> ass
                                                             CancellationTokenSource cancellationTokenSource)
             : base(testCollection, testCases, diagnosticMessageSink, messageBus, testCaseOrderer, aggregator, cancellationTokenSource)
         {
-            if (assemblyFixtureAttributes == null)
-            {
-                throw new ArgumentNullException(nameof(assemblyFixtureAttributes));
-            }
-
             this.assemblyFixtureMappings = assemblyFixtureMappings;
-            this.assemblyFixtureAttributes = assemblyFixtureAttributes;
+            this.assemblyFixtureAttributes = assemblyFixtureAttributes ?? throw new ArgumentNullException(nameof(assemblyFixtureAttributes));
             this.diagnosticMessageSink = diagnosticMessageSink;
         }
 
diff --git a/src/Xunit.NetCore.Extensions/Discoverers/ConditionalTestDiscoverer.cs b/src/Xunit.NetCore.Extensions/Discoverers/ConditionalTestDiscoverer.cs
index 711e2f6aa3a..1fc7269cd91 100644
--- a/src/Xunit.NetCore.Extensions/Discoverers/ConditionalTestDiscoverer.cs
+++ b/src/Xunit.NetCore.Extensions/Discoverers/ConditionalTestDiscoverer.cs
@@ -152,11 +152,11 @@ internal static MethodInfo LookupConditionalMethod(Type t, string name)
             TypeInfo ti = t.GetTypeInfo();
 
             MethodInfo mi = ti.GetDeclaredMethod(name);
-            if (mi != null && mi.IsStatic && mi.GetParameters().Length == 0 && mi.ReturnType == typeof(bool))
+            if (mi?.IsStatic == true && mi.GetParameters().Length == 0 && mi.ReturnType == typeof(bool))
                 return mi;
 
             PropertyInfo pi = ti.GetDeclaredProperty(name);
-            if (pi != null && pi.PropertyType == typeof(bool) && pi.GetMethod != null && pi.GetMethod.IsStatic && pi.GetMethod.GetParameters().Length == 0)
+            if (pi?.PropertyType == typeof(bool) && pi.GetMethod?.IsStatic == true && pi.GetMethod.GetParameters().Length == 0)
                 return pi.GetMethod;
 
             return LookupConditionalMethod(ti.BaseType, name);
