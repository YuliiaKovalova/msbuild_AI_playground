diff --git a/ref/net46/Microsoft.Build/Microsoft.Build.cs b/ref/net46/Microsoft.Build/Microsoft.Build.cs
index 625e783443e..2691ff79898 100644
--- a/ref/net46/Microsoft.Build/Microsoft.Build.cs
+++ b/ref/net46/Microsoft.Build/Microsoft.Build.cs
@@ -987,8 +987,10 @@ public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstanc
         public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
         public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
         public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer) { }
+        public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) { }
         public BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
         public BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
+        public BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) { }
         public string ExplicitlySpecifiedToolsVersion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public Microsoft.Build.Execution.BuildRequestDataFlags Flags { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyInstance> GlobalProperties { get { throw null; } }
@@ -996,6 +998,7 @@ public BuildRequestData(string projectFullPath, System.Collections.Generic.IDict
         public string ProjectFullPath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public Microsoft.Build.Execution.ProjectInstance ProjectInstance { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public System.Collections.Generic.IEnumerable<string> PropertiesToTransfer { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public Microsoft.Build.Execution.RequestedProjectState RequestedProjectState { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public System.Collections.Generic.ICollection<string> TargetNames { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
     }
     [System.FlagsAttribute]
@@ -1005,6 +1008,7 @@ public enum BuildRequestDataFlags
         IgnoreExistingProjectState = 4,
         None = 0,
         ProvideProjectStateAfterBuild = 2,
+        ProvideSubsetOfStateAfterBuild = 32,
         ReplaceExistingProjectInstance = 1,
         SkipNonexistentTargets = 16,
     }
@@ -1121,6 +1125,7 @@ public ProjectInstance(string projectFile, System.Collections.Generic.IDictionar
         public Microsoft.Build.Execution.ProjectInstance DeepCopy(bool isImmutable) { throw null; }
         public bool EvaluateCondition(string condition) { throw null; }
         public string ExpandString(string unexpandedValue) { throw null; }
+        public Microsoft.Build.Execution.ProjectInstance FilteredCopy(Microsoft.Build.Execution.RequestedProjectState filter) { throw null; }
         public static string GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance item) { throw null; }
         public static string GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemInstance item) { throw null; }
         public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemInstance> GetItems(string itemType) { throw null; }
@@ -1360,6 +1365,12 @@ internal ProjectTaskOutputPropertyInstance() { }
         public string TaskParameter { get { throw null; } }
         public override Microsoft.Build.Construction.ElementLocation TaskParameterLocation { get { throw null; } }
     }
+    public partial class RequestedProjectState
+    {
+        public RequestedProjectState() { }
+        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>> ItemFilters { get { throw null; } set { } }
+        public System.Collections.Generic.List<string> PropertyFilters { get { throw null; } set { } }
+    }
     public partial class TargetResult : Microsoft.Build.Execution.ITargetResult
     {
         internal TargetResult() { }
diff --git a/ref/netstandard1.3/Microsoft.Build/Microsoft.Build.cs b/ref/netstandard1.3/Microsoft.Build/Microsoft.Build.cs
index 05b2147ce9b..d05f691a537 100644
--- a/ref/netstandard1.3/Microsoft.Build/Microsoft.Build.cs
+++ b/ref/netstandard1.3/Microsoft.Build/Microsoft.Build.cs
@@ -964,8 +964,10 @@ public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstanc
         public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
         public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
         public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer) { }
+        public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) { }
         public BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
         public BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
+        public BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) { }
         public string ExplicitlySpecifiedToolsVersion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public Microsoft.Build.Execution.BuildRequestDataFlags Flags { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyInstance> GlobalProperties { get { throw null; } }
@@ -973,6 +975,7 @@ public BuildRequestData(string projectFullPath, System.Collections.Generic.IDict
         public string ProjectFullPath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public Microsoft.Build.Execution.ProjectInstance ProjectInstance { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public System.Collections.Generic.IEnumerable<string> PropertiesToTransfer { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public Microsoft.Build.Execution.RequestedProjectState RequestedProjectState { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public System.Collections.Generic.ICollection<string> TargetNames { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
     }
     [System.FlagsAttribute]
@@ -982,6 +985,7 @@ public enum BuildRequestDataFlags
         IgnoreExistingProjectState = 4,
         None = 0,
         ProvideProjectStateAfterBuild = 2,
+        ProvideSubsetOfStateAfterBuild = 32,
         ReplaceExistingProjectInstance = 1,
         SkipNonexistentTargets = 16,
     }
@@ -1098,6 +1102,7 @@ public ProjectInstance(string projectFile, System.Collections.Generic.IDictionar
         public Microsoft.Build.Execution.ProjectInstance DeepCopy(bool isImmutable) { throw null; }
         public bool EvaluateCondition(string condition) { throw null; }
         public string ExpandString(string unexpandedValue) { throw null; }
+        public Microsoft.Build.Execution.ProjectInstance FilteredCopy(Microsoft.Build.Execution.RequestedProjectState filter) { throw null; }
         public static string GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance item) { throw null; }
         public static string GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemInstance item) { throw null; }
         public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemInstance> GetItems(string itemType) { throw null; }
@@ -1337,6 +1342,12 @@ internal ProjectTaskOutputPropertyInstance() { }
         public string TaskParameter { get { throw null; } }
         public override Microsoft.Build.Construction.ElementLocation TaskParameterLocation { get { throw null; } }
     }
+    public partial class RequestedProjectState
+    {
+        public RequestedProjectState() { }
+        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>> ItemFilters { get { throw null; } set { } }
+        public System.Collections.Generic.List<string> PropertyFilters { get { throw null; } set { } }
+    }
     public partial class TargetResult : Microsoft.Build.Execution.ITargetResult
     {
         internal TargetResult() { }
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index 80f17420d96..1932db3bd7a 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -26,7 +26,7 @@
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
-
+using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
 using static Microsoft.Build.UnitTests.ObjectModelHelpers;
@@ -340,6 +340,95 @@ public void RunOutOfProcBuild(Action<BuildParameters> buildParametersModifier)
             Assert.NotEqual(Process.GetCurrentProcess().Id, processId); // "Build is expected to be out-of-proc. In fact it was in-proc."
         }
 
+        [Fact]
+        public void RequestedResultsAreSatisfied()
+        {
+            const string contents = @"
+<Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
+<PropertyGroup>
+  <UnrequestedProperty>IsUnrequested</UnrequestedProperty>
+  <RequestedProperty>IsRequested</RequestedProperty>
+  <UpdatedProperty>Stale</UpdatedProperty>
+</PropertyGroup>
+<ItemGroup>
+  <AnItem Include='Item1' UnexpectedMetadatum='Unexpected' />
+  <AnItem Include='Item2'/>
+</ItemGroup>
+<Target Name='test' Returns='@(ItemWithMetadata)'>
+  <ItemGroup>
+    <AnItem Include='$([System.Diagnostics.Process]::GetCurrentProcess().Id)' />
+    <ItemWithMetadata Metadatum1='m1' Metadatum2='m2' Include='ItemFromTarget' />
+  </ItemGroup>
+  <PropertyGroup>
+    <NewProperty>FunValue</NewProperty>
+    <UpdatedProperty>Updated</UpdatedProperty>
+  </PropertyGroup>
+  <Message Text='[success]'/>
+</Target>
+
+<Target Name='other' Returns='@(ItemWithMetadata)' DependsOnTargets='test' />
+
+</Project>
+";
+
+            // Need to set this env variable to enable Process.GetCurrentProcess().Id in the project file.
+            _env.SetEnvironmentVariable("MSBUILDENABLEALLPROPERTYFUNCTIONS", "1");
+
+            Project project = CreateProject(CleanupFileContents(contents), MSBuildDefaultToolsVersion,
+                _projectCollection, false);
+
+            var requestedProjectState = new RequestedProjectState
+            {
+                ItemFilters = new Dictionary<string, List<string>>
+                {
+                    {"AnItem", null},
+                    {"ItemWithMetadata", new List<string> {"Metadatum1"}},
+                },
+                PropertyFilters = new List<string> {"NewProperty", "RequestedProperty"},
+            };
+
+            BuildRequestData data = new BuildRequestData(project.CreateProjectInstance(), new [] {"test", "other"},
+                _projectCollection.HostServices, BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild, null,
+                requestedProjectState);
+            BuildParameters customparameters = new BuildParameters
+            {
+                EnableNodeReuse = false,
+                Loggers = new ILogger[] {_logger},
+                DisableInProcNode = true,
+            };
+
+            BuildResult result = _buildManager.Build(customparameters, data);
+
+            result.OverallResult.ShouldBe(BuildResultCode.Success);
+
+            result.ProjectStateAfterBuild.ShouldNotBeNull();
+
+            result.ProjectStateAfterBuild.Properties.ShouldNotContain(p => p.Name == "UnrequestedProperty");
+
+            result.ProjectStateAfterBuild.Properties.ShouldContain(p => p.Name == "NewProperty");
+            result.ProjectStateAfterBuild.GetPropertyValue("NewProperty").ShouldBe("FunValue");
+
+            result.ProjectStateAfterBuild.Properties.ShouldContain(p => p.Name == "RequestedProperty");
+            result.ProjectStateAfterBuild.GetPropertyValue("RequestedProperty").ShouldBe("IsRequested");
+
+            result.ProjectStateAfterBuild.Items.Count.ShouldBe(4);
+
+            result.ProjectStateAfterBuild.GetItems("ItemWithMetadata").ShouldHaveSingleItem();
+            result.ProjectStateAfterBuild.GetItems("ItemWithMetadata").First().DirectMetadataCount.ShouldBe(1);
+            result.ProjectStateAfterBuild.GetItems("ItemWithMetadata").First().GetMetadataValue("Metadatum1")
+                .ShouldBe("m1");
+            result.ProjectStateAfterBuild.GetItems("ItemWithMetadata").First().GetMetadataValue("Metadatum2")
+                .ShouldBeNullOrEmpty();
+
+            result.ProjectStateAfterBuild.GetItems("AnItem").Count.ShouldBe(3);
+            result.ProjectStateAfterBuild.GetItems("AnItem").ShouldContain(p => p.EvaluatedInclude == "Item2");
+
+            result.ProjectStateAfterBuild.GetItemsByItemTypeAndEvaluatedInclude("AnItem", "Item1")
+                .ShouldHaveSingleItem();
+            result.ProjectStateAfterBuild.GetItemsByItemTypeAndEvaluatedInclude("AnItem", "Item1").First()
+                .GetMetadataValue("UnexpectedMetadatum").ShouldBe("Unexpected");
+        }
+
         /// <summary>
         /// Make sure when we are doing an in-process build that even if the environment variable MSBUILDFORWARDPROPERTIESFROMCHILD is set that we still 
         /// get all of the initial properties.
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index f2c86d59c06..dbacd91aa65 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -863,7 +863,8 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread
                     submission.BuildRequestData.HostServices,
                     BuildEventContext.Invalid,
                     null,
-                    submission.BuildRequestData.Flags);
+                    submission.BuildRequestData.Flags,
+                    submission.BuildRequestData.RequestedProjectState);
 
                 if (_shuttingDown)
                 {
diff --git a/src/Build/BackEnd/BuildManager/BuildRequestData.cs b/src/Build/BackEnd/BuildManager/BuildRequestData.cs
index 556f1fd8e28..7e338884cea 100644
--- a/src/Build/BackEnd/BuildManager/BuildRequestData.cs
+++ b/src/Build/BackEnd/BuildManager/BuildRequestData.cs
@@ -33,7 +33,7 @@ public enum BuildRequestDataFlags
         ReplaceExistingProjectInstance = 1 << 0,
 
         /// <summary>
-        /// When this flag is present, <see cref="BuildResult"/> issued in response to this request will
+        /// When this flag is present, the <see cref="BuildResult"/> issued in response to this request will
         /// include <see cref="BuildResult.ProjectStateAfterBuild"/>.
         /// </summary>
         ProvideProjectStateAfterBuild = 1 << 1,
@@ -68,7 +68,14 @@ public enum BuildRequestDataFlags
         /// are not defined in the Project to build. This only applies to this build request (if another target calls
         /// the "missing target" at any other point this will still result in an error).
         /// </summary>
-        SkipNonexistentTargets = 1 << 4
+        SkipNonexistentTargets = 1 << 4,
+
+        /// <summary>
+        /// When this flag is present, the <see cref="BuildResult"/> issued in response to this request will
+        /// include a <see cref="BuildResult.ProjectStateAfterBuild"/> that includes ONLY the
+        /// explicitly-requested properties, items, and metadata.
+        /// </summary>
+        ProvideSubsetOfStateAfterBuild = 1 << 5,
     }
 
     /// <summary>
@@ -138,6 +145,24 @@ public BuildRequestData(ProjectInstance projectInstance, string[] targetsToBuild
             }
         }
 
+        /// <summary>
+        /// Constructs a BuildRequestData for build requests based on project instances.
+        /// </summary>
+        /// <param name="projectInstance">The instance to build.</param>
+        /// <param name="targetsToBuild">The targets to build.</param>
+        /// <param name="hostServices">The host services to use, if any.  May be null.</param>
+        /// <param name="flags">Flags controlling this build request.</param>
+        /// <param name="propertiesToTransfer">The list of properties whose values should be transferred from the project to any out-of-proc node.</param>
+        /// <param name="requestedProjectState">A <see cref="Execution.RequestedProjectState"/> describing properties, items, and metadata that should be returned. Requires setting <see cref="BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild"/>.</param>
+        public BuildRequestData(ProjectInstance projectInstance, string[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags, IEnumerable<string> propertiesToTransfer, RequestedProjectState requestedProjectState)
+            : this(projectInstance, targetsToBuild, hostServices, flags, propertiesToTransfer)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(requestedProjectState, nameof(requestedProjectState));
+
+            this.RequestedProjectState = requestedProjectState;
+        }
+
+
         /// <summary>
         /// Constructs a BuildRequestData for build requests based on project files.
         /// </summary>
@@ -151,6 +176,26 @@ public BuildRequestData(string projectFullPath, IDictionary<string, string> glob
         {
         }
 
+        /// <summary>
+        /// Constructs a BuildRequestData for build requests based on project files.
+        /// </summary>
+        /// <param name="projectFullPath">The full path to the project file.</param>
+        /// <param name="globalProperties">The global properties which should be used during evaluation of the project.  Cannot be null.</param>
+        /// <param name="toolsVersion">The tools version to use for the build.  May be null.</param>
+        /// <param name="targetsToBuild">The targets to build.</param>
+        /// <param name="hostServices">The host services to use.  May be null.</param>
+        /// <param name="flags">The <see cref="BuildRequestDataFlags"/> to use.</param>
+        /// <param name="requestedProjectState">A <see cref="Execution.RequestedProjectState"/> describing properties, items, and metadata that should be returned. Requires setting <see cref="BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild"/>.</param>
+        public BuildRequestData(string projectFullPath, IDictionary<string, string> globalProperties,
+            string toolsVersion, string[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags,
+            RequestedProjectState requestedProjectState)
+            : this(projectFullPath, globalProperties, toolsVersion, targetsToBuild, hostServices, flags)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(requestedProjectState, nameof(requestedProjectState));
+
+            this.RequestedProjectState = requestedProjectState;
+        }
+
         /// <summary>
         /// Constructs a BuildRequestData for build requests based on project files.
         /// </summary>
@@ -268,6 +313,16 @@ public IEnumerable<string> PropertiesToTransfer
             private set;
         }
 
+        /// <summary>
+        /// Returns the properties, items, and metadata that will be returned
+        /// by this build.
+        /// </summary>
+        public RequestedProjectState RequestedProjectState
+        {
+            get;
+            private set;
+        }
+
         /// <summary>
         /// Whether the tools version used originated from an explicit specification,
         /// for example from an MSBuild task or /tv switch.
diff --git a/src/Build/BackEnd/BuildManager/RequestedProjectState.cs b/src/Build/BackEnd/BuildManager/RequestedProjectState.cs
new file mode 100644
index 00000000000..94c1b248cd8
--- /dev/null
+++ b/src/Build/BackEnd/BuildManager/RequestedProjectState.cs
@@ -0,0 +1,57 @@
+ï»¿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.BackEnd;
+
+namespace Microsoft.Build.Execution
+{
+    /// <summary>
+    /// Interface defining properties, items, and metadata of interest for a <see cref="BuildRequestData"/>.
+    /// </summary>
+    public class RequestedProjectState : INodePacketTranslatable
+    {
+        private List<string> _propertyFilters;
+        private IDictionary<string, List<string>> _itemFilters;
+
+        /// <summary>
+        /// Properties of interest.
+        /// </summary>
+        public List<string> PropertyFilters
+        {
+            get { return _propertyFilters; }
+            set { _propertyFilters = value; }
+        }
+
+        /// <summary>
+        /// Items and metadata of interest.
+        /// </summary>
+        public IDictionary<string, List<string>> ItemFilters
+        {
+            get { return _itemFilters; }
+            set { _itemFilters = value; }
+        }
+
+        void INodePacketTranslatable.Translate(INodePacketTranslator translator)
+        {
+            translator.Translate(ref _propertyFilters);
+            translator.TranslateDictionary(ref _itemFilters, TranslateString, TranslateMetadataForItem, CreateItemMetadataDictionary);
+        }
+
+        private IDictionary<string, List<string>> CreateItemMetadataDictionary(int capacity)
+        {
+            return new Dictionary<string, List<string>>(capacity, StringComparer.OrdinalIgnoreCase);
+        }
+
+        private void TranslateMetadataForItem(ref List<string> list, INodePacketTranslator translator)
+        {
+            translator.Translate(ref list);
+        }
+
+        private void TranslateString(ref string s, INodePacketTranslator translator)
+        {
+            translator.Translate(ref s);
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index e35ae2a8397..15db63ca85b 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -196,11 +196,18 @@ public async Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext
                 resultsToReport.ProjectStateAfterBuild = _projectInstance;
             }
 
+            if (_requestEntry.Request.RequestedProjectState != null)
+            {
+                resultsToReport.ProjectStateAfterBuild =
+                    _projectInstance.FilteredCopy(_requestEntry.Request.RequestedProjectState);
+            }
+
             configuration.IsCacheable = previousCacheableStatus;
 
             return resultsToReport;
         }
 
+
         #region IBuildComponent Members
 
         /// <summary>
diff --git a/src/Build/BackEnd/Shared/BuildRequest.cs b/src/Build/BackEnd/Shared/BuildRequest.cs
index 587aabdb74b..c4c4222b345 100644
--- a/src/Build/BackEnd/Shared/BuildRequest.cs
+++ b/src/Build/BackEnd/Shared/BuildRequest.cs
@@ -88,6 +88,11 @@ internal class BuildRequest : INodePacket
         /// </summary>
         private BuildRequestDataFlags _buildRequestDataFlags;
 
+        /// <summary>
+        /// Filter describing properties, items, and metadata of interest for this request.
+        /// </summary>
+        private RequestedProjectState _requestedProjectState;
+
         /// <summary>
         /// If set, skip targets that are not defined in the projects to be built.
         /// </summary>
@@ -111,6 +116,7 @@ public BuildRequest()
         /// <param name="parentBuildEventContext">The build event context of the parent project.</param>
         /// <param name="parentRequest">The parent build request, if any.</param>
         /// <param name="buildRequestDataFlags">Additional flags for the request.</param>
+        /// <param name="requestedProjectState">Filter for desired build results.</param>
         public BuildRequest(
             int submissionId,
             int nodeRequestId,
@@ -119,7 +125,8 @@ public BuildRequest(
             HostServices hostServices,
             BuildEventContext parentBuildEventContext,
             BuildRequest parentRequest,
-            BuildRequestDataFlags buildRequestDataFlags = BuildRequestDataFlags.None)
+            BuildRequestDataFlags buildRequestDataFlags = BuildRequestDataFlags.None,
+            RequestedProjectState requestedProjectState = null)
         {
             ErrorUtilities.VerifyThrowArgumentNull(escapedTargets, "targets");
             ErrorUtilities.VerifyThrowArgumentNull(parentBuildEventContext, "parentBuildEventContext");
@@ -142,6 +149,7 @@ public BuildRequest(
 
             _nodeRequestId = nodeRequestId;
             _buildRequestDataFlags = buildRequestDataFlags;
+            _requestedProjectState = requestedProjectState;
         }
 
         /// <summary>
@@ -281,6 +289,16 @@ public BuildRequestDataFlags BuildRequestDataFlags
             set { _buildRequestDataFlags = value; }
         }
 
+        /// <summary>
+        /// Filter describing properties, items, and metadata of interest for this request.
+        /// </summary>
+        public RequestedProjectState RequestedProjectState
+        {
+            get { return _requestedProjectState; }
+            set { _requestedProjectState = value; }
+        }
+
+
         /// <summary>
         /// The route for host-aware tasks back to the host
         /// </summary>
@@ -338,6 +356,7 @@ public void Translate(INodePacketTranslator translator)
             translator.Translate(ref _buildEventContext);
             translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);
             translator.Translate(ref _skipNonexistentTargets);
+            translator.Translate(ref _requestedProjectState);
 
             // UNDONE: (Compat) Serialize the host object.
         }
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index 318b4cd6011..d18b1160ab5 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -110,10 +110,11 @@ public class BuildResult : INodePacket, IBuildResults
 
         /// <summary>
         /// <see cref="ProjectInstance"/> state after the build. This is only provided if <see cref="BuildRequest.BuildRequestDataFlags"/>
-        /// includes <see cref="BuildRequestDataFlags.ProvideProjectStateAfterBuild"/> for the build request which this object is a result of, 
-        /// and will be <c>null</c> otherwise.  In general, where available, it may be a non buildable-dummy object, and should only
+        /// includes <see cref="BuildRequestDataFlags.ProvideProjectStateAfterBuild"/> or
+        /// <see cref="BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild"/> for the build request which this object is a result of,
+        /// and will be <c>null</c> otherwise. Where available, it may be a non buildable-dummy object, and should only
         /// be used to retrieve <see cref="ProjectInstance.Properties"/>, <see cref="ProjectInstance.GlobalProperties"/> and
-        /// <see cref="ProjectInstance.Items"/> from it. Any other operation is not guaranteed to be supported.
+        /// <see cref="ProjectInstance.Items"/> from it. No other operation is guaranteed to be supported.
         /// </summary>
         private ProjectInstance _projectStateAfterBuild;
 
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index ef14cd2ca55..91ad6090e0e 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -474,8 +474,11 @@ private ProjectInstance(ProjectInstance that)
         /// Deep clone of this object.
         /// Useful for compiling a single file; or for keeping resolved assembly references between builds.
         /// </summary>
-        private ProjectInstance(ProjectInstance that, bool isImmutable)
+        private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProjectState filter = null)
         {
+            ErrorUtilities.VerifyThrow(filter == null || isImmutable,
+                "The result of a filtered ProjectInstance clone must be immutable.");
+
             _directory = that._directory;
             _projectFileLocation = that._projectFileLocation;
             _hostServices = that._hostServices;
@@ -484,50 +487,146 @@ private ProjectInstance(ProjectInstance that, bool isImmutable)
 
             TranslateEntireState = that.TranslateEntireState;
 
-            _properties = new PropertyDictionary<ProjectPropertyInstance>(that._properties.Count);
-
-            foreach (ProjectPropertyInstance property in that.Properties)
+            if (filter == null)
             {
-                _properties.Set(property.DeepClone(_isImmutable));
-            }
+                _properties = new PropertyDictionary<ProjectPropertyInstance>(that._properties.Count);
 
-            _items = new ItemDictionary<ProjectItemInstance>(that._items.ItemTypes.Count);
+                foreach (ProjectPropertyInstance property in that.Properties)
+                {
+                    _properties.Set(property.DeepClone(_isImmutable));
+                }
 
-            foreach (ProjectItemInstance item in that.Items)
-            {
-                _items.Add(item.DeepClone(this));
-            }
+                _items = new ItemDictionary<ProjectItemInstance>(that._items.ItemTypes.Count);
 
-            _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(that._globalProperties.Count);
+                foreach (ProjectItemInstance item in that.Items)
+                {
+                    _items.Add(item.DeepClone(this));
+                }
 
-            foreach (ProjectPropertyInstance globalProperty in that.GlobalPropertiesDictionary)
-            {
-                _globalProperties.Set(globalProperty.DeepClone(_isImmutable));
-            }
+                _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(that._globalProperties.Count);
 
-            _environmentVariableProperties = new PropertyDictionary<ProjectPropertyInstance>(that._environmentVariableProperties.Count);
+                foreach (ProjectPropertyInstance globalProperty in that.GlobalPropertiesDictionary)
+                {
+                    _globalProperties.Set(globalProperty.DeepClone(_isImmutable));
+                }
 
-            foreach (ProjectPropertyInstance environmentProperty in that._environmentVariableProperties)
-            {
-                _environmentVariableProperties.Set(environmentProperty.DeepClone(_isImmutable));
+                _environmentVariableProperties =
+                    new PropertyDictionary<ProjectPropertyInstance>(that._environmentVariableProperties.Count);
+
+                foreach (ProjectPropertyInstance environmentProperty in that._environmentVariableProperties)
+                {
+                    _environmentVariableProperties.Set(environmentProperty.DeepClone(_isImmutable));
+                }
+
+                this.DefaultTargets = new List<string>(that.DefaultTargets);
+                this.InitialTargets = new List<string>(that.InitialTargets);
+                ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance,
+                    ProjectItemDefinitionInstance>) this).BeforeTargets = CreateCloneDictionary(
+                    ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance,
+                        ProjectItemDefinitionInstance>) that).BeforeTargets, StringComparer.OrdinalIgnoreCase);
+                ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance,
+                    ProjectItemDefinitionInstance>) this).AfterTargets = CreateCloneDictionary(
+                    ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance,
+                        ProjectItemDefinitionInstance>) that).AfterTargets, StringComparer.OrdinalIgnoreCase);
+                this.TaskRegistry =
+                    that.TaskRegistry; // UNDONE: This isn't immutable, should be cloned or made immutable; it currently has a pointer to project collection
+
+                // These are immutable so we don't need to clone them:
+                this.Toolset = that.Toolset;
+                this.SubToolsetVersion = that.SubToolsetVersion;
+                _targets = that._targets;
+                _itemDefinitions = that._itemDefinitions;
+                _explicitToolsVersionSpecified = that._explicitToolsVersionSpecified;
+
+                this.EvaluatedItemElements = that.EvaluatedItemElements;
+
+                this.ProjectRootElementCache = that.ProjectRootElementCache;
             }
+            else
+            {
+                if (filter.PropertyFilters != null)
+                {
+                    // If PropertyFilters is defined, filter all types of property to contain
+                    // only those explicitly specified.
+
+                    // Reserve space assuming all specified properties exist.
+                    _properties = new PropertyDictionary<ProjectPropertyInstance>(filter.PropertyFilters.Count);
+                    _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(filter.PropertyFilters.Count);
+                    _environmentVariableProperties =
+                        new PropertyDictionary<ProjectPropertyInstance>(filter.PropertyFilters.Count);
+
+                    // Filter each type of property.
+                    foreach (var desiredProperty in filter.PropertyFilters)
+                    {
+                        var regularProperty = that.GetProperty(desiredProperty);
+                        if (regularProperty != null)
+                        {
+                            _properties.Set(regularProperty.DeepClone(isImmutable: true));
+                        }
 
-            this.DefaultTargets = new List<string>(that.DefaultTargets);
-            this.InitialTargets = new List<string>(that.InitialTargets);
-            ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)this).BeforeTargets = CreateCloneDictionary(((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)that).BeforeTargets, StringComparer.OrdinalIgnoreCase);
-            ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)this).AfterTargets = CreateCloneDictionary(((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)that).AfterTargets, StringComparer.OrdinalIgnoreCase);
-            this.TaskRegistry = that.TaskRegistry; // UNDONE: This isn't immutable, should be cloned or made immutable; it currently has a pointer to project collection
+                        var globalProperty = that.GetProperty(desiredProperty);
+                        if (globalProperty != null)
+                        {
+                            _globalProperties.Set(globalProperty.DeepClone(isImmutable: true));
+                        }
 
-            // These are immutable so we don't need to clone them:
-            this.Toolset = that.Toolset;
-            this.SubToolsetVersion = that.SubToolsetVersion;
-            _targets = that._targets;
-            _itemDefinitions = that._itemDefinitions;
-            _explicitToolsVersionSpecified = that._explicitToolsVersionSpecified;
+                        var environmentProperty = that.GetProperty(desiredProperty);
+                        if (environmentProperty != null)
+                        {
+                            _environmentVariableProperties.Set(environmentProperty.DeepClone(isImmutable: true));
+                        }
+                    }
+                }
 
-            this.EvaluatedItemElements = that.EvaluatedItemElements;
+                if (filter.ItemFilters != null)
+                {
+                    // If ItemFilters is defined, filter items down to the list
+                    // specified, optionally also filtering metadata.
+
+                    // Temporarily allow editing items to remove metadata that
+                    // wasn't explicitly asked for.
+                    _isImmutable = false;
+
+                    _items = new ItemDictionary<ProjectItemInstance>(that.Items.Count);
 
-            this.ProjectRootElementCache = that.ProjectRootElementCache;
+                    foreach (var itemFilter in filter.ItemFilters)
+                    {
+                        foreach (var actualItem in that.GetItems(itemFilter.Key))
+                        {
+                            var filteredItem = actualItem.DeepClone(this);
+
+                            if (itemFilter.Value == null)
+                            {
+                                // No specified list of metadata names, so include all metadata.
+                                // The returned list of items is still filtered by item name.
+                            }
+                            else
+                            {
+                                // Include only the explicitly-asked-for metadata by removing
+                                // any extant metadata.
+                                // UNDONE: This could be achieved at lower GC cost by applying
+                                // the metadata filter at DeepClone time above.
+                                foreach (var metadataName in filteredItem.MetadataNames)
+                                {
+                                    if (!itemFilter.Value.Contains(metadataName, StringComparer.OrdinalIgnoreCase))
+                                    {
+                                        filteredItem.RemoveMetadata(metadataName);
+                                    }
+                                }
+                            }
+
+                            _items.Add(filteredItem);
+                        }
+                    }
+
+                    // Restore immutability after editing newly cloned items.
+                    _isImmutable = isImmutable;
+
+                    // A filtered result is not useful for building anyway; ensure that
+                    // it has minimal IPC wire cost.
+                    _translateEntireState = false;
+                }
+            }
         }
 
         /// <summary>
@@ -1477,6 +1576,21 @@ public ProjectInstance DeepCopy()
             return DeepCopy(_isImmutable);
         }
 
+        /// <summary>
+        /// Create an independent clone of this object, keeping ONLY the explicitly
+        /// requested project state.
+        /// </summary>
+        /// <remarks>
+        /// Useful for reducing the wire cost of IPC for out-of-proc nodes used during
+        /// design-time builds that only need to populate a known set of data.
+        /// </remarks>
+        /// <param name="filter">Project state that should be returned.</param>
+        /// <returns></returns>
+        public ProjectInstance FilteredCopy(RequestedProjectState filter)
+        {
+            return new ProjectInstance(this, true, filter);
+        }
+
         /// <summary>
         /// Create an independent, deep clone of this object and everything in it, with
         /// specified mutability.
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 5622e32cab8..eb2ee26dc72 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -193,6 +193,7 @@
     <Compile Include="BackEnd\BuildManager\BuildParameters.cs" />
     <Compile Include="BackEnd\BuildManager\BuildSubmission.cs" />
     <Compile Include="BackEnd\BuildManager\LegacyThreadingData.cs" />
+    <Compile Include="BackEnd\BuildManager\RequestedProjectState.cs" />
     <Compile Include="BackEnd\Components\BuildComponentFactoryCollection.cs" />
     <Compile Include="BackEnd\Components\Caching\IRegisteredTaskObjectCache.cs" />
     <Compile Include="..\Shared\RegisteredTaskObjectCacheBase.cs" />
