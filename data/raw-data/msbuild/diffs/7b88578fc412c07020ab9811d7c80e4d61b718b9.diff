diff --git a/.gitignore b/.gitignore
index e902f62318d..bdbfe5b0367 100644
--- a/.gitignore
+++ b/.gitignore
@@ -31,7 +31,6 @@ artifacts/
 *.pdb
 *.pgc
 *.pgd
-*.rsp
 *.sbr
 *.tlb
 *.tli
@@ -136,12 +135,6 @@ csx/
 # Windows Store app package directory
 AppPackages/
 
-# Visual Studio cache files
-# files ending in .cache can be ignored
-*.[Cc]ache
-# but keep track of directories ending in .cache
-!*.[Cc]ache/
-
 # Others
 ClientBin/
 [Ss]tyle[Cc]op.*
@@ -220,5 +213,5 @@ Samples/MultiprocessBuild/PortableTask.dll
 stage1/
 .tools
 
-# ETL traces    
-*.etl.zip
\ No newline at end of file
+# ETL traces
+*.etl.zip
diff --git a/MSBuild.lutconfig b/MSBuild.lutconfig
new file mode 100644
index 00000000000..35293b3ca5e
--- /dev/null
+++ b/MSBuild.lutconfig
@@ -0,0 +1,7 @@
+<LUTConfig Version="1.0">
+  <Repository />
+  <ParallelBuilds>true</ParallelBuilds>
+  <ParallelTestRuns>true</ParallelTestRuns>
+  <EnablePdbs>true</EnablePdbs>
+  <TestCaseTimeout>180000</TestCaseTimeout>
+</LUTConfig>
diff --git a/MSBuild.sln b/MSBuild.sln
index cb3f5c85d02..75b985cb7be 100644
--- a/MSBuild.sln
+++ b/MSBuild.sln
@@ -75,6 +75,8 @@ Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "ProjectCachePlugin", "src\S
 EndProject
 Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "StringTools.Benchmark", "src\StringTools.Benchmark\StringTools.Benchmark.csproj", "{65749C80-47E7-42FE-B441-7A86289D46AA}"
 EndProject
+Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MSBuild.VSSetup.Arm64", "src\Package\MSBuild.VSSetup.Arm64\MSBuild.VSSetup.Arm64.csproj", "{71E59632-D644-491B-AF93-22BC93167C56}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
@@ -1019,46 +1021,6 @@ Global
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug|ARM64.ActiveCfg = Debug|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug|ARM64.Build.0 = Debug|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug|x64.ActiveCfg = Debug|x64
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug|x64.Build.0 = Debug|x64
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug|x86.ActiveCfg = Debug|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug|x86.Build.0 = Debug|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug-MONO|x64.ActiveCfg = Debug|x64
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug-MONO|x64.Build.0 = Debug|x64
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug-MONO|x86.ActiveCfg = Debug|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug-MONO|x86.Build.0 = Debug|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release|Any CPU.Build.0 = Release|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release|ARM64.ActiveCfg = Release|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release|ARM64.Build.0 = Release|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release|x64.ActiveCfg = Release|x64
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release|x64.Build.0 = Release|x64
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release|x86.ActiveCfg = Release|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release|x86.Build.0 = Release|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release-MONO|x64.Build.0 = Release-MONO|x64
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
-		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Debug|ARM64.ActiveCfg = Debug|Any CPU
@@ -1339,6 +1301,46 @@ Global
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.Debug|ARM64.ActiveCfg = Debug|arm64
+		{71E59632-D644-491B-AF93-22BC93167C56}.Debug|ARM64.Build.0 = Debug|arm64
+		{71E59632-D644-491B-AF93-22BC93167C56}.Debug|x64.ActiveCfg = Debug|x64
+		{71E59632-D644-491B-AF93-22BC93167C56}.Debug|x64.Build.0 = Debug|x64
+		{71E59632-D644-491B-AF93-22BC93167C56}.Debug|x86.ActiveCfg = Debug|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.Debug|x86.Build.0 = Debug|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|arm64
+		{71E59632-D644-491B-AF93-22BC93167C56}.Debug-MONO|ARM64.Build.0 = Debug-MONO|arm64
+		{71E59632-D644-491B-AF93-22BC93167C56}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
+		{71E59632-D644-491B-AF93-22BC93167C56}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
+		{71E59632-D644-491B-AF93-22BC93167C56}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|arm64
+		{71E59632-D644-491B-AF93-22BC93167C56}.MachineIndependent|ARM64.Build.0 = MachineIndependent|arm64
+		{71E59632-D644-491B-AF93-22BC93167C56}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
+		{71E59632-D644-491B-AF93-22BC93167C56}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
+		{71E59632-D644-491B-AF93-22BC93167C56}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release|Any CPU.Build.0 = Release|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release|ARM64.ActiveCfg = Release|arm64
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release|ARM64.Build.0 = Release|arm64
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release|x64.ActiveCfg = Release|x64
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release|x64.Build.0 = Release|x64
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release|x86.ActiveCfg = Release|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release|x86.Build.0 = Release|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release-MONO|ARM64.ActiveCfg = Release-MONO|arm64
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release-MONO|ARM64.Build.0 = Release-MONO|arm64
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release-MONO|x64.Build.0 = Release-MONO|x64
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
@@ -1356,6 +1358,7 @@ Global
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9} = {9BAD9352-DEFB-45E5-B8A4-4816B9B22A33}
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F} = {9BAD9352-DEFB-45E5-B8A4-4816B9B22A33}
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943} = {760FF85D-8BEB-4992-8095-A9678F88FD47}
+		{71E59632-D644-491B-AF93-22BC93167C56} = {9BAD9352-DEFB-45E5-B8A4-4816B9B22A33}
 	EndGlobalSection
 	GlobalSection(ExtensibilityGlobals) = postSolution
 		SolutionGuid = {F948D667-14E3-4F98-BA50-3F3C948BF4C2}
diff --git a/README.md b/README.md
index 20d68bf2708..d96c05bcda0 100644
--- a/README.md
+++ b/README.md
@@ -12,9 +12,9 @@ The current development branch is `main`. Changes in `main` will go into a futur
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=main)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=main)
 
-We have forked for MSBuild 17.1 in the branch [`vs17.1`](https://github.com/Microsoft/msbuild/tree/vs17.1). Changes to that branch need special approval.
+We have forked for MSBuild 17.2 in the branch [`vs17.2`](https://github.com/Microsoft/msbuild/tree/vs17.2). Changes to that branch need special approval.
 
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs17.1)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs17.1)
+[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs17.2)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs17.2)
 
 17.0 builds from the branch [`vs17.0`](https://github.com/Microsoft/msbuild/tree/vs17.0). Only high-priority bugfixes will be considered for servicing 17.0.
 
@@ -24,14 +24,10 @@ We have forked for MSBuild 17.1 in the branch [`vs17.1`](https://github.com/Micr
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.11)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs16.11)
 
-MSBuild 16.9 builds from the branch [`vs16.9`](https://github.com/dotnet/msbuild/tree/vs16.9). Only high-priority bugfixes will be considered for servicing 16.9.
+MSBuild 16.9 builds from the branch [`vs16.9`](https://github.com/dotnet/msbuild/tree/vs16.9). Only very-high-priority bugfixes will be considered for servicing 16.9.
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.9)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs16.9)
 
-MSBuild 16.7 builds from the branch [`vs16.7`](https://github.com/dotnet/msbuild/tree/vs16.7). Only high-priority bugfixes will be considered for servicing 16.7.
-
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.7)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs16.7)
-
 MSBuild 15.9 builds from the branch [`vs15.9`](https://github.com/dotnet/msbuild/tree/vs15.9). Only very-high-priority bugfixes will be considered for servicing 15.9.
 
 ## Building
diff --git a/documentation/specs/event-source.md b/documentation/specs/event-source.md
index 18936da2249..664a32ac397 100644
--- a/documentation/specs/event-source.md
+++ b/documentation/specs/event-source.md
@@ -33,7 +33,9 @@ EventSource is primarily used to profile code. For MSBuild specifically, a major
 | ReusableStringBuilderFactoryUnbalanced | Identifies improper usage from multiple threads or buggy code: multiple Gets were called without a Relase. |
 | Save | Saves a project to the file system if dirty, creating directories as necessary. |
 | SdkResolverResolveSdk | A single SDK resolver is called. |
-| SdkResolverServiceInitialize | Initializes SDK resolvers. |
+| SdkResolverServiceFindResolversManifests | Find all resolvers manifests. (Only appear under Changewave 17.4.) |
+| SdkResolverServiceInitialize | Initializes SDK resolvers. (Only appear before Changewave 17.4.) |
+| SdkResolverServiceLoadResolvers | Load resolvers given a resolver manifest. (Only appear under Changewave 17.4.) |
 | SdkResolverEvent | An SDK resolver logs an event. |
 | Target | Executes a target. |
 | TargetUpToDate | Checks whether a particular target needs to run or is up-to-date. |
diff --git a/documentation/specs/low-priority-switch.md b/documentation/specs/low-priority-switch.md
new file mode 100644
index 00000000000..ba33826a89e
--- /dev/null
+++ b/documentation/specs/low-priority-switch.md
@@ -0,0 +1,35 @@
+
+# Low Priority Nodes in MSBuild and Visual Studio
+
+## Problem Summary
+
+When doing other work, it can be useful for builds (which often take a long time and consume a lot of resources) to happen in the background, allowing other work to happen in the interim. This is true for both command line builds and builds within Visual Studio.
+
+Visual Studio, on the other hand, should always run at normal priority. This ensures that users can continue to interact with its other features, most notably editing code and seeing intellisense and autocomplete pop up.
+
+## High Level Design
+
+### Requirements
+
+1. A long-lived process can execute a series of builds divided between Normal and BelowNormal priority.
+2. Transitions between a build at Normal priority and one at BelowNormal priority (and vice versa) are fairly efficient, at least on Windows but ideally on all operating systems.
+3. NodeReuse is still possible. That is, another process can (often) use nodes from the long-lived process if NodeReuse is true.
+4. Any reused nodes are at the priority they themselves specify. Normal priority nodes are actually at normal priority, and low priority nodes are actually at BelowNormal priority.
+5. All nodes are at the priority they should be when being used to build even if a normal priority process had connected to them as normal priority worker nodes, and they are now executing a low priority build.
+
+
+## Non-goals
+
+Perfect parity between windows and mac or linux. Windows permits processes to raise their own priority or that of another process, whereas other operating systems do not. This is very efficient, so we should use it. As we expect this feature to be used in Visual Studio, we anticipate it being less used on mac and linux, hence not being as high priority to make it just as efficient.
+
+## Details
+
+Each node (including worker nodes) initially takes its priority from its parent process. Since we now need the priority to align with what it is passed instead of its parent, attempt to adjust priority afterwards if necessary as part of node startup.
+
+BuildManager.cs remembers the priority of the previous build it had executed. If that was set to a value that differs from the priority of the current build:
+1. On windows or when decreasing the priority: lowers the priority of all connected nodes
+2. On linux and mac when increasing the priority: disconnects from all nodes.
+
+When a worker node disconnects from the entrypoint node, it should ensure that it is the priority that would be expected by nodes that successfully connect to it. That means that it should be normal priority if lowPriority is false and BelowNormal priority otherwise.
+
+For this reason, if we intend to reuse a node, we check its priority and adjust it to the expected value if possible. If it proves impossible to adjust to the correct priority, the node shuts down.
diff --git a/documentation/specs/sdk-resolvers-algorithm.md b/documentation/specs/sdk-resolvers-algorithm.md
new file mode 100644
index 00000000000..eb962ad2644
--- /dev/null
+++ b/documentation/specs/sdk-resolvers-algorithm.md
@@ -0,0 +1,28 @@
+## SDK Resolution Algorithm
+In 17.3 under ChangeWave 17.4 the sdk resolution algorithm is changed.
+
+### Reason for change
+Previously (before ChangeWave 17.4) all SDK resolvers were loaded and then ordered by priority. The resolvers are tried one after one until one of them succeeds. In order to decrease the number of assemblies to be load we change the behavior in 17.3 under ChangeWave 17.4.
+
+### New SDK Resolution Algorithm
+Under ChangeWave 17.4 all the resolvers divides into two groups:
+- Specific resolvers, i.e. resolvers with specified sdk name pattern `ResolvableSdkPattern`
+- General resolvers, i.e. resolvers without specified sdk name pattern `ResolvableSdkPattern`
+
+The resolving algorithm works in two passes. 
+- On the first pass all the specific resolvers that match the given sdk name would be loaded, ordered by priority and tried one after one. 
+- If the sdk is not found, on the second pass all general resolvers would be loaded, ordered by priority and tried one after one.
+
+By default the resolvers are general. To make all the resolvers from some dll specific, in the corresponding manifest (xml file) one need to specify the `ResolvableSdkPattern` using C# regex format:
+```
+<SdkResolver>
+  <Path>MySdkResolver.dll</Path>
+  <ResolvableSdkPattern>MySdk.*</ResolvableSdkPattern>
+</SdkResolver>
+```
+
+Note, that the manifest file, if exists, from ChangeWave 17.4 would have preference over the dll.
+The sdk discovery works according to the following algorithm:
+- First try locate the manifest file and use it. 
+- If it is not found, we try to locate the dll in the resolver's folder. 
+Both xml and dll name should match the following name pattern `...\SdkResolvers\(ResolverName)\(ResolverName).(xml/dll)`.
\ No newline at end of file
diff --git a/documentation/wiki/ChangeWaves-Dev.md b/documentation/wiki/ChangeWaves-Dev.md
index a3cfdbcd93f..5158535340c 100644
--- a/documentation/wiki/ChangeWaves-Dev.md
+++ b/documentation/wiki/ChangeWaves-Dev.md
@@ -12,8 +12,11 @@ The opt-out comes in the form of setting the environment variable `MSBuildDisabl
 ## Choosing a Change Wave for a New Feature
 This is determined on a case by case basis and should be discussed with the MSBuild team. A safe bet would be to check our [currently active Change Waves](ChangeWaves.md#change-waves-&-associated-features) and pick the version after the latest MSBuild version. This version corresponds to the latest version of Visual Studio.
 
+### Change Wave Versioning
+Change Wave features should match the LTS version of VS they were released with. Any feature requiring a changewave during a non-LTS release of VS should use the **NEXT** version number.
+
 # Developing With Change Waves in Mind
-For the purpose of providing an example, the rest of this document assumes we're developing a feature for MSBuild version **17.4**.
+For the purpose of providing an example, the rest of this document assumes we're developing a feature for MSBuild version **17.3**.
 
 The Process:
 1. Develop your feature.
@@ -32,7 +35,7 @@ public static readonly Version Wave17_4 = new Version(17, 4);
 3. You may need to delete the lowest wave as new waves get added.
 4. Update the AllWaves array appropriately.
 ```c#
-public static readonly Version[] AllWaves = { Wave16_10, Wave17_0, Wave17_4 };
+public static readonly Version[] AllWaves = { Wave17_0, Wave17_2, Wave17_4 };
 ```
 
 ## Condition Your Feature On A Change Wave
@@ -96,4 +99,4 @@ These features will eventually become standard functionality. When a change wave
 1. Start by deleting the readonly `Wave17_4` that was created in [Creating a Change Wave](#creating-a-change-wave).
 2. Remove `ChangeWave.AreFeaturesEnabled` or `[MSBuild]::AreFeaturesEnabled` conditions surrounding features that were assigned that change wave.
 3. Remove tests associated with ensuring features would not run if this wave were set.
-4. Clear all other issues that arose from deleting the version.
+4. Clear all other issues that arose from deleting the version.
\ No newline at end of file
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 84e2c7fcb2b..2158cd2a8a5 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -22,12 +22,11 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 # Change Waves & Associated Features
 
 ## Current Rotation of Change Waves
-### 16.10
-- [Error when a property expansion in a condition has whitespace](https://github.com/dotnet/msbuild/pull/5672)
-- [Allow Custom CopyToOutputDirectory Location With TargetPath](https://github.com/dotnet/msbuild/pull/6237)
-- [Allow users that have certain special characters in their username to build successfully when using exec](https://github.com/dotnet/msbuild/pull/6223)
-- [Fail restore operations when an SDK is unresolveable](https://github.com/dotnet/msbuild/pull/6430)
-- [Optimize glob evaluation](https://github.com/dotnet/msbuild/pull/6151)
+
+### 17.4
+- [Respect deps.json when loading assemblies](https://github.com/dotnet/msbuild/pull/7520)
+- [Consider `Platform` as default during Platform Negotiation](https://github.com/dotnet/msbuild/pull/7511)
+- [Adding accepted SDK name match pattern to SDK manifests](https://github.com/dotnet/msbuild/pull/7597)
 
 ### 17.0
 - [Scheduler should honor BuildParameters.DisableInprocNode](https://github.com/dotnet/msbuild/pull/6400)
@@ -47,3 +46,10 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Enable NoWarn](https://github.com/dotnet/msbuild/pull/5671)
 - [Truncate Target/Task skipped log messages to 1024 chars](https://github.com/dotnet/msbuild/pull/5553)
 - [Don't expand full drive globs with false condition](https://github.com/dotnet/msbuild/pull/5669)
+
+### 16.10
+- [Error when a property expansion in a condition has whitespace](https://github.com/dotnet/msbuild/pull/5672)
+- [Allow Custom CopyToOutputDirectory Location With TargetPath](https://github.com/dotnet/msbuild/pull/6237)
+- [Allow users that have certain special characters in their username to build successfully when using exec](https://github.com/dotnet/msbuild/pull/6223)
+- [Fail restore operations when an SDK is unresolveable](https://github.com/dotnet/msbuild/pull/6430)
+- [Optimize glob evaluation](https://github.com/dotnet/msbuild/pull/6151)
diff --git a/eng/BootStrapMSBuild.targets b/eng/BootStrapMSBuild.targets
index 52c0b7ec043..288c062da35 100644
--- a/eng/BootStrapMSBuild.targets
+++ b/eng/BootStrapMSBuild.targets
@@ -8,7 +8,7 @@
 
   <PropertyGroup>
     <BootstrapDestination>$(ArtifactsBinDir)bootstrap\</BootstrapDestination>
-    <BootstrapDestination Condition="'$(Platform)' == 'x64'">$(BootstrapDestination)$(Platform)\</BootstrapDestination>
+    <BootstrapDestination Condition="'$(Platform)' == 'x64' or '$(Platform)' == 'arm64'">$(BootstrapDestination)$(Platform)\</BootstrapDestination>
     <BootstrapDestination>$(BootstrapDestination)$(TargetFramework.ToLowerInvariant())\MSBuild\</BootstrapDestination>
 
     <!-- TODO: Mono build should use BootstrapNetCore logic -->
@@ -21,7 +21,7 @@
 
   <Target Name="Bootstrap" DependsOnTargets="$(BootstrapDependsOn)"
           AfterTargets="AfterBuild"
-          Condition="'$(CreateBootstrap)' == 'true'"/>
+          Condition="'$(CreateBootstrap)' != 'false'"/>
 
   <Target Name="CleanBootstrapFolder">
     <!-- This sometimes fails so it might need be retried. -->
@@ -79,7 +79,8 @@
       <ShimTargets Include="Workflow.Targets" />
       <ShimTargets Include="Workflow.VisualBasic.Targets" />
 
-      <InstalledMicrosoftExtensions Include="$(MSBuildExtensionsPath)\Microsoft\**\*.*" />
+      <InstalledMicrosoftExtensions Include="$(MSBuildExtensionsPath)\Microsoft\**\*.*"
+                                    Exclude="$(MSBuildExtensionsPath)\Microsoft\VisualStudio\NodeJs\**" />
 
       <InstalledNuGetFiles Include="$(MSBuildExtensionsPath)\Microsoft\NuGet\*" />
 
@@ -100,6 +101,13 @@
       <FreshlyBuiltBinariesx64 Include="$(MSBuildTaskHostX64BinPath)**\*.exe.config" />
       <FreshlyBuiltBinariesx64 Include="$(X64BinPath)**\*.dll.config" />
 
+      <FreshlyBuiltBinariesArm64 Include="$(X64BinPath)\Microsoft.Build.Tasks.Core.dll" />
+      <FreshlyBuiltBinariesArm64 Include="$(Arm64BinPath)**\*.exe" />
+      <FreshlyBuiltBinariesArm64 Include="$(Arm64BinPath)**\*.tlb" />
+      <FreshlyBuiltBinariesArm64 Include="$(Arm64BinPath)**\*.pdb" />
+      <FreshlyBuiltBinariesArm64 Include="$(Arm64BinPath)**\*.exe.config" />
+      <FreshlyBuiltBinariesArm64 Include="$(Arm64BinPath)**\*.dll.config" />
+
       <FreshlyBuiltRootProjects Include="$(OutputPath)Microsoft.Common.props" />
       <FreshlyBuiltRootProjects Include="$(OutputPath)Microsoft.VisualStudioVersion.*.Common.props" />
       <FreshlyBuiltProjects Include="$(OutputPath)**\*props" Exclude="@(FreshlyBuiltRootProjects)" />
@@ -155,6 +163,10 @@
      <Copy SourceFiles="@(FreshlyBuiltBinariesx64)"
           DestinationFiles="@(FreshlyBuiltBinariesx64 -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\amd64\%(RecursiveDir)%(Filename)%(Extension)')" />
 
+    <!-- Copy our binaries to the arm64 location. -->
+     <Copy SourceFiles="@(FreshlyBuiltBinariesArm64)"
+          DestinationFiles="@(FreshlyBuiltBinariesArm64 -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\arm64\%(RecursiveDir)%(Filename)%(Extension)')" />
+
     <!-- Copy our freshly-built props and targets, overwriting anything we copied from the machine -->
     <Copy SourceFiles="@(FreshlyBuiltRootProjects)"
           DestinationFiles="@(FreshlyBuiltRootProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\%(Filename)%(Extension)')" />
@@ -162,6 +174,8 @@
           DestinationFiles="@(FreshlyBuiltProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\%(RecursiveDir)%(Filename)%(Extension)')" />
     <Copy SourceFiles="@(FreshlyBuiltProjects)"
           DestinationFiles="@(FreshlyBuiltProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\amd64\%(RecursiveDir)%(Filename)%(Extension)')" />
+    <Copy SourceFiles="@(FreshlyBuiltProjects)"
+          DestinationFiles="@(FreshlyBuiltProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\arm64\%(RecursiveDir)%(Filename)%(Extension)')" />
 
   </Target>
 
diff --git a/eng/Packages.props b/eng/Packages.props
index 7334fbeb8d7..495cb46f116 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -12,26 +12,22 @@
     <PackageReference Update="Microsoft.CodeAnalysis.Build.Tasks" Version="$(MicrosoftNetCompilersToolsetVersion)" />
     <PackageReference Update="Microsoft.CodeAnalysis.Collections" Version="4.2.0-1.22102.8" />
     <PackageReference Update="Microsoft.DotNet.XUnitExtensions" Version="$(MicrosoftDotNetXUnitExtensionsVersion)" />
-    <PackageReference Update="Microsoft.IO.Redist" Version="6.0.0" />
+    <PackageReference Update="Microsoft.IO.Redist" Version="$(MicrosoftIORedistVersion)" />
     <PackageReference Update="Microsoft.Net.Compilers.Toolset" Version="$(MicrosoftNetCompilersToolsetVersion)" />
-    <PackageReference Update="Microsoft.Win32.Registry" Version="4.3.0" />
     <PackageReference Update="NuGet.Build.Tasks" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="NuGet.Frameworks" Version="$(NuGetBuildTasksVersion)" />
-    <PackageReference Update="System.CodeDom" Version="4.4.0" />
-    <PackageReference Update="System.Collections.Immutable" Version="5.0.0" />
-    <PackageReference Update="System.Configuration.ConfigurationManager" Version="4.7.0" />
+    <PackageReference Update="System.Collections.Immutable" Version="6.0.0" />
+    <PackageReference Update="System.Configuration.ConfigurationManager" Version="6.0.0" />
     <PackageReference Update="System.Net.Http" Version="4.3.4" />
     <PackageReference Update="System.Memory" Version="4.5.4" />
-    <PackageReference Update="System.Reflection.Metadata" Version="1.6.0" />
+    <PackageReference Update="System.Reflection.Metadata" Version="6.0.0" />
     <PackageReference Update="System.Resources.Extensions" Version="$(SystemResourcesExtensionsPackageVersion)" />
-    <PackageReference Update="System.Runtime.CompilerServices.Unsafe" Version="6.0.0" />
-    <PackageReference Update="System.Security.Cryptography.Pkcs" Version="4.7.0" />
-    <PackageReference Update="System.Security.Cryptography.Xml" Version="4.7.0" />
-    <PackageReference Update="System.Security.Permissions" Version="4.7.0" />
-    <PackageReference Update="System.Security.Principal.Windows" Version="4.7.0" />
-    <PackageReference Update="System.Text.Encoding.CodePages" Version="4.0.1" />
-    <PackageReference Update="System.Text.Json" Version="6.0.0" />
-    <PackageReference Update="System.Threading.Tasks.Dataflow" Version="6.0.0" />
+    <PackageReference Update="System.Runtime.CompilerServices.Unsafe" Version="$(SystemRuntimeCompilerServicesUnsafeVersion)" />
+    <PackageReference Update="System.Security.Permissions" Version="6.0.0" />
+    <PackageReference Update="System.Security.Principal.Windows" Version="5.0.0" />
+    <PackageReference Update="System.Text.Encoding.CodePages" Version="6.0.0" />
+    <PackageReference Update="System.Text.Json" Version="$(SystemTextJsonVersion)" />
+    <PackageReference Update="System.Threading.Tasks.Dataflow" Version="$(SystemThreadingTasksDataflowVersion)" />
     <PackageReference Update="xunit.assert" Version="$(XUnitVersion)" />
     <PackageReference Update="xunit.console" Version="$(XUnitVersion)" />
     <PackageReference Update="xunit.core" Version="$(XUnitVersion)" />
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 157de038726..5ba194b642a 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,22 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.22166.2">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.22261.7">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>3c5f86af982adcb2bbd3932b54cd61f5e5888edc</Sha>
+      <Sha>e3cbecc5b0e51374e3d71dbb976004ab9cc90430</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.2.0-preview.2.109">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.2.0-rc.146">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>919c7e10ebdcc43235c36cf0b72c389d741835a8</Sha>
+      <Sha>b8a61266d9a6780cb7eb9c1942695cf813fdef0a</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.2.0-2.22167.6">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.2.0-4.22266.5">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>eaf9823eb18af4972cb5b8e299a350d1985be33d</Sha>
+      <Sha>5886de67259d3fe055e48985ba5cefb9d089a840</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.22166.2">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.22261.7">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>3c5f86af982adcb2bbd3932b54cd61f5e5888edc</Sha>
+      <Sha>e3cbecc5b0e51374e3d71dbb976004ab9cc90430</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index dcfb8e665c7..773a480d037 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -2,13 +2,13 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
   <PropertyGroup>
-    <VersionPrefix>17.2.1</VersionPrefix><DotNetFinalVersionKind>release</DotNetFinalVersionKind>
+    <VersionPrefix>17.3.0</VersionPrefix>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
     <!-- Workaround for https://github.com/dotnet/roslyn/issues/35793 -->
     <SemanticVersioningV1>true</SemanticVersioningV1>
-    <MicroBuildPluginsSwixBuildVersion>1.0.672</MicroBuildPluginsSwixBuildVersion>
+    <MicroBuildPluginsSwixBuildVersion>1.1.87</MicroBuildPluginsSwixBuildVersion>
     <MonoBuild Condition="'$(Configuration)' == 'Debug-MONO' or '$(Configuration)' == 'Release-MONO'">true</MonoBuild>
   </PropertyGroup>
   <!-- Repo Toolset Features -->
@@ -25,17 +25,21 @@
   </PropertyGroup>
   <!-- Production Dependencies -->
   <PropertyGroup>
-    <SystemResourcesExtensionsPackageVersion>4.6.0</SystemResourcesExtensionsPackageVersion>
+    <SystemResourcesExtensionsPackageVersion>6.0.0</SystemResourcesExtensionsPackageVersion>
   </PropertyGroup>
   <!-- Toolset Dependencies -->
   <PropertyGroup>
     <!-- DotNetCliVersion MUST match the dotnet version in global.json.
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.22166.2</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.22261.7</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>6.0.0-preview.2.21154.6</MicrosoftExtensionsDependencyModelVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.2.0-2.22167.6</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.2.0-preview.2.109</NuGetBuildTasksVersion>
+    <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.2.0-4.22266.5</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.2.0-rc.146</NuGetBuildTasksVersion>
+    <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
+    <SystemTextJsonVersion>6.0.0</SystemTextJsonVersion>
+    <SystemThreadingTasksDataflowVersion>6.0.0</SystemThreadingTasksDataflowVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index 53d8265c397..06cf49477ed 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -12,14 +12,21 @@
     <PackageReference Update="LargeAddressAware" Version="1.0.5" />
     <PackageReference Update="Microsoft.CodeAnalysis.PublicApiAnalyzers" Version="3.3.3" />
     <PackageReference Update="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.36" />
-    <PackageReference Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="3.1.2196" PrivateAssets="All" />
+    <PackageReference Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="3.2.2146" PrivateAssets="All" />
+    <PackageReference Update="Microsoft.Win32.Registry" Version="5.0.0" />
     <PackageReference Update="PdbGit" Version="3.0.41" />
     <PackageReference Update="Shouldly" Version="3.0.0" />
+    <PackageReference Update="System.CodeDom" Version="6.0.0" />
+    <PackageReference Update="System.Private.Uri" Version="4.3.2" />
+    <PackageReference Update="System.Runtime" Version="4.3.1" />
+    <PackageReference Update="System.Security.Cryptography.Pkcs" Version="6.0.1" />
+    <PackageReference Update="System.Security.Cryptography.Xml" Version="6.0.0" />
+    <PackageReference Update="System.Security.Cryptography.X509Certificates" Version="4.3.2" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true' AND $(ProjectIsDeprecated) != 'true'">
     <GlobalPackageReference Include="Microsoft.CodeAnalysis.BannedApiAnalyzers" Version="3.3.3" />
-    <GlobalPackageReference Include="StyleCop.Analyzers" Version="1.2.0-beta.406" PrivateAssets="all"/>
+    <GlobalPackageReference Include="StyleCop.Analyzers" Version="1.2.0-beta.435" PrivateAssets="all"/>
   </ItemGroup>
 
   <ItemGroup>
diff --git a/global.json b/global.json
index 02c11142b0e..3c20798654a 100644
--- a/global.json
+++ b/global.json
@@ -10,6 +10,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.22166.2"
+    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.22261.7"
   }
 }
diff --git a/scripts/Deploy-MSBuild.ps1 b/scripts/Deploy-MSBuild.ps1
index 6bb58a189b1..ef1959fc3b6 100644
--- a/scripts/Deploy-MSBuild.ps1
+++ b/scripts/Deploy-MSBuild.ps1
@@ -4,8 +4,8 @@ Param(
   [string] $destination,
   [ValidateSet('Debug','Release')]
   [string] $configuration = "Debug",
-  [ValidateSet('Core','Desktop')]
-  [string] $runtime = "Desktop"
+  [ValidateSet('Core','Desktop', 'Detect', 'Full')]
+  [string] $runtime = "Detect"
 )
 
 Set-StrictMode -Version "Latest"
@@ -50,6 +50,22 @@ $BackupFolder = New-Item (Join-Path $destination -ChildPath "Backup-$(Get-Date -
 Write-Verbose "Copying $configuration MSBuild to $destination"
 Write-Host "Existing MSBuild assemblies backed up to $BackupFolder"
 
+if ($runtime -eq "Detect") {
+    if ($destination -like "*dotnet*sdk*") {
+        $runtime = "Core"
+        Write-Host "Detected path that looks like an sdk. Writing .NET Core assemblies."
+    }
+    else {
+        $runtime = "Desktop"
+        Write-Host "Detected path that does not look like an sdk. Writing .NET Framework assemblies."
+    }
+}
+else {
+    if ($runtime -eq "Full") {
+        $runtime = "Desktop"
+    }
+}
+
 if ($runtime -eq "Desktop") {
     $targetFramework = "net472"
 } else {
diff --git a/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
index 621f0b367c1..5228974a6e7 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
@@ -1038,4 +1038,4 @@ private static ProjectItemElement GetItemFromContent(string content)
             return Helpers.GetFirst(project.Items);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build.OM.UnitTests/Construction/ProjectItemGroupElement_tests.cs b/src/Build.OM.UnitTests/Construction/ProjectItemGroupElement_tests.cs
index db06dd22a74..05fa6347ad6 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectItemGroupElement_tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectItemGroupElement_tests.cs
@@ -5,7 +5,6 @@
 using System.Xml;
 
 using Microsoft.Build.Construction;
-using Shouldly;
 using Xunit;
 
 #nullable disable
@@ -71,49 +70,6 @@ public void ReadItemGroupTwoItems()
             Assert.Equal("i2", items[1].Include);
         }
 
-        [Fact]
-        public void DeepCopyFromItemGroupWithMetadata()
-        {
-            string content = @"
-                    <Project>
-                        <ItemGroup>
-                            <i Include='i1'>
-                              <M>metadataValue</M>
-                            </i>
-                            <i Include='i2'>
-                              <M>
-                                <Some>
-                                    <Xml With='Nesting' />
-                                </Some>
-                              </M>
-                            </i>
-                        </ItemGroup>
-                    </Project>
-                ";
-
-            ProjectRootElement project = ProjectRootElement.Create(XmlReader.Create(new StringReader(content)));
-            ProjectItemGroupElement group = (ProjectItemGroupElement)Helpers.GetFirst(project.Children);
-
-            ProjectRootElement newProject = ProjectRootElement.Create();
-            ProjectItemGroupElement newItemGroup = project.AddItemGroup();
-
-            newItemGroup.DeepCopyFrom(group);
-
-            var items = Helpers.MakeList(newItemGroup.Items);
-
-            items.Count.ShouldBe(2);
-
-            items[0].Include.ShouldBe("i1");
-            ProjectMetadataElement metadataElement = items[0].Metadata.ShouldHaveSingleItem();
-            metadataElement.Name.ShouldBe("M");
-            metadataElement.Value.ShouldBe("metadataValue");
-
-            items[1].Include.ShouldBe("i2");
-            metadataElement = items[1].Metadata.ShouldHaveSingleItem();
-            metadataElement.Name.ShouldBe("M");
-            metadataElement.Value.ShouldBe("<Some><Xml With=\"Nesting\" /></Some>");
-        }
-
         /// <summary>
         /// Set the condition value
         /// </summary>
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index c39946e0c80..e292037b857 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -969,6 +969,7 @@ private static void CreateProjectInstanceFromFileWithDriveEnumeratingWildcard(Te
                     // Verify
                     collectionLogger.WarningCount.ShouldBe(1);
                     collectionLogger.AssertLogContains("MSB5029");
+                    collectionLogger.AssertLogContains(testProjectFile);
                     options.ProjectCollection.UnregisterAllLoggers();
                 }
             }
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index 00221821ec4..9760dcf7a92 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -31,11 +31,6 @@
     <Content Condition="'$(MSBuildRuntimeType)' != 'Core' and '$(Configuration)' == 'Release'" Include="$(NuGetPackageRoot)\nuget.commandline\$(NuGetCommandLinePackageVersion)\tools\NuGet.exe" CopyToOutputDirectory="PreserveNewest" Link="nuget\NuGet.exe" />
   </ItemGroup>
 
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
-    <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
-    <PackageReference Include="Microsoft.Win32.Registry" />
-  </ItemGroup>
-
   <ItemGroup>
     <Compile Include="..\Shared\EncodingStringWriter.cs">
       <Link>EncodingStringWriter.cs</Link>
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs
index 4226c3d5435..2489f2b4687 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs
@@ -780,4 +780,3 @@ public void ProjectOnErrorElementModify()
         }
     }
 }
-
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectChooseElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectChooseElementLink.cs
index 9967a7b4caf..cd95fc66b3a 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectChooseElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectChooseElementLink.cs
@@ -70,4 +70,3 @@ public MockProjectChooseElementLink(MockProjectChooseElementLinkRemoter proxy, I
         #endregion
     }
 }
-
diff --git a/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
index 0569166093f..f4cd9d64cf0 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
@@ -2,10 +2,11 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Runtime.Versioning;
+
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
 
@@ -138,9 +139,9 @@ public void TestTranslation()
             }
         }
 
-#if FEATURE_COM_INTEROP
         [Fact]
-        [SkipOnMono("disable com tests on mono")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void TestTranslationRemoteHostObjects()
         {
             var stateInHostObject = 3;
@@ -180,7 +181,6 @@ public void TestTranslationRemoteHostObjects()
                 hostObject.GetState().ShouldBe(stateInHostObject);
             }
         }
-#endif
 
         [Fact]
         public void TestTranslationHostObjectsWhenEmpty()
diff --git a/src/Build.UnitTests/BackEnd/CentralForwardingLogger_Tests.cs b/src/Build.UnitTests/BackEnd/CentralForwardingLogger_Tests.cs
index c4b329cabf7..76f0641c76d 100644
--- a/src/Build.UnitTests/BackEnd/CentralForwardingLogger_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/CentralForwardingLogger_Tests.cs
@@ -185,4 +185,4 @@ public void ForwardEvent(BuildEventArgs buildEvent)
             #endregion
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build.UnitTests/BackEnd/EventRedirectorToSink_Tests.cs b/src/Build.UnitTests/BackEnd/EventRedirectorToSink_Tests.cs
index aa8672631df..ff207da4d88 100644
--- a/src/Build.UnitTests/BackEnd/EventRedirectorToSink_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/EventRedirectorToSink_Tests.cs
@@ -97,4 +97,4 @@ public void TestForwardingNullEvent()
            );
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build.UnitTests/BackEnd/LoggingServiceFactory_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingServiceFactory_Tests.cs
index 52d7fe31cfa..d29d9623ecc 100644
--- a/src/Build.UnitTests/BackEnd/LoggingServiceFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingServiceFactory_Tests.cs
@@ -34,6 +34,7 @@ public void TestCreateAsynchronousLogger()
             LoggingServiceFactory factory = new LoggingServiceFactory(LoggerMode.Asynchronous, 1);
             LoggingService loggingService = (LoggingService)factory.CreateInstance(BuildComponentType.LoggingService);
             Assert.Equal(LoggerMode.Asynchronous, loggingService.LoggingMode); // "Expected to create an Asynchronous LoggingService"
+            loggingService.ShutdownComponent();
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
index 1753fc92445..c9964af9f2d 100644
--- a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
@@ -1099,6 +1099,7 @@ public void TestBuildFinishedWaitForEvents()
         {
             ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Asynchronous, 1);
             service.LogBuildFinished(true);
+            service.ShutdownComponent();
         }
 
         #endregion
@@ -1898,7 +1899,7 @@ public static IBuildComponent CreateLoggingService(LoggerMode mode, int nodeId,
             /// Override the method to log which event was processed so it can be verified in a test
             /// </summary>
             /// <param name="buildEvent">Build event which was asked to be processed</param>
-            internal override void ProcessLoggingEvent(object buildEvent, bool allowThrottling = false)
+            internal override void ProcessLoggingEvent(object buildEvent)
             {
                 if (buildEvent is BuildEventArgs buildEventArgs)
                 {
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
index 4b14bd3537a..e8b3812ab57 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
@@ -46,7 +46,7 @@ public void AssertDefaultLoaderReturnsDefaultResolvers()
         {
             var loader = new SdkResolverLoader();
 
-            var resolvers = loader.LoadResolvers(_loggingContext, new MockElementLocation("file"));
+            var resolvers = loader.LoadAllResolvers(_loggingContext, new MockElementLocation("file"));
 
             resolvers.Select(i => i.GetType().FullName).ShouldBe(new [] { typeof(DefaultSdkResolver).FullName });
             
@@ -88,6 +88,38 @@ public void VerifySdkResolverLoaderFileDiscoveryPattern()
             }
         }
 
+        [Fact]
+        public void SdkResolverLoaderPrefersManifestFile()
+        {
+            var root = FileUtilities.GetTemporaryDirectory();
+            try
+            {
+                var testFolder = Directory.CreateDirectory(Path.Combine(root, "MyTestResolver"));
+
+                var wrongResolverDll = Path.Combine(testFolder.FullName, "MyTestResolver.dll");
+                var resolverManifest = Path.Combine(testFolder.FullName, "MyTestResolver.xml");
+                var assemblyToLoad = Path.Combine(root, "SomeOtherResolver.dll");
+
+                File.WriteAllText(wrongResolverDll, string.Empty);
+                File.WriteAllText(assemblyToLoad, string.Empty);
+
+                File.WriteAllText(resolverManifest, $@"
+                    <SdkResolver>
+                      <Path>{assemblyToLoad}</Path>
+                    </SdkResolver>");
+
+                SdkResolverLoader loader = new SdkResolverLoader();
+                var resolversFound = loader.FindPotentialSdkResolvers(root, new MockElementLocation("file"));
+
+                resolversFound.Count.ShouldBe(1);
+                resolversFound.First().ShouldBe(assemblyToLoad);
+            }
+            finally
+            {
+                FileUtilities.DeleteDirectoryNoThrow(root, true);
+            }
+        }
+
         /// <summary>
         /// Verifies that if an SDK resolver throws while creating an instance that a warning is logged.
         /// </summary>
@@ -106,7 +138,7 @@ public void VerifyThrowsWhenResolverFailsToLoad()
 
             InvalidProjectFileException exception = Should.Throw<InvalidProjectFileException>(() =>
             {
-                sdkResolverLoader.LoadResolvers(_loggingContext, ElementLocation.EmptyLocation);
+                sdkResolverLoader.LoadAllResolvers(_loggingContext, ElementLocation.EmptyLocation);
             });
 
             exception.Message.ShouldBe($"The SDK resolver type \"{nameof(MockSdkResolverThatDoesNotLoad)}\" failed to load. A8BB8B3131D3475D881ACD3AF8D75BD6");
@@ -138,7 +170,7 @@ public void VerifyThrowsWhenResolverHasNoPublicConstructor()
 
             InvalidProjectFileException exception = Should.Throw<InvalidProjectFileException>(() =>
             {
-                sdkResolverLoader.LoadResolvers(_loggingContext, ElementLocation.EmptyLocation);
+                sdkResolverLoader.LoadAllResolvers(_loggingContext, ElementLocation.EmptyLocation);
             });
 
             exception.Message.ShouldStartWith($"The SDK resolver type \"{nameof(MockSdkResolverNoPublicConstructor)}\" failed to load.");
@@ -169,7 +201,7 @@ public void VerifyWarningLoggedWhenResolverAssemblyCannotBeLoaded()
 
             InvalidProjectFileException exception = Should.Throw<InvalidProjectFileException>(() =>
             {
-                sdkResolverLoader.LoadResolvers(_loggingContext, ElementLocation.EmptyLocation);
+                sdkResolverLoader.LoadAllResolvers(_loggingContext, ElementLocation.EmptyLocation);
             });
 
             exception.Message.ShouldBe($"The SDK resolver assembly \"{assemblyPath}\" could not be loaded. {expectedMessage}");
@@ -207,6 +239,33 @@ public void SdkResolverLoaderReadsManifestFile()
             }
         }
 
+        [Fact]
+        public void SdkResolverLoaderReadsManifestFileWithResolvableSdkPattern()
+        {
+            using (var env = TestEnvironment.Create(_output))
+            {
+                var root = env.CreateFolder().Path;
+                var resolverPath = Path.Combine(root, "MyTestResolver");
+                var resolverManifest = Path.Combine(resolverPath, "MyTestResolver.xml");
+
+                var assemblyToLoad = env.CreateFile(".dll").Path;
+
+                Directory.CreateDirectory(resolverPath);
+                File.WriteAllText(resolverManifest, $@"
+                    <SdkResolver>
+                      <ResolvableSdkPattern>1&lt;.*</ResolvableSdkPattern>
+                      <Path>{assemblyToLoad}</Path>
+                    </SdkResolver>");
+
+                SdkResolverLoader loader = new SdkResolverLoader();
+                var resolversManifestsFound = loader.FindPotentialSdkResolversManifests(root, new MockElementLocation("file"));
+
+                resolversManifestsFound.Count.ShouldBe(1);
+                resolversManifestsFound.First().Path.ShouldBe(assemblyToLoad);
+                resolversManifestsFound.First().ResolvableSdkRegex.ToString().ShouldBe("1<.*");
+            }
+        }
+
         [Fact]
         public void SdkResolverLoaderErrorsWithInvalidManifestFile()
         {
@@ -287,7 +346,7 @@ public void SdkResolverLoaderHonorsIncludeDefaultEnvVar()
                             resolvers.Add(new MockSdkResolverWithAssemblyPath(resolverPath));
                         }
                     };
-                    IList<SdkResolverBase> resolvers = loader.LoadResolvers(_loggingContext, new MockElementLocation("file"));
+                    IList<SdkResolverBase> resolvers = loader.LoadAllResolvers(_loggingContext, new MockElementLocation("file"));
 
                     resolvers.Count.ShouldBe(0);
                 }
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
index 2b86246c83f..87d3efd618d 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
@@ -17,6 +17,8 @@
 using SdkResultBase = Microsoft.Build.Framework.SdkResult;
 using SdkResultFactoryBase = Microsoft.Build.Framework.SdkResultFactory;
 using SdkResultImpl = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
+using Microsoft.Build.Shared;
+using System.Text.RegularExpressions;
 
 #nullable disable
 
@@ -39,9 +41,10 @@ public SdkResolverService_Tests()
         }
 
         [Fact]
+        // Scenario: Sdk is not resolved.
         public void AssertAllResolverErrorsLoggedWhenSdkNotResolved()
         {
-            SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy());
+            SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy(includeResolversWithPatterns: true));
 
             SdkReference sdk = new SdkReference("notfound", "referencedVersion", "minimumVersion");
 
@@ -56,8 +59,10 @@ public void AssertAllResolverErrorsLoggedWhenSdkNotResolved()
 
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver1 running");
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver2 running");
-            _logger.Errors.Select(i => i.Message).ShouldBe(new [] { "ERROR1", "ERROR2" });
-            _logger.Warnings.Select(i => i.Message).ShouldBe(new[] { "WARNING2" });
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolverWithResolvableSdkPattern1 running");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolverWithResolvableSdkPattern2 running");
+            _logger.Errors.Select(i => i.Message).ShouldBe(new [] { "ERROR4", "ERROR1", "ERROR2" });
+            _logger.Warnings.Select(i => i.Message).ShouldBe(new[] { "WARNING4", "WARNING2" });
         }
 
         [Fact]
@@ -99,7 +104,27 @@ public void AssertResolverThrows()
             e.Sdk.Name.ShouldBe("1sdkName");
         }
 
+
+        [Fact]
+        // Scenario: MockSdkResolverWithResolvableSdkPattern2 is a specific resolver (i.e. resolver with pattern)
+        // and it successfully resolves sdk.
+        public void AssertSecondResolverWithPatternCanResolve()
+        {
+            SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy(includeResolversWithPatterns: true));
+
+            SdkReference sdk = new SdkReference("2sdkName", "referencedVersion", "minimumVersion");
+
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+
+            result.Path.ShouldBe("resolverpathwithresolvablesdkpattern2");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolverWithResolvableSdkPattern2 running");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolver1 running");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolver2 running");
+        }
+
         [Fact]
+        // Scenario: MockSdkResolverWithResolvableSdkPattern1 is a specific resolver, it is loaded but did not resolve sdk.
+        // MockSdkResolver1 is a general resolver (i.e. resolver without pattern), it resolves sdk on a fallback. 
         public void AssertFirstResolverCanResolve()
         {
             SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy());
@@ -110,6 +135,46 @@ public void AssertFirstResolverCanResolve()
 
             result.Path.ShouldBe("resolverpath1");
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver1 running");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolverWithResolvableSdkPattern1 running");
+        }
+
+        [Fact]
+        // Scenario: MockSdkResolver1 has higher priority than MockSdkResolverWithResolvableSdkPattern1 and resolves sdk.
+        public void AssertFirstResolverWithPatternCantResolveChangeWave17_4()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_4.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy(includeResolversWithPatterns: true));
+
+                SdkReference sdk = new SdkReference("1sdkName", "referencedVersion", "minimumVersion");
+
+                var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+
+                result.Path.ShouldBe("resolverpath1");
+                _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver1 running");
+                _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolverWithResolvableSdkPattern1 running");
+                ChangeWaves.ResetStateForTests();
+            }
+        }
+
+        [Fact]
+        // Scenario: MockSdkResolver1 has higher priority than MockSdkResolverWithResolvableSdkPattern1 but MockSdkResolverWithResolvableSdkPattern1 resolves sdk,
+        // becuase MockSdkResolver1 is general and MockSdkResolverWithResolvableSdkPattern1 is specific.
+        public void AssertFirstResolverWithPatternCanResolve()
+        {
+            SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy(includeResolversWithPatterns: true));
+
+            SdkReference sdk = new SdkReference("11sdkName", "referencedVersion", "minimumVersion");
+
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+
+            result.Path.ShouldBe("resolverpathwithresolvablesdkpattern1");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolverWithResolvableSdkPattern1 running");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolver1 running");
         }
 
         [Fact]
@@ -539,16 +604,27 @@ public void IsRunningInVisualStudioIsSetForResolverContext()
 
         private class MockLoaderStrategy : SdkResolverLoader
         {
-            private readonly bool _includeErrorResolver;
+            private List<SdkResolver> _resolvers;
+            private List<(string ResolvableSdkPattern, SdkResolver Resolver)> _resolversWithPatterns;
+
 
-            public MockLoaderStrategy(bool includeErrorResolver = false)
+            public MockLoaderStrategy(bool includeErrorResolver = false, bool includeResolversWithPatterns = false) : this()
             {
-                _includeErrorResolver = includeErrorResolver;
+                if (includeErrorResolver)
+                {
+                    _resolvers.Add(new MockSdkResolverThrows());
+                }
+
+                if (includeResolversWithPatterns)
+                {
+                    _resolversWithPatterns.Add(("1.*", new MockSdkResolverWithResolvableSdkPattern1()));
+                    _resolversWithPatterns.Add((".*", new MockSdkResolverWithResolvableSdkPattern2()));
+                }
             }
 
-            internal override IList<SdkResolver> LoadResolvers(LoggingContext loggingContext, ElementLocation location)
+            private MockLoaderStrategy()
             {
-                List<SdkResolver> resolvers = new List<SdkResolver>
+                _resolvers = new List<SdkResolver>
                 {
                     new MockSdkResolver1(),
                     new MockSdkResolver2(),
@@ -556,12 +632,58 @@ internal override IList<SdkResolver> LoadResolvers(LoggingContext loggingContext
                     new MockSdkResolverWithState()
                 };
 
-                if (_includeErrorResolver)
+                _resolversWithPatterns = new List<(string ResolvableSdkPattern, SdkResolver Resolver)>();
+            }
+
+            internal override IList<SdkResolver> LoadAllResolvers(LoggingContext loggingContext, ElementLocation location)
+            {
+                return _resolvers.OrderBy(i => i.Priority).ToList();
+            }
+
+            internal override IList<SdkResolverManifest> GetResolversManifests(LoggingContext loggingContext,
+            ElementLocation location)
+            {
+                var manifests = new List<SdkResolverManifest>();
+                foreach(SdkResolver resolver in _resolvers)
+                {
+                    SdkResolverManifest sdkResolverManifest = new SdkResolverManifest(resolver.Name, null, null);
+                    manifests.Add(sdkResolverManifest);
+                }
+                foreach ((string ResolvableSdkPattern, SdkResolver Resolver) pair in _resolversWithPatterns)
+                {
+                    SdkResolverManifest sdkResolverManifest = new SdkResolverManifest(
+                        pair.Resolver.Name,
+                        null,
+                        new Regex(pair.ResolvableSdkPattern, RegexOptions.Compiled | RegexOptions.CultureInvariant, TimeSpan.FromMilliseconds(500))
+                    );
+                    manifests.Add(sdkResolverManifest);
+                }
+                return manifests;
+            }
+
+            protected internal override IList<SdkResolver> LoadResolversFromManifest(SdkResolverManifest manifest, LoggingContext loggingContext, ElementLocation location)
+            {
+                var resolvers = new List<SdkResolver>();
+                foreach (var resolver in _resolvers)
+                {
+                    if (resolver.Name == manifest.DisplayName)
+                    {
+                        resolvers.Add(resolver);
+                    }
+                }
+                foreach (var pair in _resolversWithPatterns)
                 {
-                    resolvers.Add(new MockSdkResolverThrows());
+                    if (pair.Resolver.Name == manifest.DisplayName)
+                    {
+                        resolvers.Add(pair.Resolver);
+                    }
                 }
+                return resolvers.OrderBy(t => t.Priority).ToList();
+            }
 
-                return resolvers.OrderBy(i => i.Priority).ToList();
+            internal override IList<SdkResolver> GetDefaultResolvers(LoggingContext loggingContext, ElementLocation location)
+            {
+                return new List<SdkResolver>();
             }
         }
 
@@ -587,7 +709,7 @@ public override SdkResultBase Resolve(SdkReference sdk, SdkResolverContextBase r
                 if (sdk.Name.StartsWith("1"))
                     return factory.IndicateSuccess("resolverpath1", "version1");
 
-                return factory.IndicateFailure(new[] {"ERROR1"});
+                return factory.IndicateFailure(new[] { "ERROR1" });
             }
         }
 
@@ -608,6 +730,40 @@ public override SdkResultBase Resolve(SdkReference sdk, SdkResolverContextBase r
             }
         }
 
+        private class MockSdkResolverWithResolvableSdkPattern1 : SdkResolver
+        {
+            public override string Name => nameof(MockSdkResolverWithResolvableSdkPattern1);
+
+            public override int Priority => 2;
+
+            public override SdkResultBase Resolve(SdkReference sdk, SdkResolverContextBase resolverContext, SdkResultFactoryBase factory)
+            {
+                resolverContext.Logger.LogMessage("MockSdkResolverWithResolvableSdkPattern1 running", MessageImportance.Normal);
+
+                if (sdk.Name.StartsWith("11"))
+                    return factory.IndicateSuccess("resolverpathwithresolvablesdkpattern1", "version3");
+
+                return factory.IndicateFailure(new[] { "ERROR3" });
+            }
+        }
+
+        private class MockSdkResolverWithResolvableSdkPattern2 : SdkResolver
+        {
+            public override string Name => nameof(MockSdkResolverWithResolvableSdkPattern2);
+
+            public override int Priority => 0;
+
+            public override SdkResultBase Resolve(SdkReference sdk, SdkResolverContextBase resolverContext, SdkResultFactoryBase factory)
+            {
+                resolverContext.Logger.LogMessage("MockSdkResolverWithResolvableSdkPattern2 running", MessageImportance.Normal);
+
+                if (sdk.Name.StartsWith("2"))
+                    return factory.IndicateSuccess("resolverpathwithresolvablesdkpattern2", "version4", new[] { "WARNING4" });
+
+                return factory.IndicateFailure(new[] { "ERROR4" }, new[] { "WARNING4" });
+            }
+        }
+
         private class MockSdkResolverWithState : SdkResolver
         {
             public const string Expected = "01713226A202458F97D9074168DF2618";
diff --git a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
index e2b71d10f36..64b62861d6f 100644
--- a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
@@ -1031,4 +1031,3 @@ private void SimpleSymlinkInputCheck(DateTime symlinkWriteTime, DateTime targetW
         }
     }
 }
-
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs b/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs
index 481da772e2f..7f390cdf98c 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.UnitTests.BackEnd
     /// <summary>
     /// A task used for testing the TaskExecutionHost, which reports what the TaskExecutionHost does to it.
     /// </summary>
-    internal class TaskBuilderTestTask : IGeneratedTask
+    public class TaskBuilderTestTask : IGeneratedTask
     {
         /// <summary>
         /// The task host.
@@ -84,7 +84,7 @@ public bool BoolParam
             set
             {
                 _boolOutput = value;
-                _testTaskHost.ParameterSet("BoolParam", value);
+                _testTaskHost?.ParameterSet("BoolParam", value);
             }
         }
 
@@ -96,7 +96,7 @@ public bool[] BoolArrayParam
             set
             {
                 _boolArrayOutput = value;
-                _testTaskHost.ParameterSet("BoolArrayParam", value);
+                _testTaskHost?.ParameterSet("BoolArrayParam", value);
             }
         }
 
@@ -108,7 +108,7 @@ public int IntParam
             set
             {
                 _intOutput = value;
-                _testTaskHost.ParameterSet("IntParam", value);
+                _testTaskHost?.ParameterSet("IntParam", value);
             }
         }
 
@@ -120,7 +120,7 @@ public int[] IntArrayParam
             set
             {
                 _intArrayOutput = value;
-                _testTaskHost.ParameterSet("IntArrayParam", value);
+                _testTaskHost?.ParameterSet("IntArrayParam", value);
             }
         }
 
@@ -132,7 +132,7 @@ public string StringParam
             set
             {
                 _stringOutput = value;
-                _testTaskHost.ParameterSet("StringParam", value);
+                _testTaskHost?.ParameterSet("StringParam", value);
             }
         }
 
@@ -144,7 +144,7 @@ public string[] StringArrayParam
             set
             {
                 _stringArrayOutput = value;
-                _testTaskHost.ParameterSet("StringArrayParam", value);
+                _testTaskHost?.ParameterSet("StringArrayParam", value);
             }
         }
 
@@ -156,7 +156,7 @@ public ITaskItem ItemParam
             set
             {
                 _itemOutput = value;
-                _testTaskHost.ParameterSet("ItemParam", value);
+                _testTaskHost?.ParameterSet("ItemParam", value);
             }
         }
 
@@ -168,7 +168,7 @@ public ITaskItem[] ItemArrayParam
             set
             {
                 _itemArrayOutput = value;
-                _testTaskHost.ParameterSet("ItemArrayParam", value);
+                _testTaskHost?.ParameterSet("ItemArrayParam", value);
             }
         }
 
@@ -181,7 +181,7 @@ public bool ExecuteReturnParam
             set
             {
                 _executeReturnValue = value;
-                _testTaskHost.ParameterSet("ExecuteReturnParam", value);
+                _testTaskHost?.ParameterSet("ExecuteReturnParam", value);
             }
         }
 
@@ -193,7 +193,7 @@ public bool BoolOutput
         {
             get
             {
-                _testTaskHost.OutputRead("BoolOutput", _boolOutput);
+                _testTaskHost?.OutputRead("BoolOutput", _boolOutput);
                 return _boolOutput;
             }
         }
@@ -206,7 +206,7 @@ public bool[] BoolArrayOutput
         {
             get
             {
-                _testTaskHost.OutputRead("BoolArrayOutput", _boolArrayOutput);
+                _testTaskHost?.OutputRead("BoolArrayOutput", _boolArrayOutput);
                 return _boolArrayOutput;
             }
         }
@@ -219,7 +219,7 @@ public int IntOutput
         {
             get
             {
-                _testTaskHost.OutputRead("IntOutput", _intOutput);
+                _testTaskHost?.OutputRead("IntOutput", _intOutput);
                 return _intOutput;
             }
         }
@@ -232,7 +232,7 @@ public int[] IntArrayOutput
         {
             get
             {
-                _testTaskHost.OutputRead("IntArrayOutput", _intArrayOutput);
+                _testTaskHost?.OutputRead("IntArrayOutput", _intArrayOutput);
                 return _intArrayOutput;
             }
         }
@@ -245,7 +245,7 @@ public string StringOutput
         {
             get
             {
-                _testTaskHost.OutputRead("StringOutput", _stringOutput);
+                _testTaskHost?.OutputRead("StringOutput", _stringOutput);
                 return _stringOutput;
             }
         }
@@ -258,7 +258,7 @@ public string EmptyStringOutput
         {
             get
             {
-                _testTaskHost.OutputRead("EmptyStringOutput", null);
+                _testTaskHost?.OutputRead("EmptyStringOutput", null);
                 return String.Empty;
             }
         }
@@ -271,7 +271,7 @@ public string[] EmptyStringArrayOutput
         {
             get
             {
-                _testTaskHost.OutputRead("EmptyStringArrayOutput", null);
+                _testTaskHost?.OutputRead("EmptyStringArrayOutput", null);
                 return Array.Empty<string>();
             }
         }
@@ -284,7 +284,7 @@ public string NullStringOutput
         {
             get
             {
-                _testTaskHost.OutputRead("NullStringOutput", null);
+                _testTaskHost?.OutputRead("NullStringOutput", null);
                 return null;
             }
         }
@@ -297,7 +297,7 @@ public ITaskItem NullITaskItemOutput
         {
             get
             {
-                _testTaskHost.OutputRead("NullITaskItemOutput", null);
+                _testTaskHost?.OutputRead("NullITaskItemOutput", null);
                 return null;
             }
         }
@@ -310,7 +310,7 @@ public string[] NullStringArrayOutput
         {
             get
             {
-                _testTaskHost.OutputRead("NullStringArrayOutput", null);
+                _testTaskHost?.OutputRead("NullStringArrayOutput", null);
                 return null;
             }
         }
@@ -323,7 +323,7 @@ public ITaskItem[] NullITaskItemArrayOutput
         {
             get
             {
-                _testTaskHost.OutputRead("NullITaskItemArrayOutput", null);
+                _testTaskHost?.OutputRead("NullITaskItemArrayOutput", null);
                 return null;
             }
         }
@@ -336,7 +336,7 @@ public string[] StringArrayOutput
         {
             get
             {
-                _testTaskHost.OutputRead("StringArrayOutput", _stringArrayOutput);
+                _testTaskHost?.OutputRead("StringArrayOutput", _stringArrayOutput);
                 return _stringArrayOutput;
             }
         }
@@ -349,7 +349,7 @@ public ITaskItem ItemOutput
         {
             get
             {
-                _testTaskHost.OutputRead("ItemOutput", _itemOutput);
+                _testTaskHost?.OutputRead("ItemOutput", _itemOutput);
                 return _itemOutput;
             }
         }
@@ -362,7 +362,7 @@ public ITaskItem[] ItemArrayOutput
         {
             get
             {
-                _testTaskHost.OutputRead("ItemArrayOutput", _itemArrayOutput);
+                _testTaskHost?.OutputRead("ItemArrayOutput", _itemArrayOutput);
                 return _itemArrayOutput;
             }
         }
@@ -375,52 +375,13 @@ public ITaskItem[] ItemArrayNullOutput
         {
             get
             {
-                _testTaskHost.OutputRead("ItemArrayNullOutput", _itemArrayOutput);
+                _testTaskHost?.OutputRead("ItemArrayNullOutput", _itemArrayOutput);
                 return null;
             }
         }
 
-        /// <summary>
-        /// An object output
-        /// </summary>
         [Output]
-        public object ObjectOutput
-        {
-            get
-            {
-                object output = new object();
-                _testTaskHost.OutputRead("ObjectOutput", output);
-                return output;
-            }
-        }
-
-        /// <summary>
-        /// An object array output
-        /// </summary>
-        [Output]
-        public object[] ObjectArrayOutput
-        {
-            get
-            {
-                object[] output = new object[] { new object(), new object() };
-                _testTaskHost.OutputRead("ObjectArrayOutput", output);
-                return output;
-            }
-        }
-
-        /// <summary>
-        /// An arraylist output
-        /// </summary>
-        [Output]
-        public ArrayList ArrayListOutput
-        {
-            get
-            {
-                ArrayList output = new ArrayList();
-                _testTaskHost.OutputRead("ArrayListOutput", output);
-                return output;
-            }
-        }
+        public TargetBuiltReason EnumOutput => TargetBuiltReason.BeforeTargets;
 
         #region ITask Members
 
diff --git a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
index 4ee43919d09..69c142d7712 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
@@ -1,11 +1,14 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 using System;
 using System.Diagnostics;
 using Microsoft.Build.Execution;
 using Microsoft.Build.UnitTests;
+using Microsoft.Build.UnitTests.BackEnd;
+
 using Shouldly;
 using Xunit;
+using Xunit.Abstractions;
 
 #nullable disable
 
@@ -13,6 +16,13 @@ namespace Microsoft.Build.Engine.UnitTests.BackEnd
 {
     public sealed class TaskHostFactory_Tests
     {
+        ITestOutputHelper _output;
+
+        public TaskHostFactory_Tests(ITestOutputHelper testOutputHelper)
+        {
+            _output = testOutputHelper;
+        }
+
         [Fact]
         [Trait("Category", "mono-osx-failing")]
         public void TaskNodesDieAfterBuild()
@@ -47,5 +57,38 @@ public void TaskNodesDieAfterBuild()
                 }
             }
         }
+
+        [Fact]
+        public void VariousParameterTypesCanBeTransmittedToAndRecievedFromTaskHost()
+        {
+            using TestEnvironment env = TestEnvironment.Create(_output);
+
+            string projectContents = $@"
+<Project>
+    <UsingTask TaskName=""{nameof(TaskBuilderTestTask)}"" AssemblyFile=""{typeof(TaskBuilderTestTask).Assembly.Location}"" TaskFactory=""TaskHostFactory"" />
+    <Target Name='{nameof(VariousParameterTypesCanBeTransmittedToAndRecievedFromTaskHost)}'>
+        <{nameof(TaskBuilderTestTask)}
+            ExecuteReturnParam=""true""
+            BoolParam=""true""
+            BoolArrayParam=""false;true;false""
+            IntParam=""314""
+            IntArrayParam=""42;67;98""
+            StringParam=""stringParamInput""
+            StringArrayParam=""stringArrayParamInput1;stringArrayParamInput2;stringArrayParamInput3"">
+
+            <Output PropertyName=""BoolOutput"" TaskParameter=""BoolOutput"" />
+            <Output PropertyName=""BoolArrayOutput"" TaskParameter=""BoolArrayOutput"" />
+            <Output PropertyName=""IntOutput"" TaskParameter=""IntOutput"" />
+            <Output PropertyName=""IntArrayOutput"" TaskParameter=""IntArrayOutput"" />
+            <Output PropertyName=""EnumOutput"" TaskParameter=""EnumOutput"" />
+            <Output PropertyName=""StringOutput"" TaskParameter=""StringOutput"" />
+            <Output PropertyName=""StringArrayOutput"" TaskParameter=""StringArrayOutput"" />
+        </{nameof(TaskBuilderTestTask)}>
+    </Target>
+</Project>";
+            TransientTestProjectWithFiles project = env.CreateTestProjectWithFiles(projectContents);
+            ProjectInstance projectInstance = new(project.ProjectFile);
+            projectInstance.Build(new[] { new MockLogger(env.Output) }).ShouldBeTrue();
+            }
     }
 }
diff --git a/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs b/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
index f1e11354289..023b16eb686 100644
--- a/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
+++ b/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
@@ -369,6 +369,7 @@ public void BuildEnvironmentFindsAmd64()
         }
 
         [Fact]
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7552", TargetFrameworkMonikers.Any)]
         [PlatformSpecific(TestPlatforms.Windows)]
         public void BuildEnvironmentFindsAmd64RunningInAmd64NoVS()
         {
@@ -386,6 +387,7 @@ public void BuildEnvironmentFindsAmd64RunningInAmd64NoVS()
         }
 
         [Fact]
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7552", TargetFrameworkMonikers.Any)]
         [PlatformSpecific(TestPlatforms.Windows)]
         public void BuildEnvironmentFindsAmd64NoVS()
         {
@@ -401,6 +403,7 @@ public void BuildEnvironmentFindsAmd64NoVS()
         }
 
         [Fact]
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7552", TargetFrameworkMonikers.Any)]
         [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
         [PlatformSpecific(TestPlatforms.Windows)]
         public void BuildEnvironmentFindsAmd64RunningInAmd64()
diff --git a/src/Build.UnitTests/Collections/MultiDictionary_Tests.cs b/src/Build.UnitTests/Collections/MultiDictionary_Tests.cs
index b26c561f60f..ae9415481aa 100644
--- a/src/Build.UnitTests/Collections/MultiDictionary_Tests.cs
+++ b/src/Build.UnitTests/Collections/MultiDictionary_Tests.cs
@@ -164,4 +164,4 @@ public void Clear()
             Assert.Equal(0, dictionary.ValueCount);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.UnitTests/Definition/ProjectItem_Tests.cs
index f8d660feeb3..6410e2474d2 100644
--- a/src/Build.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.UnitTests/Definition/ProjectItem_Tests.cs
@@ -86,4 +86,4 @@ private static IList<ProjectItem> GetItems(string content)
             return item;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
index 57abe763aaf..07ab3ac1d6a 100644
--- a/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
@@ -2983,4 +2983,3 @@ public override RegistryKeyWrapper OpenSubKey(string name)
     }
 #endif
 }
-
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 06324b51b52..997e40b8c83 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -7,6 +7,7 @@
 using System.Linq;
 using System.Net;
 using System.Threading;
+using System.Threading.Tasks;
 using System.Xml;
 
 using Microsoft.Build.Collections;
@@ -4243,7 +4244,8 @@ public void VerifyDTDProcessingIsDisabled()
         /// If DTD processing is disabled, the server should not receive any connection request.
         /// </summary>
         [Fact]
-        public void VerifyDTDProcessingIsDisabled2()
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7623")]
+        public async void VerifyDTDProcessingIsDisabled2()
         {
             string projectContents = ObjectModelHelpers.CleanupFileContents(@"<?xml version=""1.0"" encoding=""utf-8""?>
                                 <!DOCTYPE Project [
@@ -4258,9 +4260,9 @@ public void VerifyDTDProcessingIsDisabled2()
                                     </Target>
                                 </Project>");
 
-            string projectDirectory = Path.Combine(Path.GetTempPath(), "VerifyDTDProcessingIsDisabled");
+            string projectDirectory = Path.Combine(Path.GetTempPath(), "VerifyDTDProcessingIsDisabled2");
 
-            Thread t = new Thread(HttpServerThread);
+            Thread t = new(HttpServerThread);
             t.IsBackground = true;
             t.Start();
 
@@ -4268,7 +4270,7 @@ public void VerifyDTDProcessingIsDisabled2()
             {
                 if (Directory.Exists(projectDirectory))
                 {
-                    FileUtilities.DeleteWithoutTrailingBackslash(projectDirectory, true /* recursive delete */);
+                    FileUtilities.DeleteWithoutTrailingBackslash(projectDirectory, recursive: true);
                 }
 
                 Directory.CreateDirectory(projectDirectory);
@@ -4277,18 +4279,20 @@ public void VerifyDTDProcessingIsDisabled2()
 
                 File.WriteAllText(projectFilename, projectContents);
 
-                Project project = new Project(projectFilename);
+                Project project = new(projectFilename);
 
-                MockLogger logger = new MockLogger();
+                MockLogger logger = new();
                 project.Build(logger);
             }
             finally
             {
-                Thread.Sleep(500);
+                await Task.Delay(500);
+                t.IsAlive.ShouldBeTrue();
+                t.Abort();
+                await Task.Delay(500);
 
                 // Expect server to be alive and hung up unless a request originating from DTD processing was sent
                 _httpListenerThreadException.ShouldBeNull();
-                t.IsAlive.ShouldBeTrue();
             }
         }
 #endif
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 7081de2d1e6..e77a47e5ef4 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -7,6 +7,7 @@
 using System.IO;
 using System.Linq;
 using System.Runtime.InteropServices;
+using System.Runtime.Versioning;
 using System.Text;
 using System.Xml;
 
@@ -1712,8 +1713,10 @@ public void RegistryPropertyInvalidPrefixError2()
             }
            );
         }
-#if FEATURE_WIN32_REGISTRY
+
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void RegistryPropertyString()
         {
             try
@@ -1735,6 +1738,8 @@ public void RegistryPropertyString()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void RegistryPropertyBinary()
         {
             try
@@ -1759,6 +1764,8 @@ public void RegistryPropertyBinary()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void RegistryPropertyDWord()
         {
             try
@@ -1780,6 +1787,8 @@ public void RegistryPropertyDWord()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void RegistryPropertyExpandString()
         {
             try
@@ -1802,6 +1811,8 @@ public void RegistryPropertyExpandString()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void RegistryPropertyQWord()
         {
             try
@@ -1823,6 +1834,8 @@ public void RegistryPropertyQWord()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void RegistryPropertyMultiString()
         {
             try
@@ -1842,7 +1855,6 @@ public void RegistryPropertyMultiString()
                 Registry.CurrentUser.DeleteSubKey(@"Software\Microsoft\MSBuild_test");
             }
         }
-#endif
 
         [Fact]
         public void TestItemSpecModiferEscaping()
@@ -3471,8 +3483,9 @@ public void PropertySimpleSpaced()
             Assert.Equal(String.Empty, result);
         }
 
-#if FEATURE_WIN32_REGISTRY
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegitryValue()
         {
             try
@@ -3496,6 +3509,8 @@ public void PropertyFunctionGetRegitryValue()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegitryValueDefault()
         {
             try
@@ -3519,6 +3534,8 @@ public void PropertyFunctionGetRegitryValueDefault()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegistryValueFromView1()
         {
             try
@@ -3542,6 +3559,8 @@ public void PropertyFunctionGetRegistryValueFromView1()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegistryValueFromView2()
         {
             try
@@ -3563,7 +3582,6 @@ public void PropertyFunctionGetRegistryValueFromView2()
                 Registry.CurrentUser.DeleteSubKey(@"Software\Microsoft\MSBuild_test");
             }
         }
-#endif
 
         /// <summary>
         /// Expand a property function that references item metadata
@@ -3646,6 +3664,44 @@ public void PropertyFunctionHashCodeSameOnlyIfStringSame()
             }
         }
 
+        [Theory]
+        [InlineData("easycase")]
+        [InlineData("")]
+        [InlineData("\"\n()\tsdfIR$%#*;==")]
+        public void TestBase64Conversion(string testCase)
+        {
+            PropertyDictionary<ProjectPropertyInstance> pg = new();
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new(pg, FileSystems.Default);
+            string intermediate = expander.ExpandPropertiesLeaveTypedAndEscaped($"$([MSBuild]::ConvertToBase64('{testCase}'))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance) as string;
+            intermediate.Trim('=').All(c => char.IsLetterOrDigit(c) || c == '+' || c == '/').ShouldBeTrue();
+            string original = expander.ExpandPropertiesLeaveTypedAndEscaped($"$([MSBuild]::ConvertFromBase64('{intermediate}'))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance) as string;
+            original.ShouldBe(testCase);
+        }
+
+        [Theory]
+        [InlineData("easycase", "ZWFzeWNhc2U=")]
+        [InlineData("", "")]
+        [InlineData("\"\n()\tsdfIR$%#*;==", "IgooKQlzZGZJUiQlIyo7PT0=")]
+        public void TestExplicitToBase64Conversion(string plaintext, string base64)
+        {
+            PropertyDictionary<ProjectPropertyInstance> pg = new();
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new(pg, FileSystems.Default);
+            string intermediate = expander.ExpandPropertiesLeaveTypedAndEscaped($"$([MSBuild]::ConvertToBase64('{plaintext}'))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance) as string;
+            intermediate.ShouldBe(base64);
+        }
+
+        [Theory]
+        [InlineData("easycase", "ZWFzeWNhc2U=")]
+        [InlineData("", "")]
+        [InlineData("\"\n()\tsdfIR$%#*;==", "IgooKQlzZGZJUiQlIyo7PT0=")]
+        public void TestExplicitFromBase64Conversion(string plaintext, string base64)
+        {
+            PropertyDictionary<ProjectPropertyInstance> pg = new();
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new(pg, FileSystems.Default);
+            string original = expander.ExpandPropertiesLeaveTypedAndEscaped($"$([MSBuild]::ConvertFromBase64('{base64}'))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance) as string;
+            original.ShouldBe(plaintext);
+        }
+
         /// <summary>
         /// A whole bunch error check tests
         /// </summary>
@@ -3863,12 +3919,10 @@ public void Medley()
             }
 #endif
 
-#if FEATURE_WIN32_REGISTRY
             if (NativeMethodsShared.IsWindows)
             {
                 errorTests.Add("$(Registry:X)");
             }
-#endif
 
             if (!NativeMethodsShared.IsWindows)
             {
diff --git a/src/Build.UnitTests/Globbing/CompositeGlob_Tests.cs b/src/Build.UnitTests/Globbing/CompositeGlob_Tests.cs
index 0d9995c0c1b..c97598d2dcd 100644
--- a/src/Build.UnitTests/Globbing/CompositeGlob_Tests.cs
+++ b/src/Build.UnitTests/Globbing/CompositeGlob_Tests.cs
@@ -173,4 +173,4 @@ public void CreateShouldReturnNewCompositeWhenMultipleProvided()
             Assert.Equal(2, composite.Globs.Count());
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build.UnitTests/Globbing/MSBuildGlobWithGaps_Tests.cs b/src/Build.UnitTests/Globbing/MSBuildGlobWithGaps_Tests.cs
index 0a993dbc5b6..d943538c805 100644
--- a/src/Build.UnitTests/Globbing/MSBuildGlobWithGaps_Tests.cs
+++ b/src/Build.UnitTests/Globbing/MSBuildGlobWithGaps_Tests.cs
@@ -36,4 +36,4 @@ public void GlobWithGapsShouldNotMatchIfGapsMatch()
             Assert.False(glob.IsMatch("ab"));
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
new file mode 100644
index 00000000000..f1a31f7dbe6
--- /dev/null
+++ b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
@@ -0,0 +1,245 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text.RegularExpressions;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Exceptions;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+using static Microsoft.Build.Graph.UnitTests.GraphTestingUtilities;
+using static Microsoft.Build.Graph.UnitTests.ProjectGraphTests;
+
+#nullable disable
+
+namespace Microsoft.Build.Graph.UnitTests
+{
+    /// <summary>
+    /// Performs SetPlatform negotiation for all project references when opted
+    /// in via the EnableDynamicPlatformResolution property.
+    /// 
+    /// The static graph mirrors the negotiation during build to determine plartform for each node.
+    /// These tests mirror GetCompatiblePlatform_Tests.cs in order to make sure they both are in sync.
+    /// </summary>
+    public class ProjectGraphSetPlatformTests
+    {
+
+        [Fact]
+        public void ValidateSetPlatformOverride()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>x64</Platform>
+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                    <SetPlatform>platform=x86</SetPlatform>
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                        <PropertyGroup>
+                                                            <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                            <Platforms>x64;AnyCPU</Platforms>
+                                                        </PropertyGroup>
+                                                        <ItemGroup>
+                                                            <ProjectReference Include=""$(MSBuildThisFileDirectory)3.proj"" >
+                                                            </ProjectReference>
+                                                        </ItemGroup>
+                                                    </Project>");
+                var proj3 = env.CreateFile("3.proj", @"
+                                                    <Project>
+                                                        <PropertyGroup>
+                                                            <Platforms>AnyCPU;x86</Platforms>
+                                                        </PropertyGroup>
+                                                    </Project>");
+
+
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+                GetFirstNodeWithProjectNumber(graph, 3).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+            }
+        }
+
+        [Fact]
+        public void ResolvesViaPlatformLookupTable()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>win32</Platform>
+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                    <PropertyGroup>
+                                                        <Platforms>x64;x86;AnyCPU</Platforms>
+                                                    </PropertyGroup>
+                                                    </Project>");
+                
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x64");
+            }
+        }
+
+        [Fact]
+        public void ResolvesViaProjectReferencesPlatformLookupTable()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>win32</Platform>
+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                    <PropertyGroup>
+                                                        <Platforms>x64;x86;AnyCPU</Platforms>
+                                                        <PlatformLookupTable>win32=x86</PlatformLookupTable>
+                                                    </PropertyGroup>
+                                                    </Project>");
+               
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+            }
+        }
+
+        [Fact]
+        public void ResolvesViaAnyCPUDefault()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>x86</Platform>
+                                                                                                <PlatformLookupTable>AnyCPU=x64</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                    <PropertyGroup>
+                                                        <Platforms>x64;AnyCPU</Platforms>
+                                                    </PropertyGroup>
+                                                    </Project>");
+
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("AnyCPU");
+            }
+        }
+
+        [Fact]
+        public void ResolvesViaSamePlatform()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>x86</Platform>
+                                                                                                <PlatformLookupTable>x86=AnyCPU</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                    <PropertyGroup>
+                                                        <PlatformLookupTable></PlatformLookupTable>
+                                                        <Platforms>x86;x64;AnyCPU</Platforms>
+                                                    </PropertyGroup>
+                                                    </Project>");
+             
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+            }
+        }
+
+        [Fact]
+        public void FailsToResolve()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>x86</Platform>
+                                                                                                <PlatformLookupTable>AnyCPU=x64</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                    <PropertyGroup>
+                                                        <Platforms>x64</Platforms>
+                                                    </PropertyGroup>
+                                                    </Project>");
+              
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                // Here we are checking if platform is defined. in this case it should not be since Platorm would be set to the value this project defaults as
+                // in order to avoid dual build errors we remove platform in order to avoid the edge case where a project has global platform set and does not have global platform set
+                // yet still default to the same platform.
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties.ContainsKey("Platform").ShouldBeFalse();
+            }
+        }
+
+        [Fact]
+        public void PlatformIsChosenAsDefault()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>x64</Platform>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                    <PropertyGroup>
+                                                        <platform>x64</platform>
+                                                        <Platforms>x86;AnyCPU</Platforms>
+                                                    </PropertyGroup>
+                                                    </Project>");
+              
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GetPropertyValue("Platform").ShouldBe(GetFirstNodeWithProjectNumber(graph, 1).ProjectInstance.GetPropertyValue("Platform"));
+            }
+        }
+    }
+}
diff --git a/src/Build.UnitTests/Instance/HostServices_Tests.cs b/src/Build.UnitTests/Instance/HostServices_Tests.cs
index 9d9f4b033ab..f13eb9b32ab 100644
--- a/src/Build.UnitTests/Instance/HostServices_Tests.cs
+++ b/src/Build.UnitTests/Instance/HostServices_Tests.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
+using System.Runtime.Versioning;
 using System.Xml;
 
 using Microsoft.Build.Evaluation;
@@ -242,19 +243,18 @@ public void TestContradictoryAffinityCausesException_Any()
            );
         }
 
-#if FEATURE_COM_INTEROP
         /// <summary>
         /// Test which ensures that setting an Any affinity for a project with a remote host object does not throws.
         /// </summary>
         [Fact]
-        [SkipOnMono("disable com tests on mono")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void TestNoContradictoryRemoteHostObjectAffinity()
         {
             HostServices hostServices = new HostServices();
             hostServices.RegisterHostObject("project", "target", "task", "moniker");
             hostServices.SetNodeAffinity("project", NodeAffinity.Any);
         }
-#endif
 
         /// <summary>
         /// Test which ensures that setting the InProc affinity for a project with a host object is allowed.
@@ -298,12 +298,12 @@ public void TestNonContraditcoryHostObjectAllowed_Any()
             Assert.Equal(NodeAffinity.InProc, hostServices.GetNodeAffinity("project"));
         }
 
-#if FEATURE_COM_INTEROP
         /// <summary>
         /// Test which ensures the remote host object cannot affect a project which has the Any affinity specifically set.
         /// </summary>
         [Fact]
-        [SkipOnMono("disable com tests on mono")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void TestRegisterRemoteHostObjectNoAffect_Any2()
         {
             HostServices hostServices = new HostServices();
@@ -311,7 +311,6 @@ public void TestRegisterRemoteHostObjectNoAffect_Any2()
             hostServices.RegisterHostObject("project", "target", "task", "moniker");
             hostServices.GetNodeAffinity("project").ShouldBe(NodeAffinity.Any);
         }
-#endif
 
         /// <summary>
         /// Test which ensures the host object can be set for a project which has an out-of-proc affinity only because that affinity
@@ -338,12 +337,12 @@ public void TestNonContraditcoryHostObjectAllowed_InProc()
             hostServices.RegisterHostObject("project", "target", "task", hostObject);
         }
 
-#if FEATURE_COM_INTEROP
         /// <summary>
         /// Test which ensures the affinity for a project can be changed once the in process host object is registered
         /// </summary>
         [Fact]
-        [SkipOnMono("disable com tests on mono")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void TestAffinityChangeAfterRegisterInprocessHostObject()
         {
             HostServices hostServices = new HostServices();
@@ -353,7 +352,6 @@ public void TestAffinityChangeAfterRegisterInprocessHostObject()
             hostServices.RegisterHostObject("project", "target", "task", hostObject);
             hostServices.GetNodeAffinity("project").ShouldBe(NodeAffinity.InProc);
         }
-#endif
 
         /// <summary>
         /// Test which ensures the affinity for a project can be changed once the host object is cleared.
@@ -449,12 +447,12 @@ public void UnloadedProjectDiscardsHostServices()
             Assert.False(hostServices.HasInProcessHostObject(project2.FullPath));
         }
 
-#if FEATURE_COM_INTEROP
         /// <summary>
         /// Tests that register overrides existing reigsted remote host object.
         /// </summary>
         [Fact]
-        [SkipOnMono("disable com tests on mono")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void TestRegisterOverrideExistingRegisted()
         {
             var hostServices = new HostServices();
@@ -479,7 +477,6 @@ public void TestRegisterOverrideExistingRegisted()
 
             resultObject.GetState().ShouldBe(2);
         }
-#endif
 
         /// <summary>
         /// Creates a dummy project instance.
diff --git a/src/Build.UnitTests/MockElementLocation.cs b/src/Build.UnitTests/MockElementLocation.cs
index a122931106b..313a245c4c8 100644
--- a/src/Build.UnitTests/MockElementLocation.cs
+++ b/src/Build.UnitTests/MockElementLocation.cs
@@ -68,4 +68,4 @@ internal static MockElementLocation Instance
             get { return s_instance; }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build.UnitTests/Scanner_Tests.cs b/src/Build.UnitTests/Scanner_Tests.cs
index 2f7c912bf71..ae6880ac5bd 100644
--- a/src/Build.UnitTests/Scanner_Tests.cs
+++ b/src/Build.UnitTests/Scanner_Tests.cs
@@ -133,24 +133,6 @@ public void SpaceInMiddleOfProperty(string pattern)
             lexer._errorState.ShouldBeFalse();
         }
 
-        [Fact]
-        public void SpacePropertyOptOutWave16_10()
-        {
-            using TestEnvironment env = TestEnvironment.Create();
-            ChangeWaves.ResetStateForTests();
-            env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave16_10.ToString());
-            BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-            Scanner lexer = new Scanner("$(x )", ParserOptions.AllowProperties);
-            AdvanceToScannerError(lexer);
-            Assert.Null(lexer.UnexpectedlyFound);
-
-            lexer = new Scanner("$( x)", ParserOptions.AllowProperties);
-            AdvanceToScannerError(lexer);
-            Assert.Null(lexer.UnexpectedlyFound);
-            ChangeWaves.ResetStateForTests();
-        }
-
         /// <summary>
         /// Tests the special errors for "@(" and "@x" and similar cases.
         /// </summary>
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 1c08e288d57..c4a9d2c9523 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -34,6 +34,7 @@
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
 
 using Microsoft.NET.StringTools;
+using System.ComponentModel;
 
 #nullable disable
 
@@ -176,6 +177,11 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// </summary>
         private int _nextBuildSubmissionId;
 
+        /// <summary>
+        /// The last BuildParameters used for building.
+        /// </summary>
+        private bool? _previousLowPriority = null;
+
         /// <summary>
         /// Mapping of unnamed project instances to the file names assigned to them.
         /// </summary>
@@ -404,6 +410,15 @@ public void BeginBuild(BuildParameters parameters, IEnumerable<DeferredBuildMess
             _deferredBuildMessages = null;
         }
 
+        private void UpdatePriority(Process p, ProcessPriorityClass priority)
+        {
+            try
+            {
+                p.PriorityClass = priority;
+            }
+            catch (Win32Exception) { }
+        }
+
         /// <summary>
         /// Prepares the BuildManager to receive build requests.
         /// </summary>
@@ -411,6 +426,41 @@ public void BeginBuild(BuildParameters parameters, IEnumerable<DeferredBuildMess
         /// <exception cref="InvalidOperationException">Thrown if a build is already in progress.</exception>
         public void BeginBuild(BuildParameters parameters)
         {
+            if (_previousLowPriority != null)
+            {
+                if (parameters.LowPriority != _previousLowPriority)
+                {
+                    if (NativeMethodsShared.IsWindows || parameters.LowPriority)
+                    {
+                        ProcessPriorityClass priority = parameters.LowPriority ? ProcessPriorityClass.BelowNormal : ProcessPriorityClass.Normal;
+                        IEnumerable<Process> processes = _nodeManager?.GetProcesses();
+                        if (processes is not null)
+                        {
+                            foreach (Process p in processes)
+                            {
+                                UpdatePriority(p, priority);
+                            }
+                        }
+
+                        processes = _taskHostNodeManager?.GetProcesses();
+                        if (processes is not null)
+                        {
+                            foreach (Process p in processes)
+                            {
+                                UpdatePriority(p, priority);
+                            }
+                        }
+                    }
+                    else
+                    {
+                        _nodeManager?.ShutdownAllNodes();
+                        _taskHostNodeManager?.ShutdownAllNodes();
+                    }
+               }
+            }
+
+            _previousLowPriority = parameters.LowPriority;
+
             lock (_syncLock)
             {
                 AttachDebugger();
@@ -1612,7 +1662,7 @@ private void WaitForAllLoggingServiceEventsToBeProcessed()
             // this has to be called out of the lock (_syncLock)
             // because processing events can callback to 'this' instance and cause deadlock
             Debug.Assert(!Monitor.IsEntered(_syncLock));
-            ((LoggingService) ((IBuildComponentHost) this).LoggingService).WaitForThreadToProcessEvents();
+            ((LoggingService) ((IBuildComponentHost) this).LoggingService).WaitForLoggingToProcessEvents();
         }
 
         /// <summary>
@@ -2602,26 +2652,20 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)
                         break;
 
                     case ScheduleActionType.CreateNode:
-                        var newNodes = new List<NodeInfo>();
+                        IList<NodeInfo> newNodes = _nodeManager.CreateNodes(GetNodeConfiguration(), response.RequiredNodeType, response.NumberOfNodesToCreate);
 
-                        for (int i = 0; i < response.NumberOfNodesToCreate; i++)
+                        if (newNodes?.Count != response.NumberOfNodesToCreate || newNodes.Any(n => n == null))
                         {
-                            NodeInfo createdNode = _nodeManager.CreateNode(GetNodeConfiguration(), response.RequiredNodeType);
+                            BuildEventContext buildEventContext = new BuildEventContext(0, Scheduler.VirtualNode, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
+                            ((IBuildComponentHost)this).LoggingService.LogError(buildEventContext, new BuildEventFileInfo(String.Empty), "UnableToCreateNode", response.RequiredNodeType.ToString("G"));
 
-                            if (createdNode != null)
-                            {
-                                _noNodesActiveEvent.Reset();
-                                _activeNodes.Add(createdNode.NodeId);
-                                newNodes.Add(createdNode);
-                                ErrorUtilities.VerifyThrow(_activeNodes.Count != 0, "Still 0 nodes after asking for a new node.  Build cannot proceed.");
-                            }
-                            else
-                            {
-                                BuildEventContext buildEventContext = new BuildEventContext(0, Scheduler.VirtualNode, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
-                                ((IBuildComponentHost)this).LoggingService.LogError(buildEventContext, new BuildEventFileInfo(String.Empty), "UnableToCreateNode", response.RequiredNodeType.ToString("G"));
+                            throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnableToCreateNode", response.RequiredNodeType.ToString("G")));
+                        }
 
-                                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnableToCreateNode", response.RequiredNodeType.ToString("G")));
-                            }
+                        foreach (var node in newNodes)
+                        {
+                            _noNodesActiveEvent.Reset();
+                            _activeNodes.Add(node.NodeId);
                         }
 
                         IEnumerable<ScheduleResponse> newResponses = _scheduler.ReportNodesCreated(newNodes);
diff --git a/src/Build/BackEnd/Components/Communications/INodeManager.cs b/src/Build/BackEnd/Components/Communications/INodeManager.cs
index 161fb779341..f35f8cba087 100644
--- a/src/Build/BackEnd/Components/Communications/INodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/INodeManager.cs
@@ -1,10 +1,10 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System.Collections.Generic;
+using System.Diagnostics;
 using Microsoft.Build.Execution;
 
-#nullable disable
-
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
@@ -21,11 +21,12 @@ internal interface INodeManager : IBuildComponent,
         /// </summary>
         /// <param name="configuration">The configuration to use to create the node.</param>
         /// <param name="affinity">The <see cref="NodeAffinity"/> to use.</param>
+        /// <param name="numberOfNodesToCreate">Number of nodes to be reused or created.</param>
         /// <returns>Information about the node created</returns>
         /// <remarks>
         /// Throws an exception if the node could not be created.
         /// </remarks>
-        NodeInfo CreateNode(NodeConfiguration configuration, NodeAffinity affinity);
+        IList<NodeInfo> CreateNodes(NodeConfiguration configuration, NodeAffinity affinity, int numberOfNodesToCreate);
 
         /// <summary>
         /// Sends a data packet to a specific node
@@ -51,6 +52,8 @@ internal interface INodeManager : IBuildComponent,
         /// The node manager contains state which is not supposed to persist between builds, make sure this is cleared.
         /// </summary>
         void ClearPerBuildState();
+
+        IEnumerable<Process> GetProcesses();
         #endregion
     }
 }
diff --git a/src/Build/BackEnd/Components/Communications/INodeProvider.cs b/src/Build/BackEnd/Components/Communications/INodeProvider.cs
index 1a3f6b84ade..0da32af6678 100644
--- a/src/Build/BackEnd/Components/Communications/INodeProvider.cs
+++ b/src/Build/BackEnd/Components/Communications/INodeProvider.cs
@@ -1,7 +1,11 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#nullable disable
+using System;
+
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -57,14 +61,15 @@ int AvailableNodes
         /// <summary>
         /// Requests that a new node be created on the specified machine.
         /// </summary>
-        /// <param name="nodeId">The id to assign to the node.</param>
+        /// <param name="nextNodeId">The id to assign to the first created node. Resulting nodes ids will be in range [nextNodeId, nextNodeId + numberOfNodesToCreate - 1]</param>
         /// <param name="packetFactory">
         /// The packet factory used to create packets when data is
         /// received on this node.
         /// </param>
-        /// <param name="configuration">The configuration to use to create the remote node.</param>
-        /// <returns>True if the node was created, false otherwise.</returns>
-        bool CreateNode(int nodeId, INodePacketFactory packetFactory, NodeConfiguration configuration);
+        /// <param name="configurationFactory">NodeConfiguration factory of particular node</param>
+        /// <param name="numberOfNodesToCreate">Required number of nodes to create</param>
+        /// <returns>Array of NodeInfo of successfully created nodes</returns>
+        IList<NodeInfo> CreateNodes(int nextNodeId, INodePacketFactory packetFactory, Func<NodeInfo, NodeConfiguration> configurationFactory, int numberOfNodesToCreate);
 
         /// <summary>
         /// Sends data to a specific node.
@@ -83,6 +88,8 @@ int AvailableNodes
         /// Shuts down all of the managed nodes.  This call will not return until all nodes are shut down.
         /// </summary>
         void ShutdownAllNodes();
+
+        IEnumerable<Process> GetProcesses();
         #endregion
     }
 }
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
index 45303ac6d30..dce14e3d422 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
@@ -24,6 +24,8 @@ internal class NodeEndpointOutOfProc : NodeEndpointOutOfProcBase
 
         private readonly bool _lowPriority;
 
+        internal bool LowPriority { get { return _lowPriority; } }
+
         #endregion
 
         #region Constructors and Factories
@@ -54,7 +56,7 @@ internal NodeEndpointOutOfProc(
         /// </summary>
         protected override Handshake GetHandshake()
         {
-            return new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, is64Bit: EnvironmentUtilities.Is64BitProcess, nodeReuse: _enableReuse, lowPriority: _lowPriority));
+            return new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, architectureFlagToSet: XMakeAttributes.GetCurrentMSBuildArchitecture(), nodeReuse: _enableReuse, lowPriority: _lowPriority));
         }
 
         #region Structs
diff --git a/src/Build/BackEnd/Components/Communications/NodeManager.cs b/src/Build/BackEnd/Components/Communications/NodeManager.cs
index bd6dd68088c..6d9f73590eb 100644
--- a/src/Build/BackEnd/Components/Communications/NodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeManager.cs
@@ -5,8 +5,8 @@
 using System.Collections.Generic;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Execution;
-
-#nullable disable
+using System.Threading;
+using System.Diagnostics;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -16,30 +16,25 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     internal class NodeManager : INodeManager
     {
-        /// <summary>
-        /// The invalid node id
-        /// </summary>
-        private const int InvalidNodeId = 0;
-
         /// <summary>
         /// The node provider for the in-proc node.
         /// </summary>
-        private INodeProvider _inProcNodeProvider;
+        private INodeProvider? _inProcNodeProvider;
 
         /// <summary>
         /// The node provider for out-of-proc nodes.
         /// </summary> 
-        private INodeProvider _outOfProcNodeProvider;
+        private INodeProvider? _outOfProcNodeProvider;
 
         /// <summary>
         /// The build component host.
         /// </summary>
-        private IBuildComponentHost _componentHost;
+        private IBuildComponentHost? _componentHost;
 
         /// <summary>
         /// Mapping of manager-produced node IDs to the provider hosting the node.
         /// </summary>
-        private Dictionary<int, INodeProvider> _nodeIdToProvider;
+        private readonly Dictionary<int, INodeProvider> _nodeIdToProvider;
 
         /// <summary>
         /// The packet factory used to translate and route packets
@@ -92,32 +87,31 @@ private NodeManager()
         /// </summary>
         /// <param name="configuration">The configuration to use for the remote node.</param>
         /// <param name="nodeAffinity">The <see cref="NodeAffinity"/> to use.</param>
+        /// <param name="numberOfNodesToCreate">Number of nodes to be reused ot created.</param>
         /// <returns>A NodeInfo describing the node created, or null if none could be created.</returns>
-        public NodeInfo CreateNode(NodeConfiguration configuration, NodeAffinity nodeAffinity)
+        public IList<NodeInfo> CreateNodes(NodeConfiguration configuration, NodeAffinity nodeAffinity, int numberOfNodesToCreate)
         {
             // We will prefer to make nodes on the "closest" providers first; in-proc, then
             // out-of-proc, then remote.
             // When we support distributed build, we will also consider the remote provider.
-            int nodeId = InvalidNodeId;
-            if ((nodeAffinity == NodeAffinity.Any || nodeAffinity == NodeAffinity.InProc) && !_componentHost.BuildParameters.DisableInProcNode)
+            List<NodeInfo> nodes = new(numberOfNodesToCreate);
+            if ((nodeAffinity == NodeAffinity.Any || nodeAffinity == NodeAffinity.InProc) && !_componentHost!.BuildParameters.DisableInProcNode)
             {
-                nodeId = AttemptCreateNode(_inProcNodeProvider, configuration);
+                nodes.AddRange(AttemptCreateNode(_inProcNodeProvider!, configuration, numberOfNodesToCreate));
             }
 
-            if (nodeId == InvalidNodeId && (nodeAffinity == NodeAffinity.Any || nodeAffinity == NodeAffinity.OutOfProc))
+            if (nodes.Count < numberOfNodesToCreate && (nodeAffinity == NodeAffinity.Any || nodeAffinity == NodeAffinity.OutOfProc))
             {
-                nodeId = AttemptCreateNode(_outOfProcNodeProvider, configuration);
+                nodes.AddRange(AttemptCreateNode(_outOfProcNodeProvider!, configuration, numberOfNodesToCreate - nodes.Count));
             }
 
-            if (nodeId == InvalidNodeId)
+            // If we created a node, they should no longer be considered shut down.
+            if (nodes.Count > 0)
             {
-                return null;
+                _nodesShutdown = false;
             }
 
-            // If we created a node, they should no longer be considered shut down.
-            _nodesShutdown = false;
-
-            return new NodeInfo(nodeId, _nodeIdToProvider[nodeId].ProviderType);
+            return nodes;
         }
 
         /// <summary>
@@ -127,14 +121,14 @@ public NodeInfo CreateNode(NodeConfiguration configuration, NodeAffinity nodeAff
         /// <param name="packet">The packet to send.</param>
         public void SendData(int node, INodePacket packet)
         {
-            // Look up the node provider for this node in the mapping.
-            if (!_nodeIdToProvider.TryGetValue(node, out INodeProvider provider))
+            if (!_nodeIdToProvider.TryGetValue(node, out INodeProvider? provider))
             {
                 ErrorUtilities.ThrowInternalError("Node {0} does not have a provider.", node);
             }
-
-            // Send the data.
-            provider.SendData(node, packet);
+            else
+            {
+                provider.SendData(node, packet);
+            }
         }
 
         /// <summary>
@@ -176,7 +170,7 @@ public void InitializeComponent(IBuildComponentHost host)
         {
             ErrorUtilities.VerifyThrow(_componentHost == null, "NodeManager already initialized.");
             ErrorUtilities.VerifyThrow(host != null, "We can't create a NodeManager with a null componentHost");
-            _componentHost = host;
+            _componentHost = host!;
 
             _inProcNodeProvider = _componentHost.GetComponent(BuildComponentType.InProcNodeProvider) as INodeProvider;
             _outOfProcNodeProvider = _componentHost.GetComponent(BuildComponentType.OutOfProcNodeProvider) as INodeProvider;
@@ -305,47 +299,57 @@ private void RemoveNodeFromMapping(int nodeId)
         /// </summary>
         /// <param name="nodeProvider">The provider used to create the node.</param>
         /// <param name="nodeConfiguration">The <see cref="NodeConfiguration"/> to use.</param>
-        /// <returns>The id of the node created.</returns>
-        private int AttemptCreateNode(INodeProvider nodeProvider, NodeConfiguration nodeConfiguration)
+        /// <param name="numberOfNodesToCreate">Number of nodes to be reused ot created.</param>
+        /// <returns>List of created nodes.</returns>
+        private IList<NodeInfo> AttemptCreateNode(INodeProvider nodeProvider, NodeConfiguration nodeConfiguration, int numberOfNodesToCreate)
         {
             // If no provider was passed in, we obviously can't create a node.
             if (nodeProvider == null)
             {
                 ErrorUtilities.ThrowInternalError("No node provider provided.");
-                return InvalidNodeId;
+                return new List<NodeInfo>();
             }
 
             // Are there any free slots on this provider?
             if (nodeProvider.AvailableNodes == 0)
             {
-                return InvalidNodeId;
+                return new List<NodeInfo>();
             }
 
             // Assign a global ID to the node we are about to create.
-            int nodeId;
+            int fromNodeId;
             if (nodeProvider is NodeProviderInProc)
             {
-                nodeId = _inprocNodeId;
+                fromNodeId = _inprocNodeId;
             }
             else
             {
-                nodeId = _nextNodeId;
-                _nextNodeId++;
+                // Reserve node numbers for all needed nodes.
+                fromNodeId = Interlocked.Add(ref _nextNodeId, numberOfNodesToCreate) - numberOfNodesToCreate;
             }
 
-            NodeConfiguration configToSend = nodeConfiguration.Clone();
-            configToSend.NodeId = nodeId;
 
             // Create the node and add it to our mapping.
-            bool createdNode = nodeProvider.CreateNode(nodeId, this, configToSend);
+            IList<NodeInfo> nodes = nodeProvider.CreateNodes(fromNodeId, this, AcquiredNodeConfigurationFactory, numberOfNodesToCreate);
+
+            foreach (NodeInfo node in nodes)
+            {
+                _nodeIdToProvider.Add(node.NodeId, nodeProvider);
+            }
+
+            return nodes;
 
-            if (!createdNode)
+            NodeConfiguration AcquiredNodeConfigurationFactory(NodeInfo nodeInfo)
             {
-                return InvalidNodeId;
+                var config = nodeConfiguration.Clone();
+                config.NodeId = nodeInfo.NodeId;
+                return config;
             }
+        }
 
-            _nodeIdToProvider.Add(nodeId, nodeProvider);
-            return nodeId;
+        public IEnumerable<Process> GetProcesses()
+        {
+            return _outOfProcNodeProvider?.GetProcesses()!;
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
index 18e965c027b..88f5feea51b 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
@@ -2,6 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections.Generic;
+using System.Diagnostics;
 using System.Globalization;
 using System.Threading;
 using Microsoft.Build.Internal;
@@ -184,13 +186,34 @@ public void ShutdownAllNodes()
             ShutdownConnectedNodes(false /* no node reuse */);
         }
 
+        public IList<NodeInfo> CreateNodes(int nextNodeId, INodePacketFactory factory, Func<NodeInfo, NodeConfiguration> configurationFactory, int numberOfNodesToCreate)
+        {
+            var nodes = new List<NodeInfo>(numberOfNodesToCreate);
+
+            for (int i = 0; i < numberOfNodesToCreate; i++)
+            {
+                int nodeId = nextNodeId + i;
+
+                NodeInfo nodeInfo = new(nodeId, ProviderType);
+                if (!CreateNode(nodeId, factory, configurationFactory(nodeInfo)))
+                {
+                    // If it fails let it return what we have created so far so caller can somehow acquire missing nodes.
+                    break;
+                }
+
+                nodes.Add(nodeInfo);
+            }
+
+            return nodes;
+        }
+
         /// <summary>
         /// Requests that a node be created on the specified machine.
         /// </summary>
         /// <param name="nodeId">The id of the node to create.</param>
         /// <param name="factory">The factory to use to create packets from this node.</param>
         /// <param name="configuration">The configuration for the node.</param>
-        public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration configuration)
+        private bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration configuration)
         {
             ErrorUtilities.VerifyThrow(nodeId != InvalidInProcNodeId, "Cannot create in-proc node.");
 
@@ -439,6 +462,9 @@ private void Dispose(bool disposing)
             }
         }
 
+        // The process here is the same as in the main node.
+        public IEnumerable<Process> GetProcesses() => throw new NotImplementedException();
+
         #endregion
     }
 }
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
index 2430e450cac..96ebeef27f9 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
@@ -1,14 +1,15 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
-
 using Microsoft.Build.Shared;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
-using Microsoft.Build.Utilities;
+using System.Linq;
 
 #nullable disable
 
@@ -23,7 +24,7 @@ internal class NodeProviderOutOfProc : NodeProviderOutOfProcBase, INodeProvider
         /// <summary>
         /// A mapping of all the nodes managed by this provider.
         /// </summary>
-        private Dictionary<int, NodeContext> _nodeContexts;
+        private ConcurrentDictionary<int, NodeContext> _nodeContexts;
 
         /// <summary>
         /// Constructor.
@@ -69,48 +70,58 @@ public int AvailableNodes
         internal static Handshake GetHandshake(bool enableNodeReuse, bool enableLowPriority)
         {
             CommunicationsUtilities.Trace("MSBUILDNODEHANDSHAKESALT=\"{0}\", msbuildDirectory=\"{1}\", enableNodeReuse={2}, enableLowPriority={3}", Traits.MSBuildNodeHandshakeSalt, BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32, enableNodeReuse, enableLowPriority);
-            return new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableNodeReuse, lowPriority: enableLowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
+            return new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, architectureFlagToSet: XMakeAttributes.GetCurrentMSBuildArchitecture(), nodeReuse: enableNodeReuse, lowPriority: enableLowPriority));
         }
 
         /// <summary>
-        /// Instantiates a new MSBuild process acting as a child node.
+        /// Instantiates a new MSBuild processes acting as a child nodes or connect to existing ones.
         /// </summary>
-        public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration configuration)
+        public IList<NodeInfo> CreateNodes(int nextNodeId, INodePacketFactory factory, Func<NodeInfo, NodeConfiguration> configurationFactory, int numberOfNodesToCreate)
         {
             ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
 
-            if (_nodeContexts.Count >= ComponentHost.BuildParameters.MaxNodeCount)
+            // This can run concurrently. To be properly detect internal bug when we create more nodes than allowed
+            //   we add into _nodeContexts premise of future node and verify that it will not cross limits.
+            if (_nodeContexts.Count + numberOfNodesToCreate > ComponentHost.BuildParameters.MaxNodeCount)
             {
-                ErrorUtilities.ThrowInternalError("All allowable nodes already created ({0}).", _nodeContexts.Count);
-                return false;
+                ErrorUtilities.ThrowInternalError("Exceeded max node count of '{0}', current count is '{1}' ", ComponentHost.BuildParameters.MaxNodeCount, _nodeContexts.Count);
+                return new List<NodeInfo>();
             }
 
+            ConcurrentBag<NodeInfo> nodes = new();
+
             // Start the new process.  We pass in a node mode with a node number of 1, to indicate that we
             // want to start up just a standard MSBuild out-of-proc node.
             // Note: We need to always pass /nodeReuse to ensure the value for /nodeReuse from msbuild.rsp
             // (next to msbuild.exe) is ignored.
             string commandLineArgs = $"/nologo /nodemode:1 /nodeReuse:{ComponentHost.BuildParameters.EnableNodeReuse.ToString().ToLower()} /low:{ComponentHost.BuildParameters.LowPriority.ToString().ToLower()}";
 
-            // Make it here.
-            CommunicationsUtilities.Trace("Starting to acquire a new or existing node to establish node ID {0}...", nodeId);
+            CommunicationsUtilities.Trace("Starting to acquire {1} new or existing node(s) to establish nodes from ID {0} to {2}...", nextNodeId, numberOfNodesToCreate, nextNodeId + numberOfNodesToCreate - 1);
+
+            Handshake hostHandshake = new(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, architectureFlagToSet: XMakeAttributes.GetCurrentMSBuildArchitecture(), nodeReuse: ComponentHost.BuildParameters.EnableNodeReuse, lowPriority: ComponentHost.BuildParameters.LowPriority));
+            IList<NodeContext> nodeContexts = GetNodes(null, commandLineArgs, nextNodeId, factory, hostHandshake, NodeContextCreated, NodeContextTerminated, numberOfNodesToCreate);
+
+            if (nodeContexts.Count > 0)
+            {
+                return nodeContexts
+                    .Select(nc => new NodeInfo(nc.NodeId, ProviderType))
+                    .ToList();
+            }
 
-            Handshake hostHandshake = new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: ComponentHost.BuildParameters.EnableNodeReuse, lowPriority: ComponentHost.BuildParameters.LowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
-            NodeContext context = GetNode(null, commandLineArgs, nodeId, factory, hostHandshake, NodeContextTerminated);
+            throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CouldNotConnectToMSBuildExe", ComponentHost.BuildParameters.NodeExeLocation));
 
-            if (context != null)
+            void NodeContextCreated(NodeContext context)
             {
-                _nodeContexts[nodeId] = context;
+                NodeInfo nodeInfo = new NodeInfo(context.NodeId, ProviderType);
+
+                _nodeContexts[context.NodeId] = context;
 
                 // Start the asynchronous read.
                 context.BeginAsyncPacketRead();
 
                 // Configure the node.
-                context.SendData(configuration);
-
-                return true;
+                context.SendData(configurationFactory(nodeInfo));
             }
-
-            throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CouldNotConnectToMSBuildExe", ComponentHost.BuildParameters.NodeExeLocation));
         }
 
         /// <summary>
@@ -132,12 +143,7 @@ public void SendData(int nodeId, INodePacket packet)
         public void ShutdownConnectedNodes(bool enableReuse)
         {
             // Send the build completion message to the nodes, causing them to shutdown or reset.
-            List<NodeContext> contextsToShutDown;
-
-            lock (_nodeContexts)
-            {
-                contextsToShutDown = new List<NodeContext>(_nodeContexts.Values);
-            }
+            var contextsToShutDown = new List<NodeContext>(_nodeContexts.Values);
 
             ShutdownConnectedNodes(contextsToShutDown, enableReuse);
         }
@@ -171,7 +177,7 @@ public void ShutdownAllNodes()
         public void InitializeComponent(IBuildComponentHost host)
         {
             this.ComponentHost = host;
-            _nodeContexts = new Dictionary<int, NodeContext>();
+            _nodeContexts = new ConcurrentDictionary<int, NodeContext>();
         }
 
         /// <summary>
@@ -197,10 +203,12 @@ static internal IBuildComponent CreateComponent(BuildComponentType componentType
         /// </summary>
         private void NodeContextTerminated(int nodeId)
         {
-            lock (_nodeContexts)
-            {
-                _nodeContexts.Remove(nodeId);
-            }
+            _nodeContexts.TryRemove(nodeId, out _);
+        }
+
+        public IEnumerable<Process> GetProcesses()
+        {
+            return _nodeContexts.Values.Select(context => context.Process);
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 07210e39621..c681f417bb5 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -9,6 +9,7 @@
 using System.IO;
 using System.IO.Pipes;
 using System.Diagnostics;
+using System.Linq;
 using System.Threading;
 using System.Threading.Tasks;
 using System.Runtime.InteropServices;
@@ -23,8 +24,6 @@
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using Microsoft.Build.Utilities;
-
 using BackendNativeMethods = Microsoft.Build.BackEnd.NativeMethods;
 using Task = System.Threading.Tasks.Task;
 using Microsoft.Build.Framework;
@@ -67,8 +66,15 @@ internal abstract class NodeProviderOutOfProcBase
 
         /// <summary>
         /// Keeps track of the processes we've already checked for nodes so we don't check them again.
+        /// We decided to use ConcurrentDictionary of(string, byte) as common implementation of ConcurrentHashSet.
+        /// </summary>
+        private readonly ConcurrentDictionary<string, byte /*void*/> _processesToIgnore = new();
+
+        /// <summary>
+        /// Delegate used to tell the node provider that a context has been created.
         /// </summary>
-        private HashSet<string> _processesToIgnore = new HashSet<string>();
+        /// <param name="context">The created node context.</param>
+        internal delegate void NodeContextCreatedDelegate(NodeContext context);
 
         /// <summary>
         /// Delegate used to tell the node provider that a context has terminated.
@@ -143,7 +149,7 @@ protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate ter
             // INodePacketFactory
             INodePacketFactory factory = new NodePacketFactory();
 
-            List<Process> nodeProcesses = GetPossibleRunningNodes().nodeProcesses;
+            List<Process> nodeProcesses = GetPossibleRunningNodes().nodeProcesses.ToList();
 
             // Find proper MSBuildTaskHost executable name
             string msbuildtaskhostExeName = NodeProviderOutOfProcTaskHost.TaskHostNameForClr2TaskHost;
@@ -178,10 +184,16 @@ protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate ter
         }
 
         /// <summary>
-        /// Finds or creates a child process which can act as a node.
+        /// Finds or creates a child processes which can act as a node.
         /// </summary>
-        /// <returns>The pipe stream representing the node.</returns>
-        protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, int nodeId, INodePacketFactory factory, Handshake hostHandshake, NodeContextTerminateDelegate terminateNode)
+        protected IList<NodeContext> GetNodes(string msbuildLocation,
+            string commandLineArgs,
+            int nextNodeId,
+            INodePacketFactory factory,
+            Handshake hostHandshake,
+            NodeContextCreatedDelegate createNode,
+            NodeContextTerminateDelegate terminateNode,
+            int numberOfNodesToCreate)
         {
 #if DEBUG
             if (Execution.BuildManager.WaitForDebugger)
@@ -206,115 +218,169 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
                 }
             }
 
+            // Get all process of possible running node processes for reuse and put them into ConcurrentQueue.
+            // Processes from this queue will be concurrently consumed by TryReusePossibleRunningNodes while
+            //    trying to connect to them and reuse them. When queue is empty, no process to reuse left
+            //    new node process will be started.
+            string expectedProcessName = null;
+            ConcurrentQueue<Process> possibleRunningNodes = null;
 #if FEATURE_NODE_REUSE
             // Try to connect to idle nodes if node reuse is enabled.
             if (_componentHost.BuildParameters.EnableNodeReuse)
             {
-                (string expectedProcessName, List<Process> processes) runningNodesTuple = GetPossibleRunningNodes(msbuildLocation);
+                IList<Process> possibleRunningNodesList;
+                (expectedProcessName, possibleRunningNodesList) = GetPossibleRunningNodes(msbuildLocation);
+                possibleRunningNodes = new ConcurrentQueue<Process>(possibleRunningNodesList);
+
+                if (possibleRunningNodesList.Count > 0)
+                {
+                    CommunicationsUtilities.Trace("Attempting to connect to {1} existing processes '{0}'...", expectedProcessName, possibleRunningNodesList.Count);
+                }
+            }
+#endif
+            ConcurrentQueue<NodeContext> nodeContexts = new();
+            ConcurrentQueue<Exception> exceptions = new();
+            Parallel.For(nextNodeId, nextNodeId + numberOfNodesToCreate, (nodeId) =>
+            {
+                try
+                {
+                    if (!TryReuseAnyFromPossibleRunningNodes(nodeId) && !StartNewNode(nodeId))
+                    {
+                        // We were unable to reuse or launch a node.
+                        CommunicationsUtilities.Trace("FAILED TO CONNECT TO A CHILD NODE");
+                    }
+                }
+                catch (Exception ex)
+                {
+                    // It will be rethrown as aggregate exception
+                    exceptions.Enqueue(ex);
+                }
+            });
+            if (!exceptions.IsEmpty)
+            {
+                ErrorUtilities.ThrowInternalError("Cannot acquire required number of nodes.", new AggregateException(exceptions.ToArray()));
+            }
+
+            return nodeContexts.ToList();
 
-                CommunicationsUtilities.Trace("Attempting to connect to each existing {1} process in turn to establish node {0}...", nodeId, runningNodesTuple.expectedProcessName);
-                foreach (Process nodeProcess in runningNodesTuple.processes)
+            bool TryReuseAnyFromPossibleRunningNodes(int nodeId)
+            {
+                while (possibleRunningNodes != null && possibleRunningNodes.TryDequeue(out var nodeToReuse))
                 {
-                    if (nodeProcess.Id == Process.GetCurrentProcess().Id)
+                    CommunicationsUtilities.Trace("Trying to connect to existing process {2} with id {1} to establish node {0}...", nodeId, nodeToReuse.Id, nodeToReuse.ProcessName);
+                    if (nodeToReuse.Id == Process.GetCurrentProcess().Id)
                     {
                         continue;
                     }
 
                     // Get the full context of this inspection so that we can always skip this process when we have the same taskhost context
-                    string nodeLookupKey = GetProcessesToIgnoreKey(hostHandshake, nodeProcess.Id);
-                    if (_processesToIgnore.Contains(nodeLookupKey))
+                    string nodeLookupKey = GetProcessesToIgnoreKey(hostHandshake, nodeToReuse.Id);
+                    if (_processesToIgnore.ContainsKey(nodeLookupKey))
                     {
                         continue;
                     }
 
                     // We don't need to check this again
-                    _processesToIgnore.Add(nodeLookupKey);
+                    _processesToIgnore.TryAdd(nodeLookupKey, default);
 
                     // Attempt to connect to each process in turn.
-                    Stream nodeStream = TryConnectToProcess(nodeProcess.Id, 0 /* poll, don't wait for connections */, hostHandshake);
+                    Stream nodeStream = TryConnectToProcess(nodeToReuse.Id, 0 /* poll, don't wait for connections */, hostHandshake);
                     if (nodeStream != null)
                     {
                         // Connection successful, use this node.
-                        CommunicationsUtilities.Trace("Successfully connected to existed node {0} which is PID {1}", nodeId, nodeProcess.Id);
-                        return new NodeContext(nodeId, nodeProcess, nodeStream, factory, terminateNode);
+                        CommunicationsUtilities.Trace("Successfully connected to existed node {0} which is PID {1}", nodeId, nodeToReuse.Id);
+
+                        CreateNodeContext(nodeId, nodeToReuse, nodeStream);
+                        return true;
                     }
                 }
+
+                return false;
             }
-#endif
 
-            // None of the processes we tried to connect to allowed a connection, so create a new one.
-            // We try this in a loop because it is possible that there is another MSBuild multiproc
-            // host process running somewhere which is also trying to create nodes right now.  It might
-            // find our newly created node and connect to it before we get a chance.
-            CommunicationsUtilities.Trace("Could not connect to existing process, now creating a process...");
-            int retries = NodeCreationRetries;
-            while (retries-- > 0)
+            // Create a new node process.
+            bool StartNewNode(int nodeId)
             {
-#if FEATURE_NET35_TASKHOST
-                // We will also check to see if .NET 3.5 is installed in the case where we need to launch a CLR2 OOP TaskHost.
-                // Failure to detect this has been known to stall builds when Windows pops up a related dialog.
-                // It's also a waste of time when we attempt several times to launch multiple MSBuildTaskHost.exe (CLR2 TaskHost)
-                // nodes because we should never be able to connect in this case.
-                string taskHostNameForClr2TaskHost = Path.GetFileNameWithoutExtension(NodeProviderOutOfProcTaskHost.TaskHostNameForClr2TaskHost);
-                if (Path.GetFileNameWithoutExtension(msbuildLocation).Equals(taskHostNameForClr2TaskHost, StringComparison.OrdinalIgnoreCase))
+                CommunicationsUtilities.Trace("Could not connect to existing process, now creating a process...");
+
+                // We try this in a loop because it is possible that there is another MSBuild multiproc
+                // host process running somewhere which is also trying to create nodes right now.  It might
+                // find our newly created node and connect to it before we get a chance.
+                int retries = NodeCreationRetries;
+                while (retries-- > 0)
                 {
-                    if (FrameworkLocationHelper.GetPathToDotNetFrameworkV35(DotNetFrameworkArchitecture.Current) == null)
+#if FEATURE_NET35_TASKHOST
+                    // We will also check to see if .NET 3.5 is installed in the case where we need to launch a CLR2 OOP TaskHost.
+                    // Failure to detect this has been known to stall builds when Windows pops up a related dialog.
+                    // It's also a waste of time when we attempt several times to launch multiple MSBuildTaskHost.exe (CLR2 TaskHost)
+                    // nodes because we should never be able to connect in this case.
+                    string taskHostNameForClr2TaskHost = Path.GetFileNameWithoutExtension(NodeProviderOutOfProcTaskHost.TaskHostNameForClr2TaskHost);
+                    if (Path.GetFileNameWithoutExtension(msbuildLocation).Equals(taskHostNameForClr2TaskHost, StringComparison.OrdinalIgnoreCase))
                     {
-                        CommunicationsUtilities.Trace
+                        if (FrameworkLocationHelper.GetPathToDotNetFrameworkV35(DotNetFrameworkArchitecture.Current) == null)
+                        {
+                            CommunicationsUtilities.Trace
                             (
                                 "Failed to launch node from {0}. The required .NET Framework v3.5 is not installed or enabled. CommandLine: {1}",
                                 msbuildLocation,
                                 commandLineArgs
                             );
 
-                        string nodeFailedToLaunchError = ResourceUtilities.GetResourceString("TaskHostNodeFailedToLaunchErrorCodeNet35NotInstalled");
-                        throw new NodeFailedToLaunchException(null, nodeFailedToLaunchError);
+                            string nodeFailedToLaunchError = ResourceUtilities.GetResourceString("TaskHostNodeFailedToLaunchErrorCodeNet35NotInstalled");
+                            throw new NodeFailedToLaunchException(null, nodeFailedToLaunchError);
+                        }
                     }
-                }
 #endif
+                    // Create the node process
+                    Process msbuildProcess = LaunchNode(msbuildLocation, commandLineArgs);
+                    _processesToIgnore.TryAdd(GetProcessesToIgnoreKey(hostHandshake, msbuildProcess.Id), default);
 
-                // Create the node process
-                Process msbuildProcess = LaunchNode(msbuildLocation, commandLineArgs);
-                _processesToIgnore.Add(GetProcessesToIgnoreKey(hostHandshake, msbuildProcess.Id));
+                    // Note, when running under IMAGEFILEEXECUTIONOPTIONS registry key to debug, the process ID
+                    // gotten back from CreateProcess is that of the debugger, which causes this to try to connect
+                    // to the debugger process. Instead, use MSBUILDDEBUGONSTART=1
 
-                // Note, when running under IMAGEFILEEXECUTIONOPTIONS registry key to debug, the process ID
-                // gotten back from CreateProcess is that of the debugger, which causes this to try to connect
-                // to the debugger process. Instead, use MSBUILDDEBUGONSTART=1
+                    // Now try to connect to it.
+                    Stream nodeStream = TryConnectToProcess(msbuildProcess.Id, TimeoutForNewNodeCreation, hostHandshake);
+                    if (nodeStream != null)
+                    {
+                        // Connection successful, use this node.
+                        CommunicationsUtilities.Trace("Successfully connected to created node {0} which is PID {1}", nodeId, msbuildProcess.Id);
 
-                // Now try to connect to it.
-                Stream nodeStream = TryConnectToProcess(msbuildProcess.Id, TimeoutForNewNodeCreation, hostHandshake);
-                if (nodeStream != null)
-                {
-                    // Connection successful, use this node.
-                    CommunicationsUtilities.Trace("Successfully connected to created node {0} which is PID {1}", nodeId, msbuildProcess.Id);
-                    return new NodeContext(nodeId, msbuildProcess, nodeStream, factory, terminateNode);
-                }
+                        CreateNodeContext(nodeId, msbuildProcess, nodeStream);
+                        return true;
+                    }
 
-                if (msbuildProcess.HasExited)
-                {
-                    if (Traits.Instance.DebugNodeCommunication)
+                    if (msbuildProcess.HasExited)
                     {
-                        try
+                        if (Traits.Instance.DebugNodeCommunication)
                         {
-                            CommunicationsUtilities.Trace("Could not connect to node with PID {0}; it has exited with exit code {1}. This can indicate a crash at startup", msbuildProcess.Id, msbuildProcess.ExitCode);
-                        }
-                        catch (InvalidOperationException)
-                        {
-                            // This case is common on Windows where we called CreateProcess and the Process object
-                            // can't get the exit code.
-                            CommunicationsUtilities.Trace("Could not connect to node with PID {0}; it has exited with unknown exit code. This can indicate a crash at startup", msbuildProcess.Id);
+                            try
+                            {
+                                CommunicationsUtilities.Trace("Could not connect to node with PID {0}; it has exited with exit code {1}. This can indicate a crash at startup", msbuildProcess.Id, msbuildProcess.ExitCode);
+                            }
+                            catch (InvalidOperationException)
+                            {
+                                // This case is common on Windows where we called CreateProcess and the Process object
+                                // can't get the exit code.
+                                CommunicationsUtilities.Trace("Could not connect to node with PID {0}; it has exited with unknown exit code. This can indicate a crash at startup", msbuildProcess.Id);
+                            }
                         }
                     }
+                    else
+                    {
+                        CommunicationsUtilities.Trace("Could not connect to node with PID {0}; it is still running. This can occur when two multiprocess builds run in parallel and the other one 'stole' this node", msbuildProcess.Id);
+                    }
                 }
-                else
-                {
-                    CommunicationsUtilities.Trace("Could not connect to node with PID {0}; it is still running. This can occur when two multiprocess builds run in parallel and the other one 'stole' this node", msbuildProcess.Id);
-                }
+
+                return false;
             }
 
-            // We were unable to launch a node.
-            CommunicationsUtilities.Trace("FAILED TO CONNECT TO A CHILD NODE");
-            return null;
+            void CreateNodeContext(int nodeId, Process nodeToReuse, Stream nodeStream)
+            {
+                NodeContext nodeContext = new(nodeId, nodeToReuse, nodeStream, factory, terminateNode);
+                nodeContexts.Enqueue(nodeContext);
+                createNode(nodeContext);
+            }
         }
 
         /// <summary>
@@ -323,9 +389,9 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
         /// <param name="msbuildLocation"></param>
         /// <returns>
         /// Item 1 is the name of the process being searched for.
-        /// Item 2 is the list of processes themselves.
+        /// Item 2 is the ConcurrentQueue of ordered processes themselves.
         /// </returns>
-        private (string expectedProcessName, List<Process> nodeProcesses) GetPossibleRunningNodes(string msbuildLocation = null)
+        private (string expectedProcessName, IList<Process> nodeProcesses) GetPossibleRunningNodes(string msbuildLocation = null)
         {
             if (String.IsNullOrEmpty(msbuildLocation))
             {
@@ -334,12 +400,10 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
 
             var expectedProcessName = Path.GetFileNameWithoutExtension(GetCurrentHost() ?? msbuildLocation);
 
-            List<Process> nodeProcesses = new List<Process>(Process.GetProcessesByName(expectedProcessName));
-
-            // Trivial sort to try to prefer most recently used nodes
-            nodeProcesses.Sort((left, right) => left.Id - right.Id);
+            var processes = Process.GetProcessesByName(expectedProcessName);
+            Array.Sort(processes, (left, right) => left.Id.CompareTo(right.Id));
 
-            return (expectedProcessName, nodeProcesses);
+            return (expectedProcessName, processes);
         }
 
         /// <summary>
@@ -665,6 +729,8 @@ enum ExitPacketState
             /// </summary>
             private readonly Process _process;
 
+            internal Process Process { get { return _process; } }
+
             /// <summary>
             /// An array used to store the header byte for each packet when read.
             /// </summary>
@@ -728,6 +794,11 @@ public NodeContext(int nodeId, Process process,
                 _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();
             }
 
+            /// <summary>
+            /// Id of node.
+            /// </summary>
+            public int NodeId => _nodeId;
+
             /// <summary>
             /// Starts a new asynchronous read operation for this node.
             /// </summary>
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index 7ac00b41d4d..b9a9d2a2f2f 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -9,6 +9,7 @@
 
 using Microsoft.Build.Shared;
 using Microsoft.Build.Internal;
+using System.Linq;
 
 #nullable disable
 
@@ -37,6 +38,11 @@ internal class NodeProviderOutOfProcTaskHost : NodeProviderOutOfProcBase, INodeP
         /// </summary>
         private static string s_baseTaskHostPath64;
 
+        /// <summary>
+        /// Store the 64-bit path for MSBuild / MSBuildTaskHost so that we don't have to keep recalculating it.
+        /// </summary>
+        private static string s_baseTaskHostPathArm64;
+
         /// <summary>
         /// Store the path for the 32-bit MSBuildTaskHost so that we don't have to keep re-calculating it.
         /// </summary>
@@ -57,6 +63,11 @@ internal class NodeProviderOutOfProcTaskHost : NodeProviderOutOfProcBase, INodeP
         /// </summary>
         private static string s_pathToX64Clr4;
 
+        /// <summary>
+        /// Store the path for the 64-bit MSBuild so that we don't have to keep re-calculating it.
+        /// </summary>
+        private static string s_pathToArm64Clr4;
+
         /// <summary>
         /// Name for MSBuild.exe
         /// </summary>
@@ -151,7 +162,7 @@ internal static string TaskHostNameForClr2TaskHost
         /// <summary>
         /// Instantiates a new MSBuild process acting as a child node.
         /// </summary>
-        public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration configuration)
+        public IList<NodeInfo> CreateNodes(int nextNodeId, INodePacketFactory packetFactory, Func<NodeInfo, NodeConfiguration> configurationFactory, int numberOfNodesToCreate)
         {
             throw new NotImplementedException("Use the other overload of CreateNode instead");
         }
@@ -353,8 +364,10 @@ internal static void ClearCachedTaskHostPaths()
             s_pathToX32Clr4 = null;
             s_pathToX64Clr2 = null;
             s_pathToX64Clr4 = null;
+            s_pathToArm64Clr4 = null;
             s_baseTaskHostPath = null;
             s_baseTaskHostPath64 = null;
+            s_baseTaskHostPathArm64 = null;
         }
 
         /// <summary>
@@ -392,13 +405,20 @@ internal static string GetTaskHostNameFromHostContext(HandshakeOptions hostConte
         internal static string GetMSBuildLocationFromHostContext(HandshakeOptions hostContext)
         {
             string toolName = GetTaskHostNameFromHostContext(hostContext);
-            string toolPath;
+            string toolPath = null;
 
             s_baseTaskHostPath = BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32;
             s_baseTaskHostPath64 = BuildEnvironmentHelper.Instance.MSBuildToolsDirectory64;
+            s_baseTaskHostPathArm64 = BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryArm64;
+
             ErrorUtilities.VerifyThrowInternalErrorUnreachable((hostContext & HandshakeOptions.TaskHost) == HandshakeOptions.TaskHost);
 
-            if ((hostContext & HandshakeOptions.X64) == HandshakeOptions.X64 && (hostContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2)
+            if ((hostContext & HandshakeOptions.Arm64) == HandshakeOptions.Arm64 && (hostContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2)
+            {
+                // Unsupported, throw.
+                ErrorUtilities.ThrowInternalError("ARM64 CLR2 task hosts are not supported.");
+            }
+            else if ((hostContext & HandshakeOptions.X64) == HandshakeOptions.X64 && (hostContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2)
             {
                 if (s_pathToX64Clr2 == null)
                 {
@@ -434,6 +454,15 @@ internal static string GetMSBuildLocationFromHostContext(HandshakeOptions hostCo
 
                 toolPath = s_pathToX64Clr4;
             }
+            else if ((hostContext & HandshakeOptions.Arm64) == HandshakeOptions.Arm64)
+            {
+                if (s_pathToArm64Clr4 == null)
+                {
+                    s_pathToArm64Clr4 = s_baseTaskHostPathArm64;
+                }
+
+                toolPath = s_pathToArm64Clr4;
+            }
             else
             {
                 if (s_pathToX32Clr4 == null)
@@ -509,7 +538,7 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor
 
             // Start the new process.  We pass in a node mode with a node number of 2, to indicate that we
             // want to start up an MSBuild task host node.
-            string commandLineArgs = $" /nologo /nodemode:2 /nodereuse:{ComponentHost.BuildParameters.EnableNodeReuse} ";
+            string commandLineArgs = $" /nologo /nodemode:2 /nodereuse:{ComponentHost.BuildParameters.EnableNodeReuse} /low:{ComponentHost.BuildParameters.LowPriority} ";
 
             string msbuildLocation = GetMSBuildLocationFromHostContext(hostContext);
 
@@ -521,31 +550,36 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor
 
             CommunicationsUtilities.Trace("For a host context of {0}, spawning executable from {1}.", hostContext.ToString(), msbuildLocation ?? "MSBuild.exe");
 
-            // Make it here.
-            NodeContext context = GetNode
-                                    (
-                                        msbuildLocation,
-                                        commandLineArgs,
-                                        (int)hostContext,
-                                        this,
-                                        new Handshake(hostContext),
-                                        NodeContextTerminated
-                                    );
-
-            if (context != null)
-            {
-                _nodeContexts[hostContext] = context;
+            // There is always one task host per host context so we always create just 1 one task host node here.
+            int nodeId = (int)hostContext;
+            IList<NodeContext> nodeContexts = GetNodes(
+                msbuildLocation,
+                commandLineArgs,
+                nodeId,
+                this,
+                new Handshake(hostContext),
+                NodeContextCreated,
+                NodeContextTerminated,
+                1);
+
+            return nodeContexts.Count == 1;
+        }
 
-                // Start the asynchronous read.
-                context.BeginAsyncPacketRead();
+        /// <summary>
+        /// Method called when a context created.
+        /// </summary>
+        private void NodeContextCreated(NodeContext context)
+        {
+            _nodeContexts[(HandshakeOptions)context.NodeId] = context;
 
-                _activeNodes.Add((int)hostContext);
-                _noNodesActiveEvent.Reset();
+            // Start the asynchronous read.
+            context.BeginAsyncPacketRead();
 
-                return true;
+            lock (_activeNodes)
+            {
+                _activeNodes.Add(context.NodeId);
             }
-
-            return false;
+            _noNodesActiveEvent.Reset();
         }
 
         /// <summary>
@@ -572,5 +606,10 @@ private void NodeContextTerminated(int nodeId)
                 }
             }
         }
+
+        public IEnumerable<Process> GetProcesses()
+        {
+            return _nodeContexts.Values.Select(context => context.Process);
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
index 7c539f906e9..2b2102095b8 100644
--- a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
@@ -4,6 +4,8 @@
 using System;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Execution;
+using System.Collections.Generic;
+using System.Diagnostics;
 
 #nullable disable
 
@@ -42,14 +44,10 @@ private TaskHostNodeManager()
 
         /// <summary>
         /// Creates a node on an available NodeProvider, if any..
+        /// Not used - base class <see cref="NodeProviderOutOfProcBase"/> implementation is reused instead.
         /// </summary>
-        /// <param name="configuration">The configuration to use for the remote node.</param>
-        /// <param name="nodeAffinity">The <see cref="NodeAffinity"/> to use.</param>
-        /// <returns>A NodeInfo describing the node created, or null if none could be created.</returns>
-        public NodeInfo CreateNode(NodeConfiguration configuration, NodeAffinity nodeAffinity)
-        {
-            throw new NotSupportedException("not used");
-        }
+        public IList<NodeInfo> CreateNodes(NodeConfiguration configuration, NodeAffinity affinity, int numberOfNodesToCreate)
+            => throw new NotSupportedException("not used");
 
         /// <summary>
         /// Sends data to the specified node.
@@ -171,5 +169,10 @@ static internal IBuildComponent CreateComponent(BuildComponentType type)
             ErrorUtilities.VerifyThrow(type == BuildComponentType.TaskHostNodeManager, "Cannot create component of type {0}", type);
             return new TaskHostNodeManager();
         }
+
+        IEnumerable<Process> INodeManager.GetProcesses()
+        {
+            return _outOfProcTaskHostNodeProvider.GetProcesses();
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/IBuildComponent.cs b/src/Build/BackEnd/Components/IBuildComponent.cs
index a133f4f31e1..6ee30b83ed9 100644
--- a/src/Build/BackEnd/Components/IBuildComponent.cs
+++ b/src/Build/BackEnd/Components/IBuildComponent.cs
@@ -1,8 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#nullable disable
-
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 6f1f5152377..2f08099b333 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -4,12 +4,11 @@
 using System;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Globalization;
 using System.Linq;
 using System.Reflection;
 using System.Threading;
-using System.Threading.Tasks.Dataflow;
+using System.Threading.Tasks;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using InternalLoggerException = Microsoft.Build.Exceptions.InternalLoggerException;
@@ -103,7 +102,7 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         /// <summary>
         /// The mapping of build request configuration ids to project file names.
         /// </summary>
-        private Dictionary<int, string> _projectFileMap;
+        private ConcurrentDictionary<int, string> _projectFileMap;
 
         /// <summary>
         /// The current state of the logging service
@@ -167,12 +166,12 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         /// <summary>
         /// The next project ID to assign when a project evaluation started event is received.
         /// </summary>
-        private int _nextEvaluationId = 1;
+        private int _nextEvaluationId;
 
         /// <summary>
         /// The next project ID to assign when a project started event is received.
         /// </summary>
-        private int _nextProjectId = 1;
+        private int _nextProjectId;
 
         /// <summary>
         /// The next target ID to assign when a target started event is received.
@@ -239,14 +238,32 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         #region LoggingThread Data
 
         /// <summary>
-        /// The data flow buffer for logging events.
+        /// Queue for asynchronous event processing.
         /// </summary>
-        private BufferBlock<object> _loggingQueue;
+        private ConcurrentQueue<object> _eventQueue;
 
         /// <summary>
-        /// The data flow processor for logging events.
+        /// Event set when message is consumed from queue.
         /// </summary>
-        private ActionBlock<object> _loggingQueueProcessor;
+        private ManualResetEventSlim _dequeueEvent;
+        /// <summary>
+        /// Event set when queue become empty.
+        /// </summary>
+        private ManualResetEventSlim _emptyQueueEvent;
+        /// <summary>
+        /// Even set when message is added into queue.
+        /// </summary>
+        private ManualResetEventSlim _enqueueEvent;
+
+        /// <summary>
+        /// CTS for stopping logging event processing.
+        /// </summary>
+        private CancellationTokenSource _loggingEventProcessingCancellation;
+
+        /// <summary>
+        /// Task which pump/process messages from <see cref="_eventQueue"/>
+        /// </summary>
+        private Thread _loggingEventProcessingThread;
 
         /// <summary>
         /// The queue size above which the queue will close to messages from remote nodes.
@@ -276,7 +293,7 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         /// <param name="nodeId">The node identifier.</param>
         protected LoggingService(LoggerMode loggerMode, int nodeId)
         {
-            _projectFileMap = new Dictionary<int, string>();
+            _projectFileMap = new ConcurrentDictionary<int, string>();
             _logMode = loggerMode;
             _loggers = new List<ILogger>();
             _loggerDescriptions = new List<LoggerDescription>();
@@ -301,7 +318,7 @@ protected LoggingService(LoggerMode loggerMode, int nodeId)
 
             if (_logMode == LoggerMode.Asynchronous)
             {
-                CreateLoggingEventQueue();
+                StartLoggingEventProcessing();
             }
 
             // Ensure the static constructor of ItemGroupLoggingHelper runs.
@@ -372,11 +389,8 @@ public int NextEvaluationId
         {
             get
             {
-                lock (_lockObject)
-                {
-                    _nextEvaluationId += MaxCPUCount + 2 /* We can create one node more than the maxCPU count (this can happen if either the inproc or out of proc node has not been created yet and the project collection needs to be counted also)*/;
-                    return _nextEvaluationId;
-                }
+                // We can create one node more than the maxCPU count (this can happen if either the inproc or out of proc node has not been created yet and the project collection needs to be counted also)
+                return Interlocked.Add(ref _nextEvaluationId, MaxCPUCount + 2);
             }
         }
 
@@ -388,11 +402,8 @@ public int NextProjectId
         {
             get
             {
-                lock (_lockObject)
-                {
-                    _nextProjectId += MaxCPUCount + 2 /* We can create one node more than the maxCPU count (this can happen if either the inproc or out of proc node has not been created yet and the project collection needs to be counted also)*/;
-                    return _nextProjectId;
-                }
+                // We can create one node more than the maxCPU count (this can happen if either the inproc or out of proc node has not been created yet and the project collection needs to be counted also)
+                return Interlocked.Add(ref _nextProjectId, MaxCPUCount + 2);
             }
         }
 
@@ -404,11 +415,7 @@ public int NextTargetId
         {
             get
             {
-                lock (_lockObject)
-                {
-                    _nextTargetId++;
-                    return _nextTargetId;
-                }
+                return Interlocked.Increment(ref _nextTargetId);
             }
         }
 
@@ -420,11 +427,7 @@ public int NextTaskId
         {
             get
             {
-                lock (_lockObject)
-                {
-                    _nextTaskId++;
-                    return _nextTaskId;
-                }
+                return Interlocked.Increment(ref _nextTaskId);
             }
         }
 
@@ -690,28 +693,6 @@ private void AddWarningsAsMessagesOrErrors(ref IDictionary<int, ISet<string>> wa
             }
         }
 
-        /// <summary>
-        /// Return whether or not the LoggingQueue has any events left in it
-        /// </summary>
-        public bool LoggingQueueHasEvents
-        {
-            get
-            {
-                lock (_lockObject)
-                {
-                    if (_loggingQueue != null)
-                    {
-                        return _loggingQueue.Count > 0;
-                    }
-                    else
-                    {
-                        ErrorUtilities.ThrowInternalError("loggingQueue is null");
-                        return false;
-                    }
-                }
-            }
-        }
-
         /// <summary>
         /// Return an array which contains the logger type names
         /// this can be used to display which loggers are registered on the node
@@ -861,7 +842,7 @@ public void ShutdownComponent()
                         // 2. Terminate the logging event queue
                         if (_logMode == LoggerMode.Asynchronous)
                         {
-                            TerminateLoggingEventQueue();
+                            TerminateLoggingEventProcessing();
                         }
                     }
 
@@ -885,12 +866,7 @@ public void ShutdownComponent()
                     // sink for the central loggers.
                     _centralForwardingLoggerSinkId = -1;
 
-                    // Clean up anything related to the asynchronous logging
-                    if (_logMode == LoggerMode.Asynchronous)
-                    {
-                        _loggingQueue = null;
-                        _loggingQueueProcessor = null;
-                    }
+                    CleanLoggingEventProcessing();
 
                     _loggers = new List<ILogger>();
                     _loggerDescriptions = null;
@@ -924,7 +900,7 @@ public void PacketReceived(int node, INodePacket packet)
 
             LogMessagePacket loggingPacket = (LogMessagePacket)packet;
             InjectNonSerializedData(loggingPacket);
-            ProcessLoggingEvent(loggingPacket.NodeBuildEvent, allowThrottling: true);
+            ProcessLoggingEvent(loggingPacket.NodeBuildEvent);
         }
 
         /// <summary>
@@ -1150,46 +1126,43 @@ public void InitializeNodeLoggers(ICollection<LoggerDescription> descriptions, I
         /// <exception cref="InternalErrorException">buildEvent is null</exception>
         public void LogBuildEvent(BuildEventArgs buildEvent)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(buildEvent != null, "buildEvent is null");
+            ErrorUtilities.VerifyThrow(buildEvent != null, "buildEvent is null");
 
-                BuildWarningEventArgs warningEvent = null;
-                BuildErrorEventArgs errorEvent = null;
-                BuildMessageEventArgs messageEvent = null;
+            BuildWarningEventArgs warningEvent = null;
+            BuildErrorEventArgs errorEvent = null;
+            BuildMessageEventArgs messageEvent = null;
 
-                if ((warningEvent = buildEvent as BuildWarningEventArgs) != null && warningEvent.BuildEventContext != null && warningEvent.BuildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
-                {
-                    warningEvent.ProjectFile = GetAndVerifyProjectFileFromContext(warningEvent.BuildEventContext);
-                }
-                else if ((errorEvent = buildEvent as BuildErrorEventArgs) != null && errorEvent.BuildEventContext != null && errorEvent.BuildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
-                {
-                    errorEvent.ProjectFile = GetAndVerifyProjectFileFromContext(errorEvent.BuildEventContext);
-                }
-                else if ((messageEvent = buildEvent as BuildMessageEventArgs) != null && messageEvent.BuildEventContext != null && messageEvent.BuildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
-                {
-                    messageEvent.ProjectFile = GetAndVerifyProjectFileFromContext(messageEvent.BuildEventContext);
-                }
+            if ((warningEvent = buildEvent as BuildWarningEventArgs) != null && warningEvent.BuildEventContext != null && warningEvent.BuildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
+            {
+                warningEvent.ProjectFile = GetAndVerifyProjectFileFromContext(warningEvent.BuildEventContext);
+            }
+            else if ((errorEvent = buildEvent as BuildErrorEventArgs) != null && errorEvent.BuildEventContext != null && errorEvent.BuildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
+            {
+                errorEvent.ProjectFile = GetAndVerifyProjectFileFromContext(errorEvent.BuildEventContext);
+            }
+            else if ((messageEvent = buildEvent as BuildMessageEventArgs) != null && messageEvent.BuildEventContext != null && messageEvent.BuildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
+            {
+                messageEvent.ProjectFile = GetAndVerifyProjectFileFromContext(messageEvent.BuildEventContext);
+            }
 
-                if (OnlyLogCriticalEvents)
-                {
-                    // Only log certain events if OnlyLogCriticalEvents is true
-                    if (
-                        (warningEvent != null)
-                        || (errorEvent != null)
-                        || (buildEvent is CustomBuildEventArgs)
-                        || (buildEvent is CriticalBuildMessageEventArgs)
-                       )
-                    {
-                        ProcessLoggingEvent(buildEvent);
-                    }
-                }
-                else
+            if (OnlyLogCriticalEvents)
+            {
+                // Only log certain events if OnlyLogCriticalEvents is true
+                if (
+                    (warningEvent != null)
+                    || (errorEvent != null)
+                    || (buildEvent is CustomBuildEventArgs)
+                    || (buildEvent is CriticalBuildMessageEventArgs)
+                   )
                 {
-                    // Log all events if OnlyLogCriticalEvents is false
                     ProcessLoggingEvent(buildEvent);
                 }
             }
+            else
+            {
+                // Log all events if OnlyLogCriticalEvents is false
+                ProcessLoggingEvent(buildEvent);
+            }
         }
 
         #endregion
@@ -1202,20 +1175,22 @@ public void LogBuildEvent(BuildEventArgs buildEvent)
         /// In Synchronous mode the event should be routed to the correct sink or logger right away
         /// </summary>
         /// <param name="buildEvent">BuildEventArgs to process</param>
-        /// <param name="allowThrottling"><code>true</code> to allow throttling, otherwise <code>false</code>.</param>
         /// <exception cref="InternalErrorException">buildEvent is null</exception>
-        internal virtual void ProcessLoggingEvent(object buildEvent, bool allowThrottling = false)
+        internal virtual void ProcessLoggingEvent(object buildEvent)
         {
             ErrorUtilities.VerifyThrow(buildEvent != null, "buildEvent is null");
             if (_logMode == LoggerMode.Asynchronous)
             {
-                // If the queue is at capacity, this call will block - the task returned by SendAsync only completes 
-                // when the message is actually consumed or rejected (permanently) by the buffer.
-                var task = _loggingQueue.SendAsync(buildEvent);
-                if (allowThrottling)
+                // Block until queue is not full.
+                while (_eventQueue.Count >= _queueCapacity)
                 {
-                    task.Wait();
+                    // Block and wait for dequeue event.
+                    _dequeueEvent.Wait();
+                    _dequeueEvent.Reset();
                 }
+
+                _eventQueue.Enqueue(buildEvent);
+                _enqueueEvent.Set();
             }
             else
             {
@@ -1227,41 +1202,21 @@ internal virtual void ProcessLoggingEvent(object buildEvent, bool allowThrottlin
         }
 
         /// <summary>
-        /// Wait for the logging messages in the logging queue to be completly processed.
+        /// Wait for the logging messages in the logging queue to be completely processed.
         /// This is required because for Logging build finished or when the component is to shutdown
         /// we need to make sure we process all of the events before the build finished event is raised
         /// and we need to make sure we process all of the logging events before we shutdown the component.
         /// </summary>
-        internal void WaitForThreadToProcessEvents()
+        public void WaitForLoggingToProcessEvents()
         {
-            // This method may be called in the shutdown submission callback, this callback may be called after the logging service has 
-            // shutdown and nulled out the events we were going to wait on.
-            if (_logMode == LoggerMode.Asynchronous && _loggingQueue != null)
+            while (_eventQueue?.IsEmpty == false)
             {
-                BufferBlock<object> loggingQueue = null;
-                ActionBlock<object> loggingQueueProcessor = null;
-
-                lock (_lockObject)
-                {
-                    loggingQueue = _loggingQueue;
-                    loggingQueueProcessor = _loggingQueueProcessor;
-
-                    // Replaces _loggingQueue and _loggingQueueProcessor with new one, this will assure that
-                    // no further messages could possibly be trying to be added into queue we are about to drain
-                    CreateLoggingEventQueue();
-                }
-
-                // Drain queue.
-                // This shall not be locked to avoid possible deadlock caused by
-                // event handlers to reenter 'this' instance while trying to log something.
-                if (loggingQueue != null)
-                {
-                    Debug.Assert(!Monitor.IsEntered(_lockObject));
-
-                    loggingQueue.Complete();
-                    loggingQueueProcessor.Completion.Wait();
-                }
+                _emptyQueueEvent?.Wait();
             }
+            // To avoid race condition when last message has been removed from queue but
+            //   not yet fully processed (handled by loggers), we need to make sure _emptyQueueEvent
+            //   is set as it is guaranteed to be in set state no sooner than after event has been processed.
+            _emptyQueueEvent?.Wait();
         }
 
         /// <summary>
@@ -1305,55 +1260,81 @@ private static int GetWarningsAsErrorOrMessageKey(BuildEventArgs buildEventArgs)
         }
 
         /// <summary>
-        /// Create a logging thread to process the logging queue
+        /// Create a logging thread to process the logging queue.
         /// </summary>
-        private void CreateLoggingEventQueue()
+        private void StartLoggingEventProcessing()
         {
-            // We are creating a two-node dataflow graph here.  The first node is a buffer, which will hold up to the number of
-            // logging events we have specified as the queueCapacity.  The second node is the processor which will actually process each message.
-            // When the capacity of the buffer is reached, further attempts to send messages to it will block.
-            // The reason we can't just set the BoundedCapacity on the processing block is that ActionBlock has some weird behavior
-            // when the queue capacity is reached.  Specifically, it will block new messages from being processed until it has
-            // entirely drained its input queue, as opposed to letting new ones in as old ones are processed.  This is logged as 
-            // a perf bug (305575) against Dataflow.  If they choose to fix it, we can eliminate the buffer node from the graph.
-            var dataBlockOptions = new DataflowBlockOptions
-            {
-                BoundedCapacity = Convert.ToInt32(_queueCapacity)
-            };
-
-            var loggingQueue = new BufferBlock<object>(dataBlockOptions);
-
-            var executionDataBlockOptions = new ExecutionDataflowBlockOptions
+            _eventQueue = new ConcurrentQueue<object>();
+            _dequeueEvent = new ManualResetEventSlim(false);
+            _emptyQueueEvent = new ManualResetEventSlim(false);
+            _enqueueEvent = new ManualResetEventSlim(false);
+            _loggingEventProcessingCancellation = new CancellationTokenSource();
+
+            _loggingEventProcessingThread = new Thread(LoggingEventProc);
+            _loggingEventProcessingThread.Name = $"MSBuild LoggingService events queue pump: {this.GetHashCode()}";
+            _loggingEventProcessingThread.IsBackground = true;
+            _loggingEventProcessingThread.Start();
+
+            void LoggingEventProc()
             {
-                BoundedCapacity = 1
-            };
+                var completeAdding = _loggingEventProcessingCancellation.Token;
+                WaitHandle[] waitHandlesForNextEvent = { completeAdding.WaitHandle, _enqueueEvent.WaitHandle };
 
-            var loggingQueueProcessor = new ActionBlock<object>(loggingEvent => LoggingEventProcessor(loggingEvent), executionDataBlockOptions);
+                do
+                {
+                    if (_eventQueue.TryDequeue(out object ev))
+                    {
+                        LoggingEventProcessor(ev);
+                        _dequeueEvent.Set();
+                    }
+                    else
+                    {
+                        _emptyQueueEvent.Set();
 
-            var dataLinkOptions = new DataflowLinkOptions
-            {
-                PropagateCompletion = true
-            };
+                        // Wait for next event, or finish.
+                        if (!completeAdding.IsCancellationRequested && _eventQueue.IsEmpty)
+                        {
+                            WaitHandle.WaitAny(waitHandlesForNextEvent);
+                        }
 
-            loggingQueue.LinkTo(loggingQueueProcessor, dataLinkOptions);
+                        _enqueueEvent.Reset();
+                        _emptyQueueEvent.Reset();
+                    }
+                } while (!_eventQueue.IsEmpty || !completeAdding.IsCancellationRequested);
 
-            lock (_lockObject)
-            {
-                _loggingQueue = loggingQueue;
-                _loggingQueueProcessor = loggingQueueProcessor;
+                _emptyQueueEvent.Set();
             }
         }
 
+
         /// <summary>
-        /// Wait for the logginQueue to empty and then terminate the logging thread
+        /// Clean resources used for logging event processing queue.
         /// </summary>
-        private void TerminateLoggingEventQueue()
+        private void CleanLoggingEventProcessing()
         {
-            // Dont accept any more items from other threads.
-            _loggingQueue.Complete();
+            _loggingEventProcessingCancellation?.Cancel();
+            _dequeueEvent?.Dispose();
+            _enqueueEvent?.Dispose();
+            _emptyQueueEvent?.Dispose();
+            _loggingEventProcessingCancellation?.Dispose();
+
+            _eventQueue = null;
+            _dequeueEvent = null;
+            _enqueueEvent = null;
+            _emptyQueueEvent = null;
+            _loggingEventProcessingCancellation = null;
+            _loggingEventProcessingThread = null;
+        }
 
-            // Wait for completion
-            _loggingQueueProcessor.Completion.Wait();
+        /// <summary>
+        /// Create a logging thread to process the logging queue
+        /// </summary>
+        private void TerminateLoggingEventProcessing()
+        {
+            // Capture pump task in local variable as cancelling event processing is nulling _loggingEventProcessingThread.
+            var pumpTask = _loggingEventProcessingThread;
+            _loggingEventProcessingCancellation.Cancel();
+            pumpTask.Join();
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index e1906fde381..214a5118c2c 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -33,14 +33,11 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         /// <exception cref="InternalErrorException">MessageResourceName is null</exception>
         public void LogComment(BuildEventContext buildEventContext, MessageImportance importance, string messageResourceName, params object[] messageArgs)
         {
-            lock (_lockObject)
+            if (!OnlyLogCriticalEvents)
             {
-                if (!OnlyLogCriticalEvents)
-                {
-                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(messageResourceName), "Need resource string for comment message.");
+                ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(messageResourceName), "Need resource string for comment message.");
 
-                    LogCommentFromText(buildEventContext, importance, ResourceUtilities.GetResourceString(messageResourceName), messageArgs);
-                }
+                LogCommentFromText(buildEventContext, importance, ResourceUtilities.GetResourceString(messageResourceName), messageArgs);
             }
         }
 
@@ -55,10 +52,7 @@ public void LogComment(BuildEventContext buildEventContext, MessageImportance im
         /// <exception cref="InternalErrorException">Message is null</exception>
         public void LogCommentFromText(BuildEventContext buildEventContext, MessageImportance importance, string message)
         {
-            lock (_lockObject)
-            {
-                this.LogCommentFromText(buildEventContext, importance, message, messageArgs: null);
-            }
+            this.LogCommentFromText(buildEventContext, importance, message, messageArgs: null);
         }
 
         /// <summary>
@@ -73,25 +67,22 @@ public void LogCommentFromText(BuildEventContext buildEventContext, MessageImpor
         /// <exception cref="InternalErrorException">Message is null</exception>
         public void LogCommentFromText(BuildEventContext buildEventContext, MessageImportance importance, string message, params object[] messageArgs)
         {
-            lock (_lockObject)
+            if (!OnlyLogCriticalEvents)
             {
-                if (!OnlyLogCriticalEvents)
-                {
-                    ErrorUtilities.VerifyThrow(buildEventContext != null, "buildEventContext was null");
-                    ErrorUtilities.VerifyThrow(message != null, "message was null");
-
-                    BuildMessageEventArgs buildEvent = new BuildMessageEventArgs
-                        (
-                            message,
-                            helpKeyword: null,
-                            senderName: "MSBuild",
-                            importance,
-                            DateTime.UtcNow,
-                            messageArgs
-                        );
-                    buildEvent.BuildEventContext = buildEventContext;
-                    ProcessLoggingEvent(buildEvent);
-                }
+                ErrorUtilities.VerifyThrow(buildEventContext != null, "buildEventContext was null");
+                ErrorUtilities.VerifyThrow(message != null, "message was null");
+
+                BuildMessageEventArgs buildEvent = new BuildMessageEventArgs
+                    (
+                        message,
+                        helpKeyword: null,
+                        senderName: "MSBuild",
+                        importance,
+                        DateTime.UtcNow,
+                        messageArgs
+                    );
+                buildEvent.BuildEventContext = buildEventContext;
+                ProcessLoggingEvent(buildEvent);
             }
         }
         #endregion
@@ -113,10 +104,7 @@ public void LogCommentFromText(BuildEventContext buildEventContext, MessageImpor
         /// <param name="messageArgs">Arguments for the string resource</param>
         public void LogError(BuildEventContext location, BuildEventFileInfo file, string messageResourceName, params object[] messageArgs)
         {
-            lock (_lockObject)
-            {
-                LogError(location, null, file, messageResourceName, messageArgs);
-            }
+            LogError(location, null, file, messageResourceName, messageArgs);
         }
 
         /// <summary>
@@ -130,14 +118,11 @@ public void LogError(BuildEventContext location, BuildEventFileInfo file, string
         /// <exception cref="InternalErrorException">MessageResourceName is null</exception>
         public void LogError(BuildEventContext buildEventContext, string subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, params object[] messageArgs)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(messageResourceName), "Need resource string for error message.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(messageResourceName), "Need resource string for error message.");
 
-                string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, messageResourceName, messageArgs);
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, messageResourceName, messageArgs);
 
-                LogErrorFromText(buildEventContext, subcategoryResourceName, errorCode, helpKeyword, file, message);
-            }
+            LogErrorFromText(buildEventContext, subcategoryResourceName, errorCode, helpKeyword, file, message);
         }
 
         /// <summary>
@@ -153,44 +138,41 @@ public void LogError(BuildEventContext buildEventContext, string subcategoryReso
         /// <exception cref="InternalErrorException">Message is null</exception>
         public void LogErrorFromText(BuildEventContext buildEventContext, string subcategoryResourceName, string errorCode, string helpKeyword, BuildEventFileInfo file, string message)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(buildEventContext != null, "Must specify the buildEventContext");
-                ErrorUtilities.VerifyThrow(file != null, "Must specify the associated file.");
-                ErrorUtilities.VerifyThrow(message != null, "Need error message.");
-
-                string subcategory = null;
+            ErrorUtilities.VerifyThrow(buildEventContext != null, "Must specify the buildEventContext");
+            ErrorUtilities.VerifyThrow(file != null, "Must specify the associated file.");
+            ErrorUtilities.VerifyThrow(message != null, "Need error message.");
 
-                if (subcategoryResourceName != null)
-                {
-                    subcategory = AssemblyResources.GetString(subcategoryResourceName);
-                }
+            string subcategory = null;
 
-                BuildErrorEventArgs buildEvent =
-                new BuildErrorEventArgs
-                (
-                    subcategory,
-                    errorCode,
-                    file.File,
-                    file.Line,
-                    file.Column,
-                    file.EndLine,
-                    file.EndColumn,
-                    message,
-                    helpKeyword,
-                    "MSBuild"
-                );
-
-                buildEvent.BuildEventContext = buildEventContext;
-                if (buildEvent.ProjectFile == null && buildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
-                {
-                    _projectFileMap.TryGetValue(buildEventContext.ProjectContextId, out string projectFile);
-                    ErrorUtilities.VerifyThrow(projectFile != null, "ContextID {0} should have been in the ID-to-project file mapping but wasn't!", buildEventContext.ProjectContextId);
-                    buildEvent.ProjectFile = projectFile;
-                }
+            if (subcategoryResourceName != null)
+            {
+                subcategory = AssemblyResources.GetString(subcategoryResourceName);
+            }
 
-                ProcessLoggingEvent(buildEvent);
+            BuildErrorEventArgs buildEvent =
+            new BuildErrorEventArgs
+            (
+                subcategory,
+                errorCode,
+                file.File,
+                file.Line,
+                file.Column,
+                file.EndLine,
+                file.EndColumn,
+                message,
+                helpKeyword,
+                "MSBuild"
+            );
+
+            buildEvent.BuildEventContext = buildEventContext;
+            if (buildEvent.ProjectFile == null && buildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
+            {
+                _projectFileMap.TryGetValue(buildEventContext.ProjectContextId, out string projectFile);
+                ErrorUtilities.VerifyThrow(projectFile != null, "ContextID {0} should have been in the ID-to-project file mapping but wasn't!", buildEventContext.ProjectContextId);
+                buildEvent.ProjectFile = projectFile;
             }
+
+            ProcessLoggingEvent(buildEvent);
         }
 
         /// <summary>
@@ -204,39 +186,36 @@ public void LogErrorFromText(BuildEventContext buildEventContext, string subcate
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
         public void LogInvalidProjectFileError(BuildEventContext buildEventContext, InvalidProjectFileException invalidProjectFileException)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(invalidProjectFileException != null, "Need exception context.");
-                ErrorUtilities.VerifyThrow(buildEventContext != null, "buildEventContext is null");
+            ErrorUtilities.VerifyThrow(invalidProjectFileException != null, "Need exception context.");
+            ErrorUtilities.VerifyThrow(buildEventContext != null, "buildEventContext is null");
 
-                // Don't log the exception more than once.
-                if (!invalidProjectFileException.HasBeenLogged)
+            // Don't log the exception more than once.
+            if (!invalidProjectFileException.HasBeenLogged)
+            {
+                BuildErrorEventArgs buildEvent =
+                    new BuildErrorEventArgs
+                    (
+                        invalidProjectFileException.ErrorSubcategory,
+                        invalidProjectFileException.ErrorCode,
+                        invalidProjectFileException.ProjectFile,
+                        invalidProjectFileException.LineNumber,
+                        invalidProjectFileException.ColumnNumber,
+                        invalidProjectFileException.EndLineNumber,
+                        invalidProjectFileException.EndColumnNumber,
+                        invalidProjectFileException.BaseMessage,
+                        invalidProjectFileException.HelpKeyword,
+                        "MSBuild"
+                    );
+                buildEvent.BuildEventContext = buildEventContext;
+                if (buildEvent.ProjectFile == null && buildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
                 {
-                    BuildErrorEventArgs buildEvent =
-                        new BuildErrorEventArgs
-                        (
-                            invalidProjectFileException.ErrorSubcategory,
-                            invalidProjectFileException.ErrorCode,
-                            invalidProjectFileException.ProjectFile,
-                            invalidProjectFileException.LineNumber,
-                            invalidProjectFileException.ColumnNumber,
-                            invalidProjectFileException.EndLineNumber,
-                            invalidProjectFileException.EndColumnNumber,
-                            invalidProjectFileException.BaseMessage,
-                            invalidProjectFileException.HelpKeyword,
-                            "MSBuild"
-                        );
-                    buildEvent.BuildEventContext = buildEventContext;
-                    if (buildEvent.ProjectFile == null && buildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
-                    {
-                        _projectFileMap.TryGetValue(buildEventContext.ProjectContextId, out string projectFile);
-                        ErrorUtilities.VerifyThrow(projectFile != null, "ContextID {0} should have been in the ID-to-project file mapping but wasn't!", buildEventContext.ProjectContextId);
-                        buildEvent.ProjectFile = projectFile;
-                    }
-
-                    ProcessLoggingEvent(buildEvent);
-                    invalidProjectFileException.HasBeenLogged = true;
+                    _projectFileMap.TryGetValue(buildEventContext.ProjectContextId, out string projectFile);
+                    ErrorUtilities.VerifyThrow(projectFile != null, "ContextID {0} should have been in the ID-to-project file mapping but wasn't!", buildEventContext.ProjectContextId);
+                    buildEvent.ProjectFile = projectFile;
                 }
+
+                ProcessLoggingEvent(buildEvent);
+                invalidProjectFileException.HasBeenLogged = true;
             }
         }
 
@@ -249,10 +228,7 @@ public void LogInvalidProjectFileError(BuildEventContext buildEventContext, Inva
         /// <param name="file">Provides file information about where the build error happened</param>
         public void LogFatalBuildError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file)
         {
-            lock (_lockObject)
-            {
-                LogFatalError(buildEventContext, exception, file, "FatalBuildError");
-            }
+            LogFatalError(buildEventContext, exception, file, "FatalBuildError");
         }
 
         /// <summary>
@@ -266,12 +242,9 @@ public void LogFatalBuildError(BuildEventContext buildEventContext, Exception ex
         /// <exception cref="InternalErrorException">TaskName is null</exception>
         public void LogFatalTaskError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string taskName)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(taskName != null, "Must specify the name of the task that failed.");
+            ErrorUtilities.VerifyThrow(taskName != null, "Must specify the name of the task that failed.");
 
-                LogFatalError(buildEventContext, exception, file, "FatalTaskError", taskName);
-            }
+            LogFatalError(buildEventContext, exception, file, "FatalTaskError", taskName);
         }
 
         /// <summary>
@@ -286,21 +259,18 @@ public void LogFatalTaskError(BuildEventContext buildEventContext, Exception exc
         /// <exception cref="InternalErrorException">MessageResourceName is null</exception>
         public void LogFatalError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string messageResourceName, params object[] messageArgs)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(messageResourceName), "Need resource string for error message.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(messageResourceName), "Need resource string for error message.");
 
-                string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, messageResourceName, messageArgs);
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, messageResourceName, messageArgs);
 #if DEBUG
-                message += Environment.NewLine + "This is an unhandled exception from a task -- PLEASE OPEN A BUG AGAINST THE TASK OWNER.";
+            message += Environment.NewLine + "This is an unhandled exception from a task -- PLEASE OPEN A BUG AGAINST THE TASK OWNER.";
 #endif
-                if (exception != null)
-                {
-                    message += Environment.NewLine + exception.ToString();
-                }
-
-                LogErrorFromText(buildEventContext, null, errorCode, helpKeyword, file, message);
+            if (exception != null)
+            {
+                message += Environment.NewLine + exception.ToString();
             }
+
+            LogErrorFromText(buildEventContext, null, errorCode, helpKeyword, file, message);
         }
 
         #endregion
@@ -323,22 +293,19 @@ public void LogFatalError(BuildEventContext buildEventContext, Exception excepti
         /// <param name="taskName">Name of the task which the warning is being raised from</param>
         public void LogTaskWarningFromException(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string taskName)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(!String.IsNullOrEmpty(taskName), "Must specify the name of the task that failed.");
+            ErrorUtilities.VerifyThrow(!String.IsNullOrEmpty(taskName), "Must specify the name of the task that failed.");
 
-                string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string warningCode, out string helpKeyword, "FatalTaskError", taskName);
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string warningCode, out string helpKeyword, "FatalTaskError", taskName);
 #if DEBUG
-                message += Environment.NewLine + "This is an unhandled exception from a task -- PLEASE OPEN A BUG AGAINST THE TASK OWNER.";
+            message += Environment.NewLine + "This is an unhandled exception from a task -- PLEASE OPEN A BUG AGAINST THE TASK OWNER.";
 #endif
 
-                if (exception != null)
-                {
-                    message += Environment.NewLine + exception.ToString();
-                }
-
-                LogWarningFromText(buildEventContext, null, warningCode, helpKeyword, file, message);
+            if (exception != null)
+            {
+                message += Environment.NewLine + exception.ToString();
             }
+
+            LogWarningFromText(buildEventContext, null, warningCode, helpKeyword, file, message);
         }
 
         /// <summary>
@@ -351,13 +318,10 @@ public void LogTaskWarningFromException(BuildEventContext buildEventContext, Exc
         /// <param name="messageArgs">Arguments for messageResourceName</param>
         public void LogWarning(BuildEventContext buildEventContext, string subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, params object[] messageArgs)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(messageResourceName), "Need resource string for warning message.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(messageResourceName), "Need resource string for warning message.");
 
-                string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string warningCode, out string helpKeyword, messageResourceName, messageArgs);
-                LogWarningFromText(buildEventContext, subcategoryResourceName, warningCode, helpKeyword, file, message);
-            }
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string warningCode, out string helpKeyword, messageResourceName, messageArgs);
+            LogWarningFromText(buildEventContext, subcategoryResourceName, warningCode, helpKeyword, file, message);
         }
 
         /// <summary>
@@ -371,43 +335,40 @@ public void LogWarning(BuildEventContext buildEventContext, string subcategoryRe
         /// <param name="message">Warning message to log</param>
         public void LogWarningFromText(BuildEventContext buildEventContext, string subcategoryResourceName, string warningCode, string helpKeyword, BuildEventFileInfo file, string message)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(file != null, "Must specify the associated file.");
-                ErrorUtilities.VerifyThrow(message != null, "Need warning message.");
-                ErrorUtilities.VerifyThrow(buildEventContext != null, "Need a BuildEventContext");
+            ErrorUtilities.VerifyThrow(file != null, "Must specify the associated file.");
+            ErrorUtilities.VerifyThrow(message != null, "Need warning message.");
+            ErrorUtilities.VerifyThrow(buildEventContext != null, "Need a BuildEventContext");
 
-                string subcategory = null;
+            string subcategory = null;
 
-                if (!string.IsNullOrWhiteSpace(subcategoryResourceName))
-                {
-                    subcategory = AssemblyResources.GetString(subcategoryResourceName);
-                }
-
-                BuildWarningEventArgs buildEvent = new BuildWarningEventArgs
-                    (
-                        subcategory,
-                        warningCode,
-                        file.File,
-                        file.Line,
-                        file.Column,
-                        file.EndLine,
-                        file.EndColumn,
-                        message,
-                        helpKeyword,
-                        "MSBuild"
-                    );
+            if (!string.IsNullOrWhiteSpace(subcategoryResourceName))
+            {
+                subcategory = AssemblyResources.GetString(subcategoryResourceName);
+            }
 
-                buildEvent.BuildEventContext = buildEventContext;
-                if (buildEvent.ProjectFile == null && buildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
-                {
-                    _projectFileMap.TryGetValue(buildEventContext.ProjectContextId, out string projectFile);
-                    ErrorUtilities.VerifyThrow(projectFile != null, "ContextID {0} should have been in the ID-to-project file mapping but wasn't!", buildEventContext.ProjectContextId);
-                    buildEvent.ProjectFile = projectFile;
-                }
+            BuildWarningEventArgs buildEvent = new BuildWarningEventArgs
+                (
+                    subcategory,
+                    warningCode,
+                    file.File,
+                    file.Line,
+                    file.Column,
+                    file.EndLine,
+                    file.EndColumn,
+                    message,
+                    helpKeyword,
+                    "MSBuild"
+                );
 
-                ProcessLoggingEvent(buildEvent);
+            buildEvent.BuildEventContext = buildEventContext;
+            if (buildEvent.ProjectFile == null && buildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
+            {
+                _projectFileMap.TryGetValue(buildEventContext.ProjectContextId, out string projectFile);
+                ErrorUtilities.VerifyThrow(projectFile != null, "ContextID {0} should have been in the ID-to-project file mapping but wasn't!", buildEventContext.ProjectContextId);
+                buildEvent.ProjectFile = projectFile;
             }
+
+            ProcessLoggingEvent(buildEvent);
         }
 
         #endregion
@@ -419,31 +380,28 @@ public void LogWarningFromText(BuildEventContext buildEventContext, string subca
         /// </summary>
         public void LogBuildStarted()
         {
-            lock (_lockObject)
+            // If we're only logging critical events, don't risk causing all the resources to load by formatting
+            // a string that won't get emitted anyway.
+            string message = String.Empty;
+            if (!OnlyLogCriticalEvents)
             {
-                // If we're only logging critical events, don't risk causing all the resources to load by formatting
-                // a string that won't get emitted anyway.
-                string message = String.Empty;
-                if (!OnlyLogCriticalEvents)
-                {
-                    message = ResourceUtilities.GetResourceString("BuildStarted");
-                }
+                message = ResourceUtilities.GetResourceString("BuildStarted");
+            }
 
-                IDictionary<string, string> environmentProperties = null;
+            IDictionary<string, string> environmentProperties = null;
 
-                if (_componentHost?.BuildParameters != null)
-                {
-                    environmentProperties = _componentHost.BuildParameters.BuildProcessEnvironment;
-                }
+            if (_componentHost?.BuildParameters != null)
+            {
+                environmentProperties = _componentHost.BuildParameters.BuildProcessEnvironment;
+            }
 
-                BuildStartedEventArgs buildEvent = new BuildStartedEventArgs(message, null /* no help keyword */, environmentProperties);
+            BuildStartedEventArgs buildEvent = new BuildStartedEventArgs(message, null /* no help keyword */, environmentProperties);
 
-                // Raise the event with the filters
-                ProcessLoggingEvent(buildEvent);
-            }
+            // Raise the event with the filters
+            ProcessLoggingEvent(buildEvent);
 
             // Make sure we process this event before going any further
-            WaitForThreadToProcessEvents();
+            WaitForLoggingToProcessEvents();
         }
 
         /// <summary>
@@ -452,23 +410,20 @@ public void LogBuildStarted()
         /// <param name="success">Did the build pass or fail</param>
         public void LogBuildFinished(bool success)
         {
-            lock (_lockObject)
+            // If we're only logging critical events, don't risk causing all the resources to load by formatting
+            // a string that won't get emitted anyway.
+            string message = String.Empty;
+            if (!OnlyLogCriticalEvents)
             {
-                // If we're only logging critical events, don't risk causing all the resources to load by formatting
-                // a string that won't get emitted anyway.
-                string message = String.Empty;
-                if (!OnlyLogCriticalEvents)
-                {
-                    message = ResourceUtilities.GetResourceString(success ? "BuildFinishedSuccess" : "BuildFinishedFailure");
-                }
+                message = ResourceUtilities.GetResourceString(success ? "BuildFinishedSuccess" : "BuildFinishedFailure");
+            }
 
-                BuildFinishedEventArgs buildEvent = new BuildFinishedEventArgs(message, null /* no help keyword */, success);
+            BuildFinishedEventArgs buildEvent = new BuildFinishedEventArgs(message, null /* no help keyword */, success);
 
-                ProcessLoggingEvent(buildEvent);
-            }
+            ProcessLoggingEvent(buildEvent);
 
             // Make sure we process this event before going any further
-            WaitForThreadToProcessEvents();
+            WaitForLoggingToProcessEvents();
         }
 
         /// <inheritdoc />
@@ -482,36 +437,30 @@ public BuildEventContext CreateProjectCacheBuildEventContext(
             int projectInstanceId,
             string projectFile)
         {
-            lock (_lockObject)
-            {
-                int projectContextId = NextProjectId;
+            int projectContextId = NextProjectId;
 
-                // In the future if some LogProjectCacheStarted event is created, move this there to align with evaluation and build execution.
-                _projectFileMap[projectContextId] = projectFile;
+            // In the future if some LogProjectCacheStarted event is created, move this there to align with evaluation and build execution.
+            _projectFileMap[projectContextId] = projectFile;
 
-                // Because the project cache runs in the BuildManager, it makes some sense to associate logging with the in-proc node.
-                // If a invalid node id is used the messages become deferred in the console logger and spit out at the end.
-                int nodeId = Scheduler.InProcNodeId;
+            // Because the project cache runs in the BuildManager, it makes some sense to associate logging with the in-proc node.
+            // If a invalid node id is used the messages become deferred in the console logger and spit out at the end.
+            int nodeId = Scheduler.InProcNodeId;
 
-                return new BuildEventContext(submissionId, nodeId, evaluationId, projectInstanceId, projectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
-            }
+            return new BuildEventContext(submissionId, nodeId, evaluationId, projectInstanceId, projectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
         }
 
         /// <inheritdoc />
         public void LogProjectEvaluationStarted(BuildEventContext projectEvaluationEventContext, string projectFile)
         {
-            lock (_lockObject)
-            {
-                ProjectEvaluationStartedEventArgs evaluationEvent =
-                    new ProjectEvaluationStartedEventArgs(ResourceUtilities.GetResourceString("EvaluationStarted"),
-                        projectFile)
-                    {
-                        BuildEventContext = projectEvaluationEventContext,
-                        ProjectFile = projectFile
-                    };
+            ProjectEvaluationStartedEventArgs evaluationEvent =
+                new ProjectEvaluationStartedEventArgs(ResourceUtilities.GetResourceString("EvaluationStarted"),
+                    projectFile)
+                {
+                    BuildEventContext = projectEvaluationEventContext,
+                    ProjectFile = projectFile
+                };
 
-                ProcessLoggingEvent(evaluationEvent);
-            }
+            ProcessLoggingEvent(evaluationEvent);
         }
 
         /// <summary>
@@ -532,22 +481,19 @@ public void LogProjectEvaluationFinished(
             IEnumerable items,
             ProfilerResult? profilerResult)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(projectEvaluationEventContext != null, "projectBuildEventContext");
+            ErrorUtilities.VerifyThrow(projectEvaluationEventContext != null, "projectBuildEventContext");
 
-                ProjectEvaluationFinishedEventArgs buildEvent =
-                    new ProjectEvaluationFinishedEventArgs(ResourceUtilities.GetResourceString("EvaluationFinished"), projectFile)
-                    {
-                        BuildEventContext = projectEvaluationEventContext,
-                        ProjectFile = projectFile,
-                        ProfilerResult = profilerResult,
-                        GlobalProperties = globalProperties,
-                        Properties = properties,
-                        Items = items
-                    };
-                ProcessLoggingEvent(buildEvent);
-            }
+            ProjectEvaluationFinishedEventArgs buildEvent =
+                new ProjectEvaluationFinishedEventArgs(ResourceUtilities.GetResourceString("EvaluationFinished"), projectFile)
+                {
+                    BuildEventContext = projectEvaluationEventContext,
+                    ProjectFile = projectFile,
+                    ProfilerResult = profilerResult,
+                    GlobalProperties = globalProperties,
+                    Properties = properties,
+                    Items = items
+                };
+            ProcessLoggingEvent(buildEvent);
         }
 
         /// <summary>
@@ -578,76 +524,73 @@ public BuildEventContext LogProjectStarted(
             int evaluationId = BuildEventContext.InvalidEvaluationId,
             int projectContextId = BuildEventContext.InvalidProjectContextId)
         {
-            lock (_lockObject)
+            ErrorUtilities.VerifyThrow(nodeBuildEventContext != null, "Need a nodeBuildEventContext");
+
+            if (projectContextId == BuildEventContext.InvalidProjectContextId)
             {
-                ErrorUtilities.VerifyThrow(nodeBuildEventContext != null, "Need a nodeBuildEventContext");
+                projectContextId = NextProjectId;
 
-                if (projectContextId == BuildEventContext.InvalidProjectContextId)
+                // PERF: Not using VerifyThrow to avoid boxing of projectBuildEventContext.ProjectContextId in the non-error case.
+                if (_projectFileMap.ContainsKey(projectContextId))
                 {
-                    projectContextId = NextProjectId;
+                    ErrorUtilities.ThrowInternalError("ContextID {0} for project {1} should not already be in the ID-to-file mapping!", projectContextId, projectFile);
+                }
 
-                    // PERF: Not using VerifyThrow to avoid boxing of projectBuildEventContext.ProjectContextId in the non-error case.
-                    if (_projectFileMap.ContainsKey(projectContextId))
+                _projectFileMap[projectContextId] = projectFile;
+            }
+            else
+            {
+                // A projectContextId was provided, so use it with some sanity checks
+                if (_projectFileMap.TryGetValue(projectContextId, out string existingProjectFile))
+                {
+                    if (!projectFile.Equals(existingProjectFile, StringComparison.OrdinalIgnoreCase))
                     {
-                        ErrorUtilities.ThrowInternalError("ContextID {0} for project {1} should not already be in the ID-to-file mapping!", projectContextId, projectFile);
+                        ErrorUtilities.ThrowInternalError("ContextID {0} was already in the ID-to-project file mapping but the project file {1} did not match the provided one {2}!", projectContextId, existingProjectFile, projectFile);
                     }
-
-                    _projectFileMap[projectContextId] = projectFile;
                 }
                 else
                 {
-                    // A projectContextId was provided, so use it with some sanity checks
-                    if (_projectFileMap.TryGetValue(projectContextId, out string existingProjectFile))
+                    // Currently, an existing projectContextId can only be provided in the project cache scenario, which runs on the in-proc node.
+                    // If there was a cache miss and the build was scheduled on a worker node, it may not have seen this projectContextId yet.
+                    // So we only need this sanity check for the in-proc node.
+                    if (nodeBuildEventContext.NodeId == Scheduler.InProcNodeId)
                     {
-                        if (!projectFile.Equals(existingProjectFile, StringComparison.OrdinalIgnoreCase))
-                        {
-                            ErrorUtilities.ThrowInternalError("ContextID {0} was already in the ID-to-project file mapping but the project file {1} did not match the provided one {2}!", projectContextId, existingProjectFile, projectFile);
-                        }
-                    }
-                    else
-                    {
-                        // Currently, an existing projectContextId can only be provided in the project cache scenario, which runs on the in-proc node.
-                        // If there was a cache miss and the build was scheduled on a worker node, it may not have seen this projectContextId yet.
-                        // So we only need this sanity check for the in-proc node.
-                        if (nodeBuildEventContext.NodeId == Scheduler.InProcNodeId)
-                        {
-                            ErrorUtilities.ThrowInternalError("ContextID {0} should have been in the ID-to-project file mapping but wasn't!", projectContextId);
-                        }
-
-                        _projectFileMap[projectContextId] = projectFile;
+                        ErrorUtilities.ThrowInternalError("ContextID {0} should have been in the ID-to-project file mapping but wasn't!", projectContextId);
                     }
+
+                    _projectFileMap[projectContextId] = projectFile;
                 }
+            }
 
-                BuildEventContext projectBuildEventContext = new BuildEventContext(submissionId, nodeBuildEventContext.NodeId, evaluationId, configurationId, projectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
+            BuildEventContext projectBuildEventContext = new BuildEventContext(submissionId, nodeBuildEventContext.NodeId, evaluationId, configurationId, projectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
 
-                ErrorUtilities.VerifyThrow(parentBuildEventContext != null, "Need a parentBuildEventContext");
+            ErrorUtilities.VerifyThrow(parentBuildEventContext != null, "Need a parentBuildEventContext");
 
-                ErrorUtilities.VerifyThrow(_configCache.Value.HasConfiguration(configurationId), "Cannot find the project configuration while injecting non-serialized data from out-of-proc node.");
-                var buildRequestConfiguration = _configCache.Value[configurationId];
+            ErrorUtilities.VerifyThrow(_configCache.Value.HasConfiguration(configurationId), "Cannot find the project configuration while injecting non-serialized data from out-of-proc node.");
+            var buildRequestConfiguration = _configCache.Value[configurationId];
 
-                // Always log GlobalProperties on ProjectStarted
-                // See https://github.com/dotnet/msbuild/issues/6341 for details
-                IDictionary<string, string> globalProperties = buildRequestConfiguration.GlobalProperties.ToDictionary();
+            // Always log GlobalProperties on ProjectStarted
+            // See https://github.com/dotnet/msbuild/issues/6341 for details
+            IDictionary<string, string> globalProperties = buildRequestConfiguration.GlobalProperties.ToDictionary();
 
-                var buildEvent = new ProjectStartedEventArgs
-                    (
-                        configurationId,
-                        message: null,
-                        helpKeyword: null,
-                        projectFile,
-                        targetNames,
-                        properties,
-                        items,
-                        parentBuildEventContext,
-                        globalProperties,
-                        buildRequestConfiguration.ToolsVersion
-                    );
-                buildEvent.BuildEventContext = projectBuildEventContext;
+            var buildEvent = new ProjectStartedEventArgs
+                (
+                    configurationId,
+                    message: null,
+                    helpKeyword: null,
+                    projectFile,
+                    targetNames,
+                    properties,
+                    items,
+                    parentBuildEventContext,
+                    globalProperties,
+                    buildRequestConfiguration.ToolsVersion
+                );
+            buildEvent.BuildEventContext = projectBuildEventContext;
 
-                ProcessLoggingEvent(buildEvent);
+            ProcessLoggingEvent(buildEvent);
 
-                return projectBuildEventContext;
-            }
+            return projectBuildEventContext;
         }
 
         /// <summary>
@@ -659,25 +602,22 @@ public BuildEventContext LogProjectStarted(
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
         public void LogProjectFinished(BuildEventContext projectBuildEventContext, string projectFile, bool success)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(projectBuildEventContext != null, "projectBuildEventContext");
+            ErrorUtilities.VerifyThrow(projectBuildEventContext != null, "projectBuildEventContext");
 
-                ProjectFinishedEventArgs buildEvent = new ProjectFinishedEventArgs
-                    (
-                        message: null,
-                        helpKeyword: null,
-                        projectFile,
-                        success
-                    );
-                buildEvent.BuildEventContext = projectBuildEventContext;
-                ProcessLoggingEvent(buildEvent);
+            ProjectFinishedEventArgs buildEvent = new ProjectFinishedEventArgs
+                (
+                    message: null,
+                    helpKeyword: null,
+                    projectFile,
+                    success
+                );
+            buildEvent.BuildEventContext = projectBuildEventContext;
+            ProcessLoggingEvent(buildEvent);
 
-                // PERF: Not using VerifyThrow to avoid boxing of projectBuildEventContext.ProjectContextId in the non-error case.
-                if (!_projectFileMap.Remove(projectBuildEventContext.ProjectContextId))
-                {
-                    ErrorUtilities.ThrowInternalError("ContextID {0} for project {1} should be in the ID-to-file mapping!", projectBuildEventContext.ProjectContextId, projectFile);
-                }
+            // PERF: Not using VerifyThrow to avoid boxing of projectBuildEventContext.ProjectContextId in the non-error case.
+            if (!_projectFileMap.TryRemove(projectBuildEventContext.ProjectContextId, out _))
+            {
+                ErrorUtilities.ThrowInternalError("ContextID {0} for project {1} should be in the ID-to-file mapping!", projectBuildEventContext.ProjectContextId, projectFile);
             }
         }
 
@@ -694,38 +634,35 @@ public void LogProjectFinished(BuildEventContext projectBuildEventContext, strin
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
         public BuildEventContext LogTargetStarted(BuildEventContext projectBuildEventContext, string targetName, string projectFile, string projectFileOfTargetElement, string parentTargetName, TargetBuiltReason buildReason)
         {
-            lock (_lockObject)
+            ErrorUtilities.VerifyThrow(projectBuildEventContext != null, "projectBuildEventContext is null");
+            BuildEventContext targetBuildEventContext = new BuildEventContext
+                (
+                    projectBuildEventContext.SubmissionId,
+                    projectBuildEventContext.NodeId,
+                    projectBuildEventContext.ProjectInstanceId,
+                    projectBuildEventContext.ProjectContextId,
+                    NextTargetId,
+                    BuildEventContext.InvalidTaskId
+                );
+
+            if (!OnlyLogCriticalEvents)
             {
-                ErrorUtilities.VerifyThrow(projectBuildEventContext != null, "projectBuildEventContext is null");
-                BuildEventContext targetBuildEventContext = new BuildEventContext
+                TargetStartedEventArgs buildEvent = new TargetStartedEventArgs
                     (
-                        projectBuildEventContext.SubmissionId,
-                        projectBuildEventContext.NodeId,
-                        projectBuildEventContext.ProjectInstanceId,
-                        projectBuildEventContext.ProjectContextId,
-                        NextTargetId,
-                        BuildEventContext.InvalidTaskId
+                        message: null,
+                        helpKeyword: null,
+                        targetName,
+                        projectFile,
+                        projectFileOfTargetElement,
+                        parentTargetName,
+                        buildReason,
+                        DateTime.UtcNow
                     );
-
-                if (!OnlyLogCriticalEvents)
-                {
-                    TargetStartedEventArgs buildEvent = new TargetStartedEventArgs
-                        (
-                            message: null,
-                            helpKeyword: null,
-                            targetName,
-                            projectFile,
-                            projectFileOfTargetElement,
-                            parentTargetName,
-                            buildReason,
-                            DateTime.UtcNow
-                        );
-                    buildEvent.BuildEventContext = targetBuildEventContext;
-                    ProcessLoggingEvent(buildEvent);
-                }
-
-                return targetBuildEventContext;
+                buildEvent.BuildEventContext = targetBuildEventContext;
+                ProcessLoggingEvent(buildEvent);
             }
+
+            return targetBuildEventContext;
         }
 
         /// <summary>
@@ -740,26 +677,23 @@ public BuildEventContext LogTargetStarted(BuildEventContext projectBuildEventCon
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
         public void LogTargetFinished(BuildEventContext targetBuildEventContext, string targetName, string projectFile, string projectFileOfTargetElement, bool success, IEnumerable<TaskItem> targetOutputs)
         {
-            lock (_lockObject)
+            if (!OnlyLogCriticalEvents)
             {
-                if (!OnlyLogCriticalEvents)
-                {
-                    ErrorUtilities.VerifyThrow(targetBuildEventContext != null, "targetBuildEventContext is null");
-
-                    TargetFinishedEventArgs buildEvent = new TargetFinishedEventArgs
-                        (
-                            message: null,
-                            helpKeyword: null,
-                            targetName,
-                            projectFile,
-                            projectFileOfTargetElement,
-                            success,
-                            targetOutputs
-                        );
-
-                    buildEvent.BuildEventContext = targetBuildEventContext;
-                    ProcessLoggingEvent(buildEvent);
-                }
+                ErrorUtilities.VerifyThrow(targetBuildEventContext != null, "targetBuildEventContext is null");
+
+                TargetFinishedEventArgs buildEvent = new TargetFinishedEventArgs
+                    (
+                        message: null,
+                        helpKeyword: null,
+                        targetName,
+                        projectFile,
+                        projectFileOfTargetElement,
+                        success,
+                        targetOutputs
+                    );
+
+                buildEvent.BuildEventContext = targetBuildEventContext;
+                ProcessLoggingEvent(buildEvent);
             }
         }
 
@@ -773,22 +707,19 @@ public void LogTargetFinished(BuildEventContext targetBuildEventContext, string
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
         public void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode)
         {
-            lock (_lockObject)
+            ErrorUtilities.VerifyThrow(taskBuildEventContext != null, "targetBuildEventContext is null");
+            if (!OnlyLogCriticalEvents)
             {
-                ErrorUtilities.VerifyThrow(taskBuildEventContext != null, "targetBuildEventContext is null");
-                if (!OnlyLogCriticalEvents)
-                {
-                    TaskStartedEventArgs buildEvent = new TaskStartedEventArgs
-                        (
-                            message: null,
-                            helpKeyword: null,
-                            projectFile,
-                            projectFileOfTaskNode,
-                            taskName
-                        );
-                    buildEvent.BuildEventContext = taskBuildEventContext;
-                    ProcessLoggingEvent(buildEvent);
-                }
+                TaskStartedEventArgs buildEvent = new TaskStartedEventArgs
+                    (
+                        message: null,
+                        helpKeyword: null,
+                        projectFile,
+                        projectFileOfTaskNode,
+                        taskName
+                    );
+                buildEvent.BuildEventContext = taskBuildEventContext;
+                ProcessLoggingEvent(buildEvent);
             }
         }
 
@@ -805,37 +736,34 @@ public void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskN
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
         public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, int line, int column)
         {
-            lock (_lockObject)
+            ErrorUtilities.VerifyThrow(targetBuildEventContext != null, "targetBuildEventContext is null");
+            BuildEventContext taskBuildEventContext = new BuildEventContext
+                (
+                    targetBuildEventContext.SubmissionId,
+                    targetBuildEventContext.NodeId,
+                    targetBuildEventContext.ProjectInstanceId,
+                    targetBuildEventContext.ProjectContextId,
+                    targetBuildEventContext.TargetId,
+                    NextTaskId
+                );
+
+            if (!OnlyLogCriticalEvents)
             {
-                ErrorUtilities.VerifyThrow(targetBuildEventContext != null, "targetBuildEventContext is null");
-                BuildEventContext taskBuildEventContext = new BuildEventContext
+                TaskStartedEventArgs buildEvent = new TaskStartedEventArgs
                     (
-                        targetBuildEventContext.SubmissionId,
-                        targetBuildEventContext.NodeId,
-                        targetBuildEventContext.ProjectInstanceId,
-                        targetBuildEventContext.ProjectContextId,
-                        targetBuildEventContext.TargetId,
-                        NextTaskId
+                        message: null,
+                        helpKeyword: null,
+                        projectFile,
+                        projectFileOfTaskNode,
+                        taskName
                     );
-
-                if (!OnlyLogCriticalEvents)
-                {
-                    TaskStartedEventArgs buildEvent = new TaskStartedEventArgs
-                        (
-                            message: null,
-                            helpKeyword: null,
-                            projectFile,
-                            projectFileOfTaskNode,
-                            taskName
-                        );
-                    buildEvent.BuildEventContext = taskBuildEventContext;
-                    buildEvent.LineNumber = line;
-                    buildEvent.ColumnNumber = column;
-                    ProcessLoggingEvent(buildEvent);
-                }
-
-                return taskBuildEventContext;
+                buildEvent.BuildEventContext = taskBuildEventContext;
+                buildEvent.LineNumber = line;
+                buildEvent.ColumnNumber = column;
+                ProcessLoggingEvent(buildEvent);
             }
+
+            return taskBuildEventContext;
         }
 
         /// <summary>
@@ -849,24 +777,21 @@ public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventConte
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
         public void LogTaskFinished(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, bool success)
         {
-            lock (_lockObject)
+            if (!OnlyLogCriticalEvents)
             {
-                if (!OnlyLogCriticalEvents)
-                {
-                    ErrorUtilities.VerifyThrow(taskBuildEventContext != null, "taskBuildEventContext is null");
-
-                    TaskFinishedEventArgs buildEvent = new TaskFinishedEventArgs
-                        (
-                            message: null,
-                            helpKeyword: null,
-                            projectFile,
-                            projectFileOfTaskNode,
-                            taskName,
-                            success
-                        );
-                    buildEvent.BuildEventContext = taskBuildEventContext;
-                    ProcessLoggingEvent(buildEvent);
-                }
+                ErrorUtilities.VerifyThrow(taskBuildEventContext != null, "taskBuildEventContext is null");
+
+                TaskFinishedEventArgs buildEvent = new TaskFinishedEventArgs
+                    (
+                        message: null,
+                        helpKeyword: null,
+                        projectFile,
+                        projectFileOfTaskNode,
+                        taskName,
+                        success
+                    );
+                buildEvent.BuildEventContext = taskBuildEventContext;
+                ProcessLoggingEvent(buildEvent);
             }
         }
 
@@ -882,19 +807,16 @@ public void LogTaskFinished(BuildEventContext taskBuildEventContext, string task
         /// <param name="properties">The list of properties assocated with the event.</param>
         public void LogTelemetry(BuildEventContext buildEventContext, string eventName, IDictionary<string, string> properties)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(eventName != null, "eventName is null");
+            ErrorUtilities.VerifyThrow(eventName != null, "eventName is null");
 
-                TelemetryEventArgs telemetryEvent = new TelemetryEventArgs
-                {
-                    BuildEventContext = buildEventContext,
-                    EventName = eventName,
-                    Properties = properties == null ? new Dictionary<string, string>() : new Dictionary<string, string>(properties)
-                };
+            TelemetryEventArgs telemetryEvent = new TelemetryEventArgs
+            {
+                BuildEventContext = buildEventContext,
+                EventName = eventName,
+                Properties = properties == null ? new Dictionary<string, string>() : new Dictionary<string, string>(properties)
+            };
 
-                ProcessLoggingEvent(telemetryEvent);
-            }
+            ProcessLoggingEvent(telemetryEvent);
         }
 
         #endregion
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index 3fdbf100f25..4bbb3ae656d 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -576,13 +576,20 @@ private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildReques
 
         public async Task ShutDown()
         {
+            bool shouldInitiateShutdownState = _serviceState != ProjectCacheServiceState.ShutdownStarted && _serviceState != ProjectCacheServiceState.ShutdownFinished;
+
+            if (!shouldInitiateShutdownState)
+            {
+                return;
+            }
+
             BuildEventContext buildEventContext = BuildEventContext.Invalid;
             BuildEventFileInfo buildEventFileInfo = BuildEventFileInfo.Empty;
             var pluginLogger = new LoggingServiceToPluginLoggerAdapter(
                 _loggingService,
                 BuildEventContext.Invalid,
                 BuildEventFileInfo.Empty);
-
+            
             try
             {
                 SetState(ProjectCacheServiceState.ShutdownStarted);
diff --git a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
index 04b7ad67ed0..6e1e26c4258 100644
--- a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
@@ -67,11 +67,10 @@ public override void PacketReceived(int node, INodePacket packet)
 
             SdkResult response = null;
 
+            // Create an SdkReference from the request; the SdkReference constructor below never throws.
+            SdkReference sdkReference = new SdkReference(request.Name, request.Version, request.MinimumVersion);
             try
             {
-                // Create an SdkReference from the request
-                SdkReference sdkReference = new SdkReference(request.Name, request.Version, request.MinimumVersion);
-
                 ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;
 
                 // This call is usually cached so is very fast but can take longer for a new SDK that is downloaded.  Other queued threads for different SDKs will complete sooner and continue on which unblocks evaluations
@@ -90,7 +89,7 @@ public override void PacketReceived(int node, INodePacket packet)
                 // Get the node manager and send the response back to the node that requested the SDK
                 INodeManager nodeManager = Host.GetComponent(BuildComponentType.NodeManager) as INodeManager;
 
-                nodeManager.SendData(request.NodeId, response);
+                nodeManager.SendData(request.NodeId, response ?? new SdkResult(sdkReference, null, null));
             }
         }
 
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
index e6f1294b28d..0ccdd796da6 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
@@ -34,7 +34,16 @@ internal class SdkResolverLoader
 #endif
             ) ?? Environment.GetEnvironmentVariable("MSBUILDADDITIONALSDKRESOLVERSFOLDER");
 
-        internal virtual IList<SdkResolver> LoadResolvers(LoggingContext loggingContext,
+        internal virtual IList<SdkResolver> GetDefaultResolvers(LoggingContext loggingContext, ElementLocation location)
+        {
+            var resolvers = !String.Equals(IncludeDefaultResolver, "false", StringComparison.OrdinalIgnoreCase) ?
+                new List<SdkResolver> {new DefaultSdkResolver()}
+                : new List<SdkResolver>();
+
+            return resolvers;
+        }
+
+        internal virtual IList<SdkResolver> LoadAllResolvers(LoggingContext loggingContext,
             ElementLocation location)
         {
             var resolvers = !String.Equals(IncludeDefaultResolver, "false", StringComparison.OrdinalIgnoreCase) ?
@@ -57,6 +66,13 @@ internal virtual IList<SdkResolver> LoadResolvers(LoggingContext loggingContext,
             return resolvers.OrderBy(t => t.Priority).ToList();
         }
 
+        internal virtual IList<SdkResolverManifest> GetResolversManifests(LoggingContext loggingContext,
+            ElementLocation location)
+        {
+            return FindPotentialSdkResolversManifests(
+                Path.Combine(BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryRoot, "SdkResolvers"), location);
+        }
+
         /// <summary>
         ///     Find all files that are to be considered SDK Resolvers. Pattern will match
         ///     Root\SdkResolver\(ResolverName)\(ResolverName).dll.
@@ -66,24 +82,44 @@ internal virtual IList<SdkResolver> LoadResolvers(LoggingContext loggingContext,
         /// <returns></returns>
         internal virtual IList<string> FindPotentialSdkResolvers(string rootFolder, ElementLocation location)
         {
-            var assembliesList = new List<string>();
+            var manifestsList = FindPotentialSdkResolversManifests(rootFolder, location);
+
+            return manifestsList.Select(manifest => manifest.Path).ToList();
+        }
+
+        internal virtual IList<SdkResolverManifest> FindPotentialSdkResolversManifests(string rootFolder, ElementLocation location)
+        {
+            List<SdkResolverManifest> manifestsList = new List<SdkResolverManifest>();
 
             if ((string.IsNullOrEmpty(rootFolder) || !FileUtilities.DirectoryExistsNoThrow(rootFolder)) && AdditionalResolversFolder == null)
             {
-                return assembliesList;
+                return manifestsList;
             }
 
             DirectoryInfo[] subfolders = GetSubfolders(rootFolder, AdditionalResolversFolder);
 
             foreach (var subfolder in subfolders)
             {
-                var assembly = Path.Combine(subfolder.FullName, $"{subfolder.Name}.dll");
                 var manifest = Path.Combine(subfolder.FullName, $"{subfolder.Name}.xml");
+                var assembly = Path.Combine(subfolder.FullName, $"{subfolder.Name}.dll");
+                bool assemblyAdded = false;
 
-                var assemblyAdded = TryAddAssembly(assembly, assembliesList);
-                if (!assemblyAdded)
+                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+                {
+                    // Prefer manifest over the assembly. Try to read the xml first, and if not found then look for an assembly.
+                    assemblyAdded = TryAddAssemblyManifestFromXml(manifest, subfolder.FullName, manifestsList, location);
+                    if (!assemblyAdded)
+                    {
+                        assemblyAdded = TryAddAssemblyManifestFromDll(assembly, manifestsList);
+                    }
+                }
+                else
                 {
-                    assemblyAdded = TryAddAssemblyFromManifest(manifest, subfolder.FullName, assembliesList, location);
+                    assemblyAdded = TryAddAssemblyManifestFromDll(assembly, manifestsList);
+                    if (!assemblyAdded)
+                    {
+                        assemblyAdded = TryAddAssemblyManifestFromXml(manifest, subfolder.FullName, manifestsList, location);
+                    }
                 }
 
                 if (!assemblyAdded)
@@ -92,7 +128,7 @@ internal virtual IList<string> FindPotentialSdkResolvers(string rootFolder, Elem
                 }
             }
 
-            return assembliesList;
+            return manifestsList;
         }
 
         private DirectoryInfo[] GetSubfolders(string rootFolder, string additionalResolversFolder)
@@ -133,25 +169,25 @@ public int GetHashCode(DirectoryInfo value)
             }
         }
 
-        private bool TryAddAssemblyFromManifest(string pathToManifest, string manifestFolder, List<string> assembliesList, ElementLocation location)
+        private bool TryAddAssemblyManifestFromXml(string pathToManifest, string manifestFolder, List<SdkResolverManifest> manifestsList, ElementLocation location)
         {
             if (!string.IsNullOrEmpty(pathToManifest) && !FileUtilities.FileExistsNoThrow(pathToManifest)) return false;
 
-            string path = null;
-
+            SdkResolverManifest manifest = null;
             try
             {
                 // <SdkResolver>
                 //   <Path>...</Path>
+                //   <ResolvableSdkPattern>(Optional field)</ResolvableSdkPattern>
                 // </SdkResolver>
-                var manifest = SdkResolverManifest.Load(pathToManifest);
+                manifest = SdkResolverManifest.Load(pathToManifest);
 
                 if (manifest == null || string.IsNullOrEmpty(manifest.Path))
                 {
                     ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), "SdkResolverDllInManifestMissing", pathToManifest, string.Empty);
                 }
 
-                path = FileUtilities.FixFilePath(manifest.Path);
+                manifest.Path = FileUtilities.FixFilePath(manifest.Path);
             }
             catch (XmlException e)
             {
@@ -159,25 +195,27 @@ private bool TryAddAssemblyFromManifest(string pathToManifest, string manifestFo
                 ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), e, "SdkResolverManifestInvalid", pathToManifest, e.Message);
             }
 
-            if (!Path.IsPathRooted(path))
+            if (!Path.IsPathRooted(manifest.Path))
             {
-                path = Path.Combine(manifestFolder, path);
-                path = Path.GetFullPath(path);
+                manifest.Path = Path.Combine(manifestFolder, manifest.Path);
+                manifest.Path = Path.GetFullPath(manifest.Path);
             }
 
-            if (!TryAddAssembly(path, assembliesList))
+            if (string.IsNullOrEmpty(manifest.Path) || !FileUtilities.FileExistsNoThrow(manifest.Path))
             {
-                ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), "SdkResolverDllInManifestMissing", pathToManifest, path);
+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), "SdkResolverDllInManifestMissing", pathToManifest, manifest.Path);
             }
 
+            manifestsList.Add(manifest);
+
             return true;
         }
 
-        private bool TryAddAssembly(string assemblyPath, List<string> assembliesList)
+        private bool TryAddAssemblyManifestFromDll(string assemblyPath, List<SdkResolverManifest> manifestsList)
         {
             if (string.IsNullOrEmpty(assemblyPath) || !FileUtilities.FileExistsNoThrow(assemblyPath)) return false;
 
-            assembliesList.Add(assemblyPath);
+            manifestsList.Add(new SdkResolverManifest(DisplayName: assemblyPath, Path: assemblyPath, ResolvableSdkRegex: null));
             return true;
         }
 
@@ -198,6 +236,13 @@ protected virtual Assembly LoadResolverAssembly(string resolverPath, LoggingCont
 #endif
         }
 
+        protected internal virtual IList<SdkResolver> LoadResolversFromManifest(SdkResolverManifest manifest, LoggingContext loggingContext, ElementLocation location)
+        {
+            var resolvers = new List<SdkResolver>();
+            LoadResolvers(manifest.Path, loggingContext, location, resolvers);
+            return resolvers;
+        }
+
         protected virtual void LoadResolvers(string resolverPath, LoggingContext loggingContext, ElementLocation location, List<SdkResolver> resolvers)
         {
             Assembly assembly;
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
index 295ec8d7877..f8d0baf5e71 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
@@ -1,5 +1,7 @@
 ﻿using Microsoft.Build.Shared;
+using System;
 using System.IO;
+using System.Text.RegularExpressions;
 using System.Xml;
 
 #nullable disable
@@ -11,7 +13,43 @@ namespace Microsoft.Build.BackEnd.SdkResolution
     /// </summary>
     internal class SdkResolverManifest
     {
-        internal string Path { get; set; }
+        private SdkResolverManifest()
+        {
+        }
+
+        public SdkResolverManifest(string DisplayName, string Path, Regex ResolvableSdkRegex)
+        {
+            this.DisplayName = DisplayName;
+            this.Path = Path;
+            this.ResolvableSdkRegex = ResolvableSdkRegex;
+        }
+
+        /// <summary>
+        /// Sdk resolver manifest display name.
+        /// </summary>
+        /// <remarks>
+        /// This field should be used only for logging purposes. Do not use for any actual processing, unless that are tests.
+        /// </remarks>
+        public string DisplayName { get; set; }
+
+        /// <summary>
+        /// Path for resolvers dll location.
+        /// </summary>
+        public string Path { get; set; }
+
+        /// <summary>
+        /// Regex which matches all the sdk names that could be resolved by the resolvers associated with given manifest.  
+        /// </summary>
+        public Regex ResolvableSdkRegex { get; set; }
+
+        /// <summary>
+        /// The time-out interval for the name pattern regex in milliseconds.
+        /// </summary>
+        /// <remarks>
+        /// This number should notify us when the name matching regex executes unreasonable amount of time (for example, have an infinite recursive regex expression).
+        /// One should avoid to put such a regex into a resolver's xml and we want to catch this situation early. Half a second seems to be a reasonable time in which regex should finish.
+        /// </remarks>
+        private const int SdkResolverPatternRegexTimeoutMsc = 500;
 
         /// <summary>
         /// Deserialize the file into an SdkResolverManifest.
@@ -35,7 +73,7 @@ internal static SdkResolverManifest Load(string filePath)
                 {
                     if (reader.NodeType == XmlNodeType.Element && reader.Name == "SdkResolver")
                     {
-                        return ParseSdkResolverElement(reader);
+                        return ParseSdkResolverElement(reader, filePath);
                     }
                     else
                     {
@@ -47,22 +85,43 @@ internal static SdkResolverManifest Load(string filePath)
             return null;
         }
 
-        private static SdkResolverManifest ParseSdkResolverElement(XmlReader reader)
+        // This parsing code is very specific and not forward compatible, but since resolvers generally ship in the same release vehicle as MSBuild itself, only backward compatibility is required.
+        private static SdkResolverManifest ParseSdkResolverElement(XmlReader reader, string filePath)
         {
             SdkResolverManifest manifest = new SdkResolverManifest();
+            manifest.DisplayName = filePath;
 
-            while (reader.Read())
+            reader.Read();
+            while (!reader.EOF)
             {
                 switch (reader.NodeType)
                 {
                     case XmlNodeType.Element:
                         {
-                            manifest.Path = reader.Name switch
+                            switch (reader.Name)
                             {
-                                "Path" => reader.ReadElementContentAsString(),
-                                _ => throw new XmlException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnrecognizedElement", reader.Name)),
-                            };
+                                case "Path":
+                                    manifest.Path = reader.ReadElementContentAsString();
+                                    break;
+                                case "ResolvableSdkPattern":
+                                    string pattern = reader.ReadElementContentAsString();
+                                    try
+                                    {
+                                        manifest.ResolvableSdkRegex = new Regex(pattern, RegexOptions.Compiled | RegexOptions.CultureInvariant, TimeSpan.FromMilliseconds(SdkResolverPatternRegexTimeoutMsc));
+                                    }
+                                    catch (ArgumentException ex)
+                                    {
+                                        ErrorUtilities.ThrowInternalError("A regular expression parsing error occurred while parsing {0}.", ex, filePath);
+                                    }
+                                    break;
+                                default:
+                                    throw new XmlException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnrecognizedElement", reader.Name));
+                            }
+                            break;
                         }
+
+                    case XmlNodeType.EndElement:
+                        reader.Read();
                         break;
 
                     default:
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index f6675ba42a5..c38afed1d3b 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -12,6 +12,8 @@
 using System.Collections.Generic;
 using System.Reflection;
 using Microsoft.Build.Eventing;
+using System.Linq;
+using System.Text.RegularExpressions;
 
 #nullable disable
 
@@ -41,7 +43,25 @@ internal class SdkResolverService : ISdkResolverService
         /// <summary>
         /// Stores the list of SDK resolvers which were loaded.
         /// </summary>
-        private IList<SdkResolver> _resolvers;
+        /// <remarks>
+        /// Need it for supporting the ChangeWave less than <see cref="ChangeWaves.Wave17_4"/>. Remove when move out Wave17_4.
+        /// </remarks>
+        private IList<SdkResolver> _resolversList;
+
+        /// <summary>
+        /// Stores the loaded SDK resolvers, mapped to the manifest from which they came.
+        /// </summary>
+        private Dictionary<SdkResolverManifest, IList<SdkResolver>> _manifestToResolvers;
+
+        /// <summary>
+        /// Stores the list of manifests of specific SDK resolvers which could be loaded.
+        /// </summary>
+        private IList<SdkResolverManifest> _specificResolversManifestsRegistry;
+
+        /// <summary>
+        /// Stores the list of manifests of general SDK resolvers which could be loaded.
+        /// </summary>
+        private IList<SdkResolverManifest> _generalResolversManifestsRegistry;
 
         /// <summary>
         /// Stores an <see cref="SdkResolverLoader"/> which can load registered SDK resolvers.
@@ -92,12 +112,147 @@ public virtual void ClearCaches()
         /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
         public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
         {
-            // Lazy initialize the SDK resolvers
-            if (_resolvers == null)
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+            }
+            else
+            {
+                return ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+            }
+        }
+
+        /// <remarks>
+        /// Resolves the sdk in two passes. First pass consists of all specific resolvers (i.e. resolvers with pattern), which match the sdk name.
+        /// The resolvers are ordered by the priority in first pass and are tried until one of them succeeds.
+        /// If the first pass is unsuccessful, on the second pass all the general resolvers (i.e. resolvers without pattern), ordered by their priority, are tried one after one.
+        /// After that, if the second pass is unsuccessful, sdk resolution is unsuccessful.
+        /// </remarks>
+        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        {
+            if (_specificResolversManifestsRegistry == null || _generalResolversManifestsRegistry == null)
+            {
+                RegisterResolversManifests(loggingContext, sdkReferenceLocation);
+            }
+
+            // Pick up the matching specific resolvers from the list of resolvers.
+            List<SdkResolverManifest> matchingResolversManifests = new();
+            foreach (SdkResolverManifest manifest in _specificResolversManifestsRegistry)
+            {
+                try
+                {
+                    if (manifest.ResolvableSdkRegex.IsMatch(sdk.Name))
+                    {
+                        matchingResolversManifests.Add(manifest);
+                    }
+                }
+                catch (RegexMatchTimeoutException ex)
+                {
+                    ErrorUtilities.ThrowInternalError("Timeout exceeded matching sdk \"{0}\" to <ResolvableSdkPattern> from sdk resolver manifest {1}.", ex, sdk.Name, manifest.DisplayName);
+                }
+            }
+
+            List<SdkResolver> resolvers;
+            SdkResult sdkResult;
+            if (matchingResolversManifests.Count != 0)
+            {
+                // First pass.
+                resolvers = GetResolvers(matchingResolversManifests, loggingContext, sdkReferenceLocation);
+
+                if (TryResolveSdkUsingSpecifiedResolvers(
+                    resolvers,
+                    submissionId,
+                    sdk,
+                    loggingContext,
+                    sdkReferenceLocation,
+                    solutionPath,
+                    projectPath,
+                    interactive,
+                    isRunningInVisualStudio,
+                    out sdkResult))
+                {
+                    return sdkResult;
+                }
+            }
+
+            // Second pass: fallback to general resolvers. 
+            resolvers = GetResolvers(
+                _generalResolversManifestsRegistry,
+                loggingContext,
+                sdkReferenceLocation).ToList();
+
+            if (TryResolveSdkUsingSpecifiedResolvers(
+                resolvers,
+                submissionId,
+                sdk,
+                loggingContext,
+                sdkReferenceLocation,
+                solutionPath,
+                projectPath,
+                interactive,
+                isRunningInVisualStudio,
+                out sdkResult))
+            {
+                return sdkResult;
+            }
+
+            // No resolvers resolved the sdk.
+            return new SdkResult(sdk, null, null);
+        }
+
+        private List<SdkResolver> GetResolvers(IList<SdkResolverManifest> resolversManifests, LoggingContext loggingContext, ElementLocation sdkReferenceLocation)
+        {
+            // Create a sorted by priority list of resolvers. Load them if needed.
+            List<SdkResolver> resolvers = new List<SdkResolver>();
+            foreach (var resolverManifest in resolversManifests)
+            {
+                if (!_manifestToResolvers.TryGetValue(resolverManifest, out IList<SdkResolver> newResolvers))
+                {
+                    lock (_lockObject)
+                    {
+                        if (!_manifestToResolvers.TryGetValue(resolverManifest, out newResolvers))
+                        {
+                            // Loading of the needed resolvers.
+                            MSBuildEventSource.Log.SdkResolverServiceLoadResolversStart();
+                            newResolvers = _sdkResolverLoader.LoadResolversFromManifest(resolverManifest, loggingContext, sdkReferenceLocation);
+                            _manifestToResolvers[resolverManifest] = newResolvers;
+                            MSBuildEventSource.Log.SdkResolverServiceLoadResolversStop(resolverManifest.DisplayName, newResolvers.Count);
+                        }
+                    }
+                }
+
+                resolvers.AddRange(newResolvers);
+            }
+
+            resolvers.Sort((l, r) => l.Priority.CompareTo(r.Priority));
+            return resolvers;
+        }
+
+        private SdkResult ResolveSdkUsingAllResolvers(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        {
+            // Lazy initialize all SDK resolvers
+            if (_resolversList == null)
             {
                 Initialize(loggingContext, sdkReferenceLocation);
             }
 
+            TryResolveSdkUsingSpecifiedResolvers(
+                _resolversList,
+                submissionId,
+                sdk,
+                loggingContext,
+                sdkReferenceLocation,
+                solutionPath,
+                projectPath,
+                interactive,
+                isRunningInVisualStudio,
+                out SdkResult sdkResult);
+
+            return sdkResult;
+        }
+
+        private bool TryResolveSdkUsingSpecifiedResolvers(IList<SdkResolver> resolvers, int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, out SdkResult sdkResult)
+        {
             List<SdkResult> results = new List<SdkResult>();
 
             // Loop through resolvers which have already been sorted by priority, returning the first result that was successful
@@ -105,7 +260,7 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
 
             loggingContext.LogComment(MessageImportance.Low, "SdkResolving", sdk.ToString());
 
-            foreach (SdkResolver sdkResolver in _resolvers)
+            foreach (SdkResolver sdkResolver in resolvers)
             {
                 SdkResolverContext context = new SdkResolverContext(buildEngineLogger, projectPath, solutionPath, ProjectCollection.Version, interactive, isRunningInVisualStudio)
                 {
@@ -157,7 +312,8 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
                     // Associate the element location of the resolved SDK reference
                     result.ElementLocation = sdkReferenceLocation;
 
-                    return result;
+                    sdkResult = result;
+                    return true;
                 }
 
                 results.Add(result);
@@ -176,7 +332,8 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
                 }
             }
 
-            return new SdkResult(sdk, null, null);
+            sdkResult = new SdkResult(sdk, null, null);
+            return false;
         }
 
         /// <summary>
@@ -191,7 +348,28 @@ internal void InitializeForTests(SdkResolverLoader resolverLoader = null, IList<
                 _sdkResolverLoader = resolverLoader;
             }
 
-            _resolvers = resolvers;
+            _specificResolversManifestsRegistry = null;
+            _generalResolversManifestsRegistry = null;
+            _manifestToResolvers = null;
+            _resolversList = null;
+
+            if (resolvers != null)
+            {
+                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+                {
+                    _specificResolversManifestsRegistry = new List<SdkResolverManifest>();
+                    _generalResolversManifestsRegistry = new List<SdkResolverManifest>();
+                    _manifestToResolvers = new Dictionary<SdkResolverManifest, IList<SdkResolver>>();
+
+                    SdkResolverManifest sdkResolverManifest = new SdkResolverManifest(DisplayName: "TestResolversManifest", Path: null, ResolvableSdkRegex: null);
+                    _generalResolversManifestsRegistry.Add(sdkResolverManifest);
+                    _manifestToResolvers[sdkResolverManifest] = resolvers;
+                }
+                else
+                {
+                    _resolversList = resolvers;
+                }
+            }
         }
 
         private static void LogWarnings(LoggingContext loggingContext, ElementLocation location, SdkResult result)
@@ -232,14 +410,58 @@ private void Initialize(LoggingContext loggingContext, ElementLocation location)
         {
             lock (_lockObject)
             {
-                if (_resolvers != null)
+                if (_resolversList != null)
                 {
                     return;
                 }
 
                 MSBuildEventSource.Log.SdkResolverServiceInitializeStart();
-                _resolvers = _sdkResolverLoader.LoadResolvers(loggingContext, location);
-                MSBuildEventSource.Log.SdkResolverServiceInitializeStop(_resolvers.Count);
+                _resolversList = _sdkResolverLoader.LoadAllResolvers(loggingContext, location);
+                MSBuildEventSource.Log.SdkResolverServiceInitializeStop(_resolversList.Count);
+            }
+        }
+
+        private void RegisterResolversManifests(LoggingContext loggingContext, ElementLocation location)
+        {
+            lock (_lockObject)
+            {
+                if (_specificResolversManifestsRegistry != null && _generalResolversManifestsRegistry != null)
+                {
+                    return;
+                }
+
+                MSBuildEventSource.Log.SdkResolverServiceFindResolversManifestsStart();
+                var allResolversManifests = _sdkResolverLoader.GetResolversManifests(loggingContext, location);
+
+                _manifestToResolvers = new Dictionary<SdkResolverManifest, IList<SdkResolver>>();
+
+                // Load and add the manifest for the default resolvers, located directly in this dll.
+                IList<SdkResolver> defaultResolvers = _sdkResolverLoader.GetDefaultResolvers(loggingContext, location);
+                if (defaultResolvers.Count > 0)
+                {
+                    MSBuildEventSource.Log.SdkResolverServiceLoadResolversStart();
+                    SdkResolverManifest sdkDefaultResolversManifest = new SdkResolverManifest(DisplayName: "DefaultResolversManifest", Path: null, ResolvableSdkRegex: null);
+                    allResolversManifests.Add(sdkDefaultResolversManifest);
+                    _manifestToResolvers[sdkDefaultResolversManifest] = defaultResolvers;
+                    MSBuildEventSource.Log.SdkResolverServiceLoadResolversStop(sdkDefaultResolversManifest.DisplayName, defaultResolvers.Count);
+                }
+
+                MSBuildEventSource.Log.SdkResolverServiceFindResolversManifestsStop(allResolversManifests.Count);
+
+                // Break the list of all resolvers manifests into two parts: manifests with specific and general resolvers.
+                _specificResolversManifestsRegistry = new List<SdkResolverManifest>();
+                _generalResolversManifestsRegistry = new List<SdkResolverManifest>();
+                foreach (SdkResolverManifest manifest in allResolversManifests)
+                {
+                    if (manifest.ResolvableSdkRegex == null)
+                    {
+                        _generalResolversManifestsRegistry.Add(manifest);
+                    }
+                    else
+                    {
+                        _specificResolversManifestsRegistry.Add(manifest);
+                    }
+                }
             }
         }
 
@@ -250,7 +472,9 @@ private void SetResolverState(int submissionId, SdkResolver resolver, object sta
             {
                 ConcurrentDictionary<SdkResolver, object> resolverState = _resolverStateBySubmission.GetOrAdd(
                     submissionId,
-                    _ => new ConcurrentDictionary<SdkResolver, object>(NativeMethodsShared.GetLogicalCoreCount(), _resolvers.Count));
+                    _ => new ConcurrentDictionary<SdkResolver, object>(
+                        NativeMethodsShared.GetLogicalCoreCount(),
+                        ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4) ? _specificResolversManifestsRegistry.Count + _generalResolversManifestsRegistry.Count : _resolversList.Count));
 
                 resolverState.AddOrUpdate(resolver, state, (sdkResolver, obj) => state);
             }
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 2eb464830ff..60838dd3f20 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -17,6 +17,7 @@
 using Microsoft.Build.BackEnd.Components.Caching;
 using Microsoft.Build.BackEnd.SdkResolution;
 using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
+using System.Diagnostics;
 
 #nullable disable
 
@@ -809,6 +810,32 @@ private void HandleNodeConfiguration(NodeConfiguration configuration)
         private void HandleNodeBuildComplete(NodeBuildComplete buildComplete)
         {
             _shutdownReason = buildComplete.PrepareForReuse ? NodeEngineShutdownReason.BuildCompleteReuse : NodeEngineShutdownReason.BuildComplete;
+            if (_shutdownReason == NodeEngineShutdownReason.BuildCompleteReuse)
+            {
+                ProcessPriorityClass priorityClass = Process.GetCurrentProcess().PriorityClass;
+                if (priorityClass != ProcessPriorityClass.Normal && priorityClass != ProcessPriorityClass.BelowNormal)
+                {
+                    // This isn't a priority class known by MSBuild. We should avoid connecting to this node.
+                    _shutdownReason = NodeEngineShutdownReason.BuildComplete;
+                }
+                else
+                {
+                    bool lowPriority = priorityClass == ProcessPriorityClass.BelowNormal;
+                    if (_nodeEndpoint.LowPriority != lowPriority)
+                    {
+                        if (!lowPriority || NativeMethodsShared.IsWindows)
+                        {
+                            Process.GetCurrentProcess().PriorityClass = lowPriority ? ProcessPriorityClass.Normal : ProcessPriorityClass.BelowNormal;
+                        }
+                        else
+                        {
+                            // On *nix, we can't adjust the priority up, so to avoid using this node at the wrong priority, we should not be reused.
+                            _shutdownReason = NodeEngineShutdownReason.BuildComplete;
+                        }
+                    }
+                }
+            }
+            
             _shutdownEvent.Set();
         }
     }
diff --git a/src/Build/BackEnd/Shared/ConfigurationMetadata.cs b/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
index 64da2af0c03..83b3218f3fe 100644
--- a/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
+++ b/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
@@ -58,6 +58,12 @@ public ConfigurationMetadata(string projectFullPath, PropertyDictionary<ProjectP
             _toolsVersion = MSBuildConstants.CurrentToolsVersion;
             _globalProperties = globalProperties;
         }
+        public ConfigurationMetadata(string projectFullPath, PropertyDictionary<ProjectPropertyInstance> globalProperties, string previousPlatform, string previousPlatformLookupTable, bool isSetPlatformHardCoded) : this(projectFullPath, globalProperties)
+        {
+            PreviousPlatform = previousPlatform;
+            PreviousPlatformLookupTable = previousPlatformLookupTable;
+            IsSetPlatformHardCoded = isSetPlatformHardCoded;
+        }
 
         public ConfigurationMetadata(ITranslator translator)
         {
@@ -81,6 +87,11 @@ public ConfigurationMetadata(ITranslator translator)
         /// </summary>
         public string ToolsVersion => _toolsVersion;
 
+        public string PreviousPlatform { get; } = "";
+
+        public string PreviousPlatformLookupTable { get; } = "";
+        public bool IsSetPlatformHardCoded { get; } = false;
+
         private PropertyDictionary<ProjectPropertyInstance> _globalProperties;
 
         /// <summary>
@@ -167,7 +178,9 @@ private bool InternalEquals(ConfigurationMetadata other)
 
             return ProjectFullPath.Equals(other.ProjectFullPath, StringComparison.OrdinalIgnoreCase) &&
                    ToolsVersion.Equals(other.ToolsVersion, StringComparison.OrdinalIgnoreCase) &&
-                   GlobalProperties.Equals(other.GlobalProperties);
+                   GlobalProperties.Equals(other.GlobalProperties) &&
+                   PreviousPlatform.Equals(other.PreviousPlatform, StringComparison.OrdinalIgnoreCase) &&
+                   PreviousPlatformLookupTable.Equals(other.PreviousPlatformLookupTable, StringComparison.OrdinalIgnoreCase);
         }
 
         private string DebugString()
diff --git a/src/Build/Collections/ArrayDictionary.cs b/src/Build/Collections/ArrayDictionary.cs
index b2ab9062e08..8eea6dead68 100644
--- a/src/Build/Collections/ArrayDictionary.cs
+++ b/src/Build/Collections/ArrayDictionary.cs
@@ -264,4 +264,4 @@ public void Reset()
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Construction/ImplicitImportLocation.cs b/src/Build/Construction/ImplicitImportLocation.cs
index 3bc16698999..c6bf445e366 100644
--- a/src/Build/Construction/ImplicitImportLocation.cs
+++ b/src/Build/Construction/ImplicitImportLocation.cs
@@ -23,4 +23,4 @@ public enum ImplicitImportLocation
         /// </summary>
         Bottom
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Definition/NewProjectFileOptions.cs b/src/Build/Definition/NewProjectFileOptions.cs
index 9c1842bfca5..12e32de1a01 100644
--- a/src/Build/Definition/NewProjectFileOptions.cs
+++ b/src/Build/Definition/NewProjectFileOptions.cs
@@ -35,4 +35,4 @@ public enum NewProjectFileOptions
         /// </summary>
         IncludeAllOptions = ~0
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 0adf9e61756..6fb05e271d0 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -23,6 +23,7 @@
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using ProjectItemFactory = Microsoft.Build.Evaluation.ProjectItem.ProjectItemFactory;
 using System.Globalization;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Definition;
 using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Globbing;
@@ -3287,6 +3288,10 @@ public override bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnum
                 if (!IsBuildEnabled)
                 {
                     LoggingService.LogError(s_buildEventContext, new BuildEventFileInfo(FullPath), "SecurityProjectBuildDisabled");
+                    if (LoggingService is LoggingService defaultLoggingService)
+                    {
+                        defaultLoggingService.WaitForLoggingToProcessEvents();
+                    }
                     return false;
                 }
 
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 485b905abe0..32f9b37fe68 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -225,6 +225,12 @@ public void Dispose()
         /// </summary>
         private int _maxNodeCount;
 
+        /// <summary>
+        /// LoggingService Logger mode.
+        /// If Asynchronous mode is used
+        /// </summary>
+        private LoggerMode _loggerMode;
+
         /// <summary>
         /// Instantiates a project collection with no global properties or loggers that reads toolset
         /// information from the configuration file and registry.
@@ -302,6 +308,27 @@ public ProjectCollection(IDictionary<string, string> globalProperties, IEnumerab
         /// <param name="onlyLogCriticalEvents">If set to true, only critical events will be logged.</param>
         /// <param name="loadProjectsReadOnly">If set to true, load all projects as read-only.</param>
         public ProjectCollection(IDictionary<string, string> globalProperties, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers, ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly)
+            : this(globalProperties, loggers, remoteLoggers, toolsetDefinitionLocations, maxNodeCount, onlyLogCriticalEvents, loadProjectsReadOnly, useAsynchronousLogging: false)
+        {
+        }
+
+
+        /// <summary>
+        /// Instantiates a project collection with specified global properties and loggers and using the
+        /// specified toolset locations, node count, and setting of onlyLogCriticalEvents.
+        /// Global properties and loggers may be null.
+        /// Throws InvalidProjectFileException if any of the global properties are reserved.
+        /// May throw InvalidToolsetDefinitionException.
+        /// </summary>
+        /// <param name="globalProperties">The default global properties to use. May be null.</param>
+        /// <param name="loggers">The loggers to register. May be null and specified to any build instead.</param>
+        /// <param name="remoteLoggers">Any remote loggers to register. May be null and specified to any build instead.</param>
+        /// <param name="toolsetDefinitionLocations">The locations from which to load toolsets.</param>
+        /// <param name="maxNodeCount">The maximum number of nodes to use for building.</param>
+        /// <param name="onlyLogCriticalEvents">If set to true, only critical events will be logged.</param>
+        /// <param name="loadProjectsReadOnly">If set to true, load all projects as read-only.</param>
+        /// <param name="useAsynchronousLogging">If set to true, asynchronous logging will be used. <see cref="ProjectCollection.Dispose()"/> has to called to clear resources used by async logging.</param>
+        internal ProjectCollection(IDictionary<string, string> globalProperties, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers, ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly, bool useAsynchronousLogging)
         {
             _loadedProjects = new LoadedProjectCollection();
             ToolsetLocations = toolsetDefinitionLocations;
@@ -319,6 +346,7 @@ public ProjectCollection(IDictionary<string, string> globalProperties, IEnumerab
 
             try
             {
+                _loggerMode = useAsynchronousLogging ? LoggerMode.Asynchronous : LoggerMode.Synchronous;
                 CreateLoggingService(maxNodeCount, onlyLogCriticalEvents);
 
                 RegisterLoggers(loggers);
@@ -418,8 +446,14 @@ public static ProjectCollection GlobalProjectCollection
                 {
                     // Take care to ensure that there is never more than one value observed
                     // from this property even in the case of race conditions while lazily initializing.
-                    var local = new ProjectCollection();
-                    Interlocked.CompareExchange(ref s_globalProjectCollection, local, null);
+                    var local = new ProjectCollection(null, null, null, ToolsetDefinitionLocations.Default,
+                        maxNodeCount: 1, onlyLogCriticalEvents: false, loadProjectsReadOnly: false, useAsynchronousLogging: true);
+
+                    if (Interlocked.CompareExchange(ref s_globalProjectCollection, local, null) != null)
+                    {
+                        // Other thread beat us to it; dispose of this project collection
+                        local.Dispose();
+                    }
                 }
 
                 return s_globalProjectCollection;
@@ -1724,7 +1758,7 @@ private void ShutDownLoggingService()
         /// </summary>
         private void CreateLoggingService(int maxCPUCount, bool onlyLogCriticalEvents)
         {
-            _loggingService = BackEnd.Logging.LoggingService.CreateLoggingService(LoggerMode.Synchronous, 0 /*Evaluation can be done as if it was on node "0"*/);
+            _loggingService = BackEnd.Logging.LoggingService.CreateLoggingService(_loggerMode, 0 /*Evaluation can be done as if it was on node "0"*/);
             _loggingService.MaxCPUCount = maxCPUCount;
             _loggingService.OnlyLogCriticalEvents = onlyLogCriticalEvents;
         }
diff --git a/src/Build/Definition/SubToolset.cs b/src/Build/Definition/SubToolset.cs
index 90e7f0be784..af5f8e9ffa2 100644
--- a/src/Build/Definition/SubToolset.cs
+++ b/src/Build/Definition/SubToolset.cs
@@ -95,4 +95,4 @@ internal static SubToolset FactoryForDeserialization(ITranslator translator)
             return subToolset;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Evaluation/Conditionals/OperandExpressionNode.cs b/src/Build/Evaluation/Conditionals/OperandExpressionNode.cs
index 9efeb65a947..1dfbc5ecba4 100644
--- a/src/Build/Evaluation/Conditionals/OperandExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OperandExpressionNode.cs
@@ -24,4 +24,4 @@ internal override bool DetectOr()
         #endregion
 
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Evaluation/Conditionals/Scanner.cs b/src/Build/Evaluation/Conditionals/Scanner.cs
index 8a711257b2f..645181ce8f7 100644
--- a/src/Build/Evaluation/Conditionals/Scanner.cs
+++ b/src/Build/Evaluation/Conditionals/Scanner.cs
@@ -366,7 +366,7 @@ private static bool ScanForPropertyExpressionEnd(string expression, int index, o
                         // If it is not then the calling code will determine that
                         if (nestLevel == 0)
                         {
-                            if (whitespaceFound && !nonIdentifierCharacterFound && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10))
+                            if (whitespaceFound && !nonIdentifierCharacterFound)
                             {
                                 return false;
                             }
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index da150f24f83..b3154221e9f 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -1833,7 +1833,7 @@ static string EvaluateProperty(string value, IElementLocation location,
 
                 if (!sdkResult.Success)
                 {
-                    if (_loadSettings.HasFlag(ProjectLoadSettings.IgnoreMissingImports) && (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10) || !_loadSettings.HasFlag(ProjectLoadSettings.FailOnUnresolvedSdk)))
+                    if (_loadSettings.HasFlag(ProjectLoadSettings.IgnoreMissingImports) && !_loadSettings.HasFlag(ProjectLoadSettings.FailOnUnresolvedSdk))
                     {
                         ProjectImportedEventArgs eventArgs = new ProjectImportedEventArgs(
                             importElement.Location.Line,
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 1bacf84bbe7..9bc57cab1ed 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -19,9 +19,7 @@
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-#if FEATURE_WIN32_REGISTRY
 using Microsoft.Win32;
-#endif
 using AvailableStaticMethods = Microsoft.Build.Internal.AvailableStaticMethods;
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
@@ -1190,12 +1188,11 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                         }
                         else if ((expression.Length - (propertyStartIndex + 2)) > 9 && tryExtractRegistryFunction && s_invariantCompareInfo.IndexOf(expression, "Registry:", propertyStartIndex + 2, 9, CompareOptions.OrdinalIgnoreCase) == propertyStartIndex + 2)
                         {
-                            // if FEATURE_WIN32_REGISTRY is off, treat the property value as if there's no Registry value at that location, rather than fail
                             propertyBody = expression.Substring(propertyStartIndex + 2, propertyEndIndex - propertyStartIndex - 2);
 
                             // If the property body starts with any of our special objects, then deal with them
                             // This is a registry reference, like $(Registry:HKEY_LOCAL_MACHINE\Software\Vendor\Tools@TaskLocation)
-                            propertyValue = ExpandRegistryValue(propertyBody, elementLocation); // This func returns an empty string if not FEATURE_WIN32_REGISTRY
+                            propertyValue = ExpandRegistryValue(propertyBody, elementLocation); // This func returns an empty string if not on Windows
                         }
 
                         // Compat hack: as a special case, $(HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\9.0\VSTSDB@VSTSDBDirectory) should return String.Empty
@@ -1571,7 +1568,6 @@ private static object ExpandMSBuildThisFileProperty(string propertyName, IElemen
                 return value;
             }
 
-#if FEATURE_WIN32_REGISTRY
             /// <summary>
             /// Given a string like "Registry:HKEY_LOCAL_MACHINE\Software\Vendor\Tools@TaskLocation", return the value at that location
             /// in the registry. If the value isn't found, returns String.Empty.
@@ -1582,6 +1578,16 @@ private static object ExpandMSBuildThisFileProperty(string propertyName, IElemen
             /// </summary>
             private static string ExpandRegistryValue(string registryExpression, IElementLocation elementLocation)
             {
+#if RUNTIME_TYPE_NETCORE
+                // .NET Core MSBuild used to always return empty, so match that behavior
+                // on non-Windows (no registry), and with a changewave (in case someone
+                // had a registry property and it breaks when it lights up).
+                if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+                {
+                    return string.Empty;
+                }
+#endif
+
                 // Remove "Registry:" prefix
                 string registryLocation = registryExpression.Substring(9);
 
@@ -1655,15 +1661,6 @@ private static string ExpandRegistryValue(string registryExpression, IElementLoc
 
                 return result;
             }
-#else
-            /// <summary>
-            /// Given a string like "Registry:HKEY_LOCAL_MACHINE\Software\Vendor\Tools@TaskLocation", returns String.Empty, as FEATURE_WIN32_REGISTRY is off.
-            /// </summary>
-            private static string ExpandRegistryValue(string registryExpression, IElementLocation elementLocation)
-            {
-                return String.Empty;
-            }
-#endif
         }
 
         /// <summary>
@@ -3509,8 +3506,11 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
 
                     // If the result of the function call is a string, then we need to escape the result
                     // so that we maintain the "engine contains escaped data" state.
-                    // The exception is that the user is explicitly calling MSBuild::Unescape or MSBuild::Escape
-                    if (functionResult is string functionResultString && !String.Equals("Unescape", _methodMethodName, StringComparison.OrdinalIgnoreCase) && !String.Equals("Escape", _methodMethodName, StringComparison.OrdinalIgnoreCase))
+                    // The exception is that the user is explicitly calling MSBuild::Unescape, MSBuild::Escape, or ConvertFromBase64
+                    if (functionResult is string functionResultString &&
+                        !String.Equals("Unescape", _methodMethodName, StringComparison.OrdinalIgnoreCase) &&
+                        !String.Equals("Escape", _methodMethodName, StringComparison.OrdinalIgnoreCase) &&
+                        !String.Equals("ConvertFromBase64", _methodMethodName, StringComparison.OrdinalIgnoreCase))
                     {
                         functionResult = EscapingUtilities.Escape(functionResultString);
                     }
@@ -4074,6 +4074,22 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                                 return true;
                             }
                         }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.ConvertToBase64), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArg(args, out string arg0))
+                            {
+                                returnVal = IntrinsicFunctions.ConvertToBase64(arg0);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.ConvertFromBase64), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArg(args, out string arg0))
+                            {
+                                returnVal = IntrinsicFunctions.ConvertFromBase64(arg0);
+                                return true;
+                            }
+                        }
                         else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.StableStringHash), StringComparison.OrdinalIgnoreCase))
                         {
                             if (TryGetArg(args, out string arg0))
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 3217e7ffe98..ce0f37bbd56 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -5,6 +5,8 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Runtime.InteropServices;
+using System.Runtime.Versioning;
+using System.Text;
 using System.Text.RegularExpressions;
 
 using Microsoft.Build.Framework;
@@ -27,11 +29,11 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal static class IntrinsicFunctions
     {
-#if FEATURE_WIN32_REGISTRY
+#pragma warning disable CA1416 // Platform compatibility: we'll only use this on Windows
         private static readonly object[] DefaultRegistryViews = new object[] { RegistryView.Default };
+#pragma warning restore CA1416
 
         private static readonly Lazy<Regex> RegistrySdkRegex = new Lazy<Regex>(() => new Regex(@"^HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Microsoft SDKs\\Windows\\v(\d+\.\d+)$", RegexOptions.IgnoreCase));
-#endif // FEATURE_WIN32_REGISTRY
 
         private static readonly Lazy<NuGetFrameworkWrapper> NuGetFramework = new Lazy<NuGetFrameworkWrapper>(() => new NuGetFrameworkWrapper());
 
@@ -163,12 +165,20 @@ internal static int BitwiseNot(int first)
             return ~first;
         }
 
-#if FEATURE_WIN32_REGISTRY
         /// <summary>
         /// Get the value of the registry key and value, default value is null
         /// </summary>
         internal static object GetRegistryValue(string keyName, string valueName)
         {
+#if RUNTIME_TYPE_NETCORE
+            // .NET Core MSBuild used to always return empty, so match that behavior
+            // on non-Windows (no registry), and with a changewave (in case someone
+            // had a registry property and it breaks when it lights up).
+            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                return null;
+            }
+#endif
             return Registry.GetValue(keyName, valueName, null /* null to match the $(Regsitry:XYZ@ZBC) behaviour */);
         }
 
@@ -177,11 +187,30 @@ internal static object GetRegistryValue(string keyName, string valueName)
         /// </summary>
         internal static object GetRegistryValue(string keyName, string valueName, object defaultValue)
         {
+#if RUNTIME_TYPE_NETCORE
+            // .NET Core MSBuild used to always return empty, so match that behavior
+            // on non-Windows (no registry), and with a changewave (in case someone
+            // had a registry property and it breaks when it lights up).
+            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                return defaultValue;
+            }
+#endif
             return Registry.GetValue(keyName, valueName, defaultValue);
         }
 
         internal static object GetRegistryValueFromView(string keyName, string valueName, object defaultValue, params object[] views)
         {
+#if RUNTIME_TYPE_NETCORE
+            // .NET Core MSBuild used to always return empty, so match that behavior
+            // on non-Windows (no registry), and with a changewave (in case someone
+            // had a registry property and it breaks when it lights up).
+            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                return defaultValue;
+            }
+#endif
+
             if (views == null || views.Length == 0)
             {
                 views = DefaultRegistryViews;
@@ -195,6 +224,16 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
         /// </summary>
         internal static object GetRegistryValueFromView(string keyName, string valueName, object defaultValue, ArraySegment<object> views)
         {
+#if RUNTIME_TYPE_NETCORE
+            // .NET Core MSBuild used to always return empty, so match that behavior
+            // on non-Windows (no registry), and with a changewave (in case someone
+            // had a registry property and it breaks when it lights up).
+            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                return defaultValue;
+            }
+#endif
+
             // We will take on handing of default value
             // A we need to act on the null return from the GetValue call below
             // so we can keep searching other registry views
@@ -262,33 +301,6 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
             return result;
         }
 
-#else // FEATURE_WIN32_REGISTRY is off, need to mock the function names to let scrips call these property functions and get NULLs rather than fail with errors
-
-        /// <summary>
-        /// Get the value of the registry key and value, default value is null
-        /// </summary>
-        internal static object GetRegistryValue(string keyName, string valueName)
-        {
-            return null; // FEATURE_WIN32_REGISTRY is off, need to mock the function names to let scrips call these property functions and get NULLs rather than fail with errors
-        }
-
-        /// <summary>
-        /// Get the value of the registry key and value
-        /// </summary>
-        internal static object GetRegistryValue(string keyName, string valueName, object defaultValue)
-        {
-            return defaultValue; // FEATURE_WIN32_REGISTRY is off, need to mock the function names to let scrips call these property functions and get NULLs rather than fail with errors
-        }
-
-        /// <summary>
-        /// Get the value of the registry key from one of the RegistryView's specified
-        /// </summary>
-        internal static object GetRegistryValueFromView(string keyName, string valueName, object defaultValue, params object[] views)
-        {
-            return defaultValue; // FEATURE_WIN32_REGISTRY is off, need to mock the function names to let scrips call these property functions and get NULLs rather than fail with errors
-        }
-#endif
-
         /// <summary>
         /// Given the absolute location of a file, and a disc location, returns relative file path to that disk location.
         /// Throws UriFormatException.
@@ -350,6 +362,26 @@ internal static string ValueOrDefault(string conditionValue, string defaultValue
             }
         }
 
+        /// <summary>
+        /// Returns the string after converting all bytes to base 64 (alphanumeric characters plus '+' and '/'), ending in one or two '='.
+        /// </summary>
+        /// <param name="toEncode">String to encode in base 64.</param>
+        /// <returns>The encoded string.</returns>
+        internal static string ConvertToBase64(string toEncode)
+        {
+            return Convert.ToBase64String(Encoding.UTF8.GetBytes(toEncode));
+        }
+
+        /// <summary>
+        /// Returns the string after converting from base 64 (alphanumeric characters plus '+' and '/'), ending in one or two '='.
+        /// </summary>
+        /// <param name="toDecode">The string to decode.</param>
+        /// <returns>The decoded string.</returns>
+        internal static string ConvertFromBase64(string toDecode)
+        {
+            return Encoding.UTF8.GetString(Convert.FromBase64String(toDecode));
+        }
+
         /// <summary>
         /// Hash the string independent of bitness and target framework.
         /// </summary>
@@ -574,7 +606,6 @@ internal static List<string> __GetListTest()
 
 #endregion
 
-#if FEATURE_WIN32_REGISTRY
         /// <summary>
         /// Following function will parse a keyName and returns the basekey for it.
         /// It will also store the subkey name in the out parameter.
@@ -582,6 +613,7 @@ internal static List<string> __GetListTest()
         /// The return value shouldn't be null.
         /// Taken from: \ndp\clr\src\BCL\Microsoft\Win32\Registry.cs
         /// </summary>
+        [SupportedOSPlatform("windows")]
         private static RegistryKey GetBaseKeyFromKeyName(string keyName, RegistryView view, out string subKeyName)
         {
             if (keyName == null)
@@ -643,6 +675,5 @@ private static RegistryKey GetBaseKeyFromKeyName(string keyName, RegistryView vi
 
             return basekey;
         }
-#endif
     }
 }
diff --git a/src/Build/Evaluation/ItemsAndMetadataPair.cs b/src/Build/Evaluation/ItemsAndMetadataPair.cs
index b949777e8d2..9385d06ddd7 100644
--- a/src/Build/Evaluation/ItemsAndMetadataPair.cs
+++ b/src/Build/Evaluation/ItemsAndMetadataPair.cs
@@ -69,4 +69,4 @@ internal Dictionary<string, MetadataReference> Metadata
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Globbing/Extensions/MSBuildGlobExtensions.cs b/src/Build/Globbing/Extensions/MSBuildGlobExtensions.cs
index 4caec4a3a9d..28623b14545 100644
--- a/src/Build/Globbing/Extensions/MSBuildGlobExtensions.cs
+++ b/src/Build/Globbing/Extensions/MSBuildGlobExtensions.cs
@@ -26,4 +26,4 @@ public static IEnumerable<MSBuildGlob> GetParsedGlobs(this IMSBuildGlob glob)
             return parsedGlobVisitor.CollectedGlobs;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Globbing/IMSBuildGlob.cs b/src/Build/Globbing/IMSBuildGlob.cs
index 55a8c24c9d4..59a683ace91 100644
--- a/src/Build/Globbing/IMSBuildGlob.cs
+++ b/src/Build/Globbing/IMSBuildGlob.cs
@@ -23,4 +23,4 @@ public interface IMSBuildGlob
         /// <returns></returns>
         bool IsMatch(string stringToMatch);
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Globbing/MSBuildGlobWithGaps.cs b/src/Build/Globbing/MSBuildGlobWithGaps.cs
index 26062969f0c..5126a13744c 100644
--- a/src/Build/Globbing/MSBuildGlobWithGaps.cs
+++ b/src/Build/Globbing/MSBuildGlobWithGaps.cs
@@ -76,4 +76,4 @@ public bool IsMatch(string stringToMatch)
             return MainGlob.IsMatch(stringToMatch) && !Gaps.IsMatch(stringToMatch);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Globbing/Visitor/GlobVisitor.cs b/src/Build/Globbing/Visitor/GlobVisitor.cs
index 25b094d9438..aaae9a6d5c9 100644
--- a/src/Build/Globbing/Visitor/GlobVisitor.cs
+++ b/src/Build/Globbing/Visitor/GlobVisitor.cs
@@ -44,4 +44,4 @@ protected virtual void VisitMSBuildGlob(MSBuildGlob msbuildGlob)
         {
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Globbing/Visitor/ParsedGlobCollector.cs b/src/Build/Globbing/Visitor/ParsedGlobCollector.cs
index 417a8b56d49..76f85bb2d9c 100644
--- a/src/Build/Globbing/Visitor/ParsedGlobCollector.cs
+++ b/src/Build/Globbing/Visitor/ParsedGlobCollector.cs
@@ -14,4 +14,4 @@ protected override void VisitMSBuildGlob(MSBuildGlob msbuildGlob)
             _collectedGlobs.Add(msbuildGlob);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index c419203fb47..28387389e8c 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -22,6 +22,10 @@ namespace Microsoft.Build.Graph
 {
     internal class GraphBuilder
     {
+        private const string PlatformLookupTableMetadataName = "PlatformLookupTable";
+        private const string PlatformMetadataName = "Platform";
+        private const string PlatformsMetadataName = "Platforms";
+        private const string EnableDynamicPlatformResolutionMetadataName = "EnableDynamicPlatformResolution";
         internal const string SolutionItemReference = "_SolutionReference";
         
         /// <summary>
@@ -48,6 +52,8 @@ internal class GraphBuilder
         private readonly ProjectGraph.ProjectInstanceFactoryFunc _projectInstanceFactory;
         private IReadOnlyDictionary<string, IReadOnlyCollection<string>> _solutionDependencies;
 
+        private bool PlatformNegotiationEnabled = false;
+
         public GraphBuilder(
             IEnumerable<ProjectGraphEntryPoint> entryPoints,
             ProjectCollection projectCollection,
@@ -499,18 +505,44 @@ private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)
         {
             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.
             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();
+            ProjectGraphNode graphNode;
+            ProjectInstance projectInstance;
+            var negotiatePlatform = PlatformNegotiationEnabled && !configurationMetadata.IsSetPlatformHardCoded;
+
+            projectInstance = _projectInstanceFactory(
+                                configurationMetadata.ProjectFullPath,
+                                negotiatePlatform ? null : globalProperties, // Platform negotiation requires an evaluation with no global properties first
+                                _projectCollection);
 
-            var projectInstance = _projectInstanceFactory(
-                configurationMetadata.ProjectFullPath,
-                globalProperties,
-                _projectCollection);
+            if (ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)))
+            {
+                PlatformNegotiationEnabled = true;
+            }
 
             if (projectInstance == null)
             {
                 throw new InvalidOperationException(ResourceUtilities.GetResourceString("NullReferenceFromProjectInstanceFactory"));
             }
 
-            var graphNode = new ProjectGraphNode(projectInstance);
+            if (negotiatePlatform)
+            {
+                var selectedPlatform = PlatformNegotiation.GetNearestPlatform(projectInstance.GetPropertyValue(PlatformMetadataName), projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), configurationMetadata.PreviousPlatformLookupTable, projectInstance.FullPath, configurationMetadata.PreviousPlatform);
+
+                if (selectedPlatform.Equals(String.Empty))
+                {
+                    globalProperties.Remove(PlatformMetadataName);
+                }
+                else
+                {
+                    globalProperties[PlatformMetadataName] = selectedPlatform;
+                }
+                projectInstance = _projectInstanceFactory(
+                                configurationMetadata.ProjectFullPath,
+                                globalProperties,
+                                _projectCollection);           
+            }
+
+            graphNode = new ProjectGraphNode(projectInstance);
 
             var referenceInfos = ParseReferences(graphNode);
 
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index 08e0e5a56b8..a838844f160 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -1,4 +1,4 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
@@ -38,7 +38,7 @@ private ProjectInterpretation()
         {
         }
 
-        private static readonly ImmutableList<GlobalPropertiesModifier> ModifierForNonMultitargetingNodes = new[] {(GlobalPropertiesModifier) ProjectReferenceGlobalPropertiesModifier}.ToImmutableList();
+        private static readonly ImmutableList<GlobalPropertiesModifier> ModifierForNonMultitargetingNodes = new[] { (GlobalPropertiesModifier)ProjectReferenceGlobalPropertiesModifier }.ToImmutableList();
 
         internal enum ProjectType
         {
@@ -98,7 +98,16 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
 
                 var referenceGlobalProperties = GetGlobalPropertiesForItem(projectReferenceItem, requesterInstance.GlobalPropertiesDictionary, globalPropertiesModifiers);
 
-                var referenceConfig = new ConfigurationMetadata(projectReferenceFullPath, referenceGlobalProperties);
+                var requesterPlatform = "";
+                var requesterPlatformLookupTable = "";
+
+                if (ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue("EnableDynamicPlatformResolution")))
+                {
+                    requesterPlatform = requesterInstance.GetPropertyValue("Platform");
+                    requesterPlatformLookupTable = requesterInstance.GetPropertyValue("PlatformLookupTable");
+                }
+
+                var referenceConfig = new ConfigurationMetadata(projectReferenceFullPath, referenceGlobalProperties, requesterPlatform, requesterPlatformLookupTable, projectReferenceItem.HasMetadata("SetPlatform"));
 
                 yield return new ReferenceInfo(referenceConfig, projectReferenceItem);
             }
@@ -196,7 +205,7 @@ private static IEnumerable<ProjectItemInstance> ConstructInnerBuildReferences(Pr
                     project: outerBuild,
                     itemType: InnerBuildReferenceItemName,
                     includeEscaped: outerBuild.FullPath,
-                    directMetadata: new[] {new KeyValuePair<string, string>(ItemMetadataNames.PropertiesMetadataName, $"{globalPropertyName}={globalPropertyValue}")},
+                    directMetadata: new[] { new KeyValuePair<string, string>(ItemMetadataNames.PropertiesMetadataName, $"{globalPropertyName}={globalPropertyValue}") },
                     definingFileEscaped: outerBuild.FullPath);
             }
         }
diff --git a/src/Build/Instance/HostServices.cs b/src/Build/Instance/HostServices.cs
index 99d07305b77..76a28c6c8fd 100644
--- a/src/Build/Instance/HostServices.cs
+++ b/src/Build/Instance/HostServices.cs
@@ -9,6 +9,7 @@
 using System.Runtime.InteropServices;
 using System.Linq;
 using Microsoft.Build.BackEnd;
+using System.Runtime.Versioning;
 
 #nullable disable
 
@@ -56,9 +57,7 @@ public class HostServices : ITranslatable
         /// </summary>
         private Dictionary<string, NodeAffinity> _projectAffinities;
 
-#if FEATURE_COM_INTEROP
         private Lazy<IRunningObjectTableWrapper> _runningObjectTable = new Lazy<IRunningObjectTableWrapper>(() => new RunningObjectTable());
-#endif
 
         /// <summary>
         /// Gets any host object applicable to this task name
@@ -88,25 +87,27 @@ public ITaskHost GetHostObject(string projectFile, string targetName, string tas
             {
                 if (monikerNameOrITaskHost.IsMoniker)
                 {
-#if FEATURE_COM_INTEROP
-
-                    try
+                    if (NativeMethodsShared.IsWindows)
                     {
-                        object objectFromRunningObjectTable =
-                            _runningObjectTable.Value.GetObject(monikerNameOrITaskHost.MonikerName);
-                        return (ITaskHost)objectFromRunningObjectTable;
+                        try
+                        {
+                            object objectFromRunningObjectTable =
+                                _runningObjectTable.Value.GetObject(monikerNameOrITaskHost.MonikerName);
+                            return (ITaskHost)objectFromRunningObjectTable;
+                        }
+                        catch (Exception ex) when (ex is COMException || ex is InvalidCastException)
+                        {
+                            throw new HostObjectException(projectFile, targetName, taskName, ex);
+                        }
                     }
-                    catch (Exception ex) when (ex is COMException || ex is InvalidCastException)
+                    else
                     {
-                        throw new HostObjectException(projectFile, targetName, taskName, ex);
+                        throw new HostObjectException(
+                            projectFile,
+                            targetName,
+                            taskName,
+                            "COM Monikers can only be used on Windows");
                     }
-#else
-                    throw new HostObjectException(
-                        projectFile,
-                        targetName,
-                        taskName,
-                        "FEATURE_COM_INTEROP is disabled (non full framework). Host object can only be ITaskHost");
-#endif
                 }
                 else
                 {
@@ -146,7 +147,6 @@ public void RegisterHostObject(string projectFile, string targetName, string tas
             hostObjects.RegisterHostObject(targetName, taskName, hostObject);
         }
 
-#if FEATURE_COM_INTEROP
         /// <summary>
         /// Register a remote host object for a particular task/target pair.
         /// The remote host object require registered in Running Object Table(ROT) already.
@@ -161,6 +161,7 @@ public void RegisterHostObject(string projectFile, string targetName, string tas
         /// <param name="targetName">target name</param>
         /// <param name="taskName">task name</param>
         /// <param name="monikerName">the Moniker used to register host object in ROT</param>
+        [SupportedOSPlatform("windows")]
         public void RegisterHostObject(string projectFile, string targetName, string taskName, string monikerName)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
@@ -174,7 +175,6 @@ public void RegisterHostObject(string projectFile, string targetName, string tas
 
             hostObjects.RegisterHostObject(targetName, taskName, monikerName);
         }
-#endif
 
         /// <summary>
         /// Unregister the project's host objects, if any and remove any node affinities associated with it.
@@ -371,16 +371,15 @@ void ITranslatable.Translate(ITranslator translator)
             }
         }
 
-#if FEATURE_COM_INTEROP
         /// <summary>
         /// Test only
         /// </summary>
         /// <param name="runningObjectTable"></param>
+        [SupportedOSPlatform("windows")]
         internal void SetTestRunningObjectTable(IRunningObjectTableWrapper runningObjectTable)
         {
             _runningObjectTable = new Lazy<IRunningObjectTableWrapper>(() => runningObjectTable);
         }
-#endif
 
         internal class MonikerNameOrITaskHost
         {
@@ -446,10 +445,10 @@ internal void RegisterHostObject(string targetName, string taskName, ITaskHost h
                 }
             }
 
-#if FEATURE_COM_INTEROP
             /// <summary>
             /// Registers a host object for this project file
             /// </summary>
+            [SupportedOSPlatform("windows")]
             internal void RegisterHostObject(string targetName, string taskName, string monikerName)
             {
                 if (monikerName == null)
@@ -461,7 +460,6 @@ internal void RegisterHostObject(string targetName, string taskName, string moni
                     _hostObjects[new TargetTaskKey(targetName, taskName)] = new MonikerNameOrITaskHost(monikerName);
                 }
             }
-#endif
 
             /// <summary>
             /// Gets any host object for this project file matching the task and target names specified.
diff --git a/src/Build/Instance/RunningObjectTable.cs b/src/Build/Instance/RunningObjectTable.cs
index 5e0cc781414..bec9632885e 100644
--- a/src/Build/Instance/RunningObjectTable.cs
+++ b/src/Build/Instance/RunningObjectTable.cs
@@ -3,6 +3,7 @@
 
 using System.Runtime.InteropServices;
 using System.Runtime.InteropServices.ComTypes;
+using System.Runtime.Versioning;
 using System.Threading;
 using System.Threading.Tasks;
 
@@ -10,7 +11,6 @@
 
 namespace Microsoft.Build.Execution
 {
-#if FEATURE_COM_INTEROP
     /// <summary>
     /// Wrapper for the COM Running Object Table.
     /// </summary>
@@ -23,6 +23,11 @@ internal class RunningObjectTable : IRunningObjectTableWrapper
 
         public RunningObjectTable()
         {
+            if (!NativeMethodsShared.IsWindows)
+            {
+                return;
+            }
+
             if (Thread.CurrentThread.GetApartmentState() == ApartmentState.MTA)
             {
                 Ole32.GetRunningObjectTable(0, out var rot);
@@ -35,7 +40,9 @@ public RunningObjectTable()
                 _rotTask =
                 Task.Run(() =>
                     {
+#pragma warning disable CA1416 // Validate platform compatibility: we checked above but the analyzer misses it
                         Ole32.GetRunningObjectTable(0, out var rot);
+#pragma warning restore CA1416 // Validate platform compatibility
                         return rot;
                     });
             }
@@ -44,6 +51,7 @@ public RunningObjectTable()
         /// <summary>
         /// Attempts to retrieve an item from the ROT.
         /// </summary>
+        [SupportedOSPlatform("windows")]
         public object GetObject(string itemName)
         {
             var rot = _rotTask.GetAwaiter().GetResult();
@@ -75,6 +83,7 @@ public object GetObject(string itemName)
             return obj;
         }
 
+        [SupportedOSPlatform("windows")]
         private static class Ole32
         {
             [DllImport(nameof(Ole32))]
@@ -89,5 +98,4 @@ public static extern void GetRunningObjectTable(
                 out IRunningObjectTable pprot);
         }
     }
-#endif
 }
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 1b82af4f5a8..c7169a09dad 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -1666,34 +1666,41 @@ private void ParseUsingTaskParameterGroupElement<P, I>(UsingTaskParameterGroupEl
                         // Cannot have a null or empty name for the type after expansion.
                         ProjectErrorUtilities.VerifyThrowInvalidProject
                         (
-                        !String.IsNullOrEmpty(expandedType),
-                        parameter.ParameterTypeLocation,
-                        "InvalidEvaluatedAttributeValue",
-                        expandedType,
-                        parameter.ParameterType,
-                        XMakeAttributes.parameterType,
-                        XMakeElements.usingTaskParameter
+                            !String.IsNullOrEmpty(expandedType),
+                            parameter.ParameterTypeLocation,
+                            "InvalidEvaluatedAttributeValue",
+                            expandedType,
+                            parameter.ParameterType,
+                            XMakeAttributes.parameterType,
+                            XMakeElements.usingTaskParameter
                         );
 
-                        // Try and get the type directly 
-                        Type paramType = Type.GetType(expandedType);
-
-                        // The type could not be got directly try and see if the type can be found by appending the FrameworkAssemblyName to it.
-                        if (paramType == null)
+                        Type paramType;
+                        if (expandedType.StartsWith("Microsoft.Build.Framework.", StringComparison.OrdinalIgnoreCase) && !expandedType.Contains(","))
                         {
-                            paramType = Type.GetType(expandedType + "," + typeof(ITaskItem).GetTypeInfo().Assembly.FullName, false /* don't throw on error */, true /* case-insensitive */);
+                            // This is workaround for internal bug https://devdiv.visualstudio.com/DevDiv/_workitems/edit/1448821
+                            // Visual Studio can load different version of Microsoft.Build.Framework.dll and non fully classified type could be resolved from it 
+                            // which cause InvalidProjectFileException with "UnsupportedTaskParameterTypeError" message.
+                            // Another way to address this is to load types from compiled assembly - that would be more robust solution but also much more complex and risky code changes.
+                            paramType = Type.GetType(expandedType + "," + typeof(ITaskItem).GetTypeInfo().Assembly.FullName, false /* don't throw on error */, true /* case-insensitive */) ??
+                                        Type.GetType(expandedType);
+                        }
+                        else
+                        {
+                            paramType = Type.GetType(expandedType) ??
+                                        Type.GetType(expandedType + "," + typeof(ITaskItem).GetTypeInfo().Assembly.FullName, false /* don't throw on error */, true /* case-insensitive */);
+                        }
 
-                            ProjectErrorUtilities.VerifyThrowInvalidProject
-                            (
-                             paramType != null,
-                             parameter.ParameterTypeLocation,
-                             "InvalidEvaluatedAttributeValue",
-                             expandedType,
-                             parameter.ParameterType,
-                             XMakeAttributes.parameterType,
+                        ProjectErrorUtilities.VerifyThrowInvalidProject
+                        (
+                            paramType != null,
+                            parameter.ParameterTypeLocation,
+                            "InvalidEvaluatedAttributeValue",
+                            expandedType,
+                            parameter.ParameterType,
+                            XMakeAttributes.parameterType,
                             XMakeElements.usingTaskParameter
-                            );
-                        }
+                        );
 
                         bool output;
                         string expandedOutput = expander.ExpandIntoStringLeaveEscaped(parameter.Output, expanderOptions, parameter.OutputLocation);
@@ -1702,19 +1709,19 @@ private void ParseUsingTaskParameterGroupElement<P, I>(UsingTaskParameterGroupEl
                         {
                             ProjectErrorUtilities.ThrowInvalidProject
                             (
-                             parameter.OutputLocation,
-                             "InvalidEvaluatedAttributeValue",
-                             expandedOutput,
-                             parameter.Output,
-                             XMakeAttributes.output,
-                             XMakeElements.usingTaskParameter
+                                parameter.OutputLocation,
+                                "InvalidEvaluatedAttributeValue",
+                                expandedOutput,
+                                parameter.Output,
+                                XMakeAttributes.output,
+                                XMakeElements.usingTaskParameter
                             );
                         }
 
                         if (
                             (!output && (!TaskParameterTypeVerifier.IsValidInputParameter(paramType))) ||
                             (output && !TaskParameterTypeVerifier.IsValidOutputParameter(paramType))
-                           )
+                        )
                         {
                             ProjectErrorUtilities.ThrowInvalidProject
                             (
@@ -1723,7 +1730,7 @@ private void ParseUsingTaskParameterGroupElement<P, I>(UsingTaskParameterGroupEl
                                 paramType.FullName,
                                 parameter.ParameterType,
                                 parameter.Name
-                             );
+                            );
                         }
 
                         bool required;
@@ -1733,12 +1740,12 @@ private void ParseUsingTaskParameterGroupElement<P, I>(UsingTaskParameterGroupEl
                         {
                             ProjectErrorUtilities.ThrowInvalidProject
                             (
-                             parameter.RequiredLocation,
-                             "InvalidEvaluatedAttributeValue",
-                             expandedRequired,
-                             parameter.Required,
-                             XMakeAttributes.required,
-                             XMakeElements.usingTaskParameter
+                                parameter.RequiredLocation,
+                                "InvalidEvaluatedAttributeValue",
+                                expandedRequired,
+                                parameter.Required,
+                                XMakeAttributes.required,
+                                XMakeElements.usingTaskParameter
                             );
                         }
 
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index c25e4dc39fe..30c38da91e5 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -51,8 +51,6 @@
     <PackageReference Include="System.Reflection.Metadata" />
     <PackageReference Include="System.Security.Principal.Windows" />
     <PackageReference Include="System.Text.Encoding.CodePages" />
-    <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
-    <PackageReference Include="Microsoft.Win32.Registry" />
   </ItemGroup>
 
   <ItemGroup>
@@ -122,6 +120,10 @@
     <Compile Include="..\Shared\NodeShutdown.cs" />
     <Compile Include="..\Shared\NamedPipeUtil.cs" />
     <Compile Include="..\Shared\ProcessExtensions.cs" />
+    <Compile Include="..\Shared\PlatformNegotiation.cs">
+      <Link>PlatformNegotiation.cs</Link>
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="..\Shared\TaskLoggingHelper.cs">
       <Link>BackEnd\Components\RequestBuilder\IntrinsicTasks\TaskLoggingHelper.cs</Link>
       <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
diff --git a/src/Build/PublicAPI/net/PublicAPI.Shipped.txt b/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
index 03d0963d09f..a4ec0aaf92d 100644
--- a/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
+++ b/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
@@ -528,6 +528,9 @@ Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFileLocation.get ->
 Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyName.get -> string
 Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyName.set -> void
 Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyNameLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectUsingTaskElement.Override.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskElement.Override.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskElement.OverrideLocation.get -> Microsoft.Build.Construction.ElementLocation
 Microsoft.Build.Construction.ProjectUsingTaskElement.ParameterGroup.get -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
 Microsoft.Build.Construction.ProjectUsingTaskElement.Runtime.get -> string
 Microsoft.Build.Construction.ProjectUsingTaskElement.Runtime.set -> void
@@ -1031,6 +1034,8 @@ Microsoft.Build.Execution.BuildParameters.WarningsAsErrors.get -> System.Collect
 Microsoft.Build.Execution.BuildParameters.WarningsAsErrors.set -> void
 Microsoft.Build.Execution.BuildParameters.WarningsAsMessages.get -> System.Collections.Generic.ISet<string>
 Microsoft.Build.Execution.BuildParameters.WarningsAsMessages.set -> void
+Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.get -> System.Collections.Generic.ISet<string>
+Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.set -> void
 Microsoft.Build.Execution.BuildRequestData
 Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild) -> void
 Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
diff --git a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
index c5e7790c0a3..e69de29bb2d 100644
--- a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
+++ b/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
@@ -1,5 +0,0 @@
-Microsoft.Build.Construction.ProjectUsingTaskElement.Override.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.Override.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.OverrideLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.get -> System.Collections.Generic.ISet<string>
-Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.set -> void
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
index f34fab4b645..ecaad75bd4e 100644
--- a/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ b/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
@@ -528,6 +528,9 @@ Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFileLocation.get ->
 Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyName.get -> string
 Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyName.set -> void
 Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyNameLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectUsingTaskElement.Override.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskElement.Override.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskElement.OverrideLocation.get -> Microsoft.Build.Construction.ElementLocation
 Microsoft.Build.Construction.ProjectUsingTaskElement.ParameterGroup.get -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
 Microsoft.Build.Construction.ProjectUsingTaskElement.Runtime.get -> string
 Microsoft.Build.Construction.ProjectUsingTaskElement.Runtime.set -> void
@@ -961,6 +964,8 @@ Microsoft.Build.Execution.BuildParameters.AllowFailureWithoutError.set -> void
 Microsoft.Build.Execution.BuildParameters.BuildParameters() -> void
 Microsoft.Build.Execution.BuildParameters.BuildParameters(Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
 Microsoft.Build.Execution.BuildParameters.BuildProcessEnvironment.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Execution.BuildParameters.BuildThreadPriority.get -> System.Threading.ThreadPriority
+Microsoft.Build.Execution.BuildParameters.BuildThreadPriority.set -> void
 Microsoft.Build.Execution.BuildParameters.Clone() -> Microsoft.Build.Execution.BuildParameters
 Microsoft.Build.Execution.BuildParameters.Culture.get -> System.Globalization.CultureInfo
 Microsoft.Build.Execution.BuildParameters.Culture.set -> void
@@ -1029,6 +1034,8 @@ Microsoft.Build.Execution.BuildParameters.WarningsAsErrors.get -> System.Collect
 Microsoft.Build.Execution.BuildParameters.WarningsAsErrors.set -> void
 Microsoft.Build.Execution.BuildParameters.WarningsAsMessages.get -> System.Collections.Generic.ISet<string>
 Microsoft.Build.Execution.BuildParameters.WarningsAsMessages.set -> void
+Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.get -> System.Collections.Generic.ISet<string>
+Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.set -> void
 Microsoft.Build.Execution.BuildRequestData
 Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild) -> void
 Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index fdbce5593f6..e610ce450ea 100644
--- a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -1,7 +1 @@
-Microsoft.Build.Construction.ProjectUsingTaskElement.Override.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.Override.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.OverrideLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.BuildParameters.BuildThreadPriority.get -> System.Threading.ThreadPriority
-Microsoft.Build.Execution.BuildParameters.BuildThreadPriority.set -> void
-Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.get -> System.Collections.Generic.ISet<string>
-Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.set -> void
+Microsoft.Build.Execution.HostServices.RegisterHostObject(string projectFile, string targetName, string taskName, string monikerName) -> void
diff --git a/src/Build/Resources/Constants.cs b/src/Build/Resources/Constants.cs
index 02ace6e3e0a..211f8cd00fa 100644
--- a/src/Build/Resources/Constants.cs
+++ b/src/Build/Resources/Constants.cs
@@ -341,6 +341,7 @@ private static void InitializeAvailableMethods()
                         availableStaticMethods.TryAdd("System.Char", new Tuple<string, Type>(null, typeof(Char)));
                         availableStaticMethods.TryAdd("System.Convert", new Tuple<string, Type>(null, typeof(Convert)));
                         availableStaticMethods.TryAdd("System.DateTime", new Tuple<string, Type>(null, typeof(DateTime)));
+                        availableStaticMethods.TryAdd("System.DateTimeOffset", new Tuple<string, Type>(null, typeof(DateTimeOffset)));
                         availableStaticMethods.TryAdd("System.Decimal", new Tuple<string, Type>(null, typeof(Decimal)));
                         availableStaticMethods.TryAdd("System.Double", new Tuple<string, Type>(null, typeof(Double)));
                         availableStaticMethods.TryAdd("System.Enum", new Tuple<string, Type>(null, typeof(Enum)));
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index 9fc047c95c1..fbe306e3632 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -238,6 +238,7 @@ private static string[] GetFileList
                                 LogDriveEnumerationWarningWithTargetLoggingContext(
                                     targetLoggingContext,
                                     includeLocation,
+                                    excludeLocation,
                                     excludeFileSpecIsEmpty,
                                     disableExcludeDriveEnumerationWarning,                                
                                     fileSpec);
@@ -248,6 +249,7 @@ private static string[] GetFileList
                             case ILoggingService loggingService:
                                 LogDriveEnumerationWarningWithLoggingService(
                                     loggingService,
+                                    includeLocation,
                                     buildEventContext,
                                     buildEventFileInfoFullPath,
                                     filespecUnescaped);
@@ -259,6 +261,8 @@ private static string[] GetFileList
                                 LogDriveEnumerationWarningWithEvaluationLoggingContext(
                                     evaluationLoggingContext,
                                     importLocation,
+                                    includeLocation,
+                                    excludeLocation,
                                     excludeFileSpecIsEmpty,
                                     filespecUnescaped,
                                     fileSpec);
@@ -336,7 +340,7 @@ private static string[] GetFileList
             return fileList;
         }
 
-        private static void LogDriveEnumerationWarningWithTargetLoggingContext(TargetLoggingContext targetLoggingContext, IElementLocation includeLocation, bool excludeFileSpecIsEmpty, bool disableExcludeDriveEnumerationWarning, string fileSpec)
+        private static void LogDriveEnumerationWarningWithTargetLoggingContext(TargetLoggingContext targetLoggingContext, IElementLocation includeLocation, IElementLocation excludeLocation, bool excludeFileSpecIsEmpty, bool disableExcludeDriveEnumerationWarning, string fileSpec)
         {
             // Both condition lines are necessary to skip for the first GetFileListEscaped call
             // and reach for the GetFileListUnescaped call when the wildcarded Exclude attribute results
@@ -345,13 +349,14 @@ private static void LogDriveEnumerationWarningWithTargetLoggingContext(TargetLog
             // Include wildcard attributes for the GetFileListEscaped calls would falsely appear
             // with the Exclude attribute in the logged warning.
             if (((!excludeFileSpecIsEmpty) && (!disableExcludeDriveEnumerationWarning)) ||
-                (includeLocation == null))
+                ((includeLocation == null) && (excludeLocation != null)))
             {
                 targetLoggingContext.LogWarning(
                         DriveEnumeratingWildcardMessageResourceName,
                         fileSpec,
                         XMakeAttributes.exclude,
-                        XMakeElements.itemGroup);
+                        XMakeElements.itemGroup,
+                        excludeLocation.LocationString);
             }
 
             // Both conditions are necessary to reach for both GetFileListEscaped calls
@@ -363,13 +368,14 @@ private static void LogDriveEnumerationWarningWithTargetLoggingContext(TargetLog
                     DriveEnumeratingWildcardMessageResourceName,
                     fileSpec,
                     XMakeAttributes.include,
-                    XMakeElements.itemGroup);
+                    XMakeElements.itemGroup,
+                    includeLocation.LocationString);
             }
         }
 
-        private static void LogDriveEnumerationWarningWithLoggingService(ILoggingService loggingService, BuildEventContext buildEventContext, string buildEventFileInfoFullPath, string filespecUnescaped)
+        private static void LogDriveEnumerationWarningWithLoggingService(ILoggingService loggingService, IElementLocation includeLocation, BuildEventContext buildEventContext, string buildEventFileInfoFullPath, string filespecUnescaped)
         {
-            if (buildEventContext != null)
+            if (buildEventContext != null && includeLocation != null)
             {
                 loggingService.LogWarning(
                     buildEventContext,
@@ -378,11 +384,12 @@ private static void LogDriveEnumerationWarningWithLoggingService(ILoggingService
                     DriveEnumeratingWildcardMessageResourceName,
                     filespecUnescaped,
                     XMakeAttributes.include,
-                    XMakeElements.itemGroup);
+                    XMakeElements.itemGroup,
+                    includeLocation.LocationString);
             }
         }
 
-        private static void LogDriveEnumerationWarningWithEvaluationLoggingContext(EvaluationLoggingContext evaluationLoggingContext, IElementLocation importLocation, bool excludeFileSpecIsEmpty, string filespecUnescaped, string fileSpec)
+        private static void LogDriveEnumerationWarningWithEvaluationLoggingContext(EvaluationLoggingContext evaluationLoggingContext, IElementLocation importLocation, IElementLocation includeLocation, IElementLocation excludeLocation, bool excludeFileSpecIsEmpty, string filespecUnescaped, string fileSpec)
         {
             if (importLocation != null)
             {
@@ -390,23 +397,26 @@ private static void LogDriveEnumerationWarningWithEvaluationLoggingContext(Evalu
                     DriveEnumeratingWildcardMessageResourceName,
                     filespecUnescaped,
                     XMakeAttributes.project,
-                    XMakeElements.import);
+                    XMakeElements.import,
+                    importLocation.LocationString);
             }
-            else if (excludeFileSpecIsEmpty)
+            else if (excludeFileSpecIsEmpty && includeLocation != null)
             {
                 evaluationLoggingContext.LogWarning(
                     DriveEnumeratingWildcardMessageResourceName,
                     fileSpec,
                     XMakeAttributes.include,
-                    XMakeElements.itemGroup);
+                    XMakeElements.itemGroup,
+                    includeLocation.LocationString);
             }
-            else
+            else if (excludeLocation != null)
             {
                 evaluationLoggingContext.LogWarning(
                     DriveEnumeratingWildcardMessageResourceName,
                     fileSpec,
                     XMakeAttributes.exclude,
-                    XMakeElements.itemGroup);
+                    XMakeElements.itemGroup,
+                    excludeLocation.LocationString);
             }
         }
 
@@ -423,21 +433,23 @@ private static void ThrowDriveEnumerationExceptionWithTargetLoggingContext(IElem
                     DriveEnumeratingWildcardMessageResourceName,
                     filespecUnescaped,
                     XMakeAttributes.include,
-                    XMakeElements.itemGroup);
+                    XMakeElements.itemGroup,
+                    includeLocation.LocationString);
             }
 
             // The first condition is necessary to reach for both GetFileListEscaped calls
             // whenever the wildcarded Exclude attribute results in drive enumeration, and
             // the second condition is necessary to reach for the GetFileListUnescaped call
             // (also when the wildcarded Exclude attribute results in drive enumeration).
-            else if ((!excludeFileSpecIsEmpty) || (includeLocation == null))
+            else if (((!excludeFileSpecIsEmpty) || (includeLocation == null)) && (excludeLocation != null))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                         excludeLocation,
                         DriveEnumeratingWildcardMessageResourceName,
                         fileSpec,
                         XMakeAttributes.exclude,
-                        XMakeElements.itemGroup);
+                        XMakeElements.itemGroup,
+                        excludeLocation.LocationString);
             }
         }
 
@@ -448,7 +460,8 @@ private static void ThrowDriveEnumerationExceptionWithLoggingService(IElementLoc
                 DriveEnumeratingWildcardMessageResourceName,
                 filespecUnescaped,
                 XMakeAttributes.include,
-                XMakeElements.itemGroup);
+                XMakeElements.itemGroup,
+                includeLocation.LocationString);
         }
 
         private static void ThrowDriveEnumerationExceptionWithEvaluationLoggingContext(IElementLocation importLocation, IElementLocation includeLocation, IElementLocation excludeLocation, string filespecUnescaped, string fileSpec, bool excludeFileSpecIsEmpty)
@@ -460,25 +473,28 @@ private static void ThrowDriveEnumerationExceptionWithEvaluationLoggingContext(I
                     DriveEnumeratingWildcardMessageResourceName,
                     filespecUnescaped,
                     XMakeAttributes.project,
-                    XMakeElements.import);
+                    XMakeElements.import,
+                    importLocation.LocationString);
             }
-            else if (excludeFileSpecIsEmpty)
+            else if (excludeFileSpecIsEmpty && includeLocation != null)
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     includeLocation,
                     DriveEnumeratingWildcardMessageResourceName,
                     fileSpec,
                     XMakeAttributes.include,
-                    XMakeElements.itemGroup);
+                    XMakeElements.itemGroup,
+                    includeLocation.LocationString);
             }
-            else
+            else if (excludeLocation != null)
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     excludeLocation,
                     DriveEnumeratingWildcardMessageResourceName,
                     fileSpec,
                     XMakeAttributes.exclude,
-                    XMakeElements.itemGroup);
+                    XMakeElements.itemGroup,
+                    excludeLocation.LocationString);
             }
         }
 
diff --git a/src/Build/Xml/XmlReaderExtension.cs b/src/Build/Xml/XmlReaderExtension.cs
index 56b29744664..8cfd9b6497e 100644
--- a/src/Build/Xml/XmlReaderExtension.cs
+++ b/src/Build/Xml/XmlReaderExtension.cs
@@ -40,6 +40,12 @@ private XmlReaderExtension(string file, bool loadAsReadOnly)
                 _streamReader = new StreamReader(_stream, s_utf8NoBom, detectEncodingFromByteOrderMarks: true);
                 Encoding detectedEncoding;
 
+#if RUNTIME_TYPE_NETCORE
+                // Ensure that all Windows codepages are available.
+                // Safe to call multiple times per https://docs.microsoft.com/en-us/dotnet/api/system.text.encoding.registerprovider
+                Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);
+#endif
+
                 // The XmlDocumentWithWithLocation class relies on the reader's BaseURI property to be set,
                 // thus we pass the document's file path to the appropriate xml reader constructor.
                 Reader = GetXmlReader(file, _streamReader, loadAsReadOnly, out detectedEncoding);
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index e238270ae6a..6696e3861ba 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -21,7 +21,6 @@
     <FeatureAppDomain>true</FeatureAppDomain>
     <DefineConstants>$(DefineConstants);FEATURE_ASPNET_COMPILER</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_ASSEMBLY_LOCATION</DefineConstants>
-    <DefineConstants>$(DefineConstants);FEATURE_COM_INTEROP</DefineConstants>
     <DefineConstants Condition="'$(MonoBuild)' != 'true'">$(DefineConstants);FEATURE_COMPILED_XSL</DefineConstants>
     <DefineConstants Condition="'$(MonoBuild)' != 'true'">$(DefineConstants);FEATURE_COMPILE_IN_TESTS</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_CONSTRAINED_EXECUTION</DefineConstants>
@@ -88,7 +87,6 @@
   <PropertyGroup Condition="'$(NetCoreBuild)'=='true'">
     <CompilerToolsDir>$([System.IO.Path]::Combine($(ToolPackagesDir)Microsoft.Net.Compilers, $(CompilerToolsVersion), "tools"))$([System.IO.Path]::DirectorySeparatorChar)</CompilerToolsDir>
     <DefineConstants>$(DefineConstants);FEATURE_ASSEMBLYLOADCONTEXT</DefineConstants>
-    <DefineConstants>$(DefineConstants);FEATURE_PROCESSSTARTINFO_ENVIRONMENT</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_RUNTIMEINFORMATION</DefineConstants>
     <DefineConstants>$(DefineConstants);USE_MSBUILD_DLL_EXTN</DefineConstants>
     <DefineConstants>$(DefineConstants);WORKAROUND_COREFX_19110</DefineConstants>
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index 2dbbe6d8ace..de6fe3137d5 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -55,6 +55,10 @@
     <PackageReference Include="xunit.core" />
     <PackageReference Include="xunit.assert" />
 
+    <!-- Force updated reference to this package because xunit and shouldly
+         are netstandard1.6 and transitively bring in an old reference -->
+    <PackageReference Include="System.Security.Cryptography.X509Certificates" />
+
     <PackageReference Include="Microsoft.DotNet.XUnitExtensions" />
 
     <!-- Don't localize unit test projects -->
diff --git a/src/Framework.UnitTests/Attribute_Tests.cs b/src/Framework.UnitTests/Attribute_Tests.cs
index 775aedc3dfa..f4badad23d1 100644
--- a/src/Framework.UnitTests/Attribute_Tests.cs
+++ b/src/Framework.UnitTests/Attribute_Tests.cs
@@ -67,9 +67,3 @@ internal static bool TestValue2
         }
     }
 }
-
-
-
-
-
-
diff --git a/src/Framework.UnitTests/BuildStartedEventArgs_Tests.cs b/src/Framework.UnitTests/BuildStartedEventArgs_Tests.cs
index d90cc0c30d2..1d3afacb3ba 100644
--- a/src/Framework.UnitTests/BuildStartedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/BuildStartedEventArgs_Tests.cs
@@ -58,4 +58,4 @@ public BuildStartedEventArgs2()
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
index da03486b433..b66f3a66b80 100644
--- a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
+++ b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
@@ -23,11 +23,6 @@
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
   </ItemGroup>
 
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
-    <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
-    <PackageReference Include="Microsoft.Win32.Registry" />
-  </ItemGroup>
-
   <ItemGroup>
     <Service Include="{82a7f48d-3b50-4b1e-b82e-3ada8210c358}" />
   </ItemGroup>
diff --git a/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs b/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
index 4971021b470..309efaccb98 100644
--- a/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
@@ -91,4 +91,4 @@ public ProjectStartedEventArgs2()
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Framework.UnitTests/TaskCommandLineEventArgs_Tests.cs b/src/Framework.UnitTests/TaskCommandLineEventArgs_Tests.cs
index 755f6b098b7..12cbc45dd39 100644
--- a/src/Framework.UnitTests/TaskCommandLineEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/TaskCommandLineEventArgs_Tests.cs
@@ -42,4 +42,4 @@ public TaskCommandLineEventArgs2() : base()
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Framework/BuildStatusEventArgs.cs b/src/Framework/BuildStatusEventArgs.cs
index 440a0935f50..ef6146a6c6b 100644
--- a/src/Framework/BuildStatusEventArgs.cs
+++ b/src/Framework/BuildStatusEventArgs.cs
@@ -90,4 +90,3 @@ params object[] messageArgs
         }
     }
 }
-
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index 3ebe0b75ef8..ca49aaf226a 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -24,9 +24,10 @@ internal enum ChangeWaveConversionState
     /// For dev docs: https://github.com/dotnet/msbuild/blob/master/documentation/wiki/ChangeWaves-Dev.md
     internal class ChangeWaves
     {
-        internal static readonly Version Wave16_10 = new Version(16, 10);
         internal static readonly Version Wave17_0 = new Version(17, 0);
-        internal static readonly Version[] AllWaves = { Wave16_10, Wave17_0 };
+        internal static readonly Version Wave17_2 = new Version(17, 2);
+        internal static readonly Version Wave17_4 = new Version(17, 4);
+        internal static readonly Version[] AllWaves = { Wave17_0, Wave17_2, Wave17_4 };
 
         /// <summary>
         /// Special value indicating that all features behind all Change Waves should be enabled.
diff --git a/src/Framework/IBuildEngine5.cs b/src/Framework/IBuildEngine5.cs
index b03ab63c28e..3bb99e30e6e 100644
--- a/src/Framework/IBuildEngine5.cs
+++ b/src/Framework/IBuildEngine5.cs
@@ -19,4 +19,4 @@ public interface IBuildEngine5 : IBuildEngine4
         /// <param name="properties">The event properties.</param>
         void LogTelemetry(string eventName, IDictionary<string, string> properties);
     }
-}
\ No newline at end of file
+}
diff --git a/src/Framework/ITaskFactory2.cs b/src/Framework/ITaskFactory2.cs
index 882d7b1648d..c498b989789 100644
--- a/src/Framework/ITaskFactory2.cs
+++ b/src/Framework/ITaskFactory2.cs
@@ -60,4 +60,4 @@ public interface ITaskFactory2 : ITaskFactory
         /// </returns>
         ITask CreateTask(IBuildEngine taskFactoryLoggingHost, IDictionary<string, string> taskIdentityParameters);
     }
-}
\ No newline at end of file
+}
diff --git a/src/Framework/ITaskItemExtensions.cs b/src/Framework/ITaskItemExtensions.cs
index 589c483ac1c..090a95eeb07 100644
--- a/src/Framework/ITaskItemExtensions.cs
+++ b/src/Framework/ITaskItemExtensions.cs
@@ -64,4 +64,4 @@ public static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(this I
             return list;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index b4e335f7849..f2f4cc9070f 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -599,6 +599,30 @@ public void OutOfProcSdkResolverServiceRequestSdkPathFromMainNodeStop(int submis
             WriteEvent(80, submissionId, sdkName, solutionPath, projectPath, success, wasResultCached);
         }
 
+        [Event(81, Keywords = Keywords.All)]
+        public void SdkResolverServiceFindResolversManifestsStart()
+        {
+            WriteEvent(81);
+        }
+
+        [Event(82, Keywords = Keywords.All)]
+        public void SdkResolverServiceFindResolversManifestsStop(int resolverManifestCount)
+        {
+            WriteEvent(82, resolverManifestCount);
+        }
+
+        [Event(83, Keywords = Keywords.All)]
+        public void SdkResolverServiceLoadResolversStart()
+        {
+            WriteEvent(83);
+        }
+
+        [Event(84, Keywords = Keywords.All)]
+        public void SdkResolverServiceLoadResolversStop(string manifestName, int resolverCount)
+        {
+            WriteEvent(84, manifestName, resolverCount);
+        }
+
         #endregion
     }
 }
diff --git a/src/Framework/Microsoft.Build.Framework.csproj b/src/Framework/Microsoft.Build.Framework.csproj
index 9648dd397a8..e24a13ff151 100644
--- a/src/Framework/Microsoft.Build.Framework.csproj
+++ b/src/Framework/Microsoft.Build.Framework.csproj
@@ -16,8 +16,6 @@
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
     <PackageReference Include="System.Security.Permissions" />
-    <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
-    <PackageReference Include="Microsoft.Win32.Registry" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
diff --git a/src/Framework/Properties/AssemblyInfo.cs b/src/Framework/Properties/AssemblyInfo.cs
index 79b1e377c75..c4ac04d7e43 100644
--- a/src/Framework/Properties/AssemblyInfo.cs
+++ b/src/Framework/Properties/AssemblyInfo.cs
@@ -70,4 +70,3 @@
 
 [assembly: ComVisible(false)]
 [assembly: CLSCompliant(true)]
-
diff --git a/src/Framework/RunInMTAAttribute.cs b/src/Framework/RunInMTAAttribute.cs
index e2590108ec8..293694f7365 100644
--- a/src/Framework/RunInMTAAttribute.cs
+++ b/src/Framework/RunInMTAAttribute.cs
@@ -23,4 +23,4 @@ public RunInMTAAttribute()
             // do nothing
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Framework/RunInSTAAttribute.cs b/src/Framework/RunInSTAAttribute.cs
index 69750928db8..ad0653e8248 100644
--- a/src/Framework/RunInSTAAttribute.cs
+++ b/src/Framework/RunInSTAAttribute.cs
@@ -23,4 +23,4 @@ public RunInSTAAttribute()
             // do nothing
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
index 8220910cf74..9bb2da04989 100644
--- a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
+++ b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
@@ -48,6 +48,7 @@
   </Target>
 
   <Import Project="..\Package\GetBinPaths.targets" Condition="$(TargetFramework.StartsWith('net4'))"/>
+  <Import Project="..\Package\GetBinPaths.Arm64.targets" Condition="$(TargetFramework.StartsWith('net4'))"/>
 
   <Import Project="$(RepoRoot)eng\BootStrapMSBuild.targets" />
 
diff --git a/src/MSBuild/LogMessagePacket.cs b/src/MSBuild/LogMessagePacket.cs
index d5e60321b33..2e69e1f1e36 100644
--- a/src/MSBuild/LogMessagePacket.cs
+++ b/src/MSBuild/LogMessagePacket.cs
@@ -47,4 +47,4 @@ static internal INodePacket FactoryForDeserialization(ITranslator translator)
             return new LogMessagePacket(translator);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 2f12fb8c4c7..9ea8cc2fcf8 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -229,8 +229,9 @@
     <PackageReference Include="LargeAddressAware" PrivateAssets="All" />
   </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
-    <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
-    <PackageReference Include="Microsoft.Win32.Registry" />
+    <!-- Bump these to the latest version despite transitive references to older -->
+    <PackageReference Include="System.Private.Uri" />
+    <PackageReference Include="System.Runtime" />
   </ItemGroup>
   <ItemGroup>
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 342bd0b7d5d..132326e7230 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -6078,6 +6078,7 @@ elementFormDefault="qualified">
                     <xs:attribute name="RetryDelayMilliseconds" />
                     <xs:attribute name="SkipUnchangedFiles" />
                     <xs:attribute name="SourceUrl" use="required" />
+                    <xs:attribute name="Timeout" />
                 </xs:extension>
             </xs:complexContent>
         </xs:complexType>
diff --git a/src/MSBuild/ProjectSchemaValidationHandler.cs b/src/MSBuild/ProjectSchemaValidationHandler.cs
index a2c4ff0395b..3f6b1cce5f7 100644
--- a/src/MSBuild/ProjectSchemaValidationHandler.cs
+++ b/src/MSBuild/ProjectSchemaValidationHandler.cs
@@ -305,4 +305,4 @@ private void OnSchemaValidationError(object sender, ValidationEventArgs args)
         #endregion // Event Handlers
     }
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 186d984470f..42251449d2a 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -629,20 +629,6 @@ string[] commandLine
                         Environment.SetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE", "1");
                     }
 
-                    // Honor the low priority flag, we place our selves below normal priority and let sub processes inherit
-                    // that priority. Idle priority would prevent the build from proceeding as the user does normal actions.
-                    try
-                    {
-                        if (lowPriority && Process.GetCurrentProcess().PriorityClass != ProcessPriorityClass.Idle)
-                        {
-                            Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.BelowNormal;
-                        }
-                    }
-                    // We avoid increasing priority because that causes failures on mac/linux, but there is no good way to
-                    // verify that a particular priority is lower than "BelowNormal." If the error appears, ignore it and
-                    // leave priority where it was.
-                    catch (Win32Exception) { }
-
                     DateTime t1 = DateTime.Now;
 
                     // If the primary file passed to MSBuild is a .binlog file, play it back into passed loggers
@@ -2091,6 +2077,27 @@ string commandLine
                 DisplayCopyrightMessage();
             }
 
+
+            // Idle priority would prevent the build from proceeding as the user does normal actions.
+            // This switch is processed early to capture both the command line case (main node should
+            // also be low priority) and the Visual Studio case in which the main node starts and stays
+            // at normal priority (not through XMake.cs) but worker nodes still need to honor this switch.
+            if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.LowPriority))
+            {
+                lowPriority = ProcessBooleanSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.LowPriority], defaultValue: true, resourceName: "InvalidLowPriorityValue");
+            }
+            try
+            {
+                if (lowPriority && Process.GetCurrentProcess().PriorityClass != ProcessPriorityClass.Idle)
+                {
+                    Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.BelowNormal;
+                }
+            }
+            // We avoid increasing priority because that causes failures on mac/linux, but there is no good way to
+            // verify that a particular priority is lower than "BelowNormal." If the error appears, ignore it and
+            // leave priority where it was.
+            catch (Win32Exception) { }
+
             // if help switch is set (regardless of switch errors), show the help message and ignore the other switches
             if (commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.Help])
             {
@@ -2098,7 +2105,7 @@ string commandLine
             }
             else if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.NodeMode))
             {
-                StartLocalNode(commandLineSwitches);
+                StartLocalNode(commandLineSwitches, lowPriority);
             }
             else
             {
@@ -2236,11 +2243,6 @@ string commandLine
                         graphBuild = ProcessGraphBuildSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GraphBuild]);
                     }
 
-                    if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.LowPriority))
-                    {
-                        lowPriority = ProcessBooleanSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.LowPriority], defaultValue: true, resourceName: "InvalidLowPriorityValue");
-                    }
-
                     inputResultsCaches = ProcessInputResultsCaches(commandLineSwitches);
 
                     outputResultsCache = ProcessOutputResultsCache(commandLineSwitches);
@@ -2580,7 +2582,7 @@ internal static ProfilerLogger ProcessProfileEvaluationSwitch(string[] parameter
         /// Uses the input from thinNodeMode switch to start a local node server
         /// </summary>
         /// <param name="commandLineSwitches"></param>
-        private static void StartLocalNode(CommandLineSwitches commandLineSwitches)
+        private static void StartLocalNode(CommandLineSwitches commandLineSwitches, bool lowpriority)
         {
             string[] input = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeMode];
             int nodeModeNumber = 0;
@@ -2608,22 +2610,22 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches)
             {
                 Exception nodeException = null;
                 NodeEngineShutdownReason shutdownReason = NodeEngineShutdownReason.Error;
+
                 // normal OOP node case
                 if (nodeModeNumber == 1)
                 {
-                    OutOfProcNode node = new OutOfProcNode();
-
                     // If FEATURE_NODE_REUSE is OFF, just validates that the switch is OK, and always returns False
                     bool nodeReuse = ProcessNodeReuseSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeReuse]);
-                    string[] lowPriorityInput = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.LowPriority];
-                    bool lowpriority = lowPriorityInput.Length > 0 && lowPriorityInput[0].Equals("true");
-
+                    OutOfProcNode node = new OutOfProcNode();
                     shutdownReason = node.Run(nodeReuse, lowpriority, out nodeException);
 
                     FileUtilities.ClearCacheDirectory();
                 }
                 else if (nodeModeNumber == 2)
                 {
+                    // TaskHost nodes don't need to worry about node reuse or low priority. Node reuse is always off, and TaskHosts
+                    // receive a connection immediately after being launched and shut down as soon as their work is over, so
+                    // whatever our priority is is correct.
                     OutOfProcTaskHostNode node = new OutOfProcTaskHostNode();
                     shutdownReason = node.Run(out nodeException);
                 }
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 808d572d30a..d2164c5be46 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -52,7 +52,7 @@
           <bindingRedirect oldVersion="0.0.0.0-99.9.9.9" newVersion="6.0.0.0" />
           <codeBase version="6.0.0.0" href="..\Microsoft.IO.Redist.dll"/>
         </dependentAssembly>
-        
+
         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -78,8 +78,8 @@
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
         <dependentAssembly>
           <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
-          <codeBase version="5.0.0.0" href="..\System.Collections.Immutable.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
+          <codeBase version="6.0.0.0" href="..\System.Collections.Immutable.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -93,8 +93,8 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.0.0.0" newVersion="4.0.0.0" />
-          <codeBase version="4.0.0.0" href="..\System.Resources.Extensions.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
+          <codeBase version="6.0.0.0" href="..\System.Resources.Extensions.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 915c11c69f0..3f5038e8ede 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -58,7 +58,7 @@
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
         <dependentAssembly>
           <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -70,7 +70,7 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.0.0.0" newVersion="4.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index e7dba840e1a..beca5404f56 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -215,8 +215,4 @@
     <PackageReference Include="PdbGit" /> -->
     <PackageReference Include="LargeAddressAware" PrivateAssets="All" />
   </ItemGroup>
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
-    <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
-    <PackageReference Include="Microsoft.Win32.Registry" />
-  </ItemGroup>
 </Project>
diff --git a/src/MSBuildTaskHost/OutOfProcTaskHost.cs b/src/MSBuildTaskHost/OutOfProcTaskHost.cs
index c7afd19c8db..4f4b2ab02da 100644
--- a/src/MSBuildTaskHost/OutOfProcTaskHost.cs
+++ b/src/MSBuildTaskHost/OutOfProcTaskHost.cs
@@ -68,7 +68,7 @@ internal enum ExitType
         [MTAThread]
         public static int Main()
         {
-            int exitCode = (Execute() == ExitType.Success ? 0 : 1);
+            int exitCode = Execute() == ExitType.Success ? 0 : 1;
             return exitCode;
         }
 
diff --git a/src/Package/GetBinPaths.Arm64.targets b/src/Package/GetBinPaths.Arm64.targets
new file mode 100644
index 00000000000..c5ad5e64b8f
--- /dev/null
+++ b/src/Package/GetBinPaths.Arm64.targets
@@ -0,0 +1,36 @@
+﻿<Project>
+
+  <ItemGroup>
+    <!-- Set up items to build projects where the Platform is set to x64, when we need the x64 versions of the files.
+         We have to treat these separately from normal project references, as the AssignProjectConfiguration task would overwrite
+         the SetPlatform item metadata if they were ProjectReferences.
+    -->
+    <Arm64ProjectReference Include="$(MSBuildThisFileDirectory)\..\MSBuild\MSBuild.csproj"
+                         SetPlatform="Platform=arm64"
+                         SetTargetFramework="TargetFramework=$(FullFrameworkTFM)"
+                         OutputItemType="MSBuildArm64ResolvedProjectReferencePath" />
+
+    <ProjectReference Include="$(MSBuildThisFileDirectory)\..\Framework\Microsoft.Build.Framework.csproj"
+                      Private="false"
+                      ReferenceOutputAssembly="false"
+                      OutputItemType="FrameworkResolvedProjectReferencePath" />
+  </ItemGroup>
+
+  <Target Name="SetBinPathsArm64" DependsOnTargets="ResolveProjectReferences">
+    <MSBuild
+        Projects="@(Arm64ProjectReference)"
+        BuildInParallel="$(BuildInParallel)"
+        Properties="Configuration=$(Configuration); %(Arm64ProjectReference.SetPlatform); %(Arm64ProjectReference.SetTargetFramework)"
+        RemoveProperties="%(Arm64ProjectReference.GlobalPropertiesToRemove)">
+
+      <Output TaskParameter="TargetOutputs" ItemName="%(Arm64ProjectReference.OutputItemType)" />
+    </MSBuild>
+    
+    <PropertyGroup>
+      <FrameworkBinPath>@(FrameworkResolvedProjectReferencePath->'%(RootDir)%(Directory)')</FrameworkBinPath>
+      <Arm64BinPath>@(MSBuildArm64ResolvedProjectReferencePath->'%(RootDir)%(Directory)')</Arm64BinPath>
+    </PropertyGroup>
+  </Target>
+
+
+</Project>
diff --git a/src/Package/GetBinPaths.targets b/src/Package/GetBinPaths.targets
index b6254cc0d1c..dc99cabb70d 100644
--- a/src/Package/GetBinPaths.targets
+++ b/src/Package/GetBinPaths.targets
@@ -36,11 +36,6 @@
                          SetPlatform="Platform=x64"
                          OutputItemType="MSBuildTaskHostX64ResolvedProjectReferencePath"
                          GlobalPropertiesToRemove="TargetFramework" />
-
-    <Arm64ProjectReference Include="$(MSBuildThisFileDirectory)\..\MSBuild\MSBuild.csproj"
-                         SetPlatform="Platform=arm64"
-                         SetTargetFramework="TargetFramework=$(FullFrameworkTFM)"
-                         OutputItemType="MSBuildArm64ResolvedProjectReferencePath" />
   </ItemGroup>
 
   <Target Name="SetBinPaths" DependsOnTargets="ResolveProjectReferences">
@@ -52,24 +47,13 @@
 
       <Output TaskParameter="TargetOutputs" ItemName="%(X64ProjectReference.OutputItemType)" />
     </MSBuild>
-
-    <MSBuild
-        Projects="@(Arm64ProjectReference)"
-        BuildInParallel="$(BuildInParallel)"
-        Properties="Configuration=$(Configuration); %(Arm64ProjectReference.SetPlatform); %(Arm64ProjectReference.SetTargetFramework)"
-        RemoveProperties="%(Arm64ProjectReference.GlobalPropertiesToRemove)">
-
-      <Output TaskParameter="TargetOutputs" ItemName="%(Arm64ProjectReference.OutputItemType)" />
-    </MSBuild>
     
     <PropertyGroup>
       <X86BinPath>@(MSBuildResolvedProjectReferencePath->'%(RootDir)%(Directory)')</X86BinPath>
       <X64BinPath>@(MSBuildX64ResolvedProjectReferencePath->'%(RootDir)%(Directory)')</X64BinPath>
-      <Arm64BinPath>@(MSBuildArm64ResolvedProjectReferencePath->'%(RootDir)%(Directory)')</Arm64BinPath>
       <FrameworkBinPath>@(FrameworkResolvedProjectReferencePath->'%(RootDir)%(Directory)')</FrameworkBinPath>
       <MSBuildTaskHostBinPath>@(MSBuildTaskHostResolvedProjectReferencePath->'%(RootDir)%(Directory)')</MSBuildTaskHostBinPath>
       <MSBuildTaskHostX64BinPath>@(MSBuildTaskHostX64ResolvedProjectReferencePath->'%(RootDir)%(Directory)')</MSBuildTaskHostX64BinPath>
-      <MSBuildTaskHostArm64BinPath>@(MSBuildTaskHostArm64ResolvedProjectReferencePath->'%(RootDir)%(Directory)')</MSBuildTaskHostArm64BinPath>
       <MSBuildConversionBinPath>@(MSBuildConversionResolvedProjectReferencePath->'%(RootDir)%(Directory)')</MSBuildConversionBinPath>
     </PropertyGroup>
   </Target>
diff --git a/src/Package/MSBuild.VSSetup.Arm64/MSBuild.VSSetup.Arm64.csproj b/src/Package/MSBuild.VSSetup.Arm64/MSBuild.VSSetup.Arm64.csproj
new file mode 100644
index 00000000000..297958b416d
--- /dev/null
+++ b/src/Package/MSBuild.VSSetup.Arm64/MSBuild.VSSetup.Arm64.csproj
@@ -0,0 +1,36 @@
+﻿<!-- Copyright (c)  Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information. -->
+<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <TargetFramework>$(FullFrameworkTFM)</TargetFramework>
+    <!-- VS Insertion -->
+    <TargetVsixContainerName>Microsoft.Build.Arm64.vsix</TargetVsixContainerName>
+    <VisualStudioInsertionComponent>Microsoft.Build.Arm64</VisualStudioInsertionComponent>
+    <ShouldSkipProject>false</ShouldSkipProject>
+    <ShouldSkipProject Condition="'$(MonoBuild)' == 'true' or '$(MSBuildRuntimeType)' != 'Full'">true</ShouldSkipProject>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <ProjectReference Include="..\..\Build\Microsoft.Build.csproj" PrivateAssets="All" />
+  </ItemGroup>
+
+  <ItemGroup>
+    <SwrProperty Include="ThirdPartyNotice=$(ThirdPartyNotice)" />
+    <SwrProperty Include="SourceDir=$(RepoRoot)\src\" />
+
+    <!-- Only add the swr file when building on full framework msbuild, otherwise,
+    this triggers a build of the swixproj, which is not supported in core msbuild. -->
+    <SwrFile Include="files.arm64.swr" Condition=" '$(MSBuildRuntimeType)' == 'Full' " />
+  </ItemGroup>
+
+  <Import Project="..\GetBinPaths.Arm64.targets" Condition="!$(ShouldSkipProject)" />
+
+  <Target Name="SetVsixProperties" BeforeTargets="Build" DependsOnTargets="SetBinPathsArm64" Condition="!$(ShouldSkipProject)">
+    <ItemGroup>
+      <SwrProperty Include="Version=$(VsixVersion)" />
+      <SwrProperty Include="FrameworkBinPath=$(FrameworkBinPath)" />
+      <SwrProperty Include="Arm64BinPath=$(Arm64BinPath)" />
+    </ItemGroup>
+  </Target>
+
+  <Import Project="$(RepoRoot)eng\ProducesNoOutput.Settings.props" Condition="$(ShouldSkipProject)" />
+</Project>
diff --git a/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr b/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
new file mode 100644
index 00000000000..37d86a19b97
--- /dev/null
+++ b/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
@@ -0,0 +1,74 @@
+use vs
+
+package name=Microsoft.Build.Arm64
+        version=$(Version)
+        vs.package.machineArch=arm64
+        vs.package.language=neutral
+
+vs.relatedProcessFiles
+  vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\arm64\Microsoft.Build.Tasks.Core.dll"
+
+folder InstallDir:\MSBuild\Current\Bin\arm64
+  file source=$(Arm64BinPath)MSBuild.exe vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)MSBuild.exe.config
+
+  file source=$(FrameworkBinPath)x64\Microsoft.Build.Framework.tlb
+  file source=$(Arm64BinPath)Microsoft.Build.Tasks.Core.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)Microsoft.Common.CurrentVersion.targets
+  file source=$(Arm64BinPath)Microsoft.Common.CrossTargeting.targets
+  file source=$(Arm64BinPath)Microsoft.Common.overridetasks
+  file source=$(Arm64BinPath)Microsoft.Common.targets
+  file source=$(Arm64BinPath)Microsoft.Common.tasks
+  file source=$(Arm64BinPath)Microsoft.Managed.targets
+  file source=$(Arm64BinPath)Microsoft.Managed.Before.targets
+  file source=$(Arm64BinPath)Microsoft.Managed.After.targets
+  file source=$(Arm64BinPath)Microsoft.CSharp.CurrentVersion.targets
+  file source=$(Arm64BinPath)Microsoft.CSharp.CrossTargeting.targets
+  file source=$(Arm64BinPath)Microsoft.CSharp.targets
+  file source=$(Arm64BinPath)Microsoft.Net.props
+  file source=$(Arm64BinPath)Microsoft.NetFramework.CurrentVersion.props
+  file source=$(Arm64BinPath)Microsoft.NetFramework.CurrentVersion.targets
+  file source=$(Arm64BinPath)Microsoft.NetFramework.props
+  file source=$(Arm64BinPath)Microsoft.NetFramework.targets
+  file source=$(Arm64BinPath)Microsoft.VisualBasic.CurrentVersion.targets
+  file source=$(Arm64BinPath)Microsoft.VisualBasic.CrossTargeting.targets
+  file source=$(Arm64BinPath)Microsoft.VisualBasic.targets
+  file source=$(Arm64BinPath)MSBuild.rsp
+  file source=$(Arm64BinPath)Workflow.targets
+  file source=$(Arm64BinPath)Workflow.VisualBasic.targets
+  file source=$(Arm64BinPath)Microsoft.Xaml.targets
+  file source=$(Arm64BinPath)Microsoft.Data.Entity.targets
+  file source=$(Arm64BinPath)Microsoft.ServiceModel.targets
+  file source=$(Arm64BinPath)Microsoft.WinFx.targets
+  file source=$(Arm64BinPath)Microsoft.WorkflowBuildExtensions.targets
+
+folder InstallDir:\MSBuild\Current\Bin\arm64\MSBuild
+  file source=$(Arm64BinPath)\MSBuild\Microsoft.Build.Core.xsd
+  file source=$(Arm64BinPath)\MSBuild\Microsoft.Build.CommonTypes.xsd
+
+folder InstallDir:\MSBuild\Current\Bin\arm64\cs
+  file source=$(Arm64BinPath)cs\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\de
+  file source=$(Arm64BinPath)de\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\es
+  file source=$(Arm64BinPath)es\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\fr
+  file source=$(Arm64BinPath)fr\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\it
+  file source=$(Arm64BinPath)it\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\ja
+  file source=$(Arm64BinPath)ja\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\ko
+  file source=$(Arm64BinPath)ko\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\pl
+  file source=$(Arm64BinPath)pl\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\pt-BR
+  file source=$(Arm64BinPath)pt-BR\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\ru
+  file source=$(Arm64BinPath)ru\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\tr
+  file source=$(Arm64BinPath)tr\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\zh-Hans
+  file source=$(Arm64BinPath)zh-Hans\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\zh-Hant
+  file source=$(Arm64BinPath)zh-Hant\MSBuild.resources.dll vs.file.ngenArchitecture=all
\ No newline at end of file
diff --git a/src/Package/MSBuild.VSSetup/MSBuild.VSSetup.csproj b/src/Package/MSBuild.VSSetup/MSBuild.VSSetup.csproj
index d28478dfa1b..f3b3f9d2431 100644
--- a/src/Package/MSBuild.VSSetup/MSBuild.VSSetup.csproj
+++ b/src/Package/MSBuild.VSSetup/MSBuild.VSSetup.csproj
@@ -1,4 +1,4 @@
-﻿<!-- Copyright (c)  Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information. -->
+<!-- Copyright (c)  Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information. -->
 <Project Sdk="Microsoft.NET.Sdk">
   <PropertyGroup>
     <TargetFramework>$(FullFrameworkTFM)</TargetFramework>
@@ -20,7 +20,7 @@
 
     <!-- Only add the swr file when building on full framework msbuild, otherwise,
     this triggers a build of the swixproj, which is not supported in core msbuild. -->
-    <SwrFile Include="*.swr" Condition=" '$(MSBuildRuntimeType)' == 'Full' " />
+    <SwrFile Include="files.swr" Condition=" '$(MSBuildRuntimeType)' == 'Full' " />
   </ItemGroup>
 
   <!-- GetBinPaths depends on GetBuildVersion which does not get imported if ProducesNoOutput.Settings.props is imported-->
@@ -34,11 +34,9 @@
       <SwrProperty Include="Version=$(VsixVersion)" />
       <SwrProperty Include="X86BinPath=$(X86BinPath)" />
       <SwrProperty Include="X64BinPath=$(X64BinPath)" />
-      <SwrProperty Include="Arm64BinPath=$(Arm64BinPath)" />
       <SwrProperty Include="FrameworkBinPath=$(FrameworkBinPath)" />
       <SwrProperty Include="TaskHostBinPath=$(MSBuildTaskHostBinPath)" />
       <SwrProperty Include="TaskHostX64BinPath=$(MSBuildTaskHostX64BinPath)" />
-      <SwrProperty Include="TaskHostArm64BinPath=$(MSBuildTaskHostArm64BinPath)" />
       <SwrProperty Include="MSBuildConversionBinPath=$(MSBuildConversionBinPath)" />
     </ItemGroup>
   </Target>
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 35e47db3ab7..793a3d5be1c 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -7,6 +7,7 @@ package name=Microsoft.Build
 
 vs.dependencies
   vs.dependency id=Microsoft.Build.UnGAC
+  vs.dependency id=Microsoft.Build.Arm64
   vs.dependency id=Microsoft.VisualStudio.PackageGroup.NuGet
 
 vs.relatedProcessFiles
@@ -18,7 +19,6 @@ vs.relatedProcessFiles
   vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\amd64\Microsoft.Build.Framework.dll"
   vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\amd64\Microsoft.Build.Tasks.Core.dll"
   vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\amd64\Microsoft.Build.Utilities.Core.dll"
-  vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\arm64\Microsoft.Build.Tasks.Core.dll"
 
 folder InstallDir:\MSBuild\Current
   file source=$(X86BinPath)Microsoft.Common.props
@@ -309,70 +309,6 @@ folder InstallDir:\MSBuild\Current\Bin\amd64\zh-Hant
   file source=$(X64BinPath)zh-Hant\MSBuild.resources.dll vs.file.ngenArchitecture=all
   file source=$(TaskHostX64BinPath)zh-Hant\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
 
-folder InstallDir:\MSBuild\Current\Bin\arm64
-  file source=$(Arm64BinPath)MSBuild.exe vs.file.ngenArchitecture=x64
-  file source=$(Arm64BinPath)MSBuild.exe.config
-
-  file source=$(X86BinPath)Microsoft.Build.Tasks.Core.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)Microsoft.Common.CurrentVersion.targets
-  file source=$(X86BinPath)Microsoft.Common.CrossTargeting.targets
-  file source=$(X86BinPath)Microsoft.Common.overridetasks
-  file source=$(X86BinPath)Microsoft.Common.targets
-  file source=$(X86BinPath)Microsoft.Common.tasks
-  file source=$(X86BinPath)Microsoft.Managed.targets
-  file source=$(X86BinPath)Microsoft.Managed.Before.targets
-  file source=$(X86BinPath)Microsoft.Managed.After.targets
-  file source=$(X86BinPath)Microsoft.CSharp.CurrentVersion.targets
-  file source=$(X86BinPath)Microsoft.CSharp.CrossTargeting.targets
-  file source=$(X86BinPath)Microsoft.CSharp.targets
-  file source=$(X86BinPath)Microsoft.Net.props
-  file source=$(X86BinPath)Microsoft.NetFramework.CurrentVersion.props
-  file source=$(X86BinPath)Microsoft.NetFramework.CurrentVersion.targets
-  file source=$(X86BinPath)Microsoft.NetFramework.props
-  file source=$(X86BinPath)Microsoft.NetFramework.targets
-  file source=$(X86BinPath)Microsoft.VisualBasic.CurrentVersion.targets
-  file source=$(X86BinPath)Microsoft.VisualBasic.CrossTargeting.targets
-  file source=$(X86BinPath)Microsoft.VisualBasic.targets
-  file source=$(X86BinPath)MSBuild.rsp
-  file source=$(X86BinPath)Workflow.targets
-  file source=$(X86BinPath)Workflow.VisualBasic.targets
-  file source=$(X86BinPath)Microsoft.Xaml.targets
-  file source=$(X86BinPath)Microsoft.Data.Entity.targets
-  file source=$(X86BinPath)Microsoft.ServiceModel.targets
-  file source=$(X86BinPath)Microsoft.WinFx.targets
-  file source=$(X86BinPath)Microsoft.WorkflowBuildExtensions.targets
-
-folder InstallDir:\MSBuild\Current\Bin\arm64\MSBuild
-  file source=$(X86BinPath)\MSBuild\Microsoft.Build.Core.xsd
-  file source=$(X86BinPath)\MSBuild\Microsoft.Build.CommonTypes.xsd
-
-folder InstallDir:\MSBuild\Current\Bin\arm64\cs
-  file source=$(Arm64BinPath)cs\MSBuild.resources.dll vs.file.ngenArchitecture=all
-folder InstallDir:\MSBuild\Current\Bin\arm64\de
-  file source=$(Arm64BinPath)de\MSBuild.resources.dll vs.file.ngenArchitecture=all
-folder InstallDir:\MSBuild\Current\Bin\arm64\es
-  file source=$(Arm64BinPath)es\MSBuild.resources.dll vs.file.ngenArchitecture=all
-folder InstallDir:\MSBuild\Current\Bin\arm64\fr
-  file source=$(Arm64BinPath)fr\MSBuild.resources.dll vs.file.ngenArchitecture=all
-folder InstallDir:\MSBuild\Current\Bin\arm64\it
-  file source=$(Arm64BinPath)it\MSBuild.resources.dll vs.file.ngenArchitecture=all
-folder InstallDir:\MSBuild\Current\Bin\arm64\ja
-  file source=$(Arm64BinPath)ja\MSBuild.resources.dll vs.file.ngenArchitecture=all
-folder InstallDir:\MSBuild\Current\Bin\arm64\ko
-  file source=$(Arm64BinPath)ko\MSBuild.resources.dll vs.file.ngenArchitecture=all
-folder InstallDir:\MSBuild\Current\Bin\arm64\pl
-  file source=$(Arm64BinPath)pl\MSBuild.resources.dll vs.file.ngenArchitecture=all
-folder InstallDir:\MSBuild\Current\Bin\arm64\pt-BR
-  file source=$(Arm64BinPath)pt-BR\MSBuild.resources.dll vs.file.ngenArchitecture=all
-folder InstallDir:\MSBuild\Current\Bin\arm64\ru
-  file source=$(Arm64BinPath)ru\MSBuild.resources.dll vs.file.ngenArchitecture=all
-folder InstallDir:\MSBuild\Current\Bin\arm64\tr
-  file source=$(Arm64BinPath)tr\MSBuild.resources.dll vs.file.ngenArchitecture=all
-folder InstallDir:\MSBuild\Current\Bin\arm64\zh-Hans
-  file source=$(Arm64BinPath)zh-Hans\MSBuild.resources.dll vs.file.ngenArchitecture=all
-folder InstallDir:\MSBuild\Current\Bin\arm64\zh-Hant
-  file source=$(Arm64BinPath)zh-Hant\MSBuild.resources.dll vs.file.ngenArchitecture=all
-
 folder InstallDir:\Common7\IDE\CommonExtensions\MSBuild
   file source=$(SourceDir)Package\MSBuild.VSSetup\MSBuild.clientenabledpkg
   file source=$(SourceDir)Framework\Microsoft.Build.Framework.pkgdef
diff --git a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
index 5bc6022778e..6df2b6a307f 100644
--- a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
+++ b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
@@ -1,11 +1,10 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
-#if FEATURE_WIN32_REGISTRY
 
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using Microsoft.Build.Tasks;
+using System.Runtime.Versioning;
 using Microsoft.Build.Utilities;
 using Microsoft.Win32;
 using ProcessorArchitecture = System.Reflection.ProcessorArchitecture;
@@ -41,6 +40,7 @@ namespace Microsoft.Build.Shared
     ///     {AssemblyFoldersSuffix} = [ PocketPC | SmartPhone | WindowsCE]\AssemblyFoldersEx
     ///
     /// </summary>
+    [SupportedOSPlatform("windows")]
     internal class AssemblyFoldersEx : IEnumerable<AssemblyFoldersExInfo>
     {
         /// <summary>
@@ -498,4 +498,3 @@ internal IEnumerable<string> UniqueDirectoryPaths
         }
     }
 }
-#endif
diff --git a/src/Shared/AssemblyFolders/Serialization/AssemblyFolderItem.cs b/src/Shared/AssemblyFolders/Serialization/AssemblyFolderItem.cs
index ede6de07772..5151c1ff447 100644
--- a/src/Shared/AssemblyFolders/Serialization/AssemblyFolderItem.cs
+++ b/src/Shared/AssemblyFolders/Serialization/AssemblyFolderItem.cs
@@ -21,4 +21,4 @@ internal class AssemblyFolderItem
         [DataMember(IsRequired = false, Order = 4)]
         internal string Platform { get; set; }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Shared/AssemblyNameExtension.cs b/src/Shared/AssemblyNameExtension.cs
index 9c5cf7136fb..90d1c081d5c 100644
--- a/src/Shared/AssemblyNameExtension.cs
+++ b/src/Shared/AssemblyNameExtension.cs
@@ -189,59 +189,22 @@ internal AssemblyNameExtension(ITranslator translator) : this()
         /// <returns></returns>
         internal static AssemblyNameExtension GetAssemblyNameEx(string path)
         {
-            AssemblyName assemblyName = null;
-#if !FEATURE_ASSEMBLYLOADCONTEXT
             try
             {
-                assemblyName = AssemblyName.GetAssemblyName(path);
+                return new AssemblyNameExtension(AssemblyName.GetAssemblyName(path));
             }
             catch (FileLoadException)
             {
                 // Its pretty hard to get here, you need an assembly that contains a valid reference
                 // to a dependent assembly that, in turn, throws a FileLoadException during GetAssemblyName.
                 // Still it happened once, with an older version of the CLR. 
-
-                // ...falling through and relying on the assemblyName == null behavior below...
             }
             catch (FileNotFoundException)
             {
                 // Its pretty hard to get here, also since we do a file existence check right before calling this method so it can only happen if the file got deleted between that check and this call.
             }
-#else
-            using (var stream = File.OpenRead(path))
-            using (var peFile = new PEReader(stream))
-            {
-                bool hasMetadata = false;
-                try
-                {
-                    // This can throw if the stream is too small, which means
-                    // the assembly doesn't have metadata.
-                    hasMetadata = peFile.HasMetadata;
-                }
-                finally
-                {
-                    // If the file does not contain PE metadata, throw BadImageFormatException to preserve
-                    // behavior from AssemblyName.GetAssemblyName(). RAR will deal with this correctly.
-                    if (!hasMetadata)
-                    {
-                        throw new BadImageFormatException(string.Format(CultureInfo.CurrentCulture,
-                            AssemblyResources.GetString("ResolveAssemblyReference.AssemblyDoesNotContainPEMetadata"),
-                            path));
-                    }
-                }
-
-                var metadataReader = peFile.GetMetadataReader();
-                var entry = metadataReader.GetAssemblyDefinition();
 
-                assemblyName = new AssemblyName();
-                assemblyName.Name = metadataReader.GetString(entry.Name);
-                assemblyName.Version = entry.Version;
-                assemblyName.CultureName = metadataReader.GetString(entry.Culture);
-                assemblyName.SetPublicKey(metadataReader.GetBlobBytes(entry.PublicKey));
-                assemblyName.Flags = (AssemblyNameFlags)(int)entry.Flags;
-            }
-#endif
-            return assemblyName == null ? null : new AssemblyNameExtension(assemblyName);
+            return null;
         }
 
         /// <summary>
diff --git a/src/Shared/BinaryTranslator.cs b/src/Shared/BinaryTranslator.cs
index b1540445884..73888fa88a0 100644
--- a/src/Shared/BinaryTranslator.cs
+++ b/src/Shared/BinaryTranslator.cs
@@ -1,4 +1,4 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
@@ -149,6 +149,26 @@ public void Translate(ref int value)
                 value = _reader.ReadInt32();
             }
 
+            /// <summary>
+            /// Translates an <see langword="int"/> array.
+            /// </summary>
+            /// <param name="array">The array to be translated.</param>
+            public void Translate(ref int[] array)
+            {
+                if (!TranslateNullable(array))
+                {
+                    return;
+                }
+
+                int count = _reader.ReadInt32();
+                array = new int[count];
+
+                for (int i = 0; i < count; i++)
+                {
+                    array[i] = _reader.ReadInt32();
+                }
+            }
+
             /// <summary>
             /// Translates a long.
             /// </summary>
@@ -811,6 +831,26 @@ public void Translate(ref int value)
                 _writer.Write(value);
             }
 
+            /// <summary>
+            /// Translates an <see langword="int"/> array.
+            /// </summary>
+            /// <param name="array">The array to be translated.</param>
+            public void Translate(ref int[] array)
+            {
+                if (!TranslateNullable(array))
+                {
+                    return;
+                }
+
+                int count = array.Length;
+                _writer.Write(count);
+
+                for (int i = 0; i < count; i++)
+                {
+                    _writer.Write(array[i]);
+                }
+            }
+
             /// <summary>
             /// Translates a long.
             /// </summary>
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index 2862be2a9d1..b2579ae8610 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -8,6 +8,7 @@
 using System.Collections.Generic;
 using System.Text.RegularExpressions;
 
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
 using System.Reflection;
 
@@ -525,48 +526,45 @@ public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath,
                 CurrentMSBuildConfigurationFile = string.Concat(currentMSBuildExePath, ".config");
                 MSBuildToolsDirectory32 = CurrentMSBuildToolsDirectory;
                 MSBuildToolsDirectory64 = CurrentMSBuildToolsDirectory;
+                MSBuildToolsDirectoryRoot = CurrentMSBuildToolsDirectory;
             }
 
             // We can't detect an environment, don't try to set other paths.
             if (mode == BuildEnvironmentMode.None || currentMSBuildExeFile == null || currentToolsDirectory == null)
                 return;
 
-            // Check to see if our current folder is 'amd64'
-            bool runningInAmd64 = string.Equals(currentToolsDirectory.Name, "amd64", StringComparison.OrdinalIgnoreCase);
-            bool runningInARM64 = string.Equals(currentToolsDirectory.Name, "arm64", StringComparison.OrdinalIgnoreCase);
-
             var msBuildExeName = currentMSBuildExeFile.Name;
-            var folderAbove = currentToolsDirectory.Parent?.FullName;
 
-            if (folderAbove != null)
+            if (mode == BuildEnvironmentMode.VisualStudio)
+            {
+                // In Visual Studio, the entry-point MSBuild.exe is often from an arch-specific subfolder
+                MSBuildToolsDirectoryRoot = NativeMethodsShared.ProcessorArchitecture switch
+                {
+                    NativeMethodsShared.ProcessorArchitectures.X86 => CurrentMSBuildToolsDirectory,
+                    NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorArchitectures.ARM64
+                        => currentToolsDirectory.Parent?.FullName,
+                    _ => throw new InternalErrorException("Unknown processor architecture " + NativeMethodsShared.ProcessorArchitecture),
+                };
+            }
+            else
+            {
+                // In the .NET SDK, there's one copy of MSBuild.dll and it's in the root folder.
+                MSBuildToolsDirectoryRoot = CurrentMSBuildToolsDirectory;
+            }
+
+            if (mode == BuildEnvironmentMode.VisualStudio && MSBuildToolsDirectoryRoot != null)
             {
                 // Calculate potential paths to other architecture MSBuild.exe
-                var potentialAmd64FromX86 = FileUtilities.CombinePaths(CurrentMSBuildToolsDirectory, "amd64", msBuildExeName);
-                var potentialARM64FromX86 = FileUtilities.CombinePaths(CurrentMSBuildToolsDirectory, "arm64", msBuildExeName);
-                var potentialX86FromAmd64 = Path.Combine(folderAbove, msBuildExeName);
+                var potentialAmd64FromX86 = FileUtilities.CombinePaths(MSBuildToolsDirectoryRoot, "amd64", msBuildExeName);
+                var potentialARM64FromX86 = FileUtilities.CombinePaths(MSBuildToolsDirectoryRoot, "arm64", msBuildExeName);
 
                 // Check for existence of an MSBuild file. Note this is not necessary in a VS installation where we always want to
                 // assume the correct layout.
                 var existsCheck = mode == BuildEnvironmentMode.VisualStudio ? new Func<string, bool>(_ => true) : File.Exists;
 
-                if ((runningInARM64 || runningInAmd64) && existsCheck(potentialX86FromAmd64))
-                {
-                    MSBuildToolsDirectory32 = folderAbove;
-                    MSBuildToolsDirectory64 = CurrentMSBuildToolsDirectory;
-                }
-                else if (!runningInAmd64 && !runningInARM64)
-                {
-                    MSBuildToolsDirectory32 = CurrentMSBuildToolsDirectory;
-
-                    if (existsCheck(potentialARM64FromX86) && NativeMethodsShared.ProcessorArchitecture == Framework.NativeMethods.ProcessorArchitectures.ARM64)
-                    {
-                        MSBuildToolsDirectory64 = Path.Combine(CurrentMSBuildToolsDirectory, "arm64");
-                    }
-                    else if (existsCheck(potentialAmd64FromX86))
-                    {
-                        MSBuildToolsDirectory64 = Path.Combine(CurrentMSBuildToolsDirectory, "amd64");
-                    }
-                }
+                MSBuildToolsDirectory32 = MSBuildToolsDirectoryRoot;
+                MSBuildToolsDirectory64 = Path.Combine(MSBuildToolsDirectoryRoot, "amd64");
+                MSBuildToolsDirectoryArm64 = File.Exists(potentialARM64FromX86) ? Path.Combine(MSBuildToolsDirectoryRoot, "arm64") : null;
             }
 
             MSBuildExtensionsPath = mode == BuildEnvironmentMode.VisualStudio
@@ -586,6 +584,11 @@ public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath,
         /// </summary>
         internal bool RunningInVisualStudio { get; }
 
+        /// <summary>
+        /// Path to the root of the MSBuild folder (in VS scenarios, <c>MSBuild\Current\bin</c>).
+        /// </summary>
+        internal string MSBuildToolsDirectoryRoot { get; }
+
         /// <summary>
         /// Path to the MSBuild 32-bit tools directory.
         /// </summary>
@@ -596,6 +599,12 @@ public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath,
         /// </summary>
         internal string MSBuildToolsDirectory64 { get; }
 
+        /// <summary>
+        /// Path to the ARM64 tools directory.
+        /// <see langword="null" /> if ARM64 tools are not installed.
+        /// </summary>
+        internal string MSBuildToolsDirectoryArm64 { get; }
+
         /// <summary>
         /// Path to the Sdks folder for this MSBuild instance.
         /// </summary>
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 670ba076324..73dcf6f5a93 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -68,6 +68,11 @@ internal enum HandshakeOptions
         /// Using the .NET Core/.NET 5.0+ runtime
         /// </summary>
         NET = 64,
+
+        /// <summary>
+        /// ARM64 process
+        /// </summary>
+        Arm64 = 128,
     }
 
     internal readonly struct Handshake
@@ -82,13 +87,17 @@ internal readonly struct Handshake
 
         internal Handshake(HandshakeOptions nodeType)
         {
+            const int handshakeVersion = (int)CommunicationsUtilities.handshakeVersion;
+
             // We currently use 7 bits of this 32-bit integer. Very old builds will instantly reject any handshake that does not start with F5 or 06; slightly old builds always lead with 00.
             // This indicates in the first byte that we are a modern build.
-            options = (int)nodeType | (((int)CommunicationsUtilities.handshakeVersion) << 24);
+            options = (int)nodeType | (handshakeVersion << 24);
+            CommunicationsUtilities.Trace("Building handshake for node type {0}, (version {1}): options {2}.", nodeType, handshakeVersion, options);
+
             string handshakeSalt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
             CommunicationsUtilities.Trace("Handshake salt is " + handshakeSalt);
-            string toolsDirectory = (nodeType & HandshakeOptions.X64) == HandshakeOptions.X64 ? BuildEnvironmentHelper.Instance.MSBuildToolsDirectory64 : BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32;
-            CommunicationsUtilities.Trace("Tools directory is " + toolsDirectory);
+            string toolsDirectory = BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryRoot;
+            CommunicationsUtilities.Trace("Tools directory root is " + toolsDirectory);
             salt = CommunicationsUtilities.GetHashCode(handshakeSalt + toolsDirectory);
             Version fileVersion = new Version(FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location).FileVersion);
             fileVersionMajor = fileVersion.Major;
@@ -144,6 +153,11 @@ static internal class CommunicationsUtilities
         /// </summary>
         private static bool s_trace = Traits.Instance.DebugNodeCommunication;
 
+        /// <summary>
+        /// Lock trace to ensure we are logging in serial fashion.
+        /// </summary>
+        private static readonly object s_traceLock = new();
+
         /// <summary>
         /// Place to dump trace
         /// </summary>
@@ -479,22 +493,22 @@ internal static async Task<int> ReadAsync(Stream stream, byte[] buffer, int byte
         /// <summary>
         /// Given the appropriate information, return the equivalent HandshakeOptions.
         /// </summary>
-        internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit = false, bool nodeReuse = false, bool lowPriority = false, IDictionary<string, string> taskHostParameters = null)
+        internal static HandshakeOptions GetHandshakeOptions(bool taskHost, string architectureFlagToSet = null, bool nodeReuse = false, bool lowPriority = false, IDictionary<string, string> taskHostParameters = null)
         {
             HandshakeOptions context = taskHost ? HandshakeOptions.TaskHost : HandshakeOptions.None;
 
             int clrVersion = 0;
 
-            // We don't know about the TaskHost. Figure it out.
+            // We don't know about the TaskHost.
             if (taskHost)
             {
-                // Take the current TaskHost context
+                // No parameters given, default to current
                 if (taskHostParameters == null)
                 {
                     clrVersion = typeof(bool).GetTypeInfo().Assembly.GetName().Version.Major;
-                    is64Bit = XMakeAttributes.GetCurrentMSBuildArchitecture().Equals(XMakeAttributes.MSBuildArchitectureValues.x64);
+                    architectureFlagToSet = XMakeAttributes.GetCurrentMSBuildArchitecture();
                 }
-                else
+                else // Figure out flags based on parameters given
                 {
                     ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.runtime, out string runtimeVersion), "Should always have an explicit runtime when we call this method.");
                     ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.architecture, out string architecture), "Should always have an explicit architecture when we call this method.");
@@ -502,7 +516,7 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit
                     if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr2, StringComparison.OrdinalIgnoreCase))
                     {
                         clrVersion = 2;
-                    } 
+                    }
                     else if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase))
                     {
                         clrVersion = 4;
@@ -516,13 +530,20 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit
                         ErrorUtilities.ThrowInternalErrorUnreachable();
                     }
 
-                    is64Bit = architecture.Equals(XMakeAttributes.MSBuildArchitectureValues.x64);
+                    architectureFlagToSet = architecture;
                 }
             }
 
-            if (is64Bit)
+            if (!string.IsNullOrEmpty(architectureFlagToSet))
             {
-                context |= HandshakeOptions.X64;
+                if (architectureFlagToSet.Equals(XMakeAttributes.MSBuildArchitectureValues.x64, StringComparison.OrdinalIgnoreCase))
+                {
+                    context |= HandshakeOptions.X64;
+                }
+                else if (architectureFlagToSet.Equals(XMakeAttributes.MSBuildArchitectureValues.arm64, StringComparison.OrdinalIgnoreCase))
+                {
+                    context |= HandshakeOptions.Arm64;
+                }
             }
 
             switch (clrVersion)
@@ -600,9 +621,11 @@ internal static void Trace(int nodeId, string format, params object[] args)
         {
             if (s_trace)
             {
-                if (s_debugDumpPath == null)
+                lock (s_traceLock)
                 {
-                    s_debugDumpPath =
+                    if (s_debugDumpPath == null)
+                    {
+                        s_debugDumpPath =
 #if CLR2COMPATIBILITY
                         Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
 #else
@@ -611,39 +634,43 @@ internal static void Trace(int nodeId, string format, params object[] args)
                             : Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
 #endif
 
-                    if (String.IsNullOrEmpty(s_debugDumpPath))
-                    {
-                        s_debugDumpPath = Path.GetTempPath();
-                    }
-                    else
-                    {
-                        Directory.CreateDirectory(s_debugDumpPath);
+                        if (String.IsNullOrEmpty(s_debugDumpPath))
+                        {
+                            s_debugDumpPath = Path.GetTempPath();
+                        }
+                        else
+                        {
+                            Directory.CreateDirectory(s_debugDumpPath);
+                        }
                     }
-                }
 
-                try
-                {
-                    string fileName = @"MSBuild_CommTrace_PID_{0}";
-                    if (nodeId != -1)
+                    try
                     {
-                        fileName += "_node_" + nodeId;
-                    }
+                        string fileName = @"MSBuild_CommTrace_PID_{0}";
+                        if (nodeId != -1)
+                        {
+                            fileName += "_node_" + nodeId;
+                        }
 
-                    fileName += ".txt";
+                        fileName += ".txt";
 
-                    using (StreamWriter file = FileUtilities.OpenWrite(String.Format(CultureInfo.CurrentCulture, Path.Combine(s_debugDumpPath, fileName), Process.GetCurrentProcess().Id, nodeId), append: true))
+                        using (StreamWriter file =
+                               FileUtilities.OpenWrite(String.Format(CultureInfo.CurrentCulture, Path.Combine(s_debugDumpPath, fileName), Process.GetCurrentProcess().Id, nodeId),
+                                   append: true))
+                        {
+                            string message = String.Format(CultureInfo.CurrentCulture, format, args);
+                            long now = DateTime.UtcNow.Ticks;
+                            float millisecondsSinceLastLog = (float)(now - s_lastLoggedTicks) / 10000L;
+                            s_lastLoggedTicks = now;
+                            file.WriteLine("{0} (TID {1}) {2,15} +{3,10}ms: {4}", Thread.CurrentThread.Name, Thread.CurrentThread.ManagedThreadId, now, millisecondsSinceLastLog,
+                                message);
+                        }
+                    }
+                    catch (IOException)
                     {
-                        string message = String.Format(CultureInfo.CurrentCulture, format, args);
-                        long now = DateTime.UtcNow.Ticks;
-                        float millisecondsSinceLastLog = (float)(now - s_lastLoggedTicks) / 10000L;
-                        s_lastLoggedTicks = now;
-                        file.WriteLine("{0} (TID {1}) {2,15} +{3,10}ms: {4}", Thread.CurrentThread.Name, Thread.CurrentThread.ManagedThreadId, now, millisecondsSinceLastLog, message);
+                        // Ignore
                     }
                 }
-                catch (IOException)
-                {
-                    // Ignore
-                }
             }
         }
 
diff --git a/src/Shared/FileDelegates.cs b/src/Shared/FileDelegates.cs
index c4e9db5ec78..f4f972ec636 100644
--- a/src/Shared/FileDelegates.cs
+++ b/src/Shared/FileDelegates.cs
@@ -55,4 +55,4 @@ namespace Microsoft.Build.Shared
     /// </summary>
     /// <param name="path">The path to create.</param>
     internal delegate FileStream FileCreate(string path);
-}
\ No newline at end of file
+}
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index e837e1435fe..1fb4dd23850 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -114,49 +114,28 @@ internal FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemE
                 ? getFileSystemEntries
                 : (type, path, pattern, directory, stripProjectDirectory) =>
                 {
-                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10))
+                    // Always hit the filesystem with "*" pattern, cache the results, and do the filtering here.
+                    string cacheKey = type switch
                     {
-                        // New behavior:
-                        // Always hit the filesystem with "*" pattern, cache the results, and do the filtering here.
-                        string cacheKey = type switch
-                        {
-                            FileSystemEntity.Files => "F",
-                            FileSystemEntity.Directories => "D",
-                            FileSystemEntity.FilesAndDirectories => "A",
-                            _ => throw new NotImplementedException()
-                        } + ";" + path;
-                        IReadOnlyList<string> allEntriesForPath = getFileSystemDirectoryEntriesCache.GetOrAdd(
-                                cacheKey,
-                                s => getFileSystemEntries(
-                                    type,
-                                    path,
-                                    "*",
-                                    directory,
-                                    false));
-                        IEnumerable<string> filteredEntriesForPath = (pattern != null && !IsAllFilesWildcard(pattern))
-                            ? allEntriesForPath.Where(o => IsFileNameMatch(o, pattern))
-                            : allEntriesForPath;
-                        return stripProjectDirectory
-                            ? RemoveProjectDirectory(filteredEntriesForPath, directory).ToArray()
-                            : filteredEntriesForPath.ToArray();
-                    }
-                    else
-                    {
-                        // Legacy behavior:
-                        // Cache only directories, for files we won't hit the cache because the file name patterns tend to be unique
-                        if (type == FileSystemEntity.Directories)
-                        {
-                            return getFileSystemDirectoryEntriesCache.GetOrAdd(
-                                $"D;{path};{pattern ?? "*"}",
-                                s => getFileSystemEntries(
-                                    type,
-                                    path,
-                                    pattern,
-                                    directory,
-                                    stripProjectDirectory).ToArray());
-                        }
-                    }
-                    return getFileSystemEntries(type, path, pattern, directory, stripProjectDirectory);
+                        FileSystemEntity.Files => "F",
+                        FileSystemEntity.Directories => "D",
+                        FileSystemEntity.FilesAndDirectories => "A",
+                        _ => throw new NotImplementedException()
+                    } + ";" + path;
+                    IReadOnlyList<string> allEntriesForPath = getFileSystemDirectoryEntriesCache.GetOrAdd(
+                            cacheKey,
+                            s => getFileSystemEntries(
+                                type,
+                                path,
+                                "*",
+                                directory,
+                                false));
+                    IEnumerable<string> filteredEntriesForPath = (pattern != null && !IsAllFilesWildcard(pattern))
+                        ? allEntriesForPath.Where(o => IsFileNameMatch(o, pattern))
+                        : allEntriesForPath;
+                    return stripProjectDirectory
+                        ? RemoveProjectDirectory(filteredEntriesForPath, directory).ToArray()
+                        : filteredEntriesForPath.ToArray();
                 };
         }
 
diff --git a/src/Shared/IKeyed.cs b/src/Shared/IKeyed.cs
index 64bb7dc1094..c3798db36f4 100644
--- a/src/Shared/IKeyed.cs
+++ b/src/Shared/IKeyed.cs
@@ -21,4 +21,4 @@ string Key
             get;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Shared/ITranslator.cs b/src/Shared/ITranslator.cs
index 61dc02cc3a0..42274c2da1d 100644
--- a/src/Shared/ITranslator.cs
+++ b/src/Shared/ITranslator.cs
@@ -128,6 +128,12 @@ BinaryWriter Writer
         /// <param name="value">The value to be translated.</param>
         void Translate(ref int value);
 
+        /// <summary>
+        /// Translates an <see langword="int"/> array.
+        /// </summary>
+        /// <param name="array">The array to be translated.</param>
+        void Translate(ref int[] array);
+
         /// <summary>
         /// Translates a long.
         /// </summary>
diff --git a/src/Shared/LanguageParser/CSharptokenCharReader.cs b/src/Shared/LanguageParser/CSharptokenCharReader.cs
index e6daba8d38d..7dad4a3c123 100644
--- a/src/Shared/LanguageParser/CSharptokenCharReader.cs
+++ b/src/Shared/LanguageParser/CSharptokenCharReader.cs
@@ -133,4 +133,3 @@ internal bool SinkMultipleWhiteSpace()
         }
     }
 }
-
diff --git a/src/Shared/LanguageParser/VisualBasictokenCharReader.cs b/src/Shared/LanguageParser/VisualBasictokenCharReader.cs
index 696b113281c..4686976eee1 100644
--- a/src/Shared/LanguageParser/VisualBasictokenCharReader.cs
+++ b/src/Shared/LanguageParser/VisualBasictokenCharReader.cs
@@ -255,4 +255,3 @@ internal bool SinkTypeCharacter()
         }
     }
 }
-
diff --git a/src/Shared/LanguageParser/tokenChar.cs b/src/Shared/LanguageParser/tokenChar.cs
index 11b2301838d..fc1c21907e3 100644
--- a/src/Shared/LanguageParser/tokenChar.cs
+++ b/src/Shared/LanguageParser/tokenChar.cs
@@ -173,4 +173,3 @@ static internal bool IsOctalDigit(char c)
         }
     }
 }
-
diff --git a/src/Shared/LanguageParser/tokenCharReader.cs b/src/Shared/LanguageParser/tokenCharReader.cs
index 3c248272db8..ddd8b1d91a4 100644
--- a/src/Shared/LanguageParser/tokenCharReader.cs
+++ b/src/Shared/LanguageParser/tokenCharReader.cs
@@ -353,4 +353,3 @@ internal bool SinkMultipleDecimalDigits()
         }
     }
 }
-
diff --git a/src/Shared/MSBuildLoadContext.cs b/src/Shared/MSBuildLoadContext.cs
index fbe9d5e00fb..8d1e1c38e7a 100644
--- a/src/Shared/MSBuildLoadContext.cs
+++ b/src/Shared/MSBuildLoadContext.cs
@@ -1,7 +1,10 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
+
+using System;
 using System.Collections.Immutable;
 using System.IO;
 using System.Reflection;
@@ -15,6 +18,8 @@ namespace Microsoft.Build.Shared
     /// </summary>
     internal class MSBuildLoadContext : AssemblyLoadContext
     {
+        private AssemblyDependencyResolver? _resolver;
+
         private readonly string _directory;
 
         internal static readonly ImmutableHashSet<string> WellKnownAssemblyNames =
@@ -31,6 +36,16 @@ public MSBuildLoadContext(string assemblyPath)
             : base($"MSBuild plugin {assemblyPath}")
         {
             _directory = Directory.GetParent(assemblyPath)!.FullName;
+
+            // We check for the assemblyPath because it will fail with an AssemblyDependencyResolver-specific error
+            // if it does not exist. We should instead fall back to the standard failure.
+            // The second check is because AssemblyDependencyResolver loads assemblies differently than we do by default.
+            // We should maintain previous behavior in the absence of new data (a .deps.json file) indicating that we
+            // should do something different.
+            // Setting the _resolver to null essentially just opts out of the new behavior.
+            _resolver = File.Exists(assemblyPath) && File.Exists(Path.ChangeExtension(assemblyPath, ".deps.json"))
+                ? new AssemblyDependencyResolver(assemblyPath) :
+                null;
         }
 
         protected override Assembly? Load(AssemblyName assemblyName)
@@ -42,6 +57,19 @@ public MSBuildLoadContext(string assemblyPath)
                 return null;
             }
 
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                // respect plugin.dll.json with the AssemblyDependencyResolver
+                string? assemblyPath = _resolver?.ResolveAssemblyToPath(assemblyName);
+                if (assemblyPath != null)
+                {
+                    return LoadFromAssemblyPath(assemblyPath);
+                }
+            }
+
+            // Fall back to the older MSBuild-on-Core behavior to continue to support
+            // plugins that don't ship a .deps.json
+
             foreach (var cultureSubfolder in string.IsNullOrEmpty(assemblyName.CultureName)
                 // If no culture is specified, attempt to load directly from
                 // the known dependency paths.
@@ -73,7 +101,6 @@ public MSBuildLoadContext(string assemblyPath)
             // - the assembly from the user specified path is loaded, if it exists, into the custom ALC, or
             // - if the simple name of the assembly exists in the same folder as msbuild.exe, then that assembly gets loaded
             //   into the default ALC (so it's shared with other uses).
-
             var assemblyNameInExecutableDirectory = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory,
                 $"{assemblyName.Name}.dll");
 
@@ -84,5 +111,19 @@ public MSBuildLoadContext(string assemblyPath)
 
             return null;
         }
+
+        protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)
+        {
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                string? libraryPath = _resolver?.ResolveUnmanagedDllToPath(unmanagedDllName);
+                if (libraryPath != null)
+                {
+                    return LoadUnmanagedDllFromPath(libraryPath);
+                }
+            }
+
+            return base.LoadUnmanagedDll(unmanagedDllName);
+        }
     }
 }
diff --git a/src/Shared/NGen.cs b/src/Shared/NGen.cs
index 31276fe5fdd..d8e7750ef1a 100644
--- a/src/Shared/NGen.cs
+++ b/src/Shared/NGen.cs
@@ -47,4 +47,4 @@ public static implicit operator NGen<T>(T value)
             return new NGen<T>(value);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Shared/NodeEngineShutdownReason.cs b/src/Shared/NodeEngineShutdownReason.cs
index 2eaa6e307b1..854a3033ba0 100644
--- a/src/Shared/NodeEngineShutdownReason.cs
+++ b/src/Shared/NodeEngineShutdownReason.cs
@@ -32,4 +32,4 @@ public enum NodeEngineShutdownReason
         Error,
     }
     #endregion
-}
\ No newline at end of file
+}
diff --git a/src/Shared/Pair.cs b/src/Shared/Pair.cs
index ce7e3f72830..06b8b774508 100644
--- a/src/Shared/Pair.cs
+++ b/src/Shared/Pair.cs
@@ -57,4 +57,4 @@ internal TValue Value
             get { return _value; }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Shared/PlatformNegotiation.cs b/src/Shared/PlatformNegotiation.cs
new file mode 100644
index 00000000000..a0389604db3
--- /dev/null
+++ b/src/Shared/PlatformNegotiation.cs
@@ -0,0 +1,110 @@
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Evaluation;
+
+namespace Microsoft.Build.Shared
+{
+    /// <summary>
+    /// This class contains only static methods, which are used in both the 
+    /// tasks and graph projects in order for two projects to negotiate which platform a projectreference
+    /// should be built as.
+    /// </summary>
+    internal static class PlatformNegotiation
+    {
+        internal static string GetNearestPlatform(string referencedProjectPlatform, string projectReferencePlatformsMetadata, string projectReferenceLookupTableMetadata, string platformLookupTable, string projectPath, string currentProjectPlatform, TaskLoggingHelper? log = null)
+        {
+            Dictionary<string, string>? currentProjectLookupTable = ExtractLookupTable(platformLookupTable, log);
+
+            if (string.IsNullOrEmpty(projectReferencePlatformsMetadata) && string.IsNullOrEmpty(referencedProjectPlatform))
+                {
+                    log?.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoPlatformsListed", projectPath);
+                    return string.Empty;
+                }
+
+                // Pull platformLookupTable metadata from the referenced project. This allows custom
+                // mappings on a per-ProjectReference basis.
+                Dictionary<string, string>? projectReferenceLookupTable = ExtractLookupTable(projectReferenceLookupTableMetadata, log);
+
+                HashSet<string> projectReferencePlatforms = new HashSet<string>();
+                foreach (string s in projectReferencePlatformsMetadata.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
+                {
+                    projectReferencePlatforms.Add(s);
+                }
+
+                string buildProjectReferenceAs = string.Empty;
+
+                // If the referenced project has a defined `Platform` that's compatible, it will build that way by default.
+                // Don't set `buildProjectReferenceAs` and the `_GetProjectReferencePlatformProperties` target will handle the rest.
+                if (!string.IsNullOrEmpty(referencedProjectPlatform) && referencedProjectPlatform.Equals(currentProjectPlatform, StringComparison.OrdinalIgnoreCase))
+                {
+                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform", projectPath, referencedProjectPlatform);
+                }
+                // Prefer matching platforms
+                else if (projectReferencePlatforms.Contains(currentProjectPlatform))
+                {
+                    buildProjectReferenceAs = currentProjectPlatform;
+                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.SamePlatform");
+                }
+                // Prioritize platformLookupTable **metadata** attached to the ProjectReference item
+                // before the current project's table. We do this to allow per-ProjectReference fine tuning.
+                else if (projectReferenceLookupTable != null &&
+                        projectReferenceLookupTable.ContainsKey(currentProjectPlatform) &&
+                        projectReferencePlatforms.Contains(projectReferenceLookupTable[currentProjectPlatform]))
+                {
+                    buildProjectReferenceAs = projectReferenceLookupTable[currentProjectPlatform];
+                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", currentProjectPlatform, buildProjectReferenceAs, projectReferenceLookupTableMetadata);
+                }
+                // Current project's translation table follows
+                else if (currentProjectLookupTable != null &&
+                        currentProjectLookupTable.ContainsKey(currentProjectPlatform) &&
+                        projectReferencePlatforms.Contains(currentProjectLookupTable[currentProjectPlatform]))
+                {
+                    buildProjectReferenceAs = currentProjectLookupTable[currentProjectPlatform];
+                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", currentProjectPlatform, buildProjectReferenceAs, platformLookupTable);
+                }
+                // AnyCPU if possible
+                else if (projectReferencePlatforms.Contains("AnyCPU"))
+                {
+                    buildProjectReferenceAs = "AnyCPU";
+                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.AnyCPUDefault");
+                }
+                else
+                {
+                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine 
+                    // Platform/PlatformTarget when this is the case.
+                    log?.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoCompatiblePlatformFound", projectPath);
+                }
+            return buildProjectReferenceAs;
+        }
+        internal static Dictionary<string, string>? ExtractLookupTable(string stringTable, TaskLoggingHelper? log = null)
+        {
+            if (string.IsNullOrEmpty(stringTable))
+            {
+                return null;
+            }
+
+            Dictionary<string, string> table = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+
+            foreach (string s in stringTable.Trim().Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
+            {
+                string[] keyVal = s.Trim().Split(MSBuildConstants.EqualsChar);
+
+                // Invalid table, don't use it.
+                if (keyVal.Length != 2 || string.IsNullOrEmpty(keyVal[0]) || string.IsNullOrEmpty(keyVal[1]))
+                {
+                    log?.LogWarningWithCodeFromResources("GetCompatiblePlatform.InvalidLookupTableFormat", stringTable);
+                    return null;
+                }
+
+                table[keyVal[0]] = keyVal[1];
+            }
+
+            log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.LookupTableParsed", stringTable);
+
+            return table;
+        }
+    }
+}
diff --git a/src/Shared/RegistryDelegates.cs b/src/Shared/RegistryDelegates.cs
index 45f28819e26..4883342d33f 100644
--- a/src/Shared/RegistryDelegates.cs
+++ b/src/Shared/RegistryDelegates.cs
@@ -1,19 +1,12 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
-#if FEATURE_WIN32_REGISTRY
 
-using System;
-using System.IO;
-using System.Diagnostics;
-using System.Globalization;
 using Microsoft.Win32;
-using System.Collections;
 using System.Collections.Generic;
 
-#nullable disable
-
 namespace Microsoft.Build.Shared
-{  /// <summary>
+{
+    /// <summary>
    /// Given a registry hive and a request view open the base key for that registry location.
    /// </summary>
     internal delegate RegistryKey OpenBaseKey(RegistryHive hive, RegistryView view);
@@ -36,4 +29,3 @@ namespace Microsoft.Build.Shared
     /// <returns>A string containing the default value.</returns>
     internal delegate string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string subKey);
 }
-#endif
diff --git a/src/Shared/RegistryHelper.cs b/src/Shared/RegistryHelper.cs
index 19cc6190041..fc26fd09f82 100644
--- a/src/Shared/RegistryHelper.cs
+++ b/src/Shared/RegistryHelper.cs
@@ -1,20 +1,16 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
-#if FEATURE_WIN32_REGISTRY
 
 using System.Collections.Generic;
-
+using System.Runtime.Versioning;
 using Microsoft.Win32;
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-#nullable disable
 
 namespace Microsoft.Build.Shared
 {
     /// <summary>
     /// Helper methods that simplify registry access.
     /// </summary>
+    [SupportedOSPlatform("windows")]
     internal static class RegistryHelper
     {
         /// <summary>
@@ -23,11 +19,11 @@ internal static class RegistryHelper
         /// <param name="baseKey">The base registry key.</param>
         /// <param name="subkey">The subkey</param>
         /// <returns>An enumeration of strings.</returns>        
-        internal static IEnumerable<string> GetSubKeyNames(RegistryKey baseKey, string subkey)
+        internal static IEnumerable<string>? GetSubKeyNames(RegistryKey baseKey, string subkey)
         {
-            IEnumerable<string> subKeys = null;
+            IEnumerable<string>? subKeys = null;
 
-            using (RegistryKey subKey = baseKey.OpenSubKey(subkey))
+            using (RegistryKey? subKey = baseKey.OpenSubKey(subkey))
             {
                 if (subKey != null)
                 {
@@ -44,15 +40,15 @@ internal static IEnumerable<string> GetSubKeyNames(RegistryKey baseKey, string s
         /// <param name="baseKey">The base registry key.</param>
         /// <param name="subkey">The subkey</param>
         /// <returns>A string containing the default value.</returns>
-        internal static string GetDefaultValue(RegistryKey baseKey, string subkey)
+        internal static string? GetDefaultValue(RegistryKey baseKey, string subkey)
         {
-            string value = null;
+            string? value = null;
 
-            using (RegistryKey key = baseKey.OpenSubKey(subkey))
+            using (RegistryKey? key = baseKey.OpenSubKey(subkey))
             {
                 if (key?.ValueCount > 0)
                 {
-                    value = (string)key.GetValue("");
+                    value = (string?)key.GetValue("");
                 }
             }
 
@@ -73,4 +69,3 @@ internal static RegistryKey OpenBaseKey(RegistryHive hive, RegistryView view)
         }
     }
 }
-#endif
\ No newline at end of file
diff --git a/src/Shared/Resources/Strings.shared.resx b/src/Shared/Resources/Strings.shared.resx
index b1c884da6fd..1d110f22384 100644
--- a/src/Shared/Resources/Strings.shared.resx
+++ b/src/Shared/Resources/Strings.shared.resx
@@ -279,7 +279,7 @@
     <comment>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</comment>
   </data>
   <data name="WildcardResultsInDriveEnumeration" xml:space="preserve">
-    <value>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</value>
+    <value>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</value>
     <comment>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</comment>
   </data>
diff --git a/src/Shared/Resources/xlf/Strings.shared.cs.xlf b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
index 28db153e941..575278045ee 100644
--- a/src/Shared/Resources/xlf/Strings.shared.cs.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
@@ -309,8 +309,8 @@
         <note />
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
-        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="translated">MSB5029: Hodnota {0} atributu {1} v elementu &lt;{2}&gt; je zástupný znak, jehož výsledkem je výčet všech souborů na jednotce, což pravděpodobně nebylo zamýšleno. Zkontrolujte, jestli jsou odkazované vlastnosti vždy definovány.</target>
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.de.xlf b/src/Shared/Resources/xlf/Strings.shared.de.xlf
index e304bd152ac..3b3a861a769 100644
--- a/src/Shared/Resources/xlf/Strings.shared.de.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.de.xlf
@@ -309,8 +309,8 @@
         <note />
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
-        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="translated">MSB5029: Der Wert „{0}“ des Attributs „{1}“ im Element &lt;{2}&gt; ist ein Platzhalter, der dazu führt, dass alle Dateien auf dem Laufwerk aufgezählt werden, was wahrscheinlich nicht beabsichtigt war. Überprüfen Sie, ob Eigenschaften, auf die verwiesen wird, immer definiert sind.</target>
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.es.xlf b/src/Shared/Resources/xlf/Strings.shared.es.xlf
index c6979fa1689..9193d9bf3b8 100644
--- a/src/Shared/Resources/xlf/Strings.shared.es.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.es.xlf
@@ -309,8 +309,8 @@
         <note />
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
-        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="translated">MSB5029: El valor “{0}” del atributo “{1}” en el elemento &lt;{2}&gt; es un carácter comodín que da como resultado la enumeración de todos los archivos de la unidad, lo que probablemente no estaba previsto. Compruebe que siempre se definan las propiedades a las que se hace referencia.</target>
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.fr.xlf b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
index 37399b16f44..7ba650edd28 100644
--- a/src/Shared/Resources/xlf/Strings.shared.fr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
@@ -309,8 +309,8 @@
         <note />
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
-        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="translated">MSB5029: La valeur "{0}" de l'attribut "{1}" de l'élément &lt;{2}&gt; est un caractère générique qui entraîne l'énumération de tous les fichiers du lecteur, ce qui n'était probablement pas prévu. Vérifiez que les propriétés référencées sont toujours définies.</target>
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.it.xlf b/src/Shared/Resources/xlf/Strings.shared.it.xlf
index 5bb8c7eebfb..5d0abb3e4e0 100644
--- a/src/Shared/Resources/xlf/Strings.shared.it.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.it.xlf
@@ -309,8 +309,8 @@
         <note />
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
-        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="translated">MSB5029: il valore "{0}" dell'attributo "{1}" nell'elemento &lt;{2}&gt; è un carattere jolly che determina l'enumerazione di tutti i file nell'unità, che probabilmente non era previsto. Verificare che le proprietà di riferimento siano sempre definite.</target>
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ja.xlf b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
index ca851b2b211..2bfc6c3463f 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ja.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
@@ -309,8 +309,8 @@
         <note />
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
-        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="translated">MSB5029: 要素 &lt;{2}&gt; の "{1}" 属性の値 "{0}" はワイルドカードであり、ドライブ上のすべてのファイルが列挙され、それは意図されていない模様です。参照されるプロパティが常に定義されていることを確認してください。</target>
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ko.xlf b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
index 2832de50cd7..503baf9f4b0 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ko.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
@@ -309,8 +309,8 @@
         <note />
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
-        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="translated">MSB5029: &lt;{2}&gt; 요소의 "{1}" 특성의 값 "{0}"은(는) 의도하지 않은 드라이브의 모든 파일을 열거하는 와일드카드입니다. 참조된 속성이 항상 정의되어 있는지 확인하세요.</target>
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.pl.xlf b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
index c0cd32ad0a0..c026f00091e 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pl.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
@@ -309,8 +309,8 @@
         <note />
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
-        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="translated">MSB5029: Wartość „{0}” atrybutu „{1}” w elemencie &lt;{2}&gt; jest symbolem wieloznacznym, który powoduje wyliczenie wszystkich plików na dysku, co prawdopodobnie nie było zamierzone. Sprawdź, czy przywoływane właściwości są zawsze zdefiniowane.</target>
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
index ff7be552a3d..848ba95c3da 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
@@ -309,8 +309,8 @@
         <note />
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
-        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="translated">MSB5029: O valor "{0}" do atributo "{1}" no elemento &lt;{2}&gt; é um curinga que resulta na enumeração de todos os arquivos na unidade, o que provavelmente não foi pretendido. Verifique se as propriedades referenciadas estão sempre definidas.</target>
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ru.xlf b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
index 9d957db25d5..c23b63e3b4b 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ru.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
@@ -309,8 +309,8 @@
         <note />
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
-        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="translated">MSB5029: значение "{0}" атрибута "{1}" в элементе &lt;{2}&gt; является подстановочным знаком, который приводит к перечислению всех файлов на диске, что, скорее всего, не предполагалось. Убедитесь, что свойства, на которые имеются ссылки, всегда определены.</target>
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.tr.xlf b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
index ba298b18d89..09e4f9aeae1 100644
--- a/src/Shared/Resources/xlf/Strings.shared.tr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
@@ -309,8 +309,8 @@
         <note />
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
-        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="translated">MSB5029: &lt;{2}&gt; öğesindeki "{1}" özniteliğinin "{0}" değeri, sürücüdeki tüm dosyaların numaralandırılmasıyla sonuçlanan (büyük olasılıkla bunun olması amaçlanmıyordu) bir joker karakterdir. Başvurulan özelliklerin her zaman tanımlı olduğundan emin olun.</target>
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
index fd15f148422..e8a04e0bba0 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
@@ -309,8 +309,8 @@
         <note />
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
-        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="translated">MSB5029: 元素 &lt;{2}&gt; 中“{1}”属性的值“{0}”是通配符，可导致枚举驱动器上的所有文件，这可能不是预期的行为。请检查是否始终定义了所引用的属性。</target>
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
index 849ed85ed79..a63f80f76e2 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
@@ -309,8 +309,8 @@
         <note />
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
-        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="translated">MSB5029: 元素 &lt;{2}&gt; 中「{1}」屬性的值「{0}」是萬用字元，導致列舉磁碟機上的所有檔案，這很可能不是預期的結果。檢查是否一直定義參考屬性。</target>
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index 515500a98b0..c7e900625b8 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -5,6 +5,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Globalization;
 using System.Linq;
 using System.Reflection;
 using System.Security;
@@ -16,7 +17,7 @@
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
-    /// Type of parameter, used to figure out how to serialize it. 
+    /// Type of parameter, used to figure out how to serialize it.
     /// </summary>
     internal enum TaskParameterType
     {
@@ -35,18 +36,28 @@ internal enum TaskParameterType
         /// </summary>
         StringArray,
 
+        /// <summary>
+        /// Parameter is <c>true</c> or <c>false</c>.
+        /// </summary>
+        Bool,
+
+        /// <summary>
+        /// Parameter is an <see langword="int"/>.
+        /// </summary>
+        Int,
+
         /// <summary>
         /// Parameter is a value type.  Note:  Must be serializable
         /// </summary>
         ValueType,
 
         /// <summary>
-        /// Parameter is an array of value types.  Note:  Must be serializable. 
+        /// Parameter is an array of value types.  Note:  Must be serializable.
         /// </summary>
         ValueTypeArray,
 
         /// <summary>
-        /// Parameter is an ITaskItem 
+        /// Parameter is an ITaskItem
         /// </summary>
         ITaskItem,
 
@@ -56,15 +67,15 @@ internal enum TaskParameterType
         ITaskItemArray,
 
         /// <summary>
-        /// An invalid parameter -- the value of this parameter contains the exception 
-        /// that is thrown when trying to access it. 
+        /// An invalid parameter -- the value of this parameter contains the exception
+        /// that is thrown when trying to access it.
         /// </summary>
         Invalid
     }
 
     /// <summary>
-    /// Wrapper for task parameters, to allow proper serialization even 
-    /// in cases where the parameter is not .NET serializable. 
+    /// Wrapper for task parameters, to allow proper serialization even
+    /// in cases where the parameter is not .NET serializable.
     /// </summary>
     internal class TaskParameter :
 #if FEATURE_APPDOMAIN
@@ -103,11 +114,12 @@ public TaskParameter(object wrappedParameter)
                 return;
             }
 
-            // It's not null or invalid, so it should be a valid parameter type. 
+            // It's not null or invalid, so it should be a valid parameter type.
             ErrorUtilities.VerifyThrow
                 (
                     TaskParameterTypeVerifier.IsValidInputParameter(wrappedParameterType) || TaskParameterTypeVerifier.IsValidOutputParameter(wrappedParameterType),
-                    "How did we manage to get a task parameter that isn't a valid parameter type?"
+                    "How did we manage to get a task parameter of type {0} that isn't a valid parameter type?",
+                    wrappedParameterType
                 );
 
             if (wrappedParameterType.IsArray)
@@ -156,6 +168,28 @@ public TaskParameter(object wrappedParameter)
                     _parameterType = TaskParameterType.ITaskItem;
                     _wrappedParameter = CreateNewTaskItemFrom((ITaskItem)wrappedParameter);
                 }
+                // Preserve enums as strings: the enum type itself may not
+                // be loaded on the other side of the serialization, but
+                // we would convert to string anyway after pulling the
+                // task output into a property or item.
+                else if (wrappedParameterType.IsEnum)
+                {
+                    _parameterType = TaskParameterType.String;
+                    _wrappedParameter = (string)Convert.ChangeType(wrappedParameter, typeof(string), CultureInfo.InvariantCulture);
+                }
+                    // Also stringify known common value types, to avoid calling
+                    // TranslateDotNet when they'll just be stringified on the
+                    // output side
+                else if (wrappedParameterType == typeof(bool))
+                {
+                    _parameterType = TaskParameterType.Bool;
+                    _wrappedParameter = wrappedParameter;
+                }
+                else if (wrappedParameterType == typeof(int))
+                {
+                    _parameterType = TaskParameterType.Int;
+                    _wrappedParameter = wrappedParameter;
+                }
                 else if (wrappedParameterType.GetTypeInfo().IsValueType)
                 {
                     _parameterType = TaskParameterType.ValueType;
@@ -196,7 +230,7 @@ public object WrappedParameter
         }
 
         /// <summary>
-        /// TaskParameter's ToString should just pass through to whatever it's wrapping. 
+        /// TaskParameter's ToString should just pass through to whatever it's wrapping.
         /// </summary>
         public override string ToString()
         {
@@ -204,7 +238,7 @@ public override string ToString()
         }
 
         /// <summary>
-        /// Serialize / deserialize this item. 
+        /// Serialize / deserialize this item.
         /// </summary>
         public void Translate(ITranslator translator)
         {
@@ -225,6 +259,24 @@ public void Translate(ITranslator translator)
                     translator.Translate(ref stringArrayParam);
                     _wrappedParameter = stringArrayParam;
                     break;
+                case TaskParameterType.Bool:
+                    bool boolParam = _wrappedParameter switch
+                    {
+                        bool hadValue => hadValue,
+                        _ => default,
+                    };
+                    translator.Translate(ref boolParam);
+                    _wrappedParameter = boolParam;
+                    break;
+                case TaskParameterType.Int:
+                    int intParam = _wrappedParameter switch
+                    {
+                        int hadValue => hadValue,
+                        _ => default,
+                    };
+                    translator.Translate(ref intParam);
+                    _wrappedParameter = intParam;
+                    break;
                 case TaskParameterType.ValueType:
                 case TaskParameterType.ValueTypeArray:
                     translator.TranslateDotNet(ref _wrappedParameter);
@@ -270,7 +322,7 @@ internal static TaskParameter FactoryForDeserialization(ITranslator translator)
         }
 
         /// <summary>
-        /// Creates a new ITaskItem with the contents of the old one. 
+        /// Creates a new ITaskItem with the contents of the old one.
         /// </summary>
         private ITaskItem CreateNewTaskItemFrom(ITaskItem copyFrom)
         {
@@ -296,10 +348,10 @@ private ITaskItem CreateNewTaskItemFrom(ITaskItem copyFrom)
             }
             else
             {
-                // If we don't have ITaskItem2 to fall back on, we have to make do with the fact that 
-                // CloneCustomMetadata, GetMetadata, & ItemSpec returns unescaped values, and 
-                // TaskParameterTaskItem's constructor expects escaped values, so escaping them all 
-                // is the closest approximation to correct we can get.  
+                // If we don't have ITaskItem2 to fall back on, we have to make do with the fact that
+                // CloneCustomMetadata, GetMetadata, & ItemSpec returns unescaped values, and
+                // TaskParameterTaskItem's constructor expects escaped values, so escaping them all
+                // is the closest approximation to correct we can get.
                 escapedItemSpec = EscapingUtilities.Escape(copyFrom.ItemSpec);
 
                 escapedDefiningProject = EscapingUtilities.EscapeWithCaching(copyFrom.GetMetadata(FileUtilities.ItemSpecModifiers.DefiningProjectFullPath));
@@ -321,7 +373,7 @@ private ITaskItem CreateNewTaskItemFrom(ITaskItem copyFrom)
         }
 
         /// <summary>
-        /// Serialize / deserialize this item. 
+        /// Serialize / deserialize this item.
         /// </summary>
         private void TranslateITaskItemArray(ITranslator translator)
         {
@@ -358,7 +410,7 @@ private void TranslateITaskItemArray(ITranslator translator)
         }
 
         /// <summary>
-        /// Serialize / deserialize this item. 
+        /// Serialize / deserialize this item.
         /// </summary>
         private void TranslateITaskItem(ITranslator translator)
         {
@@ -402,8 +454,8 @@ private void WriteITaskItem(ITranslator translator, ITaskItem wrappedItem)
             }
             else
             {
-                // We know that the ITaskItem constructor expects an escaped string, and that ITaskItem.ItemSpec 
-                // is expected to be unescaped, so make sure we give the constructor what it wants. 
+                // We know that the ITaskItem constructor expects an escaped string, and that ITaskItem.ItemSpec
+                // is expected to be unescaped, so make sure we give the constructor what it wants.
                 escapedItemSpec = EscapingUtilities.Escape(wrappedItem.ItemSpec);
                 escapedDefiningProject = EscapingUtilities.EscapeWithCaching(wrappedItem.GetMetadata(FileUtilities.ItemSpecModifiers.DefiningProjectFullPath));
                 wrappedMetadata = wrappedItem.CloneCustomMetadata();
@@ -486,7 +538,7 @@ private bool TranslateNullable<T>(ITranslator translator, T value)
         }
 
         /// <summary>
-        /// Super simple ITaskItem derivative that we can use as a container for read items.  
+        /// Super simple ITaskItem derivative that we can use as a container for read items.
         /// </summary>
         private class TaskParameterTaskItem :
 #if FEATURE_APPDOMAIN
@@ -499,7 +551,7 @@ private class TaskParameterTaskItem :
 #endif
         {
             /// <summary>
-            /// The item spec 
+            /// The item spec
             /// </summary>
             private string _escapedItemSpec = null;
 
@@ -740,7 +792,7 @@ string ITaskItem2.GetMetadataValueEscaped(string metadataName)
             }
 
             /// <summary>
-            /// Sets the exact metadata value given to the metadata name requested. 
+            /// Sets the exact metadata value given to the metadata name requested.
             /// </summary>
             void ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue)
             {
@@ -748,7 +800,7 @@ void ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValu
             }
 
             /// <summary>
-            /// Returns a dictionary containing all metadata and their escaped forms.  
+            /// Returns a dictionary containing all metadata and their escaped forms.
             /// </summary>
             IDictionary ITaskItem2.CloneCustomMetadataEscaped()
             {
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index d4d5b8e3d1e..f8d6a15e9d3 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -1461,11 +1461,11 @@ internal static void BuildTargetWithDriveEnumeratingWildcardUsingBuildManager(Te
                 // Verify result based on value of ExpectedBuildResult
                 if (expectedBuildResult == ExpectedBuildResult.FailWithError)
                 {
-                    VerifyErrorLoggedForDriveEnumeratingWildcard(buildResult, mockLogger, targetName);
+                    VerifyErrorLoggedForDriveEnumeratingWildcard(buildResult, mockLogger, targetName, testProjectFile);
                 }
                 else if (expectedBuildResult == ExpectedBuildResult.SucceedWithWarning)
                 {
-                    VerifyWarningLoggedForDriveEnumeratingWildcard(buildResult, mockLogger, targetName);
+                    VerifyWarningLoggedForDriveEnumeratingWildcard(buildResult, mockLogger, targetName, testProjectFile);
                 }
                 else if (expectedBuildResult == ExpectedBuildResult.SucceedWithNoErrorsAndWarnings)
                 {
@@ -1478,19 +1478,21 @@ internal static void BuildTargetWithDriveEnumeratingWildcardUsingBuildManager(Te
             }
         }
 
-        private static void VerifyErrorLoggedForDriveEnumeratingWildcard(BuildResult buildResult, MockLogger mockLogger, string targetName)
+        private static void VerifyErrorLoggedForDriveEnumeratingWildcard(BuildResult buildResult, MockLogger mockLogger, string targetName, string testProjectFile)
         {
             buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
             buildResult[targetName].ResultCode.ShouldBe(TargetResultCode.Failure);
             mockLogger.ErrorCount.ShouldBe(1);
             mockLogger.Errors[0].Code.ShouldBe("MSB5029");
+            mockLogger.Errors[0].Message.ShouldContain(testProjectFile);
         }
 
-        private static void VerifyWarningLoggedForDriveEnumeratingWildcard(BuildResult buildResult, MockLogger mockLogger, string targetName)
+        private static void VerifyWarningLoggedForDriveEnumeratingWildcard(BuildResult buildResult, MockLogger mockLogger, string targetName, string testProjectFile)
         {
             VerifySuccessOfBuildAndTargetResults(buildResult, targetName);
             mockLogger.WarningCount.ShouldBe(1);
             mockLogger.Warnings[0].Code.ShouldBe("MSB5029");
+            mockLogger.Warnings[0].Message.ShouldContain(testProjectFile);
         }
 
         private static void VerifyNoErrorsAndWarningsForDriveEnumeratingWildcard(BuildResult buildResult, MockLogger mockLogger, string targetName)
diff --git a/src/Shared/UnitTests/PrintLineDebugger_Tests.cs b/src/Shared/UnitTests/PrintLineDebugger_Tests.cs
index 6b7e21ac052..a9cd5ddb7ff 100644
--- a/src/Shared/UnitTests/PrintLineDebugger_Tests.cs
+++ b/src/Shared/UnitTests/PrintLineDebugger_Tests.cs
@@ -260,4 +260,4 @@ public void CannotUnsetWriterWhenNoWriterIsSet()
         }
     }
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/src/Shared/UnitTests/TaskParameter_Tests.cs b/src/Shared/UnitTests/TaskParameter_Tests.cs
index d726a685700..9fdb8aa1c8d 100644
--- a/src/Shared/UnitTests/TaskParameter_Tests.cs
+++ b/src/Shared/UnitTests/TaskParameter_Tests.cs
@@ -89,25 +89,25 @@ public void StringArrayParameter()
         /// Verifies that construction and serialization with a value type (integer) parameter is OK.
         /// </summary>
         [Fact]
-        public void ValueTypeParameter()
+        public void IntParameter()
         {
             TaskParameter t = new TaskParameter(1);
 
             Assert.Equal(1, t.WrappedParameter);
-            Assert.Equal(TaskParameterType.ValueType, t.ParameterType);
+            Assert.Equal(TaskParameterType.Int, t.ParameterType);
 
             ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
             TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
             Assert.Equal(1, t2.WrappedParameter);
-            Assert.Equal(TaskParameterType.ValueType, t2.ParameterType);
+            Assert.Equal(TaskParameterType.Int, t2.ParameterType);
         }
 
         /// <summary>
         /// Verifies that construction and serialization with a parameter that is an array of value types (ints) is OK.
         /// </summary>
         [Fact]
-        public void ValueTypeArrayParameter()
+        public void IntArrayParameter()
         {
             TaskParameter t = new TaskParameter(new int[] { 2, 15 });
 
@@ -131,6 +131,69 @@ public void ValueTypeArrayParameter()
             Assert.Equal(15, wrappedParameter2[1]);
         }
 
+        enum TestEnumForParameter
+        {
+            Something,
+            SomethingElse
+        }
+
+        [Fact]
+        public void EnumParameter()
+        {
+            TaskParameter t = new TaskParameter(TestEnumForParameter.SomethingElse);
+
+            Assert.Equal("SomethingElse", t.WrappedParameter);
+            Assert.Equal(TaskParameterType.String, t.ParameterType);
+
+            ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
+            TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
+
+            Assert.Equal("SomethingElse", t2.WrappedParameter);
+            Assert.Equal(TaskParameterType.String, t2.ParameterType);
+        }
+
+        [Fact]
+        public void BoolParameter()
+        {
+            TaskParameter t = new TaskParameter(true);
+
+            Assert.Equal(true, t.WrappedParameter);
+            Assert.Equal(TaskParameterType.Bool, t.ParameterType);
+
+            ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
+            TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
+
+            Assert.Equal(true, t2.WrappedParameter);
+            Assert.Equal(TaskParameterType.Bool, t2.ParameterType);
+        }
+
+        /// <summary>
+        /// Verifies that construction and serialization with a parameter that is an array of value types (ints) is OK.
+        /// </summary>
+        [Fact]
+        public void BoolArrayParameter()
+        {
+            TaskParameter t = new TaskParameter(new bool[] { false, true });
+
+            Assert.Equal(TaskParameterType.ValueTypeArray, t.ParameterType);
+
+            bool[] wrappedParameter = t.WrappedParameter as bool[];
+            Assert.NotNull(wrappedParameter);
+            Assert.Equal(2, wrappedParameter.Length);
+            Assert.False(wrappedParameter[0]);
+            Assert.True(wrappedParameter[1]);
+
+            ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
+            TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
+
+            Assert.Equal(TaskParameterType.ValueTypeArray, t2.ParameterType);
+
+            bool[] wrappedParameter2 = Assert.IsType<bool[]>(t2.WrappedParameter);
+            Assert.Equal(2, wrappedParameter2.Length);
+            Assert.False(wrappedParameter2[0]);
+            Assert.True(wrappedParameter2[1]);
+        }
+
         /// <summary>
         /// Verifies that construction and serialization with an ITaskItem parameter is OK.
         /// </summary>
diff --git a/src/Shared/UnitTests/TypeLoader_Dependencies_Tests.cs b/src/Shared/UnitTests/TypeLoader_Dependencies_Tests.cs
index 54233416871..f9f2e430531 100644
--- a/src/Shared/UnitTests/TypeLoader_Dependencies_Tests.cs
+++ b/src/Shared/UnitTests/TypeLoader_Dependencies_Tests.cs
@@ -109,4 +109,3 @@ private void CheckIfCorrectAssemblyLoaded(string scriptOutput, string expectedAs
         }
     }
 }
-
diff --git a/src/Shared/UnitTests/TypeLoader_Tests.cs b/src/Shared/UnitTests/TypeLoader_Tests.cs
index 9fb112d8c03..509f4c01565 100644
--- a/src/Shared/UnitTests/TypeLoader_Tests.cs
+++ b/src/Shared/UnitTests/TypeLoader_Tests.cs
@@ -6,8 +6,10 @@
 using System.IO;
 using Microsoft.Build.Shared;
 using System.Reflection;
-using Xunit;
 using Microsoft.Build.UnitTests.Shared;
+using Xunit;
+using Xunit.Abstractions;
+using Shouldly;
 
 #nullable disable
 
@@ -19,6 +21,13 @@ public class TypeLoader_Tests
         private const string ProjectFileName = "portableTaskTest.proj";
         private const string DLLFileName = "PortableTask.dll";
 
+        private readonly ITestOutputHelper _output;
+
+        public TypeLoader_Tests(ITestOutputHelper testOutputHelper)
+        {
+            _output = testOutputHelper;
+        }
+
         [Fact]
         public void Basic()
         {
@@ -50,19 +59,18 @@ public void Regress_Mutation_ParameterOrderDoesntMatter()
         [Fact]
         public void LoadNonExistingAssembly()
         {
-            using (var dir = new FileUtilities.TempWorkingDirectory(ProjectFileFolder))
-            {
-                string projectFilePath = Path.Combine(dir.Path, ProjectFileName);
+            using var dir = new FileUtilities.TempWorkingDirectory(ProjectFileFolder);
 
-                string dllName = "NonExistent.dll";
+            string projectFilePath = Path.Combine(dir.Path, ProjectFileName);
 
-                bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + dllName, out successfulExit);
-                Assert.False(successfulExit);
+            string dllName = "NonExistent.dll";
 
-                string dllPath = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, dllName);
-                CheckIfCorrectAssemblyLoaded(output, dllPath, false);
-            }
+            bool successfulExit;
+            string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + dllName, out successfulExit, _output);
+            successfulExit.ShouldBeFalse();
+
+            string dllPath = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, dllName);
+            CheckIfCorrectAssemblyLoaded(output, dllPath, false);
         }
 
         [Fact]
@@ -73,7 +81,7 @@ public void LoadInsideAsssembly()
                 string projectFilePath = Path.Combine(dir.Path, ProjectFileName);
 
                 bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag", out successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag", out successfulExit, _output);
                 Assert.True(successfulExit);
 
                 string dllPath = Path.Combine(dir.Path, DLLFileName);
@@ -95,7 +103,7 @@ public void LoadOutsideAssembly()
                 try
                 {
                     bool successfulExit;
-                    string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + movedDLLPath, out successfulExit);
+                    string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + movedDLLPath, out successfulExit, _output);
                     Assert.True(successfulExit);
 
                     CheckIfCorrectAssemblyLoaded(output, movedDLLPath);
@@ -119,7 +127,7 @@ public void LoadInsideAssemblyWhenGivenOutsideAssemblyWithSameName()
                 try
                 {
                     bool successfulExit;
-                    string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + copiedDllPath, out successfulExit);
+                    string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + copiedDllPath, out successfulExit, _output);
                     Assert.True(successfulExit);
 
                     CheckIfCorrectAssemblyLoaded(output, originalDLLPath);
@@ -301,4 +309,3 @@ private static bool IsForwardingLoggerClass(Type type, object unused)
 #endif
     }
 }
-
diff --git a/src/Shared/XMakeAttributes.cs b/src/Shared/XMakeAttributes.cs
index c7a3e3752fc..7a4d501e09c 100644
--- a/src/Shared/XMakeAttributes.cs
+++ b/src/Shared/XMakeAttributes.cs
@@ -3,6 +3,9 @@
 
 using System;
 using System.Collections.Generic;
+#if !CLR2COMPATIBILITY
+using System.Runtime.InteropServices;
+#endif
 using System.Runtime.CompilerServices;
 
 #nullable disable
@@ -88,6 +91,7 @@ internal struct MSBuildArchitectureValues
         {
             internal const string x86 = "x86";
             internal const string x64 = "x64";
+            internal const string arm64 = "arm64";
             internal const string currentArchitecture = "CurrentArchitecture";
             internal const string any = "*";
         }
@@ -106,7 +110,7 @@ internal struct MSBuildArchitectureValues
 
         private static readonly HashSet<string> ValidMSBuildRuntimeValues = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { MSBuildRuntimeValues.clr2, MSBuildRuntimeValues.clr4, MSBuildRuntimeValues.currentRuntime, MSBuildRuntimeValues.net, MSBuildRuntimeValues.any };
 
-        private static readonly HashSet<string> ValidMSBuildArchitectureValues = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { MSBuildArchitectureValues.x86, MSBuildArchitectureValues.x64, MSBuildArchitectureValues.currentArchitecture, MSBuildArchitectureValues.any };
+        private static readonly HashSet<string> ValidMSBuildArchitectureValues = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { MSBuildArchitectureValues.x86, MSBuildArchitectureValues.x64, MSBuildArchitectureValues.arm64, MSBuildArchitectureValues.currentArchitecture, MSBuildArchitectureValues.any };
 
         /// <summary>
         /// Returns true if and only if the specified attribute is one of the attributes that the engine specifically recognizes
@@ -429,7 +433,25 @@ internal static bool TryMergeArchitectureValues(string architectureA, string arc
         /// </comments>
         internal static string GetCurrentMSBuildArchitecture()
         {
+#if !CLR2COMPATIBILITY
+            string currentArchitecture = string.Empty;
+            switch (RuntimeInformation.ProcessArchitecture)
+            {
+                case Architecture.X86:
+                    currentArchitecture = MSBuildArchitectureValues.x86;
+                    break;
+                case Architecture.X64:
+                    currentArchitecture = MSBuildArchitectureValues.x64;
+                    break;
+                case Architecture.Arm64:
+                    currentArchitecture = MSBuildArchitectureValues.arm64;
+                    break;
+                default:
+                    throw new PlatformNotSupportedException(string.Format("{0} is not a supported architecture.", RuntimeInformation.ProcessArchitecture));
+            }
+#else
             string currentArchitecture = (IntPtr.Size == sizeof(Int64)) ? MSBuildArchitectureValues.x64 : MSBuildArchitectureValues.x86;
+#endif
             return currentArchitecture;
         }
 
diff --git a/src/StringTools.Benchmark/StringTools.Benchmark.csproj b/src/StringTools.Benchmark/StringTools.Benchmark.csproj
index eb1bf1347f3..92f0e8e82eb 100644
--- a/src/StringTools.Benchmark/StringTools.Benchmark.csproj
+++ b/src/StringTools.Benchmark/StringTools.Benchmark.csproj
@@ -4,7 +4,7 @@
     <UseAppHost>false</UseAppHost>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
-    
+
     <IsPackable>false</IsPackable>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
 
@@ -14,6 +14,9 @@
 
   <ItemGroup>
     <PackageReference Include="BenchmarkDotNet" />
+    <!-- Bump these to the latest version despite transitive references to older -->
+    <PackageReference Include="System.Private.Uri" />
+    <PackageReference Include="System.Runtime" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/Tasks.UnitTests/Al_Tests.cs b/src/Tasks.UnitTests/Al_Tests.cs
index 7e235176d99..6d2d0884c8e 100644
--- a/src/Tasks.UnitTests/Al_Tests.cs
+++ b/src/Tasks.UnitTests/Al_Tests.cs
@@ -611,8 +611,3 @@ public void Win32Resource()
         }
     }
 }
-
-
-
-
-
diff --git a/src/Tasks.UnitTests/AssignCulture_Tests.cs b/src/Tasks.UnitTests/AssignCulture_Tests.cs
index 3d35d7d478d..c4c89013a1e 100644
--- a/src/Tasks.UnitTests/AssignCulture_Tests.cs
+++ b/src/Tasks.UnitTests/AssignCulture_Tests.cs
@@ -220,6 +220,3 @@ public void PseudoLocalization(string culture)
         }
     }
 }
-
-
-
diff --git a/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs b/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
index 721e3c3b6a0..07fadfaaf21 100644
--- a/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
+++ b/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
@@ -194,6 +194,3 @@ private ITaskItem GetParentedTaskItem(string itemSpec, string linkMetadata = nul
         }
     }
 }
-
-
-
diff --git a/src/Tasks.UnitTests/AssignTargetPath_Tests.cs b/src/Tasks.UnitTests/AssignTargetPath_Tests.cs
index 76ceb607817..3638a86206f 100644
--- a/src/Tasks.UnitTests/AssignTargetPath_Tests.cs
+++ b/src/Tasks.UnitTests/AssignTargetPath_Tests.cs
@@ -107,42 +107,5 @@ public void TargetPathAlreadySet(string targetPath)
             t.AssignedFiles.Length.ShouldBe(1);
             t.AssignedFiles[0].GetMetadata("TargetPath").ShouldBe(targetPath);
         }
-
-        [Theory]
-        [InlineData("c:/fully/qualified/path.txt")]
-        [InlineData("test/output/file.txt")]
-        [InlineData(@"some\dir\to\file.txt")]
-        [InlineData("file.txt")]
-        [InlineData("file")]
-        public void TargetPathAlreadySet_DisabledUnderChangeWave16_10(string targetPath)
-        {
-            using TestEnvironment env = TestEnvironment.Create();
-            string link = "c:/some/path";
-
-            ChangeWaves.ResetStateForTests();
-            env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave16_10.ToString());
-            BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-            AssignTargetPath t = new AssignTargetPath();
-            t.BuildEngine = new MockEngine();
-            Dictionary<string, string> metaData = new Dictionary<string, string>();
-            metaData.Add("TargetPath", targetPath);
-            metaData.Add("Link", link);
-            t.Files = new ITaskItem[]
-                          {
-                              new TaskItem(
-                                  itemSpec: NativeMethodsShared.IsWindows ? @"c:\f1\f2\file.txt" : "/f1/f2/file.txt",
-                                  itemMetadata: metaData)
-                          };
-            t.RootFolder = NativeMethodsShared.IsWindows ? @"c:\f1\f2" : "/f1/f2";
-
-            t.Execute().ShouldBeTrue();
-            t.AssignedFiles.Length.ShouldBe(1);
-            t.AssignedFiles[0].GetMetadata("TargetPath").ShouldBe(link);
-            ChangeWaves.ResetStateForTests();
-        }
     }
 }
-
-
-
diff --git a/src/Tasks.UnitTests/CSharpParserUtilitites_Tests.cs b/src/Tasks.UnitTests/CSharpParserUtilitites_Tests.cs
index 8d1d34cea06..fd6a6f4a794 100644
--- a/src/Tasks.UnitTests/CSharpParserUtilitites_Tests.cs
+++ b/src/Tasks.UnitTests/CSharpParserUtilitites_Tests.cs
@@ -422,6 +422,3 @@ private static void AssertParse(string source, string expectedClassName)
         }
     }
 }
-
-
-
diff --git a/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs b/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs
index 9f6ae464d25..26897d3ef06 100644
--- a/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs
+++ b/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs
@@ -446,6 +446,3 @@ int expectedLastLineNumber
         }
     }
 }
-
-
-
diff --git a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
index bf6fc63eb77..4a7d4708b26 100644
--- a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
+++ b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
@@ -1168,4 +1168,3 @@ public void CodeTaskFactoryNotSupported()
     }
 #endif
 }
-
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 997076c3bee..12705101c88 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -822,9 +822,11 @@ public void DoRetryWhenDestinationLocked()
                     engine.AssertLogContains("MSB3021"); // copy failed
                     engine.AssertLogContains("MSB3026"); // DID retry
 
-#if !RUNTIME_TYPE_NETCORE && !MONO
-                    engine.AssertLogContains(Process.GetCurrentProcess().Id.ToString()); // the file is locked by the current process
-#endif
+                    if (NativeMethodsShared.IsWindows)
+                    {
+                        engine.AssertLogContains(Process.GetCurrentProcess().Id.ToString()); // the file is locked by the current process
+                    }
+
                     Assert.Equal(2, engine.Errors); // retries failed and the actual failure
                     Assert.Equal(10, engine.Warnings);
                 }
diff --git a/src/Tasks.UnitTests/CreateItem_Tests.cs b/src/Tasks.UnitTests/CreateItem_Tests.cs
index 3092c041e8a..b82f1f4af7e 100644
--- a/src/Tasks.UnitTests/CreateItem_Tests.cs
+++ b/src/Tasks.UnitTests/CreateItem_Tests.cs
@@ -300,6 +300,7 @@ public void WildcardDriveEnumerationTaskItemLogsError(string itemSpec)
                     t.Execute().ShouldBeFalse();
                     engine.Errors.ShouldBe(1);
                     engine.AssertLogContains("MSB5029");
+                    engine.AssertLogContains(engine.ProjectFileOfTaskNode);
                 }
                 finally
                 {
@@ -353,6 +354,7 @@ private static void VerifyDriveEnumerationWarningLoggedUponCreateItemExecution(s
                     t.Execute().ShouldBeTrue();
                     engine.Warnings.ShouldBe(1);
                     engine.AssertLogContains("MSB5029");
+                    engine.AssertLogContains(engine.ProjectFileOfTaskNode);
                 }
                 finally
                 {
diff --git a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
index 2d68f17cc3f..4fffa6e0379 100644
--- a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
@@ -721,6 +721,3 @@ private void AssertSimpleCase(string code, string expected)
         }
     }
 }
-
-
-
diff --git a/src/Tasks.UnitTests/Culture_Tests.cs b/src/Tasks.UnitTests/Culture_Tests.cs
index 0a3863c1b9b..08383580b20 100644
--- a/src/Tasks.UnitTests/Culture_Tests.cs
+++ b/src/Tasks.UnitTests/Culture_Tests.cs
@@ -53,6 +53,3 @@ public void BogusEmbeddedCulture()
         }
     }
 }
-
-
-
diff --git a/src/Tasks.UnitTests/Delete_Tests.cs b/src/Tasks.UnitTests/Delete_Tests.cs
index 4a2365c5da7..31cadf2bb69 100644
--- a/src/Tasks.UnitTests/Delete_Tests.cs
+++ b/src/Tasks.UnitTests/Delete_Tests.cs
@@ -36,6 +36,3 @@ public void AttributeForwarding()
         }
     }
 }
-
-
-
diff --git a/src/Tasks.UnitTests/DirectoryBuildPropsImportTests.cs b/src/Tasks.UnitTests/DirectoryBuildPropsImportTests.cs
index 01cff53802c..762ce477248 100644
--- a/src/Tasks.UnitTests/DirectoryBuildPropsImportTests.cs
+++ b/src/Tasks.UnitTests/DirectoryBuildPropsImportTests.cs
@@ -22,4 +22,4 @@ sealed public class DirectoryBuildPropsImportTests : DirectoryBuildProjectImport
 
         protected override string ImportDirectoryBuildProjectPropertyName => "ImportDirectoryBuildProps";
     }
-}
\ No newline at end of file
+}
diff --git a/src/Tasks.UnitTests/DirectoryBuildTargetsImportTests.cs b/src/Tasks.UnitTests/DirectoryBuildTargetsImportTests.cs
index 1b065e5da1d..783538a0697 100644
--- a/src/Tasks.UnitTests/DirectoryBuildTargetsImportTests.cs
+++ b/src/Tasks.UnitTests/DirectoryBuildTargetsImportTests.cs
@@ -22,4 +22,4 @@ sealed public class DirectoryBuildTargetsImportTests : DirectoryBuildProjectImpo
 
         protected override string DirectoryBuildProjectBasePathPropertyName => "_DirectoryBuildTargetsBasePath";
     }
-}
\ No newline at end of file
+}
diff --git a/src/Tasks.UnitTests/ErrorWarningMessage_Tests.cs b/src/Tasks.UnitTests/ErrorWarningMessage_Tests.cs
index bc4cd625598..f99a7e8bb4e 100644
--- a/src/Tasks.UnitTests/ErrorWarningMessage_Tests.cs
+++ b/src/Tasks.UnitTests/ErrorWarningMessage_Tests.cs
@@ -356,6 +356,3 @@ public void ErrorFromResourcesNoResources()
         }
     }
 }
-
-
-
diff --git a/src/Tasks.UnitTests/Exec_Tests.cs b/src/Tasks.UnitTests/Exec_Tests.cs
index 72fe8006abd..3be6e26a45a 100644
--- a/src/Tasks.UnitTests/Exec_Tests.cs
+++ b/src/Tasks.UnitTests/Exec_Tests.cs
@@ -69,31 +69,6 @@ public void EscapeSpecifiedCharactersInPathToGeneratedBatchFile()
             }
         }
 
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "netcore-osx-failing")]
-        [Trait("Category", "netcore-linux-failing")]
-        public void EscapeSpecifiedCharactersInPathToGeneratedBatchFile_DisabledUnderChangeWave16_10()
-        {
-            using (var testEnvironment = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                testEnvironment.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave16_10.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                var newTempPath = testEnvironment.CreateNewTempPathWithSubfolder("hello()w]o(rld)").TempPath;
-
-                string tempPath = Path.GetTempPath();
-                Assert.StartsWith(newTempPath, tempPath);
-
-                // Now run the Exec task on a simple command.
-                Exec exec = PrepareExec("echo Hello World!");
-                exec.Execute().ShouldBeFalse();
-
-                ChangeWaves.ResetStateForTests();
-            }
-        }
-
         /// <summary>
         /// Ensures that calling the Exec task does not leave any extra TEMP files
         /// lying around.
@@ -1017,64 +992,6 @@ public void EndToEndMultilineExec_EscapeSpecialCharacters()
                 }
             }
         }
-
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "netcore-osx-failing")]
-        [Trait("Category", "netcore-linux-failing")]
-        public void EndToEndMultilineExec_EscapeSpecialCharacters_DisabledUnderChangeWave16_10()
-        {
-            using (var env = TestEnvironment.Create(_output))
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave16_10.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                var testProject = env.CreateTestProjectWithFiles(@"<Project>
-<Target Name=""ExecCommand"">
-  <Exec Command=""echo Hello, World!"" />
-   </Target>
-</Project>");
-
-                // Ensure path has subfolders
-                var newTempPath = env.CreateNewTempPathWithSubfolder("hello()wo(rld)").TempPath;
-                string tempPath = Path.GetTempPath();
-                Assert.StartsWith(newTempPath, tempPath);
-
-                using (var buildManager = new BuildManager())
-                {
-                    MockLogger logger = new MockLogger(_output, profileEvaluation: false, printEventsToStdout: false);
-
-                    var parameters = new BuildParameters()
-                    {
-                        Loggers = new[] { logger },
-                    };
-
-                    var collection = new ProjectCollection(
-                        new Dictionary<string, string>(),
-                        new[] { logger },
-                        remoteLoggers: null,
-                        ToolsetDefinitionLocations.Default,
-                        maxNodeCount: 1,
-                        onlyLogCriticalEvents: false,
-                        loadProjectsReadOnly: true);
-
-                    var project = collection.LoadProject(testProject.ProjectFile).CreateProjectInstance();
-
-                    var request = new BuildRequestData(
-                        project,
-                        targetsToBuild: new[] { "ExecCommand" },
-                        hostServices: null);
-
-                    var result = buildManager.Build(parameters, request);
-
-                    logger.AssertLogContains("Hello, World!");
-
-                    result.OverallResult.ShouldBe(BuildResultCode.Failure);
-                }
-                ChangeWaves.ResetStateForTests();
-            }
-        }
     }
 
     internal class ExecWrapper : Exec
@@ -1096,6 +1013,3 @@ public Encoding StdErrorEncoding
         }
     }
 }
-
-
-
diff --git a/src/Tasks.UnitTests/FileStateTests.cs b/src/Tasks.UnitTests/FileStateTests.cs
index 60f9d09e6d1..623fd213391 100644
--- a/src/Tasks.UnitTests/FileStateTests.cs
+++ b/src/Tasks.UnitTests/FileStateTests.cs
@@ -423,8 +423,3 @@ public void DoesNotExistParentFolderNotFound()
         }
     }
 }
-
-
-
-
-
diff --git a/src/Tasks.UnitTests/FindAppConfigFile_Tests.cs b/src/Tasks.UnitTests/FindAppConfigFile_Tests.cs
index 5da0446aff0..bdd9b209f10 100644
--- a/src/Tasks.UnitTests/FindAppConfigFile_Tests.cs
+++ b/src/Tasks.UnitTests/FindAppConfigFile_Tests.cs
@@ -96,4 +96,3 @@ public void ReturnsLastOne()
         }
     }
 }
-
diff --git a/src/Tasks.UnitTests/FindUnderPath_Tests.cs b/src/Tasks.UnitTests/FindUnderPath_Tests.cs
index cf599804d9a..ea2139737ec 100644
--- a/src/Tasks.UnitTests/FindUnderPath_Tests.cs
+++ b/src/Tasks.UnitTests/FindUnderPath_Tests.cs
@@ -141,6 +141,3 @@ public void VerifyFullPathNegative()
         }
     }
 }
-
-
-
diff --git a/src/Tasks.UnitTests/FormatUrl_Tests.cs b/src/Tasks.UnitTests/FormatUrl_Tests.cs
index 0a5b5ca0b96..84d83915f6f 100644
--- a/src/Tasks.UnitTests/FormatUrl_Tests.cs
+++ b/src/Tasks.UnitTests/FormatUrl_Tests.cs
@@ -208,4 +208,4 @@ public void UrlParentPathTest()
             t.OutputUrl.ShouldBe(@"https://example.com/Path");
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs b/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
index 7e33cb815c0..620cb08680b 100644
--- a/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
+++ b/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
@@ -136,6 +136,7 @@ public void WarnsWhenProjectReferenceHasNoPlatformOptions()
             // It will continue and have no NearestPlatform metadata.
             TaskItem projectReference = new TaskItem("foo.bar");
             projectReference.SetMetadata("Platforms", string.Empty);
+            projectReference.SetMetadata("Platform", string.Empty);
 
             GetCompatiblePlatform task = new GetCompatiblePlatform()
             {
@@ -201,5 +202,29 @@ public void WarnsOnInvalidFormatProjectReferenceLookupTable()
             task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe("x86");
             ((MockEngine)task.BuildEngine).AssertLogContains("MSB3983");
         }
+
+        // When `Platform` is retrieved in "GetTargetFrameworks" and that platform matches what's currently
+        // being built, build that project _without_ a global property for Platform.
+        [Theory]
+        [InlineData("x86;AnyCPU", "x64", "x64")] // Referenced platform matches current platform, build w/o global property
+        [InlineData("x64;x86;AnyCPU", "x64", "x64")] // Referenced platform overrides 'Platforms' being an option
+        public void PlatformIsChosenAsDefault(string referencedPlatforms, string referencedPlatform, string currentPlatform)
+        {
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", referencedPlatforms);
+            projectReference.SetMetadata("Platform", referencedPlatform);
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = currentPlatform,
+                AnnotatedProjects = new TaskItem[] { projectReference }
+            };
+
+            task.Execute().ShouldBeTrue();
+
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe(string.Empty);
+            task.Log.HasLoggedErrors.ShouldBeFalse();
+        }
     }
 }
diff --git a/src/Tasks.UnitTests/MakeDir_Tests.cs b/src/Tasks.UnitTests/MakeDir_Tests.cs
index 30d4a11db71..886d7a69aae 100644
--- a/src/Tasks.UnitTests/MakeDir_Tests.cs
+++ b/src/Tasks.UnitTests/MakeDir_Tests.cs
@@ -209,6 +209,3 @@ public void FileAlreadyExists()
         }
     }
 }
-
-
-
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index 4bf53a812a9..e0f20bd2eec 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -26,6 +26,7 @@
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
     <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
     <ProjectReference Include="..\Samples\PortableTask\PortableTask.csproj" ReferenceOutputAssembly="false" Private="false" />
+    <ProjectReference Include="..\Samples\Dependency\Dependency.csproj" ReferenceOutputAssembly="false" Private="false" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
diff --git a/src/Tasks.UnitTests/ProjectExtensionsPropsImportTest.cs b/src/Tasks.UnitTests/ProjectExtensionsPropsImportTest.cs
index b84648abced..567de6da99d 100644
--- a/src/Tasks.UnitTests/ProjectExtensionsPropsImportTest.cs
+++ b/src/Tasks.UnitTests/ProjectExtensionsPropsImportTest.cs
@@ -19,4 +19,4 @@ sealed public class ProjectExtensionsPropsImportTest : ProjectExtensionsImportTe
 
         protected override string PropertyNameToSignalImportSucceeded => "WasProjectExtensionPropsImported";
     }
-}
\ No newline at end of file
+}
diff --git a/src/Tasks.UnitTests/ProjectExtensionsTargetsImportTest.cs b/src/Tasks.UnitTests/ProjectExtensionsTargetsImportTest.cs
index 757d1a6c393..6ced7746b7d 100644
--- a/src/Tasks.UnitTests/ProjectExtensionsTargetsImportTest.cs
+++ b/src/Tasks.UnitTests/ProjectExtensionsTargetsImportTest.cs
@@ -19,4 +19,4 @@ sealed public class ProjectExtensionsTargetsImportTest : ProjectExtensionsImport
 
         protected override string PropertyNameToSignalImportSucceeded => "WasProjectExtensionTargetsImported";
     }
-}
\ No newline at end of file
+}
diff --git a/src/Tasks.UnitTests/RemoveDir_Tests.cs b/src/Tasks.UnitTests/RemoveDir_Tests.cs
index 2cff8ba1ca5..2becb7a889d 100644
--- a/src/Tasks.UnitTests/RemoveDir_Tests.cs
+++ b/src/Tasks.UnitTests/RemoveDir_Tests.cs
@@ -72,8 +72,32 @@ public void SimpleDelete()
                 }
             }
         }
-    }
-}
 
+        /// <summary>
+        /// Regression test: https://github.com/dotnet/msbuild/issues/7563
+        /// </summary>
+        [Fact]
+        public void DeleteEmptyDirectory_WarnsAndContinues()
+        {
 
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+               List<TaskItem> list = new List<TaskItem>();
 
+                for (int i = 0; i < 20; i++)
+               {
+                    list.Add(new TaskItem(""));
+               }
+
+               RemoveDir t = new RemoveDir();
+               t.Directories = list.ToArray();
+               t.BuildEngine = new MockEngine(_output);
+               t.Execute().ShouldBeTrue();
+
+                t.RemovedDirectories.Length.ShouldBe(0);
+                ((MockEngine)t.BuildEngine).Warnings.ShouldBe(20);
+               ((MockEngine)t.BuildEngine).AssertLogContains("MSB3232");
+            }
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/ResolveVCProjectOutput_Tests.cs b/src/Tasks.UnitTests/ResolveVCProjectOutput_Tests.cs
index bafba3d8fac..1dd312a7790 100644
--- a/src/Tasks.UnitTests/ResolveVCProjectOutput_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveVCProjectOutput_Tests.cs
@@ -2128,4 +2128,4 @@ public void ResolveManagedDllOutputsManagedExtensionsOverridenInFiles()
         }
     }
 }
-*/
\ No newline at end of file
+*/
diff --git a/src/Tasks.UnitTests/ResourceHandling/MSBuildResXReader_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/MSBuildResXReader_Tests.cs
index b7c228a2109..ed712777dd1 100644
--- a/src/Tasks.UnitTests/ResourceHandling/MSBuildResXReader_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/MSBuildResXReader_Tests.cs
@@ -37,6 +37,45 @@ public void ParsesSingleStringAsString()
             AssertSingleStringResource(resxWithSingleString, "StringResource", "StringValue");
         }
 
+        [Fact]
+        public void ParsesSingleStringWithoutPreserveAsString()
+        {
+            var resxWithSingleString = MSBuildResXReader.GetResourcesFromString(
+                ResXHelper.SurroundWithBoilerplate(
+                    @"<data name=""StringResource"">
+    <value> StringValue </value>
+    <comment>Comment</comment>
+  </data>"));
+
+            AssertSingleStringResource(resxWithSingleString, "StringResource", " StringValue ");
+        }
+
+        [Fact]
+        public void ParsesSingleWhitespaceStringAsString()
+        {
+            var resxWithSingleString = MSBuildResXReader.GetResourcesFromString(
+                ResXHelper.SurroundWithBoilerplate(
+                    @"<data name=""StringResource"" xml:space=""preserve"">
+    <value> </value>
+    <comment>Comment</comment>
+  </data>"));
+
+            AssertSingleStringResource(resxWithSingleString, "StringResource", " ");
+        }
+
+        [Fact]
+        public void ParsesSingleWhitespaceStringWithNoPreserveAsEmptyString()
+        {
+            var resxWithSingleString = MSBuildResXReader.GetResourcesFromString(
+                ResXHelper.SurroundWithBoilerplate(
+                    @"<data name=""StringResource"">
+    <value> </value>
+    <comment>Comment</comment>
+  </data>"));
+
+            AssertSingleStringResource(resxWithSingleString, "StringResource", "");
+        }
+
         [Fact]
         public void ParsesSingleStringWithPartialTypeName()
         {
diff --git a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
index a87f30daff6..7dbf9e846f2 100644
--- a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
@@ -4,10 +4,18 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
+using System.Reflection;
 using System.Text.RegularExpressions;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
+using Microsoft.Build.UnitTests.Shared;
 using Microsoft.Build.Utilities;
+#if NETFRAMEWORK
+using Microsoft.IO;
+#else
+using System.IO;
+#endif
 using Shouldly;
 using Xunit;
 
@@ -19,6 +27,108 @@ public class RoslynCodeTaskFactory_Tests
     {
         private const string TaskName = "MyInlineTask";
 
+        [Fact]
+        public void InlineTaskWithAssemblyPlatformAgnostic()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = env.CreateFolder(createFolder: true);
+                string location = Assembly.GetExecutingAssembly().Location;
+                TransientTestFile inlineTask = env.CreateFile(folder, "5106.proj", @$"
+<Project>
+
+  <UsingTask TaskName=""MyInlineTask"" TaskFactory=""RoslynCodeTaskFactory"" AssemblyFile=""$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll"">
+    <Task>
+      <Reference Include=""" + Path.Combine(Path.GetDirectoryName(location), "..", "..", "..", "Samples", "Dependency",
+#if DEBUG
+      "Debug"
+#else
+      "Release"
+#endif
+      , "net472", "Dependency.dll") + @""" />
+      <Using Namespace=""Dependency"" />
+      <Code Type=""Fragment"" Language=""cs"" >
+<![CDATA[
+Log.LogError(Alpha.GetString());
+]]>
+      </Code>
+    </Task>
+  </UsingTask>
+
+<Target Name=""ToRun"">
+  <MyInlineTask/>
+</Target>
+
+</Project>
+");
+                string output = RunnerUtilities.ExecMSBuild(inlineTask.Path, out bool success);
+                success.ShouldBeTrue(output);
+                output.ShouldContain("Alpha.GetString");
+            }
+        }
+
+        [Fact]
+        [SkipOnPlatform(TestPlatforms.AnyUnix, ".NETFramework 4.0 isn't on unix machines.")]
+        public void InlineTaskWithAssembly()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = env.CreateFolder(createFolder: true);
+                TransientTestFile assemblyProj = env.CreateFile(folder, "5106.csproj", @$"
+                    <Project DefaultTargets=""Build"">
+                        <PropertyGroup>
+                            <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
+                            <OutputType>Library</OutputType>
+                        </PropertyGroup>
+                        <ItemGroup>
+                            <Reference Include=""System""/>
+                            <Compile Include=""Class1.cs""/>
+                        </ItemGroup>
+                        <Import Project=""$(MSBuildBinPath)\Microsoft.CSharp.targets"" />
+                    </Project>
+");
+                TransientTestFile csFile = env.CreateFile(folder, "Class1.cs", @"
+using System;
+
+namespace _5106 {
+    public class Class1 {
+        public static string ToPrint() {
+            return ""Hello!"";
+        }
+    }
+}
+");
+                string output = RunnerUtilities.ExecMSBuild(assemblyProj.Path + $" /p:OutDir={Path.Combine(folder.Path, "subFolder")} /restore", out bool success);
+                success.ShouldBeTrue(output);
+
+                TransientTestFile inlineTask = env.CreateFile(folder, "5106.proj", @$"
+<Project>
+
+  <UsingTask TaskName=""MyInlineTask"" TaskFactory=""RoslynCodeTaskFactory"" AssemblyFile=""$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll"">
+    <Task>
+      <Reference Include=""{Path.Combine(folder.Path, "subFolder", "5106.dll")}"" />
+      <Reference Include=""netstandard"" />
+      <Using Namespace=""_5106"" />
+      <Code Type=""Fragment"" Language=""cs"" >
+<![CDATA[
+Log.LogError(Class1.ToPrint());
+]]>
+      </Code>
+    </Task>
+  </UsingTask>
+
+<Target Name=""ToRun"">
+  <MyInlineTask/>
+</Target>
+
+</Project>
+");
+                output = RunnerUtilities.ExecMSBuild(inlineTask.Path, out success);
+                success.ShouldBeTrue();
+                output.ShouldContain("Hello!");
+            }
+        }
+
         [Fact]
         public void RoslynCodeTaskFactory_ReuseCompilation()
         {
@@ -96,8 +206,12 @@ public void VisualBasicFragment()
             const string fragment = "Dim x = 0";
             string expectedSourceCode = $@"'------------------------------------------------------------------------------
 ' <auto-generated>
-'     This code was generated by a tool.
-'     Runtime Version:4.0.30319.42000
+'     This code was generated by a tool." +
+#if NETFRAMEWORK
+@"
+'     Runtime Version:4.0.30319.42000" +
+#endif
+@$"
 '
 '     Changes to this file may cause incorrect behavior and will be lost if
 '     the code is regenerated.
@@ -164,8 +278,12 @@ public void VisualBasicFragmentWithProperties()
             string expectedSourceCode = $@"'------------------------------------------------------------------------------
 ' <auto-generated>
 '     This code was generated by a tool.
-'     Runtime Version:4.0.30319.42000
-'
+" +
+#if NETFRAMEWORK
+@"'     Runtime Version:4.0.30319.42000
+" +
+#endif
+@$"'
 '     Changes to this file may cause incorrect behavior and will be lost if
 '     the code is regenerated.
 ' </auto-generated>
@@ -281,8 +399,12 @@ Return True
             string expectedSourceCode = $@"'------------------------------------------------------------------------------
 ' <auto-generated>
 '     This code was generated by a tool.
-'     Runtime Version:4.0.30319.42000
-'
+" +
+#if NETFRAMEWORK
+@"'     Runtime Version:4.0.30319.42000
+" +
+#endif
+@$"'
 '     Changes to this file may cause incorrect behavior and will be lost if
 '     the code is regenerated.
 ' </auto-generated>
@@ -353,8 +475,12 @@ public void CSharpFragment()
             string expectedSourceCode = $@"//------------------------------------------------------------------------------
 // <auto-generated>
 //     This code was generated by a tool.
-//     Runtime Version:4.0.30319.42000
-//
+" +
+#if NETFRAMEWORK
+@"//     Runtime Version:4.0.30319.42000
+" +
+#endif
+$@"//
 //     Changes to this file may cause incorrect behavior and will be lost if
 //     the code is regenerated.
 // </auto-generated>
@@ -411,8 +537,12 @@ public void CSharpFragmentWithProperties()
             string expectedSourceCode = $@"//------------------------------------------------------------------------------
 // <auto-generated>
 //     This code was generated by a tool.
-//     Runtime Version:4.0.30319.42000
-//
+" +
+#if NETFRAMEWORK
+@"//     Runtime Version:4.0.30319.42000
+" +
+#endif
+$@"//
 //     Changes to this file may cause incorrect behavior and will be lost if
 //     the code is regenerated.
 // </auto-generated>
@@ -520,8 +650,12 @@ public void CSharpMethod()
             string expectedSourceCode = $@"//------------------------------------------------------------------------------
 // <auto-generated>
 //     This code was generated by a tool.
-//     Runtime Version:4.0.30319.42000
-//
+" +
+#if NETFRAMEWORK
+@"//     Runtime Version:4.0.30319.42000
+" +
+#endif
+@$"//
 //     Changes to this file may cause incorrect behavior and will be lost if
 //     the code is regenerated.
 // </auto-generated>
@@ -757,7 +891,6 @@ private void TryLoadTaskBodyAndExpectSuccess(
             IReadOnlyList<string> expectedWarningMessages = null)
         {
             MockEngine buildEngine = new MockEngine();
-            
 
             TaskLoggingHelper log = new TaskLoggingHelper(buildEngine, TaskName)
             {
diff --git a/src/Tasks.UnitTests/StreamMappedString_Tests.cs b/src/Tasks.UnitTests/StreamMappedString_Tests.cs
index 90b8fcccfd7..544c7eed446 100644
--- a/src/Tasks.UnitTests/StreamMappedString_Tests.cs
+++ b/src/Tasks.UnitTests/StreamMappedString_Tests.cs
@@ -339,8 +339,3 @@ public override void Write(byte[] buffer, int offset, int count)
         }
     }
 }
-
-
-
-
-
diff --git a/src/Tasks.UnitTests/Touch_Tests.cs b/src/Tasks.UnitTests/Touch_Tests.cs
index 800a120a6db..5ebc57b915e 100644
--- a/src/Tasks.UnitTests/Touch_Tests.cs
+++ b/src/Tasks.UnitTests/Touch_Tests.cs
@@ -339,6 +339,3 @@ public void TouchNonExistingDirectoryDoesntExist()
         }
     }
 }
-
-
-
diff --git a/src/Tasks.UnitTests/VisualBasicParserUtilitites_Tests.cs b/src/Tasks.UnitTests/VisualBasicParserUtilitites_Tests.cs
index 9769bba27fc..8b4f52d62dc 100644
--- a/src/Tasks.UnitTests/VisualBasicParserUtilitites_Tests.cs
+++ b/src/Tasks.UnitTests/VisualBasicParserUtilitites_Tests.cs
@@ -119,6 +119,3 @@ private static void AssertParse(string source, string expectedClassName)
         }
     }
 }
-
-
-
diff --git a/src/Tasks.UnitTests/VisualBasicTokenizer_Tests.cs b/src/Tasks.UnitTests/VisualBasicTokenizer_Tests.cs
index 2f45420e496..61d39ccfee6 100644
--- a/src/Tasks.UnitTests/VisualBasicTokenizer_Tests.cs
+++ b/src/Tasks.UnitTests/VisualBasicTokenizer_Tests.cs
@@ -302,6 +302,3 @@ int expectedLastLineNumber
         }
     }
 }
-
-
-
diff --git a/src/Tasks.UnitTests/WinMDExp_Tests.cs b/src/Tasks.UnitTests/WinMDExp_Tests.cs
index 55a5aae8bc9..437c7704471 100644
--- a/src/Tasks.UnitTests/WinMDExp_Tests.cs
+++ b/src/Tasks.UnitTests/WinMDExp_Tests.cs
@@ -143,8 +143,3 @@ public void ArgumentsAreUnquoted()
         }
     }
 }
-
-
-
-
-
diff --git a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
index 5898a23ceb0..b1cf9ff948b 100644
--- a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
+++ b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
@@ -1111,6 +1111,3 @@ private static void CheckContent(string actualContent, string[] expectedAttribut
         }
     }
 }
-
-
-
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigCache.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigCache.cs
index 2862fbcce01..1cc90184eac 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigCache.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigCache.cs
@@ -66,4 +66,4 @@ internal bool FileExists(string path)
             return _useOriginalFileExists ? _fileExists(path) : _filesInDirectories.Contains(path);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
index 7611767ca12..afeaeb68a3e 100644
--- a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
+++ b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.IO;
-using System.Text;
 using System.Runtime.InteropServices;
 using Microsoft.Build.Shared;
 using System.Collections.Generic;
@@ -11,6 +10,7 @@
 using System.Reflection;
 using Microsoft.Build.Framework;
 using System.Collections.Concurrent;
+using System.Runtime.Versioning;
 
 #nullable disable
 
@@ -97,6 +97,7 @@ private static string GetLocationImpl(AssemblyNameExtension assemblyName, string
         /// <summary>
         /// Given a strong name generate the gac enumerator.
         /// </summary>
+        [SupportedOSPlatform("windows")]
         internal static IEnumerable<AssemblyNameExtension> GetGacNativeEnumerator(string strongName)
         {
             try
diff --git a/src/Tasks/AssignTargetPath.cs b/src/Tasks/AssignTargetPath.cs
index 10ede5e6a1a..48079383cd6 100644
--- a/src/Tasks/AssignTargetPath.cs
+++ b/src/Tasks/AssignTargetPath.cs
@@ -77,7 +77,7 @@ public override bool Execute()
 
                     // If TargetPath is already set, it takes priority.
                     // https://github.com/dotnet/msbuild/issues/2795
-                    string targetPath =  ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10) ? Files[i].GetMetadata(ItemMetadataNames.targetPath) : null;
+                    string targetPath = Files[i].GetMetadata(ItemMetadataNames.targetPath);
 
                     // If TargetPath not already set, fall back to default behavior.
                     if (string.IsNullOrEmpty(targetPath))
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index a7883735288..fff6c863cf8 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -1,4 +1,4 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
@@ -899,20 +899,22 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
         private static string GetLockedFileMessage(string file)
         {
             string message = string.Empty;
-#if !RUNTIME_TYPE_NETCORE && !MONO
 
             try
             {
-                var processes = LockCheck.GetProcessesLockingFile(file);
-                message = !string.IsNullOrEmpty(processes)
-                    ? ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("Copy.FileLocked", processes)
-                    : String.Empty;
+                if (NativeMethodsShared.IsWindows && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+                {
+                    var processes = LockCheck.GetProcessesLockingFile(file);
+                    message = !string.IsNullOrEmpty(processes)
+                        ? ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("Copy.FileLocked", processes)
+                        : String.Empty;
+                }
             }
             catch (Exception)
             {
                 // Never throw if we can't get the processes locking the file.
             }
-#endif
+
             return message;
         }
 
diff --git a/src/Tasks/CreateItem.cs b/src/Tasks/CreateItem.cs
index 8f2ef0163ff..2ab2cf25397 100644
--- a/src/Tasks/CreateItem.cs
+++ b/src/Tasks/CreateItem.cs
@@ -153,7 +153,8 @@ private List<ITaskItem> CreateOutputItems(Dictionary<string, string> metadataTab
                     "WildcardResultsInDriveEnumeration",
                     EscapingUtilities.UnescapeAll(fileSpec),
                     attributeType,
-                    CreateItemTask);
+                    CreateItemTask,
+                    BuildEngine.ProjectFileOfTaskNode);
             }
             else if (searchAction == FileMatcher.SearchAction.FailOnDriveEnumeratingWildcard)
             {
@@ -161,7 +162,8 @@ private List<ITaskItem> CreateOutputItems(Dictionary<string, string> metadataTab
                     "WildcardResultsInDriveEnumeration",
                     EscapingUtilities.UnescapeAll(fileSpec),
                     attributeType,
-                    CreateItemTask);
+                    CreateItemTask,
+                    BuildEngine.ProjectFileOfTaskNode);
             }
 
             return (expand, !Log.HasLoggedErrors);
diff --git a/src/Tasks/CultureInfoCache.cs b/src/Tasks/CultureInfoCache.cs
index a5c52d41275..61733113873 100644
--- a/src/Tasks/CultureInfoCache.cs
+++ b/src/Tasks/CultureInfoCache.cs
@@ -921,4 +921,3 @@ internal static bool IsValidCultureString(string name)
 #endif
     }
 }
-
diff --git a/src/Tasks/DownloadFile.cs b/src/Tasks/DownloadFile.cs
index 5192719aa13..c36685242c8 100644
--- a/src/Tasks/DownloadFile.cs
+++ b/src/Tasks/DownloadFile.cs
@@ -60,6 +60,11 @@ public sealed class DownloadFile : TaskExtension, ICancelableTask
         [Required]
         public string SourceUrl { get; set; }
 
+        /// <summary>
+        /// Gets or sets the number of milliseconds to wait before the request times out.
+        /// </summary>
+        public int Timeout { get; set; } = 100_000;
+
         /// <summary>
         /// Gets or sets a <see cref="HttpMessageHandler"/> to use.  This is used by unit tests to mock a connection to a remote server.
         /// </summary>
@@ -137,7 +142,7 @@ private async Task<bool> ExecuteAsync()
         private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)
         {
             // The main reason to use HttpClient vs WebClient is because we can pass a message handler for unit tests to mock
-            using (var client = new HttpClient(HttpMessageHandler ?? new HttpClientHandler(), disposeHandler: true))
+            using (var client = new HttpClient(HttpMessageHandler ?? new HttpClientHandler(), disposeHandler: true) { Timeout = TimeSpan.FromMilliseconds(Timeout) })
             {
                 // Only get the response without downloading the file so we can determine if the file is already up-to-date
                 using (HttpResponseMessage response = await client.GetAsync(uri, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false))
diff --git a/src/Tasks/Exec.cs b/src/Tasks/Exec.cs
index d4773311288..c05a3afb682 100644
--- a/src/Tasks/Exec.cs
+++ b/src/Tasks/Exec.cs
@@ -606,45 +606,31 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens
                     }
                     commandLine.AppendSwitch("/C"); // run then terminate
 
-                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10))
+                    StringBuilder fileName = null;
+
+                    // Escape special characters that need to be escaped.
+                    for (int i = 0; i < batchFileForCommandLine.Length; i++)
                     {
-                        StringBuilder fileName = null;
+                        char c = batchFileForCommandLine[i];
 
-                        // Escape special characters that need to be escaped.
-                        for (int i = 0; i < batchFileForCommandLine.Length; i++)
+                        if (ShouldEscapeCharacter(c) && (i == 0 || batchFileForCommandLine[i - 1] != '^'))
                         {
-                            char c = batchFileForCommandLine[i];
-
-                            if (ShouldEscapeCharacter(c) && (i == 0 || batchFileForCommandLine[i - 1] != '^'))
+                            // Avoid allocating a new string until we know we have something to escape.
+                            if (fileName == null)
                             {
-                                // Avoid allocating a new string until we know we have something to escape.
-                                if (fileName == null)
-                                {
-                                    fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);
-                                    fileName.Append(batchFileForCommandLine, 0, i);
-                                }
-
-                                fileName.Append('^');
+                                fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);
+                                fileName.Append(batchFileForCommandLine, 0, i);
                             }
 
-                            fileName?.Append(c);
+                            fileName.Append('^');
                         }
 
-                        if (fileName != null)
-                        {
-                            batchFileForCommandLine = StringBuilderCache.GetStringAndRelease(fileName);
-                        }
+                        fileName?.Append(c);
                     }
-                    else
+
+                    if (fileName != null)
                     {
-                        // If for some crazy reason the path has a & character and a space in it
-                        // then get the short path of the temp path, which should not have spaces in it
-                        // and then escape the &
-                        if (batchFileForCommandLine.Contains("&") && !batchFileForCommandLine.Contains("^&"))
-                        {
-                            batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);
-                            batchFileForCommandLine = batchFileForCommandLine.Replace("&", "^&");
-                        }
+                        batchFileForCommandLine = StringBuilderCache.GetStringAndRelease(fileName);
                     }
                 }
 
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 8d14a11f700..87e92685ed8 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -40,9 +40,7 @@
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.ResourceHandling;
 using Microsoft.Build.Utilities;
-#if FEATURE_COM_INTEROP
 using Microsoft.Win32;
-#endif
 
 #nullable disable
 
@@ -907,7 +905,6 @@ public override bool Execute()
             return !Log.HasLoggedErrors && outOfProcExecutionSucceeded;
         }
 
-#if FEATURE_COM_INTEROP
         private static readonly bool AllowMOTW = !NativeMethodsShared.IsWindows || (Registry.GetValue(@"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\SDK", "AllowProcessOfUntrustedResourceFiles", null) is string allowUntrustedFiles && allowUntrustedFiles.Equals("true", StringComparison.OrdinalIgnoreCase));
 
         private const string CLSID_InternetSecurityManager = "7b8a2d94-0ac9-11d1-896c-00c04fb6bfc4";
@@ -919,7 +916,7 @@ public override bool Execute()
         private bool IsDangerous(String filename)
         {
             // If they are opted out, there's no work to do
-            if (AllowMOTW)
+            if (AllowMOTW || !NativeMethodsShared.IsWindows)
             {
                 return false;
             }
@@ -991,12 +988,6 @@ private bool IsDangerous(String filename)
 
             return dangerous;
         }
-#else
-        private bool IsDangerous(String filename)
-        {
-            return false;
-        }
-#endif
 
 #if FEATURE_APPDOMAIN
         /// <summary>
diff --git a/src/Tasks/GetCompatiblePlatform.cs b/src/Tasks/GetCompatiblePlatform.cs
index f2b823767fd..9787b51e366 100644
--- a/src/Tasks/GetCompatiblePlatform.cs
+++ b/src/Tasks/GetCompatiblePlatform.cs
@@ -51,69 +51,17 @@ public GetCompatiblePlatform()
 
         public override bool Execute()
         {
-            Dictionary<string, string>? currentProjectLookupTable = ExtractLookupTable(PlatformLookupTable);
-
+            
             AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];
             for (int i = 0; i < AnnotatedProjects.Length; i++)
             {
                 AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);
 
-                string projectReferencePlatformMetadata = AssignedProjectsWithPlatform[i].GetMetadata("Platforms");
-
-                if (string.IsNullOrEmpty(projectReferencePlatformMetadata))
-                {
-                    Log.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoPlatformsListed", AssignedProjectsWithPlatform[i].ItemSpec);
-                    continue;
-                }
-
+                string referencedProjectPlatform = AssignedProjectsWithPlatform[i].GetMetadata("Platform");
+                string projectReferencePlatformsMetadata = AssignedProjectsWithPlatform[i].GetMetadata("Platforms");
                 string projectReferenceLookupTableMetadata = AssignedProjectsWithPlatform[i].GetMetadata("PlatformLookupTable");
-                // Pull platformlookuptable metadata from the referenced project. This allows custom
-                // mappings on a per-ProjectReference basis.
-                Dictionary<string, string>? projectReferenceLookupTable = ExtractLookupTable(projectReferenceLookupTableMetadata);
-
-                HashSet<string> projectReferencePlatforms = new HashSet<string>();
-                foreach (string s in projectReferencePlatformMetadata.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
-                {
-                    projectReferencePlatforms.Add(s);
-                }
-
-                string buildProjectReferenceAs = string.Empty;
 
-                // Prefer matching platforms
-                if (projectReferencePlatforms.Contains(CurrentProjectPlatform))
-                {
-                    buildProjectReferenceAs = CurrentProjectPlatform;
-                    Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.SamePlatform");
-                }
-                // Prioritize PlatformLookupTable **metadata** attached to the ProjectReference item
-                // before the current project's table. We do this to allow per-ProjectReference fine tuning.
-                else if (projectReferenceLookupTable != null &&
-                        projectReferenceLookupTable.ContainsKey(CurrentProjectPlatform) &&
-                        projectReferencePlatforms.Contains(projectReferenceLookupTable[CurrentProjectPlatform]))
-                {
-                    buildProjectReferenceAs = projectReferenceLookupTable[CurrentProjectPlatform];
-                    Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", CurrentProjectPlatform, buildProjectReferenceAs, projectReferenceLookupTableMetadata);
-                }
-                // Current project's translation table follows
-                else if (currentProjectLookupTable != null &&
-                        currentProjectLookupTable.ContainsKey(CurrentProjectPlatform) &&
-                        projectReferencePlatforms.Contains(currentProjectLookupTable[CurrentProjectPlatform]))
-                {
-                    buildProjectReferenceAs = currentProjectLookupTable[CurrentProjectPlatform];
-                    Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", CurrentProjectPlatform, buildProjectReferenceAs, PlatformLookupTable);
-                }
-                // AnyCPU if possible
-                else if (projectReferencePlatforms.Contains("AnyCPU"))
-                {
-                    buildProjectReferenceAs = "AnyCPU";
-                    Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.AnyCPUDefault");
-                }
-                else
-                {
-                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine 
-                    // Platform/PlatformTarget when this is the case.
-                    Log.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoCompatiblePlatformFound", AssignedProjectsWithPlatform[i].ItemSpec);
-                }
+                string? buildProjectReferenceAs = PlatformNegotiation.GetNearestPlatform(referencedProjectPlatform, projectReferencePlatformsMetadata, projectReferenceLookupTableMetadata, PlatformLookupTable, AssignedProjectsWithPlatform[i].ItemSpec, CurrentProjectPlatform, Log);
 
                 AssignedProjectsWithPlatform[i].SetMetadata("NearestPlatform", buildProjectReferenceAs);
                 Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.DisplayChosenPlatform", AssignedProjectsWithPlatform[i].ItemSpec, buildProjectReferenceAs);
@@ -121,33 +69,5 @@ public override bool Execute()
 
             return !Log.HasLoggedErrors;
         }
-
-        private Dictionary<string, string>? ExtractLookupTable(string stringTable)
-        {
-            if (string.IsNullOrEmpty(stringTable))
-            {
-                return null;
-            }
-
-            Dictionary<string, string> table = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-
-            foreach (string s in stringTable.Trim().Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
-            {
-                string[] keyVal = s.Trim().Split(MSBuildConstants.EqualsChar);
-
-                // Invalid table, don't use it.
-                if (keyVal.Length != 2 || string.IsNullOrEmpty(keyVal[0]) || string.IsNullOrEmpty(keyVal[1]))
-                {
-                    Log.LogWarningWithCodeFromResources("GetCompatiblePlatform.InvalidLookupTableFormat", stringTable);
-                    return null;
-                }
-
-                table[keyVal[0]] = keyVal[1];
-            }
-
-            Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.LookupTableParsed", stringTable);
-
-            return table;
-        }
     }
 }
diff --git a/src/Tasks/LockCheck.cs b/src/Tasks/LockCheck.cs
index 9ef5cdd62d8..fd499d4bc93 100644
--- a/src/Tasks/LockCheck.cs
+++ b/src/Tasks/LockCheck.cs
@@ -1,19 +1,19 @@
 ﻿// Taken from https://github.com/cklutz/LockCheck, MIT license.
 // Copyright (C) Christian Klutz
 
-#if !RUNTIME_TYPE_NETCORE && !MONO
-
 using System;
 using System.Collections.Generic;
 using System.ComponentModel;
 using System.Linq;
 using System.Runtime.InteropServices;
+using System.Runtime.Versioning;
 using System.Text;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+    [SupportedOSPlatform("windows")]
     internal class LockCheck
     {
         [Flags]
@@ -355,5 +355,3 @@ private static Exception GetException(int res, string apiName, string message)
         }
     }
 }
-
-#endif
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index 8d0d9fbf267..a5404f5b920 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -1390,4 +1390,3 @@ internal X509Chain TimestamperChain
         }
     }
 }
-
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 96ff4e3a91b..c08a5129001 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -191,6 +191,10 @@
     <Compile Include="..\Shared\LanguageParser\VisualBasictokenizer.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Shared\PlatformNegotiation.cs">
+      <Link>PlatformNegotiation.cs</Link>
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="..\Shared\XMakeAttributes.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -375,6 +379,7 @@
     <Compile Include="GetReferenceAssemblyPaths.cs" />
     <Compile Include="Hash.cs" />
     <Compile Include="InstalledSDKResolver.cs" />
+    <Compile Include="Interop.cs" />
     <Compile Include="ErrorFromResources.cs" />
     <Compile Include="ExtractedClassName.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
@@ -604,9 +609,6 @@
     <Compile Include="IComReferenceResolver.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="Interop.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="ManifestUtil\CngLightup.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -976,7 +978,7 @@
   </ItemGroup>
 
   <!-- Mimics AddRefAssemblies from MSBuild.csproj -->
-  <Target Name="AddRefAssemblies" 
+  <Target Name="AddRefAssemblies"
           DependsOnTargets="ResolveAssemblyReferences"
           BeforeTargets="AssignTargetPaths">
     <ItemGroup>
@@ -999,6 +1001,10 @@
     <Content Include="$(NuGetPackageRoot)microsoft.net.compilers.toolset\$(MicrosoftNetCompilersToolsetVersion)\tasks\net472\**\*" CopyToOutputDirectory="PreserveNewest" LinkBase="Roslyn" />
   </ItemGroup>
 
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
+    <PackageReference Include="Microsoft.Win32.Registry" />
+  </ItemGroup>
+
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
     <PackageReference Include="System.CodeDom" />
     <PackageReference Include="System.Reflection.Metadata" />
@@ -1007,9 +1013,6 @@
     <PackageReference Include="System.Security.Permissions" />
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
 
-    <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
-    <PackageReference Include="Microsoft.Win32.Registry" />
-
     <Content Include="$(NuGetPackageRoot)microsoft.net.compilers.toolset\$(MicrosoftNetCompilersToolsetVersion)\tasks\net6.0\**\*" CopyToOutputDirectory="PreserveNewest" LinkBase="Roslyn" />
   </ItemGroup>
 
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index 7eb75f9f283..13d74133003 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -49,6 +49,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <!-- Extract necessary information for SetPlatform negotiation -->
         <!-- This target does not run for cpp projects. -->
         <IsVcxOrNativeProj>false</IsVcxOrNativeProj>
+        <Platform Condition="$([MSBuild]::AreFeaturesEnabled('17.4'))">$(Platform)</Platform>
         <Platforms>$(Platforms)</Platforms>
       </_ThisProjectBuildMetadata>
     </ItemGroup>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 688da12288b..7b51494d4ed 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1888,6 +1888,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <IsRidAgnostic Condition=" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
         <!-- Extract necessary information for SetPlatform negotiation -->
         <IsVcxOrNativeProj Condition="'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'">true</IsVcxOrNativeProj>
+        <Platform Condition="$([MSBuild]::AreFeaturesEnabled('17.4'))">$(Platform)</Platform>
         <Platforms>$(Platforms)</Platforms>
         <!-- .vcxproj and .nativeproj contain a `ProjectConfiguration` item that have `Platform` metadata within.
              Build the `Platforms` property from that. -->
@@ -6111,7 +6112,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <!-- This item represents the native manifest, example: WindowsApplication1.exe.manifest or Native.ClassLibrary1.manifest -->
     <ItemGroup>
-      <_BuiltProjectOutputGroupOutputIntermediate Include="$(OutDir)$(_DeploymentTargetApplicationManifestFileName)" Condition="'@(NativeReference)'!='' or '@(_IsolatedComReference)'!=''">
+      <_BuiltProjectOutputGroupOutputIntermediate Include="$(OutDir)$(_DeploymentTargetApplicationManifestFileName)" Condition="('@(NativeReference)'!='' or '@(_IsolatedComReference)'!='') And Exists('$(OutDir)$(_DeploymentTargetApplicationManifestFileName)')">
         <TargetPath>$(_DeploymentTargetApplicationManifestFileName)</TargetPath>
         <!-- For compatibility with 2.0 -->
         <OriginalItemSpec>$(OutDir)$(_DeploymentTargetApplicationManifestFileName)</OriginalItemSpec>
diff --git a/src/Tasks/Microsoft.NETFramework.CurrentVersion.props b/src/Tasks/Microsoft.NETFramework.CurrentVersion.props
index 2caf4326b7a..f08677fe9b8 100644
--- a/src/Tasks/Microsoft.NETFramework.CurrentVersion.props
+++ b/src/Tasks/Microsoft.NETFramework.CurrentVersion.props
@@ -114,6 +114,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ImplicitlyExpandDesignTimeFacades Condition="'$(ImplicitlyExpandDesignTimeFacades)' == '' and ('$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetingClr2Framework)' != 'true' and '$(TargetFrameworkVersion)' != 'v4.0')">true</ImplicitlyExpandDesignTimeFacades>
   </PropertyGroup>
 
+  <PropertyGroup>
+    <AvailablePlatforms Condition="!$(AvailablePlatforms.Contains('ARM64')) and '$(TargetFrameworkIdentifier)' == '.NETFramework' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '4.0'))">$(AvailablePlatforms),ARM64</AvailablePlatforms>
+  </PropertyGroup>
+
   <!--Import props that are common for both full framework and core.
     And before the ImportAfter\* , so users can override it-->
   <Import Project="$(MSBuildToolsPath)\Microsoft.NET.props" />
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index 42368e48d88..7ea9782cedb 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -6,7 +6,6 @@
 using System.Runtime.InteropServices;
 using Microsoft.Build.Shared.FileSystem;
 
-#if FEATURE_COM_INTEROP
 using System.Text;
 using System.Reflection;
 using Microsoft.Build.Shared;
@@ -16,13 +15,12 @@
 using System.Linq;
 using System.Runtime.ExceptionServices;
 using System.Text.RegularExpressions;
-#endif
+using System.Runtime.Versioning;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
-#if FEATURE_COM_INTEROP
     /// <summary>
     /// The original ITypeInfo interface in the CLR has incorrect definitions for GetRefTypeOfImplType and GetRefTypeInfo.
     /// It uses ints for marshalling handles which will result in a crash on 64 bit systems. This is a temporary interface
@@ -76,7 +74,9 @@ internal interface ICreateTypeLib
 
     [ComImport]
     [Guid("E5CB7A31-7512-11d2-89CE-0080C792E5D8")]
+#if !NETSTANDARD2_0_OR_GREATER // NS2.0 doesn't have COM so this can't appear in the ref assembly
     [TypeLibType(TypeLibTypeFlags.FCanCreate)]
+#endif
     [ClassInterface(ClassInterfaceType.None)]
     internal class CorMetaDataDispenser
     {
@@ -85,7 +85,9 @@ internal class CorMetaDataDispenser
     [ComImport]
     [Guid("809c652e-7396-11d2-9771-00a0c9b4d50c")]
     [InterfaceType(ComInterfaceType.InterfaceIsIUnknown /*0x0001*/)]
+#if !NETSTANDARD2_0_OR_GREATER // NS2.0 doesn't have COM so this can't appear in the ref assembly
     [TypeLibType(TypeLibTypeFlags.FRestricted /*0x0200*/)]
+#endif
     internal interface IMetaDataDispenser
     {
         [return: MarshalAs(UnmanagedType.Interface)]
@@ -480,8 +482,6 @@ internal enum AssemblyNameDisplayFlags
                                     | RETARGETABLE
     }
 
-#endif
-
     [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
     internal struct STARTUPINFO
     {
@@ -1031,11 +1031,11 @@ internal static bool AllDrivesMapped()
             return false;
         }
 
-#if FEATURE_COM_INTEROP
         //------------------------------------------------------------------------------
         // CreateAssemblyCache
         //------------------------------------------------------------------------------
         [DllImport("fusion.dll")]
+        [SupportedOSPlatform("windows")]
         internal static extern uint CreateAssemblyCache(out IAssemblyCache ppAsmCache, uint dwReserved);
 
         [DllImport("fusion.dll")]
@@ -1047,6 +1047,7 @@ internal static extern int CreateAssemblyEnum(
                 IntPtr pvReserved);
 
         [DllImport("fusion.dll")]
+        [SupportedOSPlatform("windows")]
         internal static extern int CreateAssemblyNameObject(
                 out IAssemblyName ppAssemblyNameObj,
                 [MarshalAs(UnmanagedType.LPWStr)]
@@ -1064,8 +1065,8 @@ internal static extern int CreateAssemblyNameObject(
         /// <param name="pcchPath">The requested maximum length of CachePath, and upon return, the actual length of CachePath.</param>
         /// 
         [DllImport("fusion.dll", CharSet = CharSet.Unicode)]
+        [SupportedOSPlatform("windows")]
         internal static extern unsafe int GetCachePath(AssemblyCacheFlags cacheFlags, [Out] char* cachePath, ref int pcchPath);
-#endif
 
         //------------------------------------------------------------------------------
         // PFXImportCertStore
@@ -1265,7 +1266,6 @@ internal static unsafe int CorSigUncompressData(IntPtr data, out int uncompresse
         }
 #endregion
 #region InternalClass
-#if FEATURE_COM_INTEROP
         /// <summary>
         /// This class is a wrapper over the native GAC enumeration API.
         /// </summary>
@@ -1503,7 +1503,6 @@ public static string AssemblyPathFromStrongName(string strongName)
                 return null;
             }
         }
-#endif
 #endregion
     }
 }
diff --git a/src/Tasks/PublicAPI/net/PublicAPI.Shipped.txt b/src/Tasks/PublicAPI/net/PublicAPI.Shipped.txt
index 85f6da6f74e..1cc4f59b5e8 100644
--- a/src/Tasks/PublicAPI/net/PublicAPI.Shipped.txt
+++ b/src/Tasks/PublicAPI/net/PublicAPI.Shipped.txt
@@ -884,6 +884,8 @@ Microsoft.Build.Tasks.DownloadFile.SkipUnchangedFiles.get -> bool
 Microsoft.Build.Tasks.DownloadFile.SkipUnchangedFiles.set -> void
 Microsoft.Build.Tasks.DownloadFile.SourceUrl.get -> string
 Microsoft.Build.Tasks.DownloadFile.SourceUrl.set -> void
+Microsoft.Build.Tasks.DownloadFile.Timeout.get -> int
+Microsoft.Build.Tasks.DownloadFile.Timeout.set -> void
 Microsoft.Build.Tasks.Error
 Microsoft.Build.Tasks.Error.Code.get -> string
 Microsoft.Build.Tasks.Error.Code.set -> void
@@ -1956,6 +1958,8 @@ Microsoft.Build.Tasks.SGen.UseProxyTypes.set -> void
 Microsoft.Build.Tasks.SignFile
 Microsoft.Build.Tasks.SignFile.CertificateThumbprint.get -> string
 Microsoft.Build.Tasks.SignFile.CertificateThumbprint.set -> void
+Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.get -> bool
+Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.set -> void
 Microsoft.Build.Tasks.SignFile.SignFile() -> void
 Microsoft.Build.Tasks.SignFile.SigningTarget.get -> Microsoft.Build.Framework.ITaskItem
 Microsoft.Build.Tasks.SignFile.SigningTarget.set -> void
@@ -2313,8 +2317,10 @@ override Microsoft.Build.Tasks.FindInvalidProjectReferences.Execute() -> bool
 override Microsoft.Build.Tasks.FindUnderPath.Execute() -> bool
 override Microsoft.Build.Tasks.FormatUrl.Execute() -> bool
 override Microsoft.Build.Tasks.FormatVersion.Execute() -> bool
+override Microsoft.Build.Tasks.GenerateApplicationManifest.Execute() -> bool
 override Microsoft.Build.Tasks.GenerateBindingRedirects.Execute() -> bool
 override Microsoft.Build.Tasks.GenerateBootstrapper.Execute() -> bool
+override Microsoft.Build.Tasks.GenerateDeploymentManifest.Execute() -> bool
 override Microsoft.Build.Tasks.GenerateLauncher.Execute() -> bool
 override Microsoft.Build.Tasks.GenerateManifestBase.Execute() -> bool
 override Microsoft.Build.Tasks.GenerateResource.Execute() -> bool
@@ -2409,6 +2415,7 @@ static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.Sign
 static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path) -> void
 static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion) -> void
 static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier) -> void
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier, bool disallowMansignTimestampFallback) -> void
 static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(System.Security.Cryptography.X509Certificates.X509Certificate2 cert, System.Uri timestampUrl, string path) -> void
 static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.XmlToPermissionSet(System.Xml.XmlElement element) -> System.Security.PermissionSet
 System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription
diff --git a/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
index 5f9ec5dc2a5..e69de29bb2d 100644
--- a/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
+++ b/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
@@ -1,5 +0,0 @@
-Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.get -> bool
-Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.set -> void
-override Microsoft.Build.Tasks.GenerateApplicationManifest.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateDeploymentManifest.Execute() -> bool
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier, bool disallowMansignTimestampFallback) -> void
diff --git a/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt
index 092772496e2..8f3cbf42ee6 100644
--- a/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ b/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt
@@ -783,6 +783,8 @@ Microsoft.Build.Tasks.DownloadFile.SkipUnchangedFiles.get -> bool
 Microsoft.Build.Tasks.DownloadFile.SkipUnchangedFiles.set -> void
 Microsoft.Build.Tasks.DownloadFile.SourceUrl.get -> string
 Microsoft.Build.Tasks.DownloadFile.SourceUrl.set -> void
+Microsoft.Build.Tasks.DownloadFile.Timeout.get -> int
+Microsoft.Build.Tasks.DownloadFile.Timeout.set -> void
 Microsoft.Build.Tasks.Error
 Microsoft.Build.Tasks.Error.Code.get -> string
 Microsoft.Build.Tasks.Error.Code.set -> void
@@ -1642,6 +1644,8 @@ Microsoft.Build.Tasks.SGen.UseProxyTypes.set -> void
 Microsoft.Build.Tasks.SignFile
 Microsoft.Build.Tasks.SignFile.CertificateThumbprint.get -> string
 Microsoft.Build.Tasks.SignFile.CertificateThumbprint.set -> void
+Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.get -> bool
+Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.set -> void
 Microsoft.Build.Tasks.SignFile.SignFile() -> void
 Microsoft.Build.Tasks.SignFile.SigningTarget.get -> Microsoft.Build.Framework.ITaskItem
 Microsoft.Build.Tasks.SignFile.SigningTarget.set -> void
@@ -1848,7 +1852,9 @@ override Microsoft.Build.Tasks.FindInvalidProjectReferences.Execute() -> bool
 override Microsoft.Build.Tasks.FindUnderPath.Execute() -> bool
 override Microsoft.Build.Tasks.FormatUrl.Execute() -> bool
 override Microsoft.Build.Tasks.FormatVersion.Execute() -> bool
+override Microsoft.Build.Tasks.GenerateApplicationManifest.Execute() -> bool
 override Microsoft.Build.Tasks.GenerateBindingRedirects.Execute() -> bool
+override Microsoft.Build.Tasks.GenerateDeploymentManifest.Execute() -> bool
 override Microsoft.Build.Tasks.GenerateLauncher.Execute() -> bool
 override Microsoft.Build.Tasks.GenerateManifestBase.Execute() -> bool
 override Microsoft.Build.Tasks.GenerateResource.Execute() -> bool
@@ -1914,6 +1920,7 @@ static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.Sign
 static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path) -> void
 static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion) -> void
 static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier) -> void
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier, bool disallowMansignTimestampFallback) -> void
 static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(System.Security.Cryptography.X509Certificates.X509Certificate2 cert, System.Uri timestampUrl, string path) -> void
 System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription
 System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription.RSAPKCS1SHA256SignatureDescription() -> void
diff --git a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index 5f9ec5dc2a5..886e91fbd48 100644
--- a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -1,5 +1,20 @@
-Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.get -> bool
-Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.set -> void
-override Microsoft.Build.Tasks.GenerateApplicationManifest.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateDeploymentManifest.Execute() -> bool
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier, bool disallowMansignTimestampFallback) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo
+Microsoft.Build.Tasks.IFixedTypeInfo.AddressOfMember(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, out System.IntPtr ppv) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.CreateInstance(object pUnkOuter, ref System.Guid riid, out object ppvObj) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetContainingTypeLib(out System.Runtime.InteropServices.ComTypes.ITypeLib ppTLB, out int pIndex) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetDllEntry(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, System.IntPtr pBstrDllName, System.IntPtr pBstrName, System.IntPtr pwOrdinal) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetDocumentation(int index, out string strName, out string strDocString, out int dwHelpContext, out string strHelpFile) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetFuncDesc(int index, out System.IntPtr ppFuncDesc) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetIDsOfNames(string[] rgszNames, int cNames, int[] pMemId) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetImplTypeFlags(int index, out System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS pImplTypeFlags) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetMops(int memid, out string pBstrMops) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetNames(int memid, string[] rgBstrNames, int cMaxNames, out int pcNames) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeInfo(System.IntPtr hRef, out Microsoft.Build.Tasks.IFixedTypeInfo ppTI) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeOfImplType(int index, out System.IntPtr href) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetTypeAttr(out System.IntPtr ppTypeAttr) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetTypeComp(out System.Runtime.InteropServices.ComTypes.ITypeComp ppTComp) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetVarDesc(int index, out System.IntPtr ppVarDesc) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.Invoke(object pvInstance, int memid, short wFlags, ref System.Runtime.InteropServices.ComTypes.DISPPARAMS pDispParams, System.IntPtr pVarResult, System.IntPtr pExcepInfo, out int puArgErr) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseFuncDesc(System.IntPtr pFuncDesc) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseTypeAttr(System.IntPtr pTypeAttr) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseVarDesc(System.IntPtr pVarDesc) -> void
diff --git a/src/Tasks/RemoveDir.cs b/src/Tasks/RemoveDir.cs
index a88b74eb659..4e94778a998 100644
--- a/src/Tasks/RemoveDir.cs
+++ b/src/Tasks/RemoveDir.cs
@@ -51,6 +51,14 @@ public override bool Execute()
 
             foreach (ITaskItem directory in Directories)
             {
+                if (string.IsNullOrEmpty(directory.ItemSpec))
+                {
+                    // Skip any empty ItemSpecs, otherwise RemoveDir will wipe the root of the current drive (!).
+                    // https://github.com/dotnet/msbuild/issues/7563
+                    Log.LogWarningWithCodeFromResources("RemoveDir.EmptyPath");
+                    continue;
+                }
+
                 if (FileSystems.Default.DirectoryExists(directory.ItemSpec))
                 {
                     // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
diff --git a/src/Tasks/ResolveNonMSBuildProjectOutput.cs b/src/Tasks/ResolveNonMSBuildProjectOutput.cs
index dbba3804418..96779b3374d 100644
--- a/src/Tasks/ResolveNonMSBuildProjectOutput.cs
+++ b/src/Tasks/ResolveNonMSBuildProjectOutput.cs
@@ -180,4 +180,3 @@ internal bool ResolveProject(ITaskItem projectRef, out ITaskItem resolvedPath)
         #endregion
     }
 }
-
diff --git a/src/Tasks/ResourceHandling/MSBuildResXReader.cs b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
index 86dc5d50311..91786f0f529 100644
--- a/src/Tasks/ResourceHandling/MSBuildResXReader.cs
+++ b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
@@ -25,7 +25,7 @@ public static IReadOnlyList<IResource> ReadResources(Stream s, string filename,
             {
                 using (var xmlReader = new XmlTextReader(s))
                 {
-                    xmlReader.WhitespaceHandling = WhitespaceHandling.None;
+                    xmlReader.WhitespaceHandling = WhitespaceHandling.All;
 
                     XDocument doc = XDocument.Load(xmlReader, LoadOptions.PreserveWhitespace);
                     foreach (XElement elem in doc.Element("root").Elements())
@@ -105,6 +105,7 @@ private static void ParseData(string resxFilename, bool pathsRelativeToBasePath,
         {
             string name = elem.Attribute("name").Value;
             string value;
+            bool preserve = elem.Attribute(XName.Get("space", "http://www.w3.org/XML/1998/namespace"))?.Value == "preserve";
 
             XElement valueElement = elem.Element("value");
             if (valueElement is null)
@@ -119,6 +120,10 @@ private static void ParseData(string resxFilename, bool pathsRelativeToBasePath,
             else
             {
                 value = valueElement.Value;
+                if (!preserve && string.IsNullOrWhiteSpace(value))
+                {
+                    value = string.Empty;
+                }
             }
 
             string typename = elem.Attribute("type")?.Value;
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index d0dd9311e15..a128fd658e2 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -1338,6 +1338,10 @@
   <data name="RemoveDir.SkippingNonexistentDirectory">
     <value>Directory "{0}" doesn't exist. Skipping.</value>
   </data>
+  <data name="RemoveDir.EmptyPath">
+    <value>MSB3232: An empty directory was passed to RemoveDir and was ignored.</value>
+    <comment>{StrBegin="MSB3232: "}</comment>
+  </data>
   <!--
         The ResGen message bucket is: MSB3451 - MSB3460
 
@@ -2906,7 +2910,7 @@
     <comment>{StrBegin="MSB3981: "}</comment>
   </data>
   <data name="GetCompatiblePlatform.NoPlatformsListed">
-    <value>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</value>
+    <value>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</value>
     <comment>{StrBegin="MSB3982: "}</comment>
   </data>
   <data name="GetCompatiblePlatform.InvalidLookupTableFormat">
@@ -2928,6 +2932,9 @@
   <data name="GetCompatiblePlatform.AnyCPUDefault">
     <value>Choosing AnyCPU by default.</value>
   </data>
+  <data name="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
+    <value>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</value>
+  </data>
   <!--
         The tasks message bucket is: MSB3001 - MSB3999
 
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 67a661cae66..76d1ac83455 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -1362,10 +1362,15 @@
         <note>{StrBegin="MSB3981: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
-        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
-        <target state="translated">MSB3982: EnableDynamicPlatformResolution je true, ale odkazovaný projekt {0} nemá nastavená metadata pro platformy. Sestaví se bez zadané platformy.</target>
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
+        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution je true, ale odkazovaný projekt {0} nemá nastavená metadata pro platformy. Sestaví se bez zadané platformy.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
+        <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
+        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
         <source>ProjectReference and current project have the same platform.</source>
         <target state="translated">ProjectReference a aktuální projekt mají stejnou platformu.</target>
@@ -1547,6 +1552,11 @@
         <target state="translated">MSB3216: Nelze zaregistrovat sestavení {0}. Byl odepřen přístup. Zkontrolujte, zda spouštíte aplikaci jako správce. {1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: Nelze odebrat adresář {0}. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 85c2e0e3410..8e5b3b15220 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -1362,10 +1362,15 @@
         <note>{StrBegin="MSB3981: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
-        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
-        <target state="translated">MSB3982: EnableDynamicPlatformResolution ist "true". Das referenzierte Projekt "{0}" enthält jedoch keine Metadaten für "Platforms". Es wird ohne eine angegebene Plattform erstellt.</target>
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
+        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution ist "true". Das referenzierte Projekt "{0}" enthält jedoch keine Metadaten für "Platforms". Es wird ohne eine angegebene Plattform erstellt.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
+        <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
+        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
         <source>ProjectReference and current project have the same platform.</source>
         <target state="translated">ProjectReference und das aktuelle Projekt haben die gleiche Plattform.</target>
@@ -1547,6 +1552,11 @@
         <target state="translated">MSB3216: Die "{0}"-Assembly kann nicht registriert werden – Zugriff verweigert. Stellen Sie sicher, dass Sie die Anwendung als Administrator ausführen. {1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: Das Verzeichnis "{0}" kann nicht entfernt werden. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 6edbd27b1be..d670df974c0 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -1362,10 +1362,15 @@
         <note>{StrBegin="MSB3981: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
-        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
-        <target state="translated">MSB3982: EnableDynamicPlatformResolution es true, pero el proyecto al que se hace referencia, "{0}", no tiene establecido ningún conjunto de metadatos "Platforms". Se compilará sin una plataforma especificada.</target>
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
+        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution es true, pero el proyecto al que se hace referencia, "{0}", no tiene establecido ningún conjunto de metadatos "Platforms". Se compilará sin una plataforma especificada.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
+        <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
+        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
         <source>ProjectReference and current project have the same platform.</source>
         <target state="translated">ProjectReference y el proyecto actual tienen la misma plataforma.</target>
@@ -1547,6 +1552,11 @@
         <target state="translated">MSB3216: No se puede registrar el ensamblado "{0}": acceso denegado. Asegúrese de que está ejecutando la aplicación como administrador. {1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: No se puede quitar el directorio "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 30e7409e31e..598042e2274 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -1362,10 +1362,15 @@
         <note>{StrBegin="MSB3981: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
-        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
-        <target state="translated">MSB3982: EnableDynamicPlatformResolution a la valeur true, mais le projet référencé '{0}' n’a pas de métadonnées ’Platforms’ définies. Il sera généré sans une plateforme spécifiée.</target>
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
+        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution a la valeur true, mais le projet référencé '{0}' n’a pas de métadonnées ’Platforms’ définies. Il sera généré sans une plateforme spécifiée.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
+        <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
+        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
         <source>ProjectReference and current project have the same platform.</source>
         <target state="translated">ProjectReference et le projet actuel ont la même plateforme.</target>
@@ -1547,6 +1552,11 @@
         <target state="translated">MSB3216: Impossible d'inscrire l'assembly "{0}", car l'accès est refusé. Assurez-vous d'exécuter l'application comme administrateur. {1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: Impossible de supprimer le répertoire "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 545b88ce4d0..f5324d1486b 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -1362,10 +1362,15 @@
         <note>{StrBegin="MSB3981: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
-        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
-        <target state="translated">MSB3982: EnableDynamicPlatformResolution è true ma il progetto di riferimento '{0}' non ha un set di metadati 'Platforms'. Verrà compilato senza una piattaforma specificata.</target>
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
+        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution è true ma il progetto di riferimento '{0}' non ha un set di metadati 'Platforms'. Verrà compilato senza una piattaforma specificata.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
+        <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
+        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
         <source>ProjectReference and current project have the same platform.</source>
         <target state="translated">ProjectReference e il progetto corrente hanno la stessa piattaforma.</target>
@@ -1547,6 +1552,11 @@
         <target state="translated">MSB3216: non è possibile registrare l'assembly "{0}". Accesso negato. Assicurarsi di eseguire l'applicazione come amministratore. {1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: non è possibile rimuovere la directory "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index e68abe95648..05e3749d224 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -1362,10 +1362,15 @@
         <note>{StrBegin="MSB3981: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
-        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
-        <target state="translated">MSB3982: EnableDynamicPlatformResolution は true ですが、参照対象プロジェクト '{0}' に 'プラットフォーム' メタデータが設定されていません。これは、指定されたプラットフォームなしでビルドされます。</target>
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
+        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution は true ですが、参照対象プロジェクト '{0}' に 'プラットフォーム' メタデータが設定されていません。これは、指定されたプラットフォームなしでビルドされます。</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
+        <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
+        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
         <source>ProjectReference and current project have the same platform.</source>
         <target state="translated">ProjectReference と現在のプロジェクトに同じプラットフォームがあります。</target>
@@ -1547,6 +1552,11 @@
         <target state="translated">MSB3216: アセンブリ "{0}" を登録できません - アクセスが拒否されました。管理者としてアプリケーションを実行しているか確認してください。{1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: ディレクトリ "{0}" を削除できません。{1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index bc955da3f74..9e79c469a64 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -1362,10 +1362,15 @@
         <note>{StrBegin="MSB3981: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
-        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
-        <target state="translated">MSB3982: EnableDynamicPlatformResolution이 true이지만 참조된 프로젝트 '{0}'에 '플랫폼' 메타데이터 세트가 없습니다. 지정된 플랫폼 없이 구축됩니다.</target>
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
+        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution이 true이지만 참조된 프로젝트 '{0}'에 '플랫폼' 메타데이터 세트가 없습니다. 지정된 플랫폼 없이 구축됩니다.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
+        <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
+        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
         <source>ProjectReference and current project have the same platform.</source>
         <target state="translated">ProjectReference와 현재 프로젝트는 동일한 플랫폼을 가지고 있습니다.</target>
@@ -1547,6 +1552,11 @@
         <target state="translated">MSB3216: "{0}" 어셈블리를 등록할 수 없습니다. 액세스가 거부되었습니다. 관리자로 애플리케이션을 실행하고 있는지 확인하세요. {1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: "{0}" 디렉터리를 제거할 수 없습니다. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 4da67b53fb2..c4425be1017 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -1362,10 +1362,15 @@
         <note>{StrBegin="MSB3981: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
-        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
-        <target state="translated">MSB3982: element EnableDynamicPlatformResolution ma wartość true, ale projekt "{0}", do którego się odnosi, nie ma ustawionych metadanych "Platformy". Zostanie on skompilowany bez określonej platformy.</target>
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
+        <target state="needs-review-translation">MSB3982: element EnableDynamicPlatformResolution ma wartość true, ale projekt "{0}", do którego się odnosi, nie ma ustawionych metadanych "Platformy". Zostanie on skompilowany bez określonej platformy.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
+        <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
+        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
         <source>ProjectReference and current project have the same platform.</source>
         <target state="translated">Element ProjectReference i bieżący projekt mają tę samą platformę.</target>
@@ -1547,6 +1552,11 @@
         <target state="translated">MSB3216: Nie można zarejestrować zestawu „{0}” — odmowa dostępu. Upewnij się, że aplikacja została uruchomiona z uprawnieniami administratora. {1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: Nie można usunąć katalogu „{0}”. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index a8b323131f8..9e8ae3a173a 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -1362,10 +1362,15 @@
         <note>{StrBegin="MSB3981: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
-        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
-        <target state="translated">MSB3982: EnableDynamicPlatformResolution é verdadeiro, mas o projeto referenciado '{0}' não tem nenhum conjunto de metadados de 'Plataformas'. Ele será criado sem uma plataforma especificada.</target>
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
+        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution é verdadeiro, mas o projeto referenciado '{0}' não tem nenhum conjunto de metadados de 'Plataformas'. Ele será criado sem uma plataforma especificada.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
+        <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
+        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
         <source>ProjectReference and current project have the same platform.</source>
         <target state="translated">O ProjectReference e o projeto atual têm a mesma plataforma.</target>
@@ -1547,6 +1552,11 @@
         <target state="translated">MSB3216: Não é possível registrar o assembly "{0}"; acesso negado. Verifique se você está executando o aplicativo como administrador. {1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: Não é possível remover o diretório "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index a4082b93a2b..9f678d815a9 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -1362,10 +1362,15 @@
         <note>{StrBegin="MSB3981: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
-        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
-        <target state="translated">MSB3982: EnableDynamicPlatformResolution имеет значение true, но у указанного проекта "{0}" нет заданных метаданных "Platforms". Сборка будет выполнена без указанной платформы.</target>
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
+        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution имеет значение true, но у указанного проекта "{0}" нет заданных метаданных "Platforms". Сборка будет выполнена без указанной платформы.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
+        <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
+        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
         <source>ProjectReference and current project have the same platform.</source>
         <target state="translated">ProjectReference и текущий проект используют одну платформу.</target>
@@ -1547,6 +1552,11 @@
         <target state="translated">MSB3216: невозможно зарегистрировать сборку "{0}" — отказано в доступе. Убедитесь, что приложение запущено с правами администратора. {1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: Не удалось удалить каталог "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 4e6febbd0f6..b50eb2c00de 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -1362,10 +1362,15 @@
         <note>{StrBegin="MSB3981: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
-        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
-        <target state="translated">MSB3982: EnableDynamicPlatformResolution doğru ancak başvurulan proje '{0}', 'Platforms' meta veri kümesine sahip değil. Belirli bir platform olmadan oluşturulacak.</target>
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
+        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution doğru ancak başvurulan proje '{0}', 'Platforms' meta veri kümesine sahip değil. Belirli bir platform olmadan oluşturulacak.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
+        <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
+        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
         <source>ProjectReference and current project have the same platform.</source>
         <target state="translated">ProjectReference ve geçerli proje aynı platforma sahip.</target>
@@ -1547,6 +1552,11 @@
         <target state="translated">MSB3216: "{0}" bütünleştirilmiş kodu kaydedilemiyor - erişim reddedildi. Lütfen uygulamayı yönetici olarak çalıştırdığınızdan emin olun. {1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: "{0}" dizini kaldırılamıyor. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index f979f200cfb..ab943eeff47 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -1362,10 +1362,15 @@
         <note>{StrBegin="MSB3981: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
-        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
-        <target state="translated">MSB3982: EnableDynamicPlatformResolution 为 true，但引用的项目 "{0}" 没有设置 "Platforms" 元数据。它将在没有指定平台的情况下生成。</target>
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
+        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution 为 true，但引用的项目 "{0}" 没有设置 "Platforms" 元数据。它将在没有指定平台的情况下生成。</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
+        <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
+        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
         <source>ProjectReference and current project have the same platform.</source>
         <target state="translated">ProjectReference 和当前项目具有相同的平台。</target>
@@ -1547,6 +1552,11 @@
         <target state="translated">MSB3216: 无法注册程序集“{0}”- 拒绝访问。请确保您正在以管理员身份运行应用程序。{1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: 无法移除目录“{0}”。{1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 659ab09c3bf..f79344992ae 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -1362,10 +1362,15 @@
         <note>{StrBegin="MSB3981: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
-        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
-        <target state="translated">MSB3982: EnableDynamicPlatformResolution 為 true，但參考的專案 '{0}' 未設定 'Platforms' 中繼資料。它將在沒有指定平台的情況下建置。</target>
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
+        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution 為 true，但參考的專案 '{0}' 未設定 'Platforms' 中繼資料。它將在沒有指定平台的情況下建置。</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
+        <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
+        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
         <source>ProjectReference and current project have the same platform.</source>
         <target state="translated">ProjectReference 和目前的專案有相同的平台。</target>
@@ -1547,6 +1552,11 @@
         <target state="translated">MSB3216: 無法註冊組件 "{0}" - 存取遭拒。請確認您以系統管理員身分執行此應用程式。{1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: 無法移除目錄 "{0}"。{1}</target>
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
index 5feeb67170f..004d2f8067d 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
@@ -102,6 +102,11 @@ public sealed class RoslynCodeTaskFactory : ITaskFactory
         /// </summary>
         private TaskLoggingHelper _log;
 
+        /// <summary>
+        /// Stores functions that were added to the current app domain. Should be removed once we're finished.
+        /// </summary>
+        private ResolveEventHandler handlerAddedToAppDomain = null;
+
         /// <summary>
         /// Stores the parameters parsed in the &lt;UsingTask /&gt;.
         /// </summary>
@@ -123,6 +128,10 @@ public sealed class RoslynCodeTaskFactory : ITaskFactory
         /// <inheritdoc cref="ITaskFactory.CleanupTask(ITask)"/>
         public void CleanupTask(ITask task)
         {
+            if (handlerAddedToAppDomain is not null)
+            {
+                AppDomain.CurrentDomain.AssemblyResolve -= handlerAddedToAppDomain;
+            }
         }
 
         /// <inheritdoc cref="ITaskFactory.CreateTask(IBuildEngine)"/>
@@ -515,7 +524,7 @@ internal static bool TryLoadTaskBody(TaskLoggingHelper log, string taskName, str
         /// Perhaps in the future this could be more powerful by using NuGet to resolve assemblies but we think
         /// that is too complicated for a simple in-line task.  If users have more complex requirements, they
         /// can compile their own task library.</remarks>
-        internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynCodeTaskFactoryTaskInfo taskInfo, out ITaskItem[] items)
+        internal bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynCodeTaskFactoryTaskInfo taskInfo, out ITaskItem[] items)
         {
             // Store the list of resolved assemblies because a user can specify a short name or a full path
             ISet<string> resolvedAssemblyReferences = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
@@ -532,6 +541,8 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC
                 references = references.Union(DefaultReferences[taskInfo.CodeLanguage]);
             }
 
+            List<string> directoriesToAddToAppDomain = new();
+
             // Loop through the user specified references as well as the default references
             foreach (string reference in references)
             {
@@ -539,7 +550,9 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC
                 if (FileSystems.Default.FileExists(reference))
                 {
                     // The path could be relative like ..\Assembly.dll so we need to get the full path
-                    resolvedAssemblyReferences.Add(Path.GetFullPath(reference));
+                    string fullPath = Path.GetFullPath(reference);
+                    directoriesToAddToAppDomain.Add(Path.GetDirectoryName(fullPath));
+                    resolvedAssemblyReferences.Add(fullPath);
                     continue;
                 }
 
@@ -572,7 +585,34 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC
             // Transform the list of resolved assemblies to TaskItems if they were all resolved
             items = hasInvalidReference ? null : resolvedAssemblyReferences.Select(i => (ITaskItem)new TaskItem(i)).ToArray();
 
+            handlerAddedToAppDomain = (_, eventArgs) => TryLoadAssembly(directoriesToAddToAppDomain, new AssemblyName(eventArgs.Name));
+            AppDomain.CurrentDomain.AssemblyResolve += handlerAddedToAppDomain;
+
             return !hasInvalidReference;
+
+            static Assembly TryLoadAssembly(List<string> directories, AssemblyName name)
+            {
+                foreach (string directory in directories)
+                {
+                    string path;
+                    if (!string.IsNullOrEmpty(name.CultureName))
+                    {
+                        path = Path.Combine(directory, name.CultureName, name.Name + ".dll");
+                        if (File.Exists(path))
+                        {
+                            return Assembly.LoadFrom(path);
+                        }
+                    }
+
+                    path = Path.Combine(directory, name.Name + ".dll");
+                    if (File.Exists(path))
+                    {
+                        return Assembly.LoadFrom(path);
+                    }
+                }
+
+                return null;
+            }
         }
 
         private static CodeMemberProperty CreateProperty(CodeTypeDeclaration codeTypeDeclaration, string name, Type type, object defaultValue = null)
diff --git a/src/Tasks/System.Resources.Extensions.pkgdef b/src/Tasks/System.Resources.Extensions.pkgdef
index 000095869d3..6c5ef517c6e 100644
--- a/src/Tasks/System.Resources.Extensions.pkgdef
+++ b/src/Tasks/System.Resources.Extensions.pkgdef
@@ -4,4 +4,4 @@
 "publicKeyToken"="cc7b13ffcd2ddd51"
 "culture"="neutral"
 "oldVersion"="0.0.0.0-99.9.9.9"
-"newVersion"="4.0.0.0"
+"newVersion"="6.0.0.0"
diff --git a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
index 9221c73a0e0..438cb91ff75 100644
--- a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
+++ b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
@@ -25,10 +25,6 @@
     <Reference Include="System.Core" />
     <Reference Include="System.Xml" />
   </ItemGroup>
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
-    <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
-    <PackageReference Include="Microsoft.Win32.Registry" />
-  </ItemGroup>
   <ItemGroup>
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs">
       <Link>BuildEnvironmentHelper.cs</Link>
diff --git a/src/Utilities.UnitTests/EventArgsFormatting_Tests.cs b/src/Utilities.UnitTests/EventArgsFormatting_Tests.cs
index 5725b1fd685..2776d3762bb 100644
--- a/src/Utilities.UnitTests/EventArgsFormatting_Tests.cs
+++ b/src/Utilities.UnitTests/EventArgsFormatting_Tests.cs
@@ -193,4 +193,3 @@ public override void Initialize(IEventSource eventSource)
         }
     }
 }
-
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index 1ced49c9b63..b5df279597a 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -191,7 +191,7 @@ public void HandleExecutionErrorsWhenToolDoesntLogError()
 
                 // We just tried to run "cmd.exe /C garbagegarbagegarbagegarbage.exe".  This should fail,
                 // but since "cmd.exe" doesn't log its errors in canonical format, no errors got
-                // logged by the tool itself.  Therefore, ToolTask's default implementation of 
+                // logged by the tool itself.  Therefore, ToolTask's default implementation of
                 // HandleTaskExecutionErrors should have logged error MSB6006.
                 engine.AssertLogContains("MSB6006");
             }
@@ -227,7 +227,7 @@ public void HandleExecutionErrorsWhenToolLogsError()
         }
 
         /// <summary>
-        /// ToolTask should never run String.Format on strings that are 
+        /// ToolTask should never run String.Format on strings that are
         /// not meant to be formatted.
         /// </summary>
         [Fact]
@@ -524,27 +524,16 @@ public void EnvironmentVariablesToToolTask()
 
             ProcessStartInfo startInfo = task.StartInfo;
 
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
             startInfo.Environment["a"].ShouldBe("b");
             startInfo.Environment["c"].ShouldBe("d");
             startInfo.Environment[userVarName].ShouldBe("x");
             startInfo.Environment["path"].ShouldBe(String.Empty);
-#else
-            startInfo.EnvironmentVariables["a"].ShouldBe("b");
-            startInfo.EnvironmentVariables["c"].ShouldBe("d");
-            startInfo.EnvironmentVariables[userVarName].ShouldBe("x");
-            startInfo.EnvironmentVariables["path"].ShouldBe(string.Empty);
-#endif
 
             if (NativeMethodsShared.IsWindows)
             {
                 Assert.Equal(
                         Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles),
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
                         startInfo.Environment["programfiles"],
-#else
-                        startInfo.EnvironmentVariables["programfiles"],
-#endif
                         true);
             }
         }
@@ -562,11 +551,7 @@ public void EnvironmentVariablesToToolTaskEqualsSign()
             bool result = task.Execute();
 
             result.ShouldBe(true);
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
             task.StartInfo.Environment["a"].ShouldBe("b=c");
-#else
-            task.StartInfo.EnvironmentVariables["a"].ShouldBe("b=c");
-#endif
         }
 
         /// <summary>
@@ -628,12 +613,7 @@ public void EnvironmentVariablesToToolTaskNotSet()
 
             result.ShouldBe(true);
             task.ExecuteCalled.ShouldBe(true);
-            Assert.True(
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
-                task.StartInfo.Environment["PATH"].Length > 0);
-#else
-                task.StartInfo.EnvironmentVariables["PATH"].Length > 0);
-#endif
+            Assert.True(task.StartInfo.Environment["PATH"].Length > 0);
         }
 
         /// <summary>
@@ -707,22 +687,14 @@ public void FindOnPathSucceeds()
         public void GetProcessStartInfoCanOverrideEnvironmentVariables()
         {
             MyTool task = new MyTool();
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
             task.DoProcessStartInfoMutation = (p) => p.Environment.Remove("a");
-#else
-            task.DoProcessStartInfoMutation = (p) => p.EnvironmentVariables.Remove("a");
-#endif
-            
+
             task.BuildEngine = new MockEngine();
             task.EnvironmentVariables = new[] { "a=b" };
             bool result = task.Execute();
 
             result.ShouldBe(true);
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
             task.StartInfo.Environment.ContainsKey("a").ShouldBe(false);
-#else
-            task.StartInfo.EnvironmentVariables.ContainsKey("a").ShouldBe(false);
-#endif
         }
 
         [Fact]
diff --git a/src/Utilities/AppDomainIsolatedTask.cs b/src/Utilities/AppDomainIsolatedTask.cs
index 76042abcf5c..db622ab1707 100644
--- a/src/Utilities/AppDomainIsolatedTask.cs
+++ b/src/Utilities/AppDomainIsolatedTask.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#if FEATURE_APPDOMAIN
 using System;
 using System.Resources;
 using System.Security;
@@ -17,6 +16,9 @@ namespace Microsoft.Build.Utilities
     /// instantiated in its own app domain.
     /// </summary>
     [LoadInSeparateAppDomain]
+#if !FEATURE_APPDOMAIN
+    [Obsolete("AppDomains are no longer supported in .NET Core or .NET 5.0 or higher.")]
+#endif
     public abstract class AppDomainIsolatedTask : MarshalByRefObject, ITask
     {
         #region Constructors
@@ -114,9 +116,15 @@ protected string HelpKeywordPrefix
         /// lease (5 minutes I think) and task instances can expire if they take long time processing.
         /// </summary>
         [SecurityCritical]
+#pragma warning disable CS0809 // InitializeLifetimeService is not marked as obsolete in netstandard2.0
+#if !FEATURE_APPDOMAIN
+        // This Obsolete is redundant since the whole class is obsoleted, but required to guard the reference
+        // to the obsolete MarshalByRefObject.InitializeLifetimeService.
+        [Obsolete("AppDomains are no longer supported in .NET Core or .NET 5.0 or higher.")]
+#endif
         public override object InitializeLifetimeService() => null; // null means infinite lease time
+#pragma warning restore
 
         #endregion
     }
 }
-#endif
diff --git a/src/Utilities/AssemblyFolders/AssemblyFoldersExInfo.cs b/src/Utilities/AssemblyFolders/AssemblyFoldersExInfo.cs
index beee420663d..ddf605b188b 100644
--- a/src/Utilities/AssemblyFolders/AssemblyFoldersExInfo.cs
+++ b/src/Utilities/AssemblyFolders/AssemblyFoldersExInfo.cs
@@ -3,9 +3,9 @@
 //-----------------------------------------------------------------------
 // Contains information about entries in the AssemblyFoldersEx registry keys.
 //-----------------------------------------------------------------------
-#if FEATURE_WIN32_REGISTRY
 
 using System;
+using System.Runtime.Versioning;
 using Microsoft.Build.Shared;
 using Microsoft.Win32;
 
@@ -16,6 +16,7 @@ namespace Microsoft.Build.Utilities
     /// <summary>
     /// Contains information about entries in the AssemblyFoldersEx registry keys.
     /// </summary>
+    [SupportedOSPlatform("windows")]
     public class AssemblyFoldersExInfo
     {
         /// <summary>
@@ -60,4 +61,3 @@ public AssemblyFoldersExInfo(RegistryHive hive, RegistryView view, string regist
         public Version TargetFrameworkVersion { get; }
     }
 }
-#endif
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index 5e5bcafb605..b5e520f25a3 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -35,11 +35,11 @@
     <PackageReference Include="System.Text.Encoding.CodePages" />
   </ItemGroup>
 
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
-    <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
+    <!-- Need Win32 API on .NET Standard to ping registry for some methods in ToolLocationHelper -->
     <PackageReference Include="Microsoft.Win32.Registry" />
   </ItemGroup>
-
+  
   <ItemGroup Label="Shared Code">
     <Compile Include="..\Shared\AssemblyFolders\AssemblyFoldersEx.cs">
       <Link>Shared\AssemblyFolders\AssemblyFoldersEx.cs</Link>
diff --git a/src/Utilities/PublicAPI/net/PublicAPI.Shipped.txt b/src/Utilities/PublicAPI/net/PublicAPI.Shipped.txt
index e85d5954bfd..0c8ceeed580 100644
--- a/src/Utilities/PublicAPI/net/PublicAPI.Shipped.txt
+++ b/src/Utilities/PublicAPI/net/PublicAPI.Shipped.txt
@@ -136,9 +136,11 @@ Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Current = 0 -> Microsoft.B
 Microsoft.Build.Utilities.ExecutableType
 Microsoft.Build.Utilities.ExecutableType.Managed32Bit = 3 -> Microsoft.Build.Utilities.ExecutableType
 Microsoft.Build.Utilities.ExecutableType.Managed64Bit = 4 -> Microsoft.Build.Utilities.ExecutableType
+Microsoft.Build.Utilities.ExecutableType.ManagedARM64 = 7 -> Microsoft.Build.Utilities.ExecutableType
 Microsoft.Build.Utilities.ExecutableType.ManagedIL = 2 -> Microsoft.Build.Utilities.ExecutableType
 Microsoft.Build.Utilities.ExecutableType.Native32Bit = 0 -> Microsoft.Build.Utilities.ExecutableType
 Microsoft.Build.Utilities.ExecutableType.Native64Bit = 1 -> Microsoft.Build.Utilities.ExecutableType
+Microsoft.Build.Utilities.ExecutableType.NativeARM64 = 6 -> Microsoft.Build.Utilities.ExecutableType
 Microsoft.Build.Utilities.ExecutableType.SameAsCurrentProcess = 5 -> Microsoft.Build.Utilities.ExecutableType
 Microsoft.Build.Utilities.FileTracker
 Microsoft.Build.Utilities.FlatTrackingData
diff --git a/src/Utilities/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Utilities/PublicAPI/net/PublicAPI.Unshipped.txt
index fa691b1b2a2..e69de29bb2d 100644
--- a/src/Utilities/PublicAPI/net/PublicAPI.Unshipped.txt
+++ b/src/Utilities/PublicAPI/net/PublicAPI.Unshipped.txt
@@ -1,2 +0,0 @@
-Microsoft.Build.Utilities.ExecutableType.ManagedARM64 = 7 -> Microsoft.Build.Utilities.ExecutableType
-Microsoft.Build.Utilities.ExecutableType.NativeARM64 = 6 -> Microsoft.Build.Utilities.ExecutableType
\ No newline at end of file
diff --git a/src/Utilities/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Utilities/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index e69de29bb2d..b08b45a21d6 100644
--- a/src/Utilities/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Utilities/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -0,0 +1,23 @@
+abstract Microsoft.Build.Utilities.AppDomainIsolatedTask.Execute() -> bool
+Microsoft.Build.Utilities.AppDomainIsolatedTask
+Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask() -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask(System.Resources.ResourceManager taskResources) -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
+Microsoft.Build.Utilities.AppDomainIsolatedTask.BuildEngine.set -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.HelpKeywordPrefix.get -> string
+Microsoft.Build.Utilities.AppDomainIsolatedTask.HelpKeywordPrefix.set -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.HostObject.get -> Microsoft.Build.Framework.ITaskHost
+Microsoft.Build.Utilities.AppDomainIsolatedTask.HostObject.set -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
+Microsoft.Build.Utilities.AppDomainIsolatedTask.TaskResources.get -> System.Resources.ResourceManager
+Microsoft.Build.Utilities.AppDomainIsolatedTask.TaskResources.set -> void
+Microsoft.Build.Utilities.AssemblyFoldersExInfo
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.AssemblyFoldersExInfo(Microsoft.Win32.RegistryHive hive, Microsoft.Win32.RegistryView view, string registryKey, string directoryPath, System.Version targetFrameworkVersion) -> void
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.DirectoryPath.get -> string
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.Hive.get -> Microsoft.Win32.RegistryHive
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.Key.get -> string
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.TargetFrameworkVersion.get -> System.Version
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.View.get -> Microsoft.Win32.RegistryView
+override Microsoft.Build.Utilities.AppDomainIsolatedTask.InitializeLifetimeService() -> object
+static Microsoft.Build.Utilities.ToolLocationHelper.GetAssemblyFoldersExInfo(string registryRoot, string targetFrameworkVersion, string registryKeySuffix, string osVersion, string platform, System.Reflection.ProcessorArchitecture targetProcessorArchitecture) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.AssemblyFoldersExInfo>
\ No newline at end of file
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index 6ee95e78c01..53f3d588300 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -522,4 +522,4 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataLazy()
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index f4daea8da3a..baa7385f829 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -10,15 +10,15 @@
 using System.Xml;
 
 using Microsoft.Build.Shared;
-#if FEATURE_WIN32_REGISTRY
 using Microsoft.Win32;
-#endif
 
 using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
 using UtilitiesDotNetFrameworkArchitecture = Microsoft.Build.Utilities.DotNetFrameworkArchitecture;
 using SharedDotNetFrameworkArchitecture = Microsoft.Build.Shared.DotNetFrameworkArchitecture;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.AssemblyFoldersFromConfig;
+using System.Runtime.Versioning;
+using Microsoft.Build.Framework;
 
 #nullable disable
 
@@ -294,7 +294,6 @@ public static class ToolLocationHelper
         /// </summary>
         public static string CurrentToolsVersion => MSBuildConstants.CurrentToolsVersion;
 
-#if FEATURE_WIN32_REGISTRY
         /// <summary>
         /// Get a sorted list of AssemblyFoldersExInfo which contain information about what directories the 3rd party assemblies are registered under for use during build and design time.
         ///
@@ -317,6 +316,7 @@ public static class ToolLocationHelper
         /// On a 32 bit machine we only add in the 32 bit hive.
         /// </param>
         /// <returns>List of AssemblyFoldersExInfo</returns>
+        [SupportedOSPlatform("windows")]
         public static IList<AssemblyFoldersExInfo> GetAssemblyFoldersExInfo(string registryRoot, string targetFrameworkVersion, string registryKeySuffix, string osVersion, string platform, System.Reflection.ProcessorArchitecture targetProcessorArchitecture)
         {
             ErrorUtilities.VerifyThrowArgumentLength(registryRoot, nameof(registryRoot));
@@ -329,7 +329,6 @@ public static IList<AssemblyFoldersExInfo> GetAssemblyFoldersExInfo(string regis
             assemblyFolders.AddRange(assemblyFoldersEx);
             return assemblyFolders;
         }
-#endif
 
         /// <summary>
         /// Get a sorted list of AssemblyFoldersFromConfigInfo which contain information about what directories the 3rd party assemblies are registered under for use during build and design time.
@@ -2470,12 +2469,10 @@ private static IEnumerable<TargetPlatformSDK> RetrieveTargetPlatformList(string[
                     var monikers = new Dictionary<TargetPlatformSDK, TargetPlatformSDK>();
                     GatherSDKListFromDirectory(sdkDiskRoots, monikers);
 
-#if FEATURE_REGISTRY_SDKS
-                    if (NativeMethodsShared.IsWindows)
+                    if (NativeMethodsShared.IsWindows && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
                     {
                         GatherSDKListFromRegistry(registryRoot, monikers);
                     }
-#endif
 
                     collection = monikers.Keys.ToList();
                     s_cachedTargetPlatforms.Add(cachedTargetPlatformsKey, collection);
@@ -2672,10 +2669,10 @@ internal static void GatherSDKListFromDirectory(List<string> diskroots, Dictiona
             }
         }
 
-#if FEATURE_REGISTRY_SDKS
         /// <summary>
         /// Given a registry location enumerate the registry and find the installed SDKs.
         /// </summary>
+        [SupportedOSPlatform("windows")]
         internal static void GatherSDKsFromRegistryImpl(Dictionary<TargetPlatformSDK, TargetPlatformSDK> platformMonikers, string registryKeyRoot, RegistryView registryView, RegistryHive registryHive, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, OpenBaseKey openBaseKey, FileExists fileExists)
         {
             ErrorUtilities.VerifyThrowArgumentNull(platformMonikers, "PlatformMonikers");
@@ -2866,6 +2863,7 @@ internal static void GatherSDKsFromRegistryImpl(Dictionary<TargetPlatformSDK, Ta
         ///  Gather the list of SDKs installed on the machine from the registry.
         ///  Do not parallelize the getting of these entries, order is important, we want the first ones in to win.
         /// </summary>
+        [SupportedOSPlatform("windows")]
         private static void GatherSDKListFromRegistry(string registryRoot, Dictionary<TargetPlatformSDK, TargetPlatformSDK> platformMonikers)
         {
             // Setup some delegates because the methods we call use them during unit testing.
@@ -2891,7 +2889,6 @@ private static void GatherSDKListFromRegistry(string registryRoot, Dictionary<Ta
                 GatherSDKsFromRegistryImpl(platformMonikers, registryRoot, RegistryView.Default, RegistryHive.LocalMachine, getSubkeyNames, getRegistrySubKeyDefaultValue, openBaseKey, fileExists);
             }
         }
-#endif
 
         /// <summary>
         /// Get the disk locations to search for sdks under. This can be overridden by an environment variable
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 6eb42bff3ff..cc316e7ad5e 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -33,7 +33,7 @@ public enum HostObjectInitializationStatus
         UseHostObjectToExecute,
 
         /// <summary>
-        /// This means that either there is no host object available, or that the host object is 
+        /// This means that either there is no host object available, or that the host object is
         /// not capable of supporting all of the features required for this build.  Therefore,
         /// ToolTask should fallback to an alternate means of doing the build, such as invoking
         /// the command-line tool.
@@ -56,7 +56,7 @@ public enum HostObjectInitializationStatus
     /// Base class used for tasks that spawn an executable. This class implements the ToolPath property which can be used to
     /// override the default path.
     /// </summary>
-    // INTERNAL WARNING: DO NOT USE the Log property in this class! Log points to resources in the task assembly itself, and 
+    // INTERNAL WARNING: DO NOT USE the Log property in this class! Log points to resources in the task assembly itself, and
     // we want to use resources from Utilities. Use LogPrivate (for private Utilities resources) and LogShared (for shared MSBuild resources)
     public abstract class ToolTask : Task, ICancelableTask
     {
@@ -65,7 +65,7 @@ public abstract class ToolTask : Task, ICancelableTask
         #region Constructors
 
         /// <summary>
-        /// Protected constructor 
+        /// Protected constructor
         /// </summary>
         protected ToolTask()
         {
@@ -87,7 +87,7 @@ protected ToolTask()
         }
 
         /// <summary>
-        /// Protected constructor 
+        /// Protected constructor
         /// </summary>
         /// <param name="taskResources">The resource manager for task resources</param>
         protected ToolTask(ResourceManager taskResources)
@@ -97,7 +97,7 @@ protected ToolTask(ResourceManager taskResources)
         }
 
         /// <summary>
-        /// Protected constructor 
+        /// Protected constructor
         /// </summary>
         /// <param name="taskResources">The resource manager for task resources</param>
         /// <param name="helpKeywordPrefix">The help keyword prefix for task's messages</param>
@@ -112,7 +112,7 @@ protected ToolTask(ResourceManager taskResources, string helpKeywordPrefix)
         #region Properties
 
         /// <summary>
-        /// The return code of the spawned process. If the task logged any errors, but the process 
+        /// The return code of the spawned process. If the task logged any errors, but the process
         /// had an exit code of 0 (success), this will be set to -1.
         /// </summary>
         [Output]
@@ -187,7 +187,7 @@ public virtual string ToolExe
         /// <summary>
         /// Whether or not to use UTF8 encoding for the cmd file and console window.
         /// Values: Always, Never, Detect
-        /// If set to Detect, the current code page will be used unless it cannot represent 
+        /// If set to Detect, the current code page will be used unless it cannot represent
         /// the Command string. In that case, UTF-8 is used.
         /// </summary>
         public string UseUtf8Encoding { get; set; } = EncodingUtilities.UseUtf8Detect;
@@ -205,7 +205,7 @@ public virtual string ToolExe
 
         /// <summary>
         /// Project visible property that allows the user to specify an amount of time after which the task executable
-        /// is terminated. 
+        /// is terminated.
         /// </summary>
         /// <value>Time-out in milliseconds. Default is <see cref="System.Threading.Timeout.Infinite"/> (no time-out).</value>
         public virtual int Timeout { set; get; } = System.Threading.Timeout.Infinite;
@@ -326,7 +326,7 @@ public virtual string ToolExe
         protected virtual void ProcessStarted() { }
 
         /// <summary>
-        /// Gets the fully qualified tool name. Should return ToolExe if ToolTask should search for the tool 
+        /// Gets the fully qualified tool name. Should return ToolExe if ToolTask should search for the tool
         /// in the system path. If ToolPath is set, this is ignored.
         /// </summary>
         /// <returns>Path string.</returns>
@@ -334,7 +334,7 @@ protected virtual void ProcessStarted() { }
 
         /// <summary>
         /// Gets the working directory to use for the process. Should return null if ToolTask should use the
-        /// current directory. 
+        /// current directory.
         /// </summary>
         /// <remarks>This is a method rather than a property so that derived classes (like Exec) can choose to
         /// expose a public WorkingDirectory property, and it would be confusing to have two properties.</remarks>
@@ -413,7 +413,7 @@ protected virtual bool HandleTaskExecutionErrors()
 
         /// <summary>
         /// We expect tasks to override this method if they support host objects.  The implementation should
-        /// make sure that the host object is ready to perform the real work of the task.  
+        /// make sure that the host object is ready to perform the real work of the task.
         /// </summary>
         /// <returns>The return value indicates what steps to take next.  The default is to assume that there
         /// is no host object provided, and therefore we should fallback to calling the command-line tool.</returns>
@@ -480,7 +480,7 @@ private string ComputePathToTool()
                 }
             }
 
-            // only look for the file if we have a path to it. If we have just the file name, we'll 
+            // only look for the file if we have a path to it. If we have just the file name, we'll
             // look for it in the path
             if (pathToTool != null)
             {
@@ -627,12 +627,7 @@ string responseFileSwitch
             {
                 foreach (KeyValuePair<string, string> entry in envOverrides)
                 {
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
                     startInfo.Environment[entry.Key] = entry.Value;
-#else
-                    startInfo.EnvironmentVariables[entry.Key] = entry.Value;
-#endif
-
                 }
 #pragma warning restore 0618
             }
@@ -642,11 +637,7 @@ string responseFileSwitch
             {
                 foreach (KeyValuePair<string, string> variable in _environmentVariablePairs)
                 {
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
                     startInfo.Environment[variable.Key] = variable.Value;
-#else
-                    startInfo.EnvironmentVariables[variable.Key] = variable.Value;
-#endif
                 }
             }
 
@@ -807,7 +798,7 @@ protected void DeleteTempFile(string fileName)
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
-                // Warn only -- occasionally temp files fail to delete because of virus checkers; we 
+                // Warn only -- occasionally temp files fail to delete because of virus checkers; we
                 // don't want the build to fail in such cases
                 LogShared.LogWarningWithCodeFromResources("Shared.FailedDeletingTempFile", fileName, e.Message);
             }
@@ -1225,7 +1216,7 @@ private bool AssignStandardStreamLoggingImportance()
             {
                 try
                 {
-                    // Parse the raw importance string into a strongly typed enumeration.  
+                    // Parse the raw importance string into a strongly typed enumeration.
                     _standardErrorImportanceToUse = (MessageImportance)Enum.Parse(typeof(MessageImportance), StandardErrorImportance, true /* case-insensitive */);
                 }
                 catch (ArgumentException)
@@ -1245,7 +1236,7 @@ private bool AssignStandardStreamLoggingImportance()
             {
                 try
                 {
-                    // Parse the raw importance string into a strongly typed enumeration.  
+                    // Parse the raw importance string into a strongly typed enumeration.
                     _standardOutputImportanceToUse = (MessageImportance)Enum.Parse(typeof(MessageImportance), StandardOutputImportance, true /* case-insensitive */);
                 }
                 catch (ArgumentException)
@@ -1386,7 +1377,7 @@ public override bool Execute()
 
                             if (encoding.CodePage != EncodingUtilities.CurrentSystemOemEncoding.CodePage)
                             {
-                                // cmd.exe reads the first line in the console CP, 
+                                // cmd.exe reads the first line in the console CP,
                                 // which for a new console (as here) is OEMCP
                                 // this string should ideally always be ASCII
                                 // and the same in any OEMCP.
@@ -1433,7 +1424,7 @@ public override bool Execute()
 
                 // Initialize the host object.  At this point, the task may elect
                 // to not proceed.  Compiler tasks do this for purposes of up-to-date
-                // checking in the IDE.  
+                // checking in the IDE.
                 HostObjectInitializationStatus nextAction = InitializeHostObject();
                 if (nextAction == HostObjectInitializationStatus.NoActionReturnSuccess)
                 {
@@ -1483,13 +1474,13 @@ public override bool Execute()
 
                 if (UseCommandProcessor)
                 {
-                    // Log that we are about to invoke the specified command.  
+                    // Log that we are about to invoke the specified command.
                     LogToolCommand(pathToTool + commandLineCommands);
                     LogToolCommand(batchFileContents);
                 }
                 else
                 {
-                    // Log that we are about to invoke the specified command.  
+                    // Log that we are about to invoke the specified command.
                     LogToolCommand(pathToTool + commandLineCommands + " " + responseFileCommands);
                 }
                 ExitCode = 0;
@@ -1497,7 +1488,7 @@ public override bool Execute()
                 if (nextAction == HostObjectInitializationStatus.UseHostObjectToExecute)
                 {
                     // The hosting IDE passed in a host object to this task.  Give the task
-                    // a chance to call this host object to do the actual work.  
+                    // a chance to call this host object to do the actual work.
                     try
                     {
                         if (!CallHostObjectToExecute())
@@ -1632,12 +1623,12 @@ private bool LogEnvironmentVariable(bool alreadyLoggedEnvironmentHeader, string
         private static readonly char[] s_equalsSplitter = MSBuildConstants.EqualsChar;
 
         /// <summary>
-        /// The actual importance at which standard out messages will be logged 
+        /// The actual importance at which standard out messages will be logged
         /// </summary>
         private MessageImportance _standardOutputImportanceToUse = MessageImportance.Low;
 
         /// <summary>
-        /// The actual importance at which standard error messages will be logged 
+        /// The actual importance at which standard error messages will be logged
         /// </summary>
         private MessageImportance _standardErrorImportanceToUse = MessageImportance.Normal;
 
@@ -1669,7 +1660,7 @@ private bool LogEnvironmentVariable(bool alreadyLoggedEnvironmentHeader, string
         private ManualResetEvent _toolExited;
 
         /// <summary>
-        /// Set to true if the tool process was terminated, 
+        /// Set to true if the tool process was terminated,
         /// either because the timeout was reached or it was canceled.
         /// </summary>
         private bool _terminatedTool;
