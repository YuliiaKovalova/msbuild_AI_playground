diff --git a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
index 887de160539..f8b86a5a5ad 100644
--- a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
@@ -594,11 +594,13 @@ public TaskCommandLineEventArgs(string commandLine, string taskName, Microsoft.B
     }
     public partial class TaskExecutionContext
     {
+        public TaskExecutionContext() { }
         public TaskExecutionContext(string startupDirectory, System.Collections.Generic.Dictionary<string, string> buildProcessEnvironment, System.Globalization.CultureInfo culture, System.Globalization.CultureInfo uiCulture) { }
         public System.Collections.Generic.Dictionary<string, string> BuildProcessEnvironment { get { throw null; } }
         public System.Globalization.CultureInfo Culture { get { throw null; } }
         public string StartupDirectory { get { throw null; } }
         public System.Globalization.CultureInfo UICulture { get { throw null; } }
+        public string GetFullPath(string path) { throw null; }
     }
     public partial class TaskFinishedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
     {
diff --git a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
index fa36f414395..481d3e8aba1 100644
--- a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
@@ -593,11 +593,13 @@ public TaskCommandLineEventArgs(string commandLine, string taskName, Microsoft.B
     }
     public partial class TaskExecutionContext
     {
+        public TaskExecutionContext() { }
         public TaskExecutionContext(string startupDirectory, System.Collections.Generic.Dictionary<string, string> buildProcessEnvironment, System.Globalization.CultureInfo culture, System.Globalization.CultureInfo uiCulture) { }
         public System.Collections.Generic.Dictionary<string, string> BuildProcessEnvironment { get { throw null; } }
         public System.Globalization.CultureInfo Culture { get { throw null; } }
         public string StartupDirectory { get { throw null; } }
         public System.Globalization.CultureInfo UICulture { get { throw null; } }
+        public string GetFullPath(string path) { throw null; }
     }
     public partial class TaskFinishedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
     {
diff --git a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
index 319ce95d300..dbda193ec76 100644
--- a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
@@ -920,6 +920,7 @@ public ResolveAssemblyReference() { }
         public Microsoft.Build.Framework.ITaskItem[] AssemblyInformationCachePaths { get { throw null; } set { } }
         public bool AutoUnify { get { throw null; } set { } }
         public string[] CandidateAssemblyFiles { get { throw null; } set { } }
+        public Microsoft.Build.Framework.TaskExecutionContext ConcurrencyExecutionContext { get { throw null; } set { } }
         public bool CopyLocalDependenciesWhenParentReferenceInGac { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         public Microsoft.Build.Framework.ITaskItem[] CopyLocalFiles { get { throw null; } }
diff --git a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
index 7ca8c3be56c..6ed70860a5a 100644
--- a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
@@ -665,6 +665,7 @@ public ResolveAssemblyReference() { }
         public Microsoft.Build.Framework.ITaskItem[] AssemblyInformationCachePaths { get { throw null; } set { } }
         public bool AutoUnify { get { throw null; } set { } }
         public string[] CandidateAssemblyFiles { get { throw null; } set { } }
+        public Microsoft.Build.Framework.TaskExecutionContext ConcurrencyExecutionContext { get { throw null; } set { } }
         public bool CopyLocalDependenciesWhenParentReferenceInGac { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         public Microsoft.Build.Framework.ITaskItem[] CopyLocalFiles { get { throw null; } }
diff --git a/src/Framework/TaskExecutionContext.cs b/src/Framework/TaskExecutionContext.cs
index d6cb69307b3..98715d9e659 100644
--- a/src/Framework/TaskExecutionContext.cs
+++ b/src/Framework/TaskExecutionContext.cs
@@ -1,13 +1,28 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
 using System.Collections.Generic;
 using System.Globalization;
+using System.IO;
 
 namespace Microsoft.Build.Framework
 {
     public class TaskExecutionContext
     {
+        public string StartupDirectory { get; }
+        public Dictionary<string, string> BuildProcessEnvironment { get; }
+        public CultureInfo Culture { get; }
+        public CultureInfo UICulture { get; }
+
+        public TaskExecutionContext()
+        {
+            StartupDirectory = null;
+            BuildProcessEnvironment = null;
+            Culture = null;
+            UICulture = null;
+        }
+
         public TaskExecutionContext(string startupDirectory, Dictionary<string, string> buildProcessEnvironment, CultureInfo culture, CultureInfo uiCulture)
         {
             StartupDirectory = startupDirectory;
@@ -16,10 +31,20 @@ public TaskExecutionContext(string startupDirectory, Dictionary<string, string>
             UICulture = uiCulture;
         }
 
-        public string StartupDirectory { get; }
-        public Dictionary<string, string> BuildProcessEnvironment { get; }
-        public CultureInfo Culture { get; }
-        public CultureInfo UICulture { get; }
+        /// <summary>
+        /// Absolutize the given path with the startup directory.
+        /// </summary>
+        /// <param name="path">Relative or absolute path.</param>
+        /// <returns></returns>
+        public string GetFullPath(string path)
+        {
+            if (String.IsNullOrEmpty(StartupDirectory) || String.IsNullOrEmpty(path))
+            {
+                return path;
+            }
+
+            return Path.Combine(StartupDirectory, path);
+        }
     }
 
     // TODO: move to own file
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index 2d0aaec17b3..3ee1944bf54 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -3316,7 +3316,7 @@ private ReferenceTable GenerateTableWithAssemblyFromTheGlobalLocation(string loc
 #if FEATURE_WIN32_REGISTRY
                 null, null, null,
 #endif
-                null, null, new Version("4.0"), null, null, null, true, false, null, null, false, null, WarnOrErrorOnTargetArchitectureMismatchBehavior.None, false, false, null);
+                null, null, new Version("4.0"), null, null, null, true, false, null, null, false, null, WarnOrErrorOnTargetArchitectureMismatchBehavior.None, false, false, null, new TaskExecutionContext());
 
             AssemblyNameExtension assemblyNameExtension = new AssemblyNameExtension(new AssemblyName("Microsoft.VisualStudio.Interopt, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"));
             TaskItem taskItem = new TaskItem("Microsoft.VisualStudio.Interopt, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
@@ -6821,7 +6821,7 @@ public void ReferenceTableDependentItemsInBlackList4()
 #if FEATURE_WIN32_REGISTRY
                 null, null, null,
 #endif
-                null, null, null, new Version("4.0"), null, null, null, true, false, null, null, false, null, WarnOrErrorOnTargetArchitectureMismatchBehavior.None, false, false, null);
+                null, null, null, new Version("4.0"), null, null, null, true, false, null, null, false, null, WarnOrErrorOnTargetArchitectureMismatchBehavior.None, false, false, null, new TaskExecutionContext());
             MockEngine mockEngine;
             ResolveAssemblyReference rar;
             Dictionary<string, string> blackList;
@@ -6999,7 +6999,7 @@ private static ReferenceTable MakeEmptyReferenceTable(TaskLoggingHelper log)
 #if FEATURE_WIN32_REGISTRY
                 null, null, null,
 #endif
-                null, null, new Version("4.0"), null, log, null, true, false, null, null, false, null, WarnOrErrorOnTargetArchitectureMismatchBehavior.None, false, false, null);
+                null, null, new Version("4.0"), null, log, null, true, false, null, null, false, null, WarnOrErrorOnTargetArchitectureMismatchBehavior.None, false, false, null, new TaskExecutionContext());
             return referenceTable;
         }
 
diff --git a/src/Tasks.UnitTests/HintPathResolver_Tests.cs b/src/Tasks.UnitTests/HintPathResolver_Tests.cs
index 37f8f89445c..6f1631539e8 100644
--- a/src/Tasks.UnitTests/HintPathResolver_Tests.cs
+++ b/src/Tasks.UnitTests/HintPathResolver_Tests.cs
@@ -1,4 +1,5 @@
-﻿using Microsoft.Build.Shared;
+﻿using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Shouldly;
 using System;
@@ -67,7 +68,8 @@ private bool ResolveHintPath(string hintPath)
                 getAssemblyName: (path) => throw new NotImplementedException(), // not called in this code path
                 fileExists: p => FileUtilities.FileExistsNoThrow(p),
                 getRuntimeVersion: (path) => throw new NotImplementedException(), // not called in this code path
-                targetedRuntimeVesion: Version.Parse("4.0.30319"));
+                targetedRuntimeVesion: Version.Parse("4.0.30319"),
+                new TaskExecutionContext());
 
             var result = hintPathResolver.Resolve(new AssemblyNameExtension("FakeSystem.Net.Http"),
                 sdkName: "",
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
index ab6b685ba91..bc84ca3f43c 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
@@ -99,8 +99,20 @@ internal class AssemblyFoldersExResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        public AssemblyFoldersExResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, GetAssemblyRuntimeVersion getRuntimeVersion, OpenBaseKey openBaseKey, Version targetedRuntimeVesion, ProcessorArchitecture targetProcessorArchitecture, bool compareProcessorArchitecture, IBuildEngine buildEngine)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, targetProcessorArchitecture, compareProcessorArchitecture)
+        public AssemblyFoldersExResolver(
+            string searchPathElement,
+            GetAssemblyName getAssemblyName,
+            FileExists fileExists,
+            GetRegistrySubKeyNames getRegistrySubKeyNames,
+            GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue,
+            GetAssemblyRuntimeVersion getRuntimeVersion,
+            OpenBaseKey openBaseKey, Version targetedRuntimeVesion,
+            ProcessorArchitecture targetProcessorArchitecture,
+            bool compareProcessorArchitecture,
+            IBuildEngine buildEngine,
+            TaskExecutionContext executionContext
+        )
+            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, targetProcessorArchitecture, compareProcessorArchitecture, executionContext)
         {
             _buildEngine = buildEngine as IBuildEngine4;
             _getRegistrySubKeyNames = getRegistrySubKeyNames;
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigCache.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigCache.cs
index 48ab0527f2a..ac62c99f969 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigCache.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigCache.cs
@@ -2,6 +2,7 @@
 using System.Collections.Immutable;
 using System.IO;
 using System.Linq;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks.AssemblyFoldersFromConfig
@@ -29,7 +30,7 @@ internal class AssemblyFoldersFromConfigCache
         /// <summary>
         /// Constructor
         /// </summary>
-        internal AssemblyFoldersFromConfigCache(AssemblyFoldersFromConfig assemblyFoldersFromConfig, FileExists fileExists)
+        internal AssemblyFoldersFromConfigCache(AssemblyFoldersFromConfig assemblyFoldersFromConfig, FileExists fileExists, TaskExecutionContext executionContext)
         {
             AssemblyFoldersFromConfig = assemblyFoldersFromConfig;
             _fileExists = fileExists;
@@ -40,11 +41,11 @@ internal AssemblyFoldersFromConfigCache(AssemblyFoldersFromConfig assemblyFolder
             }
             else
             {
-                _filesInDirectories = assemblyFoldersFromConfig.AsParallel()
-                    .Where(assemblyFolder => FileUtilities.DirectoryExistsNoThrow(assemblyFolder.DirectoryPath))
+                _filesInDirectories = assemblyFoldersFromConfig.Select(assemblyFolder => executionContext.GetFullPath(assemblyFolder.DirectoryPath)).AsParallel()
+                    .Where(directoryPath => FileUtilities.DirectoryExistsNoThrow(directoryPath))
                     .SelectMany(
-                        assemblyFolder =>
-                            Directory.GetFiles(assemblyFolder.DirectoryPath, "*.*", SearchOption.TopDirectoryOnly))
+                        directoryPath =>
+                            Directory.GetFiles(directoryPath, "*.*", SearchOption.TopDirectoryOnly))
                     .ToImmutableHashSet(StringComparer.OrdinalIgnoreCase);
             }
         }
@@ -64,4 +65,4 @@ internal bool FileExists(string path)
             return _useOriginalFileExists ? _fileExists(path) : _filesInDirectories.Contains(path);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
index e6e2a2bcb80..d30ab65a6e9 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
@@ -76,10 +76,10 @@ internal class AssemblyFoldersFromConfigResolver : Resolver
         public AssemblyFoldersFromConfigResolver(string searchPathElement, GetAssemblyName getAssemblyName,
             FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion,
             ProcessorArchitecture targetProcessorArchitecture, bool compareProcessorArchitecture,
-            IBuildEngine buildEngine, TaskLoggingHelper log)
+            IBuildEngine buildEngine, TaskLoggingHelper log, TaskExecutionContext executionContext)
             : base(
                 searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion,
-                targetProcessorArchitecture, compareProcessorArchitecture)
+                targetProcessorArchitecture, compareProcessorArchitecture, executionContext)
         {
             _buildEngine = buildEngine as IBuildEngine4;
             _taskLogger = log;
@@ -102,7 +102,9 @@ private void LazyInitialize()
             if (match.Success)
             {
                 _targetRuntimeVersion = match.Groups["TARGETRUNTIMEVERSION"].Value.Trim();
+
                 _assemblyFolderConfigFile = match.Groups["ASSEMBLYFOLDERCONFIGFILE"].Value.Trim();
+                _assemblyFolderConfigFile = executionContext.GetFullPath(_assemblyFolderConfigFile);
 
                 if (_targetRuntimeVersion.Length != 0)
                 {
@@ -115,7 +117,7 @@ private void LazyInitialize()
                     _wasMatch = true;
 
                     bool useCache = Environment.GetEnvironmentVariable("MSBUILDDISABLEASSEMBLYFOLDERSEXCACHE") == null;
-                    string key = "6f7de854-47fe-4ae2-9cfe-9b33682abd91" + searchPathElement;
+                    string key = _assemblyFolderConfigFile + "6f7de854-47fe-4ae2-9cfe-9b33682abd91" + _targetRuntimeVersion;
                     
                     if (useCache && _buildEngine != null)
                     {
@@ -132,7 +134,7 @@ private void LazyInitialize()
                         try
                         {
                             AssemblyFoldersFromConfig assemblyFolders = new AssemblyFoldersFromConfig(_assemblyFolderConfigFile, _targetRuntimeVersion, targetProcessorArchitecture);
-                            _assemblyFoldersCache = new AssemblyFoldersFromConfigCache(assemblyFolders, fileExists);
+                            _assemblyFoldersCache = new AssemblyFoldersFromConfigCache(assemblyFolders, fileExists, executionContext);
                             if (useCache)
                             {
                                 _buildEngine?.RegisterTaskObject(key, _assemblyFoldersCache, RegisteredTaskObjectLifetime.Build, true /* dispose early ok*/);
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
index 82fbcc95204..92c6afb74c7 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -20,8 +21,16 @@ internal class AssemblyFoldersResolver : Resolver
         /// <param name="fileExists">Delegate that returns if the file exists.</param>
         /// <param name="getRuntimeVersion">Delegate that returns the clr runtime version for the file.</param>
         /// <param name="targetedRuntimeVesion">The targeted runtime version.</param>
-        public AssemblyFoldersResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
+        /// <param name="executionContext">Execution context: current directory, culture, etc.</param>
+        public AssemblyFoldersResolver(
+            string searchPathElement,
+            GetAssemblyName getAssemblyName,
+            FileExists fileExists,
+            GetAssemblyRuntimeVersion getRuntimeVersion,
+            Version targetedRuntimeVesion,
+            TaskExecutionContext executionContext
+        )
+            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false, executionContext)
         {
         }
 
diff --git a/src/Tasks/AssemblyDependency/AssemblyResolution.cs b/src/Tasks/AssemblyDependency/AssemblyResolution.cs
index f2fe396824f..4b5a0339d7c 100644
--- a/src/Tasks/AssemblyDependency/AssemblyResolution.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyResolution.cs
@@ -118,6 +118,7 @@ out userRequestedSpecificFile
         /// <param name="targetedRuntimeVersion"></param>
         /// <param name="getAssemblyPathInGac"></param>
         /// <param name="log"></param>
+        /// <param name="executionContext">Execution context: current directory, culture, etc.</param>
         /// <returns></returns>
 #else
         /// <summary>
@@ -135,6 +136,7 @@ out userRequestedSpecificFile
         /// <param name="targetedRuntimeVersion"></param>
         /// <param name="getAssemblyPathInGac"></param>
         /// <param name="log"></param>
+        /// <param name="executionContext">Execution context: current directory, culture, etc.</param>
         /// <returns></returns>
 #endif
         public static Resolver[] CompileSearchPaths
@@ -155,7 +157,8 @@ public static Resolver[] CompileSearchPaths
             GetAssemblyRuntimeVersion getRuntimeVersion,
             Version targetedRuntimeVersion,
             GetAssemblyPathInGac getAssemblyPathInGac,
-            TaskLoggingHelper log
+            TaskLoggingHelper log,
+            TaskExecutionContext executionContext
         )
         {
             var resolvers = new Resolver[searchPaths.Length];
@@ -168,44 +171,44 @@ TaskLoggingHelper log
                 // HintPath property.
                 if (String.Equals(basePath, AssemblyResolutionConstants.hintPathSentinel, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new HintPathResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
+                    resolvers[p] = new HintPathResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion, executionContext);
                 }
                 else if (String.Equals(basePath, AssemblyResolutionConstants.frameworkPathSentinel, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new FrameworkPathResolver(frameworkPaths, installedAssemblies, searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
+                    resolvers[p] = new FrameworkPathResolver(frameworkPaths, installedAssemblies, searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion, executionContext);
                 }
                 else if (String.Equals(basePath, AssemblyResolutionConstants.rawFileNameSentinel, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new RawFilenameResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
+                    resolvers[p] = new RawFilenameResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion, executionContext);
                 }
                 else if (String.Equals(basePath, AssemblyResolutionConstants.candidateAssemblyFilesSentinel, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new CandidateAssemblyFilesResolver(candidateAssemblyFiles, searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
+                    resolvers[p] = new CandidateAssemblyFilesResolver(candidateAssemblyFiles, searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion, executionContext);
                 }
 #if FEATURE_GAC
                 else if (String.Equals(basePath, AssemblyResolutionConstants.gacSentinel, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new GacResolver(targetProcessorArchitecture, searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion, getAssemblyPathInGac);
+                    resolvers[p] = new GacResolver(targetProcessorArchitecture, searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion, getAssemblyPathInGac, executionContext);
                 }
 #endif
                 else if (String.Equals(basePath, AssemblyResolutionConstants.assemblyFoldersSentinel, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new AssemblyFoldersResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
+                    resolvers[p] = new AssemblyFoldersResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion, executionContext);
                 }
 #if FEATURE_WIN32_REGISTRY
                 // Check for AssemblyFoldersEx sentinel.
                 else if (0 == String.Compare(basePath, 0, AssemblyResolutionConstants.assemblyFoldersExSentinel, 0, AssemblyResolutionConstants.assemblyFoldersExSentinel.Length, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new AssemblyFoldersExResolver(searchPaths[p], getAssemblyName, fileExists, getRegistrySubKeyNames, getRegistrySubKeyDefaultValue, getRuntimeVersion, openBaseKey, targetedRuntimeVersion, targetProcessorArchitecture, true, buildEngine);
+                    resolvers[p] = new AssemblyFoldersExResolver(searchPaths[p], getAssemblyName, fileExists, getRegistrySubKeyNames, getRegistrySubKeyDefaultValue, getRuntimeVersion, openBaseKey, targetedRuntimeVersion, targetProcessorArchitecture, true, buildEngine, executionContext);
                 }
 #endif
                 else if (0 == String.Compare(basePath, 0, AssemblyResolutionConstants.assemblyFoldersFromConfigSentinel, 0, AssemblyResolutionConstants.assemblyFoldersFromConfigSentinel.Length, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new AssemblyFoldersFromConfigResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion, targetProcessorArchitecture, true, buildEngine, log);
+                    resolvers[p] = new AssemblyFoldersFromConfigResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion, targetProcessorArchitecture, true, buildEngine, log, executionContext);
                 }
                 else
                 {
-                    resolvers[p] = new DirectoryResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
+                    resolvers[p] = new DirectoryResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion, executionContext);
                 }
             }
             return resolvers;
@@ -220,13 +223,14 @@ internal static Resolver[] CompileDirectories
             FileExists fileExists,
             GetAssemblyName getAssemblyName,
             GetAssemblyRuntimeVersion getRuntimeVersion,
-            Version targetedRuntimeVersion
+            Version targetedRuntimeVersion,
+            TaskExecutionContext executionContext
         )
         {
             var resolvers = new Resolver[directories.Count];
             for (int i = 0; i < directories.Count; i++)
             {
-                resolvers[i] = new DirectoryResolver(directories[i], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
+                resolvers[i] = new DirectoryResolver(directories[i], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion, executionContext);
             }
 
             return resolvers;
diff --git a/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs b/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
index 23ccac23cb2..ade9350fc7e 100644
--- a/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
+++ b/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
@@ -6,6 +6,7 @@
 using System.Reflection;
 using Microsoft.Build.Shared;
 using System.Diagnostics;
+using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Tasks
 {
@@ -28,8 +29,17 @@ internal class CandidateAssemblyFilesResolver : Resolver
         /// <param name="fileExists">Delegate that returns if the file exists.</param>
         /// <param name="getRuntimeVersion">Delegate that returns the clr runtime version for the file.</param>
         /// <param name="targetedRuntimeVesion">The targeted runtime version.</param>
-        public CandidateAssemblyFilesResolver(string[] candidateAssemblyFiles, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false)
+        /// <param name="executionContext">Execution context: current directory, culture, etc.</param>
+        public CandidateAssemblyFilesResolver(
+            string[] candidateAssemblyFiles,
+            string searchPathElement,
+            GetAssemblyName getAssemblyName,
+            FileExists fileExists,
+            GetAssemblyRuntimeVersion getRuntimeVersion,
+            Version targetedRuntimeVesion,
+            TaskExecutionContext executionContext
+        )
+            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false, executionContext)
         {
             _candidateAssemblyFiles = candidateAssemblyFiles;
         }
diff --git a/src/Tasks/AssemblyDependency/DirectoryResolver.cs b/src/Tasks/AssemblyDependency/DirectoryResolver.cs
index 8f7be0e76ac..b0fc409f944 100644
--- a/src/Tasks/AssemblyDependency/DirectoryResolver.cs
+++ b/src/Tasks/AssemblyDependency/DirectoryResolver.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -15,8 +16,15 @@ internal class DirectoryResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        public DirectoryResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
+        public DirectoryResolver(
+            string searchPathElement,
+            GetAssemblyName getAssemblyName,
+            FileExists fileExists,
+            GetAssemblyRuntimeVersion getRuntimeVersion,
+            Version targetedRuntimeVesion,
+            TaskExecutionContext executionContext
+        )
+            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false, executionContext)
         {
         }
 
@@ -53,8 +61,8 @@ out bool userRequestedSpecificFile
             foundPath = null;
             userRequestedSpecificFile = false;
 
-            // Resolve to the given path.
-            string resolvedPath = ResolveFromDirectory(assemblyName, isPrimaryProjectReference, wantSpecificVersion, executableExtensions, searchPathElement, assembliesConsideredAndRejected);
+            string directory = FullSearchPath;
+            string resolvedPath = ResolveFromDirectory(assemblyName, isPrimaryProjectReference, wantSpecificVersion, executableExtensions, directory, assembliesConsideredAndRejected);
             if (resolvedPath != null)
             {
                 foundPath = resolvedPath;
diff --git a/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs b/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
index bfee4b6dc71..850f3d2f577 100644
--- a/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
+++ b/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -21,8 +22,17 @@ internal class FrameworkPathResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        public FrameworkPathResolver(string[] frameworkPaths, InstalledAssemblies installedAssemblies, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
+        public FrameworkPathResolver(
+            string[] frameworkPaths,
+            InstalledAssemblies installedAssemblies,
+            string searchPathElement,
+            GetAssemblyName getAssemblyName,
+            FileExists fileExists,
+            GetAssemblyRuntimeVersion getRuntimeVersion,
+            Version targetedRuntimeVesion,
+            TaskExecutionContext executionContext
+        )
+            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false, executionContext)
         {
             _frameworkPaths = frameworkPaths;
             _installedAssemblies = installedAssemblies;
diff --git a/src/Tasks/AssemblyDependency/GacResolver.cs b/src/Tasks/AssemblyDependency/GacResolver.cs
index 16342d58a31..18f05221797 100644
--- a/src/Tasks/AssemblyDependency/GacResolver.cs
+++ b/src/Tasks/AssemblyDependency/GacResolver.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -27,8 +28,18 @@ internal class GacResolver : Resolver
         /// <param name="getRuntimeVersion">Delegate to get the runtime version.</param>
         /// <param name="targetedRuntimeVesion">The targeted runtime version.</param>
         /// <param name="getAssemblyPathInGac">Delegate to get assembly path in the GAC.</param>
-        public GacResolver(System.Reflection.ProcessorArchitecture targetProcessorArchitecture, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion, GetAssemblyPathInGac getAssemblyPathInGac)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, targetProcessorArchitecture, true)
+        /// <param name="executionContext">Execution context: current directory, culture, etc.</param>
+        public GacResolver(
+            System.Reflection.ProcessorArchitecture targetProcessorArchitecture,
+            string searchPathElement,
+            GetAssemblyName getAssemblyName,
+            FileExists fileExists,
+            GetAssemblyRuntimeVersion getRuntimeVersion,
+            Version targetedRuntimeVesion,
+            GetAssemblyPathInGac getAssemblyPathInGac,
+            TaskExecutionContext executionContext
+        )
+            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, targetProcessorArchitecture, true, executionContext)
         {
             _getAssemblyPathInGac = getAssemblyPathInGac;
         }
diff --git a/src/Tasks/AssemblyDependency/HintPathResolver.cs b/src/Tasks/AssemblyDependency/HintPathResolver.cs
index d4a90c0e2b4..289f6baef81 100644
--- a/src/Tasks/AssemblyDependency/HintPathResolver.cs
+++ b/src/Tasks/AssemblyDependency/HintPathResolver.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Reflection;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -16,8 +17,15 @@ internal class HintPathResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        public HintPathResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false)
+        public HintPathResolver(
+            string searchPathElement,
+            GetAssemblyName getAssemblyName,
+            FileExists fileExists,
+            GetAssemblyRuntimeVersion getRuntimeVersion,
+            Version targetedRuntimeVesion,
+            TaskExecutionContext executionContext
+        )
+            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false, executionContext)
         {
         }
 
diff --git a/src/Tasks/AssemblyDependency/RawFilenameResolver.cs b/src/Tasks/AssemblyDependency/RawFilenameResolver.cs
index b75ef96a73b..58fc65458d1 100644
--- a/src/Tasks/AssemblyDependency/RawFilenameResolver.cs
+++ b/src/Tasks/AssemblyDependency/RawFilenameResolver.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Reflection;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -16,8 +17,15 @@ internal class RawFilenameResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        public RawFilenameResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false)
+        public RawFilenameResolver(
+            string searchPathElement,
+            GetAssemblyName getAssemblyName,
+            FileExists fileExists,
+            GetAssemblyRuntimeVersion getRuntimeVersion,
+            Version targetedRuntimeVesion,
+            TaskExecutionContext executionContext
+        )
+            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false, executionContext)
         {
         }
 
@@ -54,8 +62,11 @@ out bool userRequestedSpecificFile
             foundPath = null;
             userRequestedSpecificFile = false;
 
-            if (rawFileNameCandidate != null)
-            {
+            if (rawFileNameCandidate is object)
+            {  
+
+                rawFileNameCandidate = executionContext.GetFullPath(rawFileNameCandidate);
+
                 // {RawFileName} was passed in.
                 if (fileExists(rawFileNameCandidate))
                 {
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 5967f4c1cdf..0c107b31445 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -144,6 +144,8 @@ internal sealed class ReferenceTable
 
         private readonly ConcurrentDictionary<string, AssemblyMetadata> _assemblyMetadataCache;
 
+        private readonly TaskExecutionContext _executionContext;
+
         /// <summary>
         /// When we exclude an assembly from resolution because it is part of out exclusion list we need to let the user know why this is.
         /// There can be a number of reasons each for un-resolving a reference, these reasons are encapsulated by a different black list. We need to log a specific message
@@ -184,6 +186,7 @@ internal sealed class ReferenceTable
         /// <param name="openBaseKey"></param>
         /// <param name="unresolveFrameworkAssembliesFromHigherFrameworks"></param>
         /// <param name="assemblyMetadataCache">Cache of metadata already read from paths.</param>
+        /// <param name="executionContext">Execution context: current directory, culture, etc.</param>
         /// <param name="allowedAssemblyExtensions"></param>
         /// <param name="getRuntimeVersion"></param>
         /// <param name="targetedRuntimeVersion">Version of the runtime to target.</param>
@@ -222,6 +225,7 @@ internal sealed class ReferenceTable
         /// <param name="getAssemblyMetadata">Delegate used for finding dependencies of a file.</param>
         /// <param name="unresolveFrameworkAssembliesFromHigherFrameworks"></param>
         /// <param name="assemblyMetadataCache">Cache of metadata already read from paths.</param>
+        /// <param name="executionContext">Execution context: current directory, culture, etc.</param>
         /// <param name="allowedAssemblyExtensions"></param>
         /// <param name="getRuntimeVersion"></param>
         /// <param name="targetedRuntimeVersion">Version of the runtime to target.</param>
@@ -278,7 +282,8 @@ internal ReferenceTable
             WarnOrErrorOnTargetArchitectureMismatchBehavior warnOrErrorOnTargetArchitectureMismatch,
             bool ignoreFrameworkAttributeVersionMismatch,
             bool unresolveFrameworkAssembliesFromHigherFrameworks,
-            ConcurrentDictionary<string, AssemblyMetadata> assemblyMetadataCache)
+            ConcurrentDictionary<string, AssemblyMetadata> assemblyMetadataCache,
+            TaskExecutionContext executionContext)
         {
             _log = log;
             _findDependencies = findDependencies;
@@ -311,6 +316,7 @@ internal ReferenceTable
             _warnOrErrorOnTargetArchitectureMismatch = warnOrErrorOnTargetArchitectureMismatch;
             _ignoreFrameworkAttributeVersionMismatch = ignoreFrameworkAttributeVersionMismatch;
             _assemblyMetadataCache = assemblyMetadataCache;
+            _executionContext = executionContext;
 
             // Set condition for when to check assembly version against the target framework version 
             _checkAssemblyVersionAgainstTargetFrameworkVersion = unresolveFrameworkAssembliesFromHigherFrameworks || ((_projectTargetFramework ?? ReferenceTable.s_targetFrameworkVersion_40) <= ReferenceTable.s_targetFrameworkVersion_40);
@@ -351,7 +357,8 @@ internal ReferenceTable
                     getRuntimeVersion,
                     targetedRuntimeVersion,
                     getAssemblyPathInGac,
-                    log
+                    log,
+                    executionContext
                 );
         }
 
@@ -1266,8 +1273,7 @@ private void ResolveReference
         (
             AssemblyNameExtension assemblyName,
             string rawFileNameCandidate,
-            Reference reference
-        )
+            Reference reference)
         {
             // Now, resolve this reference.
             string resolvedPath = null;
@@ -1294,14 +1300,14 @@ Reference reference
             // If a reference has the SDKName metadata on it then we will only search using a single resolver, that is the InstalledSDKResolver.
             if (reference.SDKName.Length > 0)
             {
-                jaggedResolvers.Add(new Resolver[] { new InstalledSDKResolver(_resolvedSDKReferences, "SDKResolver", _getAssemblyName, _fileExists, _getRuntimeVersion, _targetedRuntimeVersion) });
+                jaggedResolvers.Add(new Resolver[] { new InstalledSDKResolver(_resolvedSDKReferences, "SDKResolver", _getAssemblyName, _fileExists, _getRuntimeVersion, _targetedRuntimeVersion, _executionContext) });
             }
             else
             {
                 // Do not probe near dependees if the reference is primary and resolved externally. If resolved externally, the search paths should have been specified in such a way to point to the assembly file.
                 if (assemblyName == null || !_externallyResolvedPrimaryReferences.Contains(assemblyName.Name))
                 {
-                    jaggedResolvers.Add(AssemblyResolution.CompileDirectories(parentReferenceFolders, _fileExists, _getAssemblyName, _getRuntimeVersion, _targetedRuntimeVersion));
+                    jaggedResolvers.Add(AssemblyResolution.CompileDirectories(parentReferenceFolders, _fileExists, _getAssemblyName, _getRuntimeVersion, _targetedRuntimeVersion, _executionContext));
                 }
 
                 jaggedResolvers.Add(Resolvers);
@@ -1339,7 +1345,7 @@ out userRequestedSpecificFile
             {
                 if (!Path.IsPathRooted(resolvedPath))
                 {
-                    resolvedPath = Path.GetFullPath(resolvedPath);
+                    resolvedPath = Path.GetFullPath(_executionContext.GetFullPath(resolvedPath));
                 }
 
                 reference.FullPath = resolvedPath;
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 02a168d2e21..6619cbc5310 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -112,6 +112,13 @@ public ResolveAssemblyReference()
         private WarnOrErrorOnTargetArchitectureMismatchBehavior _warnOrErrorOnTargetArchitectureMismatch = WarnOrErrorOnTargetArchitectureMismatchBehavior.Warning;
         private bool _unresolveFrameworkAssembliesFromHigherFrameworks = false;
 
+        /// <summary>
+        /// Storage for names of all files writen to disk.
+        /// </summary>
+        private List<ITaskItem> _filesWritten = new List<ITaskItem>();
+
+        private TaskExecutionContext _concurrencyExecutionContext;
+
         /// <summary>
         /// If set to true, it forces to unresolve framework assemblies with versions higher or equal the version of the target framework, regardless of the target framework
         /// </summary>
@@ -242,6 +249,8 @@ public string[] TargetFrameworkSubsets
         ///
         ///     System, Version=2.0.3500.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
         ///
+        /// or (full ? TODO - check) path to the assembly.
+        ///
         /// These names will be resolved into full paths and all dependencies will be found.
         ///
         /// Optional attributes are:
@@ -777,6 +786,16 @@ public string[] FullFrameworkFolders
             }
         }
 
+        /// <summary>
+        /// Execution context used when task is supposed to run concurrently in multiple threads.
+        /// If null hosting process do not run this task concurrently and set it execution context on process level.
+        /// </summary>
+        public TaskExecutionContext ConcurrencyExecutionContext
+        {
+            get { return _concurrencyExecutionContext; }
+            set { _concurrencyExecutionContext = value; }
+        }
+
         /// <summary>
         /// This is a list of all primary references resolved to full paths.
         ///     bool CopyLocal - whether the given reference should be copied to the output directory.
@@ -886,17 +905,6 @@ public ITaskItem[] SuggestedRedirects
             get { return _suggestedRedirects; }
         }
 
-        /// <summary>
-        /// Storage for names of all files writen to disk.
-        /// </summary>
-        private List<ITaskItem> _filesWritten = new List<ITaskItem>();
-
-        /// <summary>
-        /// Execution context used when task is supposed to run concurrently in multiple threads.
-        /// If null hosting process do not run this task concurrently and set it execution context on process level.
-        /// </summary>
-        private TaskExecutionContext _concurrencyExecutionContext;
-
         /// <summary>
         /// The names of all files written to disk.
         /// </summary>
@@ -1997,10 +2005,21 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
         )
         {
             bool success = true;
+
+            if (_concurrencyExecutionContext is object)
+            {
+                ApplyExecutionContextToInputs();
+            }
+            else
+            {
+                _concurrencyExecutionContext = new TaskExecutionContext();
+            }
+
             MSBuildEventSource.Log.RarOverallStart();
             {
                 try
                 {
+
                     FrameworkNameVersioning frameworkMoniker = null;
                     if (!String.IsNullOrEmpty(_targetedFrameworkMoniker))
                     {
@@ -2226,7 +2245,8 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                         _warnOrErrorOnTargetArchitectureMismatch,
                         _ignoreTargetFrameworkAttributeVersionMismatch,
                         _unresolveFrameworkAssembliesFromHigherFrameworks,
-                        assemblyMetadataCache
+                        assemblyMetadataCache,
+                        _concurrencyExecutionContext
                         );
 
                     dependencyTable.FindDependenciesOfExternallyResolvedReferences = FindDependenciesOfExternallyResolvedReferences;
@@ -2931,7 +2951,7 @@ private bool IsAvailableForTargetFramework(string assemblyFXVersionAsString)
         private void FilterBySubtypeAndTargetFramework()
         {
             var assembliesLeft = new List<ITaskItem>();
-            foreach (ITaskItem assembly in Assemblies)
+            foreach (ITaskItem assembly in _assemblyNames)
             {
                 string subType = assembly.GetMetadata(ItemMetadataNames.subType);
                 if (!string.IsNullOrEmpty(subType))
@@ -3060,5 +3080,64 @@ void IConcurrentTask.ConfigureForConcurrentExecution(TaskExecutionContext execut
         {
             _concurrencyExecutionContext = executionContext;
         }
+
+        void AddCurrentDirectoryToItemSpecProperty(ITaskItem[] array)
+        {
+            for (int i = 0; i < array.Length; i++)
+            {
+                array[i].ItemSpec = String.IsNullOrEmpty(array[i].ItemSpec) ? array[i].ItemSpec : Path.Combine(_concurrencyExecutionContext.StartupDirectory, array[i].ItemSpec);
+            }
+        }
+
+        
+        void ApplyExecutionContextToInputs()
+        {
+
+            for (int i = 0; i < _candidateAssemblyFiles.Length; i++)
+            {
+                _candidateAssemblyFiles[i] = _concurrencyExecutionContext.GetFullPath(_candidateAssemblyFiles[i]);
+            }
+
+            for (int i = 0; i < _targetFrameworkDirectories.Length; i++)
+            {
+                _targetFrameworkDirectories[i] = _concurrencyExecutionContext.GetFullPath(_targetFrameworkDirectories[i]);
+            }
+
+            for (int i = 0; i < _fullFrameworkFolders.Length; i++)
+            {
+                _fullFrameworkFolders[i] = _concurrencyExecutionContext.GetFullPath(_fullFrameworkFolders[i]);
+            }
+
+            for (int i = 0; i < _latestTargetFrameworkDirectories.Length; i++)
+            {
+                _latestTargetFrameworkDirectories[i] = _concurrencyExecutionContext.GetFullPath(_latestTargetFrameworkDirectories[i]);
+            }
+
+            _appConfigFile = _concurrencyExecutionContext.GetFullPath(_appConfigFile);
+            _stateFile = _concurrencyExecutionContext.GetFullPath(_stateFile);
+
+            for (int i = 0; i < _installedAssemblyTables.Length; i++)
+            {
+                // TODO: check if it could be URI.
+                // It is said that it's on disk in docu, but code does not prohibit URI.
+                _installedAssemblyTables[i].ItemSpec = _concurrencyExecutionContext.GetFullPath(_installedAssemblyTables[i].ItemSpec);
+            }
+
+            for (int i = 0; i < _installedAssemblySubsetTables.Length; i++)
+            {
+                _installedAssemblySubsetTables[i].ItemSpec = _concurrencyExecutionContext.GetFullPath(_installedAssemblySubsetTables[i].ItemSpec);
+            }
+
+            for (int i = 0; i < _fullFrameworkAssemblyTables.Length; i++)
+            {
+                _fullFrameworkAssemblyTables[i].ItemSpec = _concurrencyExecutionContext.GetFullPath(_fullFrameworkAssemblyTables[i].ItemSpec);
+            }
+
+            for (int i = 0; i < _resolvedSDKReferences.Length; i++)
+            {
+                _resolvedSDKReferences[i].ItemSpec = _concurrencyExecutionContext.GetFullPath(_resolvedSDKReferences[i].ItemSpec);
+            }
+        }
+
     }
 }
diff --git a/src/Tasks/AssemblyDependency/Resolver.cs b/src/Tasks/AssemblyDependency/Resolver.cs
index be72b128729..a504f1b6d58 100644
--- a/src/Tasks/AssemblyDependency/Resolver.cs
+++ b/src/Tasks/AssemblyDependency/Resolver.cs
@@ -6,6 +6,7 @@
 using System.Reflection;
 using System.Collections.Generic;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Tasks
 {
@@ -49,10 +50,24 @@ internal abstract class Resolver
         /// </summary>
         protected bool compareProcessorArchitecture;
 
+        /// <summary>
+        /// Execution context: current directory, culture, etc.
+        /// </summary>
+        protected TaskExecutionContext executionContext;
+
         /// <summary>
         /// Construct.
         /// </summary>
-        protected Resolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion, ProcessorArchitecture targetedProcessorArchitecture, bool compareProcessorArchitecture)
+        protected Resolver(
+            string searchPathElement,
+            GetAssemblyName getAssemblyName,
+            FileExists fileExists,
+            GetAssemblyRuntimeVersion getRuntimeVersion,
+            Version targetedRuntimeVesion,
+            ProcessorArchitecture targetedProcessorArchitecture,
+            bool compareProcessorArchitecture,
+            TaskExecutionContext executionContext
+        )
         {
             this.searchPathElement = searchPathElement;
             this.getAssemblyName = getAssemblyName;
@@ -61,6 +76,7 @@ protected Resolver(string searchPathElement, GetAssemblyName getAssemblyName, Fi
             this.targetedRuntimeVersion = targetedRuntimeVesion;
             this.targetProcessorArchitecture = targetedProcessorArchitecture;
             this.compareProcessorArchitecture = compareProcessorArchitecture;
+            this.executionContext = executionContext;
         }
 
         /// <summary>
@@ -98,6 +114,22 @@ out bool userRequestedSpecificFile
         /// </summary>
         public string SearchPath => searchPathElement;
 
+        /// <summary>
+        /// Full path for searchPathElement, in case it is a file path.
+        /// </summary>
+        private string _fullSearchPath;
+
+        /// <summary>
+        /// The full path (i.e. path after applying the execution context) in case searchPathElement is a file path.
+        /// </summary>
+        public string FullSearchPath
+        {
+            get
+            {
+                return _fullSearchPath ?? (_fullSearchPath = executionContext.GetFullPath(searchPathElement));
+            }
+        }
+
         /// <summary>
         /// Resolve a single file.
         /// </summary>
diff --git a/src/Tasks/InstalledSDKResolver.cs b/src/Tasks/InstalledSDKResolver.cs
index ac0ff362d0b..264ed3e7eeb 100644
--- a/src/Tasks/InstalledSDKResolver.cs
+++ b/src/Tasks/InstalledSDKResolver.cs
@@ -22,8 +22,16 @@ internal class InstalledSDKResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        public InstalledSDKResolver(Dictionary<string, ITaskItem> resolvedSDKs, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
+        public InstalledSDKResolver(
+            Dictionary<string, ITaskItem> resolvedSDKs,
+            string searchPathElement,
+            GetAssemblyName getAssemblyName,
+            FileExists fileExists,
+            GetAssemblyRuntimeVersion getRuntimeVersion,
+            Version targetedRuntimeVesion,
+            TaskExecutionContext executionContext
+        )
+            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false, executionContext)
         {
             _resolvedSDKs = resolvedSDKs;
         }
