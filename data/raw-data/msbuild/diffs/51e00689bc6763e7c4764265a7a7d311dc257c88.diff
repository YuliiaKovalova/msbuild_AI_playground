diff --git a/.opt-prof.yml b/.opt-prof.yml
index c53ec2cfac1..ee9d1649fee 100644
--- a/.opt-prof.yml
+++ b/.opt-prof.yml
@@ -57,7 +57,7 @@ stages:
     cloudBuildResourceName: ComponentBuildUnderTest
     testLabPoolName: VS-Platform # The test lab pool to run your tests in
     testMachineCleanUpStrategy: ${{parameters.testMachineCleanUpStrategy}}
-    testMachineImageName: Windows-10-Enterprise-20H2
+    testMachineImageName: Windows-11-Enterprise-23H2
     visualStudioSigning: Test
     variables:
     - name: branchName # The branch in the VS repo the bootstrapper was based on
diff --git a/MSBuild.Dev.slnf b/MSBuild.Dev.slnf
index 39e25ebb5a8..79c1a4edfdf 100644
--- a/MSBuild.Dev.slnf
+++ b/MSBuild.Dev.slnf
@@ -9,13 +9,13 @@
       "src\\Framework\\Microsoft.Build.Framework.csproj",
       "src\\MSBuild.UnitTests\\Microsoft.Build.CommandLine.UnitTests.csproj",
       "src\\MSBuild\\MSBuild.csproj",
+      "src\\StringTools\\StringTools.csproj",
       "src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj",
       "src\\Tasks\\Microsoft.Build.Tasks.csproj",
+      "src\\UnitTests.Shared\\Microsoft.Build.UnitTests.Shared.csproj",
       "src\\Utilities.UnitTests\\Microsoft.Build.Utilities.UnitTests.csproj",
       "src\\Utilities\\Microsoft.Build.Utilities.csproj",
-      "src\\Xunit.NetCore.Extensions\\Xunit.NetCore.Extensions.csproj",
-      "src\\StringTools\\StringTools.csproj",
-      "src\\UnitTests.Shared\\Microsoft.Build.UnitTests.Shared.csproj"
+      "src\\Xunit.NetCore.Extensions\\Xunit.NetCore.Extensions.csproj"
     ]
   }
 }
\ No newline at end of file
diff --git a/documentation/specs/proposed/BuildCheck-feature-threat-model.md b/documentation/specs/proposed/BuildCheck-feature-threat-model.md
new file mode 100644
index 00000000000..2a0f91d11f6
--- /dev/null
+++ b/documentation/specs/proposed/BuildCheck-feature-threat-model.md
@@ -0,0 +1,87 @@
+
+# Threat model of MSBuild BuildCheck feature
+
+## BuildCheck Feature Description
+
+The infrastructure within MSBuild allowing pluggability and execution of
+Analyzers and their Rules previously known as "warning waves" and
+"MSBuild Analyzers".
+
+The feature is meant to help customers to improve and understand quality of their MSBuild scripts via rules violations reporting. It will allow MSBuild to gradually roll out additional rules, as users will be capable to configure their opt-in and severity of reports – preventing unwanted build breakages. And to equip powerusers to roll out their own quality checks – whether for general community or internal enterprise usage.
+
+[Design
+Spec](https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck.md)
+
+[Architecture](https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md)
+
+# Threats Identification
+
+This feature does not alter existing nor create any new trust boundaries.
+
+It is assumed to rely on only trusted sources, be managed by trusted operators, and operated on trusted machines.
+
+For this document, we do not address any threats that result from violating these conditions.
+
+## Acquisition
+
+### Threat: Supply chain attack on custom analyzer
+
+Custom BuildCheck analyzers are executed during build. If bad external actors inject malicious code into it by supply chain attack or somehow else, such code can run on build machine, mostly build agent or develop box.
+
+#### Mitigation
+
+Custom analyzers are delivered as regular nuget packages by MSBuild `<PackageReference />` element. This way custom analyzer packages will be included in the generated SBOM and Component Government can detect and warn about known malicious custom analyzers.
+
+It is identical to Roslyn analyzers or any other nuget package, for that matter.
+
+## Execution
+
+### Threat: Supply chain attack by custom analyzer
+
+Custom BuildCheck analyzers are executed during build. If bad external actors inject malicious code into it by supply chain attack or somehow else, such code can run on build machine, mostly build agent or develop box, with intent to inject malicious behavior into build artifacts.
+
+#### Mitigation
+
+Identical to mitigation of threat [Supply chain attack on custom analyzer](#threat-supply-chain-attack-on-custom-analyzer).
+
+### Threat: Third-Party Vulnerabilities
+Vulnerabilities in custom analyzer or its dependencies.
+
+#### Mitigation
+
+Custom analyzers are delivered as regular NuGet packages by MSBuild `<PackageReference />` element. This way custom analyzer packages will be included in the generated SBOM and Component Government can detect and warn about known malicious custom analyzers.
+
+## Configuration
+
+### Threat: Malicious configuration value
+
+Although .editorconfig shall be part of trusted sources, and hence not malicious, .editorconfig is looked up in parent folders up to the root. This can allow attacked to store malicious editor config up in parent folders with intent of disabling an analyzer or cause build malfunction for any reason.
+
+#### Mitigation
+
+This problem is identical to existing .editorconfig for Roslyn analyzers and since we share code for parsing it, we adopt same mitigation strategy, which is:
+
+- default template for editor config has `root = true` stopping parent config traversing
+- code is unit tested to verify and sanitize .editorconfig values
+
+### Threat: Intentional analyzer ID conflict or misleading ID
+
+Malicious actors can define analyzer ID to be identical or like existing well known analyzer ID to increase probability of executing malicious analyzer code.
+
+#### Mitigation
+
+Main mitigation relays on nuget packages component governance.
+
+BuildCheck also disallow duplicated analyzer IDs and do not allow well known prefixes, for example `microsoft-\*`, in custom analyzers.
+
+## Declaration
+
+### Threat: Malicious analyzer registration property function
+
+Threat actor can write malicious analyzer registration property function in project files, with intent to run code from non-governed assemblies.
+
+#### Mitigation
+
+This threat is out of scope of this document, as this requires malicious modification of source code (repository) making these sources untrusted.
+
+It is mentioned here, as a note that we have thought about it.
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index bab7c907f04..64d06a9ccf1 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -2,9 +2,9 @@
 <Dependencies>
   <ProductDependencies>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="8.0.0-alpha.1.24163.3">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="8.0.0-alpha.1.24251.1">
       <Uri>https://github.com/dotnet/source-build-reference-packages</Uri>
-      <Sha>79827eed138fd2575a8b24820b4f385ee4ffb6e6</Sha>
+      <Sha>6f814daa935e08b578b1c0c65a1f26ea3317f517</Sha>
       <SourceBuild RepoName="source-build-reference-packages" ManagedOnly="true" />
     </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
@@ -67,14 +67,14 @@
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.24204.3">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.24225.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>188340e12c0a372b1681ad6a5e72c608021efdba</Sha>
+      <Sha>67d23f4ba1813b315e7e33c71d18b63475f5c5f8</Sha>
     </Dependency>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="8.0.0-beta.24204.3">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="8.0.0-beta.24225.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>188340e12c0a372b1681ad6a5e72c608021efdba</Sha>
+      <Sha>67d23f4ba1813b315e7e33c71d18b63475f5c5f8</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.23475.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
@@ -91,14 +91,14 @@
       <Uri>https://github.com/nuget/nuget.client</Uri>
       <Sha>fb50d1a45ed10b39b5f335bc3a4bdcaea9b951cf</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.10.0-3.24216.12">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.10.0-3.24225.4">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>3af0081a6e811b78d37c62e479914f7f4cfb0d1a</Sha>
+      <Sha>0156fea1a01c1fd88ef625b45fda9d4239c99fb3</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.24204.3">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.24225.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>188340e12c0a372b1681ad6a5e72c608021efdba</Sha>
+      <Sha>67d23f4ba1813b315e7e33c71d18b63475f5c5f8</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 939fba9aa49..b06c9cc3bc0 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -48,10 +48,10 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.24204.3</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.24225.1</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.10.0-3.24216.12</MicrosoftNetCompilersToolsetVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.10.0-3.24225.4</MicrosoftNetCompilersToolsetVersion>
     <NuGetBuildTasksVersion>6.10.0-preview.2.97</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
   </PropertyGroup>
diff --git a/global.json b/global.json
index 7c11ef6ece2..f5c0c2e630c 100644
--- a/global.json
+++ b/global.json
@@ -10,6 +10,6 @@
     "xcopy-msbuild": "17.8.5"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.24204.3"
+    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.24225.1"
   }
 }
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 31dea1590f8..90f06cf86c7 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -4383,13 +4383,13 @@ public void PropertyFunctionCheckFeatureAvailability(string featureName, string
         }
 
         [Theory]
-        [InlineData("\u3407\ud840\udc60\ud86a\ude30\ud86e\udc0a\ud86e\udda0\ud879\udeae\u2fd5\u0023", 0, 3, "\u3407\ud840\udc60\ud86a\ude30")]
-        [InlineData("\u3407\ud840\udc60\ud86a\ude30\ud86e\udc0a\ud86e\udda0\ud879\udeae\u2fd5\u0023", 2, 5, "\ud86a\ude30\ud86e\udc0a\ud86e\udda0\ud879\udeae\u2fd5")]
-        public void SubstringByTextElements(string featureName, int start, int length, string expected)
+        [InlineData("\u0074\u0068\u0069\u0073\u002a\u3407\ud840\udc60\ud86a\ude30\ud86e\udc0a\ud86e\udda0\ud879\udeae\u2fd5\u0023", 2, 10, "is________")]
+        [InlineData("\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc66\u200d\ud83d\udc66\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc66\u200d\ud83d\udc66\u002e\u0070\u0072\u006f\u006a", 0, 8, "________")]
+        public void SubstringByAsciiChars(string featureName, int start, int length, string expected)
         {
             var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), FileSystems.Default);
 
-            var result = expander.ExpandIntoStringLeaveEscaped($"$([MSBuild]::SubstringByTextElements({featureName}, {start}, {length}))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
+            var result = expander.ExpandIntoStringLeaveEscaped($"$([MSBuild]::SubstringByAsciiChars({featureName}, {start}, {length}))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
 
             Assert.Equal(expected, result);
         }
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index ec86b218112..9c59416ea49 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -2989,10 +2989,22 @@ private ILoggingService CreateLoggingService(
                     ((IBuildComponentHost)this).GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider;
                 buildCheckManagerProvider!.Instance.SetDataSource(BuildCheckDataSource.EventArgs);
 
-                loggers = (loggers ?? Enumerable.Empty<ILogger>()).Concat(new[]
-                {
-                    new BuildCheckConnectorLogger(new AnalyzerLoggingContextFactory(loggingService), buildCheckManagerProvider.Instance)
-                });
+                // We do want to dictate our own forwarding logger (otherwise CentralForwardingLogger with minimum transferred importance MessageImportnace.Low is used)
+                // In the future we might optimize for single, in-node build scenario - where forwarding logger is not needed (but it's just quick pass-through)
+                LoggerDescription forwardingLoggerDescription = new LoggerDescription(
+                    loggerClassName: typeof(BuildCheckForwardingLogger).FullName,
+                    loggerAssemblyName: typeof(BuildCheckForwardingLogger).GetTypeInfo().Assembly.GetName().FullName,
+                    loggerAssemblyFile: null,
+                    loggerSwitchParameters: null,
+                    verbosity: LoggerVerbosity.Quiet);
+
+                ILogger buildCheckLogger =
+                    new BuildCheckConnectorLogger(new AnalyzerLoggingContextFactory(loggingService),
+                        buildCheckManagerProvider.Instance);
+
+                ForwardingLoggerRecord[] forwardingLogger = { new ForwardingLoggerRecord(buildCheckLogger, forwardingLoggerDescription) };
+
+                forwardingLoggers = forwardingLoggers?.Concat(forwardingLogger) ?? forwardingLogger;
             }
 
             try
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 885647baba0..c4fb2a1b766 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -9,6 +9,7 @@
 using System.Reflection;
 using System.Threading;
 using Microsoft.Build.BackEnd.Components.RequestBuilder;
+using Microsoft.Build.BuildCheck.Infrastructure;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -1758,6 +1759,10 @@ private void UpdateMinimumMessageImportance(ILogger logger)
                 Build.Logging.ConsoleLogger consoleLogger => consoleLogger.GetMinimumMessageImportance(),
                 Build.Logging.ConfigurableForwardingLogger forwardingLogger => forwardingLogger.GetMinimumMessageImportance(),
 
+                // The BuildCheck connector logger consumes only high priority messages.
+                BuildCheckForwardingLogger => MessageImportance.High,
+                BuildCheck.Infrastructure.BuildCheckConnectorLogger => MessageImportance.High,
+
                 // Central forwarding loggers are used in worker nodes if logging verbosity could not be optimized, i.e. in cases
                 // where we must log everything. They can be ignored in inproc nodes.
                 CentralForwardingLogger => (_nodeId > 1 ? MessageImportance.Low : null),
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
index 361c30c4200..14f16e691f0 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
@@ -6,6 +6,7 @@
 using System.Linq;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BuildCheck.Acquisition;
+using Microsoft.Build.BuildCheck.Utilities;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 using static Microsoft.Build.BuildCheck.Infrastructure.BuildCheckManagerProvider;
@@ -80,9 +81,6 @@ private void EventSource_AnyEventRaised(object sender, BuildEventArgs e)
 
     private void EventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
     {
-        _stats.Merge(_buildCheckManager.CreateTracingStats(), (span1, span2) => span1 + span2);
-        string msg = string.Join(Environment.NewLine, _stats.Select(a => a.Key + ": " + a.Value));
-
         BuildEventContext buildEventContext = e.BuildEventContext
             ?? new BuildEventContext(
                 BuildEventContext.InvalidNodeId,
@@ -92,8 +90,43 @@ private void EventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
 
         LoggingContext loggingContext = _loggingContextFactory.CreateLoggingContext(buildEventContext);
 
-        // Tracing: https://github.com/dotnet/msbuild/issues/9629
-        loggingContext.LogCommentFromText(MessageImportance.High, msg);
+        _stats.Merge(_buildCheckManager.CreateAnalyzerTracingStats(), (span1, span2) => span1 + span2);
+        LogAnalyzerStats(loggingContext);
+    }
+    
+    private void LogAnalyzerStats(LoggingContext loggingContext)
+    {
+        Dictionary<string, TimeSpan> infraStats = new Dictionary<string, TimeSpan>();
+        Dictionary<string, TimeSpan> analyzerStats = new Dictionary<string, TimeSpan>();
+
+        foreach (var stat in _stats)
+        {
+            if (stat.Key.StartsWith(BuildCheckConstants.infraStatPrefix))
+            {
+                string newKey = stat.Key.Substring(BuildCheckConstants.infraStatPrefix.Length);
+                infraStats[newKey] = stat.Value;
+            }
+            else
+            {
+                analyzerStats[stat.Key] = stat.Value;
+            }
+        }
+
+        BuildCheckTracingEventArgs statEvent = new BuildCheckTracingEventArgs(_stats, true)
+        { BuildEventContext = loggingContext.BuildEventContext };
+
+        loggingContext.LogBuildEvent(statEvent);
+
+        loggingContext.LogCommentFromText(MessageImportance.Low, $"BuildCheck run times{Environment.NewLine}");
+        string infraData = BuildCsvString("Infrastructure run times", infraStats);
+        loggingContext.LogCommentFromText(MessageImportance.Low, infraData);
+        string analyzerData = BuildCsvString("Analyzer run times", analyzerStats);
+        loggingContext.LogCommentFromText(MessageImportance.Low, analyzerData);
+    }
+
+    private string BuildCsvString(string title, Dictionary<string, TimeSpan> rowData)
+    {
+        return title + Environment.NewLine + String.Join(Environment.NewLine, rowData.Select(a => $"{a.Key},{a.Value}")) + Environment.NewLine;
     }
 
     private Dictionary<Type, Action<BuildEventArgs>> GetBuildEventHandlers() => new()
@@ -102,7 +135,14 @@ private void EventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
         { typeof(ProjectEvaluationStartedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationStartedEvent((ProjectEvaluationStartedEventArgs) e) },
         { typeof(ProjectStartedEventArgs), (BuildEventArgs e) => _buildCheckManager.StartProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!) },
         { typeof(ProjectFinishedEventArgs), (BuildEventArgs e) => _buildCheckManager.EndProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!) },
-        { typeof(BuildCheckTracingEventArgs), (BuildEventArgs e) => _stats.Merge(((BuildCheckTracingEventArgs)e).TracingData, (span1, span2) => span1 + span2) },
+        { typeof(BuildCheckTracingEventArgs), (BuildEventArgs e) => 
+        {
+            if(!((BuildCheckTracingEventArgs)e).IsAggregatedGlobalReport)
+            {
+                _stats.Merge(((BuildCheckTracingEventArgs)e).TracingData, (span1, span2) => span1 + span2);
+            }
+        }
+        },
         { typeof(BuildCheckAcquisitionEventArgs), (BuildEventArgs e) => _buildCheckManager.ProcessAnalyzerAcquisition(((BuildCheckAcquisitionEventArgs)e).ToAnalyzerAcquisitionData(), e.BuildEventContext!) },
     };
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
new file mode 100644
index 00000000000..3a61bcaf612
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
@@ -0,0 +1,19 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+/// <summary>
+/// Forwarding logger for the build check infrastructure.
+/// For now we jus want to forward all events, while disable verbose logging of tasks.
+/// In the future we may need more specific behavior.
+/// </summary>
+internal class BuildCheckForwardingLogger : CentralForwardingLogger
+{ }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index 33985a81707..3fadcac86b1 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.Linq;
 using System.Threading;
 using Microsoft.Build.BackEnd;
@@ -88,15 +89,19 @@ internal BuildCheckManager(ILoggingService loggingService)
         /// <param name="buildCheckDataSource"></param>
         public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
         {
+            Stopwatch stopwatch = Stopwatch.StartNew();
             if (!_enabledDataSources[(int)buildCheckDataSource])
             {
                 _enabledDataSources[(int)buildCheckDataSource] = true;
                 RegisterBuiltInAnalyzers(buildCheckDataSource);
             }
+            stopwatch.Stop();
+            _tracingReporter.AddSetDataSourceStats(stopwatch.Elapsed);
         }
 
         public void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData, BuildEventContext buildEventContext)
         {
+            Stopwatch stopwatch = Stopwatch.StartNew();
             if (IsInProcNode)
             {
                 var analyzersFactories = _acquisitionModule.CreateBuildAnalyzerFactories(acquisitionData, buildEventContext);
@@ -116,6 +121,8 @@ public void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData,
 
                 _loggingService.LogBuildEvent(eventArgs);
             }
+            stopwatch.Stop();
+            _tracingReporter.AddAcquisitionStats(stopwatch.Elapsed);
         }
 
         private static T Construct<T>() where T : new() => new();
@@ -266,7 +273,7 @@ private void SetupAnalyzersForNewProject(string projectFullPath, BuildEventConte
             // On an execution node - we might remove and dispose the analyzers once project is done
 
             // If it's already constructed - just control the custom settings do not differ
-
+            Stopwatch stopwatch = Stopwatch.StartNew();
             List<BuildAnalyzerFactoryContext> analyzersToRemove = new();
             foreach (BuildAnalyzerFactoryContext analyzerFactoryContext in _analyzersRegistry)
             {
@@ -291,9 +298,12 @@ private void SetupAnalyzersForNewProject(string projectFullPath, BuildEventConte
             foreach (var analyzerToRemove in analyzersToRemove.Select(a => a.MaterializedAnalyzer).Where(a => a != null))
             {
                 _buildCheckCentralContext.DeregisterAnalyzer(analyzerToRemove!);
-                _tracingReporter.AddStats(analyzerToRemove!.BuildAnalyzer.FriendlyName, analyzerToRemove.Elapsed);
+                _tracingReporter.AddAnalyzerStats(analyzerToRemove!.BuildAnalyzer.FriendlyName, analyzerToRemove.Elapsed);
                 analyzerToRemove.BuildAnalyzer.Dispose();
             }
+
+            stopwatch.Stop();
+            _tracingReporter.AddNewProjectStats(stopwatch.Elapsed);
         }
 
         public void ProcessEvaluationFinishedEventArgs(
@@ -302,19 +312,19 @@ public void ProcessEvaluationFinishedEventArgs(
             => _buildEventsProcessor
                 .ProcessEvaluationFinishedEventArgs(buildAnalysisContext, evaluationFinishedEventArgs);
 
-        // Tracing: https://github.com/dotnet/msbuild/issues/9629
-        public Dictionary<string, TimeSpan> CreateTracingStats()
+        public Dictionary<string, TimeSpan> CreateAnalyzerTracingStats()
         {
             foreach (BuildAnalyzerFactoryContext analyzerFactoryContext in _analyzersRegistry)
             {
                 if (analyzerFactoryContext.MaterializedAnalyzer != null)
                 {
-                    _tracingReporter.AddStats(analyzerFactoryContext.FriendlyName,
+                    _tracingReporter.AddAnalyzerStats(analyzerFactoryContext.FriendlyName,
                         analyzerFactoryContext.MaterializedAnalyzer.Elapsed);
                     analyzerFactoryContext.MaterializedAnalyzer.ClearStats();
                 }
             }
 
+            _tracingReporter.AddAnalyzerInfraStats();
             return _tracingReporter.TracingStats;
         }
 
@@ -326,9 +336,11 @@ public void FinalizeProcessing(LoggingContext loggingContext)
                 return;
             }
 
-            BuildCheckTracingEventArgs eventArgs =
-                new(CreateTracingStats()) { BuildEventContext = loggingContext.BuildEventContext };
-            loggingContext.LogBuildEvent(eventArgs);
+            var analyzerEventStats = CreateAnalyzerTracingStats();
+
+            BuildCheckTracingEventArgs analyzerEventArg =
+                new(analyzerEventStats) { BuildEventContext = loggingContext.BuildEventContext };
+            loggingContext.LogBuildEvent(analyzerEventArg);
         }
 
         public void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext,
diff --git a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
index 331502e95e0..ca8803b99af 100644
--- a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
@@ -44,7 +44,7 @@ void ProcessEvaluationFinishedEventArgs(
 
     void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData, BuildEventContext buildEventContext);
 
-    Dictionary<string, TimeSpan> CreateTracingStats();
+    Dictionary<string, TimeSpan> CreateAnalyzerTracingStats();
 
     void FinalizeProcessing(LoggingContext loggingContext);
 
diff --git a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
index 45ed260d425..4ba7579c0ba 100644
--- a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
@@ -31,8 +31,6 @@ public void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData,
     {
     }
 
-    public Dictionary<string, TimeSpan> CreateTracingStats() => throw new NotImplementedException();
-
     public void FinalizeProcessing(LoggingContext loggingContext)
     {
     }
@@ -60,4 +58,6 @@ public void YieldProject(BuildCheckDataSource buildCheckDataSource, BuildEventCo
     public void ResumeProject(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
     {
     }
+
+    public Dictionary<string, TimeSpan> CreateAnalyzerTracingStats() => new Dictionary<string, TimeSpan>();
 }
diff --git a/src/Build/BuildCheck/Infrastructure/TracingReporter.cs b/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
index 2d6d850737b..eb41e3d1214 100644
--- a/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
+++ b/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
@@ -6,6 +6,8 @@
 using System.Linq;
 using System.Text;
 using System.Threading.Tasks;
+using Microsoft.Build.BuildCheck.Utilities;
+using Microsoft.Build.Experimental.BuildCheck;
 
 namespace Microsoft.Build.BuildCheck.Infrastructure;
 
@@ -13,7 +15,13 @@ internal class TracingReporter
 {
     internal Dictionary<string, TimeSpan> TracingStats { get; } = new();
 
-    public void AddStats(string name, TimeSpan subtotal)
+    // Infrastructure time keepers
+    // TODO: add more timers throughout BuildCheck run
+    private TimeSpan analyzerAcquisitionTime;
+    private TimeSpan analyzerSetDataSourceTime;
+    private TimeSpan newProjectAnalyzersTime;
+
+    public void AddAnalyzerStats(string name, TimeSpan subtotal)
     {
         if (TracingStats.TryGetValue(name, out TimeSpan existing))
         {
@@ -24,4 +32,30 @@ public void AddStats(string name, TimeSpan subtotal)
             TracingStats[name] = subtotal;
         }
     }
+
+    public void AddAcquisitionStats(TimeSpan subtotal)
+    {
+        analyzerAcquisitionTime += subtotal;
+    }
+
+    public void AddSetDataSourceStats(TimeSpan subtotal)
+    {
+        analyzerSetDataSourceTime += subtotal;
+    }
+
+    public void AddNewProjectStats(TimeSpan subtotal)
+    {
+        newProjectAnalyzersTime += subtotal;
+    }
+
+    public void AddAnalyzerInfraStats()
+    {
+        var infraStats = new Dictionary<string, TimeSpan>() {
+                { $"{BuildCheckConstants.infraStatPrefix}analyzerAcquisitionTime", analyzerAcquisitionTime },
+                { $"{BuildCheckConstants.infraStatPrefix}analyzerSetDataSourceTime", analyzerSetDataSourceTime },
+                { $"{BuildCheckConstants.infraStatPrefix}newProjectAnalyzersTime", newProjectAnalyzersTime }
+            };
+
+        TracingStats.Merge(infraStats, (span1, span2) => span1 + span2);
+    }
 }
diff --git a/src/Build/BuildCheck/Utilities/Constants.cs b/src/Build/BuildCheck/Utilities/Constants.cs
new file mode 100644
index 00000000000..9ba6b58a1e6
--- /dev/null
+++ b/src/Build/BuildCheck/Utilities/Constants.cs
@@ -0,0 +1,19 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.BuildCheck.Utilities
+{
+    /// <summary>
+    /// Constants to be shared within BuildCheck infrastructure
+    /// </summary>
+    internal static class BuildCheckConstants
+    {
+        internal const string infraStatPrefix = "infrastructureStat_";
+    }
+}
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index ffbdbb5e855..84d485b7c59 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -4229,11 +4229,11 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                                 return true;
                             }
                         }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.SubstringByTextElements), StringComparison.OrdinalIgnoreCase))
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.SubstringByAsciiChars), StringComparison.OrdinalIgnoreCase))
                         {
                             if (TryGetArgs(args, out string arg0, out int arg1, out int arg2))
                             {
-                                returnVal = IntrinsicFunctions.SubstringByTextElements(arg0, arg1, arg2);
+                                returnVal = IntrinsicFunctions.SubstringByAsciiChars(arg0, arg1, arg2);
                                 return true;
                             }
                         }
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 611b8af238d..944478d4be6 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -9,7 +9,6 @@
 using System.Runtime.Versioning;
 using System.Text;
 using System.Text.RegularExpressions;
-using System.Globalization;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
@@ -19,6 +18,7 @@
 using Microsoft.Build.Utilities;
 using Microsoft.NET.StringTools;
 using Microsoft.Win32;
+using System.Linq;
 
 // Needed for DoesTaskHostExistForParameters
 using NodeProviderOutOfProcTaskHost = Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost;
@@ -629,10 +629,30 @@ internal static bool AreFeaturesEnabled(Version wave)
             return ChangeWaves.AreFeaturesEnabled(wave);
         }
 
-        internal static string SubstringByTextElements(string input, int start, int length)
+        internal static string SubstringByAsciiChars(string input, int start, int length)
         {
-            StringInfo stringInfo = new StringInfo(input);
-            return stringInfo.SubstringByTextElements(start, length);
+            if (start > input.Length)
+            {
+                return string.Empty;
+            }
+            if (start + length > input.Length)
+            {
+                length = input.Length - start;
+            }
+            StringBuilder sb = new StringBuilder();
+            for (int i = start; i < start + length; i++)
+            {
+                char c = input[i];
+                if (c >= 32 && c <= 126 && !FileUtilities.InvalidFileNameChars.Contains(c))
+                {
+                    sb.Append(c);
+                }
+                else
+                {
+                    sb.Append('_');
+                }
+            }
+            return sb.ToString();
         }
 
         internal static string CheckFeatureAvailability(string featureName)
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index d2801b103f0..f9528b3b6d8 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -33,7 +33,6 @@
 
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
-    <PackageReference Include="System.Security.Principal.Windows" />
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
 
     <PackageReference Include="System.Reflection.MetadataLoadContext" />
@@ -49,6 +48,7 @@
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <Reference Include="System.IO.Compression" />
     <PackageReference Include="System.Memory" />
+    <PackageReference Include="System.Security.Principal.Windows" />
     <PackageReference Include="System.Text.Json" />
   </ItemGroup>
 
@@ -161,6 +161,7 @@
     <Compile Include="BuildCheck\Acquisition\IBuildCheckAcquisitionModule.cs" />
     <Compile Include="BuildCheck\Analyzers\SharedOutputPathAnalyzer.cs" />
     <Compile Include="BuildCheck\Infrastructure\BuildCheckConfigurationException.cs" />
+    <Compile Include="BuildCheck\Infrastructure\BuildCheckForwardingLogger.cs" />
     <Compile Include="BuildCheck\Infrastructure\BuildEventsProcessor.cs" />
     <Compile Include="BuildCheck\Infrastructure\IBuildCheckManagerProvider.cs" />
     <Compile Include="BuildCheck\Infrastructure\NullBuildCheckManager.cs" />
@@ -187,6 +188,7 @@
     <Compile Include="BuildCheck\Logging\IBuildAnalysisLoggingContextFactory.cs" />
     <Compile Include="BuildCheck\OM\EvaluatedPropertiesAnalysisData.cs" />
     <Compile Include="BuildCheck\OM\ParsedItemsAnalysisData.cs" />
+    <Compile Include="BuildCheck\Utilities\Constants.cs" />
     <Compile Include="BuildCheck\Utilities\EnumerableExtensions.cs" />
     <Compile Include="Evaluation\IItemTypeDefinition.cs" />
     <Compile Include="FileAccess\DesiredAccess.cs" />
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 805b9010ea3..cce18578077 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -209,22 +209,22 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">Nepodařilo se najít zadané sestavení vlastního analyzátoru: {0}. Zkontrolujte prosím, jestli existuje.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">Nepodařilo se zaregistrovat vlastní analyzátor: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">Nepovedlo se vytvořit instanci pravidla vlastního analyzátoru s následující výjimkou: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">Pravidlo vlastního analyzátoru: {0} se úspěšně zaregistrovalo.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -618,7 +618,7 @@ Chyby: {3}</target>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">Sestavení úlohy bylo načteno z{0}, ale požadované umístění bylo{1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index ee28388b3e7..d1aa6cbc8ec 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -209,22 +209,22 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">Fehler beim Suchen der angegebenen benutzerdefinierten Analysetoolassembly: {0}. Überprüfen Sie, ob sie vorhanden ist.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">Fehler beim Registrieren des benutzerdefinierten Analysetools: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">Fehler beim Instanziieren der benutzerdefinierten Analysetoolregel mit der folgenden Ausnahme: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">Benutzerdefinierte Analysetoolregel {0} wurde erfolgreich registriert.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -618,7 +618,7 @@ Fehler: {3}</target>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">Die Aufgabenassembly wurde aus „{0}“ geladen, während der gewünschte Speicherort „{1}“ war.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 257fde173bd..90914c626ff 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -209,22 +209,22 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">No se ha podido encontrar el ensamblado del analizador personalizado especificado: {0}. Compruebe si existe.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">No se ha podido registrar el analizador personalizado: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">No se ha podido crear una instancia de la regla del analizador personalizado con la siguiente excepción: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">Regla del analizador personalizado: {0} se ha registrado correctamente.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -618,7 +618,7 @@ Errores: {3}</target>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">El ensamblado de tarea se cargó desde "{0}" mientras que la ubicación deseada era "{1}".</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index c5d61abb801..09bad2f7e80 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -209,22 +209,22 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">Impossible de trouver l’assemblée d'analyseur personnalisé spécifié : {0}. Vérifiez s’il existe.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">Échec de l’inscription de l’analyseur personnalisé : {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">Échec de l’instanciation de la règle d’analyseur personnalisé avec l’exception suivante : {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">Règle de l’analyseur personnalisé : {0} a été correctement inscrit.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -618,7 +618,7 @@ Erreurs : {3}</target>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">L’assembly de tâche a été chargé à partir de « {0} » alors que l’emplacement souhaité était « {1} ».</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 82875aa922e..8bf8eec2d8d 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -209,22 +209,22 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">Impossibile trovare l'assembly dell'analizzatore personalizzato specificato: {0}. Verificare se esiste.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">Impossibile registrare l'analizzatore personalizzato: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">Impossibile creare un'istanza della regola dell'analizzatore personalizzato con l'eccezione seguente: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">Regola dell'analizzatore personalizzato: {0} è stata registrata.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -618,7 +618,7 @@ Errori: {3}</target>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">L'assembly attività è stato caricato da "{0}" mentre era "{1}" il percorso desiderato.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 745ed6f66cb..fbdc02d0590 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -209,22 +209,22 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">指定されたカスタム アナライザー アセンブリが見つかりませんでした: {0}。存在するかどうか確認してください。</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">カスタム アナライザーを登録できませんでした: {0}</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">次の例外により、カスタム アナライザー ルールのインスタンスを作成できませんでした: {0}。</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">カスタム アナライザー ルール: {0} が正常に登録されました。</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -618,7 +618,7 @@ Errors: {3}</source>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">タスク アセンブリは '{0}' から読み込まれましたが、必要な場所は '{1}' でした。</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index c965e326ed9..dc7c94b9d2f 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -209,22 +209,22 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">지정한 사용자 지정 분석기 어셈블리를 찾지 못했습니다. {0}. 존재하는지 확인하세요.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">사용자 지정 분석기를 등록하지 못했습니다. {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">다음 예외로 인해 사용자 지정 분석기 규칙을 인스턴스화하지 못했습니다. {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">사용자 지정 분석기 규칙: {0}이(가) 등록되었습니다.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -618,7 +618,7 @@ Errors: {3}</source>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">원하는 위치가 '{1}'인 동안 '{0}'에서 작업 어셈블리를 로드했습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 34dbe8205e9..d8d09cb9c63 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -209,22 +209,22 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">Nie można odnaleźć określonego zestawu analizatora niestandardowego: {0}. Sprawdź, czy istnieje.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">Nie można zarejestrować analizatora niestandardowego: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">Nie można utworzyć wystąpienia niestandardowej reguły analizatora z następującym wyjątkiem: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">Niestandardowa reguła analizatora: {0} została pomyślnie zarejestrowana.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -618,7 +618,7 @@ Błędy: {3}</target>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">Zestaw zadania został załadowany z lokalizacji „{0}”, gdy żądana lokalizacja to „{1}”.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 888dcdb0508..389700299cc 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -209,22 +209,22 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">Falha ao localizar o assembly do analisador personalizado especificado: {0}. Verifique se existe.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">Falha ao registrar o analisador personalizado: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">Falha ao criar uma instância da regra do analisador personalizado com a seguinte exceção: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">Regra do analisador personalizado: {0} foi registrado com sucesso.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -618,7 +618,7 @@ Erros: {3}</target>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">O assembly da tarefa foi carregado de "{0}" enquanto o local desejado era "{1}".</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 57544712fe8..5c04d7194eb 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -209,22 +209,22 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">Не удалось найти указанную сборку настраиваемого анализатора: {0}. Убедитесь, что она существует.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">Не удалось зарегистрировать настраиваемый анализатор: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">Не удалось создать экземпляр правила настраиваемого анализатора со следующим исключением: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">Зарегистрировано правило настраиваемого анализатора: {0}.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -618,7 +618,7 @@ Errors: {3}</source>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">Сборка задачи была загружена из "{0}", а нужное расположение — "{1}".</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 0e42c1af423..a9dc8a0e065 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -209,22 +209,22 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">Belirtilen {0} özel çözümleyici derlemesi bulunamadı. Lütfen var olup olmadığını kontrol edin.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">Özel çözümleyici kaydedilemedi: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">Özel çözümleyici kuralı şu özel durumla başlatılamadı: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">{0} özel çözümleyici kuralı başarıyla kaydedildi.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -618,7 +618,7 @@ Hatalar: {3}</target>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">İstenilen konum '{1}' iken görev derlemesi '{0}'dan yüklendi.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index d23e8334597..868e495f52b 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -209,22 +209,22 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">找不到指定的自定义分析器程序集: {0}。请检查它是否存在。</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">无法注册自定义分析器: {0}。</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">无法实例化自定义分析器规则，出现以下异常: {0}。</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">自定义分析器规则: {0} 已成功注册。</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -618,7 +618,7 @@ Errors: {3}</source>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">已从“{0}”加载任务程序集，但所需位置为“{1}”。</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index f6f3cff5721..b31a9ad4517 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -209,22 +209,22 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">找不到指定的自訂分析器組件: {0}。請檢查它是否存在。</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">無法登錄自訂分析器: {0}。</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">無法具現化自訂分析器規則，發生下列例外狀況: {0}。</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">自訂分析器規則: 已成功登錄 {0}。</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -618,7 +618,7 @@ Errors: {3}</source>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">工作組件已從 '{0}' 載入，但 '{1}' 才是所需的位置。</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Framework/BuildCheck/BuildCheckEventArgs.cs b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
index b7edcb5161a..7789ba37d18 100644
--- a/src/Framework/BuildCheck/BuildCheckEventArgs.cs
+++ b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
@@ -30,6 +30,17 @@ internal BuildCheckTracingEventArgs()
     {
     }
 
+    internal BuildCheckTracingEventArgs(Dictionary<string, TimeSpan> data, bool isAggregatedGlobalReport) : this(data)
+    {
+        IsAggregatedGlobalReport = isAggregatedGlobalReport;
+    }
+
+    /// <summary>
+    /// When true, the tracing information is from the whole build for logging purposes
+    /// When false, the tracing is being used for communication between nodes and central process
+    /// </summary>
+    public bool IsAggregatedGlobalReport { get; private set; } = false;
+
     public Dictionary<string, TimeSpan> TracingData { get; private set; } = tracingData;
 
     internal override void WriteToStream(BinaryWriter writer)
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 73b4b3e282b..c33b4e8da98 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -2626,16 +2626,24 @@ public void EndToEndVersionMessage(string arguments, bool shouldContainVersionMe
         [InlineData("/v:normal", MessageImportance.Normal)]
         [InlineData("/v:minimal", MessageImportance.High)]
         [InlineData("/v:quiet", MessageImportance.High - 1)]
+
         [InlineData("/v:diagnostic /bl", MessageImportance.Low)]
         [InlineData("/v:detailed /bl", MessageImportance.Low)]
         [InlineData("/v:normal /bl", MessageImportance.Low)] // v:normal but with binary logger so everything must be logged
         [InlineData("/v:minimal /bl", MessageImportance.Low)] // v:minimal but with binary logger so everything must be logged
         [InlineData("/v:quiet /bl", MessageImportance.Low)] // v:quiet but with binary logger so everything must be logged
+
         [InlineData("/v:diagnostic /analyze", MessageImportance.Low)]
         [InlineData("/v:detailed /analyze", MessageImportance.Low)]
-        [InlineData("/v:normal /analyze", MessageImportance.Low)] // v:normal but with analyzers so everything must be logged
-        [InlineData("/v:minimal /analyze", MessageImportance.Low)] // v:minimal but with analyzers so everything must be logged
-        [InlineData("/v:quiet /analyze", MessageImportance.Low)] // v:quiet but with analyzers so everything must be logged
+        [InlineData("/v:normal /analyze", MessageImportance.Normal)]
+        [InlineData("/v:minimal /analyze", MessageImportance.High)]
+        [InlineData("/v:quiet /analyze", MessageImportance.High)]
+
+        [InlineData("/v:diagnostic /tl", MessageImportance.Low)]
+        [InlineData("/v:detailed /tl", MessageImportance.Low)]
+        [InlineData("/v:normal /tl", MessageImportance.Normal)]
+        [InlineData("/v:minimal /tl", MessageImportance.High)]
+        [InlineData("/v:quiet /tl", MessageImportance.High - 1)]
         public void EndToEndMinimumMessageImportance(string arguments, MessageImportance expectedMinimumMessageImportance)
         {
             using TestEnvironment testEnvironment = UnitTests.TestEnvironment.Create();
diff --git a/src/MSBuild/TerminalLogger/TerminalLogger.cs b/src/MSBuild/TerminalLogger/TerminalLogger.cs
index 71749e72717..bb31cf7d6bd 100644
--- a/src/MSBuild/TerminalLogger/TerminalLogger.cs
+++ b/src/MSBuild/TerminalLogger/TerminalLogger.cs
@@ -91,6 +91,10 @@ public ProjectContext(BuildEventContext context)
     /// <summary>
     /// Tracks the work currently being done by build nodes. Null means the node is not doing any work worth reporting.
     /// </summary>
+    /// <remarks>
+    /// There is no locking around access to this data structure despite it being accessed concurrently by multiple threads.
+    /// However, reads and writes to locations in an array is atomic, so locking is not required.
+    /// </remarks>
     private NodeStatus?[] _nodes = Array.Empty<NodeStatus>();
 
     /// <summary>
@@ -701,11 +705,8 @@ private void TargetStarted(object sender, TargetStartedEventArgs e)
 
     private void UpdateNodeStatus(BuildEventContext buildEventContext, NodeStatus? nodeStatus)
     {
-        lock (_lock)
-        {
-            int nodeIndex = NodeIndexForContext(buildEventContext);
-            _nodes[nodeIndex] = nodeStatus;
-        }
+        int nodeIndex = NodeIndexForContext(buildEventContext);
+        _nodes[nodeIndex] = nodeStatus;
     }
 
     /// <summary>
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index adecc536031..38ae4cbb8d4 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -227,6 +227,8 @@
             <property name="VSToolsPath" value="$(MSBuildProgramFiles32)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)"/>
           </searchPaths>
         </projectImportSearchPaths>
+
+        <property name="WindowsKitsRoot" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Kits\Installed Roots', 'KitsRoot10', null, RegistryView.Registry32, RegistryView.Default))" />
       </toolset>
     </msbuildToolsets>
   </configuration>
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 2a2ad570ff3..6fc1459176b 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -176,6 +176,8 @@
             <property name="VSToolsPath" value="$(MSBuildProgramFiles32)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)"/>
           </searchPaths>
         </projectImportSearchPaths>
+
+        <property name="WindowsKitsRoot" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Kits\Installed Roots', 'KitsRoot10', null, RegistryView.Registry32, RegistryView.Default))" />
       </toolset>
     </msbuildToolsets>
   </configuration>
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 26ad0cf2151..6634af8df2f 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -241,7 +241,7 @@
     </EmbeddedResource>
   </ItemGroup>
   <ItemGroup>
-    <Content Include="..\MSBuild.ico" />
+    <Content Include="..\MSBuild\MSBuild.ico" />
   </ItemGroup>
   <ItemGroup>
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
diff --git a/src/Package/GetBinPaths.Arm64.targets b/src/Package/GetBinPaths.Arm64.targets
index 21a6684a86f..59e61789962 100644
--- a/src/Package/GetBinPaths.Arm64.targets
+++ b/src/Package/GetBinPaths.Arm64.targets
@@ -14,6 +14,11 @@
                       Private="false"
                       ReferenceOutputAssembly="false"
                       OutputItemType="FrameworkResolvedProjectReferencePath" />
+
+    <Arm64ProjectReference Include="$(MSBuildThisFileDirectory)\..\MSBuildTaskHost\MSBuildTaskHost.csproj"
+                      SetPlatform="Platform=arm64"
+                      OutputItemType="MSBuildTaskHostArm64ResolvedProjectReferencePath"
+                      GlobalPropertiesToRemove="TargetFramework" />
   </ItemGroup>
 
   <Target Name="SetBinPathsArm64" DependsOnTargets="ResolveProjectReferences">
@@ -29,6 +34,8 @@
     <PropertyGroup>
       <FrameworkBinPath>@(FrameworkResolvedProjectReferencePath->'%(RootDir)%(Directory)')</FrameworkBinPath>
       <Arm64BinPath>@(MSBuildArm64ResolvedProjectReferencePath->'%(RootDir)%(Directory)')</Arm64BinPath>
+      <MSBuildTaskHostArm64BinPath>@(MSBuildTaskHostArm64ResolvedProjectReferencePath->'%(RootDir)%(Directory)')</MSBuildTaskHostArm64BinPath>
+
     </PropertyGroup>
   </Target>
 
diff --git a/src/Package/MSBuild.VSSetup.Arm64/MSBuild.VSSetup.Arm64.csproj b/src/Package/MSBuild.VSSetup.Arm64/MSBuild.VSSetup.Arm64.csproj
index 2886ce40bc8..6b9d4cebbf8 100644
--- a/src/Package/MSBuild.VSSetup.Arm64/MSBuild.VSSetup.Arm64.csproj
+++ b/src/Package/MSBuild.VSSetup.Arm64/MSBuild.VSSetup.Arm64.csproj
@@ -29,6 +29,7 @@
       <SwrProperty Include="Version=$(VsixVersion)" />
       <SwrProperty Include="FrameworkBinPath=$(FrameworkBinPath)" />
       <SwrProperty Include="Arm64BinPath=$(Arm64BinPath)" />
+      <SwrProperty Include="TaskHostArm64BinPath=$(MSBuildTaskHostArm64BinPath)" />
     </ItemGroup>
   </Target>
 
diff --git a/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr b/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
index 845c52c7b8c..9a6ef830231 100644
--- a/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
+++ b/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
@@ -50,28 +50,80 @@ folder InstallDir:\MSBuild\Current\Bin\arm64\MSBuild
   file source=$(Arm64BinPath)\MSBuild\Microsoft.Build.CommonTypes.xsd
 
 folder InstallDir:\MSBuild\Current\Bin\arm64\cs
+  file source=$(Arm64BinPath)cs\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)cs\MSBuild.resources.dll
+  file source=$(Arm64BinPath)cs\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)cs\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)cs\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\de
+  file source=$(Arm64BinPath)de\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)de\MSBuild.resources.dll
+  file source=$(Arm64BinPath)de\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)de\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)de\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\es
+  file source=$(Arm64BinPath)es\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)es\MSBuild.resources.dll
+  file source=$(Arm64BinPath)es\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)es\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)es\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\fr
+  file source=$(Arm64BinPath)fr\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)fr\MSBuild.resources.dll
+  file source=$(Arm64BinPath)fr\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)fr\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)fr\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\it
+  file source=$(Arm64BinPath)it\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)it\MSBuild.resources.dll
+  file source=$(Arm64BinPath)it\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)it\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)it\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\ja
+  file source=$(Arm64BinPath)ja\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)ja\MSBuild.resources.dll
+  file source=$(Arm64BinPath)ja\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)ja\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)ja\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\ko
+  file source=$(Arm64BinPath)ko\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)ko\MSBuild.resources.dll
+  file source=$(Arm64BinPath)ko\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)ko\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)ko\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\pl
+  file source=$(Arm64BinPath)pl\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)pl\MSBuild.resources.dll
+  file source=$(Arm64BinPath)pl\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)pl\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)pl\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\pt-BR
+  file source=$(Arm64BinPath)pt-BR\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)pt-BR\MSBuild.resources.dll
+  file source=$(Arm64BinPath)pt-BR\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)pt-BR\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)pt-BR\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\ru
+  file source=$(Arm64BinPath)ru\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)ru\MSBuild.resources.dll
+  file source=$(Arm64BinPath)ru\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)ru\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)ru\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\tr
+  file source=$(Arm64BinPath)tr\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)tr\MSBuild.resources.dll
+  file source=$(Arm64BinPath)tr\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)tr\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)tr\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\zh-Hans
+  file source=$(Arm64BinPath)zh-Hans\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)zh-Hans\MSBuild.resources.dll
+  file source=$(Arm64BinPath)zh-Hans\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)zh-Hans\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)zh-Hans\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\zh-Hant
+  file source=$(Arm64BinPath)zh-Hant\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)zh-Hant\MSBuild.resources.dll
+  file source=$(Arm64BinPath)zh-Hant\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)zh-Hant\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)zh-Hant\MSBuildTaskHost.resources.dll
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index 77978ac3749..e0ac6bae417 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -203,6 +203,8 @@ internal static class ItemMetadataNames
         internal const string assemblyName = "AssemblyName";
         internal const string assemblyVersion = "AssemblyVersion";
         internal const string publicKeyToken = "PublicKeyToken";
+        internal const string culture = "Culture";
+        internal const string withCulture = "WithCulture";
 
         /// <summary>
         /// The output path for a given item.
diff --git a/src/Tasks.UnitTests/AssignCulture_Tests.cs b/src/Tasks.UnitTests/AssignCulture_Tests.cs
index e26e33a7668..47ceeb5d7b0 100644
--- a/src/Tasks.UnitTests/AssignCulture_Tests.cs
+++ b/src/Tasks.UnitTests/AssignCulture_Tests.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
@@ -14,11 +15,9 @@ namespace Microsoft.Build.UnitTests
 {
     public sealed class AssignCulture_Tests
     {
-        /*
-        * Method:   Basic
-        *
-        * Test the basic functionality.
-        */
+        /// <summary>
+        /// Tests the basic functionality.
+        /// </summary>
         [Fact]
         public void Basic()
         {
@@ -35,11 +34,9 @@ public void Basic()
             Assert.Equal("MyResource.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
         }
 
-        /*
-        * Method:   CultureAttributePrecedence
-        *
-        * Any pre-existing Culture attribute on the item is to be ignored
-        */
+        /// <summary>
+        /// Any pre-existing Culture attribute on the item is to be ignored
+        /// </summary>
         [Fact]
         public void CultureAttributePrecedence()
         {
@@ -57,13 +54,11 @@ public void CultureAttributePrecedence()
             Assert.Equal("MyResource.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
         }
 
-        /*
-        * Method:   CultureAttributePrecedenceWithBogusCulture
-        *
-        * This is really a corner case.
-        * If the incoming item has a 'Culture' attribute already, but that culture is invalid,
-        * we still overwrite that culture.
-        */
+        /// <summary>
+        /// This is really a corner case.
+        /// If the incoming item has a 'Culture' attribute already, but that culture is invalid,
+        /// we still overwrite that culture.
+        /// </summary>
         [Fact]
         public void CultureAttributePrecedenceWithBogusCulture()
         {
@@ -81,14 +76,10 @@ public void CultureAttributePrecedenceWithBogusCulture()
             Assert.Equal("MyResource.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
         }
 
-
-
-        /*
-        * Method:   AttributeForwarding
-        *
-        * Make sure that attributes set on input items are forwarded to output items.
-        * This applies to every attribute except for the one pointed to by CultureAttribute.
-        */
+        /// <summary>
+        /// Make sure that attributes set on input items are forwarded to output items.
+        /// This applies to every attribute except for the one pointed to by CultureAttribute.
+        /// </summary>
         [Fact]
         public void AttributeForwarding()
         {
@@ -108,12 +99,10 @@ public void AttributeForwarding()
         }
 
 
-        /*
-        * Method:   NoCulture
-        *
-        * Test the case where an item has no embedded culture. For example,
-        * "MyResource.resx"
-        */
+        /// <summary>
+        /// Test the case where an item has no embedded culture. For example:
+        /// "MyResource.resx"
+        /// </summary>
         [Fact]
         public void NoCulture()
         {
@@ -130,11 +119,9 @@ public void NoCulture()
             Assert.Equal("MyResource.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
         }
 
-        /*
-        * Method:   NoExtension
-        *
-        * Test the case where an item has no extension. For example "MyResource".
-        */
+        /// <summary>
+        /// Test the case where an item has no extension. For example "MyResource".
+        /// </summary>
         [Fact]
         public void NoExtension()
         {
@@ -151,12 +138,10 @@ public void NoExtension()
             Assert.Equal("MyResource", t.CultureNeutralAssignedFiles[0].ItemSpec);
         }
 
-        /*
-        * Method:   DoubleDot
-        *
-        * Test the case where an item has two dots embedded, but otherwise looks
-        * like a well-formed item. For example "MyResource..resx".
-        */
+        /// <summary>
+        ///  Test the case where an item has two dots embedded, but otherwise looks
+        /// like a well-formed item.For example "MyResource..resx".
+        /// </summary>
         [Fact]
         public void DoubleDot()
         {
@@ -194,12 +179,11 @@ public void Regress283991()
             Assert.Single(t.AssignedFilesWithNoCulture);
         }
 
-        /*
-        * Method:   PseudoLocalization
-        *
-        * Test the usage of Windows Pseudo-Locales
-        * https://docs.microsoft.com/en-gb/windows/desktop/Intl/pseudo-locales
-        */
+        /// <summary>
+        /// Test the usage of Windows Pseudo-Locales
+        /// https://docs.microsoft.com/en-gb/windows/desktop/Intl/pseudo-locales
+        /// </summary>
+        /// <param name="culture"></param>
         [Theory]
         [InlineData("qps-ploc")]
         [InlineData("qps-plocm")]
@@ -277,5 +261,47 @@ public void Pseudolocales_CaseInsensitive()
             Assert.Equal($"MyResource.{culture}.resx", t.AssignedFiles[0].ItemSpec);
             Assert.Equal("MyResource.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
         }
+
+        /// <summary>
+        /// Any pre-existing Culture attribute on the item is to be respected
+        /// </summary>
+        [Fact]
+        public void CultureMetaDataShouldBeRespected()
+        {
+            AssignCulture t = new AssignCulture();
+            t.BuildEngine = new MockEngine();
+            ITaskItem i = new TaskItem("MyResource.fr.resx");
+            i.SetMetadata("Culture", "en-GB");
+            t.Files = new ITaskItem[] { i };
+            t.RespectAlreadyAssignedItemCulture = true;
+            t.Execute();
+
+            Assert.Single(t.AssignedFiles);
+            Assert.Single(t.CultureNeutralAssignedFiles);
+            Assert.Equal("en-GB", t.AssignedFiles[0].GetMetadata("Culture"));
+            Assert.Equal("MyResource.fr.resx", t.AssignedFiles[0].ItemSpec);
+            Assert.Equal("MyResource.fr.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
+        }
+
+        /// <summary>
+        /// Any pre-existing Culture attribute on the item is not to be respected, because culture is not set
+        /// </summary>
+        [Fact]
+        public void CultureMetaDataShouldNotBeRespected()
+        {
+            AssignCulture t = new AssignCulture();
+            t.BuildEngine = new MockEngine();
+            ITaskItem i = new TaskItem("MyResource.fr.resx");
+            i.SetMetadata("Culture", "");
+            t.Files = new ITaskItem[] { i };
+            t.RespectAlreadyAssignedItemCulture = true;
+            t.Execute();
+
+            Assert.Single(t.AssignedFiles);
+            Assert.Single(t.CultureNeutralAssignedFiles);
+            Assert.Equal("fr", t.AssignedFiles[0].GetMetadata("Culture"));
+            Assert.Equal("MyResource.fr.resx", t.AssignedFiles[0].ItemSpec);
+            Assert.Equal("MyResource.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
+        }
     }
 }
diff --git a/src/Tasks/AssignCulture.cs b/src/Tasks/AssignCulture.cs
index f55d2fd6268..277145c17d7 100644
--- a/src/Tasks/AssignCulture.cs
+++ b/src/Tasks/AssignCulture.cs
@@ -41,6 +41,12 @@ public class AssignCulture : TaskExtension
         [Required]
         public ITaskItem[] Files { get; set; } = Array.Empty<ITaskItem>();
 
+        /// <summary>
+        /// If the flag set to 'true' the incoming list with existing Culture metadata will not be ammended and CultureNeutralAssignedFiles filename will be equal to the original.
+        /// In case the Culture metadata was not provided, the logic of RespectAlreadyAssignedItemCulture will not take any effect.
+        /// </summary>
+        public bool RespectAlreadyAssignedItemCulture { get; set; } = false;
+
         /// <summary>
         /// This outgoing list of files is exactly the same as the incoming Files
         /// list except that an attribute name "Culture" will have been added if
@@ -134,32 +140,44 @@ public override bool Execute()
                     AssignedFiles[i] = new TaskItem(Files[i]);
 
                     string dependentUpon = AssignedFiles[i].GetMetadata(ItemMetadataNames.dependentUpon);
-                    Culture.ItemCultureInfo info = Culture.GetItemCultureInfo(
-                            AssignedFiles[i].ItemSpec,
-                            dependentUpon,
-                            // If 'WithCulture' is explicitly set to false, treat as 'culture-neutral' and keep the original name of the resource.
-                            // https://github.com/dotnet/msbuild/issues/3064
-                            ConversionUtilities.ValidBooleanFalse(AssignedFiles[i].GetMetadata("WithCulture")));
-
-                    if (!string.IsNullOrEmpty(info.culture))
+                    string existingCulture = AssignedFiles[i].GetMetadata(ItemMetadataNames.culture);
+                    
+                    if (RespectAlreadyAssignedItemCulture && !string.IsNullOrEmpty(existingCulture))
                     {
-                        AssignedFiles[i].SetMetadata("Culture", info.culture);
-                        AssignedFiles[i].SetMetadata("WithCulture", "true");
+                        AssignedFiles[i].SetMetadata(ItemMetadataNames.withCulture, "true");
                         cultureList.Add(AssignedFiles[i]);
+
+                        CultureNeutralAssignedFiles[i] = new TaskItem(AssignedFiles[i]);
                     }
                     else
                     {
-                        noCultureList.Add(AssignedFiles[i]);
-                        AssignedFiles[i].SetMetadata("WithCulture", "false");
-                    }
-
-                    CultureNeutralAssignedFiles[i] =
+                        Culture.ItemCultureInfo info = Culture.GetItemCultureInfo(
+                            AssignedFiles[i].ItemSpec,
+                            dependentUpon,
+                            // If 'WithCulture' is explicitly set to false, treat as 'culture-neutral' and keep the original name of the resource.
+                            // https://github.com/dotnet/msbuild/issues/3064
+                            ConversionUtilities.ValidBooleanFalse(AssignedFiles[i].GetMetadata(ItemMetadataNames.withCulture)));
+
+                        if (!string.IsNullOrEmpty(info.culture))
+                        {
+                            AssignedFiles[i].SetMetadata(ItemMetadataNames.culture, info.culture);
+                            AssignedFiles[i].SetMetadata(ItemMetadataNames.withCulture, "true");
+                            cultureList.Add(AssignedFiles[i]);
+                        }
+                        else
+                        {
+                            noCultureList.Add(AssignedFiles[i]);
+                            AssignedFiles[i].SetMetadata(ItemMetadataNames.withCulture, "false");
+                        }
+
+                        CultureNeutralAssignedFiles[i] =
                         new TaskItem(AssignedFiles[i]) { ItemSpec = info.cultureNeutralFilename };
+                    }
 
                     Log.LogMessageFromResources(
                         MessageImportance.Low,
                         "AssignCulture.Comment",
-                        AssignedFiles[i].GetMetadata("Culture"),
+                        AssignedFiles[i].GetMetadata(ItemMetadataNames.culture),
                         AssignedFiles[i].ItemSpec);
                 }
                 catch (ArgumentException e)
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index 76e17988b08..accb98d7438 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -829,81 +829,44 @@ private XmlDocument LoadAndValidateXmlDocument(string filePath, bool validateFil
 
                 if (fileExists)
                 {
-                    var xmlTextReader = new XmlTextReader(filePath) { DtdProcessing = DtdProcessing.Ignore };
-
-                    XmlReader xmlReader = xmlTextReader;
-
+                    XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
+                    xmlReaderSettings.DtdProcessing = DtdProcessing.Ignore;
                     if (validate)
                     {
-#pragma warning disable 618 // Using XmlValidatingReader. TODO: We need to switch to using XmlReader.Create() with validation.
-                        using var validatingReader = new XmlValidatingReader(xmlReader);
-#pragma warning restore 618
-                        var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true };
-                        FileStream fs = File.OpenRead(schemaPath);
-                        using (XmlReader xr = XmlReader.Create(fs, xrSettings))
+                        xmlReaderSettings.ValidationType = ValidationType.Schema;
+                        xmlReaderSettings.XmlResolver = null;
+                        xmlReaderSettings.ValidationEventHandler += results.SchemaValidationEventHandler; ;
+                        xmlReaderSettings.Schemas.Add(null, schemaPath);
+                    }
+
+                    using (StreamReader streamReader = new StreamReader(filePath))
+                    {
+                        using (XmlReader xmlReader = XmlReader.Create(streamReader, xmlReaderSettings, filePath))
                         {
                             try
                             {
-                                // first, add our schema to the validating reader's collection of schemas
-                                var xmlSchema = validatingReader.Schemas.Add(null, xr);
-
-                                // if our schema namespace gets out of sync,
-                                //   then all of our calls to SelectNodes and SelectSingleNode will fail
-                                Debug.Assert((xmlSchema != null) &&
-                                    string.Equals(schemaNamespace, xmlSchema.TargetNamespace, StringComparison.Ordinal),
-                                    System.IO.Path.GetFileName(schemaPath) + " and BootstrapperBuilder.vb have mismatched namespaces, so the BootstrapperBuilder will fail to work.");
-
-                                // if we're supposed to be validating, then hook up our handler
-                                validatingReader.ValidationEventHandler += results.SchemaValidationEventHandler;
-
-                                // switch readers so the doc does the actual read over the validating
-                                //   reader so we get validation events as we load the document
-                                xmlReader = validatingReader;
+                                Debug.Assert(_document != null, "our document should have been created by now!");
+                                xmlDocument = new XmlDocument(_document.NameTable);
+                                xmlDocument.Load(xmlReader);
                             }
                             catch (XmlException ex)
                             {
-                                Debug.Fail("Failed to load schema '" + schemaPath + "' due to the following exception:\r\n" + ex.Message);
-                                validate = false;
+                                Debug.Fail("Failed to load document '" + filePath + "' due to the following exception:\r\n" + ex.Message);
+                                return null;
                             }
                             catch (System.Xml.Schema.XmlSchemaException ex)
                             {
-                                Debug.Fail("Failed to load schema '" + schemaPath + "' due to the following exception:\r\n" + ex.Message);
-                                validate = false;
+                                Debug.Fail("Failed to load document '" + filePath + "' due to the following exception:\r\n" + ex.Message);
+                                return null;
                             }
                         }
                     }
 
-                    try
-                    {
-                        Debug.Assert(_document != null, "our document should have been created by now!");
-                        xmlDocument = new XmlDocument(_document.NameTable);
-                        xmlDocument.Load(xmlReader);
-                    }
-                    catch (XmlException ex)
-                    {
-                        Debug.Fail("Failed to load document '" + filePath + "' due to the following exception:\r\n" + ex.Message);
-                        return null;
-                    }
-                    catch (System.Xml.Schema.XmlSchemaException ex)
-                    {
-                        Debug.Fail("Failed to load document '" + filePath + "' due to the following exception:\r\n" + ex.Message);
-                        return null;
-                    }
-                    finally
-                    {
-                        xmlReader.Close();
-                    }
-
                     // Note that the xml document's default namespace must match the schema namespace
                     //   or none of our SelectNodes/SelectSingleNode calls will succeed
                     Debug.Assert(xmlDocument.DocumentElement != null &&
-                        string.Equals(xmlDocument.DocumentElement.NamespaceURI, schemaNamespace, StringComparison.Ordinal),
-                        "'" + xmlDocument.DocumentElement.NamespaceURI + "' is not '" + schemaNamespace + "'...");
-
-                    if ((xmlDocument.DocumentElement == null) ||
-                       (!string.Equals(xmlDocument.DocumentElement.NamespaceURI, schemaNamespace, StringComparison.Ordinal)))
-                    {
-                    }
+                                string.Equals(xmlDocument.DocumentElement.NamespaceURI, schemaNamespace, StringComparison.Ordinal),
+                                "'" + xmlDocument.DocumentElement.NamespaceURI + "' is not '" + schemaNamespace + "'...");
                 }
             }
 
diff --git a/src/Tasks/FileIO/GetFileHash.cs b/src/Tasks/FileIO/GetFileHash.cs
index 23ae783b33f..2d1ec4f5308 100644
--- a/src/Tasks/FileIO/GetFileHash.cs
+++ b/src/Tasks/FileIO/GetFileHash.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Security.Cryptography;
+using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -17,7 +18,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Computes the checksum for a single file.
     /// </summary>
-    public sealed class GetFileHash : TaskExtension
+    public sealed class GetFileHash : TaskExtension, ICancelableTask
     {
         internal const string _defaultFileHashAlgorithm = "SHA256";
         internal const string _hashEncodingHex = "hex";
@@ -77,8 +78,10 @@ public override bool Execute()
                 return false;
             }
 
+            var parallelOptions = new ParallelOptions() { CancellationToken = _cancellationTokenSource.Token };
+
             var writeLock = new object();
-            Parallel.For(0, Files.Length, index =>
+            Parallel.For(0, Files.Length, parallelOptions, index =>
             {
                 var file = Files[index];
 
@@ -88,7 +91,7 @@ public override bool Execute()
                     return;
                 }
 
-                var hash = ComputeHash(algorithmFactory, file.ItemSpec);
+                var hash = ComputeHash(algorithmFactory, file.ItemSpec, _cancellationTokenSource.Token);
                 var encodedHash = EncodeHash(encoding, hash);
 
                 lock (writeLock)
@@ -115,6 +118,13 @@ public override bool Execute()
             return !Log.HasLoggedErrors;
         }
 
+        private readonly CancellationTokenSource _cancellationTokenSource = new CancellationTokenSource();
+
+        public void Cancel()
+        {
+            _cancellationTokenSource.Cancel();
+        }
+
         internal static string EncodeHash(HashEncoding encoding, byte[] hash)
         {
             return encoding switch
@@ -128,12 +138,16 @@ internal static string EncodeHash(HashEncoding encoding, byte[] hash)
         internal static bool TryParseHashEncoding(string value, out HashEncoding encoding)
             => Enum.TryParse<HashEncoding>(value, /*ignoreCase:*/ true, out encoding);
 
-        internal static byte[] ComputeHash(Func<HashAlgorithm> algorithmFactory, string filePath)
+        internal static byte[] ComputeHash(Func<HashAlgorithm> algorithmFactory, string filePath, CancellationToken ct)
         {
             using (var stream = File.OpenRead(filePath))
             using (var algorithm = algorithmFactory())
             {
+#if NET5_0_OR_GREATER
+                return algorithm.ComputeHashAsync(stream, ct).Result;
+#else
                 return algorithm.ComputeHash(stream);
+#endif
             }
         }
     }
diff --git a/src/Tasks/FileIO/VerifyFileHash.cs b/src/Tasks/FileIO/VerifyFileHash.cs
index 11b168b7cd2..9c3eca7556b 100644
--- a/src/Tasks/FileIO/VerifyFileHash.cs
+++ b/src/Tasks/FileIO/VerifyFileHash.cs
@@ -4,6 +4,7 @@
 using System;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
+using System.Threading;
 
 #nullable disable
 
@@ -12,7 +13,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Verifies that a file matches the expected file hash.
     /// </summary>
-    public sealed class VerifyFileHash : TaskExtension
+    public sealed class VerifyFileHash : TaskExtension, ICancelableTask
     {
         /// <summary>
         /// The file path.
@@ -56,7 +57,7 @@ public override bool Execute()
                 return false;
             }
 
-            byte[] hash = GetFileHash.ComputeHash(algorithmFactory, File);
+            byte[] hash = GetFileHash.ComputeHash(algorithmFactory, File, _cancellationTokenSource.Token);
             string actualHash = GetFileHash.EncodeHash(encoding, hash);
             var comparison = encoding == Tasks.HashEncoding.Hex
                 ? StringComparison.OrdinalIgnoreCase
@@ -69,5 +70,12 @@ public override bool Execute()
 
             return !Log.HasLoggedErrors;
         }
+
+        private readonly CancellationTokenSource _cancellationTokenSource = new CancellationTokenSource();
+
+        public void Cancel()
+        {
+            _cancellationTokenSource.Cancel();
+        }
     }
 }
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 3fc9a9c4d00..5e81c64c525 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -385,11 +385,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <_GenerateBindingRedirectsIntermediateAppConfig>$(IntermediateOutputPath)$(TargetFileName).config</_GenerateBindingRedirectsIntermediateAppConfig>
   </PropertyGroup>
-  
+
   <PropertyGroup Condition="'$(MSBuildCopyMarkerName)' == ''">
     <MSBuildCopyMarkerName>$(MSBuildProjectFile)</MSBuildCopyMarkerName>
     <!-- For a long MSBuildProjectFile let's shorten this to 17 chars - using the first 8 codepoints of the filename and a filename hash. -->
-    <MSBuildCopyMarkerName Condition="'$(MSBuildCopyMarkerName.Length)' &gt; '17'">$([MSBuild]::SubstringByTextElements($(MSBuildProjectFile), 0, 8)).$([MSBuild]::StableStringHash($(MSBuildProjectFile)).ToString("X8"))</MSBuildCopyMarkerName>
+    <MSBuildCopyMarkerName Condition="'$(MSBuildCopyMarkerName.Length)' &gt; '17'">$([MSBuild]::SubstringByAsciiChars($(MSBuildProjectFile), 0, 8)).$([MSBuild]::StableStringHash($(MSBuildProjectFile)).ToString("X8"))</MSBuildCopyMarkerName>
     <MSBuildCopyMarkerName>$(MSBuildCopyMarkerName).Up2Date</MSBuildCopyMarkerName>
   </PropertyGroup>
 
@@ -2566,7 +2566,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <SDKReferenceRegistryRoot Condition="'$(SDKReferenceRegistryRoot)' == ''">Software\Microsoft\Microsoft SDKs</SDKReferenceRegistryRoot>
     <SDKReferenceDirectoryRoot Condition="'$(SDKReferenceDirectoryRoot)' == ''">$(LocalAppData)\Microsoft SDKs;$(MSBuildProgramFiles32)\Microsoft SDKs</SDKReferenceDirectoryRoot>
     <!-- Manifest driven extension SDK locations -->
-    <SDKExtensionDirectoryRoot Condition="'$(SDKExtensionDirectoryRoot)' == '' and '$(SDKIdentifier)' != ''">$(MSBuildProgramFiles32)\Microsoft SDKs\Windows Kits\10;$(MSBuildProgramFiles32)\Windows Kits\10</SDKExtensionDirectoryRoot>
+    <SDKExtensionDirectoryRoot Condition="'$(SDKExtensionDirectoryRoot)' == '' and '$(SDKIdentifier)' != ''">$(MSBuildProgramFiles32)\Microsoft SDKs\Windows Kits\10;$(WindowsKitsRoot)</SDKExtensionDirectoryRoot>
 
     <!-- UAP projects by default should support Windows 8.1 SDKs -->
     <SupportWindows81SDKs Condition="'$(SupportWindows81SDKs)' == '' and '$(Support81SDKs)' != 'false' and '$(TargetPlatformIdentifier)' == 'UAP'">true</SupportWindows81SDKs>
@@ -3244,6 +3244,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       Name="SplitResourcesByCulture"
       DependsOnTargets="AssignTargetPaths">
 
+    <PropertyGroup>
+      <RespectAlreadyAssignedItemCulture Condition="'$(RespectAlreadyAssignedItemCulture)' == ''">false</RespectAlreadyAssignedItemCulture>
+    </PropertyGroup>
+
     <Warning Condition="'@(ResxWithNoCulture)'!=''" Code="MSB9000" Text="ResxWithNoCulture item type is deprecated. Use EmbeddedResource items instead."/>
     <Warning Condition="'@(ResxWithCulture)'!=''" Code="MSB9001" Text="ResxWithCulture item type is deprecated. Use EmbeddedResource items instead."/>
     <Warning Condition="'@(NonResxWithCulture)'!=''" Code="MSB9002" Text="NonResxWithCulture item type is deprecated. Use EmbeddedResource items instead."/>
@@ -3261,7 +3265,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </EmbeddedResource>
     </ItemGroup>
 
-    <AssignCulture Files="@(EmbeddedResource)" Condition="'%(Extension)'!='.licx'">
+    <AssignCulture Files="@(EmbeddedResource)" Condition="'%(Extension)'!='.licx'"  RespectAlreadyAssignedItemCulture="$(RespectAlreadyAssignedItemCulture)">
       <!-- Create the list of culture resx and embedded resource files -->
       <Output TaskParameter="AssignedFilesWithCulture" ItemName="_MixedResourceWithCulture"/>
       <!-- Create the list of non-culture resx and embedded resource files -->
@@ -6819,7 +6823,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </PropertyGroup>
 
   <Import Project="$(MsTestToolsTargets)" Condition="Exists('$(MsTestToolsTargets)')" />
-  
+
   <PropertyGroup>
     <UseMSBuildTestInfrastructure Condition="'$(UseMSBuildTestInfrastructure)' == ''">false</UseMSBuildTestInfrastructure>
   </PropertyGroup>
