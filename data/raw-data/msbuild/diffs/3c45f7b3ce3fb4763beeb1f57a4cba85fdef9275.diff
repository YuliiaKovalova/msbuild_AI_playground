diff --git a/eng/AfterSigning.targets b/eng/AfterSigning.targets
new file mode 100644
index 00000000000..e699c81e7dc
--- /dev/null
+++ b/eng/AfterSigning.targets
@@ -0,0 +1,12 @@
+<Project>
+    <Target Name="CopyAMD64Symbols" Condition="'$(OfficialBuild)' == 'true'" BeforeTargets="Build">
+        <Copy 
+            SourceFiles="$(ArtifactsBinDir)MSBuild\x64\Release\net472\MSBuild.pdb"
+            DestinationFolder="$(ArtifactsSymStoreDirectory)\MSBuild\net472\amd64"
+            />
+        <Copy 
+            SourceFiles="$(ArtifactsBinDir)MSBuildTaskHost\x64\Release\net35\MSBuildTaskHost.pdb"
+            DestinationFolder="$(ArtifactsSymStoreDirectory)\MSBuildTaskHost\net35\amd64"
+            />
+    </Target>
+</Project>
\ No newline at end of file
diff --git a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
index 83e34506cb0..2184424e3f4 100644
--- a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
@@ -653,6 +653,16 @@ public ResolveKeySource() { }
         public bool SuppressAutoClosePasswordPrompt { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
+    public partial class ResolveNonMSBuildProjectOutput : Microsoft.Build.Tasks.ResolveProjectBase
+    {
+        public ResolveNonMSBuildProjectOutput() { }
+        public string PreresolvedProjectOutputs { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem[] ResolvedOutputPaths { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem[] UnresolvedProjectReferences { get { throw null; } set { } }
+        public override bool Execute() { throw null; }
+    }
     public abstract partial class ResolveProjectBase : Microsoft.Build.Tasks.TaskExtension
     {
         protected ResolveProjectBase() { }
diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
index f47b211ceb4..39712e7b9ef 100644
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/net/Microsoft.Build.cs
@@ -927,6 +927,7 @@ public BuildManager() { }
         public BuildManager(string hostName) { }
         public static Microsoft.Build.Execution.BuildManager DefaultBuildManager { get { throw null; } }
         public void BeginBuild(Microsoft.Build.Execution.BuildParameters parameters) { }
+        public void BeginBuild(Microsoft.Build.Execution.BuildParameters parameters, System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.BuildManager.DeferredBuildMessage> deferredBuildMessages) { }
         public Microsoft.Build.Execution.BuildResult Build(Microsoft.Build.Execution.BuildParameters parameters, Microsoft.Build.Execution.BuildRequestData requestData) { throw null; }
         public Microsoft.Build.Graph.GraphBuildResult Build(Microsoft.Build.Execution.BuildParameters parameters, Microsoft.Build.Graph.GraphBuildRequestData requestData) { throw null; }
         public Microsoft.Build.Execution.BuildResult BuildRequest(Microsoft.Build.Execution.BuildRequestData requestData) { throw null; }
@@ -940,6 +941,13 @@ public void EndBuild() { }
         public Microsoft.Build.Graph.GraphBuildSubmission PendBuildRequest(Microsoft.Build.Graph.GraphBuildRequestData requestData) { throw null; }
         public void ResetCaches() { }
         public void ShutdownAllNodes() { }
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public partial struct DeferredBuildMessage
+        {
+            public DeferredBuildMessage(string text, Microsoft.Build.Framework.MessageImportance importance) { throw null;}
+            public Microsoft.Build.Framework.MessageImportance Importance { get { throw null; } }
+            public string Text { get { throw null; } }
+        }
     }
     public partial class BuildParameters
     {
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
index bf01a486b2f..53256cf1600 100644
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
@@ -923,6 +923,7 @@ public BuildManager() { }
         public BuildManager(string hostName) { }
         public static Microsoft.Build.Execution.BuildManager DefaultBuildManager { get { throw null; } }
         public void BeginBuild(Microsoft.Build.Execution.BuildParameters parameters) { }
+        public void BeginBuild(Microsoft.Build.Execution.BuildParameters parameters, System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.BuildManager.DeferredBuildMessage> deferredBuildMessages) { }
         public Microsoft.Build.Execution.BuildResult Build(Microsoft.Build.Execution.BuildParameters parameters, Microsoft.Build.Execution.BuildRequestData requestData) { throw null; }
         public Microsoft.Build.Graph.GraphBuildResult Build(Microsoft.Build.Execution.BuildParameters parameters, Microsoft.Build.Graph.GraphBuildRequestData requestData) { throw null; }
         public Microsoft.Build.Execution.BuildResult BuildRequest(Microsoft.Build.Execution.BuildRequestData requestData) { throw null; }
@@ -936,6 +937,13 @@ public void EndBuild() { }
         public Microsoft.Build.Graph.GraphBuildSubmission PendBuildRequest(Microsoft.Build.Graph.GraphBuildRequestData requestData) { throw null; }
         public void ResetCaches() { }
         public void ShutdownAllNodes() { }
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public partial struct DeferredBuildMessage
+        {
+            public DeferredBuildMessage(string text, Microsoft.Build.Framework.MessageImportance importance) { throw null;}
+            public Microsoft.Build.Framework.MessageImportance Importance { get { throw null; } }
+            public string Text { get { throw null; } }
+        }
     }
     public partial class BuildParameters
     {
diff --git a/src/Build.UnitTests/BackEnd/AssemblyLoadContextTestTasks.cs b/src/Build.UnitTests/BackEnd/AssemblyLoadContextTestTasks.cs
new file mode 100644
index 00000000000..d8f6cab04c0
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/AssemblyLoadContextTestTasks.cs
@@ -0,0 +1,36 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
+using System.Collections;
+using System.Collections.Generic;
+
+namespace AssemblyLoadContextTest
+{
+    public class RegisterObject : Task
+    {
+        internal const string CacheKey = "RegressionForMSBuild#5080";
+
+        public override bool Execute()
+        {
+            BuildEngine4.RegisterTaskObject(
+                  CacheKey,
+                  new RegisterObject(),
+                  RegisteredTaskObjectLifetime.Build,
+                  allowEarlyCollection: false);
+
+            return true;
+        }
+    }
+
+    public class RetrieveObject : Task
+    {
+        public override bool Execute()
+        {
+            var entry = (RegisterObject)BuildEngine4.GetRegisteredTaskObject(RegisterObject.CacheKey, RegisteredTaskObjectLifetime.Build);
+
+            return true;
+        }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index 54bddb1ef82..62b8b493ecc 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -944,6 +944,68 @@ public void SimpleBuildWithFailure()
             _logger.AssertLogContains("[errormessage]");
         }
 
+        [Fact]
+        public void DeferredMessageShouldBeLogged()
+        {
+            string contents = CleanupFileContents(@"
+              <Project>
+                 <Target Name='Build'>
+                     <Message Text='[Message]' Importance='high'/>
+                     <Warning Text='[Warn]'/>	
+                </Target>
+              </Project>
+            ");
+
+            MockLogger logger;
+
+            const string highMessage = "deferred[High]";
+            const string normalMessage = "deferred[Normal]";
+            const string lowMessage = "deferred[Low]";
+
+            using (var buildManagerSession = new Helpers.BuildManagerSession(
+                _env,
+                deferredMessages: new[]
+                {
+                    new BuildManager.DeferredBuildMessage(highMessage, MessageImportance.High),
+                    new BuildManager.DeferredBuildMessage(normalMessage, MessageImportance.Normal),
+                    new BuildManager.DeferredBuildMessage(lowMessage, MessageImportance.Low)
+                }))
+            {
+                var result = buildManagerSession.BuildProjectFile(_env.CreateFile("build.proj", contents).Path);
+
+                result.OverallResult.ShouldBe(BuildResultCode.Success);
+
+                logger = buildManagerSession.Logger;
+            }
+
+            logger.AssertLogContains("[Warn]");
+            logger.AssertLogContains("[Message]");
+
+            logger.AssertLogContains(highMessage);
+            logger.AssertLogContains(normalMessage);
+            logger.AssertLogContains(lowMessage);
+
+            var deferredMessages = logger.BuildMessageEvents.Where(e => e.Message.StartsWith("deferred")).ToArray();
+
+            deferredMessages.Length.ShouldBe(3);
+
+            deferredMessages[0].Message.ShouldBe(highMessage);
+            deferredMessages[0].Importance.ShouldBe(MessageImportance.High);
+            deferredMessages[1].Message.ShouldBe(normalMessage);
+            deferredMessages[1].Importance.ShouldBe(MessageImportance.Normal);
+            deferredMessages[2].Message.ShouldBe(lowMessage);
+            deferredMessages[2].Importance.ShouldBe(MessageImportance.Low);
+
+            logger.BuildStartedEvents.Count.ShouldBe(1);
+            logger.BuildFinishedEvents.Count.ShouldBe(1);
+            logger.ProjectStartedEvents.Count.ShouldBe(1);
+            logger.ProjectFinishedEvents.Count.ShouldBe(1);
+            logger.TargetStartedEvents.Count.ShouldBe(1);
+            logger.TargetFinishedEvents.Count.ShouldBe(1);
+            logger.TaskStartedEvents.Count.ShouldBe(2);
+            logger.TaskFinishedEvents.Count.ShouldBe(2);
+        }
+
         /// <summary>
         /// A build with a message, error and warning, verify that 
         /// we only get errors, warnings, and project started and finished when OnlyLogCriticalEvents is true
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index 002c0128256..99dbc5198e6 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -517,6 +517,38 @@ public void NullMetadataOnLegacyOutputItems()
             logger.AssertLogContains("[foo: ]");
         }
 
+        /// <summary>
+        /// Regression test for https://github.com/microsoft/msbuild/issues/5080
+        /// </summary>
+        [Fact]
+        public void SameAssemblyFromDifferentRelativePathsSharesAssemblyLoadContext()
+        {
+            string realTaskPath = Assembly.GetExecutingAssembly().Location;
+
+            string fileName = Path.GetFileName(realTaskPath);
+            string directoryName = Path.GetDirectoryName(realTaskPath);
+
+            using var env = TestEnvironment.Create();
+
+            string customTaskFolder = Path.Combine(directoryName, "buildCrossTargeting");
+            env.CreateFolder(customTaskFolder);
+
+            string projectContents = @"<Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+  <UsingTask TaskName=`RegisterObject` AssemblyFile=`" + Path.Combine(customTaskFolder, "..", fileName) + @"` />
+  <UsingTask TaskName=`RetrieveObject` AssemblyFile=`" + realTaskPath + @"` />
+
+  <Target Name=`Build`>
+    <RegisterObject />
+    <RetrieveObject />
+  </Target>
+</Project>";
+
+            MockLogger logger = ObjectModelHelpers.BuildProjectExpectSuccess(projectContents, _testOutput);
+
+            logger.AssertLogDoesntContain("MSB4018");
+        }
+
+
 #if FEATURE_CODETASKFACTORY
         /// <summary>
         /// If an item being output from a task has null metadata, we shouldn't crash. 
diff --git a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
index a6c6c5a59d9..e9dc6951439 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
@@ -930,7 +930,7 @@ public void ParseSolutionFileWithDescriptionInformation()
         }
 
         /// <summary>
-        /// Tests the parsing of a very basic .SLN file with three independent projects.
+        /// Tests the parsing of a very basic .SLN file with four independent projects.
         /// </summary>
         [Fact]
         public void BasicSolution()
@@ -945,6 +945,8 @@ public void BasicSolution()
                 EndProject
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{DEBCE986-61B9-435E-8018-44B9EF751655}'
                 EndProject
+                Project('{6EC3EE1D-3C4E-46DD-8F32-0CC8E7565705}') = 'cpsFsProject', 'cpsFsProject\ProjectFileName.fsproj', '{9200923E-1814-4E76-A677-C61E4896D67F}'
+                EndProject
                 Global
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
                         Debug|AnyCPU = Debug|AnyCPU
@@ -963,6 +965,10 @@ public void BasicSolution()
                         {DEBCE986-61B9-435E-8018-44B9EF751655}.Debug|AnyCPU.Build.0 = Debug|AnyCPU
                         {DEBCE986-61B9-435E-8018-44B9EF751655}.Release|AnyCPU.ActiveCfg = Release|AnyCPU
                         {DEBCE986-61B9-435E-8018-44B9EF751655}.Release|AnyCPU.Build.0 = Release|AnyCPU
+                        {9200923E-1814-4E76-A677-C61E4896D67F}.Debug|AnyCPU.ActiveCfg = Debug|AnyCPU
+                        {9200923E-1814-4E76-A677-C61E4896D67F}.Debug|AnyCPU.Build.0 = Debug|AnyCPU
+                        {9200923E-1814-4E76-A677-C61E4896D67F}.Release|AnyCPU.ActiveCfg = Release|AnyCPU
+                        {9200923E-1814-4E76-A677-C61E4896D67F}.Release|AnyCPU.Build.0 = Release|AnyCPU
                     EndGlobalSection
                     GlobalSection(SolutionProperties) = preSolution
                         HideSolutionNode = FALSE
@@ -972,7 +978,7 @@ public void BasicSolution()
 
             SolutionFile solution = ParseSolutionHelper(solutionFileContents);
 
-            Assert.Equal(3, solution.ProjectsInOrder.Count);
+            Assert.Equal(4, solution.ProjectsInOrder.Count);
 
             Assert.Equal(SolutionProjectType.KnownToBeMSBuildFormat, solution.ProjectsInOrder[0].ProjectType);
             Assert.Equal("ConsoleApplication1", solution.ProjectsInOrder[0].ProjectName);
@@ -997,6 +1003,14 @@ public void BasicSolution()
             Assert.Empty(solution.ProjectsInOrder[2].Dependencies);
             Assert.Null(solution.ProjectsInOrder[2].ParentProjectGuid);
             Assert.Equal("ClassLibrary1", solution.ProjectsInOrder[2].GetUniqueProjectName());
+
+            Assert.Equal(SolutionProjectType.KnownToBeMSBuildFormat, solution.ProjectsInOrder[3].ProjectType);
+            Assert.Equal("cpsFsProject", solution.ProjectsInOrder[3].ProjectName);
+            Assert.Equal(@"cpsFsProject\ProjectFileName.fsproj", solution.ProjectsInOrder[3].RelativePath);
+            Assert.Equal("{9200923E-1814-4E76-A677-C61E4896D67F}", solution.ProjectsInOrder[3].ProjectGuid);
+            Assert.Empty(solution.ProjectsInOrder[3].Dependencies);
+            Assert.Null(solution.ProjectsInOrder[3].ParentProjectGuid);
+            Assert.Equal("cpsFsProject", solution.ProjectsInOrder[3].GetUniqueProjectName());
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index ad8d0745728..049c5fc36e3 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -233,6 +233,8 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// </summary>
         private DateTime _instantiationTimeUtc;
 
+        private IEnumerable<DeferredBuildMessage> _deferredBuildMessages;
+
 #if DEBUG
         /// <summary>
         /// <code>true</code> to wait for a debugger to be attached, otherwise <code>false</code>.
@@ -293,12 +295,12 @@ public BuildManager(string hostName)
         private enum BuildManagerState
         {
             /// <summary>
-            /// This is the default state.  <see cref="BuildManager.BeginBuild"/> may be called in this state.  All other methods raise InvalidOperationException
+            /// This is the default state.  <see cref="BeginBuild(BuildParameters)"/> may be called in this state.  All other methods raise InvalidOperationException
             /// </summary>
             Idle,
 
             /// <summary>
-            /// This is the state the BuildManager is in after <see cref="BuildManager.BeginBuild"/> has been called but before <see cref="BuildManager.EndBuild"/> has been called.
+            /// This is the state the BuildManager is in after <see cref="BeginBuild(BuildParameters)"/> has been called but before <see cref="EndBuild"/> has been called.
             /// <see cref="BuildManager.PendBuildRequest(Microsoft.Build.Execution.BuildRequestData)"/>, <see cref="BuildManager.BuildRequest(Microsoft.Build.Execution.BuildRequestData)"/>, <see cref="BuildManager.PendBuildRequest(GraphBuildRequestData)"/>, <see cref="BuildManager.BuildRequest(GraphBuildRequestData)"/>, and <see cref="BuildManager.EndBuild"/> may be called in this state.
             /// </summary>
             Building,
@@ -358,6 +360,36 @@ public static BuildManager DefaultBuildManager
         /// </summary>
         LegacyThreadingData IBuildComponentHost.LegacyThreadingData => _legacyThreadingData;
 
+        /// <summary>
+        /// <see cref="BuildManager.BeginBuild(BuildParameters,IEnumerable{DeferredBuildMessage})"/>
+        /// </summary>
+        public readonly struct DeferredBuildMessage
+        {
+            public MessageImportance Importance { get; }
+
+            public string Text { get; }
+
+            public DeferredBuildMessage(string text, MessageImportance importance)
+            {
+                Importance = importance;
+                Text = text;
+            }
+        }
+
+        /// <summary>
+        /// Prepares the BuildManager to receive build requests.
+        /// </summary>
+        /// <param name="parameters">The build parameters.  May be null.</param>
+        /// <param name="deferredBuildMessages"> Build messages to be logged before the build begins. </param>
+        /// <exception cref="InvalidOperationException">Thrown if a build is already in progress.</exception>
+        public void BeginBuild(BuildParameters parameters, IEnumerable<DeferredBuildMessage> deferredBuildMessages)
+        {
+            // deferredBuildMessages cannot be an optional parameter on a single BeginBuild method because it would break binary compatibility.
+            _deferredBuildMessages = deferredBuildMessages;
+            BeginBuild(parameters);
+            _deferredBuildMessages = null;
+        }
+
         /// <summary>
         /// Prepares the BuildManager to receive build requests.
         /// </summary>
@@ -400,6 +432,8 @@ public void BeginBuild(BuildParameters parameters)
 
                 var loggingService = InitializeLoggingService();
 
+                LogDeferredMessages(loggingService, _deferredBuildMessages);
+
                 InitializeCaches();
 
                 _taskHostNodeManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.TaskHostNodeManager) as INodeManager;
@@ -2301,6 +2335,19 @@ private ILoggingService CreateLoggingService(IEnumerable<ILogger> loggers, IEnum
             return loggingService;
         }
 
+        private static void LogDeferredMessages(ILoggingService loggingService, IEnumerable<DeferredBuildMessage> deferredBuildMessages)
+        {
+            if (deferredBuildMessages == null)
+            {
+                return;
+            }
+
+            foreach (var message in deferredBuildMessages)
+            {
+                loggingService.LogCommentFromText(BuildEventContext.Invalid, message.Importance, message.Text);
+            }
+        }
+
         /// <summary>
         /// Ensures that the packet type matches the expected type
         /// </summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 594333e16bf..8963ddba8c3 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -2,19 +2,16 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
-using System.Collections.Immutable;
 using System.Diagnostics.CodeAnalysis;
-using System.IO;
 using System.Linq;
 using System.Reflection;
 using System.Runtime.ExceptionServices;
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -319,7 +316,7 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
                 // Only create a hash table if there are more than one bucket as this is the only time a property can be overridden
                 if (buckets.Count > 1)
                 {
-                    lookupHash = lookupHash ?? new Dictionary<string, string>(MSBuildNameIgnoreCaseComparer.Default);
+                    lookupHash ??= new Dictionary<string, string>(MSBuildNameIgnoreCaseComparer.Default);
                 }
 
                 WorkUnitResult aggregateResult = new WorkUnitResult();
@@ -327,6 +324,12 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
                 // Loop through each of the batch buckets and execute them one at a time
                 for (int i = 0; i < buckets.Count; i++)
                 {
+                    // Some tests do not provide an actual taskNode; checking if _taskNode == null prevents those tests from failing.
+                    if (MSBuildEventSource.Log.IsEnabled())
+                    {
+                        TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance);
+                        MSBuildEventSource.Log.ExecuteTaskStart(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
+                    }
                     // Execute the batch bucket, pass in which bucket we are executing so that we know when to get a new taskId for the bucket.
                     taskResult = await ExecuteBucket(taskHost, (ItemBucket)buckets[i], mode, lookupHash);
 
@@ -336,8 +339,14 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
                     {
                         break;
                     }
+                    // Some tests do not provide an actual taskNode; checking if _taskNode == null prevents those tests from failing.
+                    if (MSBuildEventSource.Log.IsEnabled())
+                    {
+                        TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance);
+                        MSBuildEventSource.Log.ExecuteTaskStop(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
+                    }
                 }
-
+                
                 taskResult = aggregateResult;
             }
             finally
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 2f57426067b..dfb430410b4 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -22,6 +22,7 @@
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd.Components.Caching;
 using System.Reflection;
+using Microsoft.Build.Eventing;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -345,6 +346,7 @@ public void Yield()
                 IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;
                 ErrorUtilities.VerifyThrow(_yieldThreadId == -1, "Cannot call Yield() while yielding.");
                 _yieldThreadId = Thread.CurrentThread.ManagedThreadId;
+                MSBuildEventSource.Log.ExecuteTaskYieldStart(_taskLoggingContext.TaskName, _taskLoggingContext.BuildEventContext.TaskId);
                 builderCallback.Yield();
             }
         }
@@ -361,7 +363,10 @@ public void Reacquire()
                 IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;
                 ErrorUtilities.VerifyThrow(_yieldThreadId != -1, "Cannot call Reacquire() before Yield().");
                 ErrorUtilities.VerifyThrow(_yieldThreadId == Thread.CurrentThread.ManagedThreadId, "Cannot call Reacquire() on thread {0} when Yield() was called on thread {1}", Thread.CurrentThread.ManagedThreadId, _yieldThreadId);
+                MSBuildEventSource.Log.ExecuteTaskYieldStop(_taskLoggingContext.TaskName, _taskLoggingContext.BuildEventContext.TaskId);
+                MSBuildEventSource.Log.ExecuteTaskReacquireStart(_taskLoggingContext.TaskName, _taskLoggingContext.BuildEventContext.TaskId);
                 builderCallback.Reacquire();
+                MSBuildEventSource.Log.ExecuteTaskReacquireStop(_taskLoggingContext.TaskName, _taskLoggingContext.BuildEventContext.TaskId);
                 _yieldThreadId = -1;
             }
         }
diff --git a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
index c4457ffd3ed..096ea1c4d84 100644
--- a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
@@ -186,6 +186,8 @@ private void RequestHandlerPumpProc()
         {
             try
             {
+                Thread.CurrentThread.Name = "MSBuild SDK Resolver";
+
                 while (true)
                 {
                     WaitHandle[] handles = new WaitHandle[] { ShutdownEvent, _requestReceivedEvent };
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index d1052638ac6..287b965ab35 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -130,7 +130,7 @@ public class ProjectRootElement : ProjectElementContainer
         /// This can be used to see whether the file has been changed on disk
         /// by an external means.
         /// </summary>
-        private DateTime _lastWriteTimeWhenRead;
+        private DateTime _lastWriteTimeWhenReadUtc;
 
         /// <summary>
         /// Reason it was last marked dirty; unlocalized, for debugging
@@ -617,7 +617,9 @@ public int Version
         /// This can be used to see whether the file has been changed on disk
         /// by an external means.
         /// </summary>
-        public DateTime LastWriteTimeWhenRead => Link != null ? RootLink.LastWriteTimeWhenRead : _lastWriteTimeWhenRead;
+        public DateTime LastWriteTimeWhenRead => Link != null ? RootLink.LastWriteTimeWhenRead : _lastWriteTimeWhenReadUtc.ToLocalTime();
+
+        internal DateTime? StreamTimeUtc = null;
 
         /// <summary>
         /// This does not allow conditions, so it should not be called.
@@ -1530,7 +1532,11 @@ public void Save(Encoding saveEncoding)
                 // come from disk.
                 if (fileInfo != null)
                 {
-                    _lastWriteTimeWhenRead = fileInfo.LastWriteTime;
+                    _lastWriteTimeWhenReadUtc = fileInfo.LastWriteTimeUtc;
+                    if (_lastWriteTimeWhenReadUtc > StreamTimeUtc)
+                    {
+                        StreamTimeUtc = null;
+                    }
                 }
 
                 _versionOnDisk = Version;
@@ -1584,6 +1590,7 @@ public void Save(TextWriter writer)
                 XmlDocument.Save(projectWriter);
             }
 
+            StreamTimeUtc = DateTime.UtcNow;
             _versionOnDisk = Version;
         }
 
@@ -2054,7 +2061,11 @@ private XmlDocumentWithLocation LoadDocument(string fullPath, bool preserveForma
                     XmlDocument.FullPath = fullPath;
                 }
 
-                _lastWriteTimeWhenRead = FileUtilities.GetFileInfoNoThrow(fullPath).LastWriteTime;
+                _lastWriteTimeWhenReadUtc = FileUtilities.GetFileInfoNoThrow(fullPath).LastWriteTimeUtc;
+                if (StreamTimeUtc < _lastWriteTimeWhenReadUtc)
+                {
+                    StreamTimeUtc = null;
+                }
             }
             catch (Exception ex)
             {
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 3ca66711e41..e080ba53491 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -75,6 +75,7 @@ public sealed class SolutionFile
         private const string cpsProjectGuid = "{13B669BE-BB05-4DDF-9536-439F39A36129}";
         private const string cpsCsProjectGuid = "{9A19103F-16F7-4668-BE54-9A1E7A4F7556}";
         private const string cpsVbProjectGuid = "{778DAE3C-4631-46EA-AA77-85C1314464D9}";
+        private const string cpsFsProjectGuid = "{6EC3EE1D-3C4E-46DD-8F32-0CC8E7565705}";
         private const string vjProjectGuid = "{E6FDF86B-F3D1-11D4-8576-0002A516ECE8}";
         private const string vcProjectGuid = "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}";
         private const string fsProjectGuid = "{F2A71F9B-5D33-465A-A702-920D77279786}";
@@ -1200,6 +1201,7 @@ ProjectInSolution proj
                 (String.Compare(projectTypeGuid, cpsProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
                 (String.Compare(projectTypeGuid, cpsCsProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
                 (String.Compare(projectTypeGuid, cpsVbProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
+                (String.Compare(projectTypeGuid, cpsFsProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
                 (String.Compare(projectTypeGuid, fsProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
                 (String.Compare(projectTypeGuid, dbProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
                 (String.Compare(projectTypeGuid, vjProjectGuid, StringComparison.OrdinalIgnoreCase) == 0))
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index d6c4b0c447a..3c27218071b 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -172,6 +172,11 @@ internal class Evaluator<P, I, M, D>
         /// </summary>
         private ProjectRootElement _lastModifiedProject;
 
+        /// <summary>
+        /// Keeps track of the FullPaths of ProjectRootElements that may have been modified as a stream.
+        /// </summary>
+        private List<string> _streamImports;
+
         private readonly bool _interactive;
 
         /// <summary>
@@ -231,6 +236,9 @@ private Evaluator(
             {
                 _lastModifiedProject = projectRootElement;
             }
+            _streamImports = new List<string>();
+            // When the imports are concatenated with a semicolon, this automatically prepends a semicolon if and only if another element is later added.
+            _streamImports.Add(string.Empty);
         }
 
         /// <summary>
@@ -1819,7 +1827,6 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
             bool atleastOneImportIgnored = false;
             bool atleastOneImportEmpty = false;
             imports = new List<ProjectRootElement>();
-
             foreach (string importExpressionEscapedItem in ExpressionShredder.SplitSemiColonSeparatedList(importExpressionEscaped))
             {
                 string[] importFilesEscaped = null;
@@ -1988,6 +1995,12 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
                                 _lastModifiedProject = importedProjectElement;
                             }
 
+                            if (importedProjectElement.StreamTimeUtc?.ToLocalTime() > _lastModifiedProject.LastWriteTimeWhenRead)
+                            {
+                                _streamImports.Add(importedProjectElement.FullPath);
+                                importedProjectElement.StreamTimeUtc = null;
+                            }
+
                             if (_logProjectImportedEvents)
                             {
                                 ProjectImportedEventArgs eventArgs = new ProjectImportedEventArgs(
@@ -2113,7 +2126,7 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
                     // can store the unescaped value. The only purpose of escaping is to 
                     // avoid undesired splitting or expansion.
                     _importsSeen.Add(importFileUnescaped, importElement);
-                } 
+                }
             }
 
             if (imports.Count > 0)
@@ -2367,12 +2380,12 @@ private void SetAllProjectsProperty()
             if (_lastModifiedProject != null)
             {
                 P oldValue = _data.GetProperty(Constants.MSBuildAllProjectsPropertyName);
-
+                string streamImports = string.Join(";", _streamImports.ToArray());
                 P newValue = _data.SetProperty(
                     Constants.MSBuildAllProjectsPropertyName,
                     oldValue == null
-                        ? _lastModifiedProject.FullPath
-                        : $"{_lastModifiedProject.FullPath};{oldValue.EvaluatedValue}",
+                        ? $"{_lastModifiedProject.FullPath}{streamImports}"
+                        : $"{_lastModifiedProject.FullPath}{streamImports};{oldValue.EvaluatedValue}",
                     isGlobalProperty: false,
                     mayBeReserved: false);
 
diff --git a/src/Deprecated/Engine/Shared/NativeMethodsShared.cs b/src/Deprecated/Engine/Shared/NativeMethodsShared.cs
index b5d466ec8ff..8493287c32b 100644
--- a/src/Deprecated/Engine/Shared/NativeMethodsShared.cs
+++ b/src/Deprecated/Engine/Shared/NativeMethodsShared.cs
@@ -101,7 +101,7 @@ internal static string FindOnPath(string filename)
 
         /// <summary>
         /// Gets the current OEM code page which is used by console apps 
-        /// (as opposed to the Windows/ANSI code page used by the normal people)
+        /// (as opposed to the Windows/ANSI code page)
         /// Basically for each ANSI code page (set in Regional settings) there's a corresponding OEM code page 
         /// that needs to be used for instance when writing to batch files
         /// </summary>
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index ee2c9a0465b..0942bfb3cdb 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -1,5 +1,7 @@
-﻿using System.Collections.Generic;
+﻿using System;
 using System.Diagnostics.Tracing;
+using System.Runtime.InteropServices;
+using System.Threading;
 
 namespace Microsoft.Build.Eventing
 {
@@ -361,6 +363,41 @@ public void MSBuildExeStop(string commandLine)
             WriteEvent(46, commandLine);
         }
 
+        [Event(47)]
+        public void ExecuteTaskStart(string taskName, int taskID)
+        {
+            WriteEvent(47, taskName, taskID);
+        }
+
+        [Event(48)]
+        public void ExecuteTaskStop(string taskName, int taskID)
+        {
+            WriteEvent(48, taskName, taskID);
+        }
+
+        [Event(49)]
+        public void ExecuteTaskYieldStart(string taskName, int taskID)
+        {
+            WriteEvent(49, taskName, taskID);
+        }
+
+        [Event(50)]
+        public void ExecuteTaskYieldStop(string taskName, int taskID)
+        {
+            WriteEvent(50, taskName, taskID);
+        }
+
+        [Event(51)]
+        public void ExecuteTaskReacquireStart(string taskName, int taskID)
+        {
+            WriteEvent(51, taskName, taskID);
+        }
+
+        [Event(52)]
+        public void ExecuteTaskReacquireStop(string taskName, int taskID)
+        {
+            WriteEvent(52, taskName, taskID);
+        }
         #endregion
     }
 }
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 6ffb8fd6f9d..973855eb618 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -36,7 +36,7 @@
     <NoPackageAnalysis>true</NoPackageAnalysis>
     <AddAppConfigToBuildOutputs>false</AddAppConfigToBuildOutputs>
 
-    <DebugType Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">full</DebugType><!-- Work around arcade stomping on symbols for same-program-different-arches. -->
+    <DebugType Condition="'$(Platform)' == 'x64'">full</DebugType><!-- Setting DebugType here goes hand in hand with eng\AfterSigning.targets. This is to prompt the x64 build to produce a 'full' .pdb that's `more compatible` then 'portable' and 'embedded' .pdbs. This doesn't get set on 32 bit architecture, which will default to 'embedded' and 'pdb2pdb' will convert those as needed. See https://github.com/microsoft/msbuild/pull/5070 for context. -->
   </PropertyGroup>
 
   <PropertyGroup>
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 56e147e274f..69cbcd118b2 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -787,7 +787,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </comment>
   </data>
-  <data name="HelpMessage_37_TargetsSwitch" Visibility="Public">
+  <data name="HelpMessage_37_DocsLink" Visibility="Public">
+    <value>For more detailed information, see https://aka.ms/msbuild/docs</value>
+  </data>
+  <data name="HelpMessage_38_TargetsSwitch" Visibility="Public">
     <value>  -targets[:file]
                      Prints a list of available targets without executing the
                      actual build process. By default the output is written to
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index fd5167f363c..187bec992eb 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -173,7 +173,12 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
-      <trans-unit id="HelpMessage_37_TargetsSwitch">
+      <trans-unit id="HelpMessage_37_DocsLink">
+        <source>For more detailed information, see https://aka.ms/msbuild/docs</source>
+        <target state="new">For more detailed information, see https://aka.ms/msbuild/docs</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="HelpMessage_38_TargetsSwitch">
         <source>  -targets[:file]
                      Prints a list of available targets without executing the
                      actual build process. By default the output is written to
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index d9be5d97971..33a04bfe27c 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -173,7 +173,12 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
-      <trans-unit id="HelpMessage_37_TargetsSwitch">
+      <trans-unit id="HelpMessage_37_DocsLink">
+        <source>For more detailed information, see https://aka.ms/msbuild/docs</source>
+        <target state="new">For more detailed information, see https://aka.ms/msbuild/docs</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="HelpMessage_38_TargetsSwitch">
         <source>  -targets[:file]
                      Prints a list of available targets without executing the
                      actual build process. By default the output is written to
diff --git a/src/MSBuild/Resources/xlf/Strings.en.xlf b/src/MSBuild/Resources/xlf/Strings.en.xlf
index 44bf57741f8..54831323f57 100644
--- a/src/MSBuild/Resources/xlf/Strings.en.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.en.xlf
@@ -183,7 +183,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
-      <trans-unit id="HelpMessage_37_TargetsSwitch">
+      <trans-unit id="HelpMessage_37_DocsLink">
+        <source>For more detailed information, see https://aka.ms/msbuild/docs</source>
+        <target state="new">For more detailed information, see https://aka.ms/msbuild/docs</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="HelpMessage_38_TargetsSwitch">
         <source>  -targets[:file]
                      Prints a list of available targets without executing the
                      actual build process. By default the output is written to
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 460eaaaf06b..8ceb302dd0e 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -173,7 +173,12 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
-      <trans-unit id="HelpMessage_37_TargetsSwitch">
+      <trans-unit id="HelpMessage_37_DocsLink">
+        <source>For more detailed information, see https://aka.ms/msbuild/docs</source>
+        <target state="new">For more detailed information, see https://aka.ms/msbuild/docs</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="HelpMessage_38_TargetsSwitch">
         <source>  -targets[:file]
                      Prints a list of available targets without executing the
                      actual build process. By default the output is written to
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index f92afe930d0..90bcbfb3912 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -173,7 +173,12 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
-      <trans-unit id="HelpMessage_37_TargetsSwitch">
+      <trans-unit id="HelpMessage_37_DocsLink">
+        <source>For more detailed information, see https://aka.ms/msbuild/docs</source>
+        <target state="new">For more detailed information, see https://aka.ms/msbuild/docs</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="HelpMessage_38_TargetsSwitch">
         <source>  -targets[:file]
                      Prints a list of available targets without executing the
                      actual build process. By default the output is written to
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 1f61c378ae5..842f9f7358f 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -180,7 +180,12 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
-      <trans-unit id="HelpMessage_37_TargetsSwitch">
+      <trans-unit id="HelpMessage_37_DocsLink">
+        <source>For more detailed information, see https://aka.ms/msbuild/docs</source>
+        <target state="new">For more detailed information, see https://aka.ms/msbuild/docs</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="HelpMessage_38_TargetsSwitch">
         <source>  -targets[:file]
                      Prints a list of available targets without executing the
                      actual build process. By default the output is written to
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index e0011239c1b..dded98303db 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -173,7 +173,12 @@ Copyright (C) Microsoft Corporation.All rights reserved.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
-      <trans-unit id="HelpMessage_37_TargetsSwitch">
+      <trans-unit id="HelpMessage_37_DocsLink">
+        <source>For more detailed information, see https://aka.ms/msbuild/docs</source>
+        <target state="new">For more detailed information, see https://aka.ms/msbuild/docs</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="HelpMessage_38_TargetsSwitch">
         <source>  -targets[:file]
                      Prints a list of available targets without executing the
                      actual build process. By default the output is written to
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 83f84776265..f7c9e9d83c5 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -173,7 +173,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
-      <trans-unit id="HelpMessage_37_TargetsSwitch">
+      <trans-unit id="HelpMessage_37_DocsLink">
+        <source>For more detailed information, see https://aka.ms/msbuild/docs</source>
+        <target state="new">For more detailed information, see https://aka.ms/msbuild/docs</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="HelpMessage_38_TargetsSwitch">
         <source>  -targets[:file]
                      Prints a list of available targets without executing the
                      actual build process. By default the output is written to
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index ea179d5db4d..b42f354646d 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -180,7 +180,12 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
-      <trans-unit id="HelpMessage_37_TargetsSwitch">
+      <trans-unit id="HelpMessage_37_DocsLink">
+        <source>For more detailed information, see https://aka.ms/msbuild/docs</source>
+        <target state="new">For more detailed information, see https://aka.ms/msbuild/docs</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="HelpMessage_38_TargetsSwitch">
         <source>  -targets[:file]
                      Prints a list of available targets without executing the
                      actual build process. By default the output is written to
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 69fefac16d2..d62dccfaf1e 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -174,7 +174,12 @@ isoladamente.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
-      <trans-unit id="HelpMessage_37_TargetsSwitch">
+      <trans-unit id="HelpMessage_37_DocsLink">
+        <source>For more detailed information, see https://aka.ms/msbuild/docs</source>
+        <target state="new">For more detailed information, see https://aka.ms/msbuild/docs</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="HelpMessage_38_TargetsSwitch">
         <source>  -targets[:file]
                      Prints a list of available targets without executing the
                      actual build process. By default the output is written to
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index bb45e9181b8..7208572366e 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -172,7 +172,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
-      <trans-unit id="HelpMessage_37_TargetsSwitch">
+      <trans-unit id="HelpMessage_37_DocsLink">
+        <source>For more detailed information, see https://aka.ms/msbuild/docs</source>
+        <target state="new">For more detailed information, see https://aka.ms/msbuild/docs</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="HelpMessage_38_TargetsSwitch">
         <source>  -targets[:file]
                      Prints a list of available targets without executing the
                      actual build process. By default the output is written to
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 0b99ac73128..534daca3b7a 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -173,7 +173,12 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
-      <trans-unit id="HelpMessage_37_TargetsSwitch">
+      <trans-unit id="HelpMessage_37_DocsLink">
+        <source>For more detailed information, see https://aka.ms/msbuild/docs</source>
+        <target state="new">For more detailed information, see https://aka.ms/msbuild/docs</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="HelpMessage_38_TargetsSwitch">
         <source>  -targets[:file]
                      Prints a list of available targets without executing the
                      actual build process. By default the output is written to
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index b5267300e6e..066dc627c2b 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -173,7 +173,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
-      <trans-unit id="HelpMessage_37_TargetsSwitch">
+      <trans-unit id="HelpMessage_37_DocsLink">
+        <source>For more detailed information, see https://aka.ms/msbuild/docs</source>
+        <target state="new">For more detailed information, see https://aka.ms/msbuild/docs</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="HelpMessage_38_TargetsSwitch">
         <source>  -targets[:file]
                      Prints a list of available targets without executing the
                      actual build process. By default the output is written to
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 45b0a2ffd93..d4905ca2b9b 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -173,7 +173,12 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
-      <trans-unit id="HelpMessage_37_TargetsSwitch">
+      <trans-unit id="HelpMessage_37_DocsLink">
+        <source>For more detailed information, see https://aka.ms/msbuild/docs</source>
+        <target state="new">For more detailed information, see https://aka.ms/msbuild/docs</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="HelpMessage_38_TargetsSwitch">
         <source>  -targets[:file]
                      Prints a list of available targets without executing the
                      actual build process. By default the output is written to
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 906046bcc86..a49582ca16c 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -3721,7 +3721,7 @@ private static void ShowHelpMessage()
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_24_NodeReuse"));
 #endif
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_25_PreprocessSwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_37_TargetsSwitch"));
+            Console.WriteLine(AssemblyResources.GetString("HelpMessage_38_TargetsSwitch"));
 
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_26_DetailedSummarySwitch"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_31_RestoreSwitch"));
@@ -3738,6 +3738,7 @@ private static void ShowHelpMessage()
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_6_VersionSwitch"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_4_HelpSwitch"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_16_Examples"));
+            Console.WriteLine(AssemblyResources.GetString("HelpMessage_37_DocsLink"));
         }
 
         /// <summary>
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 117a5582398..693cc3049e2 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -9,6 +9,16 @@ vs.dependencies
   vs.dependency id=Microsoft.VisualStudio.PackageGroup.NuGet
                 version=[15.0,17.0)
 
+vs.relatedProcessFiles
+  vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\Microsoft.Build.dll"
+  vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\Microsoft.Build.Framework.dll"
+  vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\Microsoft.Build.Tasks.Core.dll"
+  vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\Microsoft.Build.Utilities.Core.dll"
+  vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\amd64\Microsoft.Build.dll"
+  vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\amd64\Microsoft.Build.Framework.dll"
+  vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\amd64\Microsoft.Build.Tasks.Core.dll"
+  vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\amd64\Microsoft.Build.Utilities.Core.dll"
+
 folder InstallDir:\MSBuild\Current
   file source=$(X86BinPath)Microsoft.Common.props
   file source=$(X86BinPath)Microsoft.VisualStudioVersion.v16.Common.props
diff --git a/src/Shared/CoreCLRAssemblyLoader.cs b/src/Shared/CoreCLRAssemblyLoader.cs
index 25b5f21ee6e..14cd04a244d 100644
--- a/src/Shared/CoreCLRAssemblyLoader.cs
+++ b/src/Shared/CoreCLRAssemblyLoader.cs
@@ -1,10 +1,13 @@
 ﻿// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.
 
+using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.Utilities;
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
 using System.Reflection;
+using System.Runtime.Loader;
 
 namespace Microsoft.Build.Shared
 {
@@ -14,8 +17,26 @@ namespace Microsoft.Build.Shared
     internal sealed class CoreClrAssemblyLoader
     {
         private readonly Dictionary<string, Assembly> _pathsToAssemblies = new Dictionary<string, Assembly>(StringComparer.OrdinalIgnoreCase);
+        private readonly Dictionary<string, Assembly> _namesToAssemblies = new Dictionary<string, Assembly>();
+        private readonly HashSet<string> _dependencyPaths = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
         private readonly object _guard = new object();
 
+        private bool _resolvingHandlerHookedUp = false;
+
+        private static readonly Version _currentAssemblyVersion = new Version(Microsoft.Build.Shared.MSBuildConstants.CurrentAssemblyVersion);
+
+        public void AddDependencyLocation(string fullPath)
+        {
+            if (fullPath == null)
+            {
+                throw new ArgumentNullException(nameof(fullPath));
+            }
+
+            lock (_guard)
+            {
+                _dependencyPaths.Add(fullPath);
+            }
+        }
 
         public Assembly LoadFromPath(string fullPath)
         {
@@ -26,6 +47,43 @@ public Assembly LoadFromPath(string fullPath)
 
             Debug.Assert(Path.IsPathRooted(fullPath));
 
+            // Normalize because the same assembly might get loaded via
+            // multiple paths (for instance, the `build` and `buildCrossTargeting`
+            // folders in a NuGet package).
+            fullPath = FileUtilities.NormalizePath(fullPath);
+
+            if (Traits.Instance.EscapeHatches.UseSingleLoadContext)
+            {
+                return LoadUsingLegacyDefaultContext(fullPath);
+            }
+            else
+            {
+                return LoadUsingPluginContext(fullPath);
+            }
+        }
+
+        private Assembly LoadUsingLegacyDefaultContext(string fullPath)
+        {
+            lock (_guard)
+            {
+                if (!_resolvingHandlerHookedUp)
+                {
+                    AssemblyLoadContext.Default.Resolving += TryResolveAssembly;
+                    _resolvingHandlerHookedUp = true;
+                }
+
+                Assembly assembly;
+                if (_pathsToAssemblies.TryGetValue(fullPath, out assembly))
+                {
+                    return assembly;
+                }
+
+                return LoadAndCache(AssemblyLoadContext.Default, fullPath);
+            }
+        }
+
+        private Assembly LoadUsingPluginContext(string fullPath)
+        {
             lock (_guard)
             {
                 Assembly assembly;
@@ -46,5 +104,98 @@ public Assembly LoadFromPath(string fullPath)
                 return assembly;
             }
         }
+
+        private Assembly TryGetWellKnownAssembly(AssemblyLoadContext context, AssemblyName assemblyName)
+        {
+            if (!MSBuildLoadContext.WellKnownAssemblyNames.Contains(assemblyName.Name))
+            {
+                return null;
+            }
+
+            // Ensure we are attempting to load a matching version
+            // of the Microsoft.Build.* assembly.
+            assemblyName.Version = _currentAssemblyVersion;
+
+            var searchPaths = new[] { Assembly.GetExecutingAssembly().Location };
+            return TryResolveAssemblyFromPaths(context, assemblyName, searchPaths);
+        }
+
+        private Assembly TryResolveAssembly(AssemblyLoadContext context, AssemblyName assemblyName)
+        {
+            lock (_guard)
+            {
+                Assembly assembly = TryGetWellKnownAssembly(context, assemblyName);
+
+                if (assembly != null)
+                {
+                    return assembly;
+                }
+
+                if (_namesToAssemblies.TryGetValue(assemblyName.FullName, out assembly))
+                {
+                    return assembly;
+                }
+
+                return TryResolveAssemblyFromPaths(context, assemblyName, _dependencyPaths);
+            }
+        }
+
+        private Assembly TryResolveAssemblyFromPaths(AssemblyLoadContext context, AssemblyName assemblyName, IEnumerable<string> searchPaths)
+        {
+            foreach (var cultureSubfolder in string.IsNullOrEmpty(assemblyName.CultureName)
+                // If no culture is specified, attempt to load directly from
+                // the known dependency paths.
+                ? new[] { string.Empty }
+                // Search for satellite assemblies in culture subdirectories
+                // of the assembly search directories, but fall back to the
+                // bare search directory if that fails.
+                : new[] { assemblyName.CultureName, string.Empty })
+            {
+                foreach (var searchPath in searchPaths)
+                {
+                    foreach (var extension in MSBuildLoadContext.Extensions)
+                    {
+                        var candidatePath = Path.Combine(searchPath,
+                            cultureSubfolder,
+                            $"{assemblyName.Name}.{extension}");
+
+                        if (IsAssemblyAlreadyLoaded(candidatePath) ||
+                            !FileSystems.Default.FileExists(candidatePath))
+                        {
+                            continue;
+                        }
+
+                        AssemblyName candidateAssemblyName = AssemblyLoadContext.GetAssemblyName(candidatePath);
+                        if (candidateAssemblyName.Version != assemblyName.Version)
+                        {
+                            continue;
+                        }
+
+                        return LoadAndCache(context, candidatePath);
+                    }
+                }
+            }
+
+            return null;
+        }
+
+        /// <remarks>
+        /// Assumes we have a lock on _guard
+        /// </remarks>
+        private Assembly LoadAndCache(AssemblyLoadContext context, string fullPath)
+        {
+            var assembly = context.LoadFromAssemblyPath(fullPath);
+            var name = assembly.FullName;
+
+            _pathsToAssemblies[fullPath] = assembly;
+            _namesToAssemblies[name] = assembly;
+
+            return assembly;
+        }
+
+        private bool IsAssemblyAlreadyLoaded(string path)
+        {
+            return _pathsToAssemblies.ContainsKey(path);
+        }
     }
 }
diff --git a/src/Shared/EncodingUtilities.cs b/src/Shared/EncodingUtilities.cs
index e243f1846e1..1a74d635c1c 100644
--- a/src/Shared/EncodingUtilities.cs
+++ b/src/Shared/EncodingUtilities.cs
@@ -14,8 +14,15 @@ namespace Microsoft.Build.Shared
     /// </summary>
     internal static class EncodingUtilities
     {
+        internal static readonly Encoding Utf8WithoutBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
+
         private static Encoding s_currentOemEncoding;
 
+        internal const string UseUtf8Always = "ALWAYS";
+        internal const string UseUtf8Never = "NEVER";
+        internal const string UseUtf8Detect = "DETECT";
+        internal const string UseUtf8System = "SYSTEM";
+
         /// <summary>
         /// Get the current system locale code page, OEM version. OEM code pages are used for console-based input/output
         /// for historical reasons.
@@ -148,5 +155,92 @@ internal static bool FileStartsWithPreamble(string file)
                 return StartsWithPreamble(stream);
             }
         }
+
+        /// <summary>
+        /// Checks to see if a string can be encoded in a specified code page.
+        /// </summary>
+        /// <remarks>Internal for testing purposes.</remarks>
+        /// <param name="codePage">Code page for encoding.</param>
+        /// <param name="stringToEncode">String to encode.</param>
+        /// <returns>True if the string can be encoded in the specified code page.</returns>
+        internal static bool CanEncodeString(int codePage, string stringToEncode)
+        {
+            // We have a System.String that contains some characters. Get a lossless representation
+            // in byte-array form.
+            var unicodeEncoding = new UnicodeEncoding();
+            var unicodeBytes = unicodeEncoding.GetBytes(stringToEncode);
+
+            // Create an Encoding using the desired code page, but throws if there's a
+            // character that can't be represented.
+            var systemEncoding = Encoding.GetEncoding(codePage, EncoderFallback.ExceptionFallback,
+                DecoderFallback.ExceptionFallback);
+
+            try
+            {
+                var oemBytes = Encoding.Convert(unicodeEncoding, systemEncoding, unicodeBytes);
+
+                // If Convert didn't throw, we can represent everything in the desired encoding.
+                return true;
+            }
+            catch (EncoderFallbackException)
+            {
+                // If a fallback encoding was attempted, we need to go to Unicode.
+                return false;
+            }
+        }
+
+        /// <summary>
+        /// Find the encoding for the batch file.
+        /// </summary>
+        /// <remarks>
+        /// The "best" encoding is the current OEM encoding, unless it's not capable of representing
+        /// the characters we plan to put in the file. If it isn't, we can fall back to UTF-8.
+        ///
+        /// Why not always UTF-8? Because tools don't always handle it well. See
+        /// https://github.com/Microsoft/msbuild/issues/397
+        /// </remarks>
+        internal static Encoding BatchFileEncoding(string contents, string encodingSpecification)
+        {
+            if (!NativeMethodsShared.IsWindows)
+            {
+                return EncodingUtilities.Utf8WithoutBom;
+            }
+
+            var defaultEncoding = EncodingUtilities.CurrentSystemOemEncoding;
+
+            // When Windows is configured to use UTF-8 by default, the above returns
+            // a UTF-8-with-BOM encoding, which cmd.exe can't interpret. Force the no-BOM
+            // encoding if the returned encoding would have emitted one (preamble is nonempty).
+            // See https://github.com/Microsoft/msbuild/issues/4268
+            if (defaultEncoding is UTF8Encoding e && e.GetPreamble().Length > 0)
+            {
+                defaultEncoding = EncodingUtilities.Utf8WithoutBom;
+            }
+
+            string useUtf8 = string.IsNullOrEmpty(encodingSpecification) ? EncodingUtilities.UseUtf8Detect : encodingSpecification;
+
+#if FEATURE_OSVERSION
+            // UTF8 is only supported in Windows 7 (6.1) or greater.
+            var windows7 = new Version(6, 1);
+
+            if (Environment.OSVersion.Version < windows7)
+            {
+                useUtf8 = EncodingUtilities.UseUtf8Never;
+            }
+#endif
+
+            switch (useUtf8.ToUpperInvariant())
+            {
+                case EncodingUtilities.UseUtf8Always:
+                    return EncodingUtilities.Utf8WithoutBom;
+                case EncodingUtilities.UseUtf8Never:
+                case EncodingUtilities.UseUtf8System:
+                    return defaultEncoding;
+                default:
+                    return EncodingUtilities.CanEncodeString(defaultEncoding.CodePage, contents)
+                        ? defaultEncoding
+                        : EncodingUtilities.Utf8WithoutBom;
+            }
+        }
     }
 }
diff --git a/src/Shared/MSBuildLoadContext.cs b/src/Shared/MSBuildLoadContext.cs
index 1e5d15d03de..6840143985b 100644
--- a/src/Shared/MSBuildLoadContext.cs
+++ b/src/Shared/MSBuildLoadContext.cs
@@ -19,9 +19,8 @@ namespace Microsoft.Build.Shared
     internal class MSBuildLoadContext : AssemblyLoadContext
     {
         private readonly string _directory;
-        private readonly object _guard = new object();
 
-        private static readonly ImmutableHashSet<string> _wellKnownAssemblyNames =
+        internal static readonly ImmutableHashSet<string> WellKnownAssemblyNames =
             new[]
             {
                 "MSBuild",
@@ -31,7 +30,7 @@ internal class MSBuildLoadContext : AssemblyLoadContext
                 "Microsoft.Build.Utilities.Core",
             }.ToImmutableHashSet();
 
-        private static readonly string[] _extensions = new[] { "ni.dll", "ni.exe", "dll", "exe" };
+        internal static readonly string[] Extensions = new[] { "ni.dll", "ni.exe", "dll", "exe" };
 
 
         public MSBuildLoadContext(string assemblyPath)
@@ -41,7 +40,7 @@ public MSBuildLoadContext(string assemblyPath)
 
         protected override Assembly? Load(AssemblyName assemblyName)
         {
-            if (_wellKnownAssemblyNames.Contains(assemblyName.Name!))
+            if (WellKnownAssemblyNames.Contains(assemblyName.Name!))
             {
                 // Force MSBuild assemblies to be loaded in the default ALC
                 // and unify to the current version.
@@ -57,7 +56,7 @@ public MSBuildLoadContext(string assemblyPath)
                 // bare search directory if that fails.
                 : new[] { assemblyName.CultureName, string.Empty })
             {
-                foreach (var extension in _extensions)
+                foreach (var extension in Extensions)
                 {
                     var candidatePath = Path.Combine(_directory,
                         cultureSubfolder,
diff --git a/src/Shared/NativeMethodsShared.cs b/src/Shared/NativeMethodsShared.cs
index 15751561086..6bc94246966 100644
--- a/src/Shared/NativeMethodsShared.cs
+++ b/src/Shared/NativeMethodsShared.cs
@@ -1357,7 +1357,7 @@ internal static void VerifyThrowWin32Result(int result)
 
         /// <summary>
         /// Gets the current OEM code page which is used by console apps
-        /// (as opposed to the Windows/ANSI code page used by the normal people)
+        /// (as opposed to the Windows/ANSI code page)
         /// Basically for each ANSI code page (set in Regional settings) there's a corresponding OEM code page
         /// that needs to be used for instance when writing to batch files
         /// </summary>
diff --git a/src/Shared/Traits.cs b/src/Shared/Traits.cs
index 78fa8799911..0ab43e56198 100644
--- a/src/Shared/Traits.cs
+++ b/src/Shared/Traits.cs
@@ -196,11 +196,21 @@ public bool LogTaskInputs
         /// </summary>
         public readonly bool DisableNuGetSdkResolver = Environment.GetEnvironmentVariable("MSBUILDDISABLENUGETSDKRESOLVER") == "1";
 
+        /// <summary>
+        /// Disable AssemblyLoadContext isolation for plugins.
+        /// </summary>
+        public readonly bool UseSingleLoadContext = Environment.GetEnvironmentVariable("MSBUILDSINGLELOADCONTEXT") == "1";
+
         /// <summary>
         /// Enables the user of autorun functionality in CMD.exe on Windows which is disabled by default in MSBuild.
         /// </summary>
         public readonly bool UseAutoRunWhenLaunchingProcessUnderCmd = Environment.GetEnvironmentVariable("MSBUILDUSERAUTORUNINCMD") == "1";
 
+        /// <summary>
+        /// Disables switching codepage to UTF-8 after detection of characters that can't be represented in the current codepage.
+        /// </summary>
+        public readonly bool AvoidUnicodeWhenWritingToolTaskBatch = Environment.GetEnvironmentVariable("MSBUILDAVOIDUNICODE") == "1";
+
         /// <summary>
         /// Workaround for https://github.com/Microsoft/vstest/issues/1503.
         /// </summary>
diff --git a/src/Shared/TypeLoader.cs b/src/Shared/TypeLoader.cs
index 828b8320823..b88c90eefdd 100644
--- a/src/Shared/TypeLoader.cs
+++ b/src/Shared/TypeLoader.cs
@@ -163,6 +163,8 @@ private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)
 #if !FEATURE_ASSEMBLYLOADCONTEXT
                     loadedAssembly = Assembly.UnsafeLoadFrom(assemblyLoadInfo.AssemblyFile);
 #else
+                    var baseDir = Path.GetDirectoryName(assemblyLoadInfo.AssemblyFile);
+                    s_coreClrAssemblyLoader.AddDependencyLocation(baseDir);
                     loadedAssembly = s_coreClrAssemblyLoader.LoadFromPath(assemblyLoadInfo.AssemblyFile);
 #endif
                 }
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 23a74df090e..7bdbb14bdc3 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -1869,7 +1869,8 @@ public BuildManagerSession(
                 TestEnvironment env,
                 BuildParameters buildParametersPrototype = null,
                 bool enableNodeReuse = false,
-                bool shutdownInProcNode = true)
+                bool shutdownInProcNode = true,
+                IEnumerable<BuildManager.DeferredBuildMessage> deferredMessages = null)
             {
                 _env = env;
 
@@ -1886,7 +1887,7 @@ public BuildManagerSession(
                 actualBuildParameters.EnableNodeReuse = enableNodeReuse;
 
                 _buildManager = new BuildManager();
-                _buildManager.BeginBuild(actualBuildParameters);
+                _buildManager.BeginBuild(actualBuildParameters, deferredMessages);
             }
 
             public BuildResult BuildProjectFile(string projectFile, string[] entryTargets = null)
diff --git a/src/Tasks.UnitTests/AssignProjectConfiguration_Tests.cs b/src/Tasks.UnitTests/AssignProjectConfiguration_Tests.cs
index ca798cfc190..349ae0014ca 100644
--- a/src/Tasks.UnitTests/AssignProjectConfiguration_Tests.cs
+++ b/src/Tasks.UnitTests/AssignProjectConfiguration_Tests.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Tasks;
 using Xunit;
+using Xunit.Abstractions;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -20,6 +21,13 @@ namespace Microsoft.Build.UnitTests
     /// </summary>
     sealed public class AssignProjectConfiguration_Tests
     {
+        private readonly ITestOutputHelper _output;
+
+        public AssignProjectConfiguration_Tests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
         private void TestResolveHelper(string itemSpec, string projectGuid, string package, string name,
             Hashtable pregenConfigurations, bool expectedResult,
             string expectedFullConfiguration, string expectedConfiguration, string expectedPlatform)
@@ -257,7 +265,7 @@ private void TestUnresolvedReferencesHelper(ArrayList projectRefs, Hashtable pre
             // but they are ignored anyway, and the rest is identical
             string xmlString = ResolveNonMSBuildProjectOutput_Tests.CreatePregeneratedPathDoc(pregenConfigurations);
 
-            MockEngine engine = new MockEngine();
+            MockEngine engine = new MockEngine(_output);
             AssignProjectConfiguration rpc = new AssignProjectConfiguration();
             rpc.BuildEngine = engine;
             rpc.SolutionConfigurationContents = xmlString;
diff --git a/src/Tasks.UnitTests/DownloadFile_Tests.cs b/src/Tasks.UnitTests/DownloadFile_Tests.cs
index 3d9ce9fad11..2d19fa29462 100644
--- a/src/Tasks.UnitTests/DownloadFile_Tests.cs
+++ b/src/Tasks.UnitTests/DownloadFile_Tests.cs
@@ -245,6 +245,66 @@ public void RetryOnResponseError()
             _mockEngine.Log.ShouldContain("MSB3924", () => _mockEngine.Log);
         }
 
+        [Fact]
+        public void AbortOnTimeout()
+        {
+            CancellationTokenSource timeout = new CancellationTokenSource();
+            timeout.Cancel();
+            DownloadFile downloadFile = new DownloadFile()
+            {
+                BuildEngine = _mockEngine,
+                HttpMessageHandler = new MockHttpMessageHandler((message, token) =>
+                {
+                    // Http timeouts manifest as "OperationCanceledExceptions" from the handler, simulate that
+                    throw new OperationCanceledException(timeout.Token);
+                }),
+                Retries = 1,
+                RetryDelayMilliseconds = 100,
+                SourceUrl = "http://notfound/foo.txt"
+            };
+
+            downloadFile.Execute().ShouldBeFalse(() => _mockEngine.Log);
+
+            _mockEngine.Log.ShouldContain("MSB3923", () => _mockEngine.Log);
+        }
+
+        [Fact]
+        public async Task NoRunawayLoop()
+        {
+            DownloadFile downloadFile = null;
+            bool failed = false;
+            downloadFile = new DownloadFile()
+            {
+                BuildEngine = _mockEngine,
+                HttpMessageHandler = new MockHttpMessageHandler((message, token) =>
+                {
+                    token.ThrowIfCancellationRequested();
+                    downloadFile.Cancel();
+                    if (!failed)
+                    {
+                        failed = true;
+                        return new HttpResponseMessage(HttpStatusCode.InternalServerError);
+                    }
+
+                    return new HttpResponseMessage(HttpStatusCode.OK)
+                    {
+                        Content = new StringContent("Success!"),
+                        RequestMessage = new HttpRequestMessage(HttpMethod.Get, "http://success/foo.txt")
+                    };
+                }),
+                Retries = 2,
+                RetryDelayMilliseconds = 100,
+                SourceUrl = "http://notfound/foo.txt"
+            };
+
+            var runaway = Task.Run(() => downloadFile.Execute());
+            await Task.Delay(TimeSpan.FromSeconds(1));
+            runaway.IsCompleted.ShouldBeTrue("Task did not cancel");
+
+            var result = await runaway;
+            result.ShouldBeFalse(() => _mockEngine.Log);
+        }
+
         [Fact]
         public void SkipUnchangedFiles()
         {
diff --git a/src/Tasks.UnitTests/Exec_Tests.cs b/src/Tasks.UnitTests/Exec_Tests.cs
index 4d7c88b6b9e..1b8cbd86330 100644
--- a/src/Tasks.UnitTests/Exec_Tests.cs
+++ b/src/Tasks.UnitTests/Exec_Tests.cs
@@ -856,8 +856,8 @@ public void CanEncodeTest()
             string nonAnsiCharacters = "\u521B\u5EFA";
             string pathWithAnsiCharacters = @"c:\windows\system32\cmd.exe";
 
-            Assert.False(Exec.CanEncodeString(defaultEncoding.CodePage, nonAnsiCharacters));
-            Assert.True(Exec.CanEncodeString(defaultEncoding.CodePage, pathWithAnsiCharacters));
+            Assert.False(EncodingUtilities.CanEncodeString(defaultEncoding.CodePage, nonAnsiCharacters));
+            Assert.True(EncodingUtilities.CanEncodeString(defaultEncoding.CodePage, pathWithAnsiCharacters));
         }
 
         [Fact]
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index b61ff9e41de..a19d99dc303 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -124,7 +124,6 @@
     <Compile Remove="AssemblyDependency\VerifyTargetFrameworkHigherThanRedist.cs" />
     <Compile Remove="AssemblyDependency\WinMDTests.cs" />
     <Compile Remove="ResolveComReference_Tests.cs" />
-    <Compile Remove="ResolveNonMSBuildProjectOutput_Tests.cs" />
     <Compile Remove="ResolveSDKReference_Tests.cs" />
     <Compile Remove="SdkToolsPathUtility_Tests.cs" />
     <Compile Remove="SGen_Tests.cs" />
diff --git a/src/Tasks.UnitTests/RegressionTests.cs b/src/Tasks.UnitTests/RegressionTests.cs
index c6cf8aa1b29..f400cef6a24 100644
--- a/src/Tasks.UnitTests/RegressionTests.cs
+++ b/src/Tasks.UnitTests/RegressionTests.cs
@@ -1,7 +1,10 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
+using System.IO;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Xunit;
 using Xunit.Abstractions;
@@ -42,5 +45,34 @@ public void OverrideBaseIntermediateOutputPathSucceeds()
 
             Assert.True(result);
         }
+
+        /// <summary>
+        /// Tests fix for https://github.com/microsoft/msbuild/issues/1479.
+        /// </summary>
+        [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsWindows))]
+        public void AssemblyAttributesLocation()
+        {
+            var expectedCompileItems = "a.cs;" + Path.Combine("obj", "Debug", ".NETFramework,Version=v4.0.AssemblyAttributes.cs");
+
+            var project = ObjectModelHelpers.CreateInMemoryProject($@"
+<Project>
+  <Import Project=""$(MSBuildToolsPath)\Microsoft.Common.props"" />
+  <ItemGroup>
+    <Compile Include=""a.cs""/>       
+  </ItemGroup>
+  <Import Project=""$(MSBuildToolsPath)\Microsoft.CSharp.targets"" />
+
+  <Target Name=""CopyFilesToOutputDirectory""/>
+
+  <Target Name=""CoreCompile"">
+    <Error Text=""Expected '@(Compile)' == '{expectedCompileItems}'""
+           Condition=""'@(Compile)' != '{expectedCompileItems}'""/>
+  </Target>
+</Project>
+");
+            var logger = new MockLogger(_output);
+            bool result = project.Build(logger);
+            Assert.True(result, "Output:" + Environment.NewLine + logger.FullLog);
+        }
     }
 }
diff --git a/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs b/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
index 1bb80b79b09..5e3385a4c34 100644
--- a/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections;
+using System.IO;
 using System.Text;
 using System.Linq;
 using System.Xml;
@@ -10,6 +11,7 @@
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Tasks;
 using Xunit;
+using Xunit.Abstractions;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -17,6 +19,13 @@ sealed public class ResolveNonMSBuildProjectOutput_Tests
     {
         private const string attributeProject = "Project";
 
+        private readonly ITestOutputHelper _output;
+
+        public ResolveNonMSBuildProjectOutput_Tests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
         static internal ITaskItem CreateReferenceItem(string itemSpec, string projectGuid, string package, string name)
         {
             TaskItem reference = new TaskItem(itemSpec);
@@ -119,32 +128,32 @@ public void TestResolve()
 
             // non matching project in string
             projectOutputs = new Hashtable();
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111111}", @"obj\wrong.dll");
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111111}", Path.Combine("obj", "wrong.dll"));
             TestResolveHelper("MCDep1.vcproj", "{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}", "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}", "MCDep1",
                 projectOutputs, false, null);
 
             // matching project in string
             projectOutputs = new Hashtable();
-            projectOutputs.Add("{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}", @"obj\correct.dll");
+            projectOutputs.Add("{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}", Path.Combine("obj", "correct.dll"));
             TestResolveHelper("MCDep1.vcproj", "{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}", "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}", "MCDep1",
-                projectOutputs, true, @"obj\correct.dll");
+                projectOutputs, true, Path.Combine("obj", "correct.dll"));
 
             // multiple non matching projects in string
             projectOutputs = new Hashtable();
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111111}", @"obj\wrong.dll");
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111112}", @"obj\wrong2.dll");
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111113}", @"obj\wrong3.dll");
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111111}", Path.Combine("obj", "wrong.dll"));
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111112}", Path.Combine("obj", "wrong2.dll"));
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111113}", Path.Combine("obj", "wrong3.dll"));
             TestResolveHelper("MCDep1.vcproj", "{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}", "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}", "MCDep1",
                 projectOutputs, false, null);
 
             // multiple non matching projects in string, one matching
             projectOutputs = new Hashtable();
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111111}", @"obj\wrong.dll");
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111112}", @"obj\wrong2.dll");
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111113}", @"obj\wrong3.dll");
-            projectOutputs.Add("{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}", @"obj\correct.dll");
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111111}", Path.Combine("obj", "wrong.dll"));
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111112}", Path.Combine("obj", "wrong2.dll"));
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111113}", Path.Combine("obj", "wrong3.dll"));
+            projectOutputs.Add("{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}", Path.Combine("obj", "correct.dll"));
             TestResolveHelper("MCDep1.vcproj", "{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}", "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}", "MCDep1",
-                projectOutputs, true, @"obj\correct.dll");
+                projectOutputs, true, Path.Combine("obj", "correct.dll"));
         }
 
         private void TestUnresolvedReferencesHelper(ArrayList projectRefs, Hashtable pregenOutputs,
@@ -170,7 +179,7 @@ private void TestUnresolvedReferencesHelper(ArrayList projectRefs, Hashtable pre
 
             string xmlString = CreatePregeneratedPathDoc(pregenOutputs);
 
-            MockEngine engine = new MockEngine();
+            MockEngine engine = new MockEngine(_output);
             ResolveNonMSBuildProjectOutput rvpo = new ResolveNonMSBuildProjectOutput();
             rvpo.GetAssemblyName = pretendGetAssemblyName;
             rvpo.BuildEngine = engine;
@@ -209,16 +218,16 @@ public void TestManagedCheck()
 
             // 1. multiple project refs, none resolvable
             projectOutputs = new Hashtable();
-            projectOutputs.Add("{2F6BBCC3-7111-4116-A68B-000000000000}", @"obj\managed.dll");
-            projectOutputs.Add("{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}", @"obj\unmanaged.dll");
+            projectOutputs.Add("{2F6BBCC3-7111-4116-A68B-000000000000}", Path.Combine("obj", "managed.dll"));
+            projectOutputs.Add("{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}", Path.Combine("obj", "unmanaged.dll"));
 
-            TestUnresolvedReferencesHelper(projectRefs, projectOutputs, path => (path == @"obj\managed.dll"), out unresolvedOutputs, out resolvedOutputs);
+            TestUnresolvedReferencesHelper(projectRefs, projectOutputs, path => (path == Path.Combine("obj", "managed.dll")), out unresolvedOutputs, out resolvedOutputs);
 
             Assert.NotNull(resolvedOutputs);
-            Assert.True(resolvedOutputs.Contains(@"obj\managed.dll"));
-            Assert.True(resolvedOutputs.Contains(@"obj\unmanaged.dll"));
-            Assert.Equal("true", ((ITaskItem)resolvedOutputs[@"obj\managed.dll"]).GetMetadata("ManagedAssembly"));
-            Assert.NotEqual("true", ((ITaskItem)resolvedOutputs[@"obj\unmanaged.dll"]).GetMetadata("ManagedAssembly"));
+            Assert.True(resolvedOutputs.Contains(Path.Combine("obj", "managed.dll")));
+            Assert.True(resolvedOutputs.Contains(Path.Combine("obj", "unmanaged.dll")));
+            Assert.Equal("true", ((ITaskItem)resolvedOutputs[Path.Combine("obj", "managed.dll")]).GetMetadata("ManagedAssembly"));
+            Assert.NotEqual("true", ((ITaskItem)resolvedOutputs[Path.Combine("obj", "unmanaged.dll")]).GetMetadata("ManagedAssembly"));
         }
 
         /// <summary>
@@ -241,9 +250,9 @@ public void TestUnresolvedReferences()
 
             // 1. multiple project refs, none resolvable
             projectOutputs = new Hashtable();
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111111}", @"obj\wrong.dll");
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111112}", @"obj\wrong2.dll");
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111113}", @"obj\wrong3.dll");
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111111}", Path.Combine("obj", "wrong.dll"));
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111112}", Path.Combine("obj", "wrong2.dll"));
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111113}", Path.Combine("obj", "wrong3.dll"));
 
             TestUnresolvedReferencesHelper(projectRefs, projectOutputs, out unresolvedOutputs, out resolvedOutputs);
 
@@ -254,38 +263,38 @@ public void TestUnresolvedReferences()
 
             // 2. multiple project refs, one resolvable
             projectOutputs = new Hashtable();
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111111}", @"obj\wrong.dll");
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111112}", @"obj\wrong2.dll");
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111113}", @"obj\wrong3.dll");
-            projectOutputs.Add("{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}", @"obj\correct.dll");
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111111}", Path.Combine("obj", "wrong.dll"));
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111112}", Path.Combine("obj", "wrong2.dll"));
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111113}", Path.Combine("obj", "wrong3.dll"));
+            projectOutputs.Add("{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}", Path.Combine("obj", "correct.dll"));
 
             TestUnresolvedReferencesHelper(projectRefs, projectOutputs, out unresolvedOutputs, out resolvedOutputs);
 
             Assert.Single(resolvedOutputs); // "One resolved ref expected for case 2"
-            Assert.True(resolvedOutputs.ContainsKey(@"obj\correct.dll"));
+            Assert.True(resolvedOutputs.ContainsKey(Path.Combine("obj", "correct.dll")));
             Assert.Single(unresolvedOutputs); // "One unresolved ref expected for case 2"
             Assert.Equal(unresolvedOutputs["MCDep1.vcproj"], projectRefs[0]);
 
             // 3. multiple project refs, all resolvable
             projectOutputs = new Hashtable();
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111111}", @"obj\wrong.dll");
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111112}", @"obj\wrong2.dll");
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111113}", @"obj\wrong3.dll");
-            projectOutputs.Add("{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}", @"obj\correct.dll");
-            projectOutputs.Add("{2F6BBCC3-7111-4116-A68B-000000000000}", @"obj\correct2.dll");
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111111}", Path.Combine("obj", "wrong.dll"));
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111112}", Path.Combine("obj", "wrong2.dll"));
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111113}", Path.Combine("obj", "wrong3.dll"));
+            projectOutputs.Add("{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}", Path.Combine("obj", "correct.dll"));
+            projectOutputs.Add("{2F6BBCC3-7111-4116-A68B-000000000000}", Path.Combine("obj", "correct2.dll"));
 
             TestUnresolvedReferencesHelper(projectRefs, projectOutputs, out unresolvedOutputs, out resolvedOutputs);
 
             Assert.Equal(2, resolvedOutputs.Count); // "Two resolved refs expected for case 3"
-            Assert.True(resolvedOutputs.ContainsKey(@"obj\correct.dll"));
-            Assert.True(resolvedOutputs.ContainsKey(@"obj\correct2.dll"));
+            Assert.True(resolvedOutputs.ContainsKey(Path.Combine("obj", "correct.dll")));
+            Assert.True(resolvedOutputs.ContainsKey(Path.Combine("obj", "correct2.dll")));
             Assert.Empty(unresolvedOutputs); // "No unresolved refs expected for case 3"
 
             // 4. multiple project refs, all failed to resolve
             projectOutputs = new Hashtable();
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111111}", @"obj\wrong.dll");
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111112}", @"obj\wrong2.dll");
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111113}", @"obj\wrong3.dll");
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111111}", Path.Combine("obj", "wrong.dll"));
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111112}", Path.Combine("obj", "wrong2.dll"));
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111113}", Path.Combine("obj", "wrong3.dll"));
             projectOutputs.Add("{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}", @"");
             projectOutputs.Add("{2F6BBCC3-7111-4116-A68B-000000000000}", @"");
 
@@ -296,23 +305,23 @@ public void TestUnresolvedReferences()
 
             // 5. multiple project refs, one resolvable, one failed to resolve
             projectOutputs = new Hashtable();
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111111}", @"obj\wrong.dll");
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111112}", @"obj\wrong2.dll");
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111113}", @"obj\wrong3.dll");
-            projectOutputs.Add("{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}", @"obj\correct.dll");
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111111}", Path.Combine("obj", "wrong.dll"));
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111112}", Path.Combine("obj", "wrong2.dll"));
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111113}", Path.Combine("obj", "wrong3.dll"));
+            projectOutputs.Add("{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}", Path.Combine("obj", "correct.dll"));
             projectOutputs.Add("{2F6BBCC3-7111-4116-A68B-000000000000}", @"");
 
             TestUnresolvedReferencesHelper(projectRefs, projectOutputs, out unresolvedOutputs, out resolvedOutputs);
 
             Assert.Single(resolvedOutputs); // "One resolved ref expected for case 5"
-            Assert.True(resolvedOutputs.ContainsKey(@"obj\correct.dll"));
+            Assert.True(resolvedOutputs.ContainsKey(Path.Combine("obj", "correct.dll")));
             Assert.Empty(unresolvedOutputs); // "No unresolved refs expected for case 5"
 
             // 6. multiple project refs, one unresolvable, one failed to resolve
             projectOutputs = new Hashtable();
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111111}", @"obj\wrong.dll");
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111112}", @"obj\wrong2.dll");
-            projectOutputs.Add("{11111111-1111-1111-1111-111111111113}", @"obj\wrong3.dll");
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111111}", Path.Combine("obj", "wrong.dll"));
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111112}", Path.Combine("obj", "wrong2.dll"));
+            projectOutputs.Add("{11111111-1111-1111-1111-111111111113}", Path.Combine("obj", "wrong3.dll"));
             projectOutputs.Add("{2F6BBCC3-7111-4116-A68B-000000000000}", @"");
 
             TestUnresolvedReferencesHelper(projectRefs, projectOutputs, out unresolvedOutputs, out resolvedOutputs);
@@ -332,14 +341,14 @@ public void TestVerifyProjectReferenceItem()
             taskItems[0] = new TaskItem("projectReference");
             taskItems[0].SetMetadata(attributeProject, "{invalid guid}");
 
-            MockEngine engine = new MockEngine();
+            MockEngine engine = new MockEngine(_output);
             rvpo.BuildEngine = engine;
             Assert.True(rvpo.VerifyProjectReferenceItems(taskItems, false /* treat problems as warnings */));
             Assert.Equal(1, engine.Warnings);
             Assert.Equal(0, engine.Errors);
             engine.AssertLogContains("MSB3107");
 
-            engine = new MockEngine();
+            engine = new MockEngine(_output);
             rvpo.BuildEngine = engine;
             Assert.False(rvpo.VerifyProjectReferenceItems(taskItems, true /* treat problems as errors */));
             Assert.Equal(0, engine.Warnings);
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index d4de701fdeb..036f9aee7d7 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -442,15 +442,24 @@ public string[] GetOutputFolders(string[] productCodes, string culture, string f
             var files = new List<string>();
             BuildPackages(settings, null, null, files, null);
 
+            List<string> packagePaths = new List<string>() { invariantPath };
+            packagePaths.AddRange(Util.AdditionalPackagePaths.Select(p => Util.AddTrailingChar(p.ToLowerInvariant(), System.IO.Path.DirectorySeparatorChar)));
+
             foreach (string file in files)
             {
                 string folder = System.IO.Path.GetDirectoryName(file);
-                if (folder.Substring(0, invariantPath.Length).ToLowerInvariant().CompareTo(invariantPath) == 0)
+
+                foreach (string packagePath in packagePaths)
                 {
-                    string relPath = folder.Substring(invariantPath.Length);
-                    if (!folders.Contains(relPath))
+                    if (folder.Length >= packagePath.Length && folder.Substring(0, packagePath.Length).ToLowerInvariant().CompareTo(packagePath) == 0)
                     {
-                        folders.Add(relPath);
+                        string relPath = folder.Substring(packagePath.Length);
+                        if (!folders.Contains(relPath))
+                        {
+                            folders.Add(relPath);
+                        }
+
+                        break;
                     }
                 }
             }
@@ -576,18 +585,23 @@ private void RefreshProducts()
             _xmlNamespaceManager.AddNamespace(BOOTSTRAPPER_PREFIX, BOOTSTRAPPER_NAMESPACE);
 
             XmlElement rootElement = _document.CreateElement("Products", BOOTSTRAPPER_NAMESPACE);
-            string packagePath = PackagePath;
 
-            if (FileSystems.Default.DirectoryExists(packagePath))
+            List<string> packagePaths = new List<string>() { PackagePath };
+            packagePaths.AddRange(Util.AdditionalPackagePaths);
+            foreach (string packagePath in packagePaths)
             {
-                foreach (string strSubDirectory in Directory.GetDirectories(packagePath))
+                if (FileSystems.Default.DirectoryExists(packagePath))
                 {
-                    int nStartIndex = packagePath.Length;
-                    if ((strSubDirectory.ToCharArray())[nStartIndex] == System.IO.Path.DirectorySeparatorChar)
+                    foreach (string strSubDirectory in Directory.GetDirectories(packagePath))
                     {
-                        nStartIndex = nStartIndex + 1;
+                        int nStartIndex = packagePath.Length;
+                        if ((strSubDirectory.ToCharArray())[nStartIndex] == System.IO.Path.DirectorySeparatorChar)
+                        {
+                            nStartIndex = nStartIndex + 1;
+                        }
+
+                        ExploreDirectory(strSubDirectory.Substring(nStartIndex), rootElement, packagePath);
                     }
-                    ExploreDirectory(strSubDirectory.Substring(nStartIndex), rootElement);
                 }
             }
 
@@ -887,11 +901,10 @@ private XmlDocument LoadAndValidateXmlDocument(string filePath, bool validateFil
             return xmlDocument;
         }
 
-        private void ExploreDirectory(string strSubDirectory, XmlElement rootElement)
+        private void ExploreDirectory(string strSubDirectory, XmlElement rootElement, string packagePath)
         {
             try
             {
-                string packagePath = PackagePath;
                 string strSubDirectoryFullPath = System.IO.Path.Combine(packagePath, strSubDirectory);
 
                 // figure out our product file paths based on the directory full path
diff --git a/src/Tasks/BootstrapperUtil/Util.cs b/src/Tasks/BootstrapperUtil/Util.cs
index 0e224e828a6..8cdc63b3a37 100644
--- a/src/Tasks/BootstrapperUtil/Util.cs
+++ b/src/Tasks/BootstrapperUtil/Util.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections.Generic;
 using System.Globalization;
 using System.IO;
 using Microsoft.Win32;
@@ -17,7 +18,10 @@ internal static class Util
 
         private const string REGISTRY_DEFAULTPATH = "Path";
 
+        private const string BOOTSTRAPPER_REGISTRY_ADDITIONAL_PACKAGE_PATHS_KEYNAME = "AdditionalPackagePaths";
+
         private static string s_defaultPath;
+        private static List<string> s_additionalPackagePaths;
 
         public static string AddTrailingChar(string str, char ch)
         {
@@ -145,6 +149,46 @@ public static string GetDefaultPath(string visualStudioVersion)
             return Directory.GetCurrentDirectory();
         }
 
+        // Gets the list of additional paths to inspect for packages as defined in the registry
+        public static List<string> AdditionalPackagePaths
+        {
+            get
+            {
+                if (s_additionalPackagePaths == null)
+                {
+                    List<string> additionalPackagePaths = new List<string>();
+                    RegistryKey bootstrapperBaseRegKey = Registry.LocalMachine.OpenSubKey(BOOTSTRAPPER_REGISTRY_PATH_BASE);
+                    if (bootstrapperBaseRegKey == null)
+                    {
+                        bootstrapperBaseRegKey = Registry.LocalMachine.OpenSubKey(BOOTSTRAPPER_WOW64_REGISTRY_PATH_BASE);
+                    }
+
+                    if (bootstrapperBaseRegKey != null)
+                    {
+                        RegistryKey additionalPackagePathsRegKey = bootstrapperBaseRegKey.OpenSubKey(BOOTSTRAPPER_REGISTRY_ADDITIONAL_PACKAGE_PATHS_KEYNAME);
+                        if (additionalPackagePathsRegKey != null)
+                        {
+                            foreach (string key in additionalPackagePathsRegKey.GetValueNames())
+                            {
+                                if (additionalPackagePathsRegKey.GetValueKind(key) == RegistryValueKind.String)
+                                {
+                                    string path = (string)additionalPackagePathsRegKey.GetValue(key);
+                                    if (!string.IsNullOrEmpty(path))
+                                    {
+                                        additionalPackagePaths.Add(path);
+                                    }
+                                }
+                            }
+                        }
+                    }
+
+                    s_additionalPackagePaths = additionalPackagePaths;
+                }
+
+                return s_additionalPackagePaths;
+            }
+        }
+
         private static string ReadRegistryString(RegistryKey key, string path, string registryValue)
         {
             RegistryKey subKey = key.OpenSubKey(path, false);
diff --git a/src/Tasks/DownloadFile.cs b/src/Tasks/DownloadFile.cs
index abf08c0ef1e..f3cbccfde1d 100644
--- a/src/Tasks/DownloadFile.cs
+++ b/src/Tasks/DownloadFile.cs
@@ -8,6 +8,7 @@
 using System.Net;
 using System.Net.Http;
 using System.Threading;
+using System.Threading.Tasks;
 using Task = System.Threading.Tasks.Task;
 
 namespace Microsoft.Build.Tasks
@@ -69,6 +70,11 @@ public void Cancel()
         }
 
         public override bool Execute()
+        {
+            return ExecuteAsync().GetAwaiter().GetResult();
+        }
+
+        private async Task<bool> ExecuteAsync()
         {
             if (!Uri.TryCreate(SourceUrl, UriKind.Absolute, out Uri uri))
             {
@@ -77,36 +83,46 @@ public override bool Execute()
             }
 
             int retryAttemptCount = 0;
-            bool canRetry = false;
+            
+            CancellationToken cancellationToken = _cancellationTokenSource.Token;
 
-            do
+            while(true)
             {
                 try
                 {
-                    Download(uri);
+                    await DownloadAsync(uri, cancellationToken);
                     break;
                 }
-                catch (OperationCanceledException)
+                catch (OperationCanceledException e) when (e.CancellationToken == cancellationToken)
                 {
+                    // This task is being cancelled. Exit the loop.
+                    break;
                 }
                 catch (Exception e)
                 {
-                    canRetry = IsRetriable(e, out Exception actualException) && retryAttemptCount++ < Retries;
+                    bool canRetry = IsRetriable(e, out Exception actualException) && retryAttemptCount++ < Retries;
 
                     if (canRetry)
                     {
                         Log.LogWarningWithCodeFromResources("DownloadFile.Retrying", SourceUrl, retryAttemptCount + 1, RetryDelayMilliseconds, actualException.Message);
 
-                        Thread.Sleep(RetryDelayMilliseconds);
-
+                        try
+                        {
+                            await Task.Delay(RetryDelayMilliseconds, cancellationToken).ConfigureAwait(false);
+                        }
+                        catch (OperationCanceledException delayException) when (delayException.CancellationToken == cancellationToken)
+                        {
+                            // This task is being cancelled, exit the loop
+                            break;
+                        }
                     }
                     else
                     {
                         Log.LogErrorWithCodeFromResources("DownloadFile.ErrorDownloading", SourceUrl, actualException.Message);
+                        break;
                     }
                 }
             }
-            while (canRetry);
 
             return !_cancellationTokenSource.IsCancellationRequested && !Log.HasLoggedErrors;
         }
@@ -115,16 +131,13 @@ public override bool Execute()
         /// Attempts to download the file.
         /// </summary>
         /// <param name="uri">The parsed <see cref="Uri"/> of the request.</param>
-        private void Download(Uri uri)
+        private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)
         {
             // The main reason to use HttpClient vs WebClient is because we can pass a message handler for unit tests to mock
             using (var client = new HttpClient(HttpMessageHandler ?? new HttpClientHandler(), disposeHandler: true))
             {
                 // Only get the response without downloading the file so we can determine if the file is already up-to-date
-                using (HttpResponseMessage response = client.GetAsync(uri, HttpCompletionOption.ResponseHeadersRead, _cancellationTokenSource.Token)
-                                                            .ConfigureAwait(continueOnCapturedContext: false)
-                                                            .GetAwaiter()
-                                                            .GetResult())
+                using (HttpResponseMessage response = await client.GetAsync(uri, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false))
                 {
                     try
                     {
@@ -159,15 +172,16 @@ private void Download(Uri uri)
 
                     try
                     {
+                        cancellationToken.ThrowIfCancellationRequested();
+
                         using (var target = new FileStream(destinationFile.FullName, FileMode.Create, FileAccess.Write, FileShare.None))
                         {
                             Log.LogMessageFromResources(MessageImportance.High, "DownloadFile.Downloading", SourceUrl, destinationFile.FullName, response.Content.Headers.ContentLength);
 
-                            Task task = response.Content.CopyToAsync(target);
-
-                            task.ConfigureAwait(continueOnCapturedContext: false);
-
-                            task.Wait(_cancellationTokenSource.Token);
+                            using (Stream responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
+                            {
+                                await responseStream.CopyToAsync(target, 1024, cancellationToken).ConfigureAwait(false);
+                            }
 
                             DownloadedFile = new TaskItem(destinationFile.FullName);
                         }
diff --git a/src/Tasks/Exec.cs b/src/Tasks/Exec.cs
index 67a24791d30..35db2490c74 100644
--- a/src/Tasks/Exec.cs
+++ b/src/Tasks/Exec.cs
@@ -43,11 +43,6 @@ public Exec()
 
         #region Fields
 
-        private const string UseUtf8Always = "ALWAYS";
-        private const string UseUtf8Never = "NEVER";
-        private const string UseUtf8Detect = "DETECT";
-        private const string UseUtf8System = "SYSTEM";
-
         // Are the encodings for StdErr and StdOut streams valid
         private bool _encodingParametersValid = true;
         private string _workingDirectory;
@@ -203,7 +198,7 @@ public ITaskItem[] Outputs
         /// </summary>
         private void CreateTemporaryBatchFile()
         {
-            var encoding = BatchFileEncoding();
+            var encoding = EncodingUtilities.BatchFileEncoding(Command + WorkingDirectory, UseUtf8Encoding);
 
             // Temporary file with the extension .Exec.bat
             _batchFile = FileUtilities.GetTemporaryFile(".exec.cmd");
@@ -650,94 +645,5 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens
         protected override MessageImportance StandardOutputLoggingImportance => MessageImportance.High;
 
         #endregion
-
-        private static readonly Encoding s_utf8WithoutBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
-
-        /// <summary>
-        /// Find the encoding for the batch file.
-        /// </summary>
-        /// <remarks>
-        /// The "best" encoding is the current OEM encoding, unless it's not capable of representing
-        /// the characters we plan to put in the file. If it isn't, we can fall back to UTF-8.
-        ///
-        /// Why not always UTF-8? Because tools don't always handle it well. See
-        /// https://github.com/Microsoft/msbuild/issues/397
-        /// </remarks>
-        private Encoding BatchFileEncoding()
-        {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return s_utf8WithoutBom;
-            }
-
-            var defaultEncoding = EncodingUtilities.CurrentSystemOemEncoding;
-
-            // When Windows is configured to use UTF-8 by default, the above returns
-            // a UTF-8-with-BOM encoding, which cmd.exe can't interpret. Force the no-BOM
-            // encoding if the returned encoding would have emitted one (preamble is nonempty).
-            // See https://github.com/Microsoft/msbuild/issues/4268
-            if (defaultEncoding is UTF8Encoding e && e.GetPreamble().Length > 0)
-            {
-                defaultEncoding = s_utf8WithoutBom;
-            }
-
-            string useUtf8 = string.IsNullOrEmpty(UseUtf8Encoding) ? UseUtf8Detect : UseUtf8Encoding;
-
-#if FEATURE_OSVERSION
-            // UTF8 is only supported in Windows 7 (6.1) or greater.
-            var windows7 = new Version(6, 1);
-
-            if (Environment.OSVersion.Version < windows7)
-            {
-                useUtf8 = UseUtf8Never;
-            }
-#endif
-
-            switch (useUtf8.ToUpperInvariant())
-            {
-                case UseUtf8Always:
-                    return s_utf8WithoutBom;
-                case UseUtf8Never:
-                case UseUtf8System:
-                    return defaultEncoding;
-                default:
-                    return CanEncodeString(defaultEncoding.CodePage, Command + WorkingDirectory)
-                        ? defaultEncoding
-                        : s_utf8WithoutBom;
-            }
-        }
-
-        /// <summary>
-        /// Checks to see if a string can be encoded in a specified code page.
-        /// </summary>
-        /// <remarks>Internal for testing purposes.</remarks>
-        /// <param name="codePage">Code page for encoding.</param>
-        /// <param name="stringToEncode">String to encode.</param>
-        /// <returns>True if the string can be encoded in the specified code page.</returns>
-        internal static bool CanEncodeString(int codePage, string stringToEncode)
-        {
-            // We have a System.String that contains some characters. Get a lossless representation
-            // in byte-array form.
-            var unicodeEncoding = new UnicodeEncoding();
-            var unicodeBytes = unicodeEncoding.GetBytes(stringToEncode);
-
-            // Create an Encoding using the desired code page, but throws if there's a
-            // character that can't be represented.
-            var systemEncoding = Encoding.GetEncoding(codePage, EncoderFallback.ExceptionFallback,
-                DecoderFallback.ExceptionFallback);
-
-            try
-            {
-                var oemBytes = Encoding.Convert(unicodeEncoding, systemEncoding, unicodeBytes);
-
-                // If Convert didn't throw, we can represent everything in the desired encoding.
-                return true;
-            }
-            catch (EncoderFallbackException)
-            {
-                // If a fallback encoding was attempted, we need to go to Unicode.
-                return false;
-            }
-        }
     }
 }
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index d0425fea95c..044ca37e250 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -474,6 +474,9 @@
     <Compile Include="ResolveKeySource.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="ResolveNonMSBuildProjectOutput.cs">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="ResolveProjectBase.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -619,9 +622,6 @@
     <Compile Include="ResolveNativeReference.cs" Condition="'$(MonoBuild)' != 'true'">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="ResolveNonMSBuildProjectOutput.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="ResolveSDKReference.cs" />
     <Compile Include="SdkToolsPathUtility.cs" />
     <Compile Include="RequiresFramework35SP1Assembly.cs" Condition="'$(MonoBuild)' != 'true'">
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index b867c66acdd..de0200a6383 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -3286,7 +3286,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup Condition="'$(TargetFrameworkMoniker)' != ''">
     <!-- Do not clean if we are going to default the path to the temp directory -->
     <TargetFrameworkMonikerAssemblyAttributesFileClean Condition="'$(TargetFrameworkMonikerAssemblyAttributesFileClean)' == '' and '$(TargetFrameworkMonikerAssemblyAttributesPath)' != ''">true</TargetFrameworkMonikerAssemblyAttributesFileClean>
-    <TargetFrameworkMonikerAssemblyAttributesPath Condition="'$(TargetFrameworkMonikerAssemblyAttributesPath)' == ''">$([System.IO.Path]::Combine('$([System.IO.Path]::GetTempPath())','$(TargetFrameworkMoniker).AssemblyAttributes$(DefaultLanguageSourceExtension)'))</TargetFrameworkMonikerAssemblyAttributesPath>
+    <TargetFrameworkMonikerAssemblyAttributesPath Condition="'$(TargetFrameworkMonikerAssemblyAttributesPath)' == ''">$([System.IO.Path]::Combine('$(IntermediateOutputPath)','$(TargetFrameworkMoniker).AssemblyAttributes$(DefaultLanguageSourceExtension)'))</TargetFrameworkMonikerAssemblyAttributesPath>
   </PropertyGroup>
 
   <PropertyGroup>
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index 07e1ef354f9..78c523c03ed 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -1,4 +1,4 @@
-// Copyright (c) Microsoft. All rights reserved.
+﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
@@ -10,11 +10,19 @@
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
+using Xunit.Abstractions;
 
 namespace Microsoft.Build.UnitTests
 {
     public sealed class ToolTask_Tests
     {
+        private ITestOutputHelper _output;
+
+        public ToolTask_Tests(ITestOutputHelper testOutput)
+        {
+            _output = testOutput;
+        }
+
         private class MyTool : ToolTask, IDisposable
         {
             private string _fullToolName;
@@ -789,5 +797,65 @@ protected override void LogToolCommand(string message)
 
             public string ResponseFileCommands { get; private set; }
         }
+
+        [Theory]
+        [InlineData("MSBUILDAVOIDUNICODE", null, false)]
+        [InlineData("MSBUILDAVOIDUNICODE", "0", false)]
+        [InlineData("MSBUILDAVOIDUNICODE", "1", true)]
+        public void ToolTaskCanUseUnicode(string environmentVariableName, string environmentVariableValue, bool expectNormalizationToANSI)
+        {
+            using TestEnvironment testEnvironment = TestEnvironment.Create(_output);
+
+            testEnvironment.SetEnvironmentVariable(environmentVariableName, environmentVariableValue);
+
+            var output = testEnvironment.ExpectFile();
+
+            MockEngine engine = new MockEngine();
+
+            var task = new ToolTaskThatNeedsUnicode
+            {
+                BuildEngine = engine,
+                UseCommandProcessor = true,
+                OutputPath = output.Path,
+            };
+
+            task.Execute();
+
+            File.Exists(output.Path).ShouldBeTrue();
+            if (NativeMethodsShared.IsUnixLike // treat all UNIXy OSes as capable of UTF-8 everywhere
+                || !expectNormalizationToANSI)
+            {
+                File.ReadAllText(output.Path).ShouldContain("łoł");
+            }
+            else
+            {
+                File.ReadAllText(output.Path).ShouldContain("lol");
+            }
+        }
+
+
+        private sealed class ToolTaskThatNeedsUnicode : ToolTask
+        {
+            protected override string ToolName => "cmd.exe";
+
+            [Required]
+            public string OutputPath { get; set; }
+
+            public ToolTaskThatNeedsUnicode()
+            {
+                UseCommandProcessor = true;
+            }
+
+            protected override string GenerateFullPathToTool()
+            {
+                return "cmd.exe";
+            }
+
+            protected override string GenerateCommandLineCommands()
+            {
+                return $"echo łoł > {OutputPath}";
+            }
+        }
+
     }
 }
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 4e875a65f59..365066c0e9d 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -1362,10 +1362,35 @@ public override bool Execute()
                         File.AppendAllText(_temporaryBatchFile, "#!/bin/sh\n"); // first line for UNIX is ANSI
                         // This is a hack..!
                         File.AppendAllText(_temporaryBatchFile, AdjustCommandsForOperatingSystem(commandLineCommands), EncodingUtilities.CurrentSystemOemEncoding);
+
+                        commandLineCommands = $"\"{_temporaryBatchFile}\"";
                     }
                     else
                     {
-                        File.AppendAllText(_temporaryBatchFile, commandLineCommands, EncodingUtilities.CurrentSystemOemEncoding);
+
+                        Encoding encoding;
+
+                        if (Traits.Instance.EscapeHatches.AvoidUnicodeWhenWritingToolTaskBatch)
+                        {
+                            encoding = EncodingUtilities.CurrentSystemOemEncoding;
+                        }
+                        else
+                        {
+                            encoding = EncodingUtilities.BatchFileEncoding(commandLineCommands + _temporaryBatchFile, EncodingUtilities.UseUtf8Detect);
+
+                            if (encoding.CodePage != EncodingUtilities.CurrentSystemOemEncoding.CodePage)
+                            {
+                                // cmd.exe reads the first line in the console CP, 
+                                // which for a new console (as here) is OEMCP
+                                // this string should ideally always be ASCII
+                                // and the same in any OEMCP.
+                                File.AppendAllText(_temporaryBatchFile,
+                                                   $@"%SystemRoot%\System32\chcp.com {encoding.CodePage}>nul{Environment.NewLine}",
+                                                   EncodingUtilities.CurrentSystemOemEncoding);
+                            }
+                        }
+
+                        File.AppendAllText(_temporaryBatchFile, commandLineCommands, encoding);
 
                         string batchFileForCommandLine = _temporaryBatchFile;
 
