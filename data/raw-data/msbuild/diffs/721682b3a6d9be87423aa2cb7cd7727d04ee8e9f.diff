diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 17573a98798..4f52ce964b1 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -5,8 +5,10 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
+using System.Linq;
 using System.Runtime.InteropServices;
 using System.Security.Principal;
+using System.Threading;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.AccessControl;
 #endif
@@ -26,6 +28,13 @@ public class Copy_Tests : IDisposable
 
         public bool UseSymbolicLinks { get; protected set; }
 
+        /// <summary>
+        /// Max copy parallelism to provide to the Copy task.
+        /// </summary>
+        public int ParallelismThreadCount { get; set; } = int.MaxValue;
+
+        private const int NoParallelismThreadCount = 1;
+
         /// <summary>
         /// Temporarily save off the value of MSBUILDALWAYSOVERWRITEREADONLYFILES, so that we can run 
         /// the tests isolated from the current state of the environment, but put it back how it belongs
@@ -49,11 +58,11 @@ public class Copy_Tests : IDisposable
         public Copy_Tests(ITestOutputHelper testOutputHelper)
         {
             _testOutputHelper = testOutputHelper;
-            _alwaysOverwriteReadOnlyFiles = Environment.GetEnvironmentVariable("MSBUILDALWAYSOVERWRITEREADONLYFILES");
-            _alwaysRetry = Environment.GetEnvironmentVariable("MSBUILDALWAYSRETRY");
+            _alwaysOverwriteReadOnlyFiles = Environment.GetEnvironmentVariable(Copy.AlwaysOverwriteReadOnlyFilesEnvVar);
+            _alwaysRetry = Environment.GetEnvironmentVariable(Copy.AlwaysRetryEnvVar);
 
-            Environment.SetEnvironmentVariable("MSBUILDALWAYSOVERWRITEREADONLYFILES", String.Empty);
-            Environment.SetEnvironmentVariable("MSBUILDALWAYSRETRY", String.Empty);
+            Environment.SetEnvironmentVariable(Copy.AlwaysOverwriteReadOnlyFilesEnvVar, String.Empty);
+            Environment.SetEnvironmentVariable(Copy.AlwaysRetryEnvVar, String.Empty);
 
             Copy.RefreshInternalEnvironmentValues();
         }
@@ -63,20 +72,31 @@ public Copy_Tests(ITestOutputHelper testOutputHelper)
         /// </summary>
         public void Dispose()
         {
-            Environment.SetEnvironmentVariable("MSBUILDALWAYSOVERWRITEREADONLYFILES", _alwaysOverwriteReadOnlyFiles);
-            Environment.SetEnvironmentVariable("MSBUILDALWAYSRETRY", _alwaysRetry);
+            Environment.SetEnvironmentVariable(Copy.AlwaysOverwriteReadOnlyFilesEnvVar, _alwaysOverwriteReadOnlyFiles);
+            Environment.SetEnvironmentVariable(Copy.AlwaysRetryEnvVar, _alwaysRetry);
 
             Copy.RefreshInternalEnvironmentValues();
         }
 
+        [Fact]
+        public void DontCopyOverSameFile_Parallel()
+        {
+            DontCopyOverSameFile(ParallelismThreadCount);
+        }
+
+        [Fact]
+        public void DontCopyOverSameFile_SingleThreaded()
+        {
+            DontCopyOverSameFile(NoParallelismThreadCount);
+        }
+
         /*
         * Method:   DontCopyOverSameFile
         *
         * If OnlyCopyIfDifferent is set to "true" then we shouldn't copy over files that
         * have the same date and time.
         */
-        [Fact]
-        public void DontCopyOverSameFile()
+        private void DontCopyOverSameFile(int parallelism)
         {
             string file = FileUtilities.GetTemporaryFile();
             try
@@ -101,7 +121,7 @@ public void DontCopyOverSameFile()
                     UseHardlinksIfPossible = UseHardLinks
                 };
 
-                t.Execute(m.CopyFile);
+                t.Execute(m.CopyFile, parallelism);
 
                 // Expect for there to have been no copies.
                 Assert.Equal(0, m.copyCount);
@@ -187,11 +207,11 @@ public void CopyOverReadOnlyFileEnvironmentOverride()
         {
             string source = FileUtilities.GetTemporaryFile();
             string destination = FileUtilities.GetTemporaryFile();
-            string oldAlwaysOverwriteValue = Environment.GetEnvironmentVariable("MSBUILDALWAYSOVERWRITEREADONLYFILES");
+            string oldAlwaysOverwriteValue = Environment.GetEnvironmentVariable(Copy.AlwaysOverwriteReadOnlyFilesEnvVar);
 
             try
             {
-                Environment.SetEnvironmentVariable("MSBUILDALWAYSOVERWRITEREADONLYFILES", "1   ");
+                Environment.SetEnvironmentVariable(Copy.AlwaysOverwriteReadOnlyFilesEnvVar, "1   ");
 
                 using (StreamWriter sw = FileUtilities.OpenWrite(source, true))
                 {
@@ -234,7 +254,7 @@ public void CopyOverReadOnlyFileEnvironmentOverride()
             }
             finally
             {
-                Environment.SetEnvironmentVariable("MSBUILDALWAYSOVERWRITEREADONLYFILES", oldAlwaysOverwriteValue);
+                Environment.SetEnvironmentVariable(Copy.AlwaysOverwriteReadOnlyFilesEnvVar, oldAlwaysOverwriteValue);
 
                 File.Delete(source);
                 File.Delete(destination);
@@ -252,11 +272,11 @@ public void AlwaysRetryCopyEnvironmentOverride()
         {
             string source = FileUtilities.GetTemporaryFile();
             string destination = FileUtilities.GetTemporaryFile();
-            string oldAlwaysOverwriteValue = Environment.GetEnvironmentVariable("MSBUILDALWAYSRETRY");
+            string oldAlwaysRetryValue = Environment.GetEnvironmentVariable(Copy.AlwaysRetryEnvVar);
 
             try
             {
-                Environment.SetEnvironmentVariable("MSBUILDALWAYSRETRY", "1   ");
+                Environment.SetEnvironmentVariable(Copy.AlwaysRetryEnvVar, "1   ");
                 Copy.RefreshInternalEnvironmentValues();
 
                 using (StreamWriter sw = FileUtilities.OpenWrite(source, true))
@@ -302,7 +322,7 @@ public void AlwaysRetryCopyEnvironmentOverride()
             }
             finally
             {
-                Environment.SetEnvironmentVariable("MSBUILDALWAYSRETRY", oldAlwaysOverwriteValue);
+                Environment.SetEnvironmentVariable(Copy.AlwaysRetryEnvVar, oldAlwaysRetryValue);
                 Copy.RefreshInternalEnvironmentValues();
 
                 File.SetAttributes(destination, FileAttributes.Normal);
@@ -906,7 +926,7 @@ internal class CopyMonitor
             */
             internal bool? CopyFile(FileState source, FileState destination)
             {
-                ++copyCount;
+                Interlocked.Increment(ref copyCount);
                 return true;
             }
         }
@@ -1308,12 +1328,23 @@ public void CopyDoubleEscapableFileToDestinationFolder()
             }
         }
 
+        [Fact]
+        public void CopyWithDuplicatesUsingFolder_Parallel()
+        {
+            CopyWithDuplicatesUsingFolder(ParallelismThreadCount);
+        }
+
+        [Fact]
+        public void CopyWithDuplicatesUsingFolder_SingleThreaded()
+        {
+            CopyWithDuplicatesUsingFolder(NoParallelismThreadCount);
+        }
+
         /// <summary>
         /// Copying duplicates should only perform the actual copy once for each unique source/destination pair
         /// but should still produce outputs for all specified source/destination pairs.
         /// </summary>
-        [Fact]
-        public void CopyWithDuplicatesUsingFolder()
+        private void CopyWithDuplicatesUsingFolder(int parallelism)
         {
             string tempPath = Path.GetTempPath();
 
@@ -1346,25 +1377,49 @@ public void CopyWithDuplicatesUsingFolder()
 
             bool success = t.Execute(delegate (FileState source, FileState dest)
             {
-                filesActuallyCopied.Add(new KeyValuePair<FileState, FileState>(source, dest));
+                lock (filesActuallyCopied)
+                {
+                    filesActuallyCopied.Add(new KeyValuePair<FileState, FileState>(source, dest));
+                }
                 return true;
-            });
+            }, parallelism);
 
             Assert.True(success);
             Assert.Equal(2, filesActuallyCopied.Count);
             Assert.Equal(4, t.CopiedFiles.Length);
-            Assert.Equal(Path.Combine(tempPath, "a.cs"), filesActuallyCopied[0].Key.Name);
-            Assert.Equal(Path.Combine(tempPath, "b.cs"), filesActuallyCopied[1].Key.Name);
+
+            // Copy calls to different destinations can come in any order when running in parallel.
+
+            string aPath = Path.Combine(tempPath, "foo", "a.cs");
+            var aCopies = filesActuallyCopied.Where(f => f.Value.Name == aPath).ToList();
+            Assert.Equal(1, aCopies.Count);
+            Assert.Equal(Path.Combine(tempPath, "a.cs"), aCopies[0].Key.Name);
+
+            string bPath = Path.Combine(tempPath, "foo", "b.cs");
+            var bCopies = filesActuallyCopied.Where(f => f.Value.Name == bPath).ToList();
+            Assert.Equal(1, bCopies.Count);
+            Assert.Equal(Path.Combine(tempPath, "b.cs"), bCopies[0].Key.Name);
 
             ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries
         }
 
+        [Fact]
+        private void CopyWithDuplicatesUsingFiles_Parallel()
+        {
+            CopyWithDuplicatesUsingFiles(ParallelismThreadCount);
+        }
+
+        [Fact]
+        private void CopyWithDuplicatesUsingFiles_SingleThreaded()
+        {
+            CopyWithDuplicatesUsingFiles(NoParallelismThreadCount);
+        }
+
         /// <summary>
         /// Copying duplicates should only perform the actual copy once for each unique source/destination pair
         /// but should still produce outputs for all specified source/destination pairs.
         /// </summary>
-        [Fact]
-        public void CopyWithDuplicatesUsingFiles()
+        private void CopyWithDuplicatesUsingFiles(int parallelism)
         {
             string tempPath = Path.GetTempPath();
 
@@ -1390,7 +1445,7 @@ public void CopyWithDuplicatesUsingFiles()
                 new TaskItem(Path.Combine(tempPath, @"xa.cs")), // a.cs -> xa.cs
                 new TaskItem(Path.Combine(tempPath, @"xa.cs")), // b.cs -> xa.cs should copy because it's a different source
                 new TaskItem(Path.Combine(tempPath, @"xb.cs")), // a.cs -> xb.cs should copy because it's a different destination
-                new TaskItem(Path.Combine(tempPath, @"xa.cs")), // a.cs -> xa.cs should copy because it's a different source
+                new TaskItem(Path.Combine(tempPath, @"xa.cs")), // a.cs -> xa.cs should copy because it's a different source from the b.cs copy done previously
                 new TaskItem(Path.Combine(tempPath, @"xa.cs")), // a.cs -> xa.cs should not copy because it's the same source
             };
 
@@ -1407,21 +1462,30 @@ public void CopyWithDuplicatesUsingFiles()
 
             bool success = t.Execute(delegate (FileState source, FileState dest)
             {
-                filesActuallyCopied.Add(new KeyValuePair<FileState, FileState>(source, dest));
+                lock (filesActuallyCopied)
+                {
+                    filesActuallyCopied.Add(new KeyValuePair<FileState, FileState>(source, dest));
+                }
                 return true;
-            });
+            }, parallelism);
 
             Assert.True(success);
             Assert.Equal(4, filesActuallyCopied.Count);
             Assert.Equal(5, t.CopiedFiles.Length);
-            Assert.Equal(Path.Combine(tempPath, "a.cs"), filesActuallyCopied[0].Key.Name);
-            Assert.Equal(Path.Combine(tempPath, "b.cs"), filesActuallyCopied[1].Key.Name);
-            Assert.Equal(Path.Combine(tempPath, "a.cs"), filesActuallyCopied[2].Key.Name);
-            Assert.Equal(Path.Combine(tempPath, "a.cs"), filesActuallyCopied[3].Key.Name);
-            Assert.Equal(Path.Combine(tempPath, "xa.cs"), filesActuallyCopied[0].Value.Name);
-            Assert.Equal(Path.Combine(tempPath, "xa.cs"), filesActuallyCopied[1].Value.Name);
-            Assert.Equal(Path.Combine(tempPath, "xb.cs"), filesActuallyCopied[2].Value.Name);
-            Assert.Equal(Path.Combine(tempPath, "xa.cs"), filesActuallyCopied[3].Value.Name);
+
+            // Copy calls to different destinations can come in any order when running in parallel.
+
+            string xaPath = Path.Combine(tempPath, "xa.cs");
+            var xaCopies = filesActuallyCopied.Where(f => f.Value.Name == xaPath).ToList();
+            Assert.Equal(3, xaCopies.Count);
+            Assert.Equal(Path.Combine(tempPath, "a.cs"), xaCopies[0].Key.Name);
+            Assert.Equal(Path.Combine(tempPath, "b.cs"), xaCopies[1].Key.Name);
+            Assert.Equal(Path.Combine(tempPath, "a.cs"), xaCopies[2].Key.Name);
+
+            string xbPath = Path.Combine(tempPath, "xb.cs");
+            var xbCopies = filesActuallyCopied.Where(f => f.Value.Name == xbPath).ToList();
+            Assert.Equal(1, xbCopies.Count);
+            Assert.Equal(Path.Combine(tempPath, "a.cs"), xbCopies[0].Key.Name);
 
             ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries
         }
@@ -1625,12 +1689,23 @@ public void InvalidRetryDelayCount()
             engine.AssertLogContains("MSB3029");
         }
 
+        [Fact]
+        public void FailureWithNoRetries_Parallel()
+        {
+            FailureWithNoRetries(ParallelismThreadCount);
+        }
+
+        [Fact]
+        public void FailureWithNoRetries_SingleThreaded()
+        {
+            FailureWithNoRetries(NoParallelismThreadCount);
+        }
+
         /// <summary>
         /// Verifies that we do not log the retrying warning if we didn't request
         /// retries.
         /// </summary>
-        [Fact]
-        public void FailureWithNoRetries()
+        private void FailureWithNoRetries(int parallelism)
         {
             var engine = new MockEngine(true /* log to console */);
             var t = new Copy
@@ -1644,7 +1719,7 @@ public void FailureWithNoRetries()
             };
             
             var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
-            bool result = t.Execute(copyFunctor.Copy);
+            bool result = t.Execute(copyFunctor.Copy, parallelism);
 
             Assert.Equal(false, result);
             engine.AssertLogDoesntContain("MSB3026");
@@ -1690,12 +1765,23 @@ public void DefaultNoHardlink()
             Assert.Equal(false, t.UseHardlinksIfPossible);
         }
 
+        [Fact]
+        public void SuccessAfterOneRetry_Parallel()
+        {
+            SuccessAfterOneRetry(ParallelismThreadCount);
+        }
+
+        [Fact]
+        public void SuccessAfterOneRetry_SingleThreaded()
+        {
+            SuccessAfterOneRetry(NoParallelismThreadCount);
+        }
+
         /// <summary>
         /// Verifies that we get the one retry we ask for after the first attempt fails,
         /// and we get appropriate messages.
         /// </summary>
-        [Fact]
-        public void SuccessAfterOneRetry()
+        public void SuccessAfterOneRetry(int parallelism)
         {
             var engine = new MockEngine(true /* log to console */);
             var t = new Copy
@@ -1709,18 +1795,29 @@ public void SuccessAfterOneRetry()
             };
 
             var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
-            bool result = t.Execute(copyFunctor.Copy);
+            bool result = t.Execute(copyFunctor.Copy, parallelism);
 
             Assert.Equal(true, result);
             engine.AssertLogContains("MSB3026");
             engine.AssertLogDoesntContain("MSB3027");
         }
 
+        [Fact]
+        public void SuccessAfterOneRetryContinueToNextFile_Parallel()
+        {
+            SuccessAfterOneRetryContinueToNextFile(ParallelismThreadCount);
+        }
+
+        [Fact]
+        public void SuccessAfterOneRetryContinueToNextFile_SingleThreaded()
+        {
+            SuccessAfterOneRetryContinueToNextFile(NoParallelismThreadCount);
+        }
+
         /// <summary>
         /// Verifies that after a successful retry we continue to the next file
         /// </summary>
-        [Fact]
-        public void SuccessAfterOneRetryContinueToNextFile()
+        private void SuccessAfterOneRetryContinueToNextFile(int parallelism)
         {
             var engine = new MockEngine(true /* log to console */);
             var t = new Copy
@@ -1734,21 +1831,34 @@ public void SuccessAfterOneRetryContinueToNextFile()
             };
 
             var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
-            bool result = t.Execute(copyFunctor.Copy);
+            bool result = t.Execute(copyFunctor.Copy, parallelism);
 
             Assert.Equal(true, result);
             engine.AssertLogContains("MSB3026");
             engine.AssertLogDoesntContain("MSB3027");
-            Assert.Equal(copyFunctor.FilesCopiedSuccessfully[0].Name, FileUtilities.FixFilePath("c:\\source"));
-            Assert.Equal(copyFunctor.FilesCopiedSuccessfully[1].Name, FileUtilities.FixFilePath("c:\\source2"));
+
+            // Copy calls to different destinations can come in any order when running in parallel.
+            Assert.True(copyFunctor.FilesCopiedSuccessfully.Any(f => f.Name == FileUtilities.FixFilePath("c:\\source")));
+            Assert.True(copyFunctor.FilesCopiedSuccessfully.Any(f => f.Name == FileUtilities.FixFilePath("c:\\source2")));
+        }
+
+        [Fact]
+        public void TooFewRetriesReturnsFalse_Parallel()
+        {
+            TooFewRetriesReturnsFalse(ParallelismThreadCount);
+        }
+
+        [Fact]
+        public void TooFewRetriesReturnsFalse_SingleThreaded()
+        {
+            TooFewRetriesReturnsFalse(NoParallelismThreadCount);
         }
 
         /// <summary>
         /// The copy delegate can return false, or throw on failure.
         /// This test tests returning false.
         /// </summary>
-        [Fact]
-        public void TooFewRetriesReturnsFalse()
+        private void TooFewRetriesReturnsFalse(int parallelism)
         {
             var engine = new MockEngine(true /* log to console */);
             var t = new Copy
@@ -1762,19 +1872,30 @@ public void TooFewRetriesReturnsFalse()
             };
 
             var copyFunctor = new CopyFunctor(4, false /* do not throw */);
-            bool result = t.Execute(copyFunctor.Copy);
+            bool result = t.Execute(copyFunctor.Copy, parallelism);
 
             Assert.Equal(false, result);
             engine.AssertLogContains("MSB3026");
             engine.AssertLogContains("MSB3027");
         }
 
+        [Fact]
+        public void TooFewRetriesThrows_Parallel()
+        {
+            TooFewRetriesThrows(ParallelismThreadCount);
+        }
+
+        [Fact]
+        public void TooFewRetriesThrows_SingleThreaded()
+        {
+            TooFewRetriesThrows(NoParallelismThreadCount);
+        }
+
         /// <summary>
         /// The copy delegate can return false, or throw on failure.
         /// This test tests the throw case.
         /// </summary>
-        [Fact]
-        public void TooFewRetriesThrows()
+        private void TooFewRetriesThrows(int parallelism)
         {
             var engine = new MockEngine(true /* log to console */);
             var t = new Copy
@@ -1788,7 +1909,7 @@ public void TooFewRetriesThrows()
             };
 
             var copyFunctor = new CopyFunctor(3, true /* throw */);
-            bool result = t.Execute(copyFunctor.Copy);
+            bool result = t.Execute(copyFunctor.Copy, parallelism);
 
             Assert.Equal(false, result);
             engine.AssertLogContains("MSB3026");
@@ -1802,6 +1923,11 @@ public void TooFewRetriesThrows()
         /// </summary>
         private class CopyFunctor
         {
+            /// <summary>
+            /// Protects the counts and lists below.
+            /// </summary>
+            private readonly object _lockObj = new object();
+
             /// <summary>
             /// On what attempt count should we stop failing?
             /// </summary>
@@ -1820,7 +1946,7 @@ private class CopyFunctor
             /// <summary>
             /// Which files we actually copied
             /// </summary>
-            internal List<FileState> FilesCopiedSuccessfully { get; }
+            internal List<FileState> FilesCopiedSuccessfully { get; } = new List<FileState>();
 
             /// <summary>
             /// Constructor
@@ -1829,8 +1955,6 @@ internal CopyFunctor(int countOfSuccess, bool throwOnFailure)
             {
                 _countOfSuccess = countOfSuccess;
                 _throwOnFailure = throwOnFailure;
-                _tries = 0;
-                FilesCopiedSuccessfully = new List<FileState>();
             }
 
             /// <summary>
@@ -1838,14 +1962,17 @@ internal CopyFunctor(int countOfSuccess, bool throwOnFailure)
             /// </summary>
             internal bool? Copy(FileState source, FileState destination)
             {
-                _tries++;
-
-                // 2nd and subsequent copies always succeed
-                if (FilesCopiedSuccessfully.Count > 0 || _countOfSuccess == _tries)
+                lock (_lockObj)
                 {
-                    Console.WriteLine("Copied {0} to {1} OK", source, destination);
-                    FilesCopiedSuccessfully.Add(source);
-                    return true;
+                    _tries++;
+
+                    // 2nd and subsequent copies always succeed
+                    if (FilesCopiedSuccessfully.Count > 0 || _countOfSuccess == _tries)
+                    {
+                        Console.WriteLine("Copied {0} to {1} OK", source, destination);
+                        FilesCopiedSuccessfully.Add(source);
+                        return true;
+                    }
                 }
 
                 if (_throwOnFailure)
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index b83923da790..70b42f59500 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -2,11 +2,12 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections.Concurrent;
 using System.IO;
 using System.Collections.Generic;
 using System.Threading;
 using System.Runtime.InteropServices;
-
+using System.Threading.Tasks.Dataflow;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
@@ -18,6 +19,22 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public class Copy : TaskExtension, ICancelableTask
     {
+        internal const string AlwaysRetryEnvVar = "MSBUILDALWAYSRETRY";
+        internal const string AlwaysOverwriteReadOnlyFilesEnvVar = "MSBUILDALWAYSOVERWRITEREADONLYFILES";
+
+        // Default parallelism determined empirically - times below are in seconds spent in the Copy task building this repo
+        // with "build -skiptests -rebuild -configuration Release /ds" (with hack to build.ps1 to disable creating selfhost
+        // build for non-selfhost first build; implies first running build in repo to pull packages and create selfhost)
+        // and comparing the task timings from the default and selfhost binlogs with different settings for this parallelism
+        // number (via env var override). >=3 samples averaged for each number.
+        //
+        //                            Parallelism: | 1     2     3     4     5     6     8     MaxInt
+        // ----------------------------------------+-------------------------------------------------
+        // 2-core (4 hyperthreaded) M.2 SSD laptop | 22.3  17.5  13.4  12.6  13.1  9.52  11.3  10.9
+        // 12-core (24 HT) SATA2 SSD 2012 desktop  | 15.1  10.2  9.57  7.29  7.64  7.41  7.67  7.79
+        // 12-core (24 HT) 1TB spinny disk         | 22.7  15.03 11.1  9.23  11.7  11.1  9.27  11.1
+        private const int DefaultCopyParallelism = int.MaxValue;
+
         /// <summary>
         /// Constructor.
         /// </summary>
@@ -29,14 +46,23 @@ public Copy()
         #region Properties
 
         private bool _canceling;
-        private readonly HashSet<string> _directoriesKnownToExist = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+
+        // Bool is just a placeholder, we're mainly interested in a threadsafe key set.
+        private readonly ConcurrentDictionary<string, bool> _directoriesKnownToExist = new ConcurrentDictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// Force the copy to retry even when it hits ERROR_ACCESS_DENIED -- normally we wouldn't retry in this case since 
         /// normally there's no point, but occasionally things get into a bad state temporarily, and retrying does actually 
         /// succeed.  So keeping around a secret environment variable to allow forcing that behavior if necessary.  
         /// </summary>
-        private static bool s_alwaysRetryCopy = Environment.GetEnvironmentVariable("MSBUILDALWAYSRETRY") != null;
+        private static bool s_alwaysRetryCopy = Environment.GetEnvironmentVariable(AlwaysRetryEnvVar) != null;
+
+        /// <summary>
+        /// Global flag to force on UseSymboliclinksIfPossible since Microsoft.Common.targets doesn't expose the functionality.
+        /// </summary>
+        private static readonly bool s_forceSymlinks = Environment.GetEnvironmentVariable("MSBuildUseSymboliclinksIfPossible") != null;
+
+        private static readonly int s_parallelism = GetParallelismFromEnvironment();
 
         /// <summary>
         /// Default milliseconds to wait between necessary retries
@@ -70,7 +96,7 @@ public Copy()
         /// <summary>
         /// Create Symbolic Links for the copied files rather than copy the files if possible to do so
         /// </summary>
-        public bool UseSymboliclinksIfPossible { get; set; }
+        public bool UseSymboliclinksIfPossible { get; set; } = s_forceSymlinks;
 
         public bool SkipUnchangedFiles { get; set; }
 
@@ -104,14 +130,13 @@ public void Cancel()
         /// </summary>
         /// <param name="sourceFile">The source file</param>
         /// <param name="destinationFile">The destination file</param>
-        /// <returns></returns>
         private static bool IsMatchingSizeAndTimeStamp
         (
             FileState sourceFile,
             FileState destinationFile
         )
         {
-            // If the destination doesn't exists, then it is not a matching file.
+            // If the destination doesn't exist, then it is not a matching file.
             if (!destinationFile.FileExists)
             {
                 return false;
@@ -133,13 +158,13 @@ FileState destinationFile
         /// <summary>
         /// INTERNAL FOR UNIT-TESTING ONLY
         /// 
-        /// We've got several environment variables that we read into statics since we don't expect them to ever 
-        /// reasonably change, but we need some way of refreshing their values so that we can modify them for 
-        /// unit testing purposes. 
+        /// We've got several environment variables that we read into statics since we don't expect them to ever
+        /// reasonably change, but we need some way of refreshing their values so that we can modify them for
+        /// unit testing purposes.
         /// </summary>
         internal static void RefreshInternalEnvironmentValues()
         {
-            s_alwaysRetryCopy = Environment.GetEnvironmentVariable("MSBUILDALWAYSRETRY") != null;
+            s_alwaysRetryCopy = Environment.GetEnvironmentVariable(AlwaysRetryEnvVar) != null;
         }
 
         /// <summary>
@@ -158,8 +183,6 @@ private void LogDiagnostic(string message, params object[] messageArgs)
         /// Copy one file from source to destination. Create the target directory if necessary and 
         /// leave the file read-write.
         /// </summary>
-        /// <param name="sourceFileState"></param>
-        /// <param name="destinationFileState"></param>
         /// <returns>Return true to indicate success, return false to indicate failure and NO retry, return NULL to indicate retry.</returns>
         private bool? CopyFileWithLogging
         (
@@ -193,7 +216,7 @@ FileState destinationFileState  // The destination file
 
             string destinationFolder = Path.GetDirectoryName(destinationFileState.Name);
 
-            if (!string.IsNullOrEmpty(destinationFolder) && !_directoriesKnownToExist.Contains(destinationFolder))
+            if (!string.IsNullOrEmpty(destinationFolder) && !_directoriesKnownToExist.ContainsKey(destinationFolder))
             {
                 if (!Directory.Exists(destinationFolder))
                 {
@@ -204,7 +227,7 @@ FileState destinationFileState  // The destination file
                 // It's very common for a lot of files to be copied to the same folder. 
                 // Eg., "c:\foo\a"->"c:\bar\a", "c:\foo\b"->"c:\bar\b" and so forth.
                 // We don't want to check whether this folder exists for every single file we copy. So store which we've checked.
-                _directoriesKnownToExist.Add(destinationFolder);
+                _directoriesKnownToExist.TryAdd(destinationFolder, true);
             }
 
             if (OverwriteReadOnlyFiles)
@@ -304,17 +327,20 @@ private void MakeFileWriteable(FileState file, bool logActivity)
         /// Copy the files.
         /// </summary>
         /// <param name="copyFile">Delegate used to copy the files.</param>
-        /// <returns></returns>
+        /// <param name="parallelism">
+        /// Thread parallelism allowed during copies. 1 uses the original algorithm, >1 uses newer algorithm.
+        /// </param>
         internal bool Execute
         (
-            CopyFileWithState copyFile
+            CopyFileWithState copyFile,
+            int parallelism
         )
         {
             // If there are no source files then just return success.
             if (SourceFiles == null || SourceFiles.Length == 0)
             {
-                DestinationFiles = Array.Empty<TaskItem>();
-                CopiedFiles = Array.Empty<TaskItem>();
+                DestinationFiles = Array.Empty<ITaskItem>();
+                CopiedFiles = Array.Empty<ITaskItem>();
                 return true;
             }
 
@@ -323,29 +349,51 @@ CopyFileWithState copyFile
                 return false;
             }
 
-            bool success = true;
-
             // Environment variable stomps on user-requested value if it's set. 
-            if (Environment.GetEnvironmentVariable("MSBUILDALWAYSOVERWRITEREADONLYFILES") != null)
+            if (Environment.GetEnvironmentVariable(AlwaysOverwriteReadOnlyFilesEnvVar) != null)
             {
                 OverwriteReadOnlyFiles = true;
             }
 
-            // Build up the sucessfully copied subset
-            var destinationFilesSuccessfullyCopied = new List<ITaskItem>();
+            // Track successfully copied subset.
+            List <ITaskItem> destinationFilesSuccessfullyCopied;
+            bool success = parallelism == 1
+                ? CopySingleThreaded(copyFile, out destinationFilesSuccessfullyCopied)
+                : CopyParallel(copyFile, parallelism, out destinationFilesSuccessfullyCopied);
+
+            // copiedFiles contains only the copies that were successful.
+            CopiedFiles = destinationFilesSuccessfullyCopied.ToArray();
+
+            return success && !_canceling;
+        }
+
+        /// <summary>
+        /// Original copy code that performs single-threaded copies.
+        /// Kept as-is for comparison to parallel algo. We can eliminate this algo once that has enough mileage
+        /// (parallelism=1 can be handled by the ActionBlock in the parallel implementation).
+        /// </summary>
+        private bool CopySingleThreaded(
+            CopyFileWithState copyFile,
+            out List<ITaskItem> destinationFilesSuccessfullyCopied)
+        {
+            bool success = true;
+            destinationFilesSuccessfullyCopied = new List<ITaskItem>();
 
             // Set of files we actually copied and the location from which they were originally copied.  The purpose
             // of this collection is to let us skip copying duplicate files.  We will only copy the file if it 
             // either has never been copied to this destination before (key doesn't exist) or if we have copied it but
             // from a different location (value is different.)
             // { dest -> source }
-            Dictionary<string, string> filesActuallyCopied = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+            var filesActuallyCopied = new Dictionary<string, string>(
+                DestinationFiles.Length, // Set length to common case of 1:1 source->dest.
+                StringComparer.OrdinalIgnoreCase);
 
             // Now that we have a list of destinationFolder files, copy from source to destinationFolder.
             for (int i = 0; i < SourceFiles.Length && !_canceling; ++i)
             {
                 bool copyComplete = false;
-                if (filesActuallyCopied.TryGetValue(DestinationFiles[i].ItemSpec, out string originalSource))
+                string destPath = DestinationFiles[i].ItemSpec;
+                if (filesActuallyCopied.TryGetValue(destPath, out string originalSource))
                 {
                     if (String.Equals(originalSource, SourceFiles[i].ItemSpec, StringComparison.OrdinalIgnoreCase))
                     {
@@ -358,7 +406,7 @@ CopyFileWithState copyFile
                 {
                     if (DoCopyIfNecessary(new FileState(SourceFiles[i].ItemSpec), new FileState(DestinationFiles[i].ItemSpec), copyFile))
                     {
-                        filesActuallyCopied[DestinationFiles[i].ItemSpec] = SourceFiles[i].ItemSpec;
+                        filesActuallyCopied[destPath] = SourceFiles[i].ItemSpec;
                         copyComplete = true;
                     }
                     else
@@ -374,15 +422,136 @@ CopyFileWithState copyFile
                 }
             }
 
-            // copiedFiles contains only the copies that were successful.
-            CopiedFiles = destinationFilesSuccessfullyCopied.ToArray();
+            return success;
+        }
 
-            return success && !_canceling;
+        /// <summary>
+        /// Parallelize I/O with the same semantics as the single-threaded copy method above.
+        /// ResolveAssemblyReferences tends to generate longer and longer lists of files to send
+        /// to CopyTask as we get further and further down the dependency graph.
+        /// The OS can handle a lot of parallel I/O so let's minimize wall clock time to get
+        /// it all done.
+        /// </summary>
+        private bool CopyParallel(
+            CopyFileWithState copyFile,
+            int parallelism,
+            out List<ITaskItem> destinationFilesSuccessfullyCopied)
+        {
+            bool success = true;
+
+            // We must supply the same semantics as the single-threaded version above:
+            //
+            // - For copy operations in the list that have the same destination, we must
+            //   provide for in-order copy attempts that allow re-copying different files
+            //   and avoiding copies for later files that match SkipUnchangedFiles semantics.
+            //   We must also add a destination file copy item for each attempt.
+            // - The order of entries in destinationFilesSuccessfullyCopied must match
+            //   the order of entries passed in, along with copied metadata.
+            // - Metadata must not be copied to destination item if the copy operation failed.
+            //
+            // We split the work into different Tasks:
+            //
+            // - Entries with unique destination file paths each get their own parallel operation.
+            // - Each subset of copies into the same destination get their own Task to run
+            //   the single-threaded logic in order.
+            //
+            // At the end we reassemble the result list in the same order as was passed in.
+
+            // Map: Destination path -> indexes in SourceFiles/DestinationItems array indices (ordered low->high).
+            var partitionsByDestination = new Dictionary<string, List<int>>(
+                DestinationFiles.Length, // Set length to common case of 1:1 source->dest.
+                StringComparer.OrdinalIgnoreCase);
+
+            for (int i = 0; i < SourceFiles.Length && !_canceling; ++i)
+            {
+                ITaskItem destItem = DestinationFiles[i];
+                string destPath = destItem.ItemSpec;
+                if (!partitionsByDestination.TryGetValue(destPath, out List<int> sourceIndices))
+                {
+                    // Use 1 for list length - common case is for no destination overlap.
+                    sourceIndices = new List<int>(1);
+                    partitionsByDestination[destPath] = sourceIndices;
+                }
+                sourceIndices.Add(i);
+            }
+
+            var successIndices = new ConcurrentBag<int>();
+            var actionBlockOptions = new ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = parallelism };
+            var partitionCopyActionBlock = new ActionBlock<List<int>>(
+                async (List<int> partition) =>
+                {
+                    // Break from synchronous thread context of caller to get onto thread pool thread.
+                    await System.Threading.Tasks.Task.Yield();
+
+                    for (int partitionIndex = 0; partitionIndex < partition.Count; partitionIndex++)
+                    {
+                        int fileIndex = partition[partitionIndex];
+                        ITaskItem sourceItem = SourceFiles[fileIndex];
+                        ITaskItem destItem = DestinationFiles[fileIndex];
+                        string sourcePath = sourceItem.ItemSpec;
+
+                        // Check if we just copied from this location to the destination, don't copy again.
+                        bool copyComplete = partitionIndex > 0 &&
+                                            String.Equals(
+                                                sourcePath,
+                                                SourceFiles[partition[partitionIndex - 1]].ItemSpec,
+                                                StringComparison.OrdinalIgnoreCase);
+
+                        if (!copyComplete)
+                        {
+                            if (DoCopyIfNecessary(
+                                new FileState(sourceItem.ItemSpec),
+                                new FileState(destItem.ItemSpec),
+                                copyFile))
+                            {
+                                copyComplete = true;
+                            }
+                            else
+                            {
+                                // Thread race to set outer variable but they race to set the same (false) value.
+                                success = false;
+                            }
+                        }
+
+                        if (copyComplete)
+                        {
+                            sourceItem.CopyMetadataTo(destItem);
+                            successIndices.Add(fileIndex);
+                        }
+                    }
+                },
+                actionBlockOptions);
+
+            foreach (List<int> partition in partitionsByDestination.Values)
+            {
+                bool partitionAccepted = partitionCopyActionBlock.Post(partition);
+                if (!partitionAccepted)
+                {
+                    // Retail assert...
+                    throw new InvalidOperationException(
+                        "BUGCHECK: Failed posting a file copy to an ActionBlock. Should not happen with block at max int capacity");
+                }
+            }
+
+            partitionCopyActionBlock.Complete();
+            partitionCopyActionBlock.Completion.GetAwaiter().GetResult();
+
+            // Assemble an in-order list of destination items that succeeded.
+            destinationFilesSuccessfullyCopied = new List<ITaskItem>(successIndices.Count);
+            int[] successIndicesSorted = successIndices.ToArray();
+            Array.Sort(successIndicesSorted);
+            foreach (int successIndex in successIndicesSorted)
+            {
+                destinationFilesSuccessfullyCopied.Add(DestinationFiles[successIndex]);
+            }
+
+            return success;
         }
 
         /// <summary>
         /// Verify that the inputs are correct.
         /// </summary>
+        /// <returns>False on an error, implying that the overall copy operation should be aborted.</returns>
         private bool ValidateInputs()
         {
             if (Retries < 0)
@@ -418,7 +587,7 @@ private bool ValidateInputs()
                 return false;
             }
 
-            //First check if create hard or symbolic link option is selected. If both then return an error
+            // First check if create hard or symbolic link option is selected. If both then return an error
             if (UseHardlinksIfPossible & UseSymboliclinksIfPossible)
             {
                 Log.LogErrorWithCodeFromResources("Copy.ExactlyOneTypeOfLink", "UseHardlinksIfPossible", "UseSymboliclinksIfPossible");
@@ -431,7 +600,7 @@ private bool ValidateInputs()
         /// <summary>
         /// Set up our list of destination files.
         /// </summary>
-        /// <returns></returns>
+        /// <returns>False if an error occurred, implying aborting the overall copy operation.</returns>
         private bool InitializeDestinationFiles()
         {
             if (DestinationFiles == null)
@@ -471,10 +640,7 @@ private bool InitializeDestinationFiles()
         /// <summary>
         /// Copy source to destination, unless SkipUnchangedFiles is true and they are equivalent.
         /// </summary>
-        /// <param name="sourceFileState"></param>
-        /// <param name="destinationFileState"></param>
-        /// <param name="copyFile"></param>
-        /// <returns></returns>
+        /// <returns>True if the file was copied or, on SkipUnchangedFiles, the file was equivalent.</returns>
         private bool DoCopyIfNecessary(FileState sourceFileState, FileState destinationFileState, CopyFileWithState copyFile)
         {
             bool success = true;
@@ -671,9 +837,11 @@ private static string GetLockedFileMessage(string file)
         /// <returns></returns>
         public override bool Execute()
         {
-            return Execute(CopyFileWithLogging);
+            return Execute(CopyFileWithLogging, s_parallelism);
         }
 
+        #endregion
+
         /// <summary>
         /// Compares two paths to see if they refer to the same file. We can't solve the general
         /// canonicalization problem, so we just compare strings on the full paths.
@@ -694,6 +862,22 @@ private static bool PathsAreIdentical(string source, string destination)
             return (0 == String.Compare(fullSourcePath, fullDestinationPath, filenameComparison));
         }
 
-        #endregion
+    	private static int GetParallelismFromEnvironment()
+        {
+            string parallelismSetting = Environment.GetEnvironmentVariable("MSBuildCopyThreadParallelism");
+            if (int.TryParse(parallelismSetting, out int parallelism) && parallelism >= 0)
+            {
+                if (parallelism == 0)
+                {
+                    parallelism = int.MaxValue;
+                }
+            }
+            else
+            {
+                parallelism = DefaultCopyParallelism;
+            }
+
+            return parallelism;
+        }
     }
 }
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index a2cb5da18b9..54e4cfd2e15 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -948,6 +948,7 @@
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="$(VisualStudioSetupInteropVersion)" />
     <PackageReference Include="System.Collections.Immutable" Version="1.3.1" />
+    <PackageReference Include="System.Threading.Tasks.Dataflow" Version="4.5.24.0" />
 
     <!-- Reference compilers package without using assets, so we can copy them to the output directory under the Roslyn folder -->
     <PackageReference Include="Microsoft.Net.Compilers" Version="$(MicrosoftNetCompilersVersion)" ExcludeAssets="All" />
@@ -961,6 +962,7 @@
     <PackageReference Include="System.Reflection.Metadata" Version="1.3.0" />
     <PackageReference Include="System.Reflection.TypeExtensions" Version="4.1.0" />
     <PackageReference Include="System.Resources.Writer" Version="4.0.0" />
+    <PackageReference Include="System.Threading.Tasks.Dataflow" Version="4.6.0" />
 
     <!-- Reference compilers package without using assets, so we can copy them to the output directory under the Roslyn folder -->
     <PackageReference Include="Microsoft.NETCore.Compilers" Version="$(MicrosoftNetCoreCompilersVersion)" ExcludeAssets="All" />
@@ -969,7 +971,6 @@
   <ItemGroup Condition="'$(MonoBuild)' == 'true'">
     <PackageReference Include="System.Reflection.Metadata" Version="1.3.0" />
   </ItemGroup>
-
   <ItemGroup>
     <!--
       Content items in this project are used to copy files to the output directory but we don't
@@ -978,4 +979,4 @@
     -->
     <Content Update="@(Content)" Pack="false" />
   </ItemGroup>
-</Project>
\ No newline at end of file
+</Project>
