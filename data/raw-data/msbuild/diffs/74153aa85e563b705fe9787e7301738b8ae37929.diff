diff --git a/src/Deprecated/Engine/LocalProvider/LocalNode.cs b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
deleted file mode 100644
index d957cf840bb..00000000000
--- a/src/Deprecated/Engine/LocalProvider/LocalNode.cs
+++ /dev/null
@@ -1,684 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-// THE ASSEMBLY BUILT FROM THIS SOURCE FILE HAS BEEN DEPRECATED FOR YEARS. IT IS BUILT ONLY TO PROVIDE
-// BACKWARD COMPATIBILITY FOR API USERS WHO HAVE NOT YET MOVED TO UPDATED APIS. PLEASE DO NOT SEND PULL
-// REQUESTS THAT CHANGE THIS FILE WITHOUT FIRST CHECKING WITH THE MAINTAINERS THAT THE FIX IS REQUIRED.
-
-using System;
-using System.Collections;
-using System.Diagnostics;
-using System.IO;
-using System.Security.AccessControl;
-using System.Threading;
-using Microsoft.Build.BuildEngine.Shared;
-using Microsoft.Build.Shared;
-
-namespace Microsoft.Build.BuildEngine
-{
-    /// <summary>
-    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
-    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
-    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
-    /// 
-    /// This class hosts a node class in the child process. It uses shared memory to communicate
-    /// with the local node provider.
-    /// Wraps a Node.
-    /// </summary>
-    /// <remarks>
-    /// <format type="text/markdown"><![CDATA[
-    /// ## Remarks
-    /// > [!WARNING]
-    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// > <xref:Microsoft.Build.Construction>
-    /// > <xref:Microsoft.Build.Evaluation>
-    /// > <xref:Microsoft.Build.Execution>
-    /// ]]></format>
-    /// </remarks>
-    public class LocalNode
-    {
-        #region Static Constructors
-        /// <summary>
-        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
-        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
-        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
-        /// 
-        /// Hook up an unhandled exception handler, in case our error handling paths are leaky
-        /// </summary>
-        /// <remarks>
-        /// <format type="text/markdown"><![CDATA[
-        /// ## Remarks
-        /// > [!WARNING]
-        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// > <xref:Microsoft.Build.Construction>
-        /// > <xref:Microsoft.Build.Evaluation>
-        /// > <xref:Microsoft.Build.Execution>
-        /// ]]></format>
-        /// </remarks>
-        static LocalNode()
-        {
-            AppDomain currentDomain = AppDomain.CurrentDomain;
-            currentDomain.UnhandledException += UnhandledExceptionHandler;
-        }
-        #endregion
-
-        #region Static Methods
-
-        /// <summary>
-        /// Dump any unhandled exceptions to a file so they can be diagnosed
-        /// </summary>
-        private static void UnhandledExceptionHandler(object sender, UnhandledExceptionEventArgs e)
-        {
-            Exception ex = (Exception)e.ExceptionObject;
-            DumpExceptionToFile(ex);
-        }
-
-        /// <summary>
-        /// Dump the exception information to a file
-        /// </summary>
-        internal static void DumpExceptionToFile(Exception ex)
-        {
-            // Lock as multiple threads may throw simultaneously
-            lock (dumpFileLocker)
-            {
-                if (dumpFileName == null)
-                {
-                    Guid guid = Guid.NewGuid();
-                    string tempPath = Path.GetTempPath();
-
-                    // For some reason we get Watson buckets because GetTempPath gives us a folder here that doesn't exist.
-                    // Either because %TMP% is misdefined, or because they deleted the temp folder during the build.
-                    if (!Directory.Exists(tempPath))
-                    {
-                        // If this throws, no sense catching it, we can't log it now, and we're here
-                        // because we're a child node with no console to log to, so die
-                        Directory.CreateDirectory(tempPath);
-                    }
-
-                    dumpFileName = Path.Combine(tempPath, "MSBuild_" + guid.ToString());
-
-                    using (StreamWriter writer = new StreamWriter(dumpFileName, true /*append*/))
-                    {
-                        writer.WriteLine("UNHANDLED EXCEPTIONS FROM CHILD NODE:");
-                        writer.WriteLine("===================");
-                    }
-                }
-
-                using (StreamWriter writer = new StreamWriter(dumpFileName, true /*append*/))
-                {
-                    writer.WriteLine(DateTime.Now.ToLongTimeString());
-                    writer.WriteLine(ex.ToString());
-                    writer.WriteLine("===================");
-                }
-            }
-        }
-
-        #endregion
-
-        #region Constructors
-
-        /// <summary>
-        /// Creates an instance of this class.
-        /// </summary>
-        internal LocalNode(int nodeNumberIn)
-        {
-            this.nodeNumber = nodeNumberIn;
-
-            engineCallback = new LocalNodeCallback(communicationThreadExitEvent, this);
-        }
-
-        #endregion
-
-        #region Communication Methods
-
-        /// <summary>
-        /// This method causes the reader and writer threads to start and create the shared memory structures
-        /// </summary>
-        private void StartCommunicationThreads()
-        {
-            // The writer thread should be created before the
-            // reader thread because some LocalCallDescriptors
-            // assume the shared memory for the writer thread
-            // has already been created. The method will both
-            // instantiate the shared memory for the writer
-            // thread and also start the writer thread itself.
-            // We will verifyThrow in the method if the
-            // sharedMemory was not created correctly.
-            engineCallback.StartWriterThread(nodeNumber);
-
-            // Create the shared memory buffer
-            this.sharedMemory =
-                  new SharedMemory
-                  (
-                        // Generate the name for the shared memory region
-                        LocalNodeProviderGlobalNames.NodeInputMemoryName(nodeNumber),
-                        SharedMemoryType.ReadOnly,
-                        // Reuse an existing shared memory region as it should have already
-                        // been created by the parent node side
-                        true
-                  );
-
-            ErrorUtilities.VerifyThrow(this.sharedMemory.IsUsable,
-                "Failed to create shared memory for local node input.");
-
-            // Start the thread that will be processing the calls from the parent engine
-            ThreadStart threadState = new ThreadStart(this.SharedMemoryReaderThread);
-            readerThread = new Thread(threadState);
-            readerThread.Name = "MSBuild Child<-Parent Reader";
-            readerThread.Start();
-        }
-
-        /// <summary>
-        /// This method causes the reader and writer threads to exit and dispose of the shared memory structures
-        /// </summary>
-        private void StopCommunicationThreads()
-        {
-            communicationThreadExitEvent.Set();
-
-            // Wait for communication threads to exit
-            Thread writerThread = engineCallback.GetWriterThread();
-            // The threads may not exist if the child has timed out before the parent has told the node
-            // to start up its communication threads. This can happen if the node is started with /nodemode:x
-            // and no parent is running, or if the parent node has spawned a new process and then crashed
-            // before establishing communication with the child node.
-            writerThread?.Join();
-
-            readerThread?.Join();
-
-            // Make sure the exit event is not set
-            communicationThreadExitEvent.Reset();
-        }
-
-        #endregion
-
-        #region Startup Methods
-
-        /// <summary>
-        /// Create global events necessary for handshaking with the parent
-        /// </summary>
-        /// <param name="nodeNumber"></param>
-        /// <returns>True if events created successfully and false otherwise</returns>
-        private static bool CreateGlobalEvents(int nodeNumber)
-        {
-            bool createdNew;
-            if (NativeMethods.IsUserAdministrator())
-            {
-                EventWaitHandleSecurity mSec = new EventWaitHandleSecurity();
-
-                // Add a rule that grants the access only to admins and systems
-                mSec.SetSecurityDescriptorSddlForm(NativeMethods.ADMINONLYSDDL);
-
-                // Create an initiation event to allow the parent side  to prove to the child that we have the same level of privilege as it does.
-                // this is done by having the parent set this event which means it needs to have administrative permissions to do so.
-                globalInitiateActivationEvent = new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeInitiateActivationEventName(nodeNumber), out createdNew, mSec);
-            }
-            else
-            {
-                // Create an initiation event to allow the parent side  to prove to the child that we have the same level of privilege as it does.
-                // this is done by having the parent set this event which means it has atleast the same permissions as the child process
-                globalInitiateActivationEvent = new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeInitiateActivationEventName(nodeNumber), out createdNew);
-            }
-
-            // This process must be the creator of the event to prevent squating by a lower privilaged attacker
-            if (!createdNew)
-            {
-                return false;
-            }
-
-            // Informs the parent process that the child process has been created.
-            globalNodeActive = new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeActiveEventName(nodeNumber));
-            globalNodeActive.Set();
-
-            // Indicate to the parent process, this node is currently is ready to start to recieve requests
-            globalNodeInUse = new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeInUseEventName(nodeNumber));
-
-            // Used by the parent process to inform the child process to shutdown due to the child process
-            // not recieving the initialization command.
-            globalNodeErrorShutdown = new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeErrorShutdownEventName(nodeNumber));
-
-            // Inform the parent process the node has started its communication threads.
-            globalNodeActivate = new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeActivedEventName(nodeNumber));
-
-            return true;
-        }
-
-        /// <summary>
-        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
-        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
-        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
-        /// 
-        /// This function starts local node when process is launched and shuts it down on time out
-        /// Called by msbuild.exe.
-        /// </summary>
-        /// <remarks>
-        /// <format type="text/markdown"><![CDATA[
-        /// ## Remarks
-        /// > [!WARNING]
-        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// > <xref:Microsoft.Build.Construction>
-        /// > <xref:Microsoft.Build.Evaluation>
-        /// > <xref:Microsoft.Build.Execution>
-        /// ]]></format>
-        /// </remarks>
-        [System.Diagnostics.CodeAnalysis.SuppressMessage("Reliability", "CA2000:Dispose objects before losing scope", Justification = "Agreed not to touch entries from Deprecated folder")]
-        public static void StartLocalNodeServer(int nodeNumber)
-        {
-            // Create global events necessary for handshaking with the parent
-            if (!CreateGlobalEvents(nodeNumber))
-            {
-                return;
-            }
-
-            LocalNode localNode = new LocalNode(nodeNumber);
-
-            WaitHandle[] waitHandles = new WaitHandle[4];
-            waitHandles[0] = shutdownEvent;
-            waitHandles[1] = globalNodeErrorShutdown;
-            waitHandles[2] = inUseEvent;
-            waitHandles[3] = globalInitiateActivationEvent;
-
-            // This is necessary to make build.exe finish promptly. Dont remove.
-            if (!Engine.debugMode)
-            {
-                // Create null streams for the current input/output/error streams
-                Console.SetOut(new StreamWriter(Stream.Null));
-                Console.SetError(new StreamWriter(Stream.Null));
-                Console.SetIn(new StreamReader(Stream.Null));
-            }
-
-            bool continueRunning = true;
-
-            while (continueRunning)
-            {
-                int eventType = WaitHandle.WaitAny(waitHandles, inactivityTimeout, false);
-
-                if (eventType == 0 || eventType == 1 || eventType == WaitHandle.WaitTimeout)
-                {
-                    continueRunning = false;
-                    localNode.ShutdownNode(eventType != 1 ?
-                                           Node.NodeShutdownLevel.PoliteShutdown :
-                                           Node.NodeShutdownLevel.ErrorShutdown, true, true);
-                }
-                else if (eventType == 2)
-                {
-                    // reset the event as we do not want it to go into this state again when we are done with this if statement.
-                    inUseEvent.Reset();
-                    // The parent knows at this point the child process has been launched
-                    globalNodeActivate.Reset();
-                    // Set the global inuse event so other parent processes know this node is now initialized
-                    globalNodeInUse.Set();
-                    // Make a copy of the parents handle to protect ourselves in case the parent dies,
-                    // this is to prevent a parent from reserving a node another parent is trying to use.
-                    globalNodeReserveHandle =
-                        new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeReserveEventName(nodeNumber));
-                    WaitHandle[] waitHandlesActive = new WaitHandle[3];
-                    waitHandlesActive[0] = shutdownEvent;
-                    waitHandlesActive[1] = globalNodeErrorShutdown;
-                    waitHandlesActive[2] = notInUseEvent;
-
-                    eventType = WaitHandle.WaitTimeout;
-                    while (eventType == WaitHandle.WaitTimeout && continueRunning)
-                    {
-                        eventType = WaitHandle.WaitAny(waitHandlesActive, parentCheckInterval, false);
-
-                        if (eventType == 0 || /* nice shutdown due to shutdownEvent */
-                            eventType == 1 || /* error shutdown due to globalNodeErrorShutdown */
-                            (eventType == WaitHandle.WaitTimeout && !localNode.IsParentProcessAlive()))
-                        {
-                            continueRunning = false;
-                            // If the exit is not triggered by running of shutdown method
-                            if (eventType != 0)
-                            {
-                                localNode.ShutdownNode(Node.NodeShutdownLevel.ErrorShutdown, true, true);
-                            }
-                        }
-                        else if (eventType == 2)
-                        {
-                            // Trigger a collection before the node goes idle to insure that
-                            // the memory is released to the system as soon as possible
-                            GC.Collect();
-                            // Change the current directory to a safe one so that the directory
-                            // last used by the build can be safely deleted. We must have read
-                            // access to the safe directory so use SystemDirectory for this purpose.
-                            Directory.SetCurrentDirectory(Environment.SystemDirectory);
-                            notInUseEvent.Reset();
-                            globalNodeInUse.Reset();
-                        }
-                    }
-
-                    ErrorUtilities.VerifyThrow(localNode.node == null,
-                                               "Expected either node to be null or continueRunning to be false.");
-
-                    // Stop the communication threads and release the shared memory object so that the next parent can create it
-                    localNode.StopCommunicationThreads();
-                    // Close the local copy of the reservation handle (this allows another parent to reserve
-                    // the node)
-                    globalNodeReserveHandle.Close();
-                    globalNodeReserveHandle = null;
-                }
-                else if (eventType == 3)
-                {
-                    globalInitiateActivationEvent.Reset();
-                    localNode.StartCommunicationThreads();
-                    globalNodeActivate.Set();
-                }
-            }
-            // Stop the communication threads and release the shared memory object so that the next parent can create it
-            localNode.StopCommunicationThreads();
-
-            globalNodeActive.Close();
-            globalNodeInUse.Close();
-        }
-
-        #endregion
-
-        #region Methods
-
-        /// <summary>
-        /// This method is run in its own thread, it is responsible for reading messages sent from the parent process
-        /// through the shared memory region.
-        /// </summary>
-        private void SharedMemoryReaderThread()
-        {
-            // Create an array of event to the node thread responds
-            WaitHandle[] waitHandles = new WaitHandle[2];
-            waitHandles[0] = communicationThreadExitEvent;
-            waitHandles[1] = sharedMemory.ReadFlag;
-
-            bool continueExecution = true;
-
-            try
-            {
-                while (continueExecution)
-                {
-                    // Wait for the next work item or an exit command
-                    int eventType = WaitHandle.WaitAny(waitHandles);
-
-                    if (eventType == 0)
-                    {
-                        // Exit node event
-                        continueExecution = false;
-                    }
-                    else
-                    {
-                        // Read the list of LocalCallDescriptors from sharedMemory,
-                        // this will be null if a large object is being read from shared
-                        // memory and will continue to be null until the large object has
-                        // been completly sent.
-                        IList localCallDescriptorList = sharedMemory.Read();
-
-                        if (localCallDescriptorList != null)
-                        {
-                            foreach (LocalCallDescriptor callDescriptor in localCallDescriptorList)
-                            {
-                                // Execute the command method which relates to running on a child node
-                                callDescriptor.NodeAction(node, this);
-
-                                if ((callDescriptor.IsReply) && (callDescriptor is LocalReplyCallDescriptor))
-                                {
-                                    // Process the reply from the parent so it can be looked in a hashtable based
-                                    // on the call descriptor who requested the reply.
-                                    engineCallback.PostReplyFromParent((LocalReplyCallDescriptor)callDescriptor);
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-            catch (Exception e)
-            {
-                // Will rethrow the exception if necessary
-                ReportFatalCommunicationError(e);
-            }
-
-            // Dispose of the shared memory buffer
-            if (sharedMemory != null)
-            {
-                sharedMemory.Dispose();
-                sharedMemory = null;
-            }
-        }
-
-        /// <summary>
-        /// This method will shutdown the node being hosted by the child process and notify the parent process if requested,
-        /// </summary>
-        /// <param name="shutdownLevel">What kind of shutdown is causing the child node to shutdown</param>
-        /// <param name="exitProcess">should the child process exit as part of the shutdown process</param>
-        /// <param name="noParentNotification">Indicates if the parent process should be notified the child node is being shutdown</param>
-        internal void ShutdownNode(Node.NodeShutdownLevel shutdownLevel, bool exitProcess, bool noParentNotification)
-        {
-            if (node != null)
-            {
-                try
-                {
-                    node.ShutdownNode(shutdownLevel);
-
-                    if (!noParentNotification)
-                    {
-                        // Write the last event out directly
-                        LocalCallDescriptorForShutdownComplete callDescriptor =
-
-                            new LocalCallDescriptorForShutdownComplete(shutdownLevel, node.TotalTaskTime);
-                        // Post the message indicating that the shutdown is complete
-                        engineCallback.PostMessageToParent(callDescriptor, true);
-                    }
-                }
-                catch (Exception e)
-                {
-                    if (shutdownLevel != Node.NodeShutdownLevel.ErrorShutdown)
-                    {
-                        ReportNonFatalCommunicationError(e);
-                    }
-                }
-            }
-
-            // If the shutdownLevel is not a build complete message, then this means there was a politeshutdown or an error shutdown, null the node out
-            // as either it is no longer needed due to the node goign idle or there was a error and it is now in a bad state.
-            if (shutdownLevel != Node.NodeShutdownLevel.BuildCompleteSuccess &&
-                shutdownLevel != Node.NodeShutdownLevel.BuildCompleteFailure)
-            {
-                node = null;
-                notInUseEvent.Set();
-            }
-
-            if (exitProcess)
-            {
-                // Even if we completed a build, if we are goign to exit the process we need to null out the node and set the notInUseEvent, this is
-                // accomplished by calling this method again with the ErrorShutdown handle
-                if (shutdownLevel == Node.NodeShutdownLevel.BuildCompleteSuccess || shutdownLevel == Node.NodeShutdownLevel.BuildCompleteFailure)
-                {
-                    ShutdownNode(Node.NodeShutdownLevel.ErrorShutdown, false, true);
-                }
-                // Signal all the communication threads to exit
-                shutdownEvent.Set();
-            }
-        }
-
-        /// <summary>
-        /// This methods activates the local node
-        /// </summary>
-        internal void Activate
-        (
-            Hashtable environmentVariables,
-            LoggerDescription[] nodeLoggers,
-            int nodeId,
-            BuildPropertyGroup parentGlobalProperties,
-            ToolsetDefinitionLocations toolsetSearchLocations,
-            int parentId,
-            string parentStartupDirectory
-        )
-        {
-            ErrorUtilities.VerifyThrow(node == null, "Expected node to be null on activation.");
-
-            this.parentProcessId = parentId;
-
-            engineCallback.Reset();
-
-            inUseEvent.Set();
-
-            // Clear the environment so that we dont have extra variables laying around, this
-            // may be a performance hog but needs to be done
-            IDictionary variableDictionary = Environment.GetEnvironmentVariables();
-            foreach (string variableName in variableDictionary.Keys)
-            {
-                Environment.SetEnvironmentVariable(variableName, null);
-            }
-
-            foreach (string key in environmentVariables.Keys)
-            {
-                Environment.SetEnvironmentVariable(key, (string)environmentVariables[key]);
-            }
-
-            // Host the msbuild engine and system
-            node = new Node(nodeId, nodeLoggers, engineCallback, parentGlobalProperties, toolsetSearchLocations, parentStartupDirectory);
-
-            // Write the initialization complete event out directly
-            LocalCallDescriptorForInitializationComplete callDescriptor =
-                new LocalCallDescriptorForInitializationComplete(EnvironmentUtilities.CurrentProcessId);
-
-            // Post the message indicating that the initialization is complete
-            engineCallback.PostMessageToParent(callDescriptor, true);
-        }
-
-        /// <summary>
-        /// This method checks is the parent process has not exited
-        /// </summary>
-        /// <returns>True if the parent process is still alive</returns>
-        private bool IsParentProcessAlive()
-        {
-            bool isParentAlive = true;
-            try
-            {
-                // Check if the parent is still there
-                using Process parentProcess = Process.GetProcessById(parentProcessId);
-                if (parentProcess.HasExited)
-                {
-                    isParentAlive = false;
-                }
-            }
-            catch (ArgumentException)
-            {
-                isParentAlive = false;
-            }
-
-            if (!isParentAlive)
-            {
-                // No logging's going to reach the parent at this point:
-                // indicate on the console what's going on
-                string message = ResourceUtilities.FormatResourceString("ParentProcessUnexpectedlyDied", node.NodeId);
-                Console.WriteLine(message);
-            }
-
-            return isParentAlive;
-        }
-
-        /// <summary>
-        /// Any error occuring in the shared memory transport is considered to be fatal
-        /// </summary>
-        /// <param name="originalException"></param>
-        /// <exception cref="Exception">Re-throws exception passed in</exception>
-        internal void ReportFatalCommunicationError(Exception originalException)
-        {
-            try
-            {
-                DumpExceptionToFile(originalException);
-            }
-            finally
-            {
-                node?.ReportFatalCommunicationError(originalException, null);
-            }
-        }
-
-        /// <summary>
-        /// This function is used to report exceptions which don't indicate breakdown
-        /// of communication with the parent
-        /// </summary>
-        /// <param name="originalException"></param>
-        internal void ReportNonFatalCommunicationError(Exception originalException)
-        {
-            if (node != null)
-            {
-                try
-                {
-                    DumpExceptionToFile(originalException);
-                }
-                finally
-                {
-                    node.ReportUnhandledError(originalException);
-                }
-            }
-            else
-            {
-                // Since there is no node object report rethrow the exception
-                ReportFatalCommunicationError(originalException);
-            }
-        }
-
-        #endregion
-        #region Properties
-        internal static string DumpFileName
-        {
-            get
-            {
-                return dumpFileName;
-            }
-        }
-        #endregion
-
-        #region Member data
-
-        private Node node;
-        private SharedMemory sharedMemory;
-        private LocalNodeCallback engineCallback;
-        private int parentProcessId;
-        private int nodeNumber;
-        private Thread readerThread;
-        private static object dumpFileLocker = new Object();
-
-        // Public named events
-        // If this event is set the node host process is currently running
-        private static EventWaitHandle globalNodeActive;
-        // If this event is set the node is currently running a build
-        private static EventWaitHandle globalNodeInUse;
-        // If this event exists the node is reserved for use by a particular parent engine
-        // the node keeps a handle to this event during builds to prevent it from being used
-        // by another parent engine if the original dies
-        private static EventWaitHandle globalNodeReserveHandle;
-        // If this event is set the node will immediatelly exit. The event is used by the
-        // parent engine to cause the node to exit if communication is lost.
-        private static EventWaitHandle globalNodeErrorShutdown;
-        // This event is used to cause the child to create the shared memory structures to start communication
-        // with the parent
-        private static EventWaitHandle globalInitiateActivationEvent;
-        // This event is used to indicate to the parent that shared memory buffers have been created and are ready for
-        // use
-        private static EventWaitHandle globalNodeActivate;
-        // Private local events
-        private static ManualResetEvent communicationThreadExitEvent = new ManualResetEvent(false);
-        private static ManualResetEvent shutdownEvent = new ManualResetEvent(false);
-        private static ManualResetEvent notInUseEvent = new ManualResetEvent(false);
-
-        /// <summary>
-        /// Indicates the node is now in use. This means the node has recieved an activate command with initialization
-        /// data from the parent procss
-        /// </summary>
-        private static ManualResetEvent inUseEvent = new ManualResetEvent(false);
-
-        /// <summary>
-        /// Randomly generated file name for all exceptions thrown by this node that need to be dumped to a file.
-        /// (There may be more than one exception, if they occur on different threads.)
-        /// </summary>
-        private static string dumpFileName = null;
-
-        // Timeouts && Constants
-        private const int inactivityTimeout = 60 * 1000; // 60 seconds of inactivity to exit
-        private const int parentCheckInterval = 5 * 1000; // Check if the parent process is there every 5 seconds
-
-        #endregion
-
-    }
-}
-
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
deleted file mode 100644
index b97ae16dad6..00000000000
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
+++ /dev/null
@@ -1,1056 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-// THE ASSEMBLY BUILT FROM THIS SOURCE FILE HAS BEEN DEPRECATED FOR YEARS. IT IS BUILT ONLY TO PROVIDE
-// BACKWARD COMPATIBILITY FOR API USERS WHO HAVE NOT YET MOVED TO UPDATED APIS. PLEASE DO NOT SEND PULL
-// REQUESTS THAT CHANGE THIS FILE WITHOUT FIRST CHECKING WITH THE MAINTAINERS THAT THE FIX IS REQUIRED.
-
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Threading;
-using System.Globalization;
-using System.IO;
-using Microsoft.Build.BuildEngine.Shared;
-using System.Runtime.InteropServices;
-using Microsoft.Build.Shared;
-
-namespace Microsoft.Build.BuildEngine
-{
-    internal class LocalNodeProvider : INodeProvider
-    {
-        #region Methods implementing INodeProvider
-        public void Initialize
-        (
-            string configuration,
-            IEngineCallback parentEngineCallback,
-            BuildPropertyGroup parentGlobalPropertyGroup,
-            ToolsetDefinitionLocations toolSetSearchLocations,
-            string startupDirectory
-        )
-        {
-            // Get from the environment how long we should wait in seconds for shutdown to complete
-            string shutdownTimeoutFromEnvironment = Environment.GetEnvironmentVariable("MSBUILDNODESHUTDOWNTIMEOUT");
-            int result;
-            if (int.TryParse(shutdownTimeoutFromEnvironment, out result) && result >= 0)
-            {
-                shutdownTimeout = result;
-            }
-
-            this.cpuCount = 1;
-
-            if (configuration != null)
-            {
-                // Split out the parameter sets based on ;
-                string[] parameters = configuration.Split(parameterDelimiters);
-                // Go through each of the parameter name value pairs and split them appart
-                for (int param = 0; param < parameters.Length; param++)
-                {
-                    if (parameters[param].Length > 0)
-                    {
-                        string[] parameterComponents = parameters[param].Split(valueDelimiters);
-                        // If there is a name and value associated with the parameter, apply the paramter to the provider
-                        if (parameterComponents.Length == 2)
-                        {
-                            ApplyParameter(parameterComponents[0], parameterComponents[1]);
-                        }
-                        else // Only the parameter name is known, this could be for a boolean parameter
-                        {
-                            ApplyParameter(parameters[param], null);
-                        }
-                    }
-                }
-            }
-
-            /* If we dont get a path passed in as a parameter, we can only assume that our path
-             is in the current appdomain basedirectory, this is the base directory
-              that the assembly resolver uses to probe for assemblies
-           */
-            if (string.IsNullOrEmpty(this.locationOfMSBuildExe))
-            {
-                this.locationOfMSBuildExe = AppDomain.CurrentDomain.BaseDirectory;
-            }
-            if ((cpuCount - 1) <= 0)
-            {
-                return;
-            }
-
-            this.exitCommunicationThreads = new ManualResetEvent(false);
-
-            this.activeNodeCount = 0;
-            this.responseCountChangeEvent = new ManualResetEvent(false);
-
-            this.nodeStateLock = new object();
-            this.nodesToLaunch = new Queue<int>();
-            this.nodeLoggers = new List<LoggerDescription>();
-
-            nodeData = new LocalNodeInfo[cpuCount - 1];
-
-            // Initialize the internal state indicating that no nodes have been launched
-            int lastUsedNodeNumber = 0;
-            for (int i = 0; i < nodeData.Length; i++)
-            {
-                nodeData[i] = new LocalNodeInfo(lastUsedNodeNumber);
-                lastUsedNodeNumber = nodeData[i].NodeNumber + 1;
-            }
-
-            // Set up the callback
-            this.engineCallback = parentEngineCallback;
-            this.parentGlobalProperties = parentGlobalPropertyGroup;
-            this.toolsetSearchLocations = toolSetSearchLocations;
-            this.startupDirectory = startupDirectory;
-
-            // Default node settings
-            centralizedLogging = false;
-            onlyLogCriticalEvents = false;
-            useBreadthFirstTraversal = true;
-            shuttingDown = false;
-
-            // Start the thread that will be processing the calls from the parent engine
-            ThreadStart threadState = new ThreadStart(this.SharedMemoryWriterThread);
-            Thread taskThread = new Thread(threadState);
-            taskThread.Name = "MSBuild Parent->Child Writer";
-            taskThread.Start();
-            threadState = new ThreadStart(this.SharedMemoryReaderThread);
-            taskThread = new Thread(threadState);
-            taskThread.Name = "MSBuild Parent<-Child Reader";
-            taskThread.Start();
-        }
-
-        /// <summary>
-        /// Apply a parameter.
-        /// </summary>
-        public void ApplyParameter(string parameterName, string parameterValue)
-        {
-            ErrorUtilities.VerifyThrowArgumentNull(parameterName, nameof(parameterName));
-
-            if (String.Equals(parameterName, "MAXCPUCOUNT", StringComparison.OrdinalIgnoreCase))
-            {
-                try
-                {
-                    this.cpuCount = Convert.ToInt32(parameterValue, CultureInfo.InvariantCulture);
-                }
-                catch (FormatException)
-                {
-                    //
-                }
-                catch (OverflowException)
-                {
-                    //
-                }
-            }
-            else if (String.Equals(parameterName, "MSBUILDLOCATION", StringComparison.OrdinalIgnoreCase))
-            {
-                this.locationOfMSBuildExe = parameterValue;
-            }
-            else if (String.Equals(parameterName, "NODEREUSE", StringComparison.OrdinalIgnoreCase))
-            {
-                try
-                {
-                    // There does not seem to be a localizable function for this
-                    if (bool.Parse(parameterValue))
-                    {
-                        this.enableNodeReuse = true;
-                    }
-                    else
-                    {
-                        this.enableNodeReuse = false;
-                    }
-                }
-                catch (FormatException)
-                {
-                    //
-                }
-                catch (ArgumentNullException)
-                {
-                    //
-                }
-            }
-        }
-
-        public INodeDescription[] QueryNodeDescriptions()
-        {
-            return new INodeDescription[cpuCount - 1];
-        }
-
-        public void AssignNodeIdentifiers(int[] nodeIds)
-        {
-            if ((cpuCount - 1) <= 0)
-            {
-                return;
-            }
-
-            ErrorUtilities.VerifyThrow(nodeIds.Length == nodeData.Length, "Expected an ID for each node");
-
-            for (int i = 0; i < nodeIds.Length; i++)
-            {
-                nodeData[i].NodeId = nodeIds[i];
-            }
-        }
-
-        public void RegisterNodeLogger(LoggerDescription loggerDescription)
-        {
-            ErrorUtilities.VerifyThrow(nodeLoggers != null, "Must call Initialize first");
-            ErrorUtilities.VerifyThrow(loggerDescription != null, "Logger description should be non-null");
-
-            if (!nodeLoggers.Contains(loggerDescription))
-            {
-                nodeLoggers.Add(loggerDescription);
-            }
-        }
-
-        public void RequestNodeStatus(int nodeIndex, int requestId)
-        {
-            ErrorUtilities.VerifyThrow(nodeLoggers != null, "Must call Initialize first");
-            ErrorUtilities.VerifyThrow(nodeIndex < nodeData.Length && nodeIndex >= 0, "Node index must be within array boundaries");
-
-            // If the node has not been launched we need to create a reply
-            // on its behalf
-            if (nodeData[nodeIndex].NodeState != NodeState.Launched)
-            {
-                NodeStatus nodeStatus = new NodeStatus(requestId, false, 0, 0, 0, nodeData[nodeIndex].NodeState == NodeState.LaunchInProgress);
-                engineCallback.PostStatus(nodeData[nodeIndex].NodeId, nodeStatus, false);
-            }
-            else if (!IsNodeProcessAliveOrUninitialized(nodeIndex))
-            {
-                NodeStatus nodeStatus = new NodeStatus(requestId); // Indicate that the node has exited
-                engineCallback.PostStatus(nodeData[nodeIndex].NodeId, nodeStatus, false);
-            }
-            else
-            {
-                // Send the request to the node
-                LocalCallDescriptorForRequestStatus callDescriptor =
-                    new LocalCallDescriptorForRequestStatus(requestId);
-                nodeData[nodeIndex].NodeCommandQueue.Enqueue(callDescriptor);
-            }
-        }
-
-        public void PostBuildRequestToNode(int nodeIndex, BuildRequest buildRequest)
-        {
-            ErrorUtilities.VerifyThrow(nodeIndex < nodeData.Length && nodeIndex >= 0, "Node index must be within array boundaries");
-
-            if (nodeData[nodeIndex].NodeState != NodeState.Launched)
-            {
-                // Note that we have to check the node status again inside the mutex. This
-                // ensures that that after flipping the status to launched inside the mutex
-                // there will be no more writes to the queue of targets waiting to be sent
-                lock (nodeStateLock)
-                {
-                    // Check if we didn't initialize this node
-                    if (nodeData[nodeIndex].NodeState != NodeState.Launched && !shuttingDown)
-                    {
-                        // Check if launch is in progress
-                        if (nodeData[nodeIndex].NodeState == NodeState.NotLaunched)
-                        {
-                            nodeData[nodeIndex].NodeState = NodeState.LaunchInProgress;
-                            lock (nodesToLaunch)
-                            {
-                                nodesToLaunch.Enqueue(nodeIndex);
-                            }
-                            ThreadStart threadState = new ThreadStart(this.LaunchNodeAndPostBuildRequest);
-                            Thread taskThread = new Thread(threadState);
-                            taskThread.Name = "MSBuild Node Launcher";
-                            taskThread.Start();
-                        }
-                        nodeData[nodeIndex].TargetList.AddFirst(new LinkedListNode<BuildRequest>(buildRequest));
-                    }
-                    else
-                    {
-                        LocalCallDescriptorForPostBuildRequests callDescriptor =
-                            new LocalCallDescriptorForPostBuildRequests(buildRequest);
-                        nodeData[nodeIndex].NodeCommandQueue.Enqueue(callDescriptor);
-                    }
-                }
-            }
-            else
-            {
-                LocalCallDescriptorForPostBuildRequests callDescriptor =
-                    new LocalCallDescriptorForPostBuildRequests(buildRequest);
-                nodeData[nodeIndex].NodeCommandQueue.Enqueue(callDescriptor);
-            }
-        }
-
-        public void PostBuildResultToNode(int nodeIndex, BuildResult buildResult)
-        {
-            ErrorUtilities.VerifyThrow(nodeIndex < nodeData.Length && nodeIndex >= 0, "Node index must be within array boundaries");
-            ErrorUtilities.VerifyThrow(nodeData[nodeIndex].NodeState == NodeState.Launched, "Node must be launched before result can be posted");
-
-            LocalCallDescriptorForPostBuildResult callDescriptor =
-                    new LocalCallDescriptorForPostBuildResult(buildResult);
-            nodeData[nodeIndex].NodeCommandQueue.Enqueue(callDescriptor);
-        }
-
-        /// <summary>
-        /// Shutdown the nodes which are being tracked and managed by this localNodeProvider.
-        /// </summary>
-        public void ShutdownNodes(Node.NodeShutdownLevel nodeShutdownLevel)
-        {
-            // Indicate that nodes should no longer be launched
-            shuttingDown = true;
-
-            // Send out shutdown requests to all active  launched nodes
-            responseCount = activeNodeCount;
-            SendShutdownRequests(nodeShutdownLevel);
-
-            DateTime startTime = DateTime.Now;
-
-            // Wait for all nodes to shutdown
-            bool timeoutExpired = false;
-
-            // Loop until we are ready to shutdown. We are ready to shutdown when
-            // all nodes either have sent their shutdown completed response or they are dead.
-            // Secondly, we will exit the loop if our shudtownTimeout has expired
-            TimeSpan shutdownTimeoutSpan = new TimeSpan(0, 0, shutdownTimeout);
-            while (!ReadyToShutdown() && !timeoutExpired)
-            {
-                responseCountChangeEvent.WaitOne(shutdownResponseTimeout, false);
-                responseCountChangeEvent.Reset();
-
-                // Timeout when the loop has been executing for more than shutdownTimeout seconds.
-                timeoutExpired = DateTime.Now.Subtract(startTime) >= shutdownTimeoutSpan;
-            }
-
-            if (timeoutExpired)
-            {
-                foreach (LocalNodeInfo nodeInfo in nodeData)
-                {
-                    //Terminate all of the nodes which have valid processId's but for which we
-                    // have not recieved a shutdown response
-                    if (nodeInfo.ProcessId > 0 && !nodeInfo.ShutdownResponseReceived)
-                    {
-                        TerminateChildNode(nodeInfo.ProcessId);
-                    }
-                }
-            }
-
-            // Reset the shutdown response received properties incase the nodes are going
-            // to be used for another build on the same engine.
-            foreach (LocalNodeInfo nodeInfo in nodeData)
-            {
-                nodeInfo.ShutdownResponseReceived = false;
-            }
-
-            // If all nodes are exiting - exit the communication threads
-            if (nodeShutdownLevel != Node.NodeShutdownLevel.BuildCompleteSuccess &&
-                nodeShutdownLevel != Node.NodeShutdownLevel.BuildCompleteFailure)
-            {
-                exitCommunicationThreads.Set();
-            }
-
-            shuttingDown = false;
-        }
-
-        /// <summary>
-        /// Determine when the child node has either responsed with a shutdown complete event or the node has died
-        /// </summary>
-        internal bool ReadyToShutdown()
-        {
-            for (int i = 0; i < nodeData.Length; i++)
-            {
-                LocalNodeInfo nodeInfo = nodeData[i];
-                // Determine if the node is alive or dead, this check will set the processId to invalid if
-                // the process is dead
-                IsNodeProcessAliveOrUninitialized(i);
-                // If any node is still alive and we have not recieved a shutdown response say we are not ready to shutdown
-                if (nodeInfo.ProcessId > 0 && !nodeInfo.ShutdownResponseReceived)
-                {
-                    return false;
-                }
-            }
-            return true;
-        }
-        /// <summary>
-        /// TEMPORARY
-        /// </summary>
-        public void UpdateSettings
-        (
-            bool enableCentralizedLogging,
-            bool enableOnlyLogCriticalEvents,
-            bool useBreadthFirstTraversalSetting
-        )
-        {
-            this.centralizedLogging = enableCentralizedLogging;
-            this.onlyLogCriticalEvents = enableOnlyLogCriticalEvents;
-            this.useBreadthFirstTraversal = useBreadthFirstTraversalSetting;
-
-            for (int i = 0; i < nodeData.Length; i++)
-            {
-                if (nodeData[i].NodeState == NodeState.Launched)
-                {
-                    UpdateSettings(i);
-                }
-            }
-        }
-
-        private void UpdateSettings(int nodeIndex)
-        {
-            // Send the updated settings once the node has initialized
-            LocalCallDescriptorForUpdateNodeSettings callDescriptor =
-                  new LocalCallDescriptorForUpdateNodeSettings(onlyLogCriticalEvents, centralizedLogging, useBreadthFirstTraversal);
-            nodeData[nodeIndex].NodeCommandQueue.Enqueue(callDescriptor);
-        }
-
-        public void PostIntrospectorCommand(int nodeIndex, TargetInProgessState child, TargetInProgessState parent)
-        {
-            // Send the updated settings once the node has initialized
-            LocalCallDescriptorForPostIntrospectorCommand callDescriptor =
-                  new LocalCallDescriptorForPostIntrospectorCommand(child, parent);
-            nodeData[nodeIndex].NodeCommandQueue.Enqueue(callDescriptor);
-        }
-
-        #endregion
-
-        #region Private methods
-
-        /// <summary>
-        /// Send shutdown message to the launched child nodes.
-        /// </summary>
-        private void SendShutdownRequests(Node.NodeShutdownLevel nodeShutdownLevel)
-        {
-            for (int i = 0; i < nodeData.Length; i++)
-            {
-                // If there is a node launch in progress wait for it complete or fail
-                // before shutting down the node
-                while (nodeData[i].NodeState == NodeState.LaunchInProgress && !nodeData[i].CommunicationFailed)
-                {
-                    Thread.Sleep(500);
-                }
-
-                if (nodeData[i].NodeState == NodeState.Launched)
-                {
-                    if (!nodeData[i].CommunicationFailed)
-                    {
-                        bool exitProcess = !enableNodeReuse;
-                        // If we are shutting down due to a BuildComplete then dont kill the nodes as this method will be called again in the engine shutdown method
-                        if (nodeShutdownLevel == Node.NodeShutdownLevel.BuildCompleteSuccess || nodeShutdownLevel == Node.NodeShutdownLevel.BuildCompleteFailure)
-                        {
-                            exitProcess = false;
-                        }
-                        // Signal to the node to shutdown
-                        LocalCallDescriptorForShutdownNode callDescriptor =
-                            new LocalCallDescriptorForShutdownNode(nodeShutdownLevel, exitProcess);
-                        nodeData[i].NodeCommandQueue.Enqueue(callDescriptor);
-                    }
-                    else
-                    {
-                        TerminateChildNode(nodeData[i].ProcessId);
-                    }
-
-                    if (nodeShutdownLevel != Node.NodeShutdownLevel.BuildCompleteSuccess &&
-                        nodeShutdownLevel != Node.NodeShutdownLevel.BuildCompleteFailure)
-                    {
-                        nodeData[i].NodeState = NodeState.NotLaunched;
-                    }
-                }
-            }
-        }
-
-        /// <summary>
-        /// Kill the child process directly if we can't communicate with it
-        /// </summary>
-        private void TerminateChildNode(int processId)
-        {
-            try
-            {
-                using Process process = Process.GetProcessById(processId);
-                if (!process.HasExited)
-                {
-                    process.Kill();
-                }
-            }
-            catch (ArgumentException)
-            {
-                // The exception indicates that the child process is no longer running
-            }
-            catch (System.ComponentModel.Win32Exception)
-            {
-                // The exception indicates that the child process is no longer running or
-                // the parent cannot access the child process information due to insufficent security permissions
-            }
-        }
-
-        /// <summary>
-        /// Returns true if the process for the given node was started and has not exited
-        /// </summary>
-        private bool IsNodeProcessAliveOrUninitialized(int nodeId)
-        {
-            // If it's alive but not being communicated with anymore, that counts as not alive
-            if (nodeData[nodeId].CommunicationFailed)
-            {
-                return false;
-            }
-
-            try
-            {
-                bool isUninitialized = nodeData[nodeId].ProcessId == LocalNodeInfo.unInitializedProcessId;
-
-                if (isUninitialized)
-                {
-                    return true;
-                }
-
-                bool isInvalidProcessId = nodeData[nodeId].ProcessId == LocalNodeInfo.invalidProcessId;
-
-                if (!isInvalidProcessId)
-                {
-                    using Process process = Process.GetProcessById(nodeData[nodeId].ProcessId);
-                    if (!process.HasExited)
-                    {
-                        return true;
-                    }
-                    
-                }
-            }
-            catch (ArgumentException)
-            {
-                // Process already exited
-
-            }
-
-            nodeData[nodeId].ProcessId = LocalNodeInfo.invalidProcessId;
-            nodeData[nodeId].CommunicationFailed = true;
-
-            return false;
-        }
-
-        private void DecreaseActiveNodeCount(int nodeId)
-        {
-            int i = 0;
-            for (; i < nodeData.Length; i++)
-            {
-                if (nodeData[i].NodeId == nodeId)
-                {
-                    nodeData[i].ReleaseNode();
-                    Interlocked.Decrement(ref activeNodeCount);
-                    break;
-                }
-            }
-            ErrorUtilities.VerifyThrow(i < nodeData.Length, "Expected to find a node to decrement count");
-        }
-
-        /// <summary>
-        ///  This function is used to increment the count of active nodes
-        /// </summary>
-        private void IncreaseActiveNodeCount()
-        {
-            Interlocked.Increment(ref activeNodeCount);
-        }
-
-        /// <summary>
-        /// This function is used to decrement the count of active nodes
-        /// </summary>
-        internal void RecordNodeResponse(int nodeId, Node.NodeShutdownLevel shutdownLevel, int totalTaskTime)
-        {
-            // If the node is shutting down - decrease the count of active nodes
-            if (shutdownLevel == Node.NodeShutdownLevel.ErrorShutdown ||
-                shutdownLevel == Node.NodeShutdownLevel.PoliteShutdown)
-            {
-                DecreaseActiveNodeCount(nodeId);
-            }
-
-            //Console.WriteLine("Node " + nodeId + " Task Time " + totalTaskTime);
-
-            int i = 0;
-            for (; i < nodeData.Length; i++)
-            {
-                if (nodeData[i].NodeId == nodeId)
-                {
-                    nodeData[i].ShutdownResponseReceived = true;
-                    Interlocked.Decrement(ref responseCount);
-                    responseCountChangeEvent.Set();
-                    break;
-                }
-            }
-            ErrorUtilities.VerifyThrow(i < nodeData.Length, "Expected to find a node to decrement count");
-        }
-
-        /// <summary>
-        /// This function is used by the node to set its own processId after it has been initialized
-        /// </summary>
-        internal void SetNodeProcessId(int processId, int nodeId)
-        {
-            for (int i = 0; i < nodeData.Length; i++)
-            {
-                if (nodeData[i].NodeId == nodeId)
-                {
-                    nodeData[i].ProcessId = processId;
-                    break;
-                }
-            }
-        }
-
-        /// <summary>
-        /// This function will start a node and send requests to it
-        /// </summary>
-        private void LaunchNodeAndPostBuildRequest()
-        {
-            int nodeIndex = 0;
-
-            // Find out what node to launch
-            lock (nodesToLaunch)
-            {
-                nodeIndex = nodesToLaunch.Dequeue();
-            }
-
-            // If the provider is shutting down - don't launch the node
-            if (shuttingDown)
-            {
-                nodeData[nodeIndex].NodeState = NodeState.NotLaunched;
-                return;
-            }
-
-            try
-            {
-                // Either launch node or connect to an already running node
-                InitializeNode(nodeIndex);
-
-                if (!nodeData[nodeIndex].CommunicationFailed)
-                {
-                    // Change the state of the node to launched
-                    lock (nodeStateLock)
-                    {
-                        nodeData[nodeIndex].NodeState = NodeState.Launched;
-                    }
-
-                    // Send all the requests to the node. Note that the requests may end up in
-                    // mixed order with the request currently being posted.
-                    LinkedListNode<BuildRequest> current = nodeData[nodeIndex].TargetList.First;
-                    BuildRequest[] buildRequests = new BuildRequest[nodeData[nodeIndex].TargetList.Count];
-                    int i = 0;
-                    while (current != null)
-                    {
-                        buildRequests[i] = current.Value;
-                        i++;
-
-                        current = current.Next;
-                    }
-                    LocalCallDescriptorForPostBuildRequests callDescriptor =
-                            new LocalCallDescriptorForPostBuildRequests(buildRequests);
-                    nodeData[nodeIndex].NodeCommandQueue.Enqueue(callDescriptor);
-
-                    nodeData[nodeIndex].TargetList = null;
-                }
-                else
-                {
-                    // Allow the engine to decide how to proceed since the node failed to launch
-                    string message = ResourceUtilities.FormatResourceString("NodeProviderFailure");
-                    ReportNodeCommunicationFailure(nodeIndex, new Exception(message), false);
-                }
-            }
-            catch (Exception e)
-            {
-                // Allow the engine to deal with the exception
-                ReportNodeCommunicationFailure(nodeIndex, e, false);
-            }
-        }
-
-        /// <summary>
-        /// This function establishes communication with a node given an index. If a node
-        /// is not running it is launched.
-        /// </summary>
-        private void InitializeNode(int nodeIndex)
-        {
-            bool nodeConnected = false;
-            int restartCount = 0;
-
-            try
-            {
-                IncreaseActiveNodeCount();
-
-                while (!nodeConnected && restartCount < maximumNodeRestartCount)
-                {
-                    if (!checkIfNodeActive(nodeData[nodeIndex].NodeNumber))
-                    {
-                        // Attempt to launch a new node process
-                        LaunchNode(nodeIndex);
-                        // If we could not launch the node there is no reason to continue
-                        if (nodeData[nodeIndex].CommunicationFailed)
-                        {
-                            break;
-                        }
-                    }
-
-                    if (checkIfNodeActive(nodeData[nodeIndex].NodeNumber))
-                    {
-                        nodeData[nodeIndex].SharedMemoryToNode.Reset();
-                        nodeData[nodeIndex].SharedMemoryFromNode.Reset();
-
-                        // Activate the initiation event to prove to the child that we have the same level of privilege as it does. This operation will not fail because each privilege level creates
-                        // events in different namespaces
-                        EventWaitHandle nodeInitiateActivationEvent = new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeInitiateActivationEventName(nodeData[nodeIndex].NodeNumber));
-                        nodeInitiateActivationEvent.Set();
-                        nodeInitiateActivationEvent.Close();
-
-                        // Wait for node to indicate that it is activated
-                        EventWaitHandle nodeActivatedEvent = new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeActivedEventName(nodeData[nodeIndex].NodeNumber));
-                        nodeActivatedEvent.WaitOne(initializationTimeout, false);
-                        nodeActivatedEvent.Close();
-
-                        // Looked in Environment.cs the IDictionary is a HashTable
-                        IDictionary variableDictionary = Environment.GetEnvironmentVariables();
-                        Hashtable environmentVariablesTable = new Hashtable(variableDictionary);
-
-                        LocalCallDescriptorForInitializeNode callDescriptorInit =
-                                new LocalCallDescriptorForInitializeNode(environmentVariablesTable, nodeLoggers.ToArray(), nodeData[nodeIndex].NodeId, parentGlobalProperties, toolsetSearchLocations, EnvironmentUtilities.CurrentProcessId, startupDirectory);
-                        nodeData[nodeIndex].NodeCommandQueue.Enqueue(callDescriptorInit);
-
-                        EventWaitHandle nodeInUseEvent = new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeInUseEventName(nodeData[nodeIndex].NodeNumber));
-
-                        // Wait for node to indicate that it is ready. The node may time out and exit, between
-                        // when we check that it is active and before the initialization messages reaches it.
-                        // In that rare case we have to restart the node.
-                        if (nodeInUseEvent.WaitOne(initializationTimeout, false))
-                        {
-                            UpdateSettings(nodeIndex);
-                            nodeConnected = true;
-                        }
-                        nodeInUseEvent.Close();
-
-                        // If the node is still active and has not replied to the initialization message it must
-                        // be in bad state - try to get that node to exit
-                        if (!nodeConnected && checkIfNodeActive(nodeData[nodeIndex].NodeNumber))
-                        {
-                            EventWaitHandle nodeShutdownEvent = new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeErrorShutdownEventName(nodeData[nodeIndex].NodeNumber));
-                            nodeShutdownEvent.Set();
-                            nodeShutdownEvent.Close();
-
-                            restartCount = maximumNodeRestartCount;
-                        }
-
-                        restartCount++;
-                    }
-                }
-            }
-            finally
-            {
-                // Make sure to decrement the active node count if the communication has failed
-                if (!nodeConnected)
-                {
-                    DecreaseActiveNodeCount(nodeData[nodeIndex].NodeId);
-                    nodeData[nodeIndex].CommunicationFailed = true;
-                }
-            }
-        }
-
-        /// <summary>
-        /// This function attempts to find out if there is currently a node running
-        /// for a given index. The node is running if the global mutex with a
-        /// "Node_" + nodeId + "_ActiveReady" as a name was created
-        /// </summary>
-        private static bool checkIfNodeActive(int nodeNumber)
-        {
-            bool nodeIsActive = false;
-            EventWaitHandle nodeActiveHandle = null;
-            try
-            {
-                nodeActiveHandle = EventWaitHandle.OpenExisting(LocalNodeProviderGlobalNames.NodeActiveEventName(nodeNumber));
-                nodeIsActive = true;
-            }
-            catch (WaitHandleCannotBeOpenedException)
-            {
-                // Assume that the node is not running
-            }
-            finally
-            {
-                nodeActiveHandle?.Close();
-            }
-
-            return nodeIsActive;
-        }
-
-        /// <summary>
-        /// This function launches a new node given a node index
-        /// </summary>
-        private void LaunchNode(int nodeIndex)
-        {
-            EventWaitHandle nodeReadyEvent = null;
-
-            string msbuildLocation = Path.Combine(locationOfMSBuildExe, "MSBuild.exe");
-            ErrorUtilities.VerifyThrow(File.Exists(msbuildLocation), "Msbuild.exe cannot be found at: " + msbuildLocation);
-
-            bool exitedDueToError = true;
-            try
-            {
-                NativeMethods.STARTUPINFO startInfo = new NativeMethods.STARTUPINFO();
-                startInfo.cb = Marshal.SizeOf(startInfo);
-                uint dwCreationFlags = NativeMethods.NORMAL_PRIORITY_CLASS;
-                if (!Engine.debugMode)
-                {
-                    startInfo.hStdError = NativeMethods.InvalidHandle;
-                    startInfo.hStdInput = NativeMethods.InvalidHandle;
-                    startInfo.hStdOutput = NativeMethods.InvalidHandle;
-                    startInfo.dwFlags = NativeMethods.STARTF_USESTDHANDLES;
-                    dwCreationFlags |= NativeMethods.CREATE_NO_WINDOW;
-                }
-
-                NativeMethods.SECURITY_ATTRIBUTES pSec = new NativeMethods.SECURITY_ATTRIBUTES();
-                NativeMethods.SECURITY_ATTRIBUTES tSec = new NativeMethods.SECURITY_ATTRIBUTES();
-                pSec.nLength = Marshal.SizeOf(pSec);
-                tSec.nLength = Marshal.SizeOf(tSec);
-
-                NativeMethods.PROCESS_INFORMATION pInfo = new NativeMethods.PROCESS_INFORMATION();
-
-                string appName = msbuildLocation;
-                // Repeat the executable name as the first token of the command line because the command line
-                // parser logic expects it and will otherwise skip the first argument
-                string cmdLine = msbuildLocation + " /nologo /oldom /nodemode:" + nodeData[nodeIndex].NodeNumber;
-                NativeMethods.CreateProcess(appName, cmdLine,
-                                            ref pSec, ref tSec,
-                                            false, dwCreationFlags,
-                                            NativeMethods.NullPtr, null, ref startInfo, out pInfo);
-
-                nodeReadyEvent = new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeActiveEventName(nodeData[nodeIndex].NodeNumber));
-
-                // Wait until the node is ready to process the requests
-                if (nodeReadyEvent.WaitOne(launchTimeout, false))
-                {
-                    exitedDueToError = false;
-                }
-            }
-            finally
-            {
-                // Dispose before losing scope
-                nodeReadyEvent?.Close();
-
-                if (exitedDueToError)
-                {
-                    nodeData[nodeIndex].CommunicationFailed = true;
-                }
-            }
-        }
-
-        /// <summary>
-        /// Report communication failure and update internal state
-        /// </summary>
-        private void ReportNodeCommunicationFailure
-        (
-            int nodeIndex,
-            Exception innerException,
-            bool decreaseActiveNodeCount
-        )
-        {
-            // Indicate that communication with a particular node has failed
-            if (nodeIndex >= 0 && nodeIndex < nodeData.Length)
-            {
-                if (decreaseActiveNodeCount && !nodeData[nodeIndex].CommunicationFailed)
-                {
-                    DecreaseActiveNodeCount(nodeData[nodeIndex].NodeId);
-                }
-
-                nodeData[nodeIndex].CommunicationFailed = true;
-            }
-
-            string message = ResourceUtilities.FormatResourceString("NodeProviderFailure");
-            RemoteErrorException wrappedException = new RemoteErrorException(message, innerException, null);
-            NodeStatus nodeStatus = new NodeStatus(wrappedException);
-
-            if (nodeIndex < 0 || nodeIndex >= nodeData.Length)
-            {
-                // Bogus node index came out of the wait handle, perhaps due to memory pressure
-                // We can't really do anything except re-throw so this problem can be diagnosed.
-                throw wrappedException;
-            }
-
-            engineCallback.PostStatus(nodeData[nodeIndex].NodeId, nodeStatus, false);
-        }
-
-        /// <summary>
-        /// This thread writes out the messages to the shared memory, where the LocalNode class
-        /// reads it.
-        /// </summary>
-        private void SharedMemoryWriterThread()
-        {
-            // Create an array of event to the node thread responds
-            WaitHandle[] waitHandles = new WaitHandle[1 + nodeData.Length];
-            waitHandles[0] = exitCommunicationThreads;
-            for (int i = 0; i < nodeData.Length; i++)
-            {
-                waitHandles[i + 1] = nodeData[i].NodeCommandQueue.QueueReadyEvent;
-            }
-
-            bool continueExecution = true;
-
-            while (continueExecution)
-            {
-                int nodeIndex = -1;
-                try
-                {
-                    // Wait for the next work item or an exit command
-                    int eventType = WaitHandle.WaitAny(waitHandles);
-
-                    if (eventType == 0)
-                    {
-                        // Exit node event
-                        continueExecution = false;
-                    }
-                    else
-                    {
-                        nodeIndex = eventType - 1;
-                        nodeData[nodeIndex].SharedMemoryToNode.Write(nodeData[nodeIndex].NodeCommandQueue, nodeData[nodeIndex].NodeHiPriCommandQueue, false);
-                    }
-                }
-                catch (Exception e)
-                {
-                    // Ignore the queue of commands to the node that failed
-                    if (nodeIndex >= 0 && nodeIndex < nodeData.Length)
-                    {
-                        waitHandles[1 + nodeIndex] = new ManualResetEvent(false);
-                    }
-                    ReportNodeCommunicationFailure(nodeIndex, e, true);
-                }
-            }
-
-            for (int i = 0; i < nodeData.Length; i++)
-            {
-                // Dispose of the shared memory buffer
-                if (nodeData[i].SharedMemoryToNode != null)
-                {
-                    nodeData[i].SharedMemoryToNode.Dispose();
-                    nodeData[i].SharedMemoryToNode = null;
-                }
-            }
-        }
-
-        /// <summary>
-        /// This thread is responsible for reading messages from the nodes. The messages are posted
-        /// to the shared memory by the LocalNodeCallback
-        /// </summary>
-        private void SharedMemoryReaderThread()
-        {
-            // Create an array of event to the node thread responds
-            WaitHandle[] waitHandles = new WaitHandle[1 + nodeData.Length];
-            waitHandles[0] = exitCommunicationThreads;
-            for (int i = 0; i < nodeData.Length; i++)
-            {
-                waitHandles[i + 1] = nodeData[i].SharedMemoryFromNode.ReadFlag;
-            }
-
-            bool continueExecution = true;
-
-            while (continueExecution)
-            {
-                int nodeIndex = -1;
-                try
-                {
-                    // Wait for the next work item or an exit command
-                    int eventType = WaitHandle.WaitAny(waitHandles);
-
-                    if (eventType == 0)
-                    {
-                        // Exit node event
-                        continueExecution = false;
-                    }
-                    else
-                    {
-                        nodeIndex = eventType - 1;
-                        IList localCallDescriptorList = nodeData[nodeIndex].SharedMemoryFromNode.Read();
-
-                        if (localCallDescriptorList != null)
-                        {
-                            foreach (LocalCallDescriptor callDescriptor in localCallDescriptorList)
-                            {
-                                // Act as requested by the call
-                                callDescriptor.HostAction(engineCallback, this, nodeData[nodeIndex].NodeId);
-                                // Check if there is a reply to this call
-                                if (callDescriptor.NeedsReply)
-                                {
-                                    nodeData[nodeIndex].NodeCommandQueue.Enqueue(callDescriptor.ReplyFromHostAction());
-                                }
-                            }
-                        }
-                    }
-                }
-                catch (Exception e)
-                {
-                    ReportNodeCommunicationFailure(nodeIndex, e, true);
-                    // Ignore the events reported from that node from now on
-                    if (nodeIndex >= 0 && nodeIndex < nodeData.Length)
-                    {
-                        waitHandles[1 + nodeIndex] = new ManualResetEvent(false);
-                    }
-                }
-            }
-
-            // Dispose of shared memory when done
-            for (int i = 0; i < nodeData.Length; i++)
-            {
-                // Dispose of the shared memory buffer
-                if (nodeData[i].SharedMemoryFromNode != null)
-                {
-                    nodeData[i].SharedMemoryFromNode.Dispose();
-                    nodeData[i].SharedMemoryFromNode = null;
-                }
-            }
-        }
-
-        #endregion
-
-        #region Data
-        private IEngineCallback engineCallback;
-        private ManualResetEvent exitCommunicationThreads;
-
-        private ManualResetEvent responseCountChangeEvent;
-        private int activeNodeCount;
-        private int responseCount;
-
-        private int cpuCount;
-
-        private object nodeStateLock;
-        private Queue<int> nodesToLaunch;
-
-        private bool centralizedLogging;
-
-        private bool onlyLogCriticalEvents;
-
-        private bool useBreadthFirstTraversal;
-
-        private bool enableNodeReuse = true;
-
-        // True after shut down has been called, this flag prevents launching of new nodes after shutdown has been called
-        private bool shuttingDown;
-
-        private List<LoggerDescription> nodeLoggers;
-
-        private string locationOfMSBuildExe = null;
-
-        private BuildPropertyGroup parentGlobalProperties;
-        private ToolsetDefinitionLocations toolsetSearchLocations;
-        private string startupDirectory;
-
-        private static readonly char[] parameterDelimiters = { ';' };
-        private static readonly char[] valueDelimiters = { '=' };
-
-        private LocalNodeInfo[] nodeData;
-
-        // Timeouts and contants
-        private const int initializationTimeout = 10 * 1000; // 10 seconds to process the init message
-        private const int launchTimeout = 60 * 1000; // 60 seconds to launch the process
-        private const int maximumNodeRestartCount = 2; // try twice to connect to the node
-        private const int shutdownResponseTimeout = 1000; // every second check if the children are still alive
-        private static int shutdownTimeout = 30; // Wait for 30 seconds for all nodes to shutdown.
-        #endregion
-
-        #region Local enums
-        internal enum NodeState
-        {
-            /// <summary>
-            /// This node has not been launched
-            /// </summary>
-            NotLaunched = 0,
-            /// <summary>
-            /// This node is in progress of being launched
-            /// </summary>
-            LaunchInProgress = 1,
-            /// <summary>
-            /// This node is launched
-            /// </summary>
-            Launched = 2,
-            /// <summary>
-            /// This node has been shutdown
-            /// </summary>
-            Shutdown = 3
-        }
-        #endregion
-    }
-}
diff --git a/src/Deprecated/Engine/Microsoft.Build.Engine.csproj b/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
deleted file mode 100644
index 5ba31507e2f..00000000000
--- a/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
+++ /dev/null
@@ -1,224 +0,0 @@
-<Project Sdk="Microsoft.NET.Sdk">
-  <PropertyGroup>
-    <TargetFramework>$(FullFrameworkTFM)</TargetFramework>
-    <NoWarn>$(NoWarn);618</NoWarn>
-    <GenerateReferenceAssemblySource>true</GenerateReferenceAssemblySource>
-    <EnableDefaultItems>false</EnableDefaultItems>
-    <!-- Do not create Tlbs when building in .NET product mode. The packages are not shipped to VS,
-         only their contents redisted within the SDK. -->
-    <CreateTlb Condition="'$(DotNetBuild)' != 'true'">true</CreateTlb>
-    <AdditionalTlbExpAsmPaths>$(XMakeRefPath)</AdditionalTlbExpAsmPaths>
-    <PublishTlbPath>$(XMakeRefPath)</PublishTlbPath>
-    <GenerateAssemblyRefs>true</GenerateAssemblyRefs>
-    <CopyToSuiteBin>true</CopyToSuiteBin>
-    <IsPackable>true</IsPackable>
-    <PackageDescription>This package contains the $(MSBuildProjectName) assembly which contains the legacy compatibility shim for the MSBuild engine.  NOTE: This assembly is deprecated.</PackageDescription>
-    <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
-    <NoWarn>$(NoWarn);1570;1572;1573;1587</NoWarn>
-    <Nullable>disable</Nullable>
-    <EnablePackageValidation>true</EnablePackageValidation>
-  </PropertyGroup>
-
-  <ItemGroup>
-    <Reference Include="System.Configuration" />
-
-    <ProjectReference Include="..\..\Framework\Microsoft.Build.Framework.csproj" />
-  </ItemGroup>
-
-  <ItemGroup>
-    <Compile Include="..\..\Shared\Constants.cs" />
-    <Compile Include="..\..\Shared\EnvironmentUtilities.cs" Link="Shared\EnvironmentUtilities.cs" />
-    <Compile Include="AssemblyInfo.cs" />
-    <Compile Include="Caching\BuildResultCacheEntry.cs" />
-    <Compile Include="Caching\CacheEntry.cs" />
-    <Compile Include="Caching\CacheEntryCustomSerializer.cs" />
-    <Compile Include="Caching\PropertyCacheEntry.cs" />
-    <Compile Include="Caching\BuildItemCacheEntry.cs" />
-    <Compile Include="Choose\Choose.cs" />
-    <Compile Include="Choose\GroupEnumeratorHelper.cs" />
-    <Compile Include="Choose\GroupingCollection.cs" />
-    <Compile Include="Choose\When.cs" />
-    <Compile Include="Collections\CopyOnWriteHashtable.cs" />
-    <Compile Include="Collections\DualQueue.cs" />
-    <Compile Include="Collections\HashTableUtility.cs" />
-    <Compile Include="Conditionals\AndExpressionNode.cs" />
-    <Compile Include="Conditionals\CharacterUtilities.cs" />
-    <Compile Include="Conditionals\EqualExpressionNode.cs" />
-    <Compile Include="Conditionals\ConditionEvaluationState.cs" />
-    <Compile Include="Conditionals\FunctionCallExpressionNode.cs" />
-    <Compile Include="Conditionals\GenericExpressionNode.cs" />
-    <Compile Include="Conditionals\GreaterThanExpressionNode.cs" />
-    <Compile Include="Conditionals\GreaterThanOrEqualExpressionNode.cs" />
-    <Compile Include="Conditionals\LessThanExpressionNode.cs" />
-    <Compile Include="Conditionals\LessThanOrEqualExpressionNode.cs" />
-    <Compile Include="Conditionals\MultipleComparisonExpressionNode.cs" />
-    <Compile Include="Conditionals\NotEqualExpressionNode.cs" />
-    <Compile Include="Conditionals\NotExpressionNode.cs" />
-    <Compile Include="Conditionals\NumericComparisonExpressionNode.cs" />
-    <Compile Include="Conditionals\NumericExpressionNode.cs" />
-    <Compile Include="Conditionals\OperandExpressionNode.cs" />
-    <Compile Include="Conditionals\OperatorExpressionNode.cs" />
-    <Compile Include="Conditionals\OrExpressionNode.cs" />
-    <Compile Include="Conditionals\Parser.cs" />
-    <Compile Include="Conditionals\Scanner.cs" />
-    <Compile Include="Conditionals\StringExpressionNode.cs" />
-    <Compile Include="Conditionals\Token.cs" />
-    <Compile Include="Engine\BatchingEngine.cs" />
-    <Compile Include="Engine\BuildRequest.cs" />
-    <Compile Include="Engine\BuildResult.cs" />
-    <Compile Include="Engine\BuildTask.cs" />
-    <Compile Include="Engine\CacheScope.cs" />
-    <Compile Include="Engine\CacheManager.cs" />
-    <Compile Include="Engine\EngineCommand.cs" />
-    <Compile Include="Engine\EventRedirector.cs" />
-    <Compile Include="Engine\ExecutionContext.cs" />
-    <Compile Include="Engine\Engine.cs" />
-    <Compile Include="Engine\EngineCallback.cs" />
-    <Compile Include="Engine\EngineLoggingServicesInProc.cs" />
-    <Compile Include="Engine\EngineLoggingServicesOutProc.cs" />
-    <Compile Include="Engine\EngineProxy.cs" />
-    <Compile Include="Engine\EventSource.cs" />
-    <Compile Include="Engine\Expander.cs" />
-    <Compile Include="Engine\EngineLoggingServices.cs" />
-    <Compile Include="Engine\IItemPropertyGrouping.cs" />
-    <Compile Include="Engine\Import.cs" />
-    <Compile Include="Engine\ImportCollection.cs" />
-    <Compile Include="Engine\ImportedProject.cs" />
-    <Compile Include="Engine\IEngineCallback.cs" />
-    <Compile Include="Engine\INodeDescription.cs" />
-    <Compile Include="Engine\INodeProvider.cs" />
-    <Compile Include="Engine\IntrinsicFunctions.cs" />
-    <Compile Include="Engine\ITaskRegistry.cs" />
-    <Compile Include="Engine\ItemBucket.cs" />
-    <Compile Include="Engine\Node.cs" />
-    <Compile Include="Engine\NodeManager.cs" />
-    <Compile Include="Engine\NodeRequestMapping.cs" />
-    <Compile Include="Engine\NodeLoggingEvent.cs" />
-    <Compile Include="Engine\Project.cs" />
-    <Compile Include="Engine\ProjectBuildState.cs" />
-    <Compile Include="Engine\ProjectManager.cs" />
-    <Compile Include="Engine\ProjectSchemaValidationHandler.cs" />
-    <Compile Include="Engine\RegistryKeyWrapper.cs" />
-    <Compile Include="Engine\RequestRoutingContext.cs" />
-    <Compile Include="Engine\Router.cs" />
-    <Compile Include="Engine\SchedulerRecord.cs" />
-    <Compile Include="Engine\Scheduler.cs" />
-    <Compile Include="Engine\Target.cs" />
-    <Compile Include="Engine\TargetExecutionWrapper.cs" />
-    <Compile Include="Engine\TargetCollection.cs" />
-    <Compile Include="Engine\TargetDependencyAnalyzer.cs" />
-    <Compile Include="Engine\TaskEngine.cs" />
-    <Compile Include="Engine\TaskEngineAssemblyResolver.cs" />
-    <Compile Include="Engine\TaskExecutionContext.cs" />
-    <Compile Include="Engine\TaskExecutionState.cs" />
-    <Compile Include="Engine\TaskExecutionModule.cs" />
-    <Compile Include="Engine\TaskOutput.cs" />
-    <Compile Include="Engine\TaskRegistry.cs" />
-    <Compile Include="Engine\TaskWorkerThread.cs" />
-    <Compile Include="Engine\Toolset.cs" />
-    <Compile Include="Engine\ToolsetConfigurationReader.cs" />
-    <Compile Include="Engine\ToolsetCollection.cs" />
-    <Compile Include="Engine\ToolsetReader.cs" />
-    <Compile Include="Engine\ToolsetRegistryReader.cs" />
-    <Compile Include="Engine\ToolsetState.cs" />
-    <Compile Include="Engine\UsingTask.cs" />
-    <Compile Include="Engine\UsingTaskCollection.cs" />
-    <Compile Include="Engine\Utilities.cs" />
-    <Compile Include="Engine\XmlSearcher.cs" />
-    <Compile Include="Errors\InternalLoggerException.cs" />
-    <Compile Include="Errors\InvalidProjectFileException.cs" />
-    <Compile Include="Errors\InvalidToolsetDefinitionException.cs" />
-    <Compile Include="Errors\RegistryException.cs" />
-    <Compile Include="Errors\RemoteErrorException.cs" />
-    <Compile Include="Introspector\Introspector.cs" />
-    <Compile Include="Introspector\NodeStatus.cs" />
-    <Compile Include="Introspector\TargetCycleDetector.cs" />
-    <Compile Include="Introspector\TargetInProgressState.cs" />
-    <Compile Include="ItemsAndProperties\ExpressionShredder.cs" />
-    <Compile Include="ItemsAndProperties\Lookup.cs" />
-    <Compile Include="Items\BuildItem.cs" />
-    <Compile Include="Items\BuildItemGroup.cs" />
-    <Compile Include="Items\BuildItemGroupCollection.cs" />
-    <Compile Include="Items\BuildItemGroupProxy.cs" />
-    <Compile Include="Items\ItemDefinitionLibrary.cs" />
-    <Compile Include="Items\ItemExpander.cs" />
-    <Compile Include="Items\TaskItem.cs" />
-    <Compile Include="LocalProvider\LocalCallDescriptor.cs" />
-    <Compile Include="LocalProvider\LocalNode.cs" />
-    <Compile Include="LocalProvider\LocalNodeCallback.cs" />
-    <Compile Include="LocalProvider\LocalNodeInfo.cs" />
-    <Compile Include="LocalProvider\LocalNodeProvider.cs" />
-    <Compile Include="LocalProvider\LocalNodeProviderGlobalNames.cs" />
-    <Compile Include="LocalProvider\NativeMethods.cs" />
-    <Compile Include="LocalProvider\SharedMemory.cs" />
-    <Compile Include="Logging\BaseConsoleLogger.cs" />
-    <Compile Include="Logging\ConsoleLogger.cs" />
-    <Compile Include="Logging\NullCentralLogger.cs" />
-    <Compile Include="Logging\DistributedLoggers\DistributedFileLogger.cs" />
-    <Compile Include="Logging\DistributedLoggers\ConfigurableForwardingLogger.cs" />
-    <Compile Include="Logging\LoggerDescription.cs" />
-    <Compile Include="Logging\ParallelLogger\ParallelLoggerHelpers.cs" />
-    <Compile Include="Logging\ParallelLogger\ParallelConsoleLogger.cs" />
-    <Compile Include="Logging\FileLogger.cs" />
-    <Compile Include="Logging\LogFormatter.cs" />
-    <Compile Include="Logging\SerialConsoleLogger.cs" />
-    <Compile Include="Properties\BuildProperty.cs" />
-    <Compile Include="Properties\BuildPropertyGroup.cs" />
-    <Compile Include="Properties\BuildPropertyGroupProxy.cs" />
-    <Compile Include="Properties\BuildPropertyGroupCollection.cs" />
-    <Compile Include="Resources\AssemblyResources.cs" />
-    <Compile Include="Resources\Constants.cs" />
-    <Compile Include="Solution\SolutionWrapperProject.cs" />
-    <Compile Include="Solution\VCProjectParser.cs" />
-    <Compile Include="Solution\VCWrapperProject.cs" />
-    <Compile Include="Tasks\IntrinsicTask.cs" />
-    <Compile Include="Utilities\EngineFileUtilities.cs" />
-    <Compile Include="Xml\BuildItemGroupChildXml.cs" />
-    <Compile Include="Xml\BuildItemGroupXml.cs" />
-    <Compile Include="Xml\ProjectXmlUtilities.cs" />
-    <Compile Include="Shared\AssemblyLoadInfo.cs" />
-    <Compile Include="Shared\AssemblyNameExtension.cs" />
-    <Compile Include="Shared\BuildEventFileInfo.cs" />
-    <Compile Include="Shared\ConfigurationInSolution.cs" />
-    <Compile Include="Shared\ConversionUtilities.cs" />
-    <Compile Include="Shared\Delegate.cs" />
-    <Compile Include="Shared\ErrorUtilities.cs" />
-    <Compile Include="Shared\EscapingUtilities.cs" />
-    <Compile Include="Shared\EventArgsFormatting.cs" />
-    <Compile Include="Shared\ExceptionHandling.cs" />
-    <Compile Include="Shared\FileMatcher.cs" />
-    <Compile Include="Shared\FileUtilities.cs" />
-    <Compile Include="Shared\FileUtilitiesRegex.cs" />
-    <Compile Include="Shared\FrameworkLocationHelper.cs" />
-    <Compile Include="Shared\InternalErrorException.cs" />
-    <Compile Include="Shared\LoadedType.cs" />
-    <Compile Include="Shared\NativeMethodsShared.cs" />
-    <Compile Include="Shared\ProjectConfigurationInSolution.cs" />
-    <Compile Include="Shared\ProjectErrorUtilities.cs" />
-    <Compile Include="Shared\ProjectFileErrorUtilities.cs" />
-    <Compile Include="Shared\ProjectInSolution.cs" />
-    <Compile Include="Shared\ProjectWriter.cs" />
-    <Compile Include="Shared\ResourceUtilities.cs" />
-    <Compile Include="Shared\SolutionParser.cs" />
-    <Compile Include="Shared\TypeLoader.cs" />
-    <Compile Include="Shared\VisualStudioConstants.cs" />
-    <Compile Include="Shared\XMakeAttributes.cs" />
-    <Compile Include="Shared\XMakeElements.cs" />
-    <Compile Include="Shared\XmlUtilities.cs" />
-
-    <!-- Resource Files -->
-
-    <EmbeddedResource Include="Resources\Strings.resx">
-      <LogicalName>$(AssemblyName).Strings.resources</LogicalName>
-      <SubType>Designer</SubType>
-    </EmbeddedResource>
-
-    <EmbeddedResource Include="..\..\Shared\Resources\Strings.shared.resx">
-      <Link>Resources\Strings.shared.resx</Link>
-      <LogicalName>$(AssemblyName).Strings.shared.resources</LogicalName>
-      <SubType>Designer</SubType>
-    </EmbeddedResource>
-  </ItemGroup>
-
-  <Import Project="$(RepoRoot)eng\ProducesNoOutput.Settings.props" Condition="! $([MSBuild]::IsOSPlatform('windows'))" />
-</Project>
