diff --git a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
index ba5e65870a0..75f6da7aa90 100644
--- a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
@@ -51,12 +51,12 @@ internal AppDomainIsolatedTaskExtension() { }
     public partial class AspNetCompiler : Microsoft.Build.Tasks.ToolTaskExtension
     {
         public AspNetCompiler() { }
-        public bool AllowPartiallyTrustedCallers { get { throw null; } set { } }
-        public bool Clean { get { throw null; } set { } }
-        public bool Debug { get { throw null; } set { } }
-        public bool DelaySign { get { throw null; } set { } }
-        public bool FixedNames { get { throw null; } set { } }
-        public bool Force { get { throw null; } set { } }
+        public bool AllowPartiallyTrustedCallers { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool Clean { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool Debug { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool DelaySign { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool FixedNames { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool Force { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string KeyContainer { get { throw null; } set { } }
         public string KeyFile { get { throw null; } set { } }
         public string MetabasePath { get { throw null; } set { } }
@@ -64,7 +64,7 @@ public AspNetCompiler() { }
         public string TargetFrameworkMoniker { get { throw null; } set { } }
         public string TargetPath { get { throw null; } set { } }
         protected override string ToolName { get { throw null; } }
-        public bool Updateable { get { throw null; } set { } }
+        public bool Updateable { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string VirtualPath { get { throw null; } set { } }
         protected internal override void AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) { }
         public override bool Execute() { throw null; }
@@ -75,15 +75,15 @@ public partial class AssignCulture : Microsoft.Build.Tasks.TaskExtension
     {
         public AssignCulture() { }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssignedFiles { get { throw null; } }
+        public Microsoft.Build.Framework.ITaskItem[] AssignedFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssignedFilesWithCulture { get { throw null; } }
+        public Microsoft.Build.Framework.ITaskItem[] AssignedFilesWithCulture { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssignedFilesWithNoCulture { get { throw null; } }
+        public Microsoft.Build.Framework.ITaskItem[] AssignedFilesWithNoCulture { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] CultureNeutralAssignedFiles { get { throw null; } }
+        public Microsoft.Build.Framework.ITaskItem[] CultureNeutralAssignedFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Files { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public partial class AssignLinkMetadata : Microsoft.Build.Tasks.TaskExtension
@@ -99,18 +99,18 @@ public partial class AssignProjectConfiguration : Microsoft.Build.Tasks.ResolveP
         public AssignProjectConfiguration() { }
         public bool AddSyntheticProjectReferencesForSolutionDependencies { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssignedProjects { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] AssignedProjects { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string CurrentProject { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
-        public string CurrentProjectConfiguration { get { throw null; } set { } }
-        public string CurrentProjectPlatform { get { throw null; } set { } }
+        public string CurrentProjectConfiguration { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string CurrentProjectPlatform { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string DefaultToVcxPlatformMapping { get { throw null; } set { } }
-        public bool OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration { get { throw null; } set { } }
-        public string OutputType { get { throw null; } set { } }
-        public bool ResolveConfigurationPlatformUsingMappings { get { throw null; } set { } }
-        public bool ShouldUnsetParentConfigurationAndPlatform { get { throw null; } set { } }
-        public string SolutionConfigurationContents { get { throw null; } set { } }
+        public bool OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string OutputType { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool ResolveConfigurationPlatformUsingMappings { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool ShouldUnsetParentConfigurationAndPlatform { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string SolutionConfigurationContents { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] UnassignedProjects { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] UnassignedProjects { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string VcxToDefaultPlatformMapping { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
@@ -118,10 +118,10 @@ public partial class AssignTargetPath : Microsoft.Build.Tasks.TaskExtension
     {
         public AssignTargetPath() { }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssignedFiles { get { throw null; } }
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] AssignedFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public Microsoft.Build.Framework.ITaskItem[] Files { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
-        public string RootFolder { get { throw null; } set { } }
+        public string RootFolder { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     [Microsoft.Build.Framework.RunInMTAAttribute]
@@ -148,9 +148,9 @@ public void CleanupTask(Microsoft.Build.Framework.ITask task) { }
     public partial class CombinePath : Microsoft.Build.Tasks.TaskExtension
     {
         public CombinePath() { }
-        public string BasePath { get { throw null; } set { } }
+        public string BasePath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] CombinedPaths { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] CombinedPaths { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] Paths { get { throw null; } set { } }
         public override bool Execute() { throw null; }
@@ -165,7 +165,7 @@ public partial class ConvertToAbsolutePath : Microsoft.Build.Tasks.TaskExtension
     {
         public ConvertToAbsolutePath() { }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AbsolutePaths { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] AbsolutePaths { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] Paths { get { throw null; } set { } }
         public override bool Execute() { throw null; }
@@ -198,11 +198,11 @@ public CreateCSharpManifestResourceName() { }
     public partial class CreateItem : Microsoft.Build.Tasks.TaskExtension
     {
         public CreateItem() { }
-        public string[] AdditionalMetadata { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] Exclude { get { throw null; } set { } }
+        public string[] AdditionalMetadata { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Exclude { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Include { get { throw null; } set { } }
-        public bool PreserveExistingMetadata { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Include { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool PreserveExistingMetadata { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public abstract partial class CreateManifestResourceName : Microsoft.Build.Tasks.TaskExtension
@@ -210,13 +210,13 @@ public abstract partial class CreateManifestResourceName : Microsoft.Build.Tasks
         protected System.Collections.Generic.Dictionary<string, Microsoft.Build.Framework.ITaskItem> itemSpecToTaskitem;
         protected CreateManifestResourceName() { }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ManifestResourceNames { get { throw null; } }
-        public bool PrependCultureAsDirectory { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] ManifestResourceNames { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public bool PrependCultureAsDirectory { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] ResourceFiles { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ResourceFilesWithManifestResourceNames { get { throw null; } set { } }
-        public string RootNamespace { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] ResourceFilesWithManifestResourceNames { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string RootNamespace { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         protected abstract string CreateManifestName(string fileName, string linkFileName, string rootNamespaceName, string dependentUponFileName, System.IO.Stream binaryStream);
         public override bool Execute() { throw null; }
         protected abstract bool IsSourceFile(string fileName);
@@ -226,7 +226,7 @@ public partial class CreateProperty : Microsoft.Build.Tasks.TaskExtension
     {
         public CreateProperty() { }
         [Microsoft.Build.Framework.OutputAttribute]
-        public string[] Value { get { throw null; } set { } }
+        public string[] Value { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         public string[] ValueSetByTask { get { throw null; } }
         public override bool Execute() { throw null; }
@@ -241,10 +241,10 @@ public partial class Delete : Microsoft.Build.Tasks.TaskExtension, Microsoft.Bui
     {
         public Delete() { }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] DeletedFiles { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] DeletedFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
-        public bool TreatErrorsAsWarnings { get { throw null; } set { } }
+        public bool TreatErrorsAsWarnings { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public void Cancel() { }
         public override bool Execute() { throw null; }
     }
@@ -367,14 +367,14 @@ public FindInvalidProjectReferences() { }
     public partial class FindUnderPath : Microsoft.Build.Tasks.TaskExtension
     {
         public FindUnderPath() { }
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Files { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] InPath { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] InPath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] OutOfPath { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] OutOfPath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem Path { get { throw null; } set { } }
-        public bool UpdateToAbsolutePaths { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem Path { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool UpdateToAbsolutePaths { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public sealed partial class FormatUrl : Microsoft.Build.Tasks.TaskExtension
@@ -795,9 +795,9 @@ public partial class ReadLinesFromFile : Microsoft.Build.Tasks.TaskExtension
     {
         public ReadLinesFromFile() { }
         [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem File { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem File { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Lines { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Lines { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public partial class RegisterAssembly : Microsoft.Build.Tasks.AppDomainIsolatedTaskExtension, System.Runtime.InteropServices.ITypeLibExporterNotifySink
@@ -1236,18 +1236,18 @@ public WriteCodeFragment() { }
     public partial class WriteLinesToFile : Microsoft.Build.Tasks.TaskExtension
     {
         public WriteLinesToFile() { }
-        public string Encoding { get { throw null; } set { } }
+        public string Encoding { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem File { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] Lines { get { throw null; } set { } }
-        public bool Overwrite { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem File { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Lines { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool Overwrite { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public bool WriteOnlyWhenDifferent { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public partial class XamlTaskFactory : Microsoft.Build.Framework.ITaskFactory
     {
         public XamlTaskFactory() { }
-        public string FactoryName { get { throw null; } }
+        public string FactoryName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public string TaskElementContents { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public string TaskName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public string TaskNamespace { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
@@ -1317,14 +1317,15 @@ public BootstrapperBuilder(string visualStudioVersion) { }
         public Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection Products { get { throw null; } }
         public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings settings) { throw null; }
         public string[] GetOutputFolders(string[] productCodes, string culture, string fallbackCulture, Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation componentsLocation) { throw null; }
+        public static string XmlToConfigurationFile(System.Xml.XmlNode input) { throw null; }
     }
     public partial class BuildMessage : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage
     {
         internal BuildMessage() { }
-        public int HelpId { get { throw null; } }
-        public string HelpKeyword { get { throw null; } }
-        public string Message { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity Severity { get { throw null; } }
+        public int HelpId { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public string HelpKeyword { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public string Message { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity Severity { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("936D32F9-1A68-4d5e-98EA-044AC9A1AADA")]
@@ -1341,9 +1342,9 @@ public partial class BuildResults : Microsoft.Build.Tasks.Deployment.Bootstrappe
     {
         internal BuildResults() { }
         public string[] ComponentFiles { get { throw null; } }
-        public string KeyFile { get { throw null; } }
+        public string KeyFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[] Messages { get { throw null; } }
-        public bool Succeeded { get { throw null; } }
+        public bool Succeeded { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
     }
     [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
@@ -1351,19 +1352,19 @@ internal BuildResults() { }
     public partial class BuildSettings : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings
     {
         public BuildSettings() { }
-        public string ApplicationFile { get { throw null; } set { } }
-        public string ApplicationName { get { throw null; } set { } }
-        public bool ApplicationRequiresElevation { get { throw null; } set { } }
-        public string ApplicationUrl { get { throw null; } set { } }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation ComponentsLocation { get { throw null; } set { } }
-        public string ComponentsUrl { get { throw null; } set { } }
-        public bool CopyComponents { get { throw null; } set { } }
-        public int FallbackLCID { get { throw null; } set { } }
-        public int LCID { get { throw null; } set { } }
-        public string OutputPath { get { throw null; } set { } }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection ProductBuilders { get { throw null; } }
-        public string SupportUrl { get { throw null; } set { } }
-        public bool Validate { get { throw null; } set { } }
+        public string ApplicationFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string ApplicationName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool ApplicationRequiresElevation { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string ApplicationUrl { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation ComponentsLocation { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string ComponentsUrl { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool CopyComponents { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public int FallbackLCID { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public int LCID { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string OutputPath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection ProductBuilders { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public string SupportUrl { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool Validate { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("12F49949-7B60-49CD-B6A0-2B5E4A638AAF")]
@@ -1493,15 +1494,15 @@ public partial interface IProductCollection
     public partial class Product : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct
     {
         public Product() { }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection Includes { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection Includes { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public string Name { get { throw null; } }
         public Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder ProductBuilder { get { throw null; } }
-        public string ProductCode { get { throw null; } }
+        public string ProductCode { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
     }
     public partial class ProductBuilder : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilder
     {
         internal ProductBuilder() { }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Product { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Product { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
     }
     [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
@@ -2168,18 +2169,18 @@ public static void WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilit
     public sealed partial class OutputMessage
     {
         internal OutputMessage() { }
-        public string Name { get { throw null; } }
-        public string Text { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType Type { get { throw null; } }
+        public string Name { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public string Text { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType Type { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public string[] GetArguments() { throw null; }
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(false)]
     public sealed partial class OutputMessageCollection : System.Collections.IEnumerable
     {
         internal OutputMessageCollection() { }
-        public int ErrorCount { get { throw null; } }
+        public int ErrorCount { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage this[int index] { get { throw null; } }
-        public int WarningCount { get { throw null; } }
+        public int WarningCount { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public void Clear() { }
         public System.Collections.IEnumerator GetEnumerator() { throw null; }
     }
@@ -2244,7 +2245,7 @@ public TrustInfo() { }
         public bool HasUnmanagedCodePermission { get { throw null; } }
         public bool IsFullTrust { get { throw null; } set { } }
         public System.Security.PermissionSet PermissionSet { get { throw null; } set { } }
-        public bool PreserveFullTrustPermissionSet { get { throw null; } set { } }
+        public bool PreserveFullTrustPermissionSet { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string SameSiteAccess { get { throw null; } set { } }
         public void Clear() { }
         public void Read(System.IO.Stream input) { }
@@ -2513,7 +2514,7 @@ public CommandLineArgumentRelation(string argument, string value, bool required,
     public partial class CommandLineGenerator
     {
         public CommandLineGenerator(Microsoft.Build.Framework.XamlTypes.Rule rule, System.Collections.Generic.Dictionary<string, object> parameterValues) { }
-        public string AdditionalOptions { get { throw null; } set { } }
+        public string AdditionalOptions { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string AlwaysAppend { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string CommandLineTemplate { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string GenerateCommandLine() { throw null; }
@@ -2522,30 +2523,30 @@ public partial class CommandLineToolSwitch
     {
         public CommandLineToolSwitch() { }
         public CommandLineToolSwitch(Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType toolType) { }
-        public bool AllowMultipleValues { get { throw null; } set { } }
+        public bool AllowMultipleValues { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public bool ArgumentRequired { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
-        public System.Collections.Generic.ICollection<System.Tuple<string, bool>> Arguments { get { throw null; } set { } }
+        public System.Collections.Generic.ICollection<System.Tuple<string, bool>> Arguments { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public bool BooleanValue { get { throw null; } set { } }
-        public string Description { get { throw null; } set { } }
-        public string DisplayName { get { throw null; } set { } }
-        public string FallbackArgumentParameter { get { throw null; } set { } }
-        public string FalseSuffix { get { throw null; } set { } }
-        public bool IncludeInCommandLine { get { throw null; } set { } }
-        public bool IsValid { get { throw null; } set { } }
-        public string Name { get { throw null; } set { } }
+        public string Description { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string DisplayName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string FallbackArgumentParameter { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string FalseSuffix { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool IncludeInCommandLine { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool IsValid { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Name { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public int Number { get { throw null; } set { } }
-        public System.Collections.Generic.LinkedList<System.Collections.Generic.KeyValuePair<string, string>> Overrides { get { throw null; } }
-        public System.Collections.Generic.LinkedList<string> Parents { get { throw null; } }
-        public bool Required { get { throw null; } set { } }
-        public string ReverseSwitchValue { get { throw null; } set { } }
-        public bool Reversible { get { throw null; } set { } }
-        public string Separator { get { throw null; } set { } }
+        public System.Collections.Generic.LinkedList<System.Collections.Generic.KeyValuePair<string, string>> Overrides { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public System.Collections.Generic.LinkedList<string> Parents { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public bool Required { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string ReverseSwitchValue { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool Reversible { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Separator { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string[] StringList { get { throw null; } set { } }
-        public string SwitchValue { get { throw null; } set { } }
+        public string SwitchValue { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public Microsoft.Build.Framework.ITaskItem[] TaskItemArray { get { throw null; } set { } }
-        public string TrueSuffix { get { throw null; } set { } }
-        public Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType Type { get { throw null; } set { } }
-        public string Value { get { throw null; } set { } }
+        public string TrueSuffix { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType Type { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Value { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
     }
     public enum CommandLineToolSwitchType
     {
@@ -2566,12 +2567,12 @@ public PropertyRelation(string argument, string value, bool required) { }
     public abstract partial class XamlDataDrivenToolTask : Microsoft.Build.Utilities.ToolTask
     {
         protected XamlDataDrivenToolTask(string[] switchOrderList, System.Resources.ResourceManager taskResources) { }
-        public virtual string[] AcceptableNonZeroExitCodes { get { throw null; } set { } }
-        protected internal System.Collections.Generic.Dictionary<string, Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch> ActiveToolSwitches { get { throw null; } }
-        public System.Collections.Generic.Dictionary<string, Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch> ActiveToolSwitchesValues { get { throw null; } set { } }
-        public string AdditionalOptions { get { throw null; } set { } }
+        public virtual string[] AcceptableNonZeroExitCodes { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        protected internal System.Collections.Generic.Dictionary<string, Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch> ActiveToolSwitches { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public System.Collections.Generic.Dictionary<string, Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch> ActiveToolSwitchesValues { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string AdditionalOptions { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string CommandLineTemplate { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
-        protected override System.Text.Encoding ResponseFileEncoding { get { throw null; } }
+        protected override System.Text.Encoding ResponseFileEncoding { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public void AddActiveSwitchToolValue(Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch switchToAdd) { }
         public string CreateSwitchValue(string propertyName, string baseSwitch, string separator, System.Tuple<string, bool>[] arguments) { throw null; }
         public override bool Execute() { throw null; }
diff --git a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
index 72ac670b95b..924c1fceb78 100644
--- a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
@@ -4,15 +4,15 @@ public partial class AssignCulture : Microsoft.Build.Tasks.TaskExtension
     {
         public AssignCulture() { }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssignedFiles { get { throw null; } }
+        public Microsoft.Build.Framework.ITaskItem[] AssignedFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssignedFilesWithCulture { get { throw null; } }
+        public Microsoft.Build.Framework.ITaskItem[] AssignedFilesWithCulture { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssignedFilesWithNoCulture { get { throw null; } }
+        public Microsoft.Build.Framework.ITaskItem[] AssignedFilesWithNoCulture { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] CultureNeutralAssignedFiles { get { throw null; } }
+        public Microsoft.Build.Framework.ITaskItem[] CultureNeutralAssignedFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Files { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public partial class AssignLinkMetadata : Microsoft.Build.Tasks.TaskExtension
@@ -28,18 +28,18 @@ public partial class AssignProjectConfiguration : Microsoft.Build.Tasks.ResolveP
         public AssignProjectConfiguration() { }
         public bool AddSyntheticProjectReferencesForSolutionDependencies { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssignedProjects { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] AssignedProjects { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string CurrentProject { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
-        public string CurrentProjectConfiguration { get { throw null; } set { } }
-        public string CurrentProjectPlatform { get { throw null; } set { } }
+        public string CurrentProjectConfiguration { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string CurrentProjectPlatform { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string DefaultToVcxPlatformMapping { get { throw null; } set { } }
-        public bool OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration { get { throw null; } set { } }
-        public string OutputType { get { throw null; } set { } }
-        public bool ResolveConfigurationPlatformUsingMappings { get { throw null; } set { } }
-        public bool ShouldUnsetParentConfigurationAndPlatform { get { throw null; } set { } }
-        public string SolutionConfigurationContents { get { throw null; } set { } }
+        public bool OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string OutputType { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool ResolveConfigurationPlatformUsingMappings { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool ShouldUnsetParentConfigurationAndPlatform { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string SolutionConfigurationContents { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] UnassignedProjects { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] UnassignedProjects { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string VcxToDefaultPlatformMapping { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
@@ -47,10 +47,10 @@ public partial class AssignTargetPath : Microsoft.Build.Tasks.TaskExtension
     {
         public AssignTargetPath() { }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssignedFiles { get { throw null; } }
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] AssignedFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public Microsoft.Build.Framework.ITaskItem[] Files { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
-        public string RootFolder { get { throw null; } set { } }
+        public string RootFolder { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     [Microsoft.Build.Framework.RunInMTAAttribute]
@@ -78,9 +78,9 @@ public void CleanupTask(Microsoft.Build.Framework.ITask task) { }
     public partial class CombinePath : Microsoft.Build.Tasks.TaskExtension
     {
         public CombinePath() { }
-        public string BasePath { get { throw null; } set { } }
+        public string BasePath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] CombinedPaths { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] CombinedPaths { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] Paths { get { throw null; } set { } }
         public override bool Execute() { throw null; }
@@ -95,7 +95,7 @@ public partial class ConvertToAbsolutePath : Microsoft.Build.Tasks.TaskExtension
     {
         public ConvertToAbsolutePath() { }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AbsolutePaths { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] AbsolutePaths { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] Paths { get { throw null; } set { } }
         public override bool Execute() { throw null; }
@@ -128,11 +128,11 @@ public CreateCSharpManifestResourceName() { }
     public partial class CreateItem : Microsoft.Build.Tasks.TaskExtension
     {
         public CreateItem() { }
-        public string[] AdditionalMetadata { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] Exclude { get { throw null; } set { } }
+        public string[] AdditionalMetadata { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Exclude { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Include { get { throw null; } set { } }
-        public bool PreserveExistingMetadata { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Include { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool PreserveExistingMetadata { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public abstract partial class CreateManifestResourceName : Microsoft.Build.Tasks.TaskExtension
@@ -140,13 +140,13 @@ public abstract partial class CreateManifestResourceName : Microsoft.Build.Tasks
         protected System.Collections.Generic.Dictionary<string, Microsoft.Build.Framework.ITaskItem> itemSpecToTaskitem;
         protected CreateManifestResourceName() { }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ManifestResourceNames { get { throw null; } }
-        public bool PrependCultureAsDirectory { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] ManifestResourceNames { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public bool PrependCultureAsDirectory { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] ResourceFiles { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ResourceFilesWithManifestResourceNames { get { throw null; } set { } }
-        public string RootNamespace { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] ResourceFilesWithManifestResourceNames { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string RootNamespace { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         protected abstract string CreateManifestName(string fileName, string linkFileName, string rootNamespaceName, string dependentUponFileName, System.IO.Stream binaryStream);
         public override bool Execute() { throw null; }
         protected abstract bool IsSourceFile(string fileName);
@@ -156,7 +156,7 @@ public partial class CreateProperty : Microsoft.Build.Tasks.TaskExtension
     {
         public CreateProperty() { }
         [Microsoft.Build.Framework.OutputAttribute]
-        public string[] Value { get { throw null; } set { } }
+        public string[] Value { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         public string[] ValueSetByTask { get { throw null; } }
         public override bool Execute() { throw null; }
@@ -171,10 +171,10 @@ public partial class Delete : Microsoft.Build.Tasks.TaskExtension, Microsoft.Bui
     {
         public Delete() { }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] DeletedFiles { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] DeletedFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
-        public bool TreatErrorsAsWarnings { get { throw null; } set { } }
+        public bool TreatErrorsAsWarnings { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public void Cancel() { }
         public override bool Execute() { throw null; }
     }
@@ -285,14 +285,14 @@ public FindInList() { }
     public partial class FindUnderPath : Microsoft.Build.Tasks.TaskExtension
     {
         public FindUnderPath() { }
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Files { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] InPath { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] InPath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] OutOfPath { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] OutOfPath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem Path { get { throw null; } set { } }
-        public bool UpdateToAbsolutePaths { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem Path { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool UpdateToAbsolutePaths { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public sealed partial class FormatVersion : Microsoft.Build.Tasks.TaskExtension
@@ -483,9 +483,9 @@ public partial class ReadLinesFromFile : Microsoft.Build.Tasks.TaskExtension
     {
         public ReadLinesFromFile() { }
         [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem File { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem File { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Lines { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Lines { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public partial class RemoveDir : Microsoft.Build.Tasks.TaskExtension
@@ -701,11 +701,11 @@ public WriteCodeFragment() { }
     public partial class WriteLinesToFile : Microsoft.Build.Tasks.TaskExtension
     {
         public WriteLinesToFile() { }
-        public string Encoding { get { throw null; } set { } }
+        public string Encoding { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem File { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] Lines { get { throw null; } set { } }
-        public bool Overwrite { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem File { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Lines { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool Overwrite { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public bool WriteOnlyWhenDifferent { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
diff --git a/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs b/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
index f9a7e3d99a7..7b670557fd4 100644
--- a/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
+++ b/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
@@ -381,10 +381,10 @@ public partial class TaskLoggingHelper : System.MarshalByRefObject
         public TaskLoggingHelper(Microsoft.Build.Framework.IBuildEngine buildEngine, string taskName) { }
         public TaskLoggingHelper(Microsoft.Build.Framework.ITask taskInstance) { }
         protected Microsoft.Build.Framework.IBuildEngine BuildEngine { get { throw null; } }
-        public bool HasLoggedErrors { get { throw null; } }
-        public string HelpKeywordPrefix { get { throw null; } set { } }
-        protected string TaskName { get { throw null; } }
-        public System.Resources.ResourceManager TaskResources { get { throw null; } set { } }
+        public bool HasLoggedErrors { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public string HelpKeywordPrefix { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        protected string TaskName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public System.Resources.ResourceManager TaskResources { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string ExtractMessageCode(string message, out string messageWithoutCodePrefix) { messageWithoutCodePrefix = default(string); throw null; }
         public virtual string FormatResourceString(string resourceName, params object[] args) { throw null; }
         public virtual string FormatString(string unformatted, params object[] args) { throw null; }
diff --git a/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs b/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
index 0326ae78bbb..1da3aafbd34 100644
--- a/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
+++ b/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
@@ -224,10 +224,10 @@ public partial class TaskLoggingHelper
         public TaskLoggingHelper(Microsoft.Build.Framework.IBuildEngine buildEngine, string taskName) { }
         public TaskLoggingHelper(Microsoft.Build.Framework.ITask taskInstance) { }
         protected Microsoft.Build.Framework.IBuildEngine BuildEngine { get { throw null; } }
-        public bool HasLoggedErrors { get { throw null; } }
-        public string HelpKeywordPrefix { get { throw null; } set { } }
-        protected string TaskName { get { throw null; } }
-        public System.Resources.ResourceManager TaskResources { get { throw null; } set { } }
+        public bool HasLoggedErrors { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public string HelpKeywordPrefix { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        protected string TaskName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public System.Resources.ResourceManager TaskResources { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string ExtractMessageCode(string message, out string messageWithoutCodePrefix) { messageWithoutCodePrefix = default(string); throw null; }
         public virtual string FormatResourceString(string resourceName, params object[] args) { throw null; }
         public virtual string FormatString(string unformatted, params object[] args) { throw null; }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/CallTarget.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/CallTarget.cs
index 14a24a0b55d..e441d31d800 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/CallTarget.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/CallTarget.cs
@@ -2,7 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
+using System.Collections.Generic;
 using System.Threading.Tasks;
 using Microsoft.Build.Framework;
 
@@ -27,7 +27,7 @@ internal class CallTarget : ITask
         #region Properties
 
         // outputs of all built targets
-        private readonly ArrayList _targetOutputs = new ArrayList();
+        private readonly List<ITaskItem> _targetOutputs = new List<ITaskItem>();
 
         /// <summary>
         /// A list of targets to build.  This is a required parameter.  If you want to build the 
@@ -41,13 +41,7 @@ internal class CallTarget : ITask
         /// </summary>
         /// <value>Array of output items.</value>
         [Output]
-        public ITaskItem[] TargetOutputs
-        {
-            get
-            {
-                return (ITaskItem[])_targetOutputs.ToArray(typeof(ITaskItem));
-            }
-        }
+        public ITaskItem[] TargetOutputs => _targetOutputs.ToArray();
 
         /// <summary>
         /// When this is true, instead of calling the engine once to build all the targets (for each project),
@@ -67,35 +61,18 @@ public ITaskItem[] TargetOutputs
 
         #region ITask Members
 
-        public IBuildEngine BuildEngine
-        {
-            get;
-            set;
-        }
+        public IBuildEngine BuildEngine { get; set; }
 
-        public IBuildEngine2 BuildEngine2
-        {
-            get { return (IBuildEngine2)BuildEngine; }
-        }
+        public IBuildEngine2 BuildEngine2 => (IBuildEngine2)BuildEngine;
 
-        public IBuildEngine3 BuildEngine3
-        {
-            get { return (IBuildEngine3)BuildEngine; }
-        }
+        public IBuildEngine3 BuildEngine3 => (IBuildEngine3)BuildEngine;
 
         /// <summary>
         /// The host object, from ITask
         /// </summary>
-        public ITaskHost HostObject
-        {
-            get;
-            set;
-        }
+        public ITaskHost HostObject { get; set; }
 
-        public TaskLoggingHelper Log
-        {
-            get { return _logHelper ?? (_logHelper = new TaskLoggingHelper(this)); }
-        }
+        public TaskLoggingHelper Log => _logHelper ?? (_logHelper = new TaskLoggingHelper(this));
 
         public bool Execute()
         {
@@ -118,9 +95,9 @@ public Task<bool> ExecuteInternal()
             // string[] represents a set of target names to build.  Depending on the value 
             // of the RunEachTargetSeparately parameter, we each just call the engine to run all 
             // the targets together, or we call the engine separately for each target.
-            ArrayList targetLists = MSBuild.CreateTargetLists(this.Targets, this.RunEachTargetSeparately);
+            List<string[]> targetLists = MSBuild.CreateTargetLists(Targets, RunEachTargetSeparately);
 
-            ITaskItem[] singleProject = new ITaskItem[1];
+            var singleProject = new ITaskItem[1];
             singleProject[0] = null;
 
             // Build the specified targets in the current project.
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
index 2549ac287ec..28c5475fe86 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.Globalization;
 using System.IO;
@@ -44,7 +43,7 @@ private enum SkipNonexistentProjectsBehavior
         #region Properties
 
         // outputs of all built targets
-        private readonly ArrayList _targetOutputs = new ArrayList();
+        private readonly List<ITaskItem> _targetOutputs = new List<ITaskItem>();
 
         // Whether to skip project files that don't exist on disk. By default we error for such projects.
         private SkipNonexistentProjectsBehavior _skipNonexistentProjects = SkipNonexistentProjectsBehavior.Error;
@@ -57,24 +56,12 @@ private enum SkipNonexistentProjectsBehavior
         /// </summary>
         public IBuildEngine BuildEngine { get; set; }
 
-        public IBuildEngine2 BuildEngine2
-        {
-            get { return (IBuildEngine2)BuildEngine; }
-        }
+        public IBuildEngine2 BuildEngine2 => (IBuildEngine2)BuildEngine;
 
-        public IBuildEngine3 BuildEngine3
-        {
-            get { return (IBuildEngine3)BuildEngine; }
-        }
+        public IBuildEngine3 BuildEngine3 => (IBuildEngine3)BuildEngine;
 
-        public TaskLoggingHelper Log
-        {
-            get
-            {
-                return _logHelper ?? (_logHelper = new TaskLoggingHelperExtension(this,
-                           AssemblyResources.PrimaryResources, AssemblyResources.SharedResources, "MSBuild."));
-            }
-        }
+        public TaskLoggingHelper Log => _logHelper ?? (_logHelper = new TaskLoggingHelperExtension(this,
+            AssemblyResources.PrimaryResources, AssemblyResources.SharedResources, "MSBuild."));
 
         /// <inheritdoc />
         /// <summary>
@@ -122,13 +109,7 @@ public TaskLoggingHelper Log
         /// </summary>
         /// <value>Array of output items.</value>
         [Output]
-        public ITaskItem[] TargetOutputs
-        {
-            get
-            {
-                return (ITaskItem[])_targetOutputs.ToArray(typeof(ITaskItem));
-            }
-        }
+        public ITaskItem[] TargetOutputs => _targetOutputs.ToArray();
 
         /// <summary>
         /// Indicates if the paths of target output items should be rebased relative to the calling project.
@@ -255,14 +236,13 @@ public async Task<bool> ExecuteInternal()
             }
 
             // We have been asked to unescape all escaped characters before processing
-            if (this.TargetAndPropertyListSeparators != null && this.TargetAndPropertyListSeparators.Length > 0)
+            if (TargetAndPropertyListSeparators != null && TargetAndPropertyListSeparators.Length > 0)
             {
                 ExpandAllTargetsAndProperties();
             }
 
             // Parse the global properties into a hashtable.
-            Hashtable propertiesTable;
-            if (!PropertyParser.GetTableWithEscaping(Log, ResourceUtilities.GetResourceString("General.GlobalProperties"), "Properties", this.Properties, out propertiesTable))
+            if (!PropertyParser.GetTableWithEscaping(Log, ResourceUtilities.GetResourceString("General.GlobalProperties"), "Properties", Properties, out Dictionary<string, string> propertiesTable))
             {
                 return false;
             }
@@ -272,7 +252,7 @@ public async Task<bool> ExecuteInternal()
             if (!String.IsNullOrEmpty(RemoveProperties))
             {
                 Log.LogMessageFromResources(MessageImportance.Low, "General.UndefineProperties");
-                undefinePropertiesArray = RemoveProperties.Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
+                undefinePropertiesArray = RemoveProperties.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
                 foreach (string property in undefinePropertiesArray)
                 {
                     Log.LogMessageFromText(String.Format(CultureInfo.InvariantCulture, "  {0}", property), MessageImportance.Low);
@@ -303,14 +283,12 @@ public async Task<bool> ExecuteInternal()
             // string[] represents a set of target names to build.  Depending on the value 
             // of the RunEachTargetSeparately parameter, we each just call the engine to run all 
             // the targets together, or we call the engine separately for each target.
-            ArrayList targetLists = CreateTargetLists(this.Targets, this.RunEachTargetSeparately);
-
+            List<string[]> targetLists = CreateTargetLists(Targets, RunEachTargetSeparately);
 
             bool success = true;
             ITaskItem[] singleProject = null;
             bool[] skipProjects = null;
 
-
             if (BuildInParallel)
             {
                 skipProjects = new bool[Projects.Length];
@@ -411,19 +389,19 @@ public async Task<bool> ExecuteInternal()
         /// <summary>
         /// Build projects which have not been skipped. This will be done in parallel
         /// </summary>
-        private async Task<bool> BuildProjectsInParallel(Hashtable propertiesTable, string[] undefinePropertiesArray, ArrayList targetLists, bool success, bool[] skipProjects)
+        private async Task<bool> BuildProjectsInParallel(Dictionary<string, string> propertiesTable, string[] undefinePropertiesArray, List<string[]> targetLists, bool success, bool[] skipProjects)
         {
             // There were some projects that were skipped so we need to recreate the
             // project array with those projects removed
-            List<ITaskItem> projectsToBuildArrayList = new List<ITaskItem>();
+            var projectsToBuildList = new List<ITaskItem>();
             for (int i = 0; i < Projects.Length; i++)
             {
                 if (!skipProjects[i])
                 {
-                    projectsToBuildArrayList.Add(Projects[i]);
+                    projectsToBuildList.Add(Projects[i]);
                 }
             }
-            var projectToBuildInParallel = projectsToBuildArrayList.ToArray();
+            var projectToBuildInParallel = projectsToBuildList.ToArray();
 
             // Make the call to build the projects
             if (projectToBuildInParallel.Length <= 0) return success;
@@ -458,32 +436,33 @@ private async Task<bool> BuildProjectsInParallel(Hashtable propertiesTable, stri
         /// </summary>
         private void ExpandAllTargetsAndProperties()
         {
-            List<string> expandedProperties = new List<string>();
-            List<string> expandedTargets = new List<string>();
+            var expandedProperties = new List<string>();
+            var expandedTargets = new List<string>();
 
             if (Properties != null)
             {
                 // Expand all properties
-                for (int n = 0; n < Properties.Length; n++)
+                foreach (string p in Properties)
                 {
                     // Split each property according to the separators
-                    string[] expandedPropertyValues = Properties[n].Split(TargetAndPropertyListSeparators, StringSplitOptions.RemoveEmptyEntries);
+                    string[] expandedPropertyValues = p.Split(TargetAndPropertyListSeparators, StringSplitOptions.RemoveEmptyEntries);
                     // Add the resultant properties to the final list
                     foreach (string property in expandedPropertyValues)
                     {
                         expandedProperties.Add(property);
                     }
                 }
+
                 Properties = expandedProperties.ToArray();
             }
 
             if (Targets != null)
             {
                 // Expand all targets
-                for (int n = 0; n < Targets.Length; n++)
+                foreach (string t in Targets)
                 {
                     // Split each target according to the separators
-                    string[] expandedTargetValues = Targets[n].Split(TargetAndPropertyListSeparators, StringSplitOptions.RemoveEmptyEntries);
+                    string[] expandedTargetValues = t.Split(TargetAndPropertyListSeparators, StringSplitOptions.RemoveEmptyEntries);
                     // Add the resultant targets to the final list
                     foreach (string target in expandedTargetValues)
                     {
@@ -495,13 +474,7 @@ private void ExpandAllTargetsAndProperties()
             }
         }
 
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="targets"></param>
-        /// <param name="runEachTargetSeparately"></param>
-        /// <returns></returns>
-        internal static ArrayList CreateTargetLists
+        internal static List<string[]> CreateTargetLists
             (
             string[] targets,
             bool runEachTargetSeparately
@@ -511,7 +484,7 @@ bool runEachTargetSeparately
             // string[] represents a set of target names to build.  Depending on the value 
             // of the RunEachTargetSeparately parameter, we each just call the engine to run all 
             // the targets together, or we call the engine separately for each target.
-            ArrayList targetLists = new ArrayList();
+            var targetLists = new List<string[]>();
             if ((runEachTargetSeparately) && (targets != null) && (targets.Length > 0))
             {
                 // Separate target invocations for each individual target.
@@ -530,20 +503,16 @@ bool runEachTargetSeparately
             return targetLists;
         }
 
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <returns>True if the operation was successful</returns>
         internal static async Task<bool> ExecuteTargets(
             ITaskItem[] projects,
-            Hashtable propertiesTable,
+            Dictionary<string, string> propertiesTable,
             string[] undefineProperties,
-            ArrayList targetLists,
+            List<string[]> targetLists,
             bool stopOnFirstFailure,
             bool rebaseOutputs,
             IBuildEngine3 buildEngine,
             TaskLoggingHelper log,
-            ArrayList targetOutputs,
+            List<ITaskItem> targetOutputs,
             bool useResultsCache,
             bool unloadProjectsOnCompletion,
             string toolsVersion,
@@ -554,12 +523,11 @@ internal static async Task<bool> ExecuteTargets(
             // We don't log a message about the project and targets we're going to
             // build, because it'll all be in the immediately subsequent ProjectStarted event.
 
-            string[] projectDirectory = new string[projects.Length];
-            string[] projectNames = new string[projects.Length];
-            string[] toolsVersions = new string[projects.Length];
-            IList<IDictionary<string, ITaskItem[]>> targetOutputsPerProject = null;
-            IDictionary[] projectProperties = new IDictionary[projects.Length];
-            List<string>[] undefinePropertiesPerProject = new List<string>[projects.Length];
+            var projectDirectory = new string[projects.Length];
+            var projectNames = new string[projects.Length];
+            var toolsVersions = new string[projects.Length];
+            var projectProperties = new Dictionary<string, string>[projects.Length];
+            var undefinePropertiesPerProject = new List<string>[projects.Length];
 
             for (int i = 0; i < projectNames.Length; i++)
             {
@@ -574,15 +542,13 @@ internal static async Task<bool> ExecuteTargets(
                     projectNames[i] = projects[i].ItemSpec;
                     toolsVersions[i] = toolsVersion;
 
-
                     // If the user specified a different set of global properties for this project, then
                     // parse the string containing the properties
                     if (!String.IsNullOrEmpty(projects[i].GetMetadata("Properties")))
                     {
-                        Hashtable preProjectPropertiesTable;
                         if (!PropertyParser.GetTableWithEscaping
-                             (log, ResourceUtilities.FormatResourceString("General.OverridingProperties", projectNames[i]), "Properties", projects[i].GetMetadata("Properties").Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries),
-                              out preProjectPropertiesTable)
+                             (log, ResourceUtilities.FormatResourceString("General.OverridingProperties", projectNames[i]), "Properties", projects[i].GetMetadata("Properties").Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries),
+                              out Dictionary<string, string> preProjectPropertiesTable)
                            )
                         {
                             return false;
@@ -601,7 +567,7 @@ internal static async Task<bool> ExecuteTargets(
                     string projectUndefineProperties = projects[i].GetMetadata("UndefineProperties");
                     if (!String.IsNullOrEmpty(projectUndefineProperties))
                     {
-                        string[] propertiesToUndefine = projectUndefineProperties.Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
+                        string[] propertiesToUndefine = projectUndefineProperties.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
                         if (undefinePropertiesPerProject[i] == null)
                         {
                             undefinePropertiesPerProject[i] = new List<string>(propertiesToUndefine.Length);
@@ -622,29 +588,28 @@ internal static async Task<bool> ExecuteTargets(
                     // parse the string containing the properties
                     if (!String.IsNullOrEmpty(projects[i].GetMetadata("AdditionalProperties")))
                     {
-                        Hashtable additionalProjectPropertiesTable;
                         if (!PropertyParser.GetTableWithEscaping
-                             (log, ResourceUtilities.FormatResourceString("General.AdditionalProperties", projectNames[i]), "AdditionalProperties", projects[i].GetMetadata("AdditionalProperties").Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries),
-                              out additionalProjectPropertiesTable)
+                             (log, ResourceUtilities.FormatResourceString("General.AdditionalProperties", projectNames[i]), "AdditionalProperties", projects[i].GetMetadata("AdditionalProperties").Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries),
+                              out Dictionary<string, string> additionalProjectPropertiesTable)
                            )
                         {
                             return false;
                         }
 
-                        Hashtable combinedTable = new Hashtable(StringComparer.OrdinalIgnoreCase);
+                        var combinedTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                         // First copy in the properties from the global table that not in the additional properties table
                         if (projectProperties[i] != null)
                         {
-                            foreach (DictionaryEntry entry in projectProperties[i])
+                            foreach (KeyValuePair<string, string> entry in projectProperties[i])
                             {
-                                if (!additionalProjectPropertiesTable.Contains(entry.Key))
+                                if (!additionalProjectPropertiesTable.ContainsKey(entry.Key))
                                 {
                                     combinedTable.Add(entry.Key, entry.Value);
                                 }
                             }
                         }
                         // Add all the additional properties
-                        foreach (DictionaryEntry entry in additionalProjectPropertiesTable)
+                        foreach (KeyValuePair<string, string> entry in additionalProjectPropertiesTable)
                         {
                             combinedTable.Add(entry.Key, entry.Value);
                         }
@@ -674,13 +639,12 @@ internal static async Task<bool> ExecuteTargets(
                 // Send the project off to the build engine.  By passing in null to the 
                 // first param, we are indicating that the project to build is the same
                 // as the *calling* project file.
-                bool currentTargetResult = true;
 
-                TaskHost taskHost = (TaskHost)buildEngine;
+                var taskHost = (TaskHost)buildEngine;
                 BuildEngineResult result = await taskHost.InternalBuildProjects(projectNames, targetList, projectProperties, undefinePropertiesPerProject, toolsVersions, true /* ask that target outputs are returned in the buildengineresult */, skipNonexistentTargets);
 
-                currentTargetResult = result.Result;
-                targetOutputsPerProject = result.TargetOutputsPerProject;
+                bool currentTargetResult = result.Result;
+                IList<IDictionary<string, ITaskItem[]>> targetOutputsPerProject = result.TargetOutputsPerProject;
                 success = success && currentTargetResult;
 
                 // If the engine was able to satisfy the build request
@@ -688,7 +652,7 @@ internal static async Task<bool> ExecuteTargets(
                 {
                     for (int i = 0; i < projects.Length; i++)
                     {
-                        IEnumerable nonNullTargetList = targetList ?? targetOutputsPerProject[i].Keys;
+                        IEnumerable<string> nonNullTargetList = targetList ?? targetOutputsPerProject[i].Keys;
 
                         foreach (string targetName in nonNullTargetList)
                         {
diff --git a/src/Framework/IBuildEngine.cs b/src/Framework/IBuildEngine.cs
index a4183d4ebfd..d14aada27ed 100644
--- a/src/Framework/IBuildEngine.cs
+++ b/src/Framework/IBuildEngine.cs
@@ -1,9 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections;
-using System.Runtime.InteropServices;
 
 namespace Microsoft.Build.Framework
 {
diff --git a/src/Framework/IBuildEngine2.cs b/src/Framework/IBuildEngine2.cs
index ddd10a08608..9bfb2949460 100644
--- a/src/Framework/IBuildEngine2.cs
+++ b/src/Framework/IBuildEngine2.cs
@@ -1,9 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections;
-using System.Runtime.InteropServices;
 
 namespace Microsoft.Build.Framework
 {
diff --git a/src/Framework/IBuildEngine3.cs b/src/Framework/IBuildEngine3.cs
index b502af85136..3bbbdc70b09 100644
--- a/src/Framework/IBuildEngine3.cs
+++ b/src/Framework/IBuildEngine3.cs
@@ -4,10 +4,8 @@
 // <summary>Interface for tasks to communicate with the MSBuild engine.</summary>
 //-----------------------------------------------------------------------
 
-using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Text;
 
 namespace Microsoft.Build.Framework
 {
diff --git a/src/Shared/PropertyParser.cs b/src/Shared/PropertyParser.cs
index b795dc8e4a3..7ca92675832 100644
--- a/src/Shared/PropertyParser.cs
+++ b/src/Shared/PropertyParser.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Text;
-using System.Collections;
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -23,13 +22,13 @@ internal static class PropertyParser
         /// a hash table containing the property names as keys and the property values as values.  
         /// </summary>
         /// <returns>true on success, false on failure.</returns>
-        internal static bool GetTable(TaskLoggingHelper log, string parameterName, string[] propertyList, out Hashtable propertiesTable)
+        internal static bool GetTable(TaskLoggingHelper log, string parameterName, string[] propertyList, out Dictionary<string, string> propertiesTable)
         {
             propertiesTable = null;
 
             if (propertyList != null)
             {
-                propertiesTable = new Hashtable(StringComparer.OrdinalIgnoreCase);
+                propertiesTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
                 // Loop through the array.  Each string in the array should be of the form:
                 //          MyPropName=MyPropValue
@@ -79,13 +78,13 @@ internal static bool GetTable(TaskLoggingHelper log, string parameterName, strin
         /// already.
         /// </summary>
         /// <returns>true on success, false on failure.</returns>
-        internal static bool GetTableWithEscaping(TaskLoggingHelper log, string parameterName, string syntaxName, string[] propertyNameValueStrings, out Hashtable finalPropertiesTable)
+        internal static bool GetTableWithEscaping(TaskLoggingHelper log, string parameterName, string syntaxName, string[] propertyNameValueStrings, out Dictionary<string, string> finalPropertiesTable)
         {
             finalPropertiesTable = null;
 
             if (propertyNameValueStrings != null)
             {
-                finalPropertiesTable = new Hashtable(StringComparer.OrdinalIgnoreCase);
+                finalPropertiesTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                 var finalPropertiesList = new List<PropertyNameValuePair>();
 
                 // Loop through the array.  Each string in the array should be of the form:
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index b5cf31f7fd8..b7788b7ebdc 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -48,7 +48,7 @@ public TaskLoggingHelper(ITask taskInstance)
         {
             ErrorUtilities.VerifyThrowArgumentNull(taskInstance, "taskInstance");
             _taskInstance = taskInstance;
-            _taskName = taskInstance.GetType().Name;
+            TaskName = taskInstance.GetType().Name;
         }
 
         /// <summary>
@@ -58,7 +58,7 @@ public TaskLoggingHelper(IBuildEngine buildEngine, string taskName)
         {
             ErrorUtilities.VerifyThrowArgumentNull(buildEngine, "buildEngine");
             ErrorUtilities.VerifyThrowArgumentLength(taskName, "taskName");
-            _taskName = taskName;
+            TaskName = taskName;
             _buildEngine = buildEngine;
         }
 
@@ -77,27 +77,18 @@ public TaskLoggingHelper(IBuildEngine buildEngine, string taskName)
 
         // We have to pass an instance of ITask to BuildEngine, and since we call into the engine from this class we
         // need to store the actual task instance.
-        private ITask _taskInstance;
+        private readonly ITask _taskInstance;
 
         /// <summary>
         /// Object to make this class thread-safe.
         /// </summary>
-        private Object _locker = new Object();
+        private readonly Object _locker = new Object();
 
         /// <summary>
         /// Gets the name of the parent task.
         /// </summary>
         /// <value>Task name string.</value>
-        protected string TaskName
-        {
-            get
-            {
-                return _taskName;
-            }
-        }
-
-        // the name of the parent task
-        private string _taskName;
+        protected string TaskName { get; }
 
         /// <summary>
         /// Gets the upper-case version of the parent task's name.
@@ -123,7 +114,7 @@ private string TaskNameUpperCase
         /// <summary>
         /// The build engine we are going to log against
         /// </summary>
-        private IBuildEngine _buildEngine;
+        private readonly IBuildEngine _buildEngine;
 
         /// <summary>
         /// Shortcut property for getting our build engine - we retrieve it from the task instance
@@ -148,55 +139,20 @@ protected IBuildEngine BuildEngine
         /// Used to load culture-specific resources. Derived classes should register their resources either during construction, or
         /// via this property, if they have localized strings.
         /// </summary>
-        public ResourceManager TaskResources
-        {
-            get
-            {
-                return _taskResources;
-            }
-
-            set
-            {
-                _taskResources = value;
-            }
-        }
+        public ResourceManager TaskResources { get; set; }
 
         // UI resources (including strings) used by the logging methods
-        private ResourceManager _taskResources;
 
         /// <summary>
         /// Gets or sets the prefix used to compose help keywords from string resource names.
         /// </summary>
         /// <value>The help keyword prefix string.</value>
-        public string HelpKeywordPrefix
-        {
-            get
-            {
-                return _helpKeywordPrefix;
-            }
-
-            set
-            {
-                _helpKeywordPrefix = value;
-            }
-        }
-
-        // the prefix for composing help keywords
-        private string _helpKeywordPrefix;
+        public string HelpKeywordPrefix { get; set; }
 
         /// <summary>
         /// Has the task logged any errors through this logging helper object?
         /// </summary>
-        public bool HasLoggedErrors
-        {
-            get
-            {
-                return _hasLoggedErrors;
-            }
-        }
-
-        // Has the task logged any errors through this logging helper object?
-        private bool _hasLoggedErrors = false;
+        public bool HasLoggedErrors { get; private set; }
 
         #endregion
 
@@ -217,10 +173,9 @@ public bool HasLoggedErrors
         /// <exception cref="ArgumentNullException">Thrown when <c>message</c> is null.</exception>
         public string ExtractMessageCode(string message, out string messageWithoutCodePrefix)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(message, "message");
+            ErrorUtilities.VerifyThrowArgumentNull(message, nameof(message));
 
-            string code;
-            messageWithoutCodePrefix = ResourceUtilities.ExtractMessageCode(false /* any code */, message, out code);
+            messageWithoutCodePrefix = ResourceUtilities.ExtractMessageCode(false /* any code */, message, out string code);
 
             return code;
         }
@@ -240,9 +195,9 @@ public string ExtractMessageCode(string message, out string messageWithoutCodePr
         /// <exception cref="ArgumentNullException">Thrown when <c>resourceName</c> is null.</exception>
         /// <exception cref="ArgumentException">Thrown when the string resource indicated by <c>resourceName</c> does not exist.</exception>
         /// <exception cref="InvalidOperationException">Thrown when the <c>TaskResources</c> property of the owner task is not set.</exception>
-        virtual public string FormatResourceString(string resourceName, params object[] args)
+        public virtual string FormatResourceString(string resourceName, params object[] args)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(resourceName, "resourceName");
+            ErrorUtilities.VerifyThrowArgumentNull(resourceName, nameof(resourceName));
             ErrorUtilities.VerifyThrowInvalidOperation(TaskResources != null, "Shared.TaskResourcesNotRegistered", TaskName);
 
             string resourceString = TaskResources.GetString(resourceName, CultureInfo.CurrentUICulture);
@@ -260,9 +215,9 @@ virtual public string FormatResourceString(string resourceName, params object[]
         /// <param name="args">Arguments for formatting.</param>
         /// <returns>The formatted string.</returns>
         /// <exception cref="ArgumentNullException">Thrown when <c>unformatted</c> is null.</exception>
-        virtual public string FormatString(string unformatted, params object[] args)
+        public virtual string FormatString(string unformatted, params object[] args)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(unformatted, "unformatted");
+            ErrorUtilities.VerifyThrowArgumentNull(unformatted, nameof(unformatted));
 
             return ResourceUtilities.FormatString(unformatted, args);
         }
@@ -273,7 +228,7 @@ virtual public string FormatString(string unformatted, params object[] args)
         /// </summary>
         /// <param name="resourceName">The resource name.</param>
         /// <returns>The message from resource.</returns>
-        virtual public string GetResourceMessage(string resourceName)
+        public virtual string GetResourceMessage(string resourceName)
         {
             string resourceString = FormatResourceString(resourceName, null);
             return resourceString;
@@ -314,7 +269,7 @@ public void LogMessage(string message, params object[] messageArgs)
         public void LogMessage(MessageImportance importance, string message, params object[] messageArgs)
         {
             // No lock needed, as BuildEngine methods from v4.5 onwards are thread safe.
-            ErrorUtilities.VerifyThrowArgumentNull(message, "message");
+            ErrorUtilities.VerifyThrowArgumentNull(message, nameof(message));
 
             BuildMessageEventArgs e = new BuildMessageEventArgs
                 (
@@ -377,7 +332,7 @@ params object[] messageArgs
         )
         {
             // No lock needed, as BuildEngine methods from v4.5 onwards are thread safe.
-            ErrorUtilities.VerifyThrowArgumentNull(message, "message");
+            ErrorUtilities.VerifyThrowArgumentNull(message, nameof(message));
 
             // If BuildEngine is null, task attempted to log before it was set on it,
             // presumably in its constructor. This is not allowed, and all
@@ -388,7 +343,7 @@ params object[] messageArgs
             // that gives the user something.
             bool fillInLocation = (String.IsNullOrEmpty(file) && (lineNumber == 0) && (columnNumber == 0));
 
-            BuildMessageEventArgs e = new BuildMessageEventArgs
+            var e = new BuildMessageEventArgs
                 (
                     subcategory,
                     code,
@@ -438,7 +393,7 @@ params object[] messageArgs
         )
         {
             // No lock needed, as BuildEngine methods from v4.5 onwards are thread safe.
-            ErrorUtilities.VerifyThrowArgumentNull(message, "message");
+            ErrorUtilities.VerifyThrowArgumentNull(message, nameof(message));
 
             // If BuildEngine is null, task attempted to log before it was set on it,
             // presumably in its constructor. This is not allowed, and all
@@ -449,7 +404,7 @@ params object[] messageArgs
             // that gives the user something.
             bool fillInLocation = (String.IsNullOrEmpty(file) && (lineNumber == 0) && (columnNumber == 0));
 
-            CriticalBuildMessageEventArgs e = new CriticalBuildMessageEventArgs
+            var e = new CriticalBuildMessageEventArgs
                 (
                     subcategory,
                     code,
@@ -504,7 +459,7 @@ public void LogMessageFromResources(MessageImportance importance, string message
         {
             // No lock needed, as the logging methods are thread safe and the rest does not modify
             // global state.
-            ErrorUtilities.VerifyThrowArgumentNull(messageResourceName, "messageResourceName");
+            ErrorUtilities.VerifyThrowArgumentNull(messageResourceName, nameof(messageResourceName));
 
             LogMessage(importance, FormatResourceString(messageResourceName, messageArgs));
 #if _DEBUG
@@ -537,7 +492,7 @@ string targetNames
         )
         {
             // No lock needed, as BuildEngine methods from v4.5 onwards are thread safe.
-            ExternalProjectStartedEventArgs eps = new ExternalProjectStartedEventArgs(message, helpKeyword, TaskName, projectFile, targetNames);
+            var eps = new ExternalProjectStartedEventArgs(message, helpKeyword, TaskName, projectFile, targetNames);
             BuildEngine.LogCustomEvent(eps);
         }
 
@@ -558,7 +513,7 @@ bool succeeded
         )
         {
             // No lock needed, as BuildEngine methods from v4.5 onwards are thread safe.
-            ExternalProjectFinishedEventArgs epf = new ExternalProjectFinishedEventArgs(message, helpKeyword, TaskName, projectFile, succeeded);
+            var epf = new ExternalProjectFinishedEventArgs(message, helpKeyword, TaskName, projectFile, succeeded);
             BuildEngine.LogCustomEvent(epf);
         }
 
@@ -586,9 +541,9 @@ public void LogCommandLine(string commandLine)
         public void LogCommandLine(MessageImportance importance, string commandLine)
         {
             // No lock needed, as BuildEngine methods from v4.5 onwards are thread safe.
-            ErrorUtilities.VerifyThrowArgumentNull(commandLine, "commandLine");
+            ErrorUtilities.VerifyThrowArgumentNull(commandLine, nameof(commandLine));
 
-            TaskCommandLineEventArgs e = new TaskCommandLineEventArgs(commandLine, TaskName, importance);
+            var e = new TaskCommandLineEventArgs(commandLine, TaskName, importance);
 
             // If BuildEngine is null, the task attempted to log before it was set on it,
             // presumably in its constructor. This is not allowed, and all we can do is throw.
@@ -648,7 +603,7 @@ params object[] messageArgs
         )
         {
             // No lock needed, as BuildEngine methods from v4.5 onwards are thread safe.
-            ErrorUtilities.VerifyThrowArgumentNull(message, "message");
+            ErrorUtilities.VerifyThrowArgumentNull(message, nameof(message));
 
             // If BuildEngine is null, task attempted to log before it was set on it,
             // presumably in its constructor. This is not allowed, and all
@@ -667,7 +622,7 @@ params object[] messageArgs
             // that gives the user something.
             bool fillInLocation = (String.IsNullOrEmpty(file) && (lineNumber == 0) && (columnNumber == 0));
 
-            BuildErrorEventArgs e = new BuildErrorEventArgs
+            var e = new BuildErrorEventArgs
                 (
                     subcategory,
                     errorCode,
@@ -684,7 +639,7 @@ params object[] messageArgs
                 );
             BuildEngine.LogErrorEvent(e);
 
-            _hasLoggedErrors = true;
+            HasLoggedErrors = true;
         }
 
         /// <summary>
@@ -730,7 +685,7 @@ params object[] messageArgs
         {
             // No lock needed, as the logging methods are thread safe and the rest does not modify
             // global state.
-            ErrorUtilities.VerifyThrowArgumentNull(messageResourceName, "messageResourceName");
+            ErrorUtilities.VerifyThrowArgumentNull(messageResourceName, nameof(messageResourceName));
 
             string subcategory = null;
 
@@ -816,7 +771,7 @@ params object[] messageArgs
         {
             // No lock needed, as the logging methods are thread safe and the rest does not modify
             // global state.
-            ErrorUtilities.VerifyThrowArgumentNull(messageResourceName, "messageResourceName");
+            ErrorUtilities.VerifyThrowArgumentNull(messageResourceName, nameof(messageResourceName));
 
             string subcategory = null;
 
@@ -825,8 +780,7 @@ params object[] messageArgs
                 subcategory = FormatResourceString(subcategoryResourceName);
             }
 
-            string errorCode;
-            string message = ResourceUtilities.ExtractMessageCode(false /* all codes */, FormatResourceString(messageResourceName, messageArgs), out errorCode);
+            string message = ResourceUtilities.ExtractMessageCode(false /* all codes */, FormatResourceString(messageResourceName, messageArgs), out string errorCode);
 
             string helpKeyword = null;
 
@@ -887,9 +841,9 @@ public void LogErrorFromException(Exception exception, bool showStackTrace, bool
         {
             // No lock needed, as the logging methods are thread safe and the rest does not modify
             // global state.
-            ErrorUtilities.VerifyThrowArgumentNull(exception, "exception");
+            ErrorUtilities.VerifyThrowArgumentNull(exception, nameof(exception));
 
-            string message = null;
+            string message;
 
             if (!showDetail && (Environment.GetEnvironmentVariable("MSBUILDDIAGNOSTICS") == null)) // This env var is also used in ToolTask
             {
@@ -904,7 +858,7 @@ public void LogErrorFromException(Exception exception, bool showStackTrace, bool
             {
                 // The more comprehensive output, showing exception types
                 // and inner exceptions
-                StringBuilder builder = new StringBuilder(200);
+                var builder = new StringBuilder(200);
                 do
                 {
                     builder.Append(exception.GetType().Name);
@@ -969,7 +923,7 @@ params object[] messageArgs
         )
         {
             // No lock needed, as BuildEngine methods from v4.5 onwards are thread safe.
-            ErrorUtilities.VerifyThrowArgumentNull(message, "message");
+            ErrorUtilities.VerifyThrowArgumentNull(message, nameof(message));
 
             // If BuildEngine is null, task attempted to log before it was set on it,
             // presumably in its constructor. This is not allowed, and all
@@ -988,7 +942,7 @@ params object[] messageArgs
             // that gives the user something.
             bool fillInLocation = (String.IsNullOrEmpty(file) && (lineNumber == 0) && (columnNumber == 0));
 
-            BuildWarningEventArgs e = new BuildWarningEventArgs
+            var e = new BuildWarningEventArgs
                 (
                     subcategory,
                     warningCode,
@@ -1050,7 +1004,7 @@ params object[] messageArgs
         {
             // No lock needed, as log methods are thread safe and the rest does not modify
             // global state.
-            ErrorUtilities.VerifyThrowArgumentNull(messageResourceName, "messageResourceName");
+            ErrorUtilities.VerifyThrowArgumentNull(messageResourceName, nameof(messageResourceName));
 
             string subcategory = null;
 
@@ -1064,9 +1018,8 @@ params object[] messageArgs
             // should have been called instead, so that the errorCode field gets populated.
             // Check this only in debug, to avoid the cost of attempting to extract a
             // message code when there probably isn't one.
-            string messageCode;
-            string throwAwayMessageBody = ResourceUtilities.ExtractMessageCode(true /* only msbuild codes */, FormatResourceString(messageResourceName, messageArgs), out messageCode);
-            Debug.Assert(messageCode == null || messageCode.Length == 0, "Called LogWarningFromResources instead of LogWarningWithCodeFromResources, but message '" + throwAwayMessageBody + "' does have an error code '" + messageCode + "'");
+            string throwAwayMessageBody = ResourceUtilities.ExtractMessageCode(true /* only msbuild codes */, FormatResourceString(messageResourceName, messageArgs), out string messageCode);
+            Debug.Assert(string.IsNullOrEmpty(messageCode), "Called LogWarningFromResources instead of LogWarningWithCodeFromResources, but message '" + throwAwayMessageBody + "' does have an error code '" + messageCode + "'");
 #endif
 
             LogWarning
@@ -1136,7 +1089,7 @@ params object[] messageArgs
         {
             // No lock needed, as log methods are thread safe and the rest does not modify
             // global state.
-            ErrorUtilities.VerifyThrowArgumentNull(messageResourceName, "messageResourceName");
+            ErrorUtilities.VerifyThrowArgumentNull(messageResourceName, nameof(messageResourceName));
 
             string subcategory = null;
 
@@ -1145,8 +1098,7 @@ params object[] messageArgs
                 subcategory = FormatResourceString(subcategoryResourceName);
             }
 
-            string warningCode;
-            string message = ResourceUtilities.ExtractMessageCode(false /* all codes */, FormatResourceString(messageResourceName, messageArgs), out warningCode);
+            string message = ResourceUtilities.ExtractMessageCode(false /* all codes */, FormatResourceString(messageResourceName, messageArgs), out string warningCode);
 
             string helpKeyword = null;
 
@@ -1191,7 +1143,7 @@ public void LogWarningFromException(Exception exception, bool showStackTrace)
         {
             // No lock needed, as log methods are thread safe and the rest does not modify
             // global state.
-            ErrorUtilities.VerifyThrowArgumentNull(exception, "exception");
+            ErrorUtilities.VerifyThrowArgumentNull(exception, nameof(exception));
 
             string message = exception.Message;
 
@@ -1233,13 +1185,13 @@ public bool LogMessagesFromFile(string fileName, MessageImportance messageImport
         {
             // No lock needed, as log methods are thread safe and the rest does not modify
             // global state.
-            ErrorUtilities.VerifyThrowArgumentNull(fileName, "fileName");
+            ErrorUtilities.VerifyThrowArgumentNull(fileName, nameof(fileName));
 
-            bool errorsFound = false;
+            bool errorsFound;
 
             // Command-line tools are generally going to emit their output using the current 
             // codepage, so that it displays correctly in the console window.  
-            using (StreamReader fileStream = FileUtilities.OpenRead(fileName, System.Text.Encoding.GetEncoding(0))) // HIGHCHAR: Use ANSI for logging messages.
+            using (StreamReader fileStream = FileUtilities.OpenRead(fileName, Encoding.GetEncoding(0))) // HIGHCHAR: Use ANSI for logging messages.
             {
                 errorsFound = LogMessagesFromStream(fileStream, messageImportance);
             }
@@ -1260,7 +1212,7 @@ public bool LogMessagesFromStream(TextReader stream, MessageImportance messageIm
         {
             // No lock needed, as log methods are thread safe and the rest does not modify
             // global state.
-            ErrorUtilities.VerifyThrowArgumentNull(stream, "stream");
+            ErrorUtilities.VerifyThrowArgumentNull(stream, nameof(stream));
 
             bool errorsFound = false;
             string lineOfText;
@@ -1288,7 +1240,7 @@ public bool LogMessageFromText(string lineOfText, MessageImportance messageImpor
         {
             // No lock needed, as log methods are thread safe and the rest does not modify
             // global state.
-            ErrorUtilities.VerifyThrowArgumentNull(lineOfText, "lineOfText");
+            ErrorUtilities.VerifyThrowArgumentNull(lineOfText, nameof(lineOfText));
 
             bool isError = false;
             CanonicalError.Parts messageParts = CanonicalError.Parse(lineOfText);
@@ -1401,8 +1353,7 @@ public override object InitializeLifetimeService()
 
                 if (!String.IsNullOrEmpty(initialLeaseTimeFromEnvironment))
                 {
-                    int leaseTimeFromEnvironment;
-                    if (int.TryParse(initialLeaseTimeFromEnvironment, out leaseTimeFromEnvironment) && leaseTimeFromEnvironment > 0)
+                    if (int.TryParse(initialLeaseTimeFromEnvironment, out int leaseTimeFromEnvironment) && leaseTimeFromEnvironment > 0)
                     {
                         initialLeaseTime = leaseTimeFromEnvironment;
                     }
@@ -1421,8 +1372,7 @@ public override object InitializeLifetimeService()
                 string leaseExtensionTimeFromEnvironment = Environment.GetEnvironmentVariable("MSBUILDTASKLOGGINGHELPERLEASEEXTENSIONTIME");
                 if (!String.IsNullOrEmpty(leaseExtensionTimeFromEnvironment))
                 {
-                    int leaseExtensionFromEnvironment;
-                    if (int.TryParse(leaseExtensionTimeFromEnvironment, out leaseExtensionFromEnvironment) && leaseExtensionFromEnvironment > 0)
+                    if (int.TryParse(leaseExtensionTimeFromEnvironment, out int leaseExtensionFromEnvironment) && leaseExtensionFromEnvironment > 0)
                     {
                         leaseExtensionTime = leaseExtensionFromEnvironment;
                     }
@@ -1455,10 +1405,7 @@ public void MarkAsInactive()
                 {
                     ILease lease = (ILease)RemotingServices.GetLifetimeService(this);
 
-                    if (lease != null)
-                    {
-                        lease.Unregister(_sponsor);
-                    }
+                    lease?.Unregister(_sponsor);
 
                     _sponsor.Close();
                     _sponsor = null;
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index bfc88672358..96e35cb8ad1 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -3289,12 +3289,11 @@ public void ResolveToGACSpecificVersion()
         [Trait("Category", "mono-osx-failing")]
         public void ParentAssemblyResolvedFromAForGac()
         {
-            Hashtable parentReferenceFolderHash = new Hashtable();
-            List<string> parentReferenceFolders = new List<string>();
-            List<Reference> referenceList = new List<Reference>();
+            var parentReferenceFolders = new List<string>();
+            var referenceList = new List<Reference>();
 
-            TaskItem taskItem = new TaskItem("Microsoft.VisualStudio.Interopt, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
-            Reference reference = new Reference(isWinMDFile, fileExists, getRuntimeVersion);
+            var taskItem = new TaskItem("Microsoft.VisualStudio.Interopt, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
+            var reference = new Reference(isWinMDFile, fileExists, getRuntimeVersion);
             reference.MakePrimaryAssemblyReference(taskItem, false, ".dll");
             reference.FullPath = "c:\\AssemblyFolders\\Microsoft.VisualStudio.Interopt.dll";
             reference.ResolvedSearchPath = "{AssemblyFolders}";
@@ -3315,14 +3314,13 @@ public void ParentAssemblyResolvedFromAForGac()
 
             foreach (Reference parentReference in referenceList)
             {
-                ReferenceTable.CalculateParentAssemblyDirectories(parentReferenceFolderHash, parentReferenceFolders, parentReference);
+                ReferenceTable.CalculateParentAssemblyDirectories(parentReferenceFolders, parentReference);
             }
 
             Assert.Equal(1, parentReferenceFolders.Count);
             Assert.True(parentReferenceFolders[0].Equals(reference2.ResolvedSearchPath, StringComparison.OrdinalIgnoreCase));
         }
-
-
+        
         /// <summary>
         /// Generate a fake reference which has been resolved from the gac. We will use it to verify the creation of the exclusion list.
         /// </summary>
diff --git a/src/Tasks.UnitTests/DependentAssembly_Tests.cs b/src/Tasks.UnitTests/DependentAssembly_Tests.cs
index 90df1d84c4b..1e928ac2a91 100644
--- a/src/Tasks.UnitTests/DependentAssembly_Tests.cs
+++ b/src/Tasks.UnitTests/DependentAssembly_Tests.cs
@@ -1,11 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections;
 using System.Xml;
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Xunit;
 
@@ -19,7 +16,7 @@ public class DependentAssembly_Tests
         [Fact]
         public void SerializeDeserialize()
         {
-            DependentAssembly dependentAssembly = new DependentAssembly();
+            var dependentAssembly = new DependentAssembly();
 
             string xml = "<assemblyIdentity name='ClassLibrary1'/>";
 
diff --git a/src/Tasks.UnitTests/PropertyParser_Tests.cs b/src/Tasks.UnitTests/PropertyParser_Tests.cs
index adec95d8c24..7a1b483fdfa 100644
--- a/src/Tasks.UnitTests/PropertyParser_Tests.cs
+++ b/src/Tasks.UnitTests/PropertyParser_Tests.cs
@@ -1,27 +1,18 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.IO;
-using System.Reflection;
-using System.Collections;
-using Microsoft.Build.Framework;
+using System.Collections.Generic;
 using Microsoft.Build.Tasks;
-using Microsoft.Build.Utilities;
-using System.Text.RegularExpressions;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
 {
-    sealed public class PropertyParser_Tests
+    public sealed class PropertyParser_Tests
     {
-        /// <summary>
-        /// </summary>
         [Fact]
         public void GetTable1()
         {
-            Hashtable propertiesTable;
-            Assert.True(PropertyParser.GetTable(null, "Properties", null, out propertiesTable));
+            Assert.True(PropertyParser.GetTable(null, "Properties", null, out Dictionary<string, string> propertiesTable));
 
             // We should have null table.
             Assert.Null(propertiesTable);
@@ -32,9 +23,8 @@ public void GetTable1()
         [Fact]
         public void GetPropertiesTable3()
         {
-            Hashtable propertiesTable;
             Assert.True(PropertyParser.GetTable(null, "Properties",
-                new string[] { "Configuration=Debug" }, out propertiesTable));
+                new[] { "Configuration=Debug" }, out Dictionary<string, string> propertiesTable));
 
             // We should have a table that looks like this:
             //      KEY                 VALUE
@@ -42,7 +32,7 @@ public void GetPropertiesTable3()
             //      Configuration       Debug
 
             Assert.Equal(1, propertiesTable.Count);
-            Assert.Equal("Debug", (string)propertiesTable["Configuration"]);
+            Assert.Equal("Debug", propertiesTable["Configuration"]);
         }
 
         /// <summary>
@@ -50,9 +40,8 @@ public void GetPropertiesTable3()
         [Fact]
         public void GetPropertiesTable4()
         {
-            Hashtable propertiesTable;
             Assert.True(PropertyParser.GetTable(null, "Properties",
-                new string[] { "Configuration=Debug", "Platform=AnyCPU", "VBL=Lab22Dev" }, out propertiesTable));
+                new[] { "Configuration=Debug", "Platform=AnyCPU", "VBL=Lab22Dev" }, out Dictionary<string, string> propertiesTable));
 
             // We should have a table that looks like this:
             //      KEY                 VALUE
@@ -62,9 +51,9 @@ public void GetPropertiesTable4()
             //      VBL                 Lab22Dev
 
             Assert.Equal(3, propertiesTable.Count);
-            Assert.Equal("Debug", (string)propertiesTable["Configuration"]);
-            Assert.Equal("AnyCPU", (string)propertiesTable["Platform"]);
-            Assert.Equal("Lab22Dev", (string)propertiesTable["VBL"]);
+            Assert.Equal("Debug", propertiesTable["Configuration"]);
+            Assert.Equal("AnyCPU", propertiesTable["Platform"]);
+            Assert.Equal("Lab22Dev", propertiesTable["VBL"]);
         }
 
         /// <summary>
@@ -72,9 +61,8 @@ public void GetPropertiesTable4()
         [Fact]
         public void GetPropertiesTable5()
         {
-            Hashtable propertiesTable;
             Assert.True(PropertyParser.GetTable(null, "Properties",
-                new string[] { "Configuration = Debug", "Platform \t=       AnyCPU" }, out propertiesTable));
+                new[] { "Configuration = Debug", "Platform \t=       AnyCPU" }, out Dictionary<string, string> propertiesTable));
 
             // We should have a table that looks like this:
             //      KEY                 VALUE
@@ -83,8 +71,8 @@ public void GetPropertiesTable5()
             //      Platform            AnyCPU
 
             Assert.Equal(2, propertiesTable.Count);
-            Assert.Equal("Debug", (string)propertiesTable["Configuration"]);
-            Assert.Equal("AnyCPU", (string)propertiesTable["Platform"]);
+            Assert.Equal("Debug", propertiesTable["Configuration"]);
+            Assert.Equal("AnyCPU", propertiesTable["Platform"]);
         }
 
         /// <summary>
@@ -92,9 +80,8 @@ public void GetPropertiesTable5()
         [Fact]
         public void GetPropertiesTable6()
         {
-            Hashtable propertiesTable;
             Assert.True(PropertyParser.GetTable(null, "Properties",
-                new string[] { "Configuration=", "Platform =  " }, out propertiesTable));
+                new[] { "Configuration=", "Platform =  " }, out Dictionary<string, string> propertiesTable));
 
             // We should have a table that looks like this:
             //      KEY                 VALUE
@@ -103,8 +90,8 @@ public void GetPropertiesTable6()
             //      Platform            <blank>
 
             Assert.Equal(2, propertiesTable.Count);
-            Assert.Equal("", (string)propertiesTable["Configuration"]);
-            Assert.Equal("", (string)propertiesTable["Platform"]);
+            Assert.Equal("", propertiesTable["Configuration"]);
+            Assert.Equal("", propertiesTable["Platform"]);
         }
 
         /// <summary>
@@ -112,10 +99,8 @@ public void GetPropertiesTable6()
         [Fact]
         public void GetPropertiesTable7()
         {
-            Hashtable propertiesTable;
-
             // This is a failure case.
-            Assert.False(PropertyParser.GetTable(null, "Properties", new string[] { "=Debug" }, out propertiesTable));
+            Assert.False(PropertyParser.GetTable(null, "Properties", new[] { "=Debug" }, out _));
         }
 
         /// <summary>
@@ -123,11 +108,9 @@ public void GetPropertiesTable7()
         [Fact]
         public void GetPropertiesTable8()
         {
-            Hashtable propertiesTable;
-
             // This is a failure case.  (Second property "x86" doesn't have a value.)
             Assert.False(PropertyParser.GetTable(null, "Properties",
-                new string[] { "Configuration=Debug", "x86" }, out propertiesTable));
+                new[] { "Configuration=Debug", "x86" }, out _));
         }
 
         /// <summary>
@@ -135,9 +118,8 @@ public void GetPropertiesTable8()
         [Fact]
         public void GetPropertiesTable9()
         {
-            Hashtable propertiesTable;
             Assert.True(PropertyParser.GetTable(null, "Properties",
-                new string[] { "DependsOn = Clean; Build" }, out propertiesTable));
+                new[] { "DependsOn = Clean; Build" }, out Dictionary<string, string> propertiesTable));
 
             // We should have a table that looks like this:
             //      KEY                 VALUE
@@ -145,7 +127,7 @@ public void GetPropertiesTable9()
             //      Depends On          Clean; Build
 
             Assert.Equal(1, propertiesTable.Count);
-            Assert.Equal("Clean; Build", (string)propertiesTable["DependsOn"]);
+            Assert.Equal("Clean; Build", propertiesTable["DependsOn"]);
         }
 
         /// <summary>
@@ -153,9 +135,8 @@ public void GetPropertiesTable9()
         [Fact]
         public void GetPropertiesTable10()
         {
-            Hashtable propertiesTable;
             Assert.True(PropertyParser.GetTable(null, "Properties",
-                new string[] { "Depends On = CleanBuild" }, out propertiesTable));
+                new[] { "Depends On = CleanBuild" }, out Dictionary<string, string> propertiesTable));
 
             // We should have a table that looks like this:
             //      KEY                 VALUE
@@ -163,15 +144,14 @@ public void GetPropertiesTable10()
             //      Depends On          CleanBuild
 
             Assert.Equal(1, propertiesTable.Count);
-            Assert.Equal("CleanBuild", (string)propertiesTable["Depends On"]);
+            Assert.Equal("CleanBuild", propertiesTable["Depends On"]);
         }
 
         [Fact]
         public void GetPropertiesTableWithEscaping1()
         {
-            Hashtable propertiesTable;
             Assert.True(PropertyParser.GetTableWithEscaping(null, "Properties", "Properties",
-                new string[] { "Configuration = Debug", "Platform = Any CPU" }, out propertiesTable));
+                new[] { "Configuration = Debug", "Platform = Any CPU" }, out Dictionary<string, string> propertiesTable));
 
             // We should have a table that looks like this:
             //      KEY                 VALUE
@@ -180,16 +160,15 @@ public void GetPropertiesTableWithEscaping1()
             //      Platform            Any CPU
 
             Assert.Equal(2, propertiesTable.Count);
-            Assert.Equal("Debug", (string)propertiesTable["Configuration"]);
-            Assert.Equal("Any CPU", (string)propertiesTable["Platform"]);
+            Assert.Equal("Debug", propertiesTable["Configuration"]);
+            Assert.Equal("Any CPU", propertiesTable["Platform"]);
         }
 
         [Fact]
         public void GetPropertiesTableWithEscaping2()
         {
-            Hashtable propertiesTable;
             Assert.True(PropertyParser.GetTableWithEscaping(null, "Properties", "Properties",
-                new string[] { "WarningsAsErrors = 1234", "5678", "9999", "Configuration=Debug" }, out propertiesTable));
+                new[] { "WarningsAsErrors = 1234", "5678", "9999", "Configuration=Debug" }, out Dictionary<string, string> propertiesTable));
 
             // We should have a table that looks like this:
             //      KEY                 VALUE
@@ -198,16 +177,15 @@ public void GetPropertiesTableWithEscaping2()
             //      Configuration       Debug
 
             Assert.Equal(2, propertiesTable.Count);
-            Assert.Equal("1234;5678;9999", (string)propertiesTable["WarningsAsErrors"]);
-            Assert.Equal("Debug", (string)propertiesTable["Configuration"]);
+            Assert.Equal("1234;5678;9999", propertiesTable["WarningsAsErrors"]);
+            Assert.Equal("Debug", propertiesTable["Configuration"]);
         }
 
         [Fact]
         public void GetPropertiesTableWithEscaping3()
         {
-            Hashtable propertiesTable;
             Assert.True(PropertyParser.GetTableWithEscaping(null, "Properties", "Properties",
-                new string[] { @"OutDir=c:\Rajeev;s Stuff\binaries", "Configuration=Debug" }, out propertiesTable));
+                new[] { @"OutDir=c:\Rajeev;s Stuff\binaries", "Configuration=Debug" }, out Dictionary<string, string> propertiesTable));
 
             // We should have a table that looks like this:
             //      KEY                 VALUE
@@ -216,8 +194,8 @@ public void GetPropertiesTableWithEscaping3()
             //      Configuration       Debug
 
             Assert.Equal(2, propertiesTable.Count);
-            Assert.Equal(@"c:\Rajeev%3bs Stuff\binaries", (string)propertiesTable["OutDir"]);
-            Assert.Equal("Debug", (string)propertiesTable["Configuration"]);
+            Assert.Equal(@"c:\Rajeev%3bs Stuff\binaries", propertiesTable["OutDir"]);
+            Assert.Equal("Debug", propertiesTable["Configuration"]);
         }
     }
 }
diff --git a/src/Tasks/Al.cs b/src/Tasks/Al.cs
index 3cb3f319a52..4766031c628 100644
--- a/src/Tasks/Al.cs
+++ b/src/Tasks/Al.cs
@@ -6,7 +6,6 @@
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
 {
@@ -69,106 +68,106 @@ link the file as a resource to the assembly
 */
         public string AlgorithmId
         {
-            set { Bag["AlgorithmId"] = value; }
-            get { return (string)Bag["AlgorithmId"]; }
+            set => Bag[nameof(AlgorithmId)] = value;
+            get => (string)Bag[nameof(AlgorithmId)];
         }
 
         public string BaseAddress
         {
-            set { Bag["BaseAddress"] = value; }
-            get { return (string)Bag["BaseAddress"]; }
+            set => Bag[nameof(BaseAddress)] = value;
+            get => (string)Bag[nameof(BaseAddress)];
         }
 
         public string CompanyName
         {
-            set { Bag["CompanyName"] = value; }
-            get { return (string)Bag["CompanyName"]; }
+            set => Bag[nameof(CompanyName)] = value;
+            get => (string)Bag[nameof(CompanyName)];
         }
 
         public string Configuration
         {
-            set { Bag["Configuration"] = value; }
-            get { return (string)Bag["Configuration"]; }
+            set => Bag[nameof(Configuration)] = value;
+            get => (string)Bag[nameof(Configuration)];
         }
 
         public string Copyright
         {
-            set { Bag["Copyright"] = value; }
-            get { return (string)Bag["Copyright"]; }
+            set => Bag[nameof(Copyright)] = value;
+            get => (string)Bag[nameof(Copyright)];
         }
 
         public string Culture
         {
-            set { Bag["Culture"] = value; }
-            get { return (string)Bag["Culture"]; }
+            set => Bag[nameof(Culture)] = value;
+            get => (string)Bag[nameof(Culture)];
         }
 
         public bool DelaySign
         {
-            set { Bag["DelaySign"] = value; }
-            get { return GetBoolParameterWithDefault("DelaySign", false); }
+            set => Bag[nameof(DelaySign)] = value;
+            get => GetBoolParameterWithDefault(nameof(DelaySign), false);
         }
 
         public string Description
         {
-            set { Bag["Description"] = value; }
-            get { return (string)Bag["Description"]; }
+            set => Bag[nameof(Description)] = value;
+            get => (string)Bag[nameof(Description)];
         }
 
         public string EvidenceFile
         {
-            set { Bag["EvidenceFile"] = value; }
-            get { return (string)Bag["EvidenceFile"]; }
+            set => Bag[nameof(EvidenceFile)] = value;
+            get => (string)Bag[nameof(EvidenceFile)];
         }
 
         public string FileVersion
         {
-            set { Bag["FileVersion"] = value; }
-            get { return (string)Bag["FileVersion"]; }
+            set => Bag[nameof(FileVersion)] = value;
+            get => (string)Bag[nameof(FileVersion)];
         }
 
         public string Flags
         {
-            set { Bag["Flags"] = value; }
-            get { return (string)Bag["Flags"]; }
+            set => Bag["Flags"] = value;
+            get => (string)Bag["Flags"];
         }
 
         public bool GenerateFullPaths
         {
-            set { Bag["GenerateFullPaths"] = value; }
-            get { return GetBoolParameterWithDefault("GenerateFullPaths", false); }
+            set => Bag[nameof(GenerateFullPaths)] = value;
+            get => GetBoolParameterWithDefault(nameof(GenerateFullPaths), false);
         }
 
         public string KeyFile
         {
-            set { Bag["KeyFile"] = value; }
-            get { return (string)Bag["KeyFile"]; }
+            set => Bag[nameof(KeyFile)] = value;
+            get => (string)Bag[nameof(KeyFile)];
         }
 
         public string KeyContainer
         {
-            set { Bag["KeyContainer"] = value; }
-            get { return (string)Bag["KeyContainer"]; }
+            set => Bag[nameof(KeyContainer)] = value;
+            get => (string)Bag[nameof(KeyContainer)];
         }
 
         public string MainEntryPoint
         {
-            set { Bag["MainEntryPoint"] = value; }
-            get { return (string)Bag["MainEntryPoint"]; }
+            set => Bag[nameof(MainEntryPoint)] = value;
+            get => (string)Bag[nameof(MainEntryPoint)];
         }
 
         [Output]
         [Required]
         public ITaskItem OutputAssembly
         {
-            set { Bag["OutputAssembly"] = value; }
-            get { return (ITaskItem)Bag["OutputAssembly"]; }
+            set => Bag[nameof(OutputAssembly)] = value;
+            get => (ITaskItem)Bag[nameof(OutputAssembly)];
         }
 
         public string Platform
         {
-            set { Bag["Platform"] = value; }
-            get { return (string)Bag["Platform"]; }
+            set => Bag[nameof(Platform)] = value;
+            get => (string)Bag[nameof(Platform)];
         }
 
         // Map explicit platform of "AnyCPU" or the default platform (null or ""), since it is commonly understood in the 
@@ -178,8 +177,8 @@ internal string PlatformWith32BitPreference
         {
             get
             {
-                string platform = this.Platform;
-                if ((String.IsNullOrEmpty(platform) || platform.Equals("anycpu", StringComparison.OrdinalIgnoreCase)) && this.Prefer32Bit)
+                string platform = Platform;
+                if ((String.IsNullOrEmpty(platform) || platform.Equals("anycpu", StringComparison.OrdinalIgnoreCase)) && Prefer32Bit)
                 {
                     platform = "anycpu32bitpreferred";
                 }
@@ -189,68 +188,68 @@ internal string PlatformWith32BitPreference
 
         public bool Prefer32Bit
         {
-            set { Bag["Prefer32Bit"] = value; }
-            get { return GetBoolParameterWithDefault("Prefer32Bit", false); }
+            set => Bag[nameof(Prefer32Bit)] = value;
+            get => GetBoolParameterWithDefault(nameof(Prefer32Bit), false);
         }
 
         public string ProductName
         {
-            set { Bag["ProductName"] = value; }
-            get { return (string)Bag["ProductName"]; }
+            set => Bag[nameof(ProductName)] = value;
+            get => (string)Bag[nameof(ProductName)];
         }
 
         public string ProductVersion
         {
-            set { Bag["ProductVersion"] = value; }
-            get { return (string)Bag["ProductVersion"]; }
+            set => Bag[nameof(ProductVersion)] = value;
+            get => (string)Bag[nameof(ProductVersion)];
         }
 
         public string[] ResponseFiles
         {
-            set { Bag["ResponseFiles"] = value; }
-            get { return (string[])Bag["ResponseFiles"]; }
+            set => Bag[nameof(ResponseFiles)] = value;
+            get => (string[])Bag[nameof(ResponseFiles)];
         }
 
         public string TargetType
         {
-            set { Bag["TargetType"] = value; }
-            get { return (string)Bag["TargetType"]; }
+            set => Bag[nameof(TargetType)] = value;
+            get => (string)Bag[nameof(TargetType)];
         }
 
         public string TemplateFile
         {
-            set { Bag["TemplateFile"] = value; }
-            get { return (string)Bag["TemplateFile"]; }
+            set => Bag[nameof(TemplateFile)] = value;
+            get => (string)Bag[nameof(TemplateFile)];
         }
 
         public string Title
         {
-            set { Bag["Title"] = value; }
-            get { return (string)Bag["Title"]; }
+            set => Bag[nameof(Title)] = value;
+            get => (string)Bag[nameof(Title)];
         }
 
         public string Trademark
         {
-            set { Bag["Trademark"] = value; }
-            get { return (string)Bag["Trademark"]; }
+            set => Bag[nameof(Trademark)] = value;
+            get => (string)Bag[nameof(Trademark)];
         }
 
         public string Version
         {
-            set { Bag["Version"] = value; }
-            get { return (string)Bag["Version"]; }
+            set => Bag[nameof(Version)] = value;
+            get => (string)Bag[nameof(Version)];
         }
 
         public string Win32Icon
         {
-            set { Bag["Win32Icon"] = value; }
-            get { return (string)Bag["Win32Icon"]; }
+            set => Bag[nameof(Win32Icon)] = value;
+            get => (string)Bag[nameof(Win32Icon)];
         }
 
         public string Win32Resource
         {
-            set { Bag["Win32Resource"] = value; }
-            get { return (string)Bag["Win32Resource"]; }
+            set => Bag[nameof(Win32Resource)] = value;
+            get => (string)Bag[nameof(Win32Resource)];
         }
 
 
@@ -258,28 +257,28 @@ public string Win32Resource
         // This is not required.
         public ITaskItem[] SourceModules
         {
-            set { Bag["SourceModules"] = value; }
-            get { return (ITaskItem[])Bag["SourceModules"]; }
+            set => Bag[nameof(SourceModules)] = value;
+            get => (ITaskItem[])Bag[nameof(SourceModules)];
         }
 
         // Embedded resource files: file[,name[,private]]
         public ITaskItem[] EmbedResources
         {
-            set { Bag["EmbedResources"] = value; }
-            get { return (ITaskItem[])Bag["EmbedResources"]; }
+            set => Bag[nameof(EmbedResources)] = value;
+            get => (ITaskItem[])Bag[nameof(EmbedResources)];
         }
 
         // Linked resource files: file[,name[,target][,private]]]
         public ITaskItem[] LinkResources
         {
-            set { Bag["LinkResources"] = value; }
-            get { return (ITaskItem[])Bag["LinkResources"]; }
+            set => Bag[nameof(LinkResources)] = value;
+            get => (ITaskItem[])Bag[nameof(LinkResources)];
         }
 
         public string SdkToolsPath
         {
-            set { Bag["SdkToolsPath"] = value; }
-            get { return (string)Bag["SdkToolsPath"]; }
+            set => Bag[nameof(SdkToolsPath)] = value;
+            get => (string)Bag[nameof(SdkToolsPath)];
         }
 
         #endregion
@@ -288,18 +287,12 @@ public string SdkToolsPath
         /// <summary>
         /// Return the name of the tool to execute.
         /// </summary>
-        override protected string ToolName
-        {
-            get
-            {
-                return "al.exe";
-            }
-        }
+        protected override string ToolName => "al.exe";
 
         /// <summary>
         /// Return the path of the tool to execute
         /// </summary>
-        override protected string GenerateFullPathToTool()
+        protected override string GenerateFullPathToTool()
         {
             string pathToTool = null;
 
@@ -312,7 +305,7 @@ override protected string GenerateFullPathToTool()
 
             if (String.IsNullOrEmpty(pathToTool) || !File.Exists(pathToTool))
             {
-                pathToTool = SdkToolsPathUtility.GeneratePathToTool(SdkToolsPathUtility.FileInfoExists, Microsoft.Build.Utilities.ProcessorArchitecture.CurrentProcessArchitecture, SdkToolsPath, ToolExe, Log, true);
+                pathToTool = SdkToolsPathUtility.GeneratePathToTool(SdkToolsPathUtility.FileInfoExists, ProcessorArchitecture.CurrentProcessArchitecture, SdkToolsPath, ToolExe, Log, true);
             }
 
             return pathToTool;
@@ -321,57 +314,57 @@ override protected string GenerateFullPathToTool()
         /// <summary>
         /// Fills the provided CommandLineBuilderExtension with those switches and other information that can go into a response file.
         /// </summary>
-        override protected internal void AddResponseFileCommands(CommandLineBuilderExtension commandLine)
-        {
-            commandLine.AppendSwitchIfNotNull("/algid:", this.AlgorithmId);
-            commandLine.AppendSwitchIfNotNull("/baseaddress:", this.BaseAddress);
-            commandLine.AppendSwitchIfNotNull("/company:", this.CompanyName);
-            commandLine.AppendSwitchIfNotNull("/configuration:", this.Configuration);
-            commandLine.AppendSwitchIfNotNull("/copyright:", this.Copyright);
-            commandLine.AppendSwitchIfNotNull("/culture:", this.Culture);
-            commandLine.AppendPlusOrMinusSwitch("/delaysign", this.Bag, "DelaySign");
-            commandLine.AppendSwitchIfNotNull("/description:", this.Description);
-            commandLine.AppendSwitchIfNotNull("/evidence:", this.EvidenceFile);
-            commandLine.AppendSwitchIfNotNull("/fileversion:", this.FileVersion);
-            commandLine.AppendSwitchIfNotNull("/flags:", this.Flags);
-            commandLine.AppendWhenTrue("/fullpaths", this.Bag, "GenerateFullPaths");
-            commandLine.AppendSwitchIfNotNull("/keyfile:", this.KeyFile);
-            commandLine.AppendSwitchIfNotNull("/keyname:", this.KeyContainer);
-            commandLine.AppendSwitchIfNotNull("/main:", this.MainEntryPoint);
-            commandLine.AppendSwitchIfNotNull("/out:", (this.OutputAssembly == null) ? null : this.OutputAssembly.ItemSpec);
-            commandLine.AppendSwitchIfNotNull("/platform:", this.PlatformWith32BitPreference);
-            commandLine.AppendSwitchIfNotNull("/product:", this.ProductName);
-            commandLine.AppendSwitchIfNotNull("/productversion:", this.ProductVersion);
-            commandLine.AppendSwitchIfNotNull("/target:", this.TargetType);
-            commandLine.AppendSwitchIfNotNull("/template:", this.TemplateFile);
-            commandLine.AppendSwitchIfNotNull("/title:", this.Title);
-            commandLine.AppendSwitchIfNotNull("/trademark:", this.Trademark);
-            commandLine.AppendSwitchIfNotNull("/version:", this.Version);
-            commandLine.AppendSwitchIfNotNull("/win32icon:", this.Win32Icon);
-            commandLine.AppendSwitchIfNotNull("/win32res:", this.Win32Resource);
-
-            commandLine.AppendSwitchIfNotNull("", this.SourceModules, new string[] { "TargetFile" });
+        protected internal override void AddResponseFileCommands(CommandLineBuilderExtension commandLine)
+        {
+            commandLine.AppendSwitchIfNotNull("/algid:", AlgorithmId);
+            commandLine.AppendSwitchIfNotNull("/baseaddress:", BaseAddress);
+            commandLine.AppendSwitchIfNotNull("/company:", CompanyName);
+            commandLine.AppendSwitchIfNotNull("/configuration:", Configuration);
+            commandLine.AppendSwitchIfNotNull("/copyright:", Copyright);
+            commandLine.AppendSwitchIfNotNull("/culture:", Culture);
+            commandLine.AppendPlusOrMinusSwitch("/delaysign", Bag, "DelaySign");
+            commandLine.AppendSwitchIfNotNull("/description:", Description);
+            commandLine.AppendSwitchIfNotNull("/evidence:", EvidenceFile);
+            commandLine.AppendSwitchIfNotNull("/fileversion:", FileVersion);
+            commandLine.AppendSwitchIfNotNull("/flags:", Flags);
+            commandLine.AppendWhenTrue("/fullpaths", Bag, "GenerateFullPaths");
+            commandLine.AppendSwitchIfNotNull("/keyfile:", KeyFile);
+            commandLine.AppendSwitchIfNotNull("/keyname:", KeyContainer);
+            commandLine.AppendSwitchIfNotNull("/main:", MainEntryPoint);
+            commandLine.AppendSwitchIfNotNull("/out:", OutputAssembly?.ItemSpec);
+            commandLine.AppendSwitchIfNotNull("/platform:", PlatformWith32BitPreference);
+            commandLine.AppendSwitchIfNotNull("/product:", ProductName);
+            commandLine.AppendSwitchIfNotNull("/productversion:", ProductVersion);
+            commandLine.AppendSwitchIfNotNull("/target:", TargetType);
+            commandLine.AppendSwitchIfNotNull("/template:", TemplateFile);
+            commandLine.AppendSwitchIfNotNull("/title:", Title);
+            commandLine.AppendSwitchIfNotNull("/trademark:", Trademark);
+            commandLine.AppendSwitchIfNotNull("/version:", Version);
+            commandLine.AppendSwitchIfNotNull("/win32icon:", Win32Icon);
+            commandLine.AppendSwitchIfNotNull("/win32res:", Win32Resource);
+
+            commandLine.AppendSwitchIfNotNull("", SourceModules, new[] { "TargetFile" });
 
             commandLine.AppendSwitchIfNotNull
             (
                 "/embed:",
-                this.EmbedResources,
-                new string[] { "LogicalName", "Access" }
+                EmbedResources,
+                new[] { "LogicalName", "Access" }
             );
 
             commandLine.AppendSwitchIfNotNull
             (
                 "/link:",
-                this.LinkResources,
-                new string[] { "LogicalName", "TargetFile", "Access" }
+                LinkResources,
+                new[] { "LogicalName", "TargetFile", "Access" }
             );
 
             // It's a good idea for the response file to be the very last switch passed, just 
             // from a predictability perspective.  This is also consistent with the compiler
             // tasks (Csc, etc.)
-            if (this.ResponseFiles != null)
+            if (ResponseFiles != null)
             {
-                foreach (string responseFile in this.ResponseFiles)
+                foreach (string responseFile in ResponseFiles)
                 {
                     commandLine.AppendSwitchIfNotNull("@", responseFile);
                 }
@@ -380,11 +373,11 @@ override protected internal void AddResponseFileCommands(CommandLineBuilderExten
 
         public override bool Execute()
         {
-            if (this.Culture != null && this.OutputAssembly != null)
+            if (Culture != null)
             {
                 // This allows subsequent tasks in the build process to know what culture each satellite 
                 // assembly is associated with.
-                this.OutputAssembly.SetMetadata("Culture", this.Culture);
+                OutputAssembly?.SetMetadata("Culture", Culture);
             }
 
             return base.Execute();
diff --git a/src/Tasks/AppConfig/AppConfig.cs b/src/Tasks/AppConfig/AppConfig.cs
index 410895fdb22..1dafb54ad60 100644
--- a/src/Tasks/AppConfig/AppConfig.cs
+++ b/src/Tasks/AppConfig/AppConfig.cs
@@ -13,11 +13,6 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     internal sealed class AppConfig
     {
-        /// <summary>
-        /// Corresponds to the contents of the &lt;runtime&gt; element.
-        /// </summary>
-        private RuntimeSection _runtime = new RuntimeSection();
-
         /// <summary>
         /// Read the .config from a file.
         /// </summary>
@@ -27,8 +22,7 @@ internal void Load(string appConfigFile)
             XmlReader reader = null;
             try
             {
-                var readerSettings = new XmlReaderSettings();
-                readerSettings.DtdProcessing = DtdProcessing.Ignore;
+                var readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
                 reader = XmlReader.Create(appConfigFile, readerSettings);
                 Read(reader);
             }
@@ -37,10 +31,10 @@ internal void Load(string appConfigFile)
                 int lineNumber = 0;
                 int linePosition = 0;
 
-                if (reader != null && reader is IXmlLineInfo)
+                if (reader is IXmlLineInfo info)
                 {
-                    lineNumber = ((IXmlLineInfo)reader).LineNumber;
-                    linePosition = ((IXmlLineInfo)reader).LinePosition;
+                    lineNumber = info.LineNumber;
+                    linePosition = info.LinePosition;
                 }
 
                 throw new AppConfigException(e.Message, appConfigFile, lineNumber, linePosition, e);
@@ -50,10 +44,10 @@ internal void Load(string appConfigFile)
                 int lineNumber = 0;
                 int linePosition = 0;
 
-                if (reader != null && reader is IXmlLineInfo)
+                if (reader is IXmlLineInfo info)
                 {
-                    lineNumber = ((IXmlLineInfo)reader).LineNumber;
-                    linePosition = ((IXmlLineInfo)reader).LinePosition;
+                    lineNumber = info.LineNumber;
+                    linePosition = info.LinePosition;
                 }
 
                 throw new AppConfigException(e.Message, appConfigFile, lineNumber, linePosition, e);
@@ -76,7 +70,7 @@ internal void Read(XmlReader reader)
                 // Look for the <runtime> section
                 if (reader.NodeType == XmlNodeType.Element && StringEquals(reader.Name, "runtime"))
                 {
-                    _runtime.Read(reader);
+                    Runtime.Read(reader);
                 }
             }
         }
@@ -84,11 +78,7 @@ internal void Read(XmlReader reader)
         /// <summary>
         /// Access the Runtime section of the application .config file.
         /// </summary>
-        /// <value></value>
-        internal RuntimeSection Runtime
-        {
-            get { return _runtime; }
-        }
+        internal RuntimeSection Runtime { get; } = new RuntimeSection();
 
         /// <summary>
         /// App.config files seem to come with mixed casing for element and attribute names.
@@ -97,7 +87,7 @@ internal RuntimeSection Runtime
         /// <param name="a"></param>
         /// <param name="b"></param>
         /// <returns></returns>
-        static internal bool StringEquals(string a, string b)
+        internal static bool StringEquals(string a, string b)
         {
             return String.Compare(a, b, StringComparison.OrdinalIgnoreCase) == 0;
         }
diff --git a/src/Tasks/AppConfig/AppConfigException.cs b/src/Tasks/AppConfig/AppConfigException.cs
index 52e1a961343..6d69ff98c6c 100644
--- a/src/Tasks/AppConfig/AppConfigException.cs
+++ b/src/Tasks/AppConfig/AppConfigException.cs
@@ -58,11 +58,6 @@ internal int Column
         /// <summary>
         /// Construct the exception.
         /// </summary>
-        /// <param name="message"></param>
-        /// <param name="fileName"></param>
-        /// <param name="line"></param>
-        /// <param name="column"></param>
-        /// <param name="inner"></param>
         public AppConfigException(string message, string fileName, int line, int column, System.Exception inner) : base(message, inner)
         {
             this.fileName = fileName;
diff --git a/src/Tasks/AppConfig/BindingRedirect.cs b/src/Tasks/AppConfig/BindingRedirect.cs
index 08082e8f16a..5e5404af394 100644
--- a/src/Tasks/AppConfig/BindingRedirect.cs
+++ b/src/Tasks/AppConfig/BindingRedirect.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Xml;
-using System.Collections;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -16,49 +15,21 @@ internal sealed class BindingRedirect
         /// <summary>
         /// The low end of the old version range.
         /// </summary>
-        private Version _oldVersionLow = null;
+        internal Version OldVersionLow { set; get; }
 
         /// <summary>
         /// The high end of the old version range.
         /// </summary>
-        private Version _oldVersionHigh = null;
+        internal Version OldVersionHigh { set; get; }
 
         /// <summary>
         /// The new version number.
         /// </summary>
-        private Version _newVersion = null;
-
-        /// <summary>
-        /// The low end of the old version range.
-        /// </summary>
-        internal Version OldVersionLow
-        {
-            set { _oldVersionLow = value; }
-            get { return _oldVersionLow; }
-        }
-
-        /// <summary>
-        /// The high end of the old version range.
-        /// </summary>
-        internal Version OldVersionHigh
-        {
-            set { _oldVersionHigh = value; }
-            get { return _oldVersionHigh; }
-        }
-
-        /// <summary>
-        /// The new version number.
-        /// </summary>
-        internal Version NewVersion
-        {
-            set { _newVersion = value; }
-            get { return _newVersion; }
-        }
+        internal Version NewVersion { set; get; }
 
         /// <summary>
         /// The reader is positioned on a &lt;bindingRedirect&gt; element--read it.
         /// </summary>
-        /// <param name="reader"></param>
         internal void Read(XmlReader reader)
         {
             string oldVersion = reader.GetAttribute("oldVersion");
@@ -73,14 +44,14 @@ internal void Read(XmlReader reader)
                 if (dashPosition != -1)
                 {
                     // This is a version range.
-                    _oldVersionLow = new Version(oldVersion.Substring(0, dashPosition));
-                    _oldVersionHigh = new Version(oldVersion.Substring(dashPosition + 1));
+                    OldVersionLow = new Version(oldVersion.Substring(0, dashPosition));
+                    OldVersionHigh = new Version(oldVersion.Substring(dashPosition + 1));
                 }
                 else
                 {
                     // This is a single version.
-                    _oldVersionLow = new Version(oldVersion);
-                    _oldVersionHigh = new Version(oldVersion);
+                    OldVersionLow = new Version(oldVersion);
+                    OldVersionHigh = new Version(oldVersion);
                 }
             }
             catch (Exception e)
@@ -100,7 +71,7 @@ internal void Read(XmlReader reader)
 
             try
             {
-                _newVersion = new Version(newVersionAttribute);
+                NewVersion = new Version(newVersionAttribute);
             }
             catch (Exception e)
             {
diff --git a/src/Tasks/AppConfig/DependentAssembly.cs b/src/Tasks/AppConfig/DependentAssembly.cs
index 740977c6cdc..261d832cd33 100644
--- a/src/Tasks/AppConfig/DependentAssembly.cs
+++ b/src/Tasks/AppConfig/DependentAssembly.cs
@@ -4,9 +4,8 @@
 using System;
 using System.Xml;
 using System.Reflection;
-using System.Collections;
+using System.Collections.Generic;
 using System.Globalization;
-
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -16,16 +15,6 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     internal sealed class DependentAssembly
     {
-        /// <summary>
-        /// List of binding redirects. Type is BindingRedirect.
-        /// </summary>
-        private BindingRedirect[] _bindingRedirects = null;
-
-        /// <summary>
-        /// The partial <see cref="AssemblyName"/>, there should be no version.
-        /// </summary>
-        private AssemblyName _partialAssemblyName;
-
         /// <summary>
         /// The partial <see cref="AssemblyName"/>, there should be no version.
         /// Setter and Getter clone the incoming / outgoing assembly
@@ -34,37 +23,27 @@ internal AssemblyName PartialAssemblyName
         {
             set
             {
-                _partialAssemblyName = value.CloneIfPossible();
-                _partialAssemblyName.Version = null;
-            }
-            get
-            {
-                return _partialAssemblyName?.CloneIfPossible();
+                AssemblyNameReadOnly = value.CloneIfPossible();
+                AssemblyNameReadOnly.Version = null;
             }
+            get => AssemblyNameReadOnly?.CloneIfPossible();
         }
 
         /// <summary>
         /// The full <see cref="AssemblyName"/>. It is not cloned. Callers should not mutate this object.
         /// </summary>
-        internal AssemblyName AssemblyNameReadOnly
-        {
-            get
-            {
-                return _partialAssemblyName;
-            }
-        }
+        internal AssemblyName AssemblyNameReadOnly { get; private set; }
 
         /// <summary>
         /// The reader is positioned on a &lt;dependentassembly&gt; element--read it.
         /// </summary>
-        /// <param name="reader"></param>
         internal void Read(XmlReader reader)
         {
-            ArrayList redirects = new ArrayList();
+            var redirects = new List<BindingRedirect>();
 
-            if (_bindingRedirects != null)
+            if (BindingRedirects != null)
             {
-                redirects.AddRange(_bindingRedirects);
+                redirects.AddRange(BindingRedirects);
             }
 
             while (reader.Read())
@@ -112,7 +91,7 @@ internal void Read(XmlReader reader)
 
                     try
                     {
-                        _partialAssemblyName = new AssemblyNameExtension(assemblyName).AssemblyName;
+                        AssemblyNameReadOnly = new AssemblyNameExtension(assemblyName).AssemblyName;
                     }
                     catch (System.IO.FileLoadException e)
                     {
@@ -124,22 +103,17 @@ internal void Read(XmlReader reader)
                 // Look for a <bindingRedirect> element.
                 if (reader.NodeType == XmlNodeType.Element && AppConfig.StringEquals(reader.Name, "bindingRedirect"))
                 {
-                    BindingRedirect bindingRedirect = new BindingRedirect();
+                    var bindingRedirect = new BindingRedirect();
                     bindingRedirect.Read(reader);
                     redirects.Add(bindingRedirect);
                 }
             }
-            _bindingRedirects = (BindingRedirect[])redirects.ToArray(typeof(BindingRedirect));
+            BindingRedirects = redirects.ToArray();
         }
 
         /// <summary>
         /// The binding redirects.
         /// </summary>
-        /// <value></value>
-        internal BindingRedirect[] BindingRedirects
-        {
-            set { _bindingRedirects = value; }
-            get { return _bindingRedirects; }
-        }
+        internal BindingRedirect[] BindingRedirects { set; get; }
     }
 }
diff --git a/src/Tasks/AppConfig/RuntimeSection.cs b/src/Tasks/AppConfig/RuntimeSection.cs
index ab94d0f81d5..cc19f814167 100644
--- a/src/Tasks/AppConfig/RuntimeSection.cs
+++ b/src/Tasks/AppConfig/RuntimeSection.cs
@@ -1,9 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Xml;
-using System.Collections;
+using System.Collections.Generic;
 
 namespace Microsoft.Build.Tasks
 {
@@ -15,12 +14,11 @@ internal sealed class RuntimeSection
         /// <summary>
         /// List of dependent assemblies. Type is DependentAssembly.
         /// </summary>
-        private ArrayList _dependentAssemblies = new ArrayList();
+        private readonly List<DependentAssembly> _dependentAssemblies = new List<DependentAssembly>();
 
         /// <summary>
         /// The reader is positioned on a &lt;runtime&gt; element--read it.
         /// </summary>
-        /// <param name="reader"></param>
         internal void Read(XmlReader reader)
         {
             while (reader.Read())
@@ -34,7 +32,7 @@ internal void Read(XmlReader reader)
                 // Look for a <dependentAssembly> element
                 if (reader.NodeType == XmlNodeType.Element && AppConfig.StringEquals(reader.Name, "dependentAssembly"))
                 {
-                    DependentAssembly dependentAssembly = new DependentAssembly();
+                    var dependentAssembly = new DependentAssembly();
                     dependentAssembly.Read(reader);
 
                     // Only add if there was an <assemblyIdentity> tag.
@@ -50,10 +48,6 @@ internal void Read(XmlReader reader)
         /// <summary>
         /// Return the collection of dependent assemblies for this runtime element.
         /// </summary>
-        /// <value></value>
-        internal DependentAssembly[] DependentAssemblies
-        {
-            get { return (DependentAssembly[])_dependentAssemblies.ToArray(typeof(DependentAssembly)); }
-        }
+        internal DependentAssembly[] DependentAssemblies => _dependentAssemblies.ToArray();
     }
 }
diff --git a/src/Tasks/AppDomainIsolatedTaskExtension.cs b/src/Tasks/AppDomainIsolatedTaskExtension.cs
index 16fa3578366..e3ec313363e 100644
--- a/src/Tasks/AppDomainIsolatedTaskExtension.cs
+++ b/src/Tasks/AppDomainIsolatedTaskExtension.cs
@@ -3,11 +3,6 @@
 
 #if FEATURE_APPDOMAIN
 
-using System;
-using System.IO;
-using System.Resources;
-using System.Security.Permissions;
-
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
@@ -41,18 +36,12 @@ internal AppDomainIsolatedTaskExtension() :
         /// Gets an instance of a TaskLoggingHelperExtension class containing task logging methods.
         /// </summary>
         /// <value>The logging helper object.</value>
-        new public TaskLoggingHelper Log
-        {
-            get
-            {
-                return _logExtension;
-            }
-        }
+        public new TaskLoggingHelper Log => _logExtension;
 
         // the logging helper
-        private TaskLoggingHelperExtension _logExtension;
+        private readonly TaskLoggingHelperExtension _logExtension;
 
         #endregion
     }
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/src/Tasks/AspNetCompiler.cs b/src/Tasks/AspNetCompiler.cs
index 439180aaf01..b054a5e7db6 100644
--- a/src/Tasks/AspNetCompiler.cs
+++ b/src/Tasks/AspNetCompiler.cs
@@ -1,10 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.IO;
-using System.Text;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
@@ -70,49 +66,29 @@ The following command compiles the application /MyApp in-place. The effect is
                 aspnet_compiler -v /MyApp -p c:\myapp c:\MyTarget
         */
 
-        private bool _updateable;
-        private bool _force;
-        private bool _debug;
-        private bool _clean;
-        private bool _aptca;
-        private bool _delaySign;
-        private bool _fixedNames;
-
         /// <summary>
         /// If specified, the strong-name assembly will allow partially
         /// trusted callers.
         /// </summary>
-        public bool AllowPartiallyTrustedCallers
-        {
-            get { return _aptca; }
-            set { _aptca = value; }
-        }
+        public bool AllowPartiallyTrustedCallers { get; set; }
 
         /// <summary>
         /// If specified, the assemblly is not fully signed when created. 
         /// </summary>
-        public bool DelaySign
-        {
-            get { return _delaySign; }
-            set { _delaySign = value; }
-        }
+        public bool DelaySign { get; set; }
 
         /// <summary>
         /// If specified, the compiled assemblies will be given fixed names.
         /// </summary>
-        public bool FixedNames
-        {
-            get { return _fixedNames; }
-            set { _fixedNames = value; }
-        }
+        public bool FixedNames { get; set; }
 
         /// <summary>
         /// Specifies a strong name key container.
         /// </summary>
         public string KeyContainer
         {
-            get { return (string)Bag["KeyContainer"]; }
-            set { Bag["KeyContainer"] = value; }
+            get => (string)Bag[nameof(KeyContainer)];
+            set => Bag[nameof(KeyContainer)] = value;
         }
 
         /// <summary>
@@ -120,8 +96,8 @@ public string KeyContainer
         /// </summary>
         public string KeyFile
         {
-            get { return (string)Bag["KeyFile"]; }
-            set { Bag["KeyFile"] = value; }
+            get => (string)Bag[nameof(KeyFile)];
+            set => Bag[nameof(KeyFile)] = value;
         }
 
         /// <summary>
@@ -130,8 +106,8 @@ public string KeyFile
         /// </summary>
         public string MetabasePath
         {
-            get { return (string)Bag["MetabasePath"]; }
-            set { Bag["MetabasePath"] = value; }
+            get => (string)Bag[nameof(MetabasePath)];
+            set => Bag[nameof(MetabasePath)] = value;
         }
 
         /// <summary>
@@ -140,8 +116,8 @@ public string MetabasePath
         /// </summary>
         public string PhysicalPath
         {
-            get { return (string)Bag["PhysicalPath"]; }
-            set { Bag["PhysicalPath"] = value; }
+            get => (string)Bag[nameof(PhysicalPath)];
+            set => Bag[nameof(PhysicalPath)] = value;
         }
 
         /// <summary>
@@ -150,8 +126,8 @@ public string PhysicalPath
         /// </summary>
         public string TargetPath
         {
-            get { return (string)Bag["TargetPath"]; }
-            set { Bag["TargetPath"] = value; }
+            get => (string)Bag[nameof(TargetPath)];
+            set => Bag[nameof(TargetPath)] = value;
         }
 
         /// <summary>
@@ -162,49 +138,33 @@ public string TargetPath
         /// </summary>
         public string VirtualPath
         {
-            get { return (string)Bag["VirtualPath"]; }
-            set { Bag["VirtualPath"] = value; }
+            get => (string)Bag[nameof(VirtualPath)];
+            set => Bag[nameof(VirtualPath)] = value;
         }
 
         /// <summary>
         /// If Updateable is true, then the web is compile with -u flag so that it
         /// can be updated after compilation
         /// </summary>
-        public bool Updateable
-        {
-            get { return _updateable; }
-            set { _updateable = value; }
-        }
+        public bool Updateable { get; set; }
 
         /// <summary>
         /// If Force is true, then the web is compile with -f flag overwriting
         /// files in the target location
         /// </summary>
-        public bool Force
-        {
-            get { return _force; }
-            set { _force = value; }
-        }
+        public bool Force { get; set; }
 
         /// <summary>
         /// If Debug is true, then the debug information will be emitted during
         /// compilation.
         /// </summary>
-        public bool Debug
-        {
-            get { return _debug; }
-            set { _debug = value; }
-        }
+        public bool Debug { get; set; }
 
         /// <summary>
         /// If Clean is true, then the application will be built clean. Previously
         /// compiled components will be re-compiled.
         /// </summary>
-        public bool Clean
-        {
-            get { return _clean; }
-            set { _clean = value; }
-        }
+        public bool Clean { get; set; }
 
         /// <summary>
         /// The TargetFrameworkMoniker indicating which .NET Framework version of 
@@ -212,17 +172,14 @@ public bool Clean
         /// </summary>
         public string TargetFrameworkMoniker
         {
-            get { return (string)Bag["TargetFrameworkMoniker"]; }
-            set { Bag["TargetFrameworkMoniker"] = value; }
+            get => (string)Bag[nameof(TargetFrameworkMoniker)];
+            set => Bag[nameof(TargetFrameworkMoniker)] = value;
         }
 
         /// <summary>
         /// The name of the tool to execute
         /// </summary>
-        protected override string ToolName
-        {
-            get { return "aspnet_compiler.exe"; }
-        }
+        protected override string ToolName => "aspnet_compiler.exe";
 
         /// <summary>
         /// Small helper property to get the "project name"
@@ -231,16 +188,11 @@ private string ProjectName
         {
             get
             {
-                if (this.PhysicalPath != null)
+                if (PhysicalPath != null)
                 {
-                    return this.PhysicalPath;
+                    return PhysicalPath;
                 }
-                else if (this.VirtualPath != null)
-                {
-                    return this.VirtualPath;
-                }
-
-                return this.MetabasePath;
+                return VirtualPath ?? MetabasePath;
             }
         }
 
@@ -251,7 +203,7 @@ private string TargetName
         {
             get
             {
-                if (this.Clean)
+                if (Clean)
                 {
                     return "Clean";
                 }
@@ -293,27 +245,41 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens
             commandLine.AppendSwitchIfNotNull("-p ", PhysicalPath);
 
             if (Updateable)
+            {
                 commandLine.AppendSwitch("-u");
+            }
 
             if (Force)
+            {
                 commandLine.AppendSwitch("-f");
+            }
 
             if (Clean)
+            {
                 commandLine.AppendSwitch("-c");
+            }
 
             if (Debug)
+            {
                 commandLine.AppendSwitch("-d");
+            }
 
             if (FixedNames)
+            {
                 commandLine.AppendSwitch("-fixednames");
+            }
 
             commandLine.AppendSwitchIfNotNull("", TargetPath);
 
             if (AllowPartiallyTrustedCallers)
+            {
                 commandLine.AppendSwitch("-aptca");
+            }
 
             if (DelaySign)
+            {
                 commandLine.AppendSwitch("-delaysign");
+            }
 
             commandLine.AppendSwitchIfNotNull("-keyfile ", KeyFile);
             commandLine.AppendSwitchIfNotNull("-keycontainer ", KeyContainer);
@@ -325,10 +291,8 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens
         /// <returns>path to aspnet_compiler.exe, null if not found</returns>
         protected override string GenerateFullPathToTool()
         {
-            string pathToTool = null;
-
             // If ToolPath wasn't passed in, we want to default to the latest
-            pathToTool = ToolLocationHelper.GetPathToDotNetFrameworkFile(ToolExe, TargetDotNetFrameworkVersion.Latest);
+            string pathToTool = ToolLocationHelper.GetPathToDotNetFrameworkFile(ToolExe, TargetDotNetFrameworkVersion.Latest);
 
             if (pathToTool == null)
             {
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
index 315c7d801a3..cd8a2c7dc5c 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
@@ -6,14 +6,12 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
-using System.Reflection;
 using System.Text.RegularExpressions;
 using System.Threading.Tasks;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
-using Microsoft.Build.Framework;
 using ProcessorArchitecture = System.Reflection.ProcessorArchitecture;
-using System.Diagnostics;
 
 namespace Microsoft.Build.Tasks
 {
@@ -37,17 +35,17 @@ internal class AssemblyFoldersExResolver : Resolver
         /// <summary>
         /// Delegate.
         /// </summary>
-        private GetRegistrySubKeyNames _getRegistrySubKeyNames;
+        private readonly GetRegistrySubKeyNames _getRegistrySubKeyNames;
 
         /// <summary>
         /// Delegate
         /// </summary>
-        private GetRegistrySubKeyDefaultValue _getRegistrySubKeyDefaultValue;
+        private readonly GetRegistrySubKeyDefaultValue _getRegistrySubKeyDefaultValue;
 
         /// <summary>
         /// Open the base registry key given a hive and a view
         /// </summary>
-        private OpenBaseKey _openBaseKey;
+        private readonly OpenBaseKey _openBaseKey;
 
         /// <summary>
         /// Whether or not the search path could be cracked.
@@ -92,23 +90,12 @@ internal class AssemblyFoldersExResolver : Resolver
         /// <summary>
         /// BuildEngine
         /// </summary>
-        private IBuildEngine4 _buildEngine;
+        private readonly IBuildEngine4 _buildEngine;
 
         /// <summary>
         /// If it is not initialized then just return the null object, that would mean the resolver was not called.
         /// </summary>
-        internal AssemblyFoldersEx AssemblyFoldersExLocations
-        {
-            get
-            {
-                if (_assemblyFoldersCache == null)
-                {
-                    return null;
-                }
-
-                return _assemblyFoldersCache.AssemblyFoldersEx;
-            }
-        }
+        internal AssemblyFoldersEx AssemblyFoldersExLocations => _assemblyFoldersCache?.AssemblyFoldersEx;
 
         /// <summary>
         /// Construct.
@@ -128,7 +115,9 @@ public AssemblyFoldersExResolver(string searchPathElement, GetAssemblyName getAs
         private void LazyInitialize()
         {
             if (_isInitialized)
+            {
                 return;
+            }
 
             _isInitialized = true;
 
@@ -154,7 +143,7 @@ private void LazyInitialize()
                         _targetRuntimeVersion = _targetRuntimeVersion.Insert(0, "v");
                     }
 
-                    if (conditions != null && conditions.Value != null && conditions.Length > 0 && conditions.Value.Length > 0)
+                    if (conditions?.Value != null && conditions.Length > 0 && conditions.Value.Length > 0)
                     {
                         string value = conditions.Value.Trim();
 
@@ -184,9 +173,9 @@ private void LazyInitialize()
                     {
                         AssemblyFoldersEx assemblyFolders = new AssemblyFoldersEx(_registryKeyRoot, _targetRuntimeVersion, _registryKeySuffix, _osVersion, _platform, _getRegistrySubKeyNames, _getRegistrySubKeyDefaultValue, this.targetProcessorArchitecture, _openBaseKey);
                         _assemblyFoldersCache = new AssemblyFoldersExCache(assemblyFolders, fileExists);
-                        if (useCache && _buildEngine != null)
+                        if (useCache)
                         {
-                            _buildEngine.RegisterTaskObject(key, _assemblyFoldersCache, RegisteredTaskObjectLifetime.Build, true /* dispose early ok*/);
+                            _buildEngine?.RegisterTaskObject(key, _assemblyFoldersCache, RegisteredTaskObjectLifetime.Build, true /* dispose early ok*/);
                         }
                     }
 
@@ -220,7 +209,6 @@ public override bool Resolve
             string hintPath,
             string assemblyFolderKey,
             ArrayList assembliesConsideredAndRejected,
-
             out string foundPath,
             out bool userRequestedSpecificFile
         )
@@ -280,7 +268,6 @@ out bool userRequestedSpecificFile
                 }
             }
 
-
             return false;
         }
     }
@@ -290,32 +277,27 @@ out bool userRequestedSpecificFile
     /// </summary>
     internal class AssemblyFoldersExCache
     {
-        /// <summary>
-        /// Directory list of folders under assemblyfoldersex
-        /// </summary>
-        private AssemblyFoldersEx _assemblyFoldersEx;
-
         /// <summary>
         /// Set of files in ALL assemblyfoldersEx directories
         /// </summary>
-        private HashSet<string> _filesInDirectories = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+        private readonly HashSet<string> _filesInDirectories = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// File exists delegate we are replacing
         /// </summary>
-        private FileExists _fileExists;
+        private readonly FileExists _fileExists;
 
         /// <summary>
         /// Should we use the original on or use our own
         /// </summary>
-        private bool _useOriginalFileExists = false;
+        private readonly bool _useOriginalFileExists;
 
         /// <summary>
         /// Constructor
         /// </summary>
         internal AssemblyFoldersExCache(AssemblyFoldersEx assemblyFoldersEx, FileExists fileExists)
         {
-            _assemblyFoldersEx = assemblyFoldersEx;
+            AssemblyFoldersEx = assemblyFoldersEx;
             _fileExists = fileExists;
 
             if (Environment.GetEnvironmentVariable("MSBUILDDISABLEASSEMBLYFOLDERSEXCACHE") != null)
@@ -324,9 +306,9 @@ internal AssemblyFoldersExCache(AssemblyFoldersEx assemblyFoldersEx, FileExists
             }
             else
             {
-                Object lockobject = new Object();
+                var lockobject = new Object();
 
-                Parallel.ForEach<AssemblyFoldersExInfo>(assemblyFoldersEx, assemblyFolder =>
+                Parallel.ForEach(assemblyFoldersEx, assemblyFolder =>
                 {
                     if (FileUtilities.DirectoryExistsNoThrow(assemblyFolder.DirectoryPath))
                     {
@@ -347,10 +329,7 @@ internal AssemblyFoldersExCache(AssemblyFoldersEx assemblyFoldersEx, FileExists
         /// <summary>
         /// AssemblyfoldersEx object which contains the set of directories in assmblyfoldersex
         /// </summary>
-        internal AssemblyFoldersEx AssemblyFoldersEx
-        {
-            get { return _assemblyFoldersEx; }
-        }
+        internal AssemblyFoldersEx AssemblyFoldersEx { get; }
 
         /// <summary>
         ///  Fast file exists for assemblyfoldersex.
@@ -364,11 +343,8 @@ internal bool FileExists(string path)
                 bool exists = _filesInDirectories.Contains(path);
                 return exists;
             }
-            else
-            {
-                return _fileExists(path);
-            }
+            return _fileExists(path);
         }
     }
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
index 36407c28f8a..5211aa85c03 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Reflection;
 using System.Collections;
+using System.Collections.Generic;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -61,18 +62,13 @@ out bool userRequestedSpecificFile
             if (assemblyName != null)
             {
                 // {AssemblyFolders} was passed in.
-                ICollection assemblyFolders = AssemblyFolder.GetAssemblyFolders(assemblyFolderKey);
-
-                if (assemblyFolders != null)
+                foreach (string assemblyFolder in AssemblyFolder.GetAssemblyFolders(assemblyFolderKey))
                 {
-                    foreach (string assemblyFolder in assemblyFolders)
+                    string resolvedPath = ResolveFromDirectory(assemblyName, isPrimaryProjectReference, wantSpecificVersion, executableExtensions, assemblyFolder, assembliesConsideredAndRejected);
+                    if (resolvedPath != null)
                     {
-                        string resolvedPath = ResolveFromDirectory(assemblyName, isPrimaryProjectReference, wantSpecificVersion, executableExtensions, assemblyFolder, assembliesConsideredAndRejected);
-                        if (resolvedPath != null)
-                        {
-                            foundPath = resolvedPath;
-                            return true;
-                        }
+                        foundPath = resolvedPath;
+                        return true;
                     }
                 }
             }
diff --git a/src/Tasks/AssemblyDependency/AssemblyInformation.cs b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
index b200ae84551..10f37ef326a 100644
--- a/src/Tasks/AssemblyDependency/AssemblyInformation.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
@@ -2,22 +2,21 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Concurrent;
+using System.Collections.Generic;
 using System.Globalization;
 using System.IO;
+using System.Linq;
 using System.Runtime.InteropServices;
+using System.Runtime.Versioning;
 using System.Reflection;
-using System.Linq;
+using System.Text;
 
 using Microsoft.Build.Shared;
-using System.Text;
-using System.Runtime.Versioning;
 #if !FEATURE_ASSEMBLY_LOADFROM || MONO
 using System.Reflection.PortableExecutable;
 using System.Reflection.Metadata;
 #endif
-using System.Collections.Generic;
 using Microsoft.Build.Tasks.AssemblyDependency;
 
 namespace Microsoft.Build.Tasks
@@ -28,15 +27,15 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     internal class AssemblyInformation : DisposableBase
     {
-        private AssemblyNameExtension[] _assemblyDependencies = null;
-        private string[] _assemblyFiles = null;
+        private AssemblyNameExtension[] _assemblyDependencies;
+        private string[] _assemblyFiles;
 #if FEATURE_ASSEMBLY_LOADFROM
-        private IMetaDataDispenser _metadataDispenser = null;
-        private IMetaDataAssemblyImport _assemblyImport = null;
+        private readonly IMetaDataDispenser _metadataDispenser;
+        private readonly IMetaDataAssemblyImport _assemblyImport;
         private static Guid s_importerGuid = new Guid(((GuidAttribute)Attribute.GetCustomAttribute(typeof(IMetaDataImport), typeof(GuidAttribute), false)).Value);
         private readonly Assembly _assembly;
 #endif
-        private string _sourceFile;
+        private readonly string _sourceFile;
         private FrameworkName _frameworkName;
 
 #if !FEATURE_ASSEMBLY_LOADFROM || MONO
@@ -65,7 +64,7 @@ static AssemblyInformation()
         internal AssemblyInformation(string sourceFile)
         {
             // Extra checks for PInvoke-destined data.
-            ErrorUtilities.VerifyThrowArgumentNull(sourceFile, "sourceFile");
+            ErrorUtilities.VerifyThrowArgumentNull(sourceFile, nameof(sourceFile));
             _sourceFile = sourceFile;
 
 #if FEATURE_ASSEMBLY_LOADFROM
@@ -147,7 +146,6 @@ public AssemblyNameExtension[] Dependencies
         /// <summary>
         /// Get the scatter files from the assembly metadata. 
         /// </summary>
-        /// <value></value>
         public string[] Files
         {
             get
@@ -221,7 +219,7 @@ out FrameworkName frameworkName
         /// </summary>
         internal static FrameworkName GetTargetFrameworkAttribute(string path)
         {
-            using (AssemblyInformation import = new AssemblyInformation(path))
+            using (var import = new AssemblyInformation(path))
             {
                 return import.FrameworkNameAttribute;
             }
@@ -291,7 +289,7 @@ private FrameworkName GetFrameworkName()
                 {
                     try
                     {
-                        if (a.AttributeType.Equals(typeof(TargetFrameworkAttribute)))
+                        if (a.AttributeType == typeof(TargetFrameworkAttribute))
                         {
                             attr = a;
                             break;
@@ -313,20 +311,16 @@ private FrameworkName GetFrameworkName()
             FrameworkName frameworkAttribute = null;
             try
             {
-                IMetaDataImport2 import2 = (IMetaDataImport2)_assemblyImport;
-                IntPtr data = IntPtr.Zero;
-                UInt32 valueLen = 0;
-                string frameworkNameAttribute = null;
-                UInt32 assemblyScope;
+                var import2 = (IMetaDataImport2)_assemblyImport;
 
-                _assemblyImport.GetAssemblyFromScope(out assemblyScope);
-                int hr = import2.GetCustomAttributeByName(assemblyScope, s_targetFrameworkAttribute, out data, out valueLen);
+                _assemblyImport.GetAssemblyFromScope(out uint assemblyScope);
+                int hr = import2.GetCustomAttributeByName(assemblyScope, s_targetFrameworkAttribute, out IntPtr data, out uint valueLen);
 
                 // get the AssemblyTitle
                 if (hr == NativeMethodsShared.S_OK)
                 {
                     // if an AssemblyTitle exists, parse the contents of the blob
-                    if (NativeMethods.TryReadMetadataString(_sourceFile, data, valueLen, out frameworkNameAttribute))
+                    if (NativeMethods.TryReadMetadataString(_sourceFile, data, valueLen, out string frameworkNameAttribute))
                     {
                         if (!String.IsNullOrEmpty(frameworkNameAttribute))
                         {
@@ -501,9 +495,14 @@ protected override void DisposeUnmanagedResources()
             if (NativeMethodsShared.IsWindows)
             {
                 if (_assemblyImport != null)
+                {
                     Marshal.ReleaseComObject(_assemblyImport);
+                }
+
                 if (_metadataDispenser != null)
+                {
                     Marshal.ReleaseComObject(_metadataDispenser);
+                }
             }
         }
 #endif
@@ -518,9 +517,8 @@ internal static string GetRuntimeVersion(string path)
 #if FEATURE_MSCOREE
             if (NativeMethodsShared.IsWindows)
             {
-                StringBuilder runtimeVersion = null;
-                uint hresult = 0;
-                uint actualBufferSize = 0;
+                StringBuilder runtimeVersion;
+                uint hresult;
 #if _DEBUG
                 // Just to make sure and exercise the code that doubles the size
                 // every time GetRequestedRuntimeInfo fails due to insufficient buffer size.
@@ -531,11 +529,11 @@ internal static string GetRuntimeVersion(string path)
                 do
                 {
                     runtimeVersion = new StringBuilder(bufferLength);
-                    hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out actualBufferSize);
+                    hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out _);
                     bufferLength = bufferLength * 2;
                 } while (hresult == NativeMethodsShared.ERROR_INSUFFICIENT_BUFFER);
 
-                if (hresult == NativeMethodsShared.S_OK && runtimeVersion != null)
+                if (hresult == NativeMethodsShared.S_OK)
                 {
                     return runtimeVersion.ToString();
                 }
@@ -561,7 +559,7 @@ internal static string GetRuntimeVersion(string path)
         private AssemblyNameExtension[] ImportAssemblyDependencies()
         {
 #if FEATURE_ASSEMBLY_LOADFROM
-            ArrayList asmRefs = new ArrayList();
+            var asmRefs = new List<AssemblyNameExtension>();
 
             if (!NativeMethodsShared.IsWindows)
             {
@@ -569,12 +567,12 @@ private AssemblyNameExtension[] ImportAssemblyDependencies()
             }
 
             IntPtr asmRefEnum = IntPtr.Zero;
-            UInt32[] asmRefTokens = new UInt32[GENMAN_ENUM_TOKEN_BUF_SIZE];
-            UInt32 fetched;
+            var asmRefTokens = new UInt32[GENMAN_ENUM_TOKEN_BUF_SIZE];
             // Ensure the enum handle is closed.
             try
             {
                 // Enum chunks of refs in 16-ref blocks until we run out.
+                UInt32 fetched;
                 do
                 {
                     _assemblyImport.EnumAssemblyRefs(
@@ -586,21 +584,19 @@ private AssemblyNameExtension[] ImportAssemblyDependencies()
                     for (uint i = 0; i < fetched; i++)
                     {
                         // Determine the length of the string to contain the name first.
-                        IntPtr hashDataPtr, pubKeyPtr;
-                        UInt32 hashDataLength, pubKeyBytes, asmNameLength, flags;
                         _assemblyImport.GetAssemblyRefProps(
                             asmRefTokens[i],
-                            out pubKeyPtr,
-                            out pubKeyBytes,
+                            out IntPtr pubKeyPtr,
+                            out uint pubKeyBytes,
                             null,
                             0,
-                            out asmNameLength,
+                            out uint asmNameLength,
                             IntPtr.Zero,
-                            out hashDataPtr,
-                            out hashDataLength,
-                            out flags);
+                            out _,
+                            out _,
+                            out uint flags);
                         // Allocate assembly name buffer.
-                        char[] asmNameBuf = new char[asmNameLength + 1];
+                        var asmNameBuf = new char[asmNameLength + 1];
                         IntPtr asmMetaPtr = IntPtr.Zero;
                         // Ensure metadata structure is freed.
                         try
@@ -616,8 +612,8 @@ private AssemblyNameExtension[] ImportAssemblyDependencies()
                                 (uint)asmNameBuf.Length,
                                 out asmNameLength,
                                 asmMetaPtr,
-                                out hashDataPtr,
-                                out hashDataLength,
+                                out _,
+                                out _,
                                 out flags);
                             // Construct the assembly name and free metadata structure.
                             AssemblyNameExtension asmName = ConstructAssemblyName(
@@ -640,10 +636,12 @@ private AssemblyNameExtension[] ImportAssemblyDependencies()
             finally
             {
                 if (asmRefEnum != IntPtr.Zero)
+                {
                     _assemblyImport.CloseEnum(asmRefEnum);
+                }
             }
 
-            return (AssemblyNameExtension[])asmRefs.ToArray(typeof(AssemblyNameExtension));
+            return asmRefs.ToArray();
 #else
             CorePopulateMetadata();
             return _assemblyDependencies;
@@ -663,29 +661,26 @@ private string[] ImportFiles()
             }
 
 #if FEATURE_ASSEMBLY_LOADFROM
-            ArrayList files = new ArrayList();
+            var files = new List<string>();
             IntPtr fileEnum = IntPtr.Zero;
-            UInt32[] fileTokens = new UInt32[GENMAN_ENUM_TOKEN_BUF_SIZE];
-            char[] fileNameBuf = new char[GENMAN_STRING_BUF_SIZE];
-            UInt32 fetched;
+            var fileTokens = new UInt32[GENMAN_ENUM_TOKEN_BUF_SIZE];
+            var fileNameBuf = new char[GENMAN_STRING_BUF_SIZE];
 
             // Ensure the enum handle is closed.
             try
             {
                 // Enum chunks of files until we run out.
+                UInt32 fetched;
                 do
                 {
                     _assemblyImport.EnumFiles(ref fileEnum, fileTokens, (uint)fileTokens.Length, out fetched);
 
                     for (uint i = 0; i < fetched; i++)
                     {
-                        IntPtr hashDataPtr;
-                        UInt32 fileNameLength, hashDataLength, fileFlags;
-
                         // Retrieve file properties.
                         _assemblyImport.GetFileProps(fileTokens[i],
-                            fileNameBuf, (uint)fileNameBuf.Length, out fileNameLength,
-                            out hashDataPtr, out hashDataLength, out fileFlags);
+                            fileNameBuf, (uint)fileNameBuf.Length, out uint fileNameLength,
+                            out _, out _, out _);
 
                         // Add file to file list.
                         string file = new string(fileNameBuf, 0, (int)(fileNameLength - 1));
@@ -696,10 +691,12 @@ private string[] ImportFiles()
             finally
             {
                 if (fileEnum != IntPtr.Zero)
+                {
                     _assemblyImport.CloseEnum(fileEnum);
+                }
             }
 
-            return (string[])files.ToArray(typeof(string));
+            return files.ToArray();
 #else
             return Array.Empty<string>();
 #endif
@@ -710,7 +707,7 @@ private string[] ImportFiles()
         /// Allocate assembly metadata structure buffer.
         /// </summary>
         /// <returns>Pointer to structure</returns>
-        private IntPtr AllocAsmMeta()
+        private static IntPtr AllocAsmMeta()
         {
             ASSEMBLYMETADATA asmMeta;
             asmMeta.usMajorVersion = asmMeta.usMinorVersion = asmMeta.usBuildNumber = asmMeta.usRevisionNumber = 0;
@@ -718,7 +715,7 @@ private IntPtr AllocAsmMeta()
             asmMeta.rOses = asmMeta.rpProcessors = IntPtr.Zero;
             // Allocate buffer for locale.
             asmMeta.rpLocale = Marshal.AllocCoTaskMem(GENMAN_LOCALE_BUF_SIZE * 2);
-            asmMeta.cchLocale = (uint)GENMAN_LOCALE_BUF_SIZE;
+            asmMeta.cchLocale = GENMAN_LOCALE_BUF_SIZE;
             // Convert to unmanaged structure.
             int size = Marshal.SizeOf<ASSEMBLYMETADATA>();
             IntPtr asmMetaPtr = Marshal.AllocCoTaskMem(size);
@@ -737,16 +734,21 @@ private IntPtr AllocAsmMeta()
         /// <param name="pubKeyBytes">Count of bytes in public key.</param>
         /// <param name="flags">Extra flags</param>
         /// <returns>The assembly name.</returns>
-        private AssemblyNameExtension ConstructAssemblyName(IntPtr asmMetaPtr, char[] asmNameBuf, UInt32 asmNameLength, IntPtr pubKeyPtr, UInt32 pubKeyBytes, UInt32 flags)
+        private static AssemblyNameExtension ConstructAssemblyName(IntPtr asmMetaPtr, char[] asmNameBuf, UInt32 asmNameLength, IntPtr pubKeyPtr, UInt32 pubKeyBytes, UInt32 flags)
         {
             // Marshal the assembly metadata back to a managed type.
             ASSEMBLYMETADATA asmMeta = (ASSEMBLYMETADATA)Marshal.PtrToStructure(asmMetaPtr, typeof(ASSEMBLYMETADATA));
 
             // Construct the assembly name. (Note asmNameLength should/must be > 0.)
-            AssemblyName assemblyName = new AssemblyName();
-            assemblyName.Name = new string(asmNameBuf, 0, (int)asmNameLength - 1);
-            assemblyName.Version = new Version(asmMeta.usMajorVersion, asmMeta.usMinorVersion, asmMeta.usBuildNumber, asmMeta.usRevisionNumber);
-
+            var assemblyName = new AssemblyName
+            {
+                Name = new string(asmNameBuf, 0, (int) asmNameLength - 1),
+                Version = new Version(
+                    asmMeta.usMajorVersion,
+                    asmMeta.usMinorVersion,
+                    asmMeta.usBuildNumber,
+                    asmMeta.usRevisionNumber)
+            };
 
             // Set culture info.
             string locale = Marshal.PtrToStringUni(asmMeta.rpLocale);
@@ -759,9 +761,8 @@ private AssemblyNameExtension ConstructAssemblyName(IntPtr asmMetaPtr, char[] as
                 assemblyName.CultureInfo = CultureInfo.CreateSpecificCulture(String.Empty);
             }
 
-
             // Set public key or PKT.
-            byte[] publicKey = new byte[pubKeyBytes];
+            var publicKey = new byte[pubKeyBytes];
             Marshal.Copy(pubKeyPtr, publicKey, 0, (int)pubKeyBytes);
             if ((flags & (uint)CorAssemblyFlags.afPublicKey) != 0)
             {
@@ -780,12 +781,12 @@ private AssemblyNameExtension ConstructAssemblyName(IntPtr asmMetaPtr, char[] as
         /// Free the assembly metadata structure.
         /// </summary>
         /// <param name="asmMetaPtr">The pointer.</param>
-        private void FreeAsmMeta(IntPtr asmMetaPtr)
+        private static void FreeAsmMeta(IntPtr asmMetaPtr)
         {
             if (asmMetaPtr != IntPtr.Zero)
             {
                 // Marshal the assembly metadata back to a managed type.
-                ASSEMBLYMETADATA asmMeta = (ASSEMBLYMETADATA)Marshal.PtrToStructure(asmMetaPtr, typeof(ASSEMBLYMETADATA));
+                var asmMeta = (ASSEMBLYMETADATA)Marshal.PtrToStructure(asmMetaPtr, typeof(ASSEMBLYMETADATA));
                 // Free unmanaged memory.
                 Marshal.FreeCoTaskMem(asmMeta.rpLocale);
                 Marshal.DestroyStructure(asmMetaPtr, typeof(ASSEMBLYMETADATA));
@@ -817,7 +818,9 @@ public static string GetRuntimeVersion(string path)
             using (var sr = new BinaryReader(File.OpenRead(path)))
             {
                 if (!File.Exists(path))
+                {
                     return string.Empty;
+                }
 
                 // This algorithm for getting the runtime version is based on
                 // the ECMA Standard 335: The Common Language Infrastructure (CLI)
@@ -837,8 +840,11 @@ public static string GetRuntimeVersion(string path)
                     // and then the PE optional header followed by PE section headers.
                     // There must be room for all of that.
 
-                    if (sr.BaseStream.Length < PEHeaderPointerOffset + 4 + PEHeaderSize + OptionalPEHeaderSize + SectionHeaderSize)
+                    if (sr.BaseStream.Length < PEHeaderPointerOffset + 4 + PEHeaderSize + OptionalPEHeaderSize +
+                        SectionHeaderSize)
+                    {
                         return string.Empty;
+                    }
 
                     // The PE format starts with an MS-DOS stub of 128 bytes.
                     // At offset 0x3c in the DOS header is a 4-byte unsigned integer offset to the PE
@@ -847,15 +853,20 @@ public static string GetRuntimeVersion(string path)
                     sr.BaseStream.Position = PEHeaderPointerOffset;
                     var peHeaderOffset = sr.ReadUInt32();
 
-                    if (peHeaderOffset + 4 + PEHeaderSize + OptionalPEHeaderSize + SectionHeaderSize >= sr.BaseStream.Length)
+                    if (peHeaderOffset + 4 + PEHeaderSize + OptionalPEHeaderSize + SectionHeaderSize >=
+                        sr.BaseStream.Length)
+                    {
                         return string.Empty;
+                    }
 
                     // The PE header is specified in section II.25.2
                     // Read the PE header signature
 
                     sr.BaseStream.Position = peHeaderOffset;
-                    if (!ReadBytes(sr, (byte)'P', (byte)'E', 0, 0))
+                    if (!ReadBytes(sr, (byte) 'P', (byte) 'E', 0, 0))
+                    {
                         return string.Empty;
+                    }
 
                     // The PE header immediately follows the signature
                     var peHeaderBase = peHeaderOffset + 4;
@@ -864,7 +875,9 @@ public static string GetRuntimeVersion(string path)
                     sr.BaseStream.Position = peHeaderBase + 2;
                     var numberOfSections = sr.ReadUInt16();
                     if (numberOfSections > 96)
+                    {
                         return string.Empty; // There can't be more than 96 sections, something is wrong
+                    }
 
                     // Immediately after the PE Header is the PE Optional Header.
                     // This header is optional in the general PE spec, but always
@@ -891,14 +904,18 @@ public static string GetRuntimeVersion(string path)
                         cliHeaderRvaOffset = optionalHeaderOffset + 224;
                     }
                     else
+                    {
                         return string.Empty;
+                    }
 
                     // Read the CLI header RVA
 
                     sr.BaseStream.Position = cliHeaderRvaOffset;
                     var cliHeaderRva = sr.ReadUInt32();
                     if (cliHeaderRva == 0)
+                    {
                         return string.Empty; // No CLI section
+                    }
 
                     // Immediately following the optional header is the Section
                     // Table, which contains a number of section headers.
@@ -938,7 +955,9 @@ public static string GetRuntimeVersion(string path)
 
                     // CLI section not found
                     if (cliHeaderOffset == 0)
+                    {
                         return string.Empty;
+                    }
 
                     // The CLI header is specified in section II.25.3.3.
                     // It contains all of the runtime-specific data entries and other information.
@@ -950,7 +969,9 @@ public static string GetRuntimeVersion(string path)
 
                     var metadataOffset = RvaToOffset(sections, metadataRva);
                     if (metadataOffset == 0)
+                    {
                         return string.Empty;
+                    }
 
                     // The metadata root is specified in section II.24.2.1
                     // The first 4 bytes contain a signature.
@@ -958,23 +979,30 @@ public static string GetRuntimeVersion(string path)
 
                     sr.BaseStream.Position = metadataOffset;
                     if (!ReadBytes(sr, 0x42, 0x53, 0x4a, 0x42)) // Metadata root signature
+                    {
                         return string.Empty;
+                    }
 
                     // Read the version string length
                     sr.BaseStream.Position = metadataOffset + 12;
                     var length = sr.ReadInt32();
                     if (length > 255 || length <= 0 || sr.BaseStream.Position + length >= sr.BaseStream.Length)
+                    {
                         return string.Empty;
+                    }
 
                     // Read the version string
                     var v = Encoding.UTF8.GetString(sr.ReadBytes(length));
                     if (v.Length < 2 || v[0] != 'v')
+                    {
                         return string.Empty;
+                    }
 
                     // Make sure it is a version number
-                    Version version;
-                    if (!Version.TryParse(v.Substring(1), out version))
+                    if (!Version.TryParse(v.Substring(1), out _))
+                    {
                         return string.Empty;
+                    }
                     return v;
                 }
                 catch
@@ -987,11 +1015,14 @@ public static string GetRuntimeVersion(string path)
 
         private static bool ReadBytes(BinaryReader r, params byte[] bytes)
         {
-            for (int n = 0; n < bytes.Length; n++)
+            foreach (byte b in bytes)
             {
-                if (bytes[n] != r.ReadByte())
+                if (b != r.ReadByte())
+                {
                     return false;
+                }
             }
+
             return true;
         }
 
diff --git a/src/Tasks/AssemblyDependency/AssemblyNameReference.cs b/src/Tasks/AssemblyDependency/AssemblyNameReference.cs
index 103fc26b050..40f179a5380 100644
--- a/src/Tasks/AssemblyDependency/AssemblyNameReference.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyNameReference.cs
@@ -2,14 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
-using System.Collections;
-using System.Globalization;
-using System.Runtime.InteropServices;
-using System.Diagnostics;
-using System.Reflection;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -33,8 +25,6 @@ public override string ToString()
         /// <summary>
         /// Compare by assembly name.
         /// </summary>
-        /// <param name="other"></param>
-        /// <returns></returns>
         public int CompareTo(AssemblyNameReference other)
         {
             return assemblyName.CompareTo(other.assemblyName);
@@ -43,9 +33,6 @@ public int CompareTo(AssemblyNameReference other)
         /// <summary>
         /// Construct a new AssemblyNameReference.
         /// </summary>
-        /// <param name="assemblyName"></param>
-        /// <param name="reference"></param>
-        /// <returns></returns>
         public static AssemblyNameReference Create(AssemblyNameExtension assemblyName, Reference reference)
         {
             AssemblyNameReference result;
diff --git a/src/Tasks/AssemblyDependency/AssemblyNameReferenceAscendingVersionComparer.cs b/src/Tasks/AssemblyDependency/AssemblyNameReferenceAscendingVersionComparer.cs
index a416a68ab63..2ee7a97689b 100644
--- a/src/Tasks/AssemblyDependency/AssemblyNameReferenceAscendingVersionComparer.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyNameReferenceAscendingVersionComparer.cs
@@ -3,15 +3,16 @@
 
 using System;
 using System.Collections;
+using System.Collections.Generic;
 
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
     /// Compare the two AssemblyNameReferences by version number.
     /// </summary>
-    sealed internal class AssemblyNameReferenceAscendingVersionComparer : IComparer
+    internal sealed class AssemblyNameReferenceAscendingVersionComparer : IComparer<AssemblyNameReference>
     {
-        internal readonly static IComparer comparer = new AssemblyNameReferenceAscendingVersionComparer();
+        internal static readonly IComparer<AssemblyNameReference> comparer = new AssemblyNameReferenceAscendingVersionComparer();
 
         /// <summary>
         /// Private construct so there's only one instance.
@@ -23,14 +24,8 @@ private AssemblyNameReferenceAscendingVersionComparer()
         /// <summary>
         /// Compare the two AssemblyNameReferences by version number.
         /// </summary>
-        /// <param name="o1"></param>
-        /// <param name="o2"></param>
-        /// <returns></returns>
-        public int Compare(object o1, object o2)
+        public int Compare(AssemblyNameReference i1, AssemblyNameReference i2)
         {
-            AssemblyNameReference i1 = (AssemblyNameReference)o1;
-            AssemblyNameReference i2 = (AssemblyNameReference)o2;
-
             Version v1 = i1.assemblyName.Version;
             Version v2 = i2.assemblyName.Version;
 
diff --git a/src/Tasks/AssemblyDependency/AssemblyResolution.cs b/src/Tasks/AssemblyDependency/AssemblyResolution.cs
index 361edc442b1..47548b52db2 100644
--- a/src/Tasks/AssemblyDependency/AssemblyResolution.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyResolution.cs
@@ -2,18 +2,11 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Resources;
+using System.Collections;
+using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
-using System.Reflection;
-using System.IO;
-using System.Collections;
-using System.Collections.Generic;
-using System.Globalization;
-using System.Diagnostics;
-using System.Runtime.InteropServices;
-using System.Text.RegularExpressions;
 using Microsoft.Build.Tasks.AssemblyFoldersFromConfig;
 
 namespace Microsoft.Build.Tasks
@@ -37,8 +30,10 @@ internal static class AssemblyResolution
         /// </summary>
         /// <param name="jaggedResolvers">The array of resolvers to search with.</param>
         /// <param name="assemblyName">The assembly name to look up.</param>
+        /// <param name="sdkName"></param>
         /// <param name="rawFileNameCandidate">The file name to match if {RawFileName} is seen. (May be null).</param>
         /// <param name="isPrimaryProjectReference">True if this is a primary reference directly from the project file.</param>
+        /// <param name="wantSpecificVersion"></param>
         /// <param name="executableExtensions">The filename extension of the assembly. Must be this or its no match.</param>
         /// <param name="hintPath">This reference's hintpath</param>
         /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
@@ -78,7 +73,6 @@ out bool userRequestedSpecificFile
                 // Search each searchpath.
                 foreach (Resolver resolver in resolvers)
                 {
-                    string fileLocation;
                     if
                     (
                         resolver.Resolve
@@ -92,7 +86,7 @@ out bool userRequestedSpecificFile
                             hintPath,
                             assemblyFolderKey,
                             assembliesConsideredAndRejected,
-                            out fileLocation,
+                            out string fileLocation,
                             out userRequestedSpecificFile
                         )
                     )
@@ -109,6 +103,7 @@ out userRequestedSpecificFile
         /// <summary>
         /// Compile search paths into an array of resolvers.
         /// </summary>
+        /// <param name="buildEngine"></param>
         /// <param name="searchPaths"></param>
         /// <param name="candidateAssemblyFiles">Paths to assembly files mentioned in the project.</param>
         /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64, the processor architecture being targetted.</param>
@@ -117,7 +112,12 @@ out userRequestedSpecificFile
         /// <param name="getAssemblyName"></param>
         /// <param name="getRegistrySubKeyNames"></param>
         /// <param name="getRegistrySubKeyDefaultValue"></param>
+        /// <param name="openBaseKey"></param>
         /// <param name="installedAssemblies"></param>
+        /// <param name="getRuntimeVersion"></param>
+        /// <param name="targetedRuntimeVersion"></param>
+        /// <param name="getAssemblyPathInGac"></param>
+        /// <param name="log"></param>
         /// <returns></returns>
         public static Resolver[] CompileSearchPaths
         (
@@ -140,7 +140,7 @@ public static Resolver[] CompileSearchPaths
             TaskLoggingHelper log
         )
         {
-            Resolver[] resolvers = new Resolver[searchPaths.Length];
+            var resolvers = new Resolver[searchPaths.Length];
 
             for (int p = 0; p < searchPaths.Length; ++p)
             {
@@ -196,10 +196,6 @@ TaskLoggingHelper log
         /// <summary>
         /// Build a resolver array from a set of directories to resolve directly from.
         /// </summary>
-        /// <param name="directories"></param>
-        /// <param name="fileExists"></param>
-        /// <param name="getAssemblyName"></param>
-        /// <returns></returns>
         internal static Resolver[] CompileDirectories
         (
             List<string> directories,
diff --git a/src/Tasks/AssemblyDependency/AssemblyResolutionConstants.cs b/src/Tasks/AssemblyDependency/AssemblyResolutionConstants.cs
index bd2b54231d4..f59f6714724 100644
--- a/src/Tasks/AssemblyDependency/AssemblyResolutionConstants.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyResolutionConstants.cs
@@ -1,19 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Resources;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
-using Microsoft.Build.Shared;
-using System.Reflection;
-using System.IO;
-using System.Collections;
-using System.Globalization;
-using System.Diagnostics;
-using System.Runtime.InteropServices;
-using System.Text.RegularExpressions;
-
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
diff --git a/src/Tasks/AssemblyDependency/BadImageReferenceException.cs b/src/Tasks/AssemblyDependency/BadImageReferenceException.cs
index ccbebed6fa8..ab7ebd3a456 100644
--- a/src/Tasks/AssemblyDependency/BadImageReferenceException.cs
+++ b/src/Tasks/AssemblyDependency/BadImageReferenceException.cs
@@ -12,13 +12,6 @@ namespace Microsoft.Build.Tasks
     [Serializable]
     internal sealed class BadImageReferenceException : Exception
     {
-        /// <summary>
-        /// Don't allow default construction.
-        /// </summary>
-        private BadImageReferenceException()
-        {
-        }
-
         /// <summary>
         /// Construct
         /// </summary>
diff --git a/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs b/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
index 6d01bf7ef2e..06a57288be6 100644
--- a/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
+++ b/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
@@ -17,7 +17,7 @@ internal class CandidateAssemblyFilesResolver : Resolver
         /// <summary>
         /// The candidate assembly files.
         /// </summary>
-        private string[] _candidateAssemblyFiles;
+        private readonly string[] _candidateAssemblyFiles;
 
         /// <summary>
         /// Construct.
@@ -36,6 +36,7 @@ public CandidateAssemblyFilesResolver(string[] candidateAssemblyFiles, string se
         /// Resolve a reference to a specific file name.
         /// </summary>
         /// <param name="assemblyName">The assemblyname of the reference.</param>
+        /// <param name="sdkName"></param>
         /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
         /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
         /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
@@ -57,7 +58,6 @@ public override bool Resolve
             string hintPath,
             string assemblyFolderKey,
             ArrayList assembliesConsideredAndRejected,
-
             out string foundPath,
             out bool userRequestedSpecificFile
         )
@@ -80,9 +80,11 @@ out bool userRequestedSpecificFile
                         ResolutionSearchLocation considered = null;
                         if (assembliesConsideredAndRejected != null)
                         {
-                            considered = new ResolutionSearchLocation();
-                            considered.FileNameAttempted = candidateAssemblyFile;
-                            considered.SearchPath = searchPathElement;
+                            considered = new ResolutionSearchLocation
+                            {
+                                FileNameAttempted = candidateAssemblyFile,
+                                SearchPath = searchPathElement
+                            };
                         }
 
                         if (FileMatchesAssemblyName(assemblyName, isPrimaryProjectReference, wantSpecificVersion, false, candidateAssemblyFile, considered))
@@ -108,8 +110,6 @@ out bool userRequestedSpecificFile
                 }
             }
 
-
-
             return false;
         }
     }
diff --git a/src/Tasks/AssemblyDependency/ConflictLossReason.cs b/src/Tasks/AssemblyDependency/ConflictLossReason.cs
index c84d211c0ca..2a5f99c478e 100644
--- a/src/Tasks/AssemblyDependency/ConflictLossReason.cs
+++ b/src/Tasks/AssemblyDependency/ConflictLossReason.cs
@@ -1,15 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.IO;
-using System.Collections;
-using System.Reflection;
-using System.Diagnostics;
-using System.Globalization;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Framework;
-
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
diff --git a/src/Tasks/AssemblyDependency/CopyLocalState.cs b/src/Tasks/AssemblyDependency/CopyLocalState.cs
index b48481f3ebc..ffc77ba7845 100644
--- a/src/Tasks/AssemblyDependency/CopyLocalState.cs
+++ b/src/Tasks/AssemblyDependency/CopyLocalState.cs
@@ -1,14 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.IO;
-using System.Collections;
-using System.Reflection;
-using System.Diagnostics;
-using System.Globalization;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Tasks
 {
@@ -86,8 +79,6 @@ internal static class CopyLocalStateUtility
         /// <summary>
         /// Returns the true or false from a CopyLocalState.
         /// </summary>
-        /// <param name="state"></param>
-        /// <returns></returns>
         internal static bool IsCopyLocal(CopyLocalState state)
         {
             switch (state)
diff --git a/src/Tasks/AssemblyDependency/DependencyResolutionException.cs b/src/Tasks/AssemblyDependency/DependencyResolutionException.cs
index 1821f403622..26692718ced 100644
--- a/src/Tasks/AssemblyDependency/DependencyResolutionException.cs
+++ b/src/Tasks/AssemblyDependency/DependencyResolutionException.cs
@@ -12,13 +12,6 @@ namespace Microsoft.Build.Tasks
     [Serializable]
     internal sealed class DependencyResolutionException : Exception
     {
-        /// <summary>
-        /// Don't allow default construction.
-        /// </summary>
-        private DependencyResolutionException()
-        {
-        }
-
         /// <summary>
         /// Construct
         /// </summary>
diff --git a/src/Tasks/AssemblyDependency/DirectoryResolver.cs b/src/Tasks/AssemblyDependency/DirectoryResolver.cs
index c15a5cf4d12..db5ace43ef2 100644
--- a/src/Tasks/AssemblyDependency/DirectoryResolver.cs
+++ b/src/Tasks/AssemblyDependency/DirectoryResolver.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Reflection;
 using System.Collections;
 using Microsoft.Build.Shared;
 
@@ -16,19 +15,16 @@ internal class DirectoryResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        /// <param name="searchPathElement"></param>
-        /// <param name="getAssemblyName"></param>
-        /// <param name="fileExists"></param>
         public DirectoryResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
             : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
         {
         }
 
-
         /// <summary>
         /// Resolve a reference to a specific file name.
         /// </summary>
         /// <param name="assemblyName">The assemblyname of the reference.</param>
+        /// <param name="sdkName"></param>
         /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
         /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
         /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
@@ -50,7 +46,6 @@ public override bool Resolve
             string hintPath,
             string assemblyFolderKey,
             ArrayList assembliesConsideredAndRejected,
-
             out string foundPath,
             out bool userRequestedSpecificFile
         )
@@ -65,8 +60,7 @@ out bool userRequestedSpecificFile
                 foundPath = resolvedPath;
                 return true;
             }
-
-
+            
             return false;
         }
     }
diff --git a/src/Tasks/AssemblyDependency/DisposableBase.cs b/src/Tasks/AssemblyDependency/DisposableBase.cs
index b9f6b60b952..f1e7a08dac7 100644
--- a/src/Tasks/AssemblyDependency/DisposableBase.cs
+++ b/src/Tasks/AssemblyDependency/DisposableBase.cs
@@ -8,12 +8,12 @@ namespace Microsoft.Build.Tasks
     //
     // Abstract base class to implement IDisposable interface.
     //
-    internal abstract class DisposableBase : System.IDisposable
+    internal abstract class DisposableBase : IDisposable
     {
         private bool _disposed;
 
         // Constructor
-        public DisposableBase()
+        protected DisposableBase()
         {
             _disposed = false;
         }
diff --git a/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs b/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
index 22fd35d4727..1ed24824d38 100644
--- a/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
+++ b/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Reflection;
 using System.Collections;
 using Microsoft.Build.Shared;
 
@@ -14,19 +13,14 @@ namespace Microsoft.Build.Tasks
     internal class FrameworkPathResolver : Resolver
     {
         // Paths to FX folders.
-        private string[] _frameworkPaths;
+        private readonly string[] _frameworkPaths;
 
         // Table of information about framework assemblies.
-        private InstalledAssemblies _installedAssemblies;
+        private readonly InstalledAssemblies _installedAssemblies;
 
         /// <summary>
         /// Construct.
         /// </summary>
-        /// <param name="frameworkPaths">Paths to framework directories.</param>
-        /// <param name="installedAssemblies"></param>
-        /// <param name="searchPathElement"></param>
-        /// <param name="getAssemblyName"></param>
-        /// <param name="fileExists"></param>
         public FrameworkPathResolver(string[] frameworkPaths, InstalledAssemblies installedAssemblies, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
             : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
         {
@@ -34,11 +28,11 @@ public FrameworkPathResolver(string[] frameworkPaths, InstalledAssemblies instal
             _installedAssemblies = installedAssemblies;
         }
 
-
         /// <summary>
         /// Resolve a reference to a specific file name.
         /// </summary>
         /// <param name="assemblyName">The assemblyname of the reference.</param>
+        /// <param name="sdkName"></param>
         /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
         /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
         /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
@@ -60,7 +54,6 @@ public override bool Resolve
             string hintPath,
             string assemblyFolderKey,
             ArrayList assembliesConsideredAndRejected,
-
             out string foundPath,
             out bool userRequestedSpecificFile
         )
@@ -106,7 +99,7 @@ internal static AssemblyNameExtension GetHighestVersionInRedist(InstalledAssembl
                 {
                     for (int i = 0; i < assemblyEntries.Length; ++i)
                     {
-                        AssemblyNameExtension current = new AssemblyNameExtension(assemblyEntries[i].FullName);
+                        var current = new AssemblyNameExtension(assemblyEntries[i].FullName);
 
                         // If the current version is higher than the previously looked at.
                         if (current.Version != null && current.Version.CompareTo(assemblyNameToUse.Version) > 0)
diff --git a/src/Tasks/AssemblyDependency/GacResolver.cs b/src/Tasks/AssemblyDependency/GacResolver.cs
index 34fc6c46b45..600e3f9e52b 100644
--- a/src/Tasks/AssemblyDependency/GacResolver.cs
+++ b/src/Tasks/AssemblyDependency/GacResolver.cs
@@ -2,11 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Reflection;
 using System.Collections;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
 {
@@ -36,11 +33,11 @@ public GacResolver(System.Reflection.ProcessorArchitecture targetProcessorArchit
             _getAssemblyPathInGac = getAssemblyPathInGac;
         }
 
-
         /// <summary>
         /// Resolve a reference to a specific file name.
         /// </summary>
         /// <param name="assemblyName">The assembly name object of the assembly.</param>
+        /// <param name="sdkName"></param>
         /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
         /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
         /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
@@ -85,17 +82,18 @@ out bool userRequestedSpecificFile
                     // Record this as a location that was considered.
                     if (assembliesConsideredAndRejected != null)
                     {
-                        ResolutionSearchLocation considered = new ResolutionSearchLocation();
-                        considered.FileNameAttempted = assemblyName.FullName;
-                        considered.SearchPath = searchPathElement;
-                        considered.AssemblyName = assemblyName;
-                        considered.Reason = NoMatchReason.NotInGac;
+                        var considered = new ResolutionSearchLocation
+                        {
+                            FileNameAttempted = assemblyName.FullName,
+                            SearchPath = searchPathElement,
+                            AssemblyName = assemblyName,
+                            Reason = NoMatchReason.NotInGac
+                        };
                         assembliesConsideredAndRejected.Add(considered);
                     }
                 }
             }
 
-
             return false;
         }
     }
diff --git a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
index 1f933476e64..e71f38a96ff 100644
--- a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
+++ b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
@@ -32,39 +32,23 @@ public class GenerateBindingRedirects : TaskExtension
         /// <summary>
         /// Sugested redirects as output from the ResolveAssemblyReference task.
         /// </summary>
-        public ITaskItem[] SuggestedRedirects
-        {
-            get;
-            set;
-        }
+        public ITaskItem[] SuggestedRedirects { get; set; }
 
         /// <summary>
         /// Path to the app.config source file.
         /// </summary>
-        public ITaskItem AppConfigFile
-        {
-            get;
-            set;
-        }
+        public ITaskItem AppConfigFile { get; set; }
 
         /// <summary>
         /// Name of the output application config file: $(TargetFileName).config
         /// </summary>
-        public string TargetName
-        {
-            get;
-            set;
-        }
+        public string TargetName { get; set; }
 
         /// <summary>
         /// Path to an intermediate file where we can write the input app.config plus the generated binding redirects.
         /// </summary>
         [Output]
-        public ITaskItem OutputAppConfigFile
-        {
-            get;
-            set;
-        }
+        public ITaskItem OutputAppConfigFile { get; set; }
 
         /// <summary>
         /// Execute the task.
@@ -87,10 +71,10 @@ public override bool Execute()
                 return false;
             }
 
-            var runtimeNode = doc.Root.Nodes()
-                                        .OfType<XElement>()
-                                        .Where(e => e.Name.LocalName == "runtime")
-                                        .FirstOrDefault();
+            XElement runtimeNode = doc.Root
+                                      .Nodes()
+                                      .OfType<XElement>()
+                                      .FirstOrDefault(e => e.Name.LocalName == "runtime");
 
             if (runtimeNode == null)
             {
@@ -224,10 +208,10 @@ private void UpdateExistingBindingRedirects(XElement runtimeNode, IDictionary<As
 
                 foreach (var dependentAssembly in dependentAssemblies)
                 {
-                    var assemblyIdentity = dependentAssembly.Nodes()
+                    var assemblyIdentity = dependentAssembly
+                        .Nodes()
                         .OfType<XElement>()
-                        .Where(e => e.Name.LocalName == "assemblyIdentity")
-                        .FirstOrDefault();
+                        .FirstOrDefault(e => e.Name.LocalName == "assemblyIdentity");
 
                     if (assemblyIdentity == null)
                     {
@@ -237,10 +221,10 @@ private void UpdateExistingBindingRedirects(XElement runtimeNode, IDictionary<As
                         continue;
                     }
 
-                    var bindingRedirect = dependentAssembly.Nodes()
+                    var bindingRedirect = dependentAssembly
+                        .Nodes()
                         .OfType<XElement>()
-                        .Where(e => e.Name.LocalName == "bindingRedirect")
-                        .FirstOrDefault();
+                        .FirstOrDefault(e => e.Name.LocalName == "bindingRedirect");
 
                     if (bindingRedirect == null)
                     {
@@ -260,7 +244,7 @@ private void UpdateExistingBindingRedirects(XElement runtimeNode, IDictionary<As
                     var nameValue = name.Value;
                     var publicKeyTokenValue = publicKeyToken.Value;
                     var culture = assemblyIdentity.Attribute("culture");
-                    var cultureValue = culture == null ? String.Empty : culture.Value;
+                    var cultureValue = culture?.Value ?? String.Empty;
 
                     var oldVersionAttribute = bindingRedirect.Attribute("oldVersion");
                     var newVersionAttribute = bindingRedirect.Attribute("newVersion");
@@ -271,7 +255,7 @@ private void UpdateExistingBindingRedirects(XElement runtimeNode, IDictionary<As
                     }
 
                     var oldVersionRange = oldVersionAttribute.Value.Split('-');
-                    if (oldVersionRange == null || oldVersionRange.Length == 0 || oldVersionRange.Length > 2)
+                    if (oldVersionRange.Length == 0 || oldVersionRange.Length > 2)
                     {
                         continue;
                     }
@@ -279,14 +263,13 @@ private void UpdateExistingBindingRedirects(XElement runtimeNode, IDictionary<As
                     var oldVerStrLow = oldVersionRange[0];
                     var oldVerStrHigh = oldVersionRange[oldVersionRange.Length == 1 ? 0 : 1];
 
-                    Version oldVersionLow, oldVersionHigh;
-                    if (!Version.TryParse(oldVerStrLow, out oldVersionLow))
+                    if (!Version.TryParse(oldVerStrLow, out Version oldVersionLow))
                     {
                         Log.LogWarningWithCodeFromResources("GenerateBindingRedirects.MalformedVersionNumber", oldVerStrLow);
                         continue;
                     }
 
-                    if (!Version.TryParse(oldVerStrHigh, out oldVersionHigh))
+                    if (!Version.TryParse(oldVerStrHigh, out Version oldVersionHigh))
                     {
                         Log.LogWarningWithCodeFromResources("GenerateBindingRedirects.MalformedVersionNumber", oldVerStrHigh);
                         continue;
@@ -309,10 +292,16 @@ private void UpdateExistingBindingRedirects(XElement runtimeNode, IDictionary<As
                                 var newPublicKeyToken = entry.Key.GetPublicKeyToken();
                                 var newProcessorArchitecture = entry.Key.ProcessorArchitecture;
 
-                                var attributes = new List<XAttribute>(4);
-                                attributes.Add(new XAttribute("name", newName));
-                                attributes.Add(new XAttribute("culture", String.IsNullOrEmpty(newCulture) ? "neutral" : newCulture));
-                                attributes.Add(new XAttribute("publicKeyToken", ResolveAssemblyReference.ByteArrayToString(newPublicKeyToken)));
+                                var attributes = new List<XAttribute>(4)
+                                {
+                                    new XAttribute("name", newName),
+                                    new XAttribute(
+                                        "culture",
+                                        String.IsNullOrEmpty(newCulture) ? "neutral" : newCulture),
+                                    new XAttribute(
+                                        "publicKeyToken",
+                                        ResolveAssemblyReference.ByteArrayToString(newPublicKeyToken))
+                                };
                                 if (newProcessorArchitecture != 0)
                                 {
                                     attributes.Add(new XAttribute("processorArchitecture", newProcessorArchitecture.ToString()));
diff --git a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
index 29c1d953ca6..bd27d48ab41 100644
--- a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
+++ b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
@@ -17,28 +17,28 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Methods for dealing with the GAC.
     /// </summary>
-    static internal class GlobalAssemblyCache
+    internal static class GlobalAssemblyCache
     {
         /// <summary>
         /// Default delegate to get the path based on a fusion name.
         /// </summary>
-        internal static readonly GetPathFromFusionName pathFromFusionName = new GetPathFromFusionName(RetrievePathFromFusionName);
+        internal static readonly GetPathFromFusionName pathFromFusionName = RetrievePathFromFusionName;
 
         /// <summary>
         /// Default delegate to get the gac enumerator.
         /// </summary>
-        internal static readonly GetGacEnumerator gacEnumerator = new GetGacEnumerator(GetGacNativeEnumerator);
+        internal static readonly GetGacEnumerator gacEnumerator = GetGacNativeEnumerator;
 
         /// <summary>
         /// Given a strong name, find its path in the GAC.
         /// </summary>
-        /// <param name="strongName">The strong name.</param>
+        /// <param name="assemblyName">The assembly name.</param>
         /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64.</param>
         /// <returns>The path to the assembly. Empty if none exists.</returns>
         private static string GetLocationImpl(AssemblyNameExtension assemblyName, string targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntime, FileExists fileExists, GetPathFromFusionName getPathFromFusionName, GetGacEnumerator getGacEnumerator, bool specificVersion)
         {
             // Extra checks for PInvoke-destined data.
-            ErrorUtilities.VerifyThrowArgumentNull(assemblyName, "assemblyName");
+            ErrorUtilities.VerifyThrowArgumentNull(assemblyName, nameof(assemblyName));
             ErrorUtilities.VerifyThrow(assemblyName.FullName != null, "Got a null assembly name fullname.");
 
             string strongName = assemblyName.FullName;
@@ -81,19 +81,16 @@ private static string GetLocationImpl(AssemblyNameExtension assemblyName, string
         /// </summary>
         internal static IEnumerable<AssemblyNameExtension> GetGacNativeEnumerator(string strongName)
         {
-            IEnumerable<AssemblyNameExtension> gacEnumerator = null;
             try
             {
                 // Will fail if the publickeyToken is null but will not fail if it is missing.
-                gacEnumerator = new Microsoft.Build.Tasks.NativeMethods.AssemblyCacheEnum(strongName);
+                return new NativeMethods.AssemblyCacheEnum(strongName);
             }
             catch (FileLoadException)
             {
                 // We could not handle the name passed in
                 return null;
             }
-
-            return gacEnumerator;
         }
 
         /// <summary>
@@ -101,7 +98,7 @@ internal static IEnumerable<AssemblyNameExtension> GetGacNativeEnumerator(string
         /// </summary>
         private static SortedDictionary<Version, SortedDictionary<AssemblyNameExtension, string>> GenerateListOfAssembliesByRuntime(string strongName, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntime, FileExists fileExists, GetPathFromFusionName getPathFromFusionName, GetGacEnumerator getGacEnumerator, bool specificVersion)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(targetedRuntime, "targetedRuntime");
+            ErrorUtilities.VerifyThrowArgumentNull(targetedRuntime, nameof(targetedRuntime));
 
             IEnumerable<AssemblyNameExtension> gacEnum = getGacEnumerator(strongName);
 
@@ -162,20 +159,17 @@ private static SortedDictionary<Version, SortedDictionary<AssemblyNameExtension,
         internal static string RetrievePathFromFusionName(string strongName)
         {
             // Extra checks for PInvoke-destined data.
-            ErrorUtilities.VerifyThrowArgumentNull(strongName, "assemblyName");
+            ErrorUtilities.VerifyThrowArgumentNull(strongName, nameof(strongName));
 
             string value;
 
             if (NativeMethodsShared.IsWindows)
             {
-                IAssemblyCache assemblyCache;
-
-                uint hr = NativeMethods.CreateAssemblyCache(out assemblyCache, 0);
+                uint hr = NativeMethods.CreateAssemblyCache(out IAssemblyCache assemblyCache, 0);
 
                 ErrorUtilities.VerifyThrow(hr == NativeMethodsShared.S_OK, "CreateAssemblyCache failed, hr {0}", hr);
 
-                ASSEMBLY_INFO assemblyInfo = new ASSEMBLY_INFO();
-                assemblyInfo.cbAssemblyInfo = (uint)Marshal.SizeOf<ASSEMBLY_INFO>();
+                var assemblyInfo = new ASSEMBLY_INFO { cbAssemblyInfo = (uint) Marshal.SizeOf<ASSEMBLY_INFO>() };
 
                 assemblyCache.QueryAssemblyInfo(0, strongName, ref assemblyInfo);
 
@@ -273,8 +267,7 @@ bool specificVersion
                 {
                     if (fusionNameToResolvedPath.ContainsKey(strongName))
                     {
-                        string fusionName = null;
-                        fusionNameToResolvedPath.TryGetValue(strongName, out fusionName);
+                        fusionNameToResolvedPath.TryGetValue(strongName, out string fusionName);
                         return fusionName;
                     }
                 }
@@ -283,17 +276,11 @@ bool specificVersion
             // Optimize out the case where the public key token is null, if it is null it is not a strongly named assembly and CANNOT be in the gac.
             // also passing it would cause the gac enumeration method to throw an exception indicating the assembly is not a strongnamed assembly.
 
-            string location = null;
-
             // If the publickeyToken is null and the publickeytoken is in the fusion name then this means we are passing in a null or empty PublicKeyToken and then this cannot possibly be in the gac.
             if ((strongName.GetPublicKeyToken() == null || strongName.GetPublicKeyToken().Length == 0) && strongName.FullName.IndexOf("PublicKeyToken", StringComparison.OrdinalIgnoreCase) != -1)
             {
-                if (fusionNameToResolvedPath != null)
-                {
-                    fusionNameToResolvedPath.TryAdd(strongName, location);
-                }
-
-                return location;
+                fusionNameToResolvedPath?.TryAdd(strongName, null);
+                return null;
             }
 
             // A delegate was not passed in to use the default one
@@ -303,6 +290,7 @@ bool specificVersion
             getGacEnumerator = getGacEnumerator ?? gacEnumerator;
 
             // If we have no processor architecture set then we can tryout a number of processor architectures.
+            string location;
             if (!strongName.HasProcessorArchitectureInFusionName)
             {
                 if (targetProcessorArchitecture != ProcessorArchitecture.MSIL && targetProcessorArchitecture != ProcessorArchitecture.None)
@@ -318,12 +306,9 @@ bool specificVersion
                         location = GetLocationImpl(strongName, processorArchitecture, getRuntimeVersion, targetedRuntimeVersion, fileExists, getPathFromFusionName, getGacEnumerator, specificVersion);
                     }
 
-                    if (location != null && location.Length > 0)
+                    if (!string.IsNullOrEmpty(location))
                     {
-                        if (fusionNameToResolvedPath != null)
-                        {
-                            fusionNameToResolvedPath.TryAdd(strongName, location);
-                        }
+                        fusionNameToResolvedPath?.TryAdd(strongName, location);
                         return location;
                     }
                 }
@@ -337,12 +322,9 @@ bool specificVersion
                 {
                     location = GetLocationImpl(strongName, "MSIL", getRuntimeVersion, targetedRuntimeVersion, fileExists, getPathFromFusionName, getGacEnumerator, specificVersion);
                 }
-                if (location != null && location.Length > 0)
+                if (!string.IsNullOrEmpty(location))
                 {
-                    if (fusionNameToResolvedPath != null)
-                    {
-                        fusionNameToResolvedPath.TryAdd(strongName, location);
-                    }
+                    fusionNameToResolvedPath?.TryAdd(strongName, location);
                     return location;
                 }
             }
@@ -357,19 +339,13 @@ bool specificVersion
                 location = GetLocationImpl(strongName, null, getRuntimeVersion, targetedRuntimeVersion, fileExists, getPathFromFusionName, getGacEnumerator, specificVersion);
             }
 
-            if (location != null && location.Length > 0)
+            if (!string.IsNullOrEmpty(location))
             {
-                if (fusionNameToResolvedPath != null)
-                {
-                    fusionNameToResolvedPath.TryAdd(strongName, location);
-                }
+                fusionNameToResolvedPath?.TryAdd(strongName, location);
                 return location;
             }
 
-            if (fusionNameToResolvedPath != null)
-            {
-                fusionNameToResolvedPath.TryAdd(strongName, null);
-            }
+            fusionNameToResolvedPath?.TryAdd(strongName, null);
 
             return null;
         }
@@ -377,7 +353,6 @@ bool specificVersion
         /// <summary>
         /// Return the root path of the GAC
         /// </summary>
-        /// <returns></returns>
         internal static string GetGacPath()
         {
             int gacPathLength = 0;
diff --git a/src/Tasks/AssemblyDependency/HintPathResolver.cs b/src/Tasks/AssemblyDependency/HintPathResolver.cs
index d5ee4fef2be..561729126ec 100644
--- a/src/Tasks/AssemblyDependency/HintPathResolver.cs
+++ b/src/Tasks/AssemblyDependency/HintPathResolver.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
 using System.Reflection;
 using System.Collections;
 using Microsoft.Build.Shared;
@@ -17,9 +16,6 @@ internal class HintPathResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        /// <param name="searchPathElement"></param>
-        /// <param name="getAssemblyName"></param>
-        /// <param name="fileExists"></param>
         public HintPathResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
             : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false)
         {
@@ -29,6 +25,7 @@ public HintPathResolver(string searchPathElement, GetAssemblyName getAssemblyNam
         /// Resolve a reference to a specific file name.
         /// </summary>
         /// <param name="assemblyName">The assemblyname of the reference.</param>
+        /// <param name="sdkName"></param>
         /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
         /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
         /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
@@ -50,12 +47,11 @@ public override bool Resolve
             string hintPath,
             string assemblyFolderKey,
             ArrayList assembliesConsideredAndRejected,
-
             out string foundPath,
             out bool userRequestedSpecificFile
         )
         {
-            if (hintPath != null && hintPath.Length > 0)
+            if (!string.IsNullOrEmpty(hintPath))
             {
                 if (ResolveAsFile(hintPath, assemblyName, isPrimaryProjectReference, wantSpecificVersion, true, assembliesConsideredAndRejected))
                 {
diff --git a/src/Tasks/AssemblyDependency/InstalledAssemblies.cs b/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
index 136e6628de0..a37a9cc6c0b 100644
--- a/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
+++ b/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
@@ -2,16 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
-using System.Collections;
-using System.Globalization;
-using System.Runtime.InteropServices;
-using System.Diagnostics;
-using System.Reflection;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
-using System.Collections.Generic;
 
 namespace Microsoft.Build.Tasks
 {
@@ -20,12 +11,11 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     internal class InstalledAssemblies
     {
-        private RedistList _redistList = null;
+        private readonly RedistList _redistList;
 
         /// <summary>
         /// Construct.
         /// </summary>
-        /// <param name="redistList"></param>
         internal InstalledAssemblies(RedistList redistList)
         {
             _redistList = redistList;
@@ -53,7 +43,6 @@ out string redistName
             isRedistRoot = null;
             redistName = null;
 
-
             // Short-circuit in cases where there is no redist list.
             if (_redistList == null)
             {
@@ -83,8 +72,6 @@ out string redistName
                 isPrerequisite = _redistList.IsPrerequisiteAssembly(highestVersionFromRedistList.FullName);
                 isRedistRoot = _redistList.IsRedistRoot(highestVersionFromRedistList.FullName);
                 redistName = _redistList.RedistName(highestVersionFromRedistList.FullName);
-
-                return;
             }
         }
 
@@ -95,12 +82,7 @@ out string redistName
         internal AssemblyNameExtension RemapAssemblyExtension(AssemblyNameExtension assemblyName)
         {
             // Short-circuit in cases where there is no redist list
-            if (_redistList == null)
-            {
-                return null;
-            }
-
-            return _redistList.RemapAssembly(assemblyName);
+            return _redistList?.RemapAssembly(assemblyName);
         }
 
         /// <summary>
diff --git a/src/Tasks/AssemblyDependency/InvalidReferenceAssemblyNameException.cs b/src/Tasks/AssemblyDependency/InvalidReferenceAssemblyNameException.cs
index ed4bbf5995d..e4151f82e01 100644
--- a/src/Tasks/AssemblyDependency/InvalidReferenceAssemblyNameException.cs
+++ b/src/Tasks/AssemblyDependency/InvalidReferenceAssemblyNameException.cs
@@ -2,14 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
-using System.Collections;
-using System.Globalization;
-using System.Runtime.InteropServices;
-using System.Diagnostics;
-using System.Reflection;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 using System.Runtime.Serialization;
 
 namespace Microsoft.Build.Tasks
@@ -21,21 +13,12 @@ namespace Microsoft.Build.Tasks
     [Serializable]
     internal sealed class InvalidReferenceAssemblyNameException : Exception
     {
-        private string sourceItemSpec;
-
-        /// <summary>
-        /// Don't allow default construction.
-        /// </summary>
-        private InvalidReferenceAssemblyNameException()
-        {
-        }
-
         /// <summary>
         /// Construct
         /// </summary>
         internal InvalidReferenceAssemblyNameException(string sourceItemSpec)
         {
-            this.sourceItemSpec = sourceItemSpec;
+            SourceItemSpec = sourceItemSpec;
         }
 
         /// <summary>
@@ -48,9 +31,6 @@ private InvalidReferenceAssemblyNameException(SerializationInfo info, StreamingC
         /// <summary>
         /// The item spec of the item that is the source fo the problem.
         /// </summary>
-        internal string SourceItemSpec
-        {
-            get { return sourceItemSpec; }
-        }
+        internal string SourceItemSpec { get; }
     }
 }
diff --git a/src/Tasks/AssemblyDependency/NoMatchReason.cs b/src/Tasks/AssemblyDependency/NoMatchReason.cs
index 309c9371df3..27ad0d285ff 100644
--- a/src/Tasks/AssemblyDependency/NoMatchReason.cs
+++ b/src/Tasks/AssemblyDependency/NoMatchReason.cs
@@ -1,18 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Resources;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
-using System.Reflection;
-using System.IO;
-using System.Collections;
-using System.Globalization;
-using System.Diagnostics;
-using System.Runtime.InteropServices;
-using System.Text.RegularExpressions;
-
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
diff --git a/src/Tasks/AssemblyDependency/RawFilenameResolver.cs b/src/Tasks/AssemblyDependency/RawFilenameResolver.cs
index 58e7c2bb42d..f423dc0bafc 100644
--- a/src/Tasks/AssemblyDependency/RawFilenameResolver.cs
+++ b/src/Tasks/AssemblyDependency/RawFilenameResolver.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
 using System.Reflection;
 using System.Collections;
 using Microsoft.Build.Shared;
@@ -17,19 +16,16 @@ internal class RawFilenameResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        /// <param name="searchPathElement"></param>
-        /// <param name="getAssemblyName"></param>
-        /// <param name="fileExists"></param>
         public RawFilenameResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
             : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false)
         {
         }
 
-
         /// <summary>
         /// Resolve a reference to a specific file name.
         /// </summary>
         /// <param name="assemblyName">The assemblyname of the reference.</param>
+        /// <param name="sdkName"></param>
         /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
         /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
         /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
@@ -51,7 +47,6 @@ public override bool Resolve
             string hintPath,
             string assemblyFolderKey,
             ArrayList assembliesConsideredAndRejected,
-
             out string foundPath,
             out bool userRequestedSpecificFile
         )
@@ -68,21 +63,19 @@ out bool userRequestedSpecificFile
                     foundPath = rawFileNameCandidate;
                     return true;
                 }
-                else
+
+                if (assembliesConsideredAndRejected != null)
                 {
-                    if (assembliesConsideredAndRejected != null)
+                    var considered = new ResolutionSearchLocation
                     {
-                        ResolutionSearchLocation considered = null;
-                        considered = new ResolutionSearchLocation();
-                        considered.FileNameAttempted = rawFileNameCandidate;
-                        considered.SearchPath = searchPathElement;
-                        considered.Reason = NoMatchReason.NotAFileNameOnDisk;
-                        assembliesConsideredAndRejected.Add(considered);
-                    }
+                        FileNameAttempted = rawFileNameCandidate,
+                        SearchPath = searchPathElement,
+                        Reason = NoMatchReason.NotAFileNameOnDisk
+                    };
+                    assembliesConsideredAndRejected.Add(considered);
                 }
             }
 
-
             return false;
         }
     }
diff --git a/src/Tasks/AssemblyDependency/Reference.cs b/src/Tasks/AssemblyDependency/Reference.cs
index e1298d60e78..0bdd0d08d63 100644
--- a/src/Tasks/AssemblyDependency/Reference.cs
+++ b/src/Tasks/AssemblyDependency/Reference.cs
@@ -2,14 +2,15 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
 using System.Collections;
-using System.Reflection;
-using System.Diagnostics;
 using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Runtime.Versioning;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Framework;
-using System.Runtime.Versioning;
 
 namespace Microsoft.Build.Tasks
 {
@@ -23,13 +24,13 @@ sealed internal class Reference
         /// A hash table is used to remove duplicates.
         /// All source items that inspired this reference (possibly indirectly through a dependency chain).
         /// </summary>
-        private Hashtable _sourceItems = new Hashtable(StringComparer.OrdinalIgnoreCase);
+        private Dictionary<string, ITaskItem> _sourceItems = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// Hashtable of Key=Reference, Value=Irrelevent.
         /// A list of unique dependies.
         /// </summary>
-        private Hashtable _dependees = new Hashtable();
+        private HashSet<Reference> _dependees = new HashSet<Reference>();
 
         /// <summary>
         /// Hashset of Reference which depend on this reference
@@ -43,69 +44,38 @@ sealed internal class Reference
         private string[] _scatterFiles = Array.Empty<string>();
 
         /// <summary>
-        /// ArrayList of Exception.
         /// Any errors that occurred while resolving or finding dependencies on this item.
         /// </summary>
-        private ArrayList _errors = new ArrayList();
+        private List<Exception> _errors = new List<Exception>();
 
         /// <summary>
-        /// ArrayList of string.
         /// Contains any file extension that are related to this file. Pdbs and xmls are related.
         /// This is an extension string starting with "."
         /// </summary>
-        private ArrayList _relatedFileExtensions = new ArrayList();
+        private List<string> _relatedFileExtensions = new List<string>();
 
         /// <summary>
-        /// ArrayList of string.
         /// Contains satellite files for this reference.
         /// This file path is relative to the location of the reference.
         /// </summary>
-        private ArrayList _satelliteFiles = new ArrayList();
+        private List<string> _satelliteFiles = new List<string>();
 
         /// <summary>
-        /// ArrayList of string.
-        /// Contains serializaion assembly files for this reference.
+        /// Contains serialization assembly files for this reference.
         /// This file path is relative to the location of the reference.
         /// </summary>
-        private ArrayList _serializationAssemblyFiles = new ArrayList();
-
-        /// <summary>
-        /// The list of assemblies that were consider for matching but that 
-        /// didn't pan out because they didn't match exactly.
-        /// </summary>
-        private ArrayList _assembliesConsideredAndRejected = new ArrayList();
-
-        /// <summary>
-        /// The searchpath location that the reference was found at.
-        /// </summary>
-        private string _resolvedSearchPath = String.Empty;
-
-        /// <summary>
-        /// This is the reference that won against this reference in the conflict contest.
-        /// </summary>
-        private AssemblyNameExtension _conflictVictorName = null;
-
-        /// <summary>
-        /// The reason this reference lost
-        /// </summary>
-        private ConflictLossReason _conflictLossReason = ConflictLossReason.DidntLose;
+        private List<string> _serializationAssemblyFiles = new List<string>();
 
         /// <summary>
         /// AssemblyNames of references that lost collision conflicts with this reference.
         /// </summary>
-        private ArrayList _conflictVictims = new ArrayList();
+        private List<AssemblyNameExtension> _conflictVictims = new List<AssemblyNameExtension>();
 
         /// <summary>
         /// These are the versions (type UnificationVersion) that were unified from.
         /// </summary>
         private Dictionary<string, UnificationVersion> _preUnificationVersions = new Dictionary<string, UnificationVersion>(StringComparer.OrdinalIgnoreCase);
 
-        /// <summary>
-        /// If 'true' then the path that this item points to is known to be a bad image.
-        /// This item shouldn't be passed to compilers and so forth. 
-        /// </summary>
-        private bool _isBadImage = false;
-
         /// <summary>
         /// The original source item, as passed into the task that is directly associated
         /// with this reference.  This only applies to "primary" references.
@@ -133,85 +103,10 @@ sealed internal class Reference
         /// </summary>
         private string _fullPathWithoutExtension = String.Empty;
 
-        /// <summary>
-        /// Whether this assembly came from the project. If 'false' then this reference was deduced 
-        /// through the reference resolution process.
-        /// </summary>
-        private bool _isPrimary = false;
-
-        /// <summary>
-        /// Whether or not this reference will be installed on the target machine.
-        /// </summary>
-        private bool _isPrerequisite = false;
-
-        /// <summary>
-        /// Whether or not this reference is a redist root.
-        /// </summary>
-        private bool? _isRedistRoot = null;
-
-        /// <summary>
-        /// The redist name for this reference (if any).
-        /// </summary>
-        private string _redistName = null;
-
-        /// <summary>
-        /// Whether this reference should be copied to the local 'bin' dir or not and the reason this flag
-        /// was set that way.
-        /// </summary>
-        private CopyLocalState _copyLocalState = CopyLocalState.Undecided;
-
-        /// <summary>
-        /// Whether or not we still need to find dependencies for this reference.
-        /// </summary>
-        private bool _dependenciesFound = false;
-
-        /// <summary>
-        /// This is the HintPath from the source item. This is used to resolve the assembly.
-        /// </summary>
-        private string _hintPath = "";
-
         /// <summary>
         /// The list of expected extensions.
         /// </summary>
-        private ArrayList _expectedExtensions = null;
-
-        /// <summary>
-        /// Whether or not the exact specific version is required.
-        /// Note that simple names like "MySimpleAssemblyName" will need to match exactly.
-        /// That is, no version that has other information will be accepted.
-        /// </summary>
-        private bool _wantSpecificVersion = true;
-
-        /// <summary>
-        /// Whether or not the types from this reference need to be embedded into the target assembly
-        /// </summary>
-        private bool _embedInteropTypes = false;
-
-        /// <summary>
-        /// This is the key that was passed in to the reference through the &lt;AssemblyFolderKey&gt; metadata.
-        /// </summary>
-        private string _assemblyFolderKey = String.Empty;
-
-        /// <summary>
-        /// This will be true if the user requested a specific file. We know this when the file was resolved
-        /// by hintpath or if it was resolve as a raw file name for example.
-        /// </summary>
-        private bool _userRequestedSpecificFile = false;
-
-        /// <summary>
-        /// Version of the references
-        /// </summary>
-        private Version _referenceVersion = null;
-
-        /// <summary>
-        /// A set of properties which are useful to log the correct information for why this reference was not resolved.
-        /// </summary>
-        private ExclusionListProperties _exclusionListProperties = new ExclusionListProperties();
-
-        /// <summary>
-        /// Is the reference a native winMD file. This means it has a image runtime of WindowsRuntime and not CLR.
-        /// </summary>
-        private bool _winMDFile;
+        private List<string> _expectedExtensions;
 
         /// <summary>
         ///  Is the file a managed winmd file. That means it has both windows runtime and CLR in the imageruntime string.
@@ -223,12 +118,6 @@ sealed internal class Reference
         /// </summary>
         private string _imageRuntimeVersion;
 
-
-        /// <summary>
-        /// If the reference has an SDK name metadata this will contain that string.
-        /// </summary>
-        private string _sdkName = String.Empty;
-
         /// <summary>
         /// Set containing the names the reference was remapped from
         /// </summary>
@@ -249,11 +138,6 @@ sealed internal class Reference
         /// </summary>
         private GetAssemblyRuntimeVersion _getRuntimeVersion;
 
-        /// <summary>
-        /// The frameworkName the reference was built against
-        /// </summary>
-        private FrameworkName _frameworkName;
-
         internal Reference(IsWinMDFile isWinMDFile, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion)
         {
             _isWinMDFile = isWinMDFile;
@@ -266,7 +150,7 @@ internal Reference(IsWinMDFile isWinMDFile, FileExists fileExists, GetAssemblyRu
         /// </summary>
         internal void AddSourceItem(ITaskItem sourceItem)
         {
-            bool sourceItemAlreadyInList = _sourceItems.Contains(sourceItem.ItemSpec);
+            bool sourceItemAlreadyInList = _sourceItems.ContainsKey(sourceItem.ItemSpec);
             if (!sourceItemAlreadyInList)
             {
                 _sourceItems[sourceItem.ItemSpec] = sourceItem;
@@ -285,7 +169,6 @@ internal void AddSourceItems(IEnumerable sourceItemsToAdd)
             }
         }
 
-
         /// <summary>
         /// We have had our source item list updated, we need to propagate this change to any of our dependencies so they have the new information.
         /// </summary>
@@ -306,7 +189,7 @@ internal void PropagateSourceItems(ITaskItem sourceItem)
         /// </summary>
         internal ICollection GetSourceItems()
         {
-            return (ICollection)_sourceItems.Values;
+            return _sourceItems.Values;
         }
 
         /// <summary>
@@ -329,16 +212,16 @@ internal void AddDependee(Reference dependee)
 
             dependee.AddDependency(this);
 
-            if (_dependees[dependee] == null)
+            if (!_dependees.Contains(dependee))
             {
-                _dependees[dependee] = String.Empty;
+                _dependees.Add(dependee);
 
                 // When a new dependee is added, this is a new place where a reference might be resolved.
                 // Reset this item so it will be re-resolved if possible.
                 if (IsUnresolvable)
                 {
-                    _errors = new ArrayList();
-                    _assembliesConsideredAndRejected = new ArrayList();
+                    _errors = new List<Exception>();
+                    AssembliesConsideredAndRejected = new ArrayList();
                 }
             }
         }
@@ -346,7 +229,6 @@ internal void AddDependee(Reference dependee)
         /// <summary>
         /// A dependee may be removed because it or its dependee's are in the black list
         /// </summary>
-        /// <param name="dependeeToRemove"></param>
         internal void RemoveDependee(Reference dependeeToRemove)
         {
             _dependees.Remove(dependeeToRemove);
@@ -367,7 +249,7 @@ internal void RemoveDependency(Reference dependencyToRemove)
         /// </summary>
         internal ICollection GetDependees()
         {
-            return (ICollection)_dependees.Keys;
+            return _dependees.ToList();
         }
 
         /// <summary>
@@ -402,7 +284,7 @@ internal void SetExecutableExtension(string extension)
         {
             if (_expectedExtensions == null)
             {
-                _expectedExtensions = new ArrayList();
+                _expectedExtensions = new List<string>();
             }
             else
             {
@@ -425,53 +307,31 @@ internal string[] GetExecutableExtensions(string[] allowedAssemblyExtensions)
                 // Use the default.
                 return allowedAssemblyExtensions;
             }
-            return (string[])_expectedExtensions.ToArray(typeof(string));
+            return _expectedExtensions.ToArray();
         }
 
         /// <summary>
         /// Whether the name needs to match exactly or just the simple name part needs to match.
         /// </summary>
         /// <value></value>
-        internal bool WantSpecificVersion
-        {
-            get { return _wantSpecificVersion; }
-        }
+        internal bool WantSpecificVersion { get; private set; } = true;
 
         /// <summary>
         /// Whether types need to be embedded into the target assembly
         /// </summary>
         /// <value></value>
-        internal bool EmbedInteropTypes
-        {
-            get { return _embedInteropTypes; }
-            set { _embedInteropTypes = value; }
-        }
+        internal bool EmbedInteropTypes { get; set; } = false;
 
         /// <summary>
         /// This will be true if the user requested a specific file. We know this when the file was resolved
         /// by hintpath or if it was resolve as a raw file name for example.
         /// </summary>
-        internal bool UserRequestedSpecificFile
-        {
-            get { return _userRequestedSpecificFile; }
-            set { _userRequestedSpecificFile = value; }
-        }
+        internal bool UserRequestedSpecificFile { get; set; } = false;
 
         /// <summary>
         /// The version number of this reference
         /// </summary>
-        internal Version ReferenceVersion
-        {
-            get
-            {
-                return _referenceVersion;
-            }
-
-            set
-            {
-                _referenceVersion = value;
-            }
-        }
+        internal Version ReferenceVersion { get; set; } = null;
 
         /// <summary>
         /// True if the assembly was found to be in the GAC.
@@ -489,20 +349,14 @@ internal bool ResolvedFromGac
         {
             get
             {
-                return string.Equals(_resolvedSearchPath, AssemblyResolutionConstants.gacSentinel, StringComparison.OrdinalIgnoreCase);
+                return string.Equals(ResolvedSearchPath, AssemblyResolutionConstants.gacSentinel, StringComparison.OrdinalIgnoreCase);
             }
         }
 
         /// <summary>
         /// Set of properties for this reference used to log why this reference could not be resolved.
         /// </summary>
-        internal ExclusionListProperties ExclusionListLoggingProperties
-        {
-            get
-            {
-                return _exclusionListProperties;
-            }
-        }
+        internal ExclusionListProperties ExclusionListLoggingProperties { get; } = new ExclusionListProperties();
 
         /// <summary>
         /// Determines if a given reference or its parent primary references have specific version metadata set to true.
@@ -517,7 +371,7 @@ internal bool CheckForSpecificVersionMetadataOnParentsReference(bool anyParentHa
             // this saves us from having to read the metadata from our item again.
             if (IsPrimary)
             {
-                hasSpecificVersionMetadata = _wantSpecificVersion;
+                hasSpecificVersionMetadata = WantSpecificVersion;
             }
             else
             {
@@ -546,7 +400,7 @@ internal void AddError(Exception e)
         {
             if (e is BadImageReferenceException)
             {
-                _isBadImage = true;
+                IsBadImage = true;
             }
             _errors.Add(e);
         }
@@ -557,7 +411,7 @@ internal void AddError(Exception e)
         /// <returns>The collection of resolution errors.</returns>
         internal ICollection GetErrors()
         {
-            return (ICollection)_errors;
+            return _errors;
         }
 
         /// <summary>
@@ -565,7 +419,7 @@ internal ICollection GetErrors()
         /// Related files always live in the same directory as the reference.
         /// Examples include, MyAssembly.pdb and MyAssembly.xml
         /// </summary>
-        /// <param name="filename">This is the filename extension.</param>
+        /// <param name="filenameExtension">This is the filename extension.</param>
         internal void AddRelatedFileExtension(string filenameExtension)
         {
 #if _DEBUG
@@ -580,10 +434,9 @@ internal void AddRelatedFileExtension(string filenameExtension)
         /// <returns>The collection of related file extensions.</returns>
         internal ICollection GetRelatedFileExtensions()
         {
-            return (ICollection)_relatedFileExtensions;
+            return _relatedFileExtensions;
         }
 
-
         /// <summary>
         /// Add a new satellite file
         /// </summary>
@@ -614,7 +467,7 @@ internal void AddSerializationAssemblyFile(string filename)
         /// <returns>The collection of satellit files.</returns>
         internal ICollection GetSatelliteFiles()
         {
-            return (ICollection)_satelliteFiles;
+            return _satelliteFiles;
         }
 
         /// <summary>
@@ -623,7 +476,7 @@ internal ICollection GetSatelliteFiles()
         /// <returns>The collection of serialization assembly files.</returns>
         internal ICollection GetSerializationAssemblyFiles()
         {
-            return (ICollection)_serializationAssemblyFiles;
+            return _serializationAssemblyFiles;
         }
 
         /// <summary>
@@ -646,19 +499,19 @@ internal string FullPath
                     if (_fullPath == null || _fullPath.Length == 0)
                     {
                         _scatterFiles = Array.Empty<string>();
-                        _satelliteFiles = new ArrayList();
-                        _serializationAssemblyFiles = new ArrayList();
-                        _assembliesConsideredAndRejected = new ArrayList();
-                        _resolvedSearchPath = String.Empty;
+                        _satelliteFiles = new List<string>();
+                        _serializationAssemblyFiles = new List<string>();
+                        AssembliesConsideredAndRejected = new ArrayList();
+                        ResolvedSearchPath = String.Empty;
                         _preUnificationVersions = new Dictionary<string, UnificationVersion>(StringComparer.OrdinalIgnoreCase);
-                        _isBadImage = false;
-                        _dependenciesFound = false;
-                        _userRequestedSpecificFile = false;
-                        _winMDFile = false;
+                        IsBadImage = false;
+                        DependenciesFound = false;
+                        UserRequestedSpecificFile = false;
+                        IsWinMDFile = false;
                     }
                     else if (NativeMethodsShared.IsWindows)
                     {
-                        _winMDFile = _isWinMDFile(_fullPath, _getRuntimeVersion, _fileExists, out _imageRuntimeVersion, out _isManagedWinMDFile);
+                        IsWinMDFile = _isWinMDFile(_fullPath, _getRuntimeVersion, _fileExists, out _imageRuntimeVersion, out _isManagedWinMDFile);
                     }
                 }
             }
@@ -667,7 +520,6 @@ internal string FullPath
         /// <summary>
         /// The directory that this assembly lives in.
         /// </summary>
-        /// <value></value>
         internal string DirectoryName
         {
             get
@@ -703,7 +555,6 @@ internal string FileNameWithoutExtension
         /// <summary>
         /// The full path to the assembly but without an extension on the file namee
         /// </summary>
-        /// <value></value>
         internal string FullPathWithoutExtension
         {
             get
@@ -721,59 +572,35 @@ internal string FullPathWithoutExtension
         /// This is the HintPath from the source item. This is used to resolve the assembly.
         /// </summary>
         /// <value>The hint path to this assembly.</value>
-        internal string HintPath
-        {
-            get { return _hintPath; }
-            set { _hintPath = value; }
-        }
+        internal string HintPath { get; set; } = "";
 
         /// <summary>
         /// This is the key that was passed in to the reference through the &lt;AssemblyFolderKey&gt; metadata.
         /// </summary>
         /// <value>The &lt;AssemblyFolderKey&gt; value.</value>
-        internal string AssemblyFolderKey
-        {
-            get { return _assemblyFolderKey; }
-            set { _assemblyFolderKey = value; }
-        }
+        internal string AssemblyFolderKey { get; set; } = String.Empty;
 
         /// <summary>
         /// Whether this assembly came from the project. If 'false' then this reference was deduced 
         /// through the reference resolution process.
         /// </summary>
         /// <value>'true' if this reference is a primary assembly.</value>
-        internal bool IsPrimary
-        {
-            get { return _isPrimary; }
-        }
+        internal bool IsPrimary { get; private set; } = false;
 
         /// <summary>
         /// Whether or not this reference will be installed on the target machine.
         /// </summary>
-        internal bool IsPrerequisite
-        {
-            set { _isPrerequisite = value; }
-            get { return _isPrerequisite; }
-        }
+        internal bool IsPrerequisite { set; get; } = false;
 
         /// <summary>
         /// Whether or not this reference is a redist root.
         /// </summary>
-        internal bool? IsRedistRoot
-        {
-            set { _isRedistRoot = value; }
-            get { return _isRedistRoot; }
-        }
+        internal bool? IsRedistRoot { set; get; } = null;
 
         /// <summary>
         /// The redist name for this reference (if any)
         /// </summary>
-        internal string RedistName
-        {
-            set { _redistName = value; }
-            get { return _redistName; }
-        }
-
+        internal string RedistName { set; get; } = null;
 
         /// <summary>
         /// The original source item, as passed into the task that is directly associated
@@ -784,9 +611,9 @@ internal ITaskItem PrimarySourceItem
             get
             {
                 ErrorUtilities.VerifyThrow(
-                    !(_isPrimary && _primarySourceItem == null), "A primary reference must have a primary source item.");
+                    !(IsPrimary && _primarySourceItem == null), "A primary reference must have a primary source item.");
                 ErrorUtilities.VerifyThrow(
-                    (_isPrimary || _primarySourceItem == null), "Only a primary reference can have a primary source item.");
+                    (IsPrimary || _primarySourceItem == null), "Only a primary reference can have a primary source item.");
 
                 return _primarySourceItem;
             }
@@ -797,10 +624,7 @@ internal ITaskItem PrimarySourceItem
         /// This item shouldn't be passed to compilers and so forth. 
         /// </summary>
         /// <value>'true' if this reference points to a bad image.</value>
-        internal bool IsBadImage
-        {
-            get { return _isBadImage; }
-        }
+        internal bool IsBadImage { get; private set; } = false;
 
         /// <summary>
         ///  If true, then this item conflicted with another item and lost.
@@ -816,7 +640,6 @@ internal bool IsConflictVictim
         /// <summary>
         /// Add a conflict victim to this reference
         /// </summary>
-        /// <param name="victim"></param>
         internal void AddConflictVictim(AssemblyNameExtension victim)
         {
             _conflictVictims.Add(victim);
@@ -827,35 +650,23 @@ internal void AddConflictVictim(AssemblyNameExtension victim)
         /// </summary>
         internal AssemblyNameExtension[] GetConflictVictims()
         {
-            return (AssemblyNameExtension[])_conflictVictims.ToArray(typeof(AssemblyNameExtension));
+            return _conflictVictims.ToArray();
         }
 
         /// <summary>
         ///  The name of the assembly that won over this reference.
         /// </summary>
-        internal AssemblyNameExtension ConflictVictorName
-        {
-            get { return _conflictVictorName; }
-            set { _conflictVictorName = value; }
-        }
+        internal AssemblyNameExtension ConflictVictorName { get; set; } = null;
 
         /// <summary>
         ///  The reason why this reference lost to another reference.
         /// </summary>
-        internal ConflictLossReason ConflictLossExplanation
-        {
-            get { return _conflictLossReason; }
-            set { _conflictLossReason = value; }
-        }
+        internal ConflictLossReason ConflictLossExplanation { get; set; } = ConflictLossReason.DidntLose;
 
         /// <summary>
         /// Is the file a WinMDFile.
         /// </summary>
-        internal bool IsWinMDFile
-        {
-            get { return _winMDFile; }
-            set { _winMDFile = value; }
-        }
+        internal bool IsWinMDFile { get; set; }
 
         /// <summary>
         /// Is the file a Managed.
@@ -943,10 +754,7 @@ internal bool IsUnified
         /// was set that way.
         /// </summary>
         /// <value>The current copy-local state.</value>
-        internal CopyLocalState CopyLocal
-        {
-            get { return _copyLocalState; }
-        }
+        internal CopyLocalState CopyLocal { get; private set; } = CopyLocalState.Undecided;
 
         /// <summary>
         /// Whether the reference should be CopyLocal. For the reason, see CopyLocalState.
@@ -956,7 +764,7 @@ internal bool IsCopyLocal
         {
             get
             {
-                return CopyLocalStateUtility.IsCopyLocal(_copyLocalState);
+                return CopyLocalStateUtility.IsCopyLocal(CopyLocal);
             }
         }
 
@@ -987,70 +795,43 @@ internal bool IsUnresolvable
         /// <summary>
         /// Whether or not we still need to find dependencies for this reference.
         /// </summary>
-        internal bool DependenciesFound
-        {
-            get { return _dependenciesFound; }
-            set { _dependenciesFound = value; }
-        }
+        internal bool DependenciesFound { get; set; } = false;
 
         /// <summary>
         /// If the reference has an SDK name metadata this will contain that string.
         /// </summary>
-        internal string SDKName
-        {
-            get
-            {
-                return _sdkName;
-            }
-        }
+        internal string SDKName { get; private set; } = String.Empty;
 
         /// <summary>
         /// Add some records to the table of assemblies that were considered and then rejected.
         /// </summary>
         internal void AddAssembliesConsideredAndRejected(ArrayList assembliesConsideredAndRejectedToAdd)
         {
-            _assembliesConsideredAndRejected.AddRange(assembliesConsideredAndRejectedToAdd);
+            AssembliesConsideredAndRejected.AddRange(assembliesConsideredAndRejectedToAdd);
         }
 
         /// <summary>
         /// Returns a collection of strings. Each string is the full path to an assembly that was 
         /// considered for resolution but then rejected because it wasn't a complete match.
         /// </summary>
-        internal ArrayList AssembliesConsideredAndRejected
-        {
-            get { return _assembliesConsideredAndRejected; }
-        }
+        internal ArrayList AssembliesConsideredAndRejected { get; private set; } = new ArrayList();
 
         /// <summary>
         /// The searchpath location that the reference was found at.
         /// </summary>
-        internal string ResolvedSearchPath
-        {
-            get { return _resolvedSearchPath; }
-            set { _resolvedSearchPath = value; }
-        }
+        internal string ResolvedSearchPath { get; set; } = String.Empty;
 
         /// <summary>
         /// FrameworkName attribute on this reference
         /// </summary>
-        internal FrameworkName FrameworkNameAttribute
-        {
-            get { return _frameworkName; }
-            set
-            {
-                _frameworkName = value;
-            }
-        }
+        internal FrameworkName FrameworkNameAttribute { get; set; }
 
         /// <summary>
         /// Indicates that the reference is primary and has ExternallyResolved=true metadata to denote that 
         /// it was resolved by an external system (commonly from nuget). Such a system has already provided a
         /// resolved closure as primary references and therefore we can skip the expensive closure walk.
-        internal bool ExternallyResolved
-        {
-            get;
-            private set;
-        }
+        /// </summary>
+        internal bool ExternallyResolved { get; private set; }
 
         /// <summary>
         /// Make this reference an assembly that is a dependency of 'sourceReference'
@@ -1063,16 +844,16 @@ internal bool ExternallyResolved
         /// <param name="sourceReference">The source reference that this reference will be dependent on</param>
         internal void MakeDependentAssemblyReference(Reference sourceReference)
         {
-            _copyLocalState = CopyLocalState.Undecided;
+            CopyLocal = CopyLocalState.Undecided;
 
             // This is a true dependency, so its not primary.
-            _isPrimary = false;
+            IsPrimary = false;
 
             // This is an assembly file, so we'll need to find dependencies later.
             DependenciesFound = false;
 
             // Dependencies must always be specific version.
-            _wantSpecificVersion = true;
+            WantSpecificVersion = true;
 
             // Add source items from the original item.
             AddSourceItems(sourceReference.GetSourceItems());
@@ -1086,7 +867,7 @@ internal void MakeDependentAssemblyReference(Reference sourceReference)
         /// This is a refrence that is an assembly and is primary.
         /// </summary>
         /// <param name="sourceItem">The source item.</param>
-        /// <param name="wantSpecificVersion">Whether the version needs to match exactly or loosely.</param>
+        /// <param name="wantSpecificVersionValue">Whether the version needs to match exactly or loosely.</param>
         /// <param name="executableExtension">The filename extension that the resulting assembly must have.</param>
         internal void MakePrimaryAssemblyReference
         (
@@ -1095,15 +876,15 @@ internal void MakePrimaryAssemblyReference
             string executableExtension
         )
         {
-            _copyLocalState = CopyLocalState.Undecided;
+            CopyLocal = CopyLocalState.Undecided;
 
             // This is a primary reference.
-            _isPrimary = true;
+            IsPrimary = true;
 
             // This is the source item (from the list passed into the task) that
             // originally created this reference.
             _primarySourceItem = sourceItem;
-            _sdkName = sourceItem.GetMetadata("SDKName");
+            SDKName = sourceItem.GetMetadata("SDKName");
 
             if (executableExtension != null && executableExtension.Length > 0)
             {
@@ -1112,7 +893,7 @@ string executableExtension
             }
 
             // The specific version indicator.
-            _wantSpecificVersion = wantSpecificVersionValue;
+            WantSpecificVersion = wantSpecificVersionValue;
 
             // This is an assembly file, so we'll need to find dependencies later.
             DependenciesFound = false;
@@ -1183,20 +964,20 @@ ReferenceTable referenceTable
             // If this item was unresolvable, then copy-local is false.
             if (IsUnresolvable)
             {
-                _copyLocalState = CopyLocalState.NoBecauseUnresolved;
+                CopyLocal = CopyLocalState.NoBecauseUnresolved;
                 return;
             }
 
             if (EmbedInteropTypes)
             {
-                _copyLocalState = CopyLocalState.NoBecauseEmbedded;
+                CopyLocal = CopyLocalState.NoBecauseEmbedded;
                 return;
             }
 
             // If this item was a conflict victim, then it should not be copy-local.
             if (IsConflictVictim)
             {
-                _copyLocalState = CopyLocalState.NoBecauseConflictVictim;
+                CopyLocal = CopyLocalState.NoBecauseConflictVictim;
                 return;
             }
 
@@ -1213,7 +994,7 @@ out found
 
                 if (found)
                 {
-                    _copyLocalState = result
+                    CopyLocal = result
                         ? CopyLocalState.YesBecauseReferenceItemHadMetadata
                         : CopyLocalState.NoBecauseReferenceItemHadMetadata;
                     return;
@@ -1225,12 +1006,12 @@ out found
                 // has Private=false, then this dependency should false too.
                 bool privateTrueFound = false;
                 bool privateFalseFound = false;
-                foreach (DictionaryEntry entry in _sourceItems)
+                foreach (ITaskItem item in _sourceItems.Values)
                 {
                     bool found;
                     bool result = MetadataConversionUtilities.TryConvertItemMetadataToBool
                         (
-                            (ITaskItem)entry.Value,
+                            item,
                             ItemMetadataNames.privateMetadata,
                             out found
                         );
@@ -1254,7 +1035,7 @@ out found
 
                 if (privateFalseFound && !privateTrueFound)
                 {
-                    _copyLocalState = CopyLocalState.NoBecauseReferenceItemHadMetadata;
+                    CopyLocal = CopyLocalState.NoBecauseReferenceItemHadMetadata;
                     return;
                 }
             }
@@ -1262,14 +1043,14 @@ out found
             // If the item was determined to be an prereq assembly.
             if (IsPrerequisite && !UserRequestedSpecificFile)
             {
-                _copyLocalState = CopyLocalState.NoBecausePrerequisite;
+                CopyLocal = CopyLocalState.NoBecausePrerequisite;
                 return;
             }
 
             // Items in the frameworks directory shouldn't be copy-local
             if (IsFrameworkFile(_fullPath, frameworkPaths))
             {
-                _copyLocalState = CopyLocalState.NoBecauseFrameworkFile;
+                CopyLocal = CopyLocalState.NoBecauseFrameworkFile;
                 return;
             }
 
@@ -1280,9 +1061,9 @@ out found
                 bool foundSourceItemNotInGac = false;
 
                 // Go through all of the parent source items and check to see if they were found in the GAC
-                foreach (DictionaryEntry entry in _sourceItems)
+                foreach (string key in _sourceItems.Keys)
                 {
-                    AssemblyNameExtension primaryAssemblyName = referenceTable.GetReferenceFromItemSpec((string)entry.Key);
+                    AssemblyNameExtension primaryAssemblyName = referenceTable.GetReferenceFromItemSpec(key);
                     Reference primaryReference = referenceTable.GetReference(primaryAssemblyName);
 
                     if (doNotCopyLocalIfInGac)
@@ -1312,7 +1093,7 @@ out found
                 // All parent source items were found in the GAC.
                 if (!foundSourceItemNotInGac)
                 {
-                    _copyLocalState = CopyLocalState.NoBecauseParentReferencesFoundInGAC;
+                    CopyLocal = CopyLocalState.NoBecauseParentReferencesFoundInGAC;
                     return;
                 }
             }
@@ -1327,19 +1108,19 @@ out found
 
                 if (FoundInGac.Value)
                 {
-                    _copyLocalState = CopyLocalState.NoBecauseReferenceFoundInGAC;
+                    CopyLocal = CopyLocalState.NoBecauseReferenceFoundInGAC;
                     return;
                 }
             }
 
             if (ResolvedFromGac)
             {
-                _copyLocalState = CopyLocalState.NoBecauseReferenceResolvedFromGAC;
+                CopyLocal = CopyLocalState.NoBecauseReferenceResolvedFromGAC;
                 return;
             }
 
             //  It was resolved locally, so copy it.
-            _copyLocalState = CopyLocalState.YesBecauseOfHeuristic;
+            CopyLocal = CopyLocalState.YesBecauseOfHeuristic;
         }
 
         /// <summary>
@@ -1360,63 +1141,25 @@ public override string ToString()
         /// </summary>
         internal class ExclusionListProperties
         {
-            #region Fields
-            /// <summary>
-            /// What is the highest version of an assembly found in the current redist list for the targeted framework
-            /// </summary>
-            private Version _highestVersionInRedist;
-
-            /// <summary>
-            /// Delegate which will log the reason the assembly was not resolved
-            /// </summary>
-            private ReferenceTable.LogExclusionReason _exclusionReasonLogDelegate;
-
-            /// <summary>
-            /// What is the target framework moniker of the highest redist list on the system.
-            /// </summary>
-            private string _highestRedistListMonkier;
-
-            /// <summary>
-            /// Is this reference in an exclusion list
-            /// </summary>
-            private bool _isInExclusionList;
-            #endregion
-
             /// <summary>
             /// Is this reference in an exclusion list
             /// </summary>
-            internal bool IsInExclusionList
-            {
-                get { return _isInExclusionList; }
-                set { _isInExclusionList = value; }
-            }
+            internal bool IsInExclusionList { get; set; }
 
             /// <summary>
             /// What is the highest version of this assembly in the current redist list
             /// </summary>
-            internal Version HighestVersionInRedist
-            {
-                get { return _highestVersionInRedist; }
-                set { _highestVersionInRedist = value; }
-            }
+            internal Version HighestVersionInRedist { get; set; }
 
             /// <summary>
             /// What is the highest versioned redist list on the machine
             /// </summary>
-            internal string HighestRedistListMonkier
-            {
-                get { return _highestRedistListMonkier; }
-                set { _highestRedistListMonkier = value; }
-            }
+            internal string HighestRedistListMonkier { get; set; }
 
             /// <summary>
             /// Delegate which logs the reason for not resolving a reference
             /// </summary>
-            internal Microsoft.Build.Tasks.ReferenceTable.LogExclusionReason ExclusionReasonLogDelegate
-            {
-                get { return _exclusionReasonLogDelegate; }
-                set { _exclusionReasonLogDelegate = value; }
-            }
+            internal ReferenceTable.LogExclusionReason ExclusionReasonLogDelegate { get; set; }
         }
     }
 }
diff --git a/src/Tasks/AssemblyDependency/ReferenceResolutionException.cs b/src/Tasks/AssemblyDependency/ReferenceResolutionException.cs
index 84533877348..13c8424b7fe 100644
--- a/src/Tasks/AssemblyDependency/ReferenceResolutionException.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceResolutionException.cs
@@ -2,14 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
-using System.Collections;
-using System.Globalization;
-using System.Runtime.InteropServices;
-using System.Diagnostics;
-using System.Reflection;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 using System.Runtime.Serialization;
 
 namespace Microsoft.Build.Tasks
@@ -20,13 +12,6 @@ namespace Microsoft.Build.Tasks
     [Serializable]
     internal sealed class ReferenceResolutionException : Exception
     {
-        /// <summary>
-        /// Don't allow default construction.
-        /// </summary>
-        private ReferenceResolutionException()
-        {
-        }
-
         /// <summary>
         /// Construct
         /// </summary>
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 9f7cee72bc6..dcd79313b6e 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -25,7 +25,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// A table of references.
     /// </summary>
-    sealed internal class ReferenceTable
+    internal sealed class ReferenceTable
     {
         /// <summary>version 4.0</summary>
         private static readonly Version s_targetFrameworkVersion_40 = new Version("4.0");
@@ -34,137 +34,115 @@ sealed internal class ReferenceTable
         /// A mapping of a framework identifier to the most current redist list on the system based on the target framework identifier on the moniker.
         /// This is used to determine if an assembly is in a redist list for the framework targeted by the moniker.
         /// </summary>
-        private static Dictionary<string, Tuple<RedistList, string>> s_monikerToHighestRedistList = new Dictionary<string, Tuple<RedistList, string>>(StringComparer.OrdinalIgnoreCase);
-
-        /// <summary>
-        /// The table of references. 
-        ///   Key is assemblyName; 
-        ///   Value is Reference.
-        /// </summary>
-        private Dictionary<AssemblyNameExtension, Reference> _references = new Dictionary<AssemblyNameExtension, Reference>(AssemblyNameComparer.GenericComparer);
+        private static readonly Dictionary<string, Tuple<RedistList, string>> s_monikerToHighestRedistList = new Dictionary<string, Tuple<RedistList, string>>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// Reference simple names that were resolved by an external entity to RAR.
         /// </summary>
-        private HashSet<string> _externallyResolvedPrimaryReferences = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+        private readonly HashSet<string> _externallyResolvedPrimaryReferences = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>The table of remapped assemblies. Used for Unification.</summary>
         private DependentAssembly[] _remappedAssemblies = Array.Empty<DependentAssembly>();
         /// <summary>If true, then search for dependencies.</summary>
-        private bool _findDependencies = true;
+        private readonly bool _findDependencies;
         /// <summary>
         ///  Should version be ignored for framework primary references
         /// </summary>
-        private bool _ignoreVersionForFrameworkReferences = false;
+        private readonly bool _ignoreVersionForFrameworkReferences;
         /// <summary>If true, then search for satellite files.</summary>
-        private bool _findSatellites = true;
+        private readonly bool _findSatellites;
         /// <summary>If true, then search for serialization assembly files.</summary>
-        private bool _findSerializationAssemblies = true;
+        private readonly bool _findSerializationAssemblies;
         /// <summary>If true, then search for related files.</summary>
-        private bool _findRelatedFiles = true;
+        private readonly bool _findRelatedFiles;
         /// <summary>
         /// If true, then force framework assembly version check against the target framework version
         /// If false, the default behavior is to disable version checks for target framework versions 4.5 and above.
         /// </summary>
-        private bool _checkAssemblyVersionAgainstTargetFrameworkVersion = false;
+        private readonly bool _checkAssemblyVersionAgainstTargetFrameworkVersion;
 
         /// <summary>Path to the FX.</summary>
-        private string[] _frameworkPaths;
+        private readonly string[] _frameworkPaths;
         /// <summary>The allowed assembly extensions.</summary>
-        private string[] _allowedAssemblyExtensions;
+        private readonly string[] _allowedAssemblyExtensions;
         /// <summary>These are companion files that typically travel with assemblies</summary>
-        private string[] _relatedFileExtensions;
+        private readonly string[] _relatedFileExtensions;
         /// <summary>
         /// Locations where sdks are installed. K:SDKName v: Resolved Reference item
         /// </summary>
-        private Dictionary<string, ITaskItem> _resolvedSDKReferences;
+        private readonly Dictionary<string, ITaskItem> _resolvedSDKReferences;
         /// <summary>Path to installed assembly XML tables.</summary>
-        private InstalledAssemblies _installedAssemblies;
+        private readonly InstalledAssemblies _installedAssemblies;
         /// <summary>Like x86 or IA64\AMD64, the processor architecture being targetted.</summary>
-        private SystemProcessorArchitecture _targetProcessorArchitecture;
+        private readonly SystemProcessorArchitecture _targetProcessorArchitecture;
         /// <summary>Delegate used for checking for the existence of a file.</summary>
-        private FileExists _fileExists;
+        private readonly FileExists _fileExists;
         /// <summary>Delegate used for checking for the existence of a directory.</summary>
-        private DirectoryExists _directoryExists;
+        private readonly DirectoryExists _directoryExists;
         /// <summary>Delegate used for getting directories.</summary>
-        private GetDirectories _getDirectories;
+        private readonly GetDirectories _getDirectories;
         /// <summary>Delegate used for getting assembly names.</summary>
-        private GetAssemblyName _getAssemblyName;
+        private readonly GetAssemblyName _getAssemblyName;
         /// <summary>Delegate used for finding dependencies of a file.</summary>
-        private GetAssemblyMetadata _getAssemblyMetadata;
+        private readonly GetAssemblyMetadata _getAssemblyMetadata;
         /// <summary>Delegate used to get the image runtime version of a file</summary>
-        private GetAssemblyRuntimeVersion _getRuntimeVersion;
+        private readonly GetAssemblyRuntimeVersion _getRuntimeVersion;
 #if FEATURE_WIN32_REGISTRY
         /// <summary> Delegate to get the base registry key for AssemblyFoldersEx</summary>
         private OpenBaseKey _openBaseKey;
 #endif
         /// <summary>Version of the runtime we are targeting</summary>
-        private Version _targetedRuntimeVersion = null;
+        private readonly Version _targetedRuntimeVersion;
 
         /// <summary>
         /// Delegate used to get the machineType from the PE header of the dll.
         /// </summary>
-        private ReadMachineTypeFromPEHeader _readMachineTypeFromPEHeader;
+        private readonly ReadMachineTypeFromPEHeader _readMachineTypeFromPEHeader;
 
         /// <summary>
         /// Is the file a winMD file
         /// </summary>
-        private IsWinMDFile _isWinMDFile;
+        private readonly IsWinMDFile _isWinMDFile;
 
         /// <summary>version of the framework targeted by this project</summary>
-        private Version _projectTargetFramework;
+        private readonly Version _projectTargetFramework;
 
         /// <summary>
         /// Target framework moniker we are targeting.
         /// </summary>
-        private FrameworkNameVersioning _targetFrameworkMoniker;
-
-        /// <summary>
-        /// Searchpaths compiled into an array of resolvers.
-        /// </summary>
-        private Resolver[] _compiledSearchPaths;
+        private readonly FrameworkNameVersioning _targetFrameworkMoniker;
 
         /// <summary>
         /// Logging helper to allow the logging of meessages from the Reference Table
         /// </summary>
-        private TaskLoggingHelper _log;
+        private readonly TaskLoggingHelper _log;
 
         /// <summary>
         /// List of framework directories which are the highest on the machine
         /// </summary>
-        private string[] _latestTargetFrameworkDirectories;
-
-        /// <summary>
-        /// List of assemblies which have been excluded from being referenced.
-        /// </summary>
-        private List<string> _listOfExcludedAssemblies = null;
+        private readonly string[] _latestTargetFrameworkDirectories;
 
         /// <summary>
         /// Should dependencies be set to copy local if the parent reference is in the GAC
         /// </summary>
-        private bool _copyLocalDependenciesWhenParentReferenceInGac;
+        private readonly bool _copyLocalDependenciesWhenParentReferenceInGac;
 
-        private bool _doNotCopyLocalIfInGac;
+        private readonly bool _doNotCopyLocalIfInGac;
 
         /// <summary>
         ///  Shoould the framework attribute version mismatch be ignored.
         /// </summary>
-        private bool _ignoreFrameworkAttributeVersionMismatch;
+        private readonly bool _ignoreFrameworkAttributeVersionMismatch;
 
         /// <summary>
         /// Delegate to determine if an assembly name is in the GAC.
         /// </summary>
-        private GetAssemblyPathInGac _getAssemblyPathInGac;
-
-        /// <summary>
-        /// Build engine 
-        /// </summary>
-        private IBuildEngine _buildEngine;
+        private readonly GetAssemblyPathInGac _getAssemblyPathInGac;
 
         /// <summary>
         /// Should a warning or error be emitted on architecture mismatch
         /// </summary>
-        private WarnOrErrorOnTargetArchitectureMismatchBehavior _warnOrErrorOnTargetArchitectureMismatch = WarnOrErrorOnTargetArchitectureMismatchBehavior.Warning;
+        private readonly WarnOrErrorOnTargetArchitectureMismatchBehavior _warnOrErrorOnTargetArchitectureMismatch = WarnOrErrorOnTargetArchitectureMismatchBehavior.Warning;
 
         private readonly ConcurrentDictionary<string, AssemblyMetadata> _assemblyMetadataCache;
 
@@ -185,11 +163,13 @@ sealed internal class ReferenceTable
         /// <summary>
         /// Construct.
         /// </summary>
+        /// <param name="buildEngine"></param>
         /// <param name="findDependencies">If true, then search for dependencies.</param>
         /// <param name="findSatellites">If true, then search for satellite files.</param>
         /// <param name="findSerializationAssemblies">If true, then search for serialization assembly files.</param>
         /// <param name="findRelatedFiles">If true, then search for related files.</param>
         /// <param name="searchPaths">Paths to search for dependent assemblies on.</param>
+        /// <param name="relatedFileExtensions"></param>
         /// <param name="candidateAssemblyFiles">List of literal assembly file names to be considered when SearchPaths has {CandidateAssemblyFiles}.</param>
         /// <param name="resolvedSDKItems">Resolved sdk items</param>
         /// <param name="frameworkPaths">Path to the FX.</param>
@@ -202,7 +182,24 @@ sealed internal class ReferenceTable
         /// <param name="getAssemblyMetadata">Delegate used for finding dependencies of a file.</param>
         /// <param name="getRegistrySubKeyNames">Used to get registry subkey names.</param>
         /// <param name="getRegistrySubKeyDefaultValue">Used to get registry default values.</param>
+        /// <param name="unresolveFrameworkAssembliesFromHigherFrameworks"></param>
         /// <param name="assemblyMetadataCache">Cache of metadata already read from paths.</param>
+        /// <param name="allowedAssemblyExtensions"></param>
+        /// <param name="openBaseKey"></param>
+        /// <param name="getRuntimeVersion"></param>
+        /// <param name="targetedRuntimeVersion"></param>
+        /// <param name="projectTargetFramework"></param>
+        /// <param name="targetFrameworkMoniker"></param>
+        /// <param name="log"></param>
+        /// <param name="latestTargetFrameworkDirectories"></param>
+        /// <param name="copyLocalDependenciesWhenParentReferenceInGac"></param>
+        /// <param name="doNotCopyLocalIfInGac"></param>
+        /// <param name="getAssemblyPathInGac"></param>
+        /// <param name="isWinMDFile"></param>
+        /// <param name="ignoreVersionForFrameworkReferences"></param>
+        /// <param name="readMachineTypeFromPEHeader"></param>
+        /// <param name="warnOrErrorOnTargetArchitectureMismatch"></param>
+        /// <param name="ignoreFrameworkAttributeVersionMismatch"></param>
         internal ReferenceTable
         (
             IBuildEngine buildEngine,
@@ -245,7 +242,6 @@ internal ReferenceTable
             bool unresolveFrameworkAssembliesFromHigherFrameworks,
             ConcurrentDictionary<string, AssemblyMetadata> assemblyMetadataCache)
         {
-            _buildEngine = buildEngine;
             _log = log;
             _findDependencies = findDependencies;
             _findSatellites = findSatellites;
@@ -285,7 +281,6 @@ internal ReferenceTable
             _resolvedSDKReferences = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);
             _ignoreVersionForFrameworkReferences = ignoreVersionForFrameworkReferences;
 
-
             if (resolvedSDKItems != null)
             {
                 foreach (ITaskItem resolvedSDK in resolvedSDKItems)
@@ -307,7 +302,7 @@ internal ReferenceTable
             }
 
             // Compile searchpaths into fast resolver array.
-            _compiledSearchPaths = AssemblyResolution.CompileSearchPaths
+            Resolvers = AssemblyResolution.CompileSearchPaths
                 (
                     buildEngine,
                     searchPaths,
@@ -332,34 +327,18 @@ internal ReferenceTable
         /// <summary>
         /// Set of resolvers the reference table uses.
         /// </summary>
-        internal Resolver[] Resolvers
-        {
-            get { return _compiledSearchPaths; }
-        }
+        internal Resolver[] Resolvers { get; }
 
         /// <summary>
         /// Get a table of all vertices.
         /// </summary>
-        /// <returns></returns>
-        internal Dictionary<AssemblyNameExtension, Reference> References
-        {
-            get
-            {
-                return _references;
-            }
-        }
+        internal Dictionary<AssemblyNameExtension, Reference> References { get; private set; } = new Dictionary<AssemblyNameExtension, Reference>(AssemblyNameComparer.GenericComparer);
 
         /// <summary>
         /// If assemblies have been marked for exclusion this contains the list of their full names
         /// This may be null
         /// </summary>
-        internal List<string> ListOfExcludedAssemblies
-        {
-            get
-            {
-                return _listOfExcludedAssemblies;
-            }
-        }
+        internal List<string> ListOfExcludedAssemblies { get; private set; }
 
         /// <summary>
         /// Indicates that at least one reference was <see cref="Reference.ExternallyResolved"/> and
@@ -389,16 +368,16 @@ internal List<string> ListOfExcludedAssemblies
         internal void AddReference(AssemblyNameExtension assemblyName, Reference reference)
         {
             ErrorUtilities.VerifyThrow(assemblyName.Name != null, "Got an empty assembly name.");
-            if (_references.ContainsKey(assemblyName))
+            if (References.ContainsKey(assemblyName))
             {
-                Reference referenceGoingToBeReplaced = _references[assemblyName];
+                Reference referenceGoingToBeReplaced = References[assemblyName];
                 foreach (AssemblyRemapping pair in referenceGoingToBeReplaced.RemappedAssemblyNames())
                 {
                     reference.AddRemapping(pair.From, pair.To);
                 }
             }
 
-            _references[assemblyName] = reference;
+            References[assemblyName] = reference;
         }
 
 
@@ -410,8 +389,7 @@ internal void AddReference(AssemblyNameExtension assemblyName, Reference referen
         internal Reference GetReference(AssemblyNameExtension assemblyName)
         {
             ErrorUtilities.VerifyThrow(assemblyName.Name != null, "Got an empty assembly name.");
-            Reference referenceToReturn = null;
-            _references.TryGetValue(assemblyName, out referenceToReturn);
+            References.TryGetValue(assemblyName, out Reference referenceToReturn);
             return referenceToReturn;
         }
 
@@ -474,7 +452,7 @@ string assemblyFileName
                     }
                 }
             }
-            catch (System.BadImageFormatException e)
+            catch (BadImageFormatException e)
             {
                 reference.AddError(new DependencyResolutionException(e.Message, e));
             }
@@ -512,9 +490,9 @@ ArrayList exceptions
             // Set the primary flag to 'true'.
             if (referenceAssemblyFiles != null)
             {
-                for (int i = 0; i < referenceAssemblyFiles.Length; ++i)
+                foreach (ITaskItem i in referenceAssemblyFiles)
                 {
-                    SetPrimaryFileItem(referenceAssemblyFiles[i]);
+                    SetPrimaryFileItem(i);
                 }
             }
 
@@ -522,9 +500,9 @@ ArrayList exceptions
             // Set the primary flag to 'true'.
             if (referenceAssemblyNames != null)
             {
-                for (int i = 0; i < referenceAssemblyNames.Length; ++i)
+                foreach (ITaskItem n in referenceAssemblyNames)
                 {
-                    Exception e = SetPrimaryAssemblyReferenceItem(referenceAssemblyNames[i]);
+                    Exception e = SetPrimaryAssemblyReferenceItem(n);
 
                     if (e != null)
                     {
@@ -537,7 +515,7 @@ ArrayList exceptions
         /// <summary>
         /// Given an item that refers to a assembly name, make it a primary reference.
         /// </summary>
-        /// <param name="referenceAssemblyNames">The task item which contain fusion names to add.</param>
+        /// <param name="referenceAssemblyName">The task item which contain fusion names to add.</param>
         /// <returns>Resulting exception containing resolution failure details, if any: too costly to throw it.</returns>
         private Exception SetPrimaryAssemblyReferenceItem
         (
@@ -552,8 +530,7 @@ ITaskItem referenceAssemblyName
             AssemblyNameExtension assemblyName = null;
             string itemSpec = referenceAssemblyName.ItemSpec;
             string fusionName = referenceAssemblyName.GetMetadata(ItemMetadataNames.fusionName);
-            bool metadataFound = false;
-            bool result = MetadataConversionUtilities.TryConvertItemMetadataToBool(referenceAssemblyName, ItemMetadataNames.IgnoreVersionForFrameworkReference, out metadataFound);
+            bool result = MetadataConversionUtilities.TryConvertItemMetadataToBool(referenceAssemblyName, ItemMetadataNames.IgnoreVersionForFrameworkReference, out bool metadataFound);
             bool ignoreVersionForFrameworkReference = false;
 
             if (metadataFound)
@@ -568,13 +545,12 @@ ITaskItem referenceAssemblyName
             TryConvertToAssemblyName(itemSpec, fusionName, ref assemblyName);
 
             // Figure out the specific version value.
-            bool foundSpecificVersionMetadata = false;
-            bool wantSpecificVersion = MetadataConversionUtilities.TryConvertItemMetadataToBool(referenceAssemblyName, ItemMetadataNames.specificVersion, out foundSpecificVersionMetadata);
+            bool wantSpecificVersion = MetadataConversionUtilities.TryConvertItemMetadataToBool(referenceAssemblyName, ItemMetadataNames.specificVersion, out bool foundSpecificVersionMetadata);
 
             bool isSimpleName = (assemblyName != null && assemblyName.IsSimpleName);
 
             // Create the reference.
-            Reference reference = new Reference(_isWinMDFile, _fileExists, _getRuntimeVersion);
+            var reference = new Reference(_isWinMDFile, _fileExists, _getRuntimeVersion);
             reference.MakePrimaryAssemblyReference(referenceAssemblyName, wantSpecificVersion, executableExtension);
 
             // Escape simple names.
@@ -640,7 +616,7 @@ ITaskItem referenceAssemblyName
 
                 if (reference.IsResolved)
                 {
-                    AssemblyNameExtension possiblyBetterAssemblyName = null;
+                    AssemblyNameExtension possiblyBetterAssemblyName;
 
                     try
                     {
@@ -655,7 +631,7 @@ ITaskItem referenceAssemblyName
                     }
 
                     // Use the better name if it exists.
-                    if (possiblyBetterAssemblyName != null && possiblyBetterAssemblyName.Name != null)
+                    if (possiblyBetterAssemblyName?.Name != null)
                     {
                         assemblyName = possiblyBetterAssemblyName;
                     }
@@ -705,18 +681,13 @@ ITaskItem referenceAssemblyName
             }
             else
             {
-                Version unifiedVersion = null;
-                bool isPrerequisite = false;
-                bool? isRedistRoot = null;
-                string redistName = null;
-
                 _installedAssemblies.GetInfo
                 (
                     assemblyName,
-                    out unifiedVersion,
-                    out isPrerequisite,
-                    out isRedistRoot,
-                    out redistName
+                    out _,
+                    out bool isPrerequisite,
+                    out bool? isRedistRoot,
+                    out string redistName
                 );
 
                 reference.IsPrerequisite = isPrerequisite;
@@ -738,14 +709,11 @@ out redistName
         /// Attempts to convert an itemSpec and fusionName into an assembly name.
         /// AssemblyName is left unchanged if conversion wasn't possible.
         /// </summary>
-        /// <param name="itemSpec"></param>
-        /// <param name="fusionName"></param>
-        /// <param name="assemblyName"></param>
         private static void TryConvertToAssemblyName(string itemSpec, string fusionName, ref AssemblyNameExtension assemblyName)
         {
             // FusionName is used if available.
             string finalName = fusionName;
-            if (finalName == null || finalName.Length == 0)
+            if (string.IsNullOrEmpty(finalName))
             {
                 // Otherwise, its itemSpec.
                 finalName = itemSpec;
@@ -768,7 +736,7 @@ private static void TryConvertToAssemblyName(string itemSpec, string fusionName,
                 {
                     assemblyName = new AssemblyNameExtension(finalName, true /*throw if not valid*/);
                 }
-                catch (System.IO.FileLoadException)
+                catch (FileLoadException)
                 {
                     // Not a valid AssemblyName. Maybe its a file name.
                     TryGatherAssemblyNameEssentials(finalName, ref assemblyName);
@@ -821,7 +789,7 @@ private static void TryGatherAssemblyNameEssentials(string fusionName, ref Assem
             {
                 assemblyName = new AssemblyNameExtension(newFusionName, true /* throw if not valid */);
             }
-            catch (System.IO.FileLoadException)
+            catch (FileLoadException)
             {
                 // Not a valid AssemblyName. Maybe its a file name.
                 // TryGatherAssemblyNameEssentials
@@ -832,9 +800,6 @@ private static void TryGatherAssemblyNameEssentials(string fusionName, ref Assem
         /// <summary>
         /// Attempt to get one field out of an assembly name.
         /// </summary>
-        /// <param name="fusionName"></param>
-        /// <param name="component"></param>
-        /// <param name="value"></param>
         private static void TryGetAssemblyNameComponent(string fusionName, string component, ref string value)
         {
             int position = fusionName.IndexOf(component + "=", StringComparison.Ordinal);
@@ -843,7 +808,7 @@ private static void TryGetAssemblyNameComponent(string fusionName, string compon
                 return;
             }
             position += component.Length + 1;
-            int nextDelimiter = fusionName.IndexOfAny(new char[] { ',', ' ' }, position);
+            int nextDelimiter = fusionName.IndexOfAny(new[] { ',', ' ' }, position);
             if (nextDelimiter == -1)
             {
                 value = fusionName.Substring(position);
@@ -857,13 +822,12 @@ private static void TryGetAssemblyNameComponent(string fusionName, string compon
         /// <summary>
         /// Given an item that refers to a file name, make it a primary reference.
         /// </summary>
-        /// <param name="referenceAssemblyFile"></param>
         private void SetPrimaryFileItem(ITaskItem referenceAssemblyFile)
         {
             try
             {
                 // Create the reference.
-                Reference reference = new Reference(_isWinMDFile, _fileExists, _getRuntimeVersion);
+                var reference = new Reference(_isWinMDFile, _fileExists, _getRuntimeVersion);
 
                 bool hasSpecificVersionMetadata = MetadataConversionUtilities.TryConvertItemMetadataToBool(referenceAssemblyFile, ItemMetadataNames.specificVersion);
                 reference.MakePrimaryAssemblyReference
@@ -906,7 +870,6 @@ private void SetPrimaryFileItem(ITaskItem referenceAssemblyFile)
         /// <summary>
         /// Find related files like .pdbs and .xmls
         /// </summary>
-        /// <param name="fullPath">Path to the parent assembly.</param>
         /// <param name="reference">The reference to the parent assembly.</param>
         private void FindRelatedFiles
         (
@@ -943,8 +906,6 @@ Reference reference
         /// <summary>
         /// Find satellite assemblies.
         /// </summary>
-        /// <param name="directoryName">Directory of the parrent assembly.</param>
-        /// <param name="fullPath">Path to the parent assembly.</param>
         /// <param name="reference">The reference to the parent assembly.</param>
         private void FindSatellites
         (
@@ -983,18 +944,13 @@ Reference reference
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
-                if (_log != null)
-                {
-                    _log.LogErrorFromResources("ResolveAssemblyReference.ProblemFindingSatelliteAssemblies", reference.FullPath, e.Message);
-                }
+                _log?.LogErrorFromResources("ResolveAssemblyReference.ProblemFindingSatelliteAssemblies", reference.FullPath, e.Message);
             }
         }
 
         /// <summary>
         /// Find serialization assemblies.
         /// </summary>
-        /// <param name="directoryName">Directory of the parrent assembly.</param>
-        /// <param name="fullPath">Path to the parent assembly.</param>
         /// <param name="reference">The reference to the parent assembly.</param>
         private void FindSerializationAssemblies
         (
@@ -1022,9 +978,6 @@ Reference reference
         /// <summary>
         /// Get unified dependencies and scatter files for a reference.
         /// </summary>
-        /// <param name="reference"></param>
-        /// <param name="unifiedDependencies"></param>
-        /// <param name="scatterFiles"></param>
         private void GetUnifiedAssemblyMetadata
             (
                 Reference reference,
@@ -1042,20 +995,18 @@ out string[] scatterFiles
                 return;
             }
 
-            AssemblyNameExtension[] dependentAssemblies = null;
-            FrameworkName frameworkName = null;
             _getAssemblyMetadata
             (
                 reference.FullPath,
                 _assemblyMetadataCache,
-                out dependentAssemblies,
+                out AssemblyNameExtension[] dependentAssemblies,
                 out scatterFiles,
-                out frameworkName
+                out FrameworkName frameworkName
             );
 
             reference.FrameworkNameAttribute = frameworkName;
 
-            List<AssemblyNameExtension> dependencies = new List<AssemblyNameExtension>(dependentAssemblies?.Length ?? 0);
+            var dependencies = new List<AssemblyNameExtension>(dependentAssemblies?.Length ?? 0);
 
             if (dependentAssemblies != null && dependentAssemblies.Length > 0)
             {
@@ -1100,8 +1051,6 @@ out frameworkName
         /// Given an enumerator of pre-unified assembly names, return an enumerator of unified 
         /// assembly names.
         /// </summary>
-        /// <param name="preUnificationAssemblyName"></param>
-        /// <returns></returns>
         private IEnumerable<UnifiedAssemblyName> GetUnifiedAssemblyNames
         (
             IEnumerable<AssemblyNameExtension> preUnificationAssemblyNames
@@ -1111,15 +1060,9 @@ IEnumerable<AssemblyNameExtension> preUnificationAssemblyNames
             {
                 // First, unify the assembly name so that we're dealing with the right version.
                 // Not AssemblyNameExtension because we're going to write to it.
-                AssemblyNameExtension dependentAssembly = new AssemblyNameExtension(preUnificationAssemblyName.AssemblyName.CloneIfPossible());
+                var dependentAssembly = new AssemblyNameExtension(preUnificationAssemblyName.AssemblyName.CloneIfPossible());
 
-                Version unifiedVersion;
-                bool isPrerequisite;
-                bool? isRedistRoot;
-                string redistName;
-
-                UnificationReason unificationReason;
-                bool isUnified = UnifyAssemblyNameVersions(dependentAssembly, out unifiedVersion, out unificationReason, out isPrerequisite, out isRedistRoot, out redistName);
+                bool isUnified = UnifyAssemblyNameVersions(dependentAssembly, out Version unifiedVersion, out UnificationReason unificationReason, out bool isPrerequisite, out bool? isRedistRoot, out string redistName);
                 dependentAssembly.ReplaceVersion(unifiedVersion);
 
                 yield return new UnifiedAssemblyName(preUnificationAssemblyName, dependentAssembly, isUnified, unificationReason, isPrerequisite, isRedistRoot, redistName);
@@ -1131,11 +1074,10 @@ IEnumerable<AssemblyNameExtension> preUnificationAssemblyNames
         /// </summary>
         /// <param name="reference">The reference to the parent assembly.</param>
         /// <param name="newEntries">New references are added to this list.</param>
-        /// <param name="removeEntries">Entries that should be removed from the list.</param>
         private void FindDependenciesAndScatterFiles
         (
             Reference reference,
-            ArrayList newEntries
+            List<KeyValuePair<AssemblyNameExtension, Reference>> newEntries
         )
         {
             // Before checking for dependencies check to see if the reference itself exists. 
@@ -1153,9 +1095,7 @@ ArrayList newEntries
 
             try
             {
-                IEnumerable<UnifiedAssemblyName> unifiedDependencies = null;
-                string[] scatterFiles = null;
-                GetUnifiedAssemblyMetadata(reference, out unifiedDependencies, out scatterFiles);
+                GetUnifiedAssemblyMetadata(reference, out IEnumerable<UnifiedAssemblyName> unifiedDependencies, out string[] scatterFiles);
                 reference.AttachScatterFiles(scatterFiles);
 
                 // If no dependencies then fall out.
@@ -1187,8 +1127,7 @@ ArrayList newEntries
 
                         newReference.IsPrerequisite = unifiedDependency.IsPrerequisite;
 
-                        DictionaryEntry newEntry = new DictionaryEntry(unifiedDependency.PostUnified, newReference);
-
+                        var newEntry = new KeyValuePair<AssemblyNameExtension, Reference>(unifiedDependency.PostUnified, newReference);
                         newEntries.Add(newEntry);
                     }
                     else
@@ -1255,7 +1194,6 @@ private static bool IsPseudoAssembly(string name)
             return String.Compare(name, "mscorlib", StringComparison.OrdinalIgnoreCase) == 0;
         }
 
-
         /// <summary>
         /// Based on the set of parent assemblies we want to add their directories to the list of resolvers so that 
         /// if the dependency is sitting beside the assembly which requires it then we will resolve the assembly from that location first.
@@ -1263,10 +1201,11 @@ private static bool IsPseudoAssembly(string name)
         /// The only time we do not want to do this is if the parent assembly came from the GAC or AssemblyFoldersEx then we want the assembly 
         /// to be found using those resolvers so that our GAC and AssemblyFolders checks later on will work on those assemblies.
         /// </summary>
-        internal static void CalculateParentAssemblyDirectories(Hashtable parentReferenceFolderHash, List<string> parentReferenceFolders, Reference parentReference)
+        internal static void CalculateParentAssemblyDirectories(List<string> parentReferenceFolders, Reference parentReference)
         {
             string parentReferenceFolder = parentReference.DirectoryName;
             string parentReferenceResolvedSearchPath = parentReference.ResolvedSearchPath;
+            var parentReferencesAdded = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
             bool parentReferenceResolvedFromGAC = false;
             bool parentReferenceResolvedFromAssemblyFolders = false;
@@ -1279,9 +1218,9 @@ internal static void CalculateParentAssemblyDirectories(Hashtable parentReferenc
             // Only add the parent folder as a search location if we have not added it to the list yet and the parent reference has not been resolved from the GAC or AssemblyFolders
             // If the reference has been resolved from one of these locations we want the dependency to be found using the GAC or AssemblyFolder resolver rather than the directory resolver
             // This way the dependency is marked with the correct search path "GAC" or "AssemblyFolder"  rather than "c:\xxxxxx" which prevents our GAC/AssemblyFolder check from working
-            if (!parentReferenceFolderHash.ContainsKey(parentReferenceFolder) && !parentReferenceResolvedFromGAC && !parentReferenceResolvedFromAssemblyFolders)
+            if (!parentReferencesAdded.Contains(parentReferenceFolder) && !parentReferenceResolvedFromGAC && !parentReferenceResolvedFromAssemblyFolders)
             {
-                parentReferenceFolderHash[parentReferenceFolder] = String.Empty;
+                parentReferencesAdded.Add(parentReferenceFolder);
                 parentReferenceFolders.Add(parentReferenceFolder);
             }
         }
@@ -1291,7 +1230,7 @@ internal static void CalculateParentAssemblyDirectories(Hashtable parentReferenc
         /// full name. Should only be called on references that haven't been resolved yet--otherwise, its
         /// a perf problem.
         /// </summary>
-        /// <param name="referenceFusionName">The fusion name for this reference.</param>
+        /// <param name="assemblyName">The fusion name for this reference.</param>
         /// <param name="rawFileNameCandidate">The file name to match if {RawFileName} is seen. (May be null).</param>
         /// <param name="reference">The reference object.</param>
         private void ResolveReference
@@ -1307,20 +1246,19 @@ Reference reference
             bool userRequestedSpecificFile = false;
 
             // A list of assemblies that might have been matches but weren't
-            ArrayList assembliesConsideredAndRejected = new ArrayList();
+            var assembliesConsideredAndRejected = new ArrayList();
 
             // First, look for the dependency in the parents' directories. Unless they are resolved from the GAC or assemblyFoldersEx then 
-            // we should make sure we use the GAC and assemblyFolders resolvers themserves rather than a directory resolver to find the reference.\
-            // this way we dont get assemblies pulled from the GAC or AssemblyFolders but dont have the marking that they were pulled form there.
-            Hashtable parentReferenceFolderHash = new Hashtable(StringComparer.OrdinalIgnoreCase);
-            List<string> parentReferenceFolders = new List<string>();
+            // we should make sure we use the GAC and assemblyFolders resolvers themserves rather than a directory resolver to find the reference.
+            // This way we dont get assemblies pulled from the GAC or AssemblyFolders but dont have the marking that they were pulled form there.
+            var parentReferenceFolders = new List<string>();
             foreach (Reference parentReference in reference.GetDependees())
             {
-                CalculateParentAssemblyDirectories(parentReferenceFolderHash, parentReferenceFolders, parentReference);
+                CalculateParentAssemblyDirectories(parentReferenceFolders, parentReference);
             }
 
             // Build the set of resolvers.
-            List<Resolver[]> jaggedResolvers = new List<Resolver[]>();
+            var jaggedResolvers = new List<Resolver[]>();
 
             // If a reference has an SDK name on it then we must ONLY resolve it from the SDK which matches the SDKName on the refernce metadata
             // this is to support the case where a single reference assembly is selected from the SDK.
@@ -1337,7 +1275,7 @@ Reference reference
                     jaggedResolvers.Add(AssemblyResolution.CompileDirectories(parentReferenceFolders, _fileExists, _getAssemblyName, _getRuntimeVersion, _targetedRuntimeVersion));
                 }
 
-                jaggedResolvers.Add(_compiledSearchPaths);
+                jaggedResolvers.Add(Resolvers);
             }
 
             // Resolve
@@ -1359,7 +1297,7 @@ Reference reference
                     out userRequestedSpecificFile
                 );
             }
-            catch (System.BadImageFormatException e)
+            catch (BadImageFormatException e)
             {
                 reference.AddError(new DependencyResolutionException(e.Message, e));
             }
@@ -1407,15 +1345,13 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
 #endif
             {
                 // Create a table which will contain the references which are not in the black list
-                Dictionary<AssemblyNameExtension, Reference> goodReferences = new Dictionary<AssemblyNameExtension, Reference>(AssemblyNameComparer.GenericComparer);
+                var goodReferences = new Dictionary<AssemblyNameExtension, Reference>(AssemblyNameComparer.GenericComparer);
 
                 // List of references which were removed from the reference table, we will loop through these and make sure that we get rid of the dependent references also.
-                List<Reference> removedReferences = new List<Reference>();
+                var removedReferences = new List<Reference>();
 
                 // For each reference, have a list of dependency references and their assembly names. (List<KeyValuePair<Reference, AssemblyNameExtension>>) == the dependent reference and the assembly name.
-                Dictionary<Reference, List<ReferenceAssemblyExtensionPair>> dependencyGraph = new Dictionary<Reference, List<ReferenceAssemblyExtensionPair>>();
-
-                LogExclusionReason logExclusionReason = null;
+                var dependencyGraph = new Dictionary<Reference, List<ReferenceAssemblyExtensionPair>>();
 
                 if (subsetName == null)
                 {
@@ -1423,15 +1359,15 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
                 }
 
                 // Go through each of the references, we go through this table because in general it will be considerably smaller than the blacklist. (10's of references vs 100's of black list items)
-                foreach (AssemblyNameExtension assemblyName in _references.Keys)
+                foreach (AssemblyNameExtension assemblyName in References.Keys)
                 {
-                    Reference assemblyReference = _references[assemblyName];
+                    Reference assemblyReference = References[assemblyName];
 
                     AddToDependencyGraph(dependencyGraph, assemblyName, assemblyReference);
 
                     // Is the assembly name not in the black list. This means the assembly could be allowed.
                     bool isMarkedForExclusion = assemblyReference.ExclusionListLoggingProperties.IsInExclusionList;
-                    logExclusionReason = assemblyReference.ExclusionListLoggingProperties.ExclusionReasonLogDelegate;
+                    LogExclusionReason logExclusionReason = assemblyReference.ExclusionListLoggingProperties.ExclusionReasonLogDelegate;
 
                     // Case one, the assembly is a primary reference
                     if (assemblyReference.IsPrimary)
@@ -1492,7 +1428,7 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
                 }
 
                 // Replace the references table with the list only containing good references.
-                _references = goodReferences;
+                References = goodReferences;
             }
         }
 
@@ -1506,11 +1442,9 @@ private static void AddToDependencyGraph(Dictionary<Reference, List<ReferenceAss
             // Find the references who the current reference is a dependency for 
             foreach (Reference dependee in assemblyReference.GetDependees())
             {
-                // This list will contain a list of key value pairs (K: Dependent reference V: assembly Name)
-                List<ReferenceAssemblyExtensionPair> dependencies = null;
-
                 // For a dependee see if we already have a list started
-                if (!dependencyGraph.TryGetValue(dependee, out dependencies))
+                // 'dependencies' will contain a list of key value pairs (K: Dependent reference V: assembly Name)
+                if (!dependencyGraph.TryGetValue(dependee, out List<ReferenceAssemblyExtensionPair> dependencies))
                 {
                     dependencies = new List<ReferenceAssemblyExtensionPair>();
                     dependencyGraph.Add(dependee, dependencies);
@@ -1547,7 +1481,7 @@ private void RemoveDependencyMarkedForExclusion(LogExclusionReason logExclusionR
                 if (primaryAssemblyName != null)
                 {
                     // Get the specific primary reference which caused this dependency
-                    Reference primaryAssemblyReference = _references[primaryAssemblyName];
+                    Reference primaryAssemblyReference = References[primaryAssemblyName];
                     bool hasSpecificVersionMetadata = primaryAssemblyReference.WantSpecificVersion;
 
                     if (!hasSpecificVersionMetadata)
@@ -1559,9 +1493,9 @@ private void RemoveDependencyMarkedForExclusion(LogExclusionReason logExclusionR
                             goodReferences.Remove(primaryAssemblyName);
                         }
 
-                        if (!removeOnlyNoWarning && logExclusionReason != null)
+                        if (!removeOnlyNoWarning)
                         {
-                            logExclusionReason(false, assemblyName, assemblyReference, dependee, subsetName);
+                            logExclusionReason?.Invoke(false, assemblyName, assemblyReference, dependee, subsetName);
                         }
                     }
                 }
@@ -1576,10 +1510,10 @@ private static void RemovePrimaryReferenceMarkedForExclusion(LogExclusionReason
         {
             removedReferences.Add(assemblyReference);
 
-            if (!removeOnlyNoWarning && logExclusionReason != null)
+            if (!removeOnlyNoWarning)
             {
                 // Note a primary references will always have a PrimarySourceItem which is not null
-                logExclusionReason(true, assemblyName, assemblyReference, assemblyReference.PrimarySourceItem, subsetName);
+                logExclusionReason?.Invoke(true, assemblyName, assemblyReference, assemblyReference.PrimarySourceItem, subsetName);
             }
         }
 
@@ -1588,9 +1522,9 @@ private static void RemovePrimaryReferenceMarkedForExclusion(LogExclusionReason
         /// </summary>
         internal AssemblyNameExtension GetReferenceFromItemSpec(string itemSpec)
         {
-            foreach (AssemblyNameExtension assemblyName in _references.Keys)
+            foreach (AssemblyNameExtension assemblyName in References.Keys)
             {
-                Reference assemblyReference = _references[assemblyName];
+                Reference assemblyReference = References[assemblyName];
                 if (assemblyReference.IsPrimary && assemblyReference.PrimarySourceItem.ItemSpec.Equals(itemSpec, StringComparison.OrdinalIgnoreCase))
                 {
                     return assemblyName;
@@ -1607,12 +1541,10 @@ internal AssemblyNameExtension GetReferenceFromItemSpec(string itemSpec)
         /// <param name="removedReference">Reference to remove dependencies for</param>
         /// <param name="referenceList">Reference list which contains reference to be used in unification and returned as resolved items</param>
         /// <param name="dependencyList"> A dictionary (Key: Reference Value: List of dependencies and their assembly name)</param>
-        private void RemoveDependencies(Reference removedReference, Dictionary<AssemblyNameExtension, Reference> referenceList, Dictionary<Reference, List<ReferenceAssemblyExtensionPair>> dependencyList)
+        private static void RemoveDependencies(Reference removedReference, Dictionary<AssemblyNameExtension, Reference> referenceList, Dictionary<Reference, List<ReferenceAssemblyExtensionPair>> dependencyList)
         {
-            List<ReferenceAssemblyExtensionPair> dependencies = null;
-
             // See if the reference has a list of dependencies
-            if (!dependencyList.TryGetValue(removedReference, out dependencies))
+            if (!dependencyList.TryGetValue(removedReference, out List<ReferenceAssemblyExtensionPair> dependencies))
             {
                 return;
             }
@@ -1651,7 +1583,7 @@ private void RemoveDependencies(Reference removedReference, Dictionary<AssemblyN
         /// If any are found, they're resolved and then dependencies are found. Then the process is repeated 
         /// until nothing is left unresolved.
         /// </summary>
-        /// <param name="remappedAssemblies">The table of remapped assemblies.</param>
+        /// <param name="remappedAssembliesValue">The table of remapped assemblies.</param>
         /// <param name="referenceAssemblyFiles">The task items which contain file names to add.</param>
         /// <param name="referenceAssemblyNames">The task items which contain fusion names to add.</param>
         /// <param name="exceptions">Errors encountered while computing closure.</param>
@@ -1667,7 +1599,7 @@ ArrayList exceptions
             using (new CodeMarkerStartEnd(CodeMarkerEvent.perfMSBuildRARComputeClosureBegin, CodeMarkerEvent.perfMSBuildRARComputeClosureEnd))
 #endif
             {
-                _references.Clear();
+                References.Clear();
                 _externallyResolvedPrimaryReferences.Clear();
                 SkippedFindingExternallyResolvedDependencies = false;
 
@@ -1683,13 +1615,13 @@ ArrayList exceptions
         /// </summary>
         private void ComputeClosure()
         {
-            bool moreResolvable = true;
+            bool moreResolvable;
             int moreResolvableIterations = 0;
             const int maxIterations = 100000; // Wait for a ridiculously large number of iterations before bailing out.
 
             do
             {
-                bool moreDependencies = true;
+                bool moreDependencies;
 
                 int dependencyIterations = 0;
                 do
@@ -1733,7 +1665,7 @@ private bool FindAssociatedFiles()
         {
             bool newDependencies = false;
 
-            ArrayList newEntries = new ArrayList();
+            var newEntries = new List<KeyValuePair<AssemblyNameExtension, Reference>>();
 
             foreach (Reference reference in References.Values)
             {
@@ -1816,10 +1748,10 @@ private bool FindAssociatedFiles()
             }
 
             // Add each new dependency found.
-            foreach (DictionaryEntry newEntry in newEntries)
+            foreach (KeyValuePair<AssemblyNameExtension, Reference> newEntry in newEntries)
             {
                 newDependencies = true;
-                AddReference((AssemblyNameExtension)newEntry.Key, (Reference)newEntry.Value);
+                AddReference(newEntry.Key, newEntry.Value);
             }
 
             return newDependencies;
@@ -1851,13 +1783,11 @@ private int ResolveConflictsBetweenReferences()
             int count = 0;
 
             // Get a table of simple name mapped to (perhaps multiple) reference.
-            Hashtable baseNames = BuildSimpleNameTable();
+            Dictionary<string, List<AssemblyNameReference>> baseNames = BuildSimpleNameTable();
 
             // Now we have references organized into groups that would conflict.
-            foreach (string baseName in baseNames.Keys)
+            foreach (List<AssemblyNameReference> assemblyReferences in baseNames.Values)
             {
-                ArrayList assemblyReferences = (ArrayList)baseNames[baseName];
-
                 // Sort to make it predictable. Choose to sort by ascending version number
                 // since this is known to reveal bugs in at least one circumstance.
                 assemblyReferences.Sort(AssemblyNameReferenceAscendingVersionComparer.comparer);
@@ -1868,8 +1798,8 @@ private int ResolveConflictsBetweenReferences()
                     // Resolve the conflict. Victim is the index of the item that lost.
                     int victim = ResolveAssemblyNameConflict
                     (
-                        (AssemblyNameReference)assemblyReferences[0],
-                        (AssemblyNameReference)assemblyReferences[1]
+                        assemblyReferences[0],
+                        assemblyReferences[1]
                     );
 
                     assemblyReferences.RemoveAt(victim);
@@ -1904,12 +1834,13 @@ out AssemblyNameReference[] conflictingReferences
             // Build two tables, one with a count and one with the corresponding references.
             // Dependencies which differ only by version number need a suggested redirect.
             // The count tells us whether there are two or more.
-            Hashtable counts = new Hashtable(StringComparer.OrdinalIgnoreCase);
-            Hashtable references = new Hashtable(StringComparer.OrdinalIgnoreCase);
+            var counts = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
+            var references = new Dictionary<string, AssemblyNameReference>(StringComparer.OrdinalIgnoreCase);
 
-            foreach (AssemblyNameExtension assemblyName in References.Keys)
+            foreach (KeyValuePair<AssemblyNameExtension, Reference> kvp in References)
             {
-                Reference reference = GetReference(assemblyName);
+                AssemblyNameExtension assemblyName = kvp.Key;
+                Reference reference = kvp.Value;
 
                 // If the assembly has a parent which has specific version set to true then we need to see if it is framework assembly
                 if (reference.CheckForSpecificVersionMetadataOnParentsReference(true))
@@ -1939,10 +1870,10 @@ out AssemblyNameReference[] conflictingReferences
                     baseKey.Version = null;
                     string key = baseKey.ToString();
 
-                    if (counts.ContainsKey(key))
+                    if (counts.TryGetValue(key, out int c))
                     {
-                        counts[key] = ((int)counts[key]) + 1;
-                        Version lastVersion = ((AssemblyNameReference)references[key]).assemblyName.Version;
+                        counts[key] = c + 1;
+                        Version lastVersion = references[key].assemblyName.Version;
 
                         if (lastVersion == null || lastVersion < version)
                         {
@@ -1958,27 +1889,31 @@ out AssemblyNameReference[] conflictingReferences
             }
 
             // Build the list of conflicted assemblies.
-            List<AssemblyNameReference> assemblyNamesList = new List<AssemblyNameReference>();
+            var assemblyNamesList = new List<AssemblyNameReference>();
             foreach (string versionLessAssemblyName in counts.Keys)
             {
-                if (((int)counts[versionLessAssemblyName]) > 1)
+                if (counts[versionLessAssemblyName] > 1)
                 {
-                    assemblyNamesList.Add((AssemblyNameReference)references[versionLessAssemblyName]);
+                    assemblyNamesList.Add(references[versionLessAssemblyName]);
                 }
             }
 
             // Pass over the list of conflicting references and make a binding redirect for each.
-            List<DependentAssembly> idealRemappingsList = new List<DependentAssembly>();
+            var idealRemappingsList = new List<DependentAssembly>();
 
             foreach (AssemblyNameReference assemblyNameReference in assemblyNamesList)
             {
-                DependentAssembly remapping = new DependentAssembly();
-                remapping.PartialAssemblyName = assemblyNameReference.assemblyName.AssemblyName;
-                BindingRedirect bindingRedirect = new BindingRedirect();
-                bindingRedirect.OldVersionLow = new Version("0.0.0.0");
-                bindingRedirect.OldVersionHigh = assemblyNameReference.assemblyName.AssemblyName.Version;
-                bindingRedirect.NewVersion = assemblyNameReference.assemblyName.AssemblyName.Version;
-                remapping.BindingRedirects = new BindingRedirect[] { bindingRedirect };
+                var remapping = new DependentAssembly
+                {
+                    PartialAssemblyName = assemblyNameReference.assemblyName.AssemblyName
+                };
+                var bindingRedirect = new BindingRedirect
+                {
+                    OldVersionLow = new Version("0.0.0.0"),
+                    OldVersionHigh = assemblyNameReference.assemblyName.AssemblyName.Version,
+                    NewVersion = assemblyNameReference.assemblyName.AssemblyName.Version
+                };
+                remapping.BindingRedirects = new[] { bindingRedirect };
 
                 idealRemappingsList.Add(remapping);
             }
@@ -2008,18 +1943,16 @@ internal bool MarkReferencesExcludedDueToOtherFramework(AssemblyNameExtension as
                 return false;
             }
 
-            bool inLaterRedistListAndFromGlobalLocation = false;
-
             // Check against target framework version if projectTargetFramework is null or less than 4.5, also when flag to force check is set to true
             if (_checkAssemblyVersionAgainstTargetFrameworkVersion)
             {
                 // Did the assembly name get resolved from a GlobalLocation, GAC or AssemblyFolders and is it in the frameworkList.xml for the 
                 // highest version of the currently targeted framework identifier.
-                inLaterRedistListAndFromGlobalLocation = InLatestRedistList(assemblyName, reference);
+                bool inLaterRedistListAndFromGlobalLocation = InLatestRedistList(assemblyName);
 
                 if (inLaterRedistListAndFromGlobalLocation)
                 {
-                    LogExclusionReason reason = new LogExclusionReason(LogAnotherFrameworkUnResolve);
+                    LogExclusionReason reason = LogAnotherFrameworkUnResolve;
                     reference.ExclusionListLoggingProperties.ExclusionReasonLogDelegate = reason;
                     reference.ExclusionListLoggingProperties.IsInExclusionList = true;
                     haveMarkedReference = true;
@@ -2032,13 +1965,13 @@ internal bool MarkReferencesExcludedDueToOtherFramework(AssemblyNameExtension as
         /// <summary>
         /// Is the assembly in the latest framework redist list as either passed into RAR on the lastestFrameworkDirectories property or determined by inspecting the file system.
         /// </summary>
-        private bool InLatestRedistList(AssemblyNameExtension assemblyName, Reference reference)
+        private bool InLatestRedistList(AssemblyNameExtension assemblyName)
         {
             bool inLaterRedistList = false;
 
             Tuple<RedistList, string> redistListOtherFramework = GetHighestVersionFullFrameworkForTFM(_targetFrameworkMoniker);
 
-            if (redistListOtherFramework != null && redistListOtherFramework.Item1 != null && redistListOtherFramework.Item1.FrameworkAssemblyEntryInRedist(assemblyName))
+            if (redistListOtherFramework?.Item1 != null && redistListOtherFramework.Item1.FrameworkAssemblyEntryInRedist(assemblyName))
             {
                 inLaterRedistList = true;
             }
@@ -2066,7 +1999,7 @@ private Tuple<RedistList, string> GetHighestVersionFullFrameworkForTFM(Framework
                 {
                     if (!s_monikerToHighestRedistList.TryGetValue(targetFrameworkMoniker.Identifier, out redistListAndOtherFrameworkName))
                     {
-                        IList<string> referenceAssemblyDirectories = null;
+                        IList<string> referenceAssemblyDirectories;
 
                         string otherFrameworkName = null;
 
@@ -2079,8 +2012,7 @@ private Tuple<RedistList, string> GetHighestVersionFullFrameworkForTFM(Framework
                         }
                         else
                         {
-                            FrameworkNameVersioning highestFrameworkName = null;
-                            referenceAssemblyDirectories = GetHighestVersionReferenceAssemblyDirectories(targetFrameworkMoniker, out highestFrameworkName);
+                            referenceAssemblyDirectories = GetHighestVersionReferenceAssemblyDirectories(targetFrameworkMoniker, out FrameworkName highestFrameworkName);
                             if (highestFrameworkName != null)
                             {
                                 otherFrameworkName = highestFrameworkName.FullName;
@@ -2089,8 +2021,8 @@ private Tuple<RedistList, string> GetHighestVersionFullFrameworkForTFM(Framework
 
                         if (referenceAssemblyDirectories != null && referenceAssemblyDirectories.Count > 0)
                         {
-                            HashSet<string> seenFrameworkDirectories = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
-                            List<AssemblyTableInfo> assemblyTableInfos = new List<AssemblyTableInfo>();
+                            var seenFrameworkDirectories = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+                            var assemblyTableInfos = new List<AssemblyTableInfo>();
                             foreach (string path in referenceAssemblyDirectories)
                             {
                                 string[] listPaths = RedistList.GetRedistListPathsFromDisk(path);
@@ -2123,7 +2055,7 @@ private Tuple<RedistList, string> GetHighestVersionFullFrameworkForTFM(Framework
         /// </summary>
         private static IList<string> GetHighestVersionReferenceAssemblyDirectories(FrameworkNameVersioning targetFrameworkMoniker, out FrameworkNameVersioning highestVersionMoniker)
         {
-            IList<string> referenceAssemblyDirectories = null;
+            IList<string> referenceAssemblyDirectories;
             string targetFrameworkRootDirectory = ToolLocationHelper.GetProgramFilesReferenceAssemblyRoot();
 
             highestVersionMoniker = ToolLocationHelper.HighestVersionOfTargetFrameworkIdentifier(targetFrameworkRootDirectory, targetFrameworkMoniker.Identifier);
@@ -2137,8 +2069,7 @@ private static IList<string> GetHighestVersionReferenceAssemblyDirectories(Frame
             }
             return referenceAssemblyDirectories;
         }
-
-
+        
         /// <summary>
         /// Is the assemblyName in the current redist list and does it have a version number which is higher than what is in the current redist list.
         /// This may happen if someone passes in a p2p reference whcih is a framework assembly which is a higher version than what is in the redist list.
@@ -2163,8 +2094,6 @@ internal void MarkReferenceWithHighestVersionInCurrentRedistList(AssemblyNameExt
         /// </summary>
         internal bool MarkReferenceForExclusionDueToHigherThanCurrentFramework(AssemblyNameExtension assemblyName, Reference reference)
         {
-            bool higherThanCurrentRedistList = false;
-
             // In this method have we marked a reference as needing to be excluded
             bool haveMarkedReference = false;
 
@@ -2176,13 +2105,12 @@ internal bool MarkReferenceForExclusionDueToHigherThanCurrentFramework(AssemblyN
                 // Check assemblies versions when target framework version is less than 4.5
 
                 // Make sure the version is higher than the version in the redist. 
-                higherThanCurrentRedistList = (reference.ReferenceVersion != null && reference.ExclusionListLoggingProperties.HighestVersionInRedist != null)
-                                              && reference.ReferenceVersion.CompareTo(reference.ExclusionListLoggingProperties.HighestVersionInRedist) > 0;
+                bool higherThanCurrentRedistList = (reference.ReferenceVersion != null && reference.ExclusionListLoggingProperties.HighestVersionInRedist != null)
+                                                   && reference.ReferenceVersion.CompareTo(reference.ExclusionListLoggingProperties.HighestVersionInRedist) > 0;
 
                 if (higherThanCurrentRedistList)
                 {
-                    LogExclusionReason reason = new LogExclusionReason(LogHigherVersionUnresolve);
-                    reference.ExclusionListLoggingProperties.ExclusionReasonLogDelegate = reason;
+                    reference.ExclusionListLoggingProperties.ExclusionReasonLogDelegate = LogHigherVersionUnresolve;
                     reference.ExclusionListLoggingProperties.IsInExclusionList = true;
                     haveMarkedReference = true;
                 }
@@ -2197,7 +2125,6 @@ internal bool MarkReferenceForExclusionDueToHigherThanCurrentFramework(AssemblyN
         /// </summary>
         internal bool MarkReferenceForExclusionDueToHigherThanCurrentFrameworkAttribute(AssemblyNameExtension assemblyName, Reference reference)
         {
-            bool higherThanCurrentFramework = false;
             // In this method have we marked a reference as needing to be excluded
             bool haveMarkedReference = false;
 
@@ -2208,36 +2135,34 @@ internal bool MarkReferenceForExclusionDueToHigherThanCurrentFrameworkAttribute(
 
             // Make sure the version is higher than the version in the redist. 
             // If the identifier are not equal we do not check since we are not trying to catch cross framework incompatibilities.
-            higherThanCurrentFramework = reference.FrameworkNameAttribute != null
-                                         && _targetFrameworkMoniker != null
-                                         && String.Equals(reference.FrameworkNameAttribute.Identifier, _targetFrameworkMoniker.Identifier, StringComparison.OrdinalIgnoreCase)
-                                         && reference.FrameworkNameAttribute.Version > _targetFrameworkMoniker.Version;
+            bool higherThanCurrentFramework = reference.FrameworkNameAttribute != null
+                                              && _targetFrameworkMoniker != null
+                                              && String.Equals(reference.FrameworkNameAttribute.Identifier, _targetFrameworkMoniker.Identifier, StringComparison.OrdinalIgnoreCase)
+                                              && reference.FrameworkNameAttribute.Version > _targetFrameworkMoniker.Version;
 
             // Mark reference as excluded
             if (higherThanCurrentFramework)
             {
-                LogExclusionReason reason = new LogExclusionReason(LogHigherVersionUnresolveDueToAttribute);
-                reference.ExclusionListLoggingProperties.ExclusionReasonLogDelegate = reason;
+                reference.ExclusionListLoggingProperties.ExclusionReasonLogDelegate = LogHigherVersionUnresolveDueToAttribute;
                 reference.ExclusionListLoggingProperties.IsInExclusionList = true;
                 haveMarkedReference = true;
             }
 
             return haveMarkedReference;
         }
-
-
+        
         /// <summary>
         /// Build a table of simple names mapped to assemblyname+reference.
         /// </summary>
-        private Hashtable BuildSimpleNameTable()
+        private Dictionary<string, List<AssemblyNameReference>> BuildSimpleNameTable()
         {
             // Build a list of base file names from references.
             // These would conflict with each other if copied to the output directory.
-            Hashtable baseNames = new Hashtable(StringComparer.CurrentCultureIgnoreCase);
-            AssemblyNameReference assemblyReference;
+            var baseNames = new Dictionary<string, List<AssemblyNameReference>>(StringComparer.CurrentCultureIgnoreCase);
 
             foreach (AssemblyNameExtension assemblyName in References.Keys)
             {
+                AssemblyNameReference assemblyReference;
                 assemblyReference.assemblyName = assemblyName;
                 assemblyReference.reference = GetReference(assemblyName);
 
@@ -2246,12 +2171,13 @@ private Hashtable BuildSimpleNameTable()
                 // which would influence unification. We want to report this to the user.
                 string baseName = assemblyName.Name;
 
-                if (!baseNames.ContainsKey(baseName))
+                if (!baseNames.TryGetValue(baseName, out List<AssemblyNameReference> refs))
                 {
-                    baseNames[baseName] = new ArrayList();
+                    refs = new List<AssemblyNameReference>();
+                    baseNames[baseName] = refs;
                 }
 
-                ((ArrayList)baseNames[baseName]).Add(assemblyReference);
+                refs.Add(assemblyReference);
             }
 
             return baseNames;
@@ -2263,16 +2189,14 @@ private Hashtable BuildSimpleNameTable()
         /// </summary>
         private static int ResolveAssemblyNameConflict(AssemblyNameReference assemblyReference0, AssemblyNameReference assemblyReference1)
         {
-            int victim = 0;
-
             // Extra checks for PInvoke-destined data.
             ErrorUtilities.VerifyThrow(assemblyReference0.assemblyName.FullName != null, "Got a null assembly name fullname. (0)");
             ErrorUtilities.VerifyThrow(assemblyReference1.assemblyName.FullName != null, "Got a null assembly name fullname. (1)");
 
-            string[] conflictFusionNames = new string[] { assemblyReference0.assemblyName.FullName, assemblyReference1.assemblyName.FullName };
-            Reference[] conflictReferences = new Reference[] { assemblyReference0.reference, assemblyReference1.reference };
-            AssemblyNameExtension[] conflictAssemblyNames = new AssemblyNameExtension[] { assemblyReference0.assemblyName, assemblyReference1.assemblyName };
-            bool[] conflictLegacyUnified = new bool[] { assemblyReference0.reference.IsPrimary, assemblyReference1.reference.IsPrimary };
+            string[] conflictFusionNames = { assemblyReference0.assemblyName.FullName, assemblyReference1.assemblyName.FullName };
+            Reference[] conflictReferences = { assemblyReference0.reference, assemblyReference1.reference };
+            AssemblyNameExtension[] conflictAssemblyNames = { assemblyReference0.assemblyName, assemblyReference1.assemblyName };
+            bool[] conflictLegacyUnified = { assemblyReference0.reference.IsPrimary, assemblyReference1.reference.IsPrimary };
 
             //  If both assemblies being compared are primary references, the caller should pass in a zero-flag 
             // (non-unified) for both. (This conforms to the C# assumption that two direct references are meant to be 
@@ -2284,20 +2208,18 @@ private static int ResolveAssemblyNameConflict(AssemblyNameReference assemblyRef
             }
 
             // This is ok here because even if the method says two versions are equivilant the algorithm below will still pick the highest version.
-            bool equivalent = false;
-            NativeMethods.AssemblyComparisonResult result = 0;
             NativeMethods.CompareAssemblyIdentity
             (
                 conflictFusionNames[0],
                 conflictLegacyUnified[0],
                 conflictFusionNames[1],
                 conflictLegacyUnified[1],
-                out equivalent,
-                out result
+                out bool equivalent,
+                out _
             );
 
             // Remove one and provide some information about why.
-            victim = 0;
+            var victim = 0;
             ConflictLossReason reason = ConflictLossReason.InsolubleConflict;
 
             // Pick the one with the highest version number.
@@ -2356,8 +2278,7 @@ out result
                     }
                 }
             }
-
-
+            
             // Remove the one chosen.
             int victor = 1 - victim;
             conflictReferences[victim].ConflictVictorName = conflictAssemblyNames[victor];
@@ -2370,7 +2291,7 @@ out result
         /// <summary>
         /// Returns true if an assembly has been removed from the .NET framework
         /// </summary>
-        private bool IsAssemblyRemovedFromDotNetFramework(AssemblyNameExtension assemblyName, string fullPath, string[] frameworkPaths, InstalledAssemblies installedAssemblies)
+        private static bool IsAssemblyRemovedFromDotNetFramework(AssemblyNameExtension assemblyName, string fullPath, string[] frameworkPaths, InstalledAssemblies installedAssemblies)
         {
             if (installedAssemblies != null)
             {
@@ -2526,13 +2447,13 @@ out ITaskItem[] copyLocalFiles
             scatterFiles = Array.Empty<ITaskItem>();
             copyLocalFiles = Array.Empty<ITaskItem>();
 
-            ArrayList primaryItems = new ArrayList();
-            ArrayList dependencyItems = new ArrayList();
-            ArrayList relatedItems = new ArrayList();
-            ArrayList satelliteItems = new ArrayList();
-            ArrayList serializationAssemblyItems = new ArrayList();
-            ArrayList scatterItems = new ArrayList();
-            ArrayList copyLocalItems = new ArrayList();
+            var primaryItems = new List<ITaskItem>();
+            var dependencyItems = new List<ITaskItem>();
+            var relatedItems = new List<ITaskItem>();
+            var satelliteItems = new List<ITaskItem>();
+            var serializationAssemblyItems = new List<ITaskItem>();
+            var scatterItems = new List<ITaskItem>();
+            var copyLocalItems = new List<ITaskItem>();
 
             foreach (AssemblyNameExtension assemblyName in References.Keys)
             {
@@ -2566,7 +2487,7 @@ out ITaskItem[] copyLocalFiles
 
                     if (reference.IsResolved)
                     {
-                        ITaskItem referenceItem = SetItemMetadata(relatedItems, satelliteItems, serializationAssemblyItems, scatterItems, fusionName, reference, assemblyName, _fileExists);
+                        ITaskItem referenceItem = SetItemMetadata(relatedItems, satelliteItems, serializationAssemblyItems, scatterItems, fusionName, reference, assemblyName);
 
                         if (reference.IsPrimary)
                         {
@@ -2588,11 +2509,11 @@ out ITaskItem[] copyLocalFiles
             primaryFiles = new ITaskItem[primaryItems.Count];
             primaryItems.CopyTo(primaryFiles, 0);
 
-            dependencyFiles = (ITaskItem[])dependencyItems.ToArray(typeof(ITaskItem));
-            relatedFiles = (ITaskItem[])relatedItems.ToArray(typeof(ITaskItem));
-            satelliteFiles = (ITaskItem[])satelliteItems.ToArray(typeof(ITaskItem));
-            serializationAssemblyFiles = (ITaskItem[])serializationAssemblyItems.ToArray(typeof(ITaskItem));
-            scatterFiles = (ITaskItem[])scatterItems.ToArray(typeof(ITaskItem));
+            dependencyFiles = dependencyItems.ToArray();
+            relatedFiles = relatedItems.ToArray();
+            satelliteFiles = satelliteItems.ToArray();
+            serializationAssemblyFiles = serializationAssemblyItems.ToArray();
+            scatterFiles = scatterItems.ToArray();
 
             // Sort for stable outputs. (These came from a hashtable, which as undefined enumeration order.)
             Array.Sort(primaryFiles, TaskItemSpecFilenameComparer.Comparer);
@@ -2604,13 +2525,13 @@ out ITaskItem[] copyLocalFiles
             FindCopyLocalItems(satelliteFiles, copyLocalItems);
             FindCopyLocalItems(serializationAssemblyFiles, copyLocalItems);
             FindCopyLocalItems(scatterFiles, copyLocalItems);
-            copyLocalFiles = (ITaskItem[])copyLocalItems.ToArray(typeof(ITaskItem));
+            copyLocalFiles = copyLocalItems.ToArray();
         }
 
         /// <summary>
         /// Set metadata on the items which will be output from RAR.
         /// </summary>
-        private ITaskItem SetItemMetadata(ArrayList relatedItems, ArrayList satelliteItems, ArrayList serializationAssemblyItems, ArrayList scatterItems, string fusionName, Reference reference, AssemblyNameExtension assemblyName, FileExists fileExists)
+        private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem> satelliteItems, List<ITaskItem> serializationAssemblyItems, List<ITaskItem> scatterItems, string fusionName, Reference reference, AssemblyNameExtension assemblyName)
         {
             // Set up the main item.
             ITaskItem referenceItem = new TaskItem();
@@ -2964,25 +2885,20 @@ private static void RemoveNonForwardableMetadata(ITaskItem item)
             item.RemoveMetadata(ItemMetadataNames.winMDFile);
         }
 
-
         /// <summary>
         /// Given a list of items, find all that have CopyLocal==true and add it to the list.
         /// </summary>
-        /// <param name="items"></param>
-        /// <param name="copyLocalItems"></param>
-        private static void FindCopyLocalItems(ITaskItem[] items, ArrayList copyLocalItems)
+        private static void FindCopyLocalItems(ITaskItem[] items, List<ITaskItem> copyLocalItems)
         {
             foreach (ITaskItem i in items)
             {
-                bool found;
                 bool copyLocal = MetadataConversionUtilities.TryConvertItemMetadataToBool
                     (
                         i,
                         ItemMetadataNames.copyLocal,
-                        out found
+                        out bool found
                     );
 
-
                 if (found && copyLocal)
                 {
                     copyLocalItems.Add(i);
@@ -3061,24 +2977,15 @@ internal void LogProfileExclusionUnresolve(bool displayPrimaryReferenceMessage,
         /// </summary>
         internal struct ReferenceAssemblyExtensionPair
         {
-            private Reference _assemblyKey;
-            private AssemblyNameExtension _assemblyValue;
-
             internal ReferenceAssemblyExtensionPair(Reference key, AssemblyNameExtension value)
             {
-                _assemblyKey = key;
-                _assemblyValue = value;
+                Key = key;
+                Value = value;
             }
 
-            internal Reference Key
-            {
-                get { return _assemblyKey; }
-            }
+            internal Reference Key { get; }
 
-            internal AssemblyNameExtension Value
-            {
-                get { return _assemblyValue; }
-            }
+            internal AssemblyNameExtension Value { get; }
         }
 
         #endregion
@@ -3090,7 +2997,7 @@ internal AssemblyNameExtension Value
         internal bool MarkReferencesForExclusion(Hashtable exclusionList)
         {
             bool anyMarkedReference = false;
-            _listOfExcludedAssemblies = new List<string>();
+            ListOfExcludedAssemblies = new List<string>();
 
             foreach (AssemblyNameExtension assemblyName in References.Keys)
             {
@@ -3111,9 +3018,9 @@ internal bool MarkReferencesForExclusion(Hashtable exclusionList)
                         if (exclusionList.ContainsKey(assemblyFullName))
                         {
                             anyMarkedReference = true;
-                            reference.ExclusionListLoggingProperties.ExclusionReasonLogDelegate = new LogExclusionReason(LogProfileExclusionUnresolve);
+                            reference.ExclusionListLoggingProperties.ExclusionReasonLogDelegate = LogProfileExclusionUnresolve;
                             reference.ExclusionListLoggingProperties.IsInExclusionList = true;
-                            _listOfExcludedAssemblies.Add(assemblyFullName);
+                            ListOfExcludedAssemblies.Add(assemblyFullName);
                         }
                     }
 
@@ -3123,7 +3030,7 @@ internal bool MarkReferencesForExclusion(Hashtable exclusionList)
                         if (MarkReferenceForExclusionDueToHigherThanCurrentFramework(assemblyName, reference))
                         {
                             anyMarkedReference = true;
-                            _listOfExcludedAssemblies.Add(assemblyFullName);
+                            ListOfExcludedAssemblies.Add(assemblyFullName);
                         }
                     }
 
@@ -3133,7 +3040,7 @@ internal bool MarkReferencesForExclusion(Hashtable exclusionList)
                         if (MarkReferencesExcludedDueToOtherFramework(assemblyName, reference))
                         {
                             anyMarkedReference = true;
-                            _listOfExcludedAssemblies.Add(assemblyFullName);
+                            ListOfExcludedAssemblies.Add(assemblyFullName);
                         }
                     }
 
@@ -3143,7 +3050,7 @@ internal bool MarkReferencesForExclusion(Hashtable exclusionList)
                         if (!_ignoreFrameworkAttributeVersionMismatch && MarkReferenceForExclusionDueToHigherThanCurrentFrameworkAttribute(assemblyName, reference))
                         {
                             anyMarkedReference = true;
-                            _listOfExcludedAssemblies.Add(assemblyFullName);
+                            ListOfExcludedAssemblies.Add(assemblyFullName);
                         }
                     }
                 }
diff --git a/src/Tasks/AssemblyDependency/ResolutionSearchLocation.cs b/src/Tasks/AssemblyDependency/ResolutionSearchLocation.cs
index 6375db0d826..591ddee0c3e 100644
--- a/src/Tasks/AssemblyDependency/ResolutionSearchLocation.cs
+++ b/src/Tasks/AssemblyDependency/ResolutionSearchLocation.cs
@@ -1,17 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Resources;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
-using System.Reflection;
-using System.IO;
-using System.Collections;
-using System.Globalization;
-using System.Diagnostics;
-using System.Runtime.InteropServices;
-using System.Text.RegularExpressions;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -22,45 +11,24 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     internal class ResolutionSearchLocation
     {
-        private string _fileNameAttempted = null;
-        private string _searchPath = null;
-        private AssemblyNameExtension _assemblyName = null;
-        private NoMatchReason _reason = NoMatchReason.Unknown;
-
         /// <summary>
         /// The name of the file that was attempted to match.
         /// </summary>
-        internal string FileNameAttempted
-        {
-            get { return _fileNameAttempted; }
-            set { _fileNameAttempted = value; }
-        }
+        internal string FileNameAttempted { get; set; }
 
         /// <summary>
         /// The literal searchpath element that was used to discover this location.
         /// </summary>
-        internal string SearchPath
-        {
-            get { return _searchPath; }
-            set { _searchPath = value; }
-        }
+        internal string SearchPath { get; set; }
 
         /// <summary>
         /// The name of the assembly found at that location. Will be null if there was no assembly there.
         /// </summary>
-        internal AssemblyNameExtension AssemblyName
-        {
-            get { return _assemblyName; }
-            set { _assemblyName = value; }
-        }
+        internal AssemblyNameExtension AssemblyName { get; set; }
 
         /// <summary>
         /// The reason there was no macth.
         /// </summary>
-        internal NoMatchReason Reason
-        {
-            get { return _reason; }
-            set { _reason = value; }
-        }
+        internal NoMatchReason Reason { get; set; } = NoMatchReason.Unknown;
     }
 }
diff --git a/src/Tasks/AssemblyDependency/Resolver.cs b/src/Tasks/AssemblyDependency/Resolver.cs
index 2604b03189b..b481ad8843c 100644
--- a/src/Tasks/AssemblyDependency/Resolver.cs
+++ b/src/Tasks/AssemblyDependency/Resolver.cs
@@ -91,7 +91,6 @@ public abstract bool Resolve
             ArrayList assembliesConsideredAndRejected,
             out string foundPath,
             out bool userRequestedSpecificFile
-
         );
 
         /// <summary>
diff --git a/src/Tasks/AssemblyDependency/UnificationReason.cs b/src/Tasks/AssemblyDependency/UnificationReason.cs
index d4db845b835..c439d571e50 100644
--- a/src/Tasks/AssemblyDependency/UnificationReason.cs
+++ b/src/Tasks/AssemblyDependency/UnificationReason.cs
@@ -1,15 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.IO;
-using System.Collections;
-using System.Reflection;
-using System.Diagnostics;
-using System.Globalization;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Framework;
-
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
diff --git a/src/Tasks/AssemblyDependency/UnificationVersion.cs b/src/Tasks/AssemblyDependency/UnificationVersion.cs
index 00006c6570f..79eb947430f 100644
--- a/src/Tasks/AssemblyDependency/UnificationVersion.cs
+++ b/src/Tasks/AssemblyDependency/UnificationVersion.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Reflection;
 
 namespace Microsoft.Build.Tasks
 {
diff --git a/src/Tasks/AssemblyDependency/UnifiedAssemblyName.cs b/src/Tasks/AssemblyDependency/UnifiedAssemblyName.cs
index 459457ca2f3..1f91306f771 100644
--- a/src/Tasks/AssemblyDependency/UnifiedAssemblyName.cs
+++ b/src/Tasks/AssemblyDependency/UnifiedAssemblyName.cs
@@ -1,8 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Reflection;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -12,58 +10,29 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     internal class UnifiedAssemblyName
     {
-        private AssemblyNameExtension _preUnified;
-        private AssemblyNameExtension _postUnified;
-        private bool _isUnified;
-        private bool _isPrerequisite;
-        private bool? _isRedistRoot;
-        private string _redistName;
-        private UnificationReason _unificationReason;
-
         public UnifiedAssemblyName(AssemblyNameExtension preUnified, AssemblyNameExtension postUnified, bool isUnified, UnificationReason unificationReason, bool isPrerequisite, bool? isRedistRoot, string redistName)
         {
-            _preUnified = preUnified;
-            _postUnified = postUnified;
-            _isUnified = isUnified;
-            _isPrerequisite = isPrerequisite;
-            _isRedistRoot = isRedistRoot;
-            _redistName = redistName;
-            _unificationReason = unificationReason;
+            PreUnified = preUnified;
+            PostUnified = postUnified;
+            IsUnified = isUnified;
+            IsPrerequisite = isPrerequisite;
+            IsRedistRoot = isRedistRoot;
+            RedistName = redistName;
+            UnificationReason = unificationReason;
         }
 
-        public AssemblyNameExtension PreUnified
-        {
-            get { return _preUnified; }
-        }
+        public AssemblyNameExtension PreUnified { get; }
 
-        public AssemblyNameExtension PostUnified
-        {
-            get { return _postUnified; }
-        }
+        public AssemblyNameExtension PostUnified { get; }
 
-        public bool IsUnified
-        {
-            get { return _isUnified; }
-        }
+        public bool IsUnified { get; }
 
-        public UnificationReason UnificationReason
-        {
-            get { return _unificationReason; }
-        }
+        public UnificationReason UnificationReason { get; }
 
-        public bool IsPrerequisite
-        {
-            get { return _isPrerequisite; }
-        }
+        public bool IsPrerequisite { get; }
 
-        public bool? IsRedistRoot
-        {
-            get { return _isRedistRoot; }
-        }
+        public bool? IsRedistRoot { get; }
 
-        public string RedistName
-        {
-            get { return _redistName; }
-        }
+        public string RedistName { get; }
     }
 }
diff --git a/src/Tasks/AssemblyDependency/WarnOrErrorOnTargetArchitectureMismatchBehavior.cs b/src/Tasks/AssemblyDependency/WarnOrErrorOnTargetArchitectureMismatchBehavior.cs
index 3490a10ba49..e516e911861 100644
--- a/src/Tasks/AssemblyDependency/WarnOrErrorOnTargetArchitectureMismatchBehavior.cs
+++ b/src/Tasks/AssemblyDependency/WarnOrErrorOnTargetArchitectureMismatchBehavior.cs
@@ -5,21 +5,8 @@
 // <summary>Should a warning or error or nothing be emitted when there is a architecture mismatch</summary>
 //-----------------------------------------------------------------------
 
-using System;
-using System.Resources;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
-using System.Reflection;
-using System.IO;
-using System.Collections;
-using System.Globalization;
-using System.Diagnostics;
-using System.Runtime.InteropServices;
-using System.Text.RegularExpressions;
-
 namespace Microsoft.Build.Tasks
 {
-    #region enum
     /// <summary>
     /// Enum describing the behavior when a a primary reference has an architecture different from the project
     /// </summary>
@@ -40,5 +27,4 @@ internal enum WarnOrErrorOnTargetArchitectureMismatchBehavior
         /// </summary>
         None
     }
-    #endregion
 }
diff --git a/src/Tasks/AssemblyFolder.cs b/src/Tasks/AssemblyFolder.cs
index 9e2c6372b5f..a035c1ed97f 100644
--- a/src/Tasks/AssemblyFolder.cs
+++ b/src/Tasks/AssemblyFolder.cs
@@ -4,8 +4,7 @@
 
 using System;
 using System.IO;
-using System.Collections;
-
+using System.Collections.Generic;
 using Microsoft.Build.Shared;
 using Microsoft.Win32;
 
@@ -20,12 +19,12 @@ internal static class AssemblyFolder
         /// Key -- Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project
         /// Value -- Directory
         /// </summary>
-        private static Hashtable s_assemblyFolders;
+        private static Dictionary<string, string> s_assemblyFolders;
 
         /// <summary>
         /// Synchronize the creation of assemblyFolders
         /// </summary>
-        private static Object s_syncLock = new Object();
+        private static readonly Object s_syncLock = new Object();
 
         /// <summary>
         /// Given a registry key, find all of the registered assembly folders and add them to the list.
@@ -37,7 +36,7 @@ private static void AddFoldersFromRegistryKey
         (
             RegistryKey hive,
             string key,
-            Hashtable directories
+            Dictionary<string, string> directories
         )
         {
             if (!NativeMethodsShared.IsWindows && hive == Registry.LocalMachine)
@@ -45,7 +44,7 @@ Hashtable directories
                 string path = NativeMethodsShared.FrameworkBasePath;
                 if (Directory.Exists(path))
                 {
-                    foreach (var p in Directory.EnumerateDirectories(path))
+                    foreach (string p in Directory.EnumerateDirectories(path))
                     {
                         directories[
                             "hklm" + "\\" + p.Substring(p.LastIndexOf(Path.DirectorySeparatorChar) + 1)] = p;
@@ -96,12 +95,9 @@ Hashtable directories
         /// <summary>
         /// For the given key name, look for registered assembly folders in HKCU then HKLM.
         /// </summary>
-        /// <param name="key"></param>
-        /// <param name="directories"></param>
-        private static void AddFoldersFromRegistryKey
-        (
+        private static void AddFoldersFromRegistryKey(
             string key,
-            Hashtable directories
+            Dictionary<string, string> directories
         )
         {
             // First add the current user.
@@ -126,7 +122,7 @@ Hashtable directories
         /// </summary>
         private static void CreateAssemblyFolders()
         {
-            s_assemblyFolders = new Hashtable(StringComparer.OrdinalIgnoreCase);
+            s_assemblyFolders = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
             // Populate the table of assembly folders.
             AddFoldersFromRegistryKey
@@ -146,8 +142,7 @@ private static void CreateAssemblyFolders()
         /// Returns the list of assembly folders that we're interested in.
         /// </summary>
         /// <param name="regKeyAlias">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
-        /// <returns>Collection of assembly folders.</returns>
-        static internal ICollection GetAssemblyFolders(string regKeyAlias)
+        internal static IEnumerable<string> GetAssemblyFolders(string regKeyAlias)
         {
             lock (s_syncLock)
             {
@@ -158,19 +153,22 @@ static internal ICollection GetAssemblyFolders(string regKeyAlias)
             }
 
             // If no specific alias was requested then return the complete list.
-            if (regKeyAlias == null || regKeyAlias.Length == 0)
+            if (string.IsNullOrEmpty(regKeyAlias))
             {
-                return s_assemblyFolders.Values;
+                foreach (string folder in s_assemblyFolders.Values)
+                {
+                    yield return folder;
+                }
             }
 
             // If a specific alias was requested then return only that alias.
-            ArrayList specificKey = new ArrayList();
-            string directory = (string)s_assemblyFolders[regKeyAlias];
-            if (directory != null && directory.Length > 0)
+            if (s_assemblyFolders.TryGetValue(regKeyAlias, out string directory))
             {
-                specificKey.Add(directory);
+                if (!string.IsNullOrEmpty(directory))
+                {
+                    yield return directory;
+                }
             }
-            return specificKey;
         }
     }
 }
diff --git a/src/Tasks/AssemblyInfo.cs b/src/Tasks/AssemblyInfo.cs
index 1008108c858..2a8c51f1613 100644
--- a/src/Tasks/AssemblyInfo.cs
+++ b/src/Tasks/AssemblyInfo.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Reflection;
 using System.Resources;
-using System.Security;
 using System.Runtime.InteropServices;
 using System.Runtime.CompilerServices;
 
diff --git a/src/Tasks/AssemblyRegistrationCache.cs b/src/Tasks/AssemblyRegistrationCache.cs
index 2a5c6c17602..63ae6fdd833 100644
--- a/src/Tasks/AssemblyRegistrationCache.cs
+++ b/src/Tasks/AssemblyRegistrationCache.cs
@@ -2,12 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.IO;
-using System.Runtime.Serialization;
-using System.Runtime.Serialization.Formatters.Binary;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
+using System.Collections.Generic;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -21,21 +16,12 @@ internal sealed class AssemblyRegistrationCache : StateFileBase
         /// <summary>
         /// The list of registered assembly files.
         /// </summary>
-        private ArrayList assemblies = null;
+        private readonly List<string> _assemblies = new List<string>();
 
         /// <summary>
         /// The list of registered type library files.
         /// </summary>
-        private ArrayList typeLibraries = null;
-
-        /// <summary>
-        /// Construct.
-        /// </summary>
-        internal AssemblyRegistrationCache()
-        {
-            assemblies = new ArrayList();
-            typeLibraries = new ArrayList();
-        }
+        private readonly List<string> _typeLibraries = new List<string>();
 
         /// <summary>
         /// The number of entries in the state file
@@ -44,34 +30,28 @@ internal int Count
         {
             get
             {
-                ErrorUtilities.VerifyThrow(assemblies.Count == typeLibraries.Count, "Internal assembly and type library lists should have the same number of entries in AssemblyRegistrationCache");
-                return assemblies.Count;
+                ErrorUtilities.VerifyThrow(_assemblies.Count == _typeLibraries.Count, "Internal assembly and type library lists should have the same number of entries in AssemblyRegistrationCache");
+                return _assemblies.Count;
             }
         }
 
         /// <summary>
         /// Sets the entry with the specified index
         /// </summary>
-        /// <param name="index"></param>
-        /// <param name="assemblyPath"></param>
-        /// <param name="typeLibraryPath"></param>
         internal void AddEntry(string assemblyPath, string typeLibraryPath)
         {
-            assemblies.Add(assemblyPath);
-            typeLibraries.Add(typeLibraryPath);
+            _assemblies.Add(assemblyPath);
+            _typeLibraries.Add(typeLibraryPath);
         }
 
         /// <summary>
         /// Gets the entry with the specified index
         /// </summary>
-        /// <param name="index"></param>
-        /// <param name="assemblyPath"></param>
-        /// <param name="typeLibraryPath"></param>
         internal void GetEntry(int index, out string assemblyPath, out string typeLibraryPath)
         {
-            ErrorUtilities.VerifyThrow((index >= 0) && (index < assemblies.Count), "Invalid index in the call to AssemblyRegistrationCache.GetEntry");
-            assemblyPath = (string)assemblies[index];
-            typeLibraryPath = (string)typeLibraries[index];
+            ErrorUtilities.VerifyThrow((index >= 0) && (index < _assemblies.Count), "Invalid index in the call to AssemblyRegistrationCache.GetEntry");
+            assemblyPath = _assemblies[index];
+            typeLibraryPath = _typeLibraries[index];
         }
     }
 }
diff --git a/src/Tasks/AssemblyRemapping.cs b/src/Tasks/AssemblyRemapping.cs
index decc7ddf749..523e97310bd 100644
--- a/src/Tasks/AssemblyRemapping.cs
+++ b/src/Tasks/AssemblyRemapping.cs
@@ -14,54 +14,31 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     internal class AssemblyRemapping : IEquatable<AssemblyRemapping>
     {
-        /// <summary>
-        /// The assemblyName we mapped from
-        /// </summary>
-        private readonly AssemblyNameExtension _from;
-
-        /// <summary>
-        /// The assemblyName we mapped to
-        /// </summary>
-        private readonly AssemblyNameExtension _to;
-
         /// <summary>
         /// Constructor
         /// </summary>
         public AssemblyRemapping(AssemblyNameExtension from, AssemblyNameExtension to)
         {
-            _from = from;
-            _to = to;
+            From = from;
+            To = to;
         }
 
         /// <summary>
         /// The assemblyName we mapped from
         /// </summary>
-        public AssemblyNameExtension From
-        {
-            get
-            {
-                return _from;
-            }
-        }
+        public AssemblyNameExtension From { get; }
 
         /// <summary>
         /// The assemblyName we mapped to
         /// </summary>
-        public AssemblyNameExtension To
-        {
-            get
-            {
-                return _to;
-            }
-        }
+        public AssemblyNameExtension To { get; }
 
         /// <summary>
         /// Compare two Assembly remapping objects
         /// </summary>
         public override bool Equals(object obj)
         {
-            AssemblyNameExtension name = obj as AssemblyNameExtension;
-            if (name == null)
+            if (!(obj is AssemblyNameExtension name))
             {
                 return false;
             }
@@ -74,7 +51,7 @@ public override bool Equals(object obj)
         /// </summary>
         public override int GetHashCode()
         {
-            return _from.GetHashCode();
+            return From.GetHashCode();
         }
 
         /// <summary>
@@ -82,7 +59,7 @@ public override int GetHashCode()
         /// </summary>
         public bool Equals(AssemblyRemapping other)
         {
-            return _from.Equals(other._from);
+            return From.Equals(other.From);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Tasks/AssemblyResources.cs b/src/Tasks/AssemblyResources.cs
index da09a2d66e9..49f192ddca3 100644
--- a/src/Tasks/AssemblyResources.cs
+++ b/src/Tasks/AssemblyResources.cs
@@ -16,17 +16,11 @@ internal static class AssemblyResources
         /// Loads the specified resource string, either from the assembly's primary resources, or its shared resources.
         /// </summary>
         /// <remarks>This method is thread-safe.</remarks>
-        /// <param name="name"></param>
         /// <returns>The resource string, or null if not found.</returns>
         internal static string GetString(string name)
         {
             // NOTE: the ResourceManager.GetString() method is thread-safe
-            string resource = s_resources.GetString(name, CultureInfo.CurrentUICulture);
-
-            if (resource == null)
-            {
-                resource = s_sharedResources.GetString(name, CultureInfo.CurrentUICulture);
-            }
+            string resource = PrimaryResources.GetString(name, CultureInfo.CurrentUICulture) ?? SharedResources.GetString(name, CultureInfo.CurrentUICulture);
 
             ErrorUtilities.VerifyThrow(resource != null, "Missing resource '{0}'", name);
 
@@ -38,30 +32,16 @@ internal static string GetString(string name)
         /// </summary>
         /// <remarks>This property is thread-safe.</remarks>
         /// <value>ResourceManager for primary resources.</value>
-        internal static ResourceManager PrimaryResources
-        {
-            get
-            {
-                return s_resources;
-            }
-        }
+        internal static ResourceManager PrimaryResources { get; } = new ResourceManager("Microsoft.Build.Tasks.Core.Strings", typeof(AssemblyResources).GetTypeInfo().Assembly);
 
         /// <summary>
         /// Gets the assembly's shared resources i.e. the resources this assembly shares with other assemblies.
         /// </summary>
         /// <remarks>This property is thread-safe.</remarks>
         /// <value>ResourceManager for shared resources.</value>
-        internal static ResourceManager SharedResources
-        {
-            get
-            {
-                return s_sharedResources;
-            }
-        }
+        internal static ResourceManager SharedResources { get; } = new ResourceManager("Microsoft.Build.Tasks.Core.Strings.shared", typeof(AssemblyResources).GetTypeInfo().Assembly);
 
         // assembly resources
-        private static readonly ResourceManager s_resources = new ResourceManager("Microsoft.Build.Tasks.Core.Strings", typeof(AssemblyResources).GetTypeInfo().Assembly);
         // shared resources
-        private static readonly ResourceManager s_sharedResources = new ResourceManager("Microsoft.Build.Tasks.Core.Strings.shared", typeof(AssemblyResources).GetTypeInfo().Assembly);
     }
 }
diff --git a/src/Tasks/AssignCulture.cs b/src/Tasks/AssignCulture.cs
index ec603235d07..81851321cf0 100644
--- a/src/Tasks/AssignCulture.cs
+++ b/src/Tasks/AssignCulture.cs
@@ -2,15 +2,9 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
-using System.Diagnostics;
-using System.Resources;
-using System.Reflection;
-using System.Globalization;
-using System.Collections;
+using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
 {
@@ -33,30 +27,13 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public class AssignCulture : TaskExtension
     {
-        /// <summary>
-        /// Constructor
-        /// </summary>
-        public AssignCulture()
-        {
-        }
-
         #region Properties
 
-        private ITaskItem[] _files = Array.Empty<TaskItem>();
-        private ITaskItem[] _assignedFiles = null;
-        private ITaskItem[] _assignedFilesWithCulture = null;
-        private ITaskItem[] _assignedFilesWithNoCulture = null;
-        private ITaskItem[] _cultureNeutralAssignedFiles = null;
-
         /// <summary>
         /// The incoming list of files to assign a culture to.
         /// </summary>
         [Required]
-        public ITaskItem[] Files
-        {
-            get { return _files; }
-            set { _files = value; }
-        }
+        public ITaskItem[] Files { get; set; } = Array.Empty<ITaskItem>();
 
         /// <summary>
         /// This outgoing list of files is exactly the same as the incoming Files
@@ -71,10 +48,7 @@ public ITaskItem[] Files
         /// that original attribute is used instead.
         /// </summary>
         [Output]
-        public ITaskItem[] AssignedFiles
-        {
-            get { return _assignedFiles; }
-        }
+        public ITaskItem[] AssignedFiles { get; private set; }
 
         /// <summary>
         /// This is a subset of AssignedFiles that has all of the items that
@@ -88,10 +62,7 @@ public ITaskItem[] AssignedFiles
         ///      AssignedFiles = AssignedFilesWithCulture + AssignedFilesWithNoCulture
         /// </summary>
         [Output]
-        public ITaskItem[] AssignedFilesWithCulture
-        {
-            get { return _assignedFilesWithCulture; }
-        }
+        public ITaskItem[] AssignedFilesWithCulture { get; private set; }
 
         /// <summary>
         /// This is a subset of AssignedFiles that has all of the items that
@@ -102,10 +73,7 @@ public ITaskItem[] AssignedFilesWithCulture
         ///      AssignedFiles = AssignedFilesWithCulture + AssignedFilesWithNoCulture
         /// </summary>
         [Output]
-        public ITaskItem[] AssignedFilesWithNoCulture
-        {
-            get { return _assignedFilesWithNoCulture; }
-        }
+        public ITaskItem[] AssignedFilesWithNoCulture { get; private set; }
 
         /// <summary>
         /// This list has the same number of items as the Files list or the
@@ -134,26 +102,22 @@ public ITaskItem[] AssignedFilesWithNoCulture
         /// because 'XX' is not a valid culture identifier.
         /// </summary>
         [Output]
-        public ITaskItem[] CultureNeutralAssignedFiles
-        {
-            get { return _cultureNeutralAssignedFiles; }
-        }
+        public ITaskItem[] CultureNeutralAssignedFiles { get; private set; }
 
         #endregion
 
         #region ITask Members
-
-
+        
         /// <summary>
         /// Execute.
         /// </summary>
         /// <returns></returns>
         public override bool Execute()
         {
-            _assignedFiles = new TaskItem[Files.Length];
-            _cultureNeutralAssignedFiles = new TaskItem[Files.Length];
-            ArrayList cultureList = new ArrayList();
-            ArrayList noCultureList = new ArrayList();
+            AssignedFiles = new ITaskItem[Files.Length];
+            CultureNeutralAssignedFiles = new ITaskItem[Files.Length];
+            var cultureList = new List<ITaskItem>();
+            var noCultureList = new List<ITaskItem>();
 
             bool retValue = true;
 
@@ -170,7 +134,7 @@ public override bool Execute()
                             dependentUpon
                         );
 
-                    if (info.culture != null && info.culture.Length > 0)
+                    if (!string.IsNullOrEmpty(info.culture))
                     {
                         AssignedFiles[i].SetMetadata("Culture", info.culture);
                         AssignedFiles[i].SetMetadata("WithCulture", "true");
@@ -182,8 +146,8 @@ public override bool Execute()
                         AssignedFiles[i].SetMetadata("WithCulture", "false");
                     }
 
-                    CultureNeutralAssignedFiles[i] = new TaskItem(AssignedFiles[i]);
-                    CultureNeutralAssignedFiles[i].ItemSpec = info.cultureNeutralFilename;
+                    CultureNeutralAssignedFiles[i] =
+                        new TaskItem(AssignedFiles[i]) { ItemSpec = info.cultureNeutralFilename };
 
                     Log.LogMessageFromResources
                     (
@@ -209,8 +173,8 @@ public override bool Execute()
 #endif
             }
 
-            _assignedFilesWithCulture = (ITaskItem[])cultureList.ToArray(typeof(ITaskItem));
-            _assignedFilesWithNoCulture = (ITaskItem[])noCultureList.ToArray(typeof(ITaskItem));
+            AssignedFilesWithCulture = cultureList.ToArray();
+            AssignedFilesWithNoCulture = noCultureList.ToArray();
 
             return retValue;
         }
diff --git a/src/Tasks/AssignLinkMetadata.cs b/src/Tasks/AssignLinkMetadata.cs
index a5d57dc097e..5bbba9a8bbe 100644
--- a/src/Tasks/AssignLinkMetadata.cs
+++ b/src/Tasks/AssignLinkMetadata.cs
@@ -10,7 +10,6 @@
 using Microsoft.Build.Utilities;
 using System;
 using System.Collections.Generic;
-using System.IO;
 
 namespace Microsoft.Build.Tasks
 {
@@ -22,21 +21,13 @@ public class AssignLinkMetadata : TaskExtension
         /// <summary>
         /// The set of items to assign metadata to
         /// </summary>
-        public ITaskItem[] Items
-        {
-            get;
-            set;
-        }
+        public ITaskItem[] Items { get; set; }
 
         /// <summary>
         /// The set of items to which the Link metadata has been set
         /// </summary>
         [Output]
-        public ITaskItem[] OutputItems
-        {
-            get;
-            set;
-        }
+        public ITaskItem[] OutputItems { get; set; }
 
         /// <summary>
         /// Sets "Link" metadata on any item where the project file in which they 
@@ -47,11 +38,11 @@ public ITaskItem[] OutputItems
         /// </summary>
         public override bool Execute()
         {
-            List<ITaskItem> outputItems = new List<ITaskItem>();
+            var outputItems = new List<ITaskItem>();
 
-            if (this.Items != null)
+            if (Items != null)
             {
-                foreach (var item in this.Items)
+                foreach (ITaskItem item in Items)
                 {
                     try
                     {
@@ -80,7 +71,7 @@ public override bool Execute()
                 }
             }
 
-            this.OutputItems = outputItems.ToArray();
+            OutputItems = outputItems.ToArray();
             return !Log.HasLoggedErrors;
         }
     }
diff --git a/src/Tasks/AssignProjectConfiguration.cs b/src/Tasks/AssignProjectConfiguration.cs
index 3d613352fed..2d9f517e631 100644
--- a/src/Tasks/AssignProjectConfiguration.cs
+++ b/src/Tasks/AssignProjectConfiguration.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
 using System.Xml;
@@ -14,47 +13,19 @@ namespace Microsoft.Build.Tasks
 {
     public class AssignProjectConfiguration : ResolveProjectBase
     {
-        #region Constructors
-
-        /// <summary>
-        /// default public constructor
-        /// </summary>
-        public AssignProjectConfiguration()
-        {
-            // do nothing
-        }
-
-        #endregion
-
         #region Properties
 
         /// <summary>
         /// A special XML string containing a project configuration for each project - we need to simply 
         /// match the projects and assign the appropriate configuration names to them
         /// </summary>
-        public string SolutionConfigurationContents
-        {
-            get
-            {
-                return _solutionConfigurationContents;
-            }
-            set
-            {
-                _solutionConfigurationContents = value;
-            }
-        }
-
-        private string _solutionConfigurationContents = null;
+        public string SolutionConfigurationContents { get; set; }
 
         /// <summary>
         /// Whether to use the solution dependency information passed in the solution blob
         /// to add synthetic project references for the purposes of build ordering
         /// </summary>
-        public bool AddSyntheticProjectReferencesForSolutionDependencies
-        {
-            get;
-            set;
-        }
+        public bool AddSyntheticProjectReferencesForSolutionDependencies { get; set; }
 
         /// <summary>
         /// String containing a semicolon-delimited list of mappings from the platform names used
@@ -66,15 +37,8 @@ public bool AddSyntheticProjectReferencesForSolutionDependencies
         [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Vcx", Justification = "Public API that has already shipped; VCX is a recognizable short form for .vcxproj")]
         public string DefaultToVcxPlatformMapping
         {
-            get
-            {
-                if (_defaultToVcxPlatformMapping == null)
-                {
-                    _defaultToVcxPlatformMapping = "AnyCPU=Win32;X86=Win32;X64=X64;Itanium=Itanium";
-                }
-
-                return _defaultToVcxPlatformMapping;
-            }
+            get => _defaultToVcxPlatformMapping ??
+                   (_defaultToVcxPlatformMapping = "AnyCPU=Win32;X86=Win32;X64=X64;Itanium=Itanium");
 
             set
             {
@@ -86,7 +50,7 @@ public string DefaultToVcxPlatformMapping
             }
         }
 
-        private string _defaultToVcxPlatformMapping = null;
+        private string _defaultToVcxPlatformMapping;
 
         /// <summary>
         /// String containing a semicolon-delimited list of mappings from .vcxproj platform names
@@ -126,150 +90,54 @@ public string VcxToDefaultPlatformMapping
             }
         }
 
-        private string _vcxToDefaultPlatformMapping = null;
+        private string _vcxToDefaultPlatformMapping;
 
         /// <summary>
         /// The current project's full path
         /// </summary>
-        public string CurrentProject
-        {
-            get;
-            set;
-        }
+        public string CurrentProject { get; set; }
 
         /// <summary>
         /// The current project's platform.
         /// </summary>
-        public string CurrentProjectConfiguration
-        {
-            get
-            {
-                return _currentProjectConfiguration;
-            }
-
-            set
-            {
-                _currentProjectConfiguration = value;
-            }
-        }
-
-        private string _currentProjectConfiguration;
+        public string CurrentProjectConfiguration { get; set; }
 
         /// <summary>
         /// The current project's platform.
         /// </summary>
-        public string CurrentProjectPlatform
-        {
-            get
-            {
-                return _currentProjectPlatform;
-            }
-
-            set
-            {
-                _currentProjectPlatform = value;
-            }
-        }
+        public string CurrentProjectPlatform { get; set; }
 
         /// <summary>
         /// Should we build references even if they were disabled in the project configuration
         /// </summary>
-        private bool _onlyReferenceAndBuildProjectsEnabledInSolutionConfiguration = false;
-
-        /// <summary>
-        /// Should we build references even if they were disabled in the project configuration
-        /// </summary>
-        public bool OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration
-        {
-            get
-            {
-                return _onlyReferenceAndBuildProjectsEnabledInSolutionConfiguration;
-            }
-
-            set
-            {
-                _onlyReferenceAndBuildProjectsEnabledInSolutionConfiguration = value;
-            }
-        }
+        public bool OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration { get; set; } = false;
 
         // Whether to set the project reference's GlobalPropertiesToRemove metadata to contain
         // Configuration and Platform. 
-        private bool _shouldUnsetParentConfigurationAndPlatform = false;
 
         /// <summary>
         /// Whether to set the GlobalPropertiesToRemove metadata on the project reference such that
         /// on an MSBuild call, the Configuration and Platform metadata will be unset, allowing the 
         /// child project to build in its default configuration / platform. 
         /// </summary>
-        public bool ShouldUnsetParentConfigurationAndPlatform
-        {
-            get
-            {
-                return _shouldUnsetParentConfigurationAndPlatform;
-            }
-
-            set
-            {
-                _shouldUnsetParentConfigurationAndPlatform = value;
-            }
-        }
-
-        private string _outputType;
+        public bool ShouldUnsetParentConfigurationAndPlatform { get; set; } = false;
 
         /// <summary>
         /// The output type for the project
         /// </summary>
-        public string OutputType
-        {
-            get
-            {
-                return _outputType;
-            }
-
-            set
-            {
-                _outputType = value;
-            }
-        }
-
-        private string _currentProjectPlatform;
+        public string OutputType { get; set; }
 
         /// <summary>
         /// True if we should use the default mappings to resolve the configuration/platform
         /// of the passed in project references, false otherwise.
         /// </summary>
-        public bool ResolveConfigurationPlatformUsingMappings
-        {
-            get
-            {
-                return _resolveConfigurationPlatformUsingMappings;
-            }
-
-            set
-            {
-                _resolveConfigurationPlatformUsingMappings = value;
-            }
-        }
-
-        private bool _resolveConfigurationPlatformUsingMappings;
+        public bool ResolveConfigurationPlatformUsingMappings { get; set; }
 
         /// <summary>
         /// The list of resolved reference paths (preserving the original project reference attributes)
         /// </summary>
         [Output]
-        public ITaskItem[] AssignedProjects
-        {
-            get
-            {
-                return _assignedProjects;
-            }
-            set
-            {
-                _assignedProjects = value;
-            }
-        }
-
-        private ITaskItem[] _assignedProjects = null;
+        public ITaskItem[] AssignedProjects { get; set; }
 
         /// <summary>
         /// The list of project reference items that could not be resolved using the pre-resolved list of outputs.
@@ -277,19 +145,7 @@ public ITaskItem[] AssignedProjects
         /// are in the MSBuild format.
         /// </summary>
         [Output]
-        public ITaskItem[] UnassignedProjects
-        {
-            get
-            {
-                return _unassignedProjects;
-            }
-            set
-            {
-                _unassignedProjects = value;
-            }
-        }
-
-        private ITaskItem[] _unassignedProjects = null;
+        public ITaskItem[] UnassignedProjects { get; set; }
 
         private const string attrFullConfiguration = "FullConfiguration";
         private const string buildReferenceMetadataName = "BuildReference";
@@ -300,11 +156,11 @@ public ITaskItem[] UnassignedProjects
         private const string attrSetConfiguration = "SetConfiguration";
         private const string attrSetPlatform = "SetPlatform";
 
-        private static readonly char[] s_configPlatformSeparator = new char[] { '|' };
+        private static readonly char[] s_configPlatformSeparator = { '|' };
 
         private IDictionary<string, string> _vcxToDefaultMap;
         private IDictionary<string, string> _defaultToVcxMap;
-        private bool _mappingsPopulated = false;
+        private bool _mappingsPopulated;
 
         #endregion
 
@@ -323,8 +179,8 @@ public override bool Execute()
                     return false;
                 }
 
-                ArrayList resolvedReferences = new ArrayList(ProjectReferences.GetLength(0));
-                ArrayList unresolvedReferences = new ArrayList(ProjectReferences.GetLength(0));
+                var resolvedReferences = new List<ITaskItem>(ProjectReferences.GetLength(0));
+                var unresolvedReferences = new List<ITaskItem>(ProjectReferences.GetLength(0));
 
                 if (!String.IsNullOrEmpty(SolutionConfigurationContents))
                 {
@@ -340,10 +196,7 @@ public override bool Execute()
 
                 foreach (ITaskItem projectRef in ProjectReferences)
                 {
-                    bool resolveSuccess = false;
-                    ITaskItem resolvedReference;
-
-                    resolveSuccess = ResolveProject(projectRef, out resolvedReference);
+                    bool resolveSuccess = ResolveProject(projectRef, out ITaskItem resolvedReference);
 
                     if (resolveSuccess)
                     {
@@ -365,9 +218,9 @@ public override bool Execute()
                                 globalPropertiesToRemove += ";";
                             }
 
-                            if (projectRef is ITaskItem2)
+                            if (projectRef is ITaskItem2 item2)
                             {
-                                ((ITaskItem2)projectRef).SetMetadataValueLiteral("GlobalPropertiesToRemove", globalPropertiesToRemove + "Configuration;Platform");
+                                item2.SetMetadataValueLiteral("GlobalPropertiesToRemove", globalPropertiesToRemove + "Configuration;Platform");
                             }
                             else
                             {
@@ -384,12 +237,12 @@ public override bool Execute()
                     }
                 }
 
-                AssignedProjects = (ITaskItem[])resolvedReferences.ToArray(typeof(ITaskItem));
-                UnassignedProjects = (ITaskItem[])unresolvedReferences.ToArray(typeof(ITaskItem));
+                AssignedProjects = resolvedReferences.ToArray();
+                UnassignedProjects = unresolvedReferences.ToArray();
             }
             catch (XmlException e)
             {
-                Log.LogErrorWithCodeFromResources("General.ErrorExecutingTask", this.GetType().Name, e.Message);
+                Log.LogErrorWithCodeFromResources("General.ErrorExecutingTask", GetType().Name, e.Message);
                 return false;
             }
 
@@ -399,16 +252,11 @@ public override bool Execute()
         #endregion
 
         #region Methods
-
-
+        
         /// <summary>
         /// Given a project reference task item and an XML document containing project configurations, 
         /// find the configuration for that task item.
         /// </summary>
-        /// <param name="resolvedPath">
-        /// resulting ITaskItem containing the resolved project item with the FullConfiguration, 
-        /// Configuration and Platform attributes
-        /// </param>
         /// <returns>true if resolved successfully</returns>
         internal bool ResolveProject(ITaskItem projectRef, out ITaskItem resolvedProjectWithConfiguration)
         {
@@ -432,7 +280,7 @@ internal bool ResolveProject(ITaskItem projectRef, out ITaskItem resolvedProject
                     SetupDefaultPlatformMappings();
                 }
 
-                string transformedPlatform = null;
+                string transformedPlatform;
 
                 if (String.Equals(projectRef.GetMetadata("Extension"), ".vcxproj", StringComparison.OrdinalIgnoreCase))
                 {
@@ -450,31 +298,28 @@ internal bool ResolveProject(ITaskItem projectRef, out ITaskItem resolvedProject
                 }
             }
 
-            SetBuildInProjectAndReferenceOutputAssemblyMetadata(_onlyReferenceAndBuildProjectsEnabledInSolutionConfiguration, projectRef, projectConfigurationElement);
+            SetBuildInProjectAndReferenceOutputAssemblyMetadata(OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration, projectRef, projectConfigurationElement);
 
-            if (projectConfiguration != null)
+            if (!string.IsNullOrEmpty(projectConfiguration))
             {
-                if (!string.IsNullOrEmpty(projectConfiguration))
-                {
-                    resolvedProjectWithConfiguration = projectRef;
-                    resolvedProjectWithConfiguration.SetMetadata(attrFullConfiguration, projectConfiguration);
+                resolvedProjectWithConfiguration = projectRef;
+                resolvedProjectWithConfiguration.SetMetadata(attrFullConfiguration, projectConfiguration);
 
-                    string[] configurationPlatformParts = projectConfiguration.Split(s_configPlatformSeparator);
-                    resolvedProjectWithConfiguration.SetMetadata(attrSetConfiguration, "Configuration=" + configurationPlatformParts[0]);
-                    resolvedProjectWithConfiguration.SetMetadata(attrConfiguration, configurationPlatformParts[0]);
+                string[] configurationPlatformParts = projectConfiguration.Split(s_configPlatformSeparator);
+                resolvedProjectWithConfiguration.SetMetadata(attrSetConfiguration, "Configuration=" + configurationPlatformParts[0]);
+                resolvedProjectWithConfiguration.SetMetadata(attrConfiguration, configurationPlatformParts[0]);
 
-                    if (configurationPlatformParts.Length > 1)
-                    {
-                        resolvedProjectWithConfiguration.SetMetadata(attrSetPlatform, "Platform=" + configurationPlatformParts[1]);
-                        resolvedProjectWithConfiguration.SetMetadata(attrPlatform, configurationPlatformParts[1]);
-                    }
-                    else
-                    {
-                        resolvedProjectWithConfiguration.SetMetadata(attrSetPlatform, "Platform=");
-                    }
-
-                    return true;
+                if (configurationPlatformParts.Length > 1)
+                {
+                    resolvedProjectWithConfiguration.SetMetadata(attrSetPlatform, "Platform=" + configurationPlatformParts[1]);
+                    resolvedProjectWithConfiguration.SetMetadata(attrPlatform, configurationPlatformParts[1]);
                 }
+                else
+                {
+                    resolvedProjectWithConfiguration.SetMetadata(attrSetPlatform, "Platform=");
+                }
+
+                return true;
             }
 
             resolvedProjectWithConfiguration = null;
@@ -489,13 +334,11 @@ internal static void SetBuildInProjectAndReferenceOutputAssemblyMetadata(bool on
         {
             if (projectConfigurationElement != null && resolvedProjectWithConfiguration != null && onlyReferenceAndBuildProjectsEnabledInSolutionConfiguration)
             {
-                bool buildProject = false;
-
                 // The value of the specified attribute. An empty string is returned if a matching attribute is not found or if the attribute does not have a specified or default value. 
                 string buildProjectInSolution = projectConfigurationElement.GetAttribute(buildProjectInSolutionAttribute);
 
                 // We could not parse out what was in the attribute, act as if it was not set in the first place. 
-                if (bool.TryParse(buildProjectInSolution, out buildProject))
+                if (bool.TryParse(buildProjectInSolution, out bool buildProject))
                 {
                     // If we do not want to build references disabled in the solution configuration blob   
                     // and the solution configuration indicates the build for this project is disabled 
@@ -553,7 +396,7 @@ private void PopulateMappingDictionary(IDictionary<string, string> map, string m
             {
                 string[] platforms = mapping.Split('=');
 
-                if (platforms == null || platforms.Length != 2)
+                if (platforms.Length != 2)
                 {
                     Log.LogErrorFromResources("AssignProjectConfiguration.IllegalMappingString", mapping.Trim(), mappingList);
                 }
diff --git a/src/Tasks/AssignTargetPath.cs b/src/Tasks/AssignTargetPath.cs
index 5d61309695c..4c9f16e77c4 100644
--- a/src/Tasks/AssignTargetPath.cs
+++ b/src/Tasks/AssignTargetPath.cs
@@ -3,11 +3,6 @@
 
 using System;
 using System.IO;
-using System.Diagnostics;
-using System.Resources;
-using System.Reflection;
-using System.Globalization;
-using System.Collections;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
@@ -20,47 +15,25 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public class AssignTargetPath : TaskExtension
     {
-        /// <summary>
-        /// Construct.
-        /// </summary>
-        public AssignTargetPath()
-        {
-        }
-
         #region Properties
 
-        private string _rootFolder = null;
-        private ITaskItem[] _files = Array.Empty<ITaskItem>();
-        private ITaskItem[] _assignedFiles = null;
-
         /// <summary>
         /// The folder to make the links relative to.
         /// </summary>
         [Required]
-        public string RootFolder
-        {
-            get { return _rootFolder; }
-            set { _rootFolder = value; }
-        }
+        public string RootFolder { get; set; }
 
         /// <summary>
         /// The incoming list of files.
         /// </summary>
-        public ITaskItem[] Files
-        {
-            get { return _files; }
-            set { _files = value; }
-        }
+        public ITaskItem[] Files { get; set; } = Array.Empty<ITaskItem>();
 
         /// <summary>
         /// The resulting list of files.
         /// </summary>
         /// <value></value>
         [Output]
-        public ITaskItem[] AssignedFiles
-        {
-            get { return _assignedFiles; }
-        }
+        public ITaskItem[] AssignedFiles { get; private set; }
 
         #endregion
 
@@ -70,14 +43,14 @@ public ITaskItem[] AssignedFiles
         /// <returns></returns>
         public override bool Execute()
         {
-            _assignedFiles = new TaskItem[Files.Length];
+            AssignedFiles = new ITaskItem[Files.Length];
 
             if (Files.Length > 0)
             {
                 // Compose a file in the root folder.
                 // NOTE: at this point fullRootPath may or may not have a trailing
                 // slash because Path.GetFullPath() does not add or remove it
-                string fullRootPath = Path.GetFullPath(this.RootFolder);
+                string fullRootPath = Path.GetFullPath(RootFolder);
 
                 // Ensure trailing slash otherwise c:\bin appears to match part of c:\bin2\foo
                 fullRootPath = FileUtilities.EnsureTrailingSlash(fullRootPath);
@@ -104,7 +77,7 @@ public override bool Execute()
                     // If file has a link, use that.
                     string targetPath = link;
 
-                    if (link == null || link.Length == 0)
+                    if (string.IsNullOrEmpty(link))
                     {
                         if (// if the file path is relative
                             !Path.IsPathRooted(Files[i].ItemSpec) &&
diff --git a/src/Tasks/AxImp.cs b/src/Tasks/AxImp.cs
index 8c85449046f..23e36b89917 100644
--- a/src/Tasks/AxImp.cs
+++ b/src/Tasks/AxImp.cs
@@ -52,8 +52,8 @@ AxImp OcxName [Options]
             /// </summary>
             public string ActiveXControlName
             {
-                get { return (string)Bag["ActiveXControlName"]; }
-                set { Bag["ActiveXControlName"] = value; }
+                get => (string)Bag[nameof(ActiveXControlName)];
+                set => Bag[nameof(ActiveXControlName)] = value;
             }
 
             /// <summary>
@@ -61,8 +61,8 @@ public string ActiveXControlName
             /// </summary>
             public bool GenerateSource
             {
-                get { return GetBoolParameterWithDefault("GenerateSource", false); }
-                set { Bag["GenerateSource"] = value; }
+                get => GetBoolParameterWithDefault(nameof(GenerateSource), false);
+                set => Bag[nameof(GenerateSource)] = value;
             }
 
             /// <summary>
@@ -70,8 +70,8 @@ public bool GenerateSource
             /// </summary>
             public bool NoLogo
             {
-                get { return GetBoolParameterWithDefault("NoLogo", false); }
-                set { Bag["NoLogo"] = value; }
+                get => GetBoolParameterWithDefault(nameof(NoLogo), false);
+                set => Bag[nameof(NoLogo)] = value;
             }
 
             /// <summary>
@@ -79,8 +79,8 @@ public bool NoLogo
             /// </summary>
             public string OutputAssembly
             {
-                get { return (string)Bag["OutputAssembly"]; }
-                set { Bag["OutputAssembly"] = value; }
+                get => (string)Bag[nameof(OutputAssembly)];
+                set => Bag[nameof(OutputAssembly)] = value;
             }
 
             /// <summary>
@@ -88,8 +88,8 @@ public string OutputAssembly
             /// </summary>
             public string RuntimeCallableWrapperAssembly
             {
-                get { return (string)Bag["RuntimeCallableWrapperAssembly"]; }
-                set { Bag["RuntimeCallableWrapperAssembly"] = value; }
+                get => (string)Bag[nameof(RuntimeCallableWrapperAssembly)];
+                set => Bag[nameof(RuntimeCallableWrapperAssembly)] = value;
             }
 
             /// <summary>
@@ -97,8 +97,8 @@ public string RuntimeCallableWrapperAssembly
             /// </summary>
             public bool Silent
             {
-                get { return GetBoolParameterWithDefault("Silent", false); }
-                set { Bag["Silent"] = value; }
+                get => GetBoolParameterWithDefault(nameof(Silent), false);
+                set => Bag[nameof(Silent)] = value;
             }
 
             /// <summary>
@@ -106,8 +106,8 @@ public bool Silent
             /// </summary>
             public bool Verbose
             {
-                get { return GetBoolParameterWithDefault("Verbose", false); }
-                set { Bag["Verbose"] = value; }
+                get => GetBoolParameterWithDefault(nameof(Verbose), false);
+                set => Bag[nameof(Verbose)] = value;
             }
 
             #endregion // Properties
@@ -117,10 +117,7 @@ public bool Verbose
             /// <summary>
             /// Returns the name of the tool to execute
             /// </summary>
-            protected override string ToolName
-            {
-                get { return "AxImp.exe"; }
-            }
+            protected override string ToolName => "AxImp.exe";
 
             /// <summary>
             /// Fills the provided CommandLineBuilderExtension with all the command line options used when
@@ -162,4 +159,4 @@ protected override bool ValidateParameters()
             #endregion // ToolTask Members
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Tasks/AxReference.cs b/src/Tasks/AxReference.cs
index 1a86245ee2c..39a4ddf71a5 100644
--- a/src/Tasks/AxReference.cs
+++ b/src/Tasks/AxReference.cs
@@ -43,32 +43,24 @@ internal AxReference(TaskLoggingHelper taskLoggingHelper, bool silent, IComRefer
 
         #region Methods
 
-        /*
-         * Method:  GetWrapperFileName
-         * 
-         * Constructs the wrapper file name from a type library name.
-         */
+        /// <summary>
+        /// Constructs the wrapper file name from a type library name.
+        /// </summary>
         protected override string GetWrapperFileNameInternal(string typeLibName)
         {
             return GetWrapperFileName("AxInterop.", typeLibName, IncludeTypeLibVersionInName, ReferenceInfo.attr.wMajorVerNum, ReferenceInfo.attr.wMinorVerNum);
         }
 
-        /*
-         * Method:  GenerateWrapper
-         * 
-         * Generates a wrapper for this reference.
-         */
+        /// <summary>
+        /// Generates a wrapper for this reference.
+        /// </summary>
         internal bool GenerateWrapper(out ComReferenceWrapperInfo wrapperInfo)
         {
             wrapperInfo = null;
 
             // The tool gets the public key for itself, but we get it here anyway to
             // give nice messages in errors cases.
-            StrongNameKeyPair keyPair = null;
-            byte[] publicKey = null;
-            GetAndValidateStrongNameKey(out keyPair, out publicKey);
-
-            bool generateWrapperSucceeded = true;
+            GetAndValidateStrongNameKey(out _, out _);
 
             string tlbName = ReferenceInfo.taskItem.GetMetadata(ComReferenceItemMetadataNames.tlbReferenceName);
 
@@ -90,7 +82,7 @@ internal bool GenerateWrapper(out ComReferenceWrapperInfo wrapperInfo)
             axImp.KeyContainer = KeyContainer;
             axImp.KeyFile = KeyFile;
             axImp.Silent = Silent;
-            if (ReferenceInfo != null && ReferenceInfo.primaryOfAxImpRef != null && ReferenceInfo.primaryOfAxImpRef.resolvedWrapper != null && ReferenceInfo.primaryOfAxImpRef.resolvedWrapper.path != null)
+            if (ReferenceInfo?.primaryOfAxImpRef?.resolvedWrapper?.path != null)
             {
                 // This path should hit unless there was a prior resolution error or bug in the resolution code.
                 // The reason is that everything (tlbs and pias) gets resolved before AxImp references.
@@ -98,13 +90,12 @@ internal bool GenerateWrapper(out ComReferenceWrapperInfo wrapperInfo)
             }
             axImp.OutputAssembly = Path.Combine(OutputDirectory, GetWrapperFileName());
 
-            generateWrapperSucceeded = axImp.Execute();
+            bool generateWrapperSucceeded = axImp.Execute();
 
             string wrapperPath = GetWrapperPath();
 
             // store the wrapper info...
-            wrapperInfo = new ComReferenceWrapperInfo();
-            wrapperInfo.path = wrapperPath;
+            wrapperInfo = new ComReferenceWrapperInfo { path = wrapperPath };
             wrapperInfo.assembly = Assembly.UnsafeLoadFrom(wrapperInfo.path);
 
             // ...and we're done!
diff --git a/src/Tasks/AxTlbBaseReference.cs b/src/Tasks/AxTlbBaseReference.cs
index eda9139a9cf..bea3cab734b 100644
--- a/src/Tasks/AxTlbBaseReference.cs
+++ b/src/Tasks/AxTlbBaseReference.cs
@@ -7,21 +7,15 @@
 using System.Reflection;
 using System.Text;
 
-// TYPELIBATTR clashes with the one in InteropServices.
-using TYPELIBATTR = System.Runtime.InteropServices.ComTypes.TYPELIBATTR;
-
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
 {
-    /*
-     * Class:   AxTlbBaseReference
-     * 
-     * Common abstract base for aximp and tlbimp COM reference wrapper classes. 
-     * They share the resolution method and only differ in constructing the wrapper file name.
-     *
-     */
+    /// <summary>
+    /// Common abstract base for aximp and tlbimp COM reference wrapper classes. 
+    /// They share the resolution method and only differ in constructing the wrapper file name.
+    /// </summary>
     internal abstract class AxTlbBaseReference : ComReference
     {
         #region Constructors	
@@ -37,14 +31,14 @@ internal abstract class AxTlbBaseReference : ComReference
         /// <param name="keyFile">file containing public/private keys</param>
         /// <param name="keyContainer">container name for public/private keys</param>
         /// <param name="executeAsTool">True if GenerateWrapper() should generate the wrapper out-of-proc using aximp.exe or tlbimp.exe</param>
-        /// <param name="sdkToolsPath">Path to the SDK tools directory where aximp.exe or tlbimp.exe can be found</param>
+        /// <param name="toolPath">Path to the SDK tools directory where aximp.exe or tlbimp.exe can be found</param>
         /// <param name="buildEngine">BuildEngine of parent task; needed for logging purposes when generating wrapper out-of-proc</param>
         internal AxTlbBaseReference(TaskLoggingHelper taskLoggingHelper, bool silent, IComReferenceResolver resolverCallback, ComReferenceInfo referenceInfo, string itemName, string outputDirectory, bool delaySign, string keyFile, string keyContainer, bool includeTypeLibVersionInName, bool executeAsTool, string toolPath, IBuildEngine buildEngine, string[] environmentVariables)
             : base(taskLoggingHelper, silent, referenceInfo, itemName)
         {
-            _resolverCallback = resolverCallback;
-            _outputDirectory = outputDirectory;
-            _includeTypeLibVersionInName = includeTypeLibVersionInName;
+            ResolverCallback = resolverCallback;
+            OutputDirectory = outputDirectory;
+            IncludeTypeLibVersionInName = includeTypeLibVersionInName;
 
             BuildEngine = buildEngine;
             EnvironmentVariables = environmentVariables;
@@ -62,28 +56,12 @@ internal AxTlbBaseReference(TaskLoggingHelper taskLoggingHelper, bool silent, IC
         /// <summary>
         /// directory we should write the wrapper to
         /// </summary>
-        protected virtual string OutputDirectory
-        {
-            get
-            {
-                return _outputDirectory;
-            }
-        }
-
-        private string _outputDirectory;
+        protected virtual string OutputDirectory { get; }
 
         /// <summary>
         /// callback interface for resolving dependent COM refs/NET assemblies
         /// </summary>
-        protected IComReferenceResolver ResolverCallback
-        {
-            get
-            {
-                return _resolverCallback;
-            }
-        }
-
-        private IComReferenceResolver _resolverCallback;
+        protected IComReferenceResolver ResolverCallback { get; }
 
         /// <summary>
         /// container name for public/private keys
@@ -128,30 +106,15 @@ protected IComReferenceResolver ResolverCallback
         /// <summary>
         /// When true, we include the typelib version number in the name.
         /// </summary>
-        protected bool IncludeTypeLibVersionInName
-        {
-            get
-            {
-                return _includeTypeLibVersionInName;
-            }
-
-            set
-            {
-                _includeTypeLibVersionInName = value;
-            }
-        }
-
-        private bool _includeTypeLibVersionInName;
+        protected bool IncludeTypeLibVersionInName { get; set; }
 
         #endregion
 
         #region Methods
 
-        /*
-         * Method:  FindExistingWrapper
-         * 
-         * Checks if there's a preexisting wrapper for this reference.
-         */
+        /// <summary>
+        /// Checks if there's a preexisting wrapper for this reference. 
+        /// </summary>
         internal override bool FindExistingWrapper(out ComReferenceWrapperInfo wrapperInfo, DateTime componentTimestamp)
         {
             wrapperInfo = null;
@@ -164,33 +127,36 @@ internal override bool FindExistingWrapper(out ComReferenceWrapperInfo wrapperIn
                 return false;
             }
 
-            wrapperInfo = new ComReferenceWrapperInfo();
-            wrapperInfo.path = wrapperPath;
+            wrapperInfo = new ComReferenceWrapperInfo { path = wrapperPath };
 
             return IsWrapperUpToDate(wrapperInfo, componentTimestamp);
         }
 
-        /*
-         * Method:  IsWrapperUpToDate
-         * 
-         * Checks if the existing wrapper is up to date.
-         */
+        /// <summary>
+        /// Checks if the existing wrapper is up to date.
+        /// </summary>
         protected virtual bool IsWrapperUpToDate(ComReferenceWrapperInfo wrapperInfo, DateTime componentTimestamp)
         {
-            Debug.Assert(ReferenceInfo.strippedTypeLibPath != null && ReferenceInfo.strippedTypeLibPath.Length > 0, "ReferenceInfo.path should be valid if we got here");
-            if (ReferenceInfo.strippedTypeLibPath == null || ReferenceInfo.strippedTypeLibPath.Length == 0)
+            Debug.Assert(!string.IsNullOrEmpty(ReferenceInfo.strippedTypeLibPath), "ReferenceInfo.path should be valid if we got here");
+            if (string.IsNullOrEmpty(ReferenceInfo.strippedTypeLibPath))
+            {
                 throw new ComReferenceResolutionException();
+            }
 
             // if wrapper doesn't exist, wrapper is obviously not up to date
             if (!File.Exists(wrapperInfo.path))
+            {
                 return false;
+            }
 
             // if typelib file has a DIFFERENT last write time, wrapper is not up to date
             // the reason we're comparing write times in an unusual way is that type libraries are unusual
             // "source files" for wrappers. If you upgrade/downgrade a system component, its write
             // time may be earlier than before but we should still regenerate the wrapper.
             if (DateTime.Compare(File.GetLastWriteTime(ReferenceInfo.strippedTypeLibPath), componentTimestamp) != 0)
+            {
                 return false;
+            }
 
             // Compare our the existing wrapper's strong name state to the one we are requesting. 
             if (!SigningRequirementsMatchExistingWrapper(wrapperInfo))
@@ -212,22 +178,18 @@ protected virtual bool IsWrapperUpToDate(ComReferenceWrapperInfo wrapperInfo, Da
             return (wrapperInfo.assembly != null);
         }
 
-        /*
-         * Method:  GetWrapperPath
-         * 
-         * Constructs the wrapper file path. 
-         */
+        /// <summary>
+        /// Constructs the wrapper file path. 
+        /// </summary>
         internal string GetWrapperPath()
         {
             // combine with the specified output directory
             return Path.Combine(OutputDirectory, GetWrapperFileName());
         }
 
-        /*
-         * Method:  GetWrapperFileName
-         * 
-         * Helper method for constructing wrapper file name.
-         */
+        /// <summary>
+        /// Helper method for constructing wrapper file name.
+        /// </summary>
         internal string GetWrapperFileName()
         {
             return GetWrapperFileNameInternal(ReferenceInfo.typeLibName);
@@ -236,9 +198,12 @@ internal string GetWrapperFileName()
         /*
          * Method:  GetWrapperFileName
          * 
-         * Constructs the wrapper file name from a type library name. Specialized wrappers must override it if 
-         * they want to use the Resolve method from this class.
+         * 
          */
+        /// <summary>
+        /// Constructs the wrapper file name from a type library name. Specialized wrappers must override it if 
+        /// they want to use the Resolve method from this class.
+        /// </summary>
         protected abstract string GetWrapperFileNameInternal(string typeLibName);
 
         /// <summary>
@@ -257,7 +222,7 @@ internal static string GetWrapperFileName(string interopDllHeader, string typeLi
             // XXX = the header ("Interop." or the like)
             // YYY = typeLibName
             // Z.W = optional TLB version number
-            StringBuilder builder = new StringBuilder(interopDllHeader);
+            var builder = new StringBuilder(interopDllHeader);
             builder.Append(typeLibName);
 
             if (includeTypeLibVersionInName)
@@ -306,12 +271,12 @@ internal void GetAndValidateStrongNameKey(out StrongNameKeyPair keyPair, out byt
                 // to fully sign the assembly. (only if either KeyContainer or KeyFile was specified though)
                 if (keyPair == null)
                 {
-                    if (KeyContainer != null && KeyContainer.Length > 0)
+                    if (!string.IsNullOrEmpty(KeyContainer))
                     {
                         Log.LogErrorWithCodeFromResources(null, ReferenceInfo.SourceItemSpec, 0, 0, 0, 0, "ResolveComReference.StrongNameUtils.NoKeyPairInContainer", KeyContainer);
                         throw new StrongNameException();
                     }
-                    else if (KeyFile != null && KeyFile.Length > 0)
+                    if (!string.IsNullOrEmpty(KeyFile))
                     {
                         Log.LogErrorWithCodeFromResources(null, ReferenceInfo.SourceItemSpec, 0, 0, 0, 0, "ResolveComReference.StrongNameUtils.NoKeyPairInFile", KeyFile);
                         throw new StrongNameException();
@@ -329,16 +294,9 @@ private bool SigningRequirementsMatchExistingWrapper(ComReferenceWrapperInfo wra
         {
             StrongNameLevel desiredStrongNameLevel = StrongNameLevel.None;
 
-            if ((KeyFile != null && KeyFile.Length > 0) || (KeyContainer != null && KeyContainer.Length > 0))
+            if (!string.IsNullOrEmpty(KeyFile) || !string.IsNullOrEmpty(KeyContainer))
             {
-                if (DelaySign)
-                {
-                    desiredStrongNameLevel = StrongNameLevel.DelaySigned;
-                }
-                else
-                {
-                    desiredStrongNameLevel = StrongNameLevel.FullySigned;
-                }
+                desiredStrongNameLevel = DelaySign ? StrongNameLevel.DelaySigned : StrongNameLevel.FullySigned;
             }
 
             // ...and see what we have already
@@ -354,11 +312,8 @@ private bool SigningRequirementsMatchExistingWrapper(ComReferenceWrapperInfo wra
             if (desiredStrongNameLevel == StrongNameLevel.DelaySigned ||
                 desiredStrongNameLevel == StrongNameLevel.FullySigned)
             {
-                StrongNameKeyPair snkPair;
-                byte[] desiredPublicKey = null;
-
                 // get desired public key
-                StrongNameUtils.GetStrongNameKey(Log, KeyFile, KeyContainer, out snkPair, out desiredPublicKey);
+                StrongNameUtils.GetStrongNameKey(Log, KeyFile, KeyContainer, out _, out byte[] desiredPublicKey);
 
                 // get current public key
                 AssemblyName assemblyName = AssemblyName.GetAssemblyName(wrapperInfo.path);
diff --git a/src/Tasks/AxTlbBaseTask.cs b/src/Tasks/AxTlbBaseTask.cs
index 156e0a3f62f..fe574137b44 100644
--- a/src/Tasks/AxTlbBaseTask.cs
+++ b/src/Tasks/AxTlbBaseTask.cs
@@ -23,7 +23,7 @@ internal abstract class AxTlbBaseTask : ToolTaskExtension
         /// we should pass the file using the /publickey: parameter instead of
         /// /keyfile. 
         /// </summary>
-        private bool _delaySigningAndKeyFileOnlyContainsPublicKey = false;
+        private bool _delaySigningAndKeyFileOnlyContainsPublicKey;
 
         #endregion
 
@@ -33,8 +33,8 @@ internal abstract class AxTlbBaseTask : ToolTaskExtension
         /// </summary>
         public bool DelaySign
         {
-            get { return GetBoolParameterWithDefault("DelaySign", false); }
-            set { Bag["DelaySign"] = value; }
+            get => GetBoolParameterWithDefault(nameof(DelaySign), false);
+            set => Bag[nameof(DelaySign)] = value;
         }
 
         /// <summary>
@@ -42,8 +42,8 @@ public bool DelaySign
         /// </summary>
         public string KeyContainer
         {
-            get { return (string)Bag["KeyContainer"]; }
-            set { Bag["KeyContainer"] = value; }
+            get => (string)Bag[nameof(KeyContainer)];
+            set => Bag[nameof(KeyContainer)] = value;
         }
 
         /// <summary>
@@ -51,8 +51,8 @@ public string KeyContainer
         /// </summary>
         public string KeyFile
         {
-            get { return (string)Bag["KeyFile"]; }
-            set { Bag["KeyFile"] = value; }
+            get => (string)Bag[nameof(KeyFile)];
+            set => Bag[nameof(KeyFile)] = value;
         }
 
         /// <summary>
@@ -60,8 +60,8 @@ public string KeyFile
         /// </summary>
         public string SdkToolsPath
         {
-            get { return (string)Bag["SdkToolsPath"]; }
-            set { Bag["SdkToolsPath"] = value; }
+            get => (string)Bag[nameof(SdkToolsPath)];
+            set => Bag[nameof(SdkToolsPath)] = value;
         }
 
         #endregion // Properties
@@ -73,13 +73,7 @@ public string SdkToolsPath
         /// executable, so return null for the ToolName -- And make sure that 
         /// Execute() logs an error!
         /// </summary>
-        protected override string ToolName
-        {
-            get
-            {
-                return null;
-            }
-        }
+        protected override string ToolName { get; } = null;
 
         /// <summary>
         /// Invokes the ToolTask with the given parameters
@@ -119,7 +113,7 @@ protected override string GenerateFullPathToTool()
             pathToTool = SdkToolsPathUtility.GeneratePathToTool
             (
                 SdkToolsPathUtility.FileInfoExists,
-                Microsoft.Build.Utilities.ProcessorArchitecture.CurrentProcessArchitecture,
+                Utilities.ProcessorArchitecture.CurrentProcessArchitecture,
                 SdkToolsPath,
                 ToolName,
                 Log,
@@ -150,10 +144,7 @@ protected override bool ValidateParameters()
                 // as we're concerned, parameters check out properly
                 return base.ValidateParameters();
             }
-            else
-            {
-                return false;
-            }
+            return false;
         }
 
         /// <summary>
@@ -190,7 +181,6 @@ private void AddStrongNameOptions(CommandLineBuilderExtension commandLine)
         private bool ValidateStrongNameParameters()
         {
             bool keyFileExists = false;
-            bool keyContainerSpecified = false;
 
             // Make sure that if KeyFile is defined, it's a real file.
             if (!String.IsNullOrEmpty(KeyFile))
@@ -207,7 +197,7 @@ private bool ValidateStrongNameParameters()
             }
 
             // Check if KeyContainer name is specified
-            keyContainerSpecified = !String.IsNullOrEmpty(KeyContainer);
+            bool keyContainerSpecified = !String.IsNullOrEmpty(KeyContainer);
 
             // Cannot define both KeyFile and KeyContainer
             if (keyFileExists && keyContainerSpecified)
@@ -227,7 +217,7 @@ private bool ValidateStrongNameParameters()
             // even just a public key)
             if (keyFileExists || keyContainerSpecified)
             {
-                StrongNameKeyPair keyPair = null;
+                StrongNameKeyPair keyPair;
                 byte[] publicKey = null;
 
                 try
@@ -249,7 +239,7 @@ private bool ValidateStrongNameParameters()
                         Log.LogErrorWithCodeFromResources("AxTlbBaseTask.StrongNameUtils.NoPublicKeySpecified");
                         return false;
                     }
-                    else if (keyPair == null)
+                    if (keyPair == null)
                     {
                         // record this so we know which switch to pass to the task
                         _delaySigningAndKeyFileOnlyContainsPublicKey = true;
@@ -264,7 +254,7 @@ private bool ValidateStrongNameParameters()
                             Log.LogErrorWithCodeFromResources("AxTlbBaseTask.StrongNameUtils.NoKeyPairInContainer", KeyContainer);
                             return false;
                         }
-                        else if (!String.IsNullOrEmpty(KeyFile))
+                        if (!String.IsNullOrEmpty(KeyFile))
                         {
                             Log.LogErrorWithCodeFromResources("AxTlbBaseTask.StrongNameUtils.NoKeyPairInFile", KeyFile);
                             return false;
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index 6b34cdbc6ad..87f85dd334e 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -3,12 +3,12 @@
 
 using Microsoft.Build.Shared;
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.IO;
+using System.Linq;
 using System.Reflection;
 using System.Runtime.InteropServices;
 using System.Security.Cryptography.X509Certificates;
@@ -22,7 +22,7 @@ namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
     /// <summary>
     /// This class is the top-level object for the bootstrapper system.
     /// </summary>
-    [ComVisibleAttribute(true), GuidAttribute("1D9FE38A-0226-4b95-9C6B-6DFFA2236270"), ClassInterface(ClassInterfaceType.None)]
+    [ComVisible(true), Guid("1D9FE38A-0226-4b95-9C6B-6DFFA2236270"), ClassInterface(ClassInterfaceType.None)]
     public class BootstrapperBuilder : IBootstrapperBuilder
     {
         private static readonly bool s_logging = !String.IsNullOrEmpty(Environment.GetEnvironmentVariable("VSPLOG"));
@@ -32,13 +32,12 @@ public class BootstrapperBuilder : IBootstrapperBuilder
         private XmlDocument _document;
 
         private XmlNamespaceManager _xmlNamespaceManager;
-        private ProductCollection _products = new ProductCollection();
-        private Hashtable _cultures = new Hashtable();
-        private Hashtable _validationResults = new Hashtable();
+        private readonly ProductCollection _products = new ProductCollection();
+        private readonly Dictionary<string, XmlNode> _cultures = new Dictionary<string, XmlNode>(StringComparer.OrdinalIgnoreCase);
+        private readonly Dictionary<string, ProductValidationResults> _validationResults = new Dictionary<string, ProductValidationResults>(StringComparer.Ordinal);
         private BuildResults _results;
         private BuildResults _loopDependenciesWarnings;
-        private bool _fValidate = true;
-        private bool _fInitialized = false;
+        private bool _fInitialized;
 
         private const string SETUP_EXE = "setup.exe";
         private const string SETUP_BIN = "setup.bin";
@@ -92,7 +91,7 @@ public BootstrapperBuilder(string visualStudioVersion)
         /// <value>Path to bootstrapper files.</value>
         public string Path
         {
-            get { return _path; }
+            get => _path;
             set
             {
                 if (!_fInitialized || string.Compare(_path, value, StringComparison.OrdinalIgnoreCase) != 0)
@@ -111,7 +110,9 @@ public ProductCollection Products
             get
             {
                 if (!_fInitialized)
+                {
                     Refresh();
+                }
 
                 return _products;
             }
@@ -140,12 +141,18 @@ public BuildResults Build(BuildSettings settings)
                 }
 
                 if (!_fInitialized)
+                {
                     Refresh();
+                }
 
                 if (String.IsNullOrEmpty(settings.Culture))
+                {
                     settings.Culture = MapLCIDToCultureName(settings.LCID);
+                }
                 if (String.IsNullOrEmpty(settings.FallbackCulture))
+                {
                     settings.FallbackCulture = MapLCIDToCultureName(settings.FallbackLCID);
+                }
 
                 if (String.IsNullOrEmpty(settings.Culture) || settings.Culture == "*")
                 {
@@ -154,7 +161,7 @@ public BuildResults Build(BuildSettings settings)
 
                 AddBuiltProducts(settings);
 
-                ArrayList componentFilesCopied = new ArrayList();
+                var componentFilesCopied = new List<string>();
 
                 // Copy setup.bin to the output directory
                 string strOutputExe = System.IO.Path.Combine(settings.OutputPath, SETUP_EXE);
@@ -164,7 +171,7 @@ public BuildResults Build(BuildSettings settings)
                     return _results;
                 }
 
-                ResourceUpdater resourceUpdater = new ResourceUpdater();
+                var resourceUpdater = new ResourceUpdater();
 
                 // Build up the String table for setup.exe
                 if (!BuildResources(settings, resourceUpdater))
@@ -190,11 +197,13 @@ public BuildResults Build(BuildSettings settings)
 
                 // Key: File hash, Value: A DictionaryEntry whose Key is "EULAx" and value is a 
                 // fully qualified path to a eula. It can be any eula that matches the hash.
-                Hashtable eulas = new Hashtable();
+                var eulas = new Dictionary<string, KeyValuePair<string, string>>(StringComparer.Ordinal);
 
                 // Copy package files, add each Package config info to the config file
                 if (!BuildPackages(settings, configElement, resourceUpdater, componentFilesCopied, eulas))
+                {
                     return _results;
+                }
 
                 // Transform the configuration xml into something the bootstrapper will understand
                 DumpXmlToFile(configElement, "bootstrapper.cfg.xml");
@@ -203,17 +212,16 @@ public BuildResults Build(BuildSettings settings)
                 DumpStringToFile(config, "bootstrapper.cfg", false);
 
                 // Put eulas in the resource stream
-                foreach (object obj in eulas.Values)
+                foreach (KeyValuePair<string, string> de in eulas.Values)
                 {
-                    DictionaryEntry de = (DictionaryEntry)obj;
                     string data;
-                    FileInfo fi = new System.IO.FileInfo(de.Value.ToString());
+                    var fi = new FileInfo(de.Value);
                     using (FileStream fs = fi.OpenRead())
                     {
                         data = new StreamReader(fs).ReadToEnd();
                     }
 
-                    resourceUpdater.AddStringResource(44, de.Key.ToString(), data);
+                    resourceUpdater.AddStringResource(44, de.Key, data);
                 }
 
                 resourceUpdater.AddStringResource(44, "COUNT", eulas.Count.ToString(CultureInfo.InvariantCulture));
@@ -235,7 +243,7 @@ public BuildResults Build(BuildSettings settings)
             return _results;
         }
 
-        private void Merge(Dictionary<string, Product> output, Dictionary<string, Product> input)
+        private static void Merge(Dictionary<string, Product> output, Dictionary<string, Product> input)
         {
             foreach (Product product in input.Values)
             {
@@ -243,18 +251,20 @@ private void Merge(Dictionary<string, Product> output, Dictionary<string, Produc
             }
         }
 
-        private void AddProduct(Dictionary<string, Product> output, Product product)
+        private static void AddProduct(Dictionary<string, Product> output, Product product)
         {
             if (!output.ContainsKey(product.ProductCode.ToLowerInvariant()))
+            {
                 output.Add(product.ProductCode.ToLowerInvariant(), product);
+            }
         }
 
         private void AddBuiltProducts(BuildSettings settings)
         {
-            Dictionary<string, ProductBuilder> builtProducts = new Dictionary<string, ProductBuilder>();
-            Dictionary<string, Product> productsAndIncludes = new Dictionary<string, Product>();
+            var builtProducts = new Dictionary<string, ProductBuilder>();
+            var productsAndIncludes = new Dictionary<string, Product>();
 
-            if (_loopDependenciesWarnings != null && _loopDependenciesWarnings.Messages != null)
+            if (_loopDependenciesWarnings?.Messages != null)
             {
                 foreach (BuildMessage message in _loopDependenciesWarnings.Messages)
                 {
@@ -314,7 +324,7 @@ private void AddBuiltProducts(BuildSettings settings)
                     }
                 }
 
-                foreach (ArrayList missingDependecies in builder.Product.MissingDependencies)
+                foreach (List<string> missingDependecies in builder.Product.MissingDependencies)
                 {
                     if (missingDependecies.Count == 1)
                     {
@@ -322,7 +332,7 @@ private void AddBuiltProducts(BuildSettings settings)
                     }
                     else
                     {
-                        StringBuilder missingProductCodes = new StringBuilder();
+                        var missingProductCodes = new StringBuilder();
                         foreach (string productCode in missingDependecies)
                         {
                             missingProductCodes.Append(productCode);
@@ -399,7 +409,6 @@ private void AddStringResourceForUrl(ResourceUpdater resourceUpdater, string nam
         /// <param name="culture">The culture used to build the bootstrapper</param>
         /// <param name="fallbackCulture">The fallback culture used to build the bootstrapper</param>
         /// <param name="componentsLocation">How the bootstrapper would package the selected components</param>
-        /// <returns></returns>
         public string[] GetOutputFolders(string[] productCodes, string culture, string fallbackCulture, ComponentsLocation componentsLocation)
         {
             if (!_fInitialized)
@@ -407,8 +416,8 @@ public string[] GetOutputFolders(string[] productCodes, string culture, string f
                 Refresh();
             }
 
-            Hashtable folders = new Hashtable();
-            BuildSettings settings = new BuildSettings();
+            var folders = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+            var settings = new BuildSettings();
             string invariantPath = PackagePath.ToLowerInvariant();
             invariantPath = Util.AddTrailingChar(invariantPath, System.IO.Path.DirectorySeparatorChar);
             settings.CopyComponents = false;
@@ -423,12 +432,13 @@ public string[] GetOutputFolders(string[] productCodes, string culture, string f
             foreach (string productCode in productCodes)
             {
                 Product product = Products.Product(productCode);
-                if (product == null)
-                    continue;
-                settings.ProductBuilders.Add(product.ProductBuilder);
+                if (product != null)
+                {
+                    settings.ProductBuilders.Add(product.ProductBuilder);
+                }
             }
-            ArrayList files = new ArrayList();
 
+            var files = new List<string>();
             BuildPackages(settings, null, null, files, null);
 
             foreach (string file in files)
@@ -436,23 +446,24 @@ public string[] GetOutputFolders(string[] productCodes, string culture, string f
                 string folder = System.IO.Path.GetDirectoryName(file);
                 if (folder.Substring(0, invariantPath.Length).ToLowerInvariant().CompareTo(invariantPath) == 0)
                 {
-                    string relPath = folder.Substring(invariantPath.Length).ToLowerInvariant();
+                    string relPath = folder.Substring(invariantPath.Length);
                     if (!folders.Contains(relPath))
-                        folders.Add(relPath, relPath);
+                    {
+                        folders.Add(relPath);
+                    }
                 }
             }
 
-            ArrayList list = new ArrayList(folders.Values);
-            string[] a = new string[list.Count];
-            list.CopyTo(a, 0);
-            return a;
+            return folders.ToArray();
         }
 
         internal bool ContainsCulture(string culture)
         {
             if (!_fInitialized)
+            {
                 Refresh();
-            return _cultures.Contains(culture);
+            }
+            return _cultures.ContainsKey(culture);
         }
 
         internal string[] Cultures
@@ -460,36 +471,23 @@ internal string[] Cultures
             get
             {
                 if (!_fInitialized)
+                {
                     Refresh();
+                }
 
-                ArrayList list = new ArrayList(_cultures.Values);
+                List<string> list = _cultures.Values.Select(v => v.ToString()).ToList();
                 list.Sort();
-                string[] a = new string[list.Count];
-                list.CopyTo(a, 0);
-                return a;
+                return list.ToArray();
             }
         }
 
-        internal bool Validate
-        {
-            get { return _fValidate; }
-            set { _fValidate = value; }
-        }
+        internal bool Validate { get; set; } = true;
 
-        private string BootstrapperPath
-        {
-            get { return System.IO.Path.Combine(Path, ENGINE_PATH); }
-        }
+        private string BootstrapperPath => System.IO.Path.Combine(Path, ENGINE_PATH);
 
-        private string PackagePath
-        {
-            get { return System.IO.Path.Combine(Path, PACKAGE_PATH); }
-        }
+        private string PackagePath => System.IO.Path.Combine(Path, PACKAGE_PATH);
 
-        private string SchemaPath
-        {
-            get { return System.IO.Path.Combine(Path, SCHEMA_PATH); }
-        }
+        private string SchemaPath => System.IO.Path.Combine(Path, SCHEMA_PATH);
 
         private void Refresh()
         {
@@ -521,12 +519,11 @@ private void RefreshResources()
                     string resourceFile = System.IO.Path.Combine(resourceDirectory, SETUP_RESOURCES_FILE);
                     if (File.Exists(resourceFile))
                     {
-                        XmlDocument resourceDoc = new XmlDocument();
+                        var resourceDoc = new XmlDocument();
                         try
                         {
-                            XmlReaderSettings xrs = new XmlReaderSettings();
-                            xrs.DtdProcessing = DtdProcessing.Ignore;
-                            using (XmlReader xr = XmlReader.Create(resourceFile, xrs))
+                            var xrs = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
+                            using (var xr = XmlReader.Create(resourceFile, xrs))
                             {
                                 resourceDoc.Load(xr);
                             }
@@ -539,29 +536,27 @@ private void RefreshResources()
                         }
 
                         XmlNode rootNode = resourceDoc.SelectSingleNode("Resources");
-                        if (rootNode != null)
+                        XmlAttribute cultureAttribute = (XmlAttribute) rootNode?.Attributes.GetNamedItem("Culture");
+                        if (cultureAttribute != null)
                         {
-                            XmlAttribute cultureAttribute = (XmlAttribute)rootNode.Attributes.GetNamedItem("Culture");
-                            if (cultureAttribute != null)
+                            XmlNode stringsNode = rootNode.SelectSingleNode("Strings");
+                            XmlNode stringNode = stringsNode?.SelectSingleNode(string.Format(CultureInfo.InvariantCulture, "String[@Name='{0}']", cultureAttribute.Value));
+                            if (stringNode != null)
                             {
-                                XmlNode stringsNode = rootNode.SelectSingleNode("Strings");
-                                if (stringsNode != null)
+                                string culture = stringNode.InnerText;
+
+                                XmlNode resourcesNode = rootNode.OwnerDocument.ImportNode(rootNode, true);
+                                resourcesNode.Attributes.RemoveNamedItem("Culture");
+                                var newAttribute = (XmlAttribute)rootNode.OwnerDocument.ImportNode(cultureAttribute, false);
+                                newAttribute.Value = stringNode.InnerText;
+                                resourcesNode.Attributes.Append(newAttribute);
+                                if (!_cultures.ContainsKey(culture))
                                 {
-                                    XmlNode stringNode = stringsNode.SelectSingleNode(string.Format(CultureInfo.InvariantCulture, "String[@Name='{0}']", cultureAttribute.Value));
-                                    if (stringNode != null)
-                                    {
-                                        string culture = stringNode.InnerText;
-
-                                        XmlNode resourcesNode = rootNode.OwnerDocument.ImportNode(rootNode, true);
-                                        resourcesNode.Attributes.RemoveNamedItem("Culture");
-                                        XmlAttribute newAttribute = (XmlAttribute)rootNode.OwnerDocument.ImportNode(cultureAttribute, false);
-                                        newAttribute.Value = stringNode.InnerText;
-                                        resourcesNode.Attributes.Append(newAttribute);
-                                        if (!_cultures.Contains(culture.ToLowerInvariant()))
-                                            _cultures.Add(culture.ToLowerInvariant(), resourcesNode);
-                                        else
-                                            Debug.Fail("Already found resources for culture " + stringNode.InnerText);
-                                    }
+                                    _cultures.Add(culture, resourcesNode);
+                                }
+                                else
+                                {
+                                    Debug.Fail("Already found resources for culture " + stringNode.InnerText);
                                 }
                             }
                         }
@@ -597,9 +592,9 @@ private void RefreshProducts()
 
             _document.AppendChild(rootElement);
 
-            Hashtable availableProducts = new Hashtable();
+            var availableProducts = new Dictionary<string, Product>(StringComparer.Ordinal);
             // A second copy of all the project which will get destroyed during the generation of the build order
-            Hashtable buildQueue = new Hashtable();
+            var buildQueue = new Dictionary<string, Product>(StringComparer.Ordinal);
 
             XmlNodeList productsFound = rootElement.SelectNodes(BOOTSTRAPPER_PREFIX + ":Product", _xmlNamespaceManager);
             foreach (XmlNode productNode in productsFound)
@@ -629,36 +624,34 @@ private void RefreshProducts()
             OrderProducts(availableProducts, buildQueue);
         }
 
-        private void AddDependencies(Product p, Hashtable availableProducts)
+        private void AddDependencies(Product p, Dictionary<string, Product> availableProducts)
         {
             foreach (string relatedProductCode in SelectRelatedProducts(p, "DependsOnProduct"))
             {
-                if (availableProducts.Contains(relatedProductCode))
+                if (availableProducts.TryGetValue(relatedProductCode, out Product product))
                 {
-                    p.AddDependentProduct((Product)availableProducts[relatedProductCode]);
+                    p.AddDependentProduct(product);
                 }
                 else
                 {
-                    ArrayList missingDependencies = new ArrayList();
-                    missingDependencies.Add(relatedProductCode);
-                    p.AddMissingDependency(missingDependencies);
+                    p.AddMissingDependency(new List<string> { relatedProductCode });
                 }
             }
 
             foreach (XmlNode eitherProductNode in SelectEitherProducts(p))
             {
-                List<Product> foundDependencies = new List<Product>();
-                ArrayList allDependencies = new ArrayList();
+                var foundDependencies = new List<Product>();
+                var allDependencies = new List<string>();
 
                 foreach (XmlNode relatedProductNode in eitherProductNode.SelectNodes(String.Format(CultureInfo.InvariantCulture, "{0}:DependsOnProduct", BOOTSTRAPPER_PREFIX), _xmlNamespaceManager))
                 {
-                    XmlAttribute relatedProductAttribute = (XmlAttribute)(relatedProductNode.Attributes.GetNamedItem("Code"));
+                    var relatedProductAttribute = (XmlAttribute)(relatedProductNode.Attributes.GetNamedItem("Code"));
                     if (relatedProductAttribute != null)
                     {
                         string dependency = relatedProductAttribute.Value;
-                        if (availableProducts.Contains(dependency))
+                        if (availableProducts.TryGetValue(dependency, out Product product))
                         {
-                            foundDependencies.Add((Product)availableProducts[dependency]);
+                            foundDependencies.Add(product);
                         }
                         allDependencies.Add(dependency);
                     }
@@ -678,20 +671,20 @@ private void AddDependencies(Product p, Hashtable availableProducts)
             }
         }
 
-        private void AddIncludes(Product p, Hashtable availableProducts)
+        private void AddIncludes(Product p, Dictionary<string, Product> availableProducts)
         {
             foreach (string relatedProductCode in SelectRelatedProducts(p, "IncludesProduct"))
             {
-                if (availableProducts.Contains(relatedProductCode))
+                if (availableProducts.TryGetValue(relatedProductCode, out Product product))
                 {
-                    p.Includes.Add((Product)availableProducts[relatedProductCode]);
+                    p.Includes.Add(product);
                 }
             }
         }
 
         private string[] SelectRelatedProducts(Product p, string nodeName)
         {
-            ArrayList list = new ArrayList();
+            var list = new List<string>();
 
             XmlNodeList relatedProducts = p.Node.SelectNodes(string.Format(CultureInfo.InvariantCulture, "{0}:Package/{1}:RelatedProducts/{2}:{3}", BOOTSTRAPPER_PREFIX, BOOTSTRAPPER_PREFIX, BOOTSTRAPPER_PREFIX, nodeName), _xmlNamespaceManager);
             if (relatedProducts != null)
@@ -706,9 +699,7 @@ private string[] SelectRelatedProducts(Product p, string nodeName)
                 }
             }
 
-            string[] a = new string[list.Count];
-            list.CopyTo(a, 0);
-            return a;
+            return list.ToArray();
         }
 
         private XmlNodeList SelectEitherProducts(Product p)
@@ -717,19 +708,20 @@ private XmlNodeList SelectEitherProducts(Product p)
             return eitherProducts;
         }
 
-        private void OrderProducts(Hashtable availableProducts, Hashtable buildQueue)
+        private void OrderProducts(Dictionary<string, Product> availableProducts, Dictionary<string, Product> buildQueue)
         {
             bool loopDetected = false;
             _loopDependenciesWarnings = new BuildResults();
-            StringBuilder productsInLoop = new StringBuilder();
+            var productsInLoop = new StringBuilder();
+            var productsToRemove = new List<string>();
             while (buildQueue.Count > 0)
             {
-                List<string> productsToRemove = new List<string>();
+                productsToRemove.Clear();
                 foreach (Product p in buildQueue.Values)
                 {
                     if (p.Dependencies.Count == 0)
                     {
-                        _products.Add((Product)availableProducts[p.ProductCode]);
+                        _products.Add(availableProducts[p.ProductCode]);
                         RemoveDependency(buildQueue, p);
                         productsToRemove.Add(p.ProductCode);
                     }
@@ -750,9 +742,8 @@ private void OrderProducts(Hashtable availableProducts, Hashtable buildQueue)
                 // of the first project in the queue;
                 if (buildQueue.Count > 0 && productsToRemove.Count == 0)
                 {
-                    IDictionaryEnumerator enumerator = buildQueue.GetEnumerator();
-                    enumerator.MoveNext();
-                    ((Product)enumerator.Value).Dependencies.RemoveAll(m => true);
+                    Product p = buildQueue.Values.First();
+                    p.Dependencies.RemoveAll(m => true);
                     loopDetected = true;
                 }
 
@@ -768,7 +759,7 @@ private void OrderProducts(Hashtable availableProducts, Hashtable buildQueue)
             }
         }
 
-        private void RemoveDependency(Hashtable availableProducts, Product product)
+        private static void RemoveDependency(Dictionary<string, Product> availableProducts, Product product)
         {
             foreach (Product p in availableProducts.Values)
             {
@@ -815,8 +806,7 @@ private XmlDocument LoadAndValidateXmlDocument(string filePath, bool validateFil
 
                 if (fileExists)
                 {
-                    XmlTextReader xmlTextReader = new XmlTextReader(filePath);
-                    xmlTextReader.DtdProcessing = DtdProcessing.Ignore;
+                    var xmlTextReader = new XmlTextReader(filePath) { DtdProcessing = DtdProcessing.Ignore };
 
                     XmlReader xmlReader = xmlTextReader;
 
@@ -825,8 +815,7 @@ private XmlDocument LoadAndValidateXmlDocument(string filePath, bool validateFil
 #pragma warning disable 618 // Using XmlValidatingReader. TODO: We need to switch to using XmlReader.Create() with validation.
                         var validatingReader = new XmlValidatingReader(xmlReader);
 #pragma warning restore 618
-                        XmlReaderSettings xrSettings = new XmlReaderSettings();
-                        xrSettings.DtdProcessing = DtdProcessing.Ignore;
+                        var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
                         using (XmlReader xr = XmlReader.Create(schemaPath, xrSettings))
                         {
                             try
@@ -884,7 +873,7 @@ private XmlDocument LoadAndValidateXmlDocument(string filePath, bool validateFil
                     // Note that the xml document's default namespace must match the schema namespace
                     //   or none of our SelectNodes/SelectSingleNode calls will succeed
                     Debug.Assert(xmlDocument.DocumentElement != null &&
-                    string.Equals(xmlDocument.DocumentElement.NamespaceURI, schemaNamespace, StringComparison.Ordinal),
+                        string.Equals(xmlDocument.DocumentElement.NamespaceURI, schemaNamespace, StringComparison.Ordinal),
                         "'" + xmlDocument.DocumentElement.NamespaceURI + "' is not '" + schemaNamespace + "'...");
 
                     if ((xmlDocument.DocumentElement == null) ||
@@ -908,7 +897,7 @@ private void ExploreDirectory(string strSubDirectory, XmlElement rootElement)
                 string strBaseManifestFilename = System.IO.Path.Combine(strSubDirectoryFullPath, ROOT_MANIFEST_FILE);
                 string strBaseManifestSchemaFileName = System.IO.Path.Combine(SchemaPath, MANIFEST_FILE_SCHEMA);
 
-                ProductValidationResults productValidationResults = new ProductValidationResults(strBaseManifestFilename);
+                var productValidationResults = new ProductValidationResults(strBaseManifestFilename);
 
                 // open the XmlDocument for this product.xml
                 XmlDocument productDoc = LoadAndValidateXmlDocument(strBaseManifestFilename, false, strBaseManifestSchemaFileName, BOOTSTRAPPER_NAMESPACE, productValidationResults);
@@ -920,7 +909,7 @@ private void ExploreDirectory(string strSubDirectory, XmlElement rootElement)
                     if (baseNode != null)
                     {
                         // Get the ProductCode attribute for this product
-                        XmlAttribute productCodeAttribute = (XmlAttribute)(baseNode.Attributes.GetNamedItem("ProductCode"));
+                        var productCodeAttribute = (XmlAttribute)(baseNode.Attributes.GetNamedItem("ProductCode"));
                         if (productCodeAttribute != null)
                         {
                             // now add it to our full document if it's not already present
@@ -931,7 +920,9 @@ private void ExploreDirectory(string strSubDirectory, XmlElement rootElement)
                             }
                             else
                             {
-                                productValidationResults = (ProductValidationResults)_validationResults[productCodeAttribute];
+                                _validationResults.TryGetValue(
+                                    productCodeAttribute.Value,
+                                    out productValidationResults);
                             }
 
                             // Fix-up the <PackageFiles> of the base node to include the SourcePath and TargetPath
@@ -953,7 +944,7 @@ private void ExploreDirectory(string strSubDirectory, XmlElement rootElement)
                             {
                                 // The base node would get destroyed as we build-up this new node.
                                 // Thus, we want to use a copy of the baseNode
-                                XmlElement baseElement = (XmlElement)(_document.ImportNode(baseNode, true));
+                                var baseElement = (XmlElement)(_document.ImportNode(baseNode, true));
 
                                 string strLangManifestFilename = System.IO.Path.Combine(strLanguageDirectory, CHILD_MANIFEST_FILE);
                                 string strLangManifestSchemaFileName = System.IO.Path.Combine(SchemaPath, MANIFEST_FILE_SCHEMA);
@@ -966,7 +957,9 @@ private void ExploreDirectory(string strSubDirectory, XmlElement rootElement)
 
                                     Debug.Assert(langDoc != null, "we couldn't load package.xml in '" + strLangManifestFilename + "'...?");
                                     if (langDoc == null)
+                                    {
                                         continue;
+                                    }
 
                                     XmlNode langNode = langDoc.SelectSingleNode(BOOTSTRAPPER_PREFIX + ":Package", _xmlNamespaceManager);
                                     Debug.Assert(langNode != null, string.Format(CultureInfo.CurrentCulture, "Unable to find a package node in {0}", strLangManifestFilename));
@@ -984,8 +977,11 @@ private void ExploreDirectory(string strSubDirectory, XmlElement rootElement)
                                         {
                                             int nStartIndex = packagePath.Length;
 
-                                            if ((strLanguageDirectory.ToCharArray())[nStartIndex] == System.IO.Path.DirectorySeparatorChar)
+                                            if ((strLanguageDirectory.ToCharArray())[nStartIndex] ==
+                                                System.IO.Path.DirectorySeparatorChar)
+                                            {
                                                 nStartIndex++;
+                                            }
                                             UpdatePackageFileNodes(packageFilesNodePackage, strLanguageDirectory, strSubDirectory);
 
                                             ReplacePackageFileAttributes(checksNode, "PackageFile", packageFilesNodePackage, "PackageFile", "OldName", "Name");
@@ -1010,7 +1006,7 @@ private void ExploreDirectory(string strSubDirectory, XmlElement rootElement)
 
                                         foreach (XmlAttribute attribute in baseElement.Attributes)
                                         {
-                                            XmlAttribute convertedAttribute = (XmlAttribute)(mergeElement.OwnerDocument.ImportNode(attribute, false));
+                                            var convertedAttribute = (XmlAttribute)(mergeElement.OwnerDocument.ImportNode(attribute, false));
                                             MergeAttribute(mergeElement, convertedAttribute);
                                         }
 
@@ -1031,8 +1027,8 @@ private void ExploreDirectory(string strSubDirectory, XmlElement rootElement)
                                         AppendNode(baseElement, "RelatedProducts", mergeElement);
 
                                         // Create a unique identifier for this package
-                                        XmlAttribute cultureAttribute = (XmlAttribute)mergeElement.Attributes.GetNamedItem("Culture");
-                                        if (cultureAttribute != null && !String.IsNullOrEmpty(cultureAttribute.Value))
+                                        var cultureAttribute = (XmlAttribute)mergeElement.Attributes.GetNamedItem("Culture");
+                                        if (!String.IsNullOrEmpty(cultureAttribute?.Value))
                                         {
                                             string packageCode = productCodeAttribute.Value + "." + cultureAttribute.Value;
                                             AddAttribute(mergeElement, "PackageCode", packageCode);
@@ -1052,7 +1048,7 @@ private void ExploreDirectory(string strSubDirectory, XmlElement rootElement)
                             if (packageAdded)
                             {
                                 rootElement.AppendChild(productNode);
-                                if (!_validationResults.Contains(productCodeAttribute.Value))
+                                if (!_validationResults.ContainsKey(productCodeAttribute.Value))
                                 {
                                     _validationResults.Add(productCodeAttribute.Value, productValidationResults);
                                 }
@@ -1069,7 +1065,7 @@ private void ExploreDirectory(string strSubDirectory, XmlElement rootElement)
             {
                 Debug.Fail(ex.Message);
             }
-            catch (System.IO.IOException ex)
+            catch (IOException ex)
             {
                 Debug.Fail(ex.Message);
             }
@@ -1086,7 +1082,7 @@ private Product CreateProduct(XmlNode node)
             Product product = null;
             if (!String.IsNullOrEmpty(productCode))
             {
-                ProductValidationResults results = (ProductValidationResults)_validationResults[productCode];
+                _validationResults.TryGetValue(productCode, out ProductValidationResults results);
 
                 XmlNode packageFilesNode = node.SelectSingleNode(BOOTSTRAPPER_PREFIX + ":Package/" + BOOTSTRAPPER_PREFIX + ":PackageFiles", _xmlNamespaceManager);
                 string copyAllPackageFiles = String.Empty;
@@ -1112,11 +1108,11 @@ private Product CreateProduct(XmlNode node)
             return null;
         }
 
-        private Package CreatePackage(XmlNode node, Product product)
+        private static Package CreatePackage(XmlNode node, Product product)
         {
             string culture = ReadAttribute(node, "Culture");
 
-            XmlValidationResults results = null;
+            XmlValidationResults results;
             if (culture != null)
             {
                 results = product.GetPackageValidationResults(culture);
@@ -1144,20 +1140,22 @@ private void ReplaceAttributes(XmlNode targetNode, string attributeName, string
                 // replace attributes on the node itself
                 XmlAttribute attrib = targetNode.Attributes[attributeName];
                 if (attrib != null && attrib.Value == oldValue)
+                {
                     attrib.Value = newValue;
+                }
             }
         }
 
-        private void ReplaceAttribute(XmlNode targetNode, string attributeName, string attributeValue)
+        private static void ReplaceAttribute(XmlNode targetNode, string attributeName, string attributeValue)
         {
             XmlAttribute attribute = targetNode.OwnerDocument.CreateAttribute(attributeName);
             attribute.Value = attributeValue;
             targetNode.Attributes.SetNamedItem(attribute);
         }
 
-        private void MergeAttribute(XmlNode targetNode, XmlAttribute attribute)
+        private static void MergeAttribute(XmlNode targetNode, XmlAttribute attribute)
         {
-            XmlAttribute targetAttribute = (XmlAttribute)(targetNode.Attributes.GetNamedItem(attribute.Name));
+            var targetAttribute = (XmlAttribute)(targetNode.Attributes.GetNamedItem(attribute.Name));
             if (targetAttribute == null)
             {
                 // This node does not already contain the attribute.  Add the parameter
@@ -1171,7 +1169,7 @@ private void UpdatePackageFileNodes(XmlNode packageFilesNode, string strSourcePa
 
             foreach (XmlNode packageFileNode in packageFileNodeList)
             {
-                XmlAttribute nameAttribute = (XmlAttribute)(packageFileNode.Attributes.GetNamedItem("Name"));
+                var nameAttribute = (XmlAttribute)(packageFileNode.Attributes.GetNamedItem("Name"));
 
                 // the name attribute is required -- we can't do anything if it's not present
                 if (nameAttribute != null)
@@ -1314,12 +1312,12 @@ private void CorrectPackageFiles(XmlNode node)
                 XmlNodeList packageFileNodeList = node.SelectNodes("//" + BOOTSTRAPPER_PREFIX + ":*[@PackageFile]", _xmlNamespaceManager);
                 foreach (XmlNode currentNode in packageFileNodeList)
                 {
-                    XmlAttribute attribute = (XmlAttribute)(currentNode.Attributes.GetNamedItem("PackageFile"));
+                    var attribute = (XmlAttribute)(currentNode.Attributes.GetNamedItem("PackageFile"));
                     string strQuery = BOOTSTRAPPER_PREFIX + ":PackageFile[@Name='" + attribute.Value + "']";
                     XmlNode packageFileNode = packageFilesNode.SelectSingleNode(strQuery, _xmlNamespaceManager);
                     if (packageFileNode != null)
                     {
-                        XmlAttribute targetPathAttribute = (XmlAttribute)(packageFileNode.Attributes.GetNamedItem("TargetPath"));
+                        var targetPathAttribute = (XmlAttribute)(packageFileNode.Attributes.GetNamedItem("TargetPath"));
                         attribute.Value = targetPathAttribute.Value;
                     }
                 }
@@ -1329,8 +1327,6 @@ private void CorrectPackageFiles(XmlNode node)
         private void ReplaceStrings(XmlNode node)
         {
             XmlNode stringsNode = node.SelectSingleNode(BOOTSTRAPPER_PREFIX + ":Strings", _xmlNamespaceManager);
-            XmlNode stringNode;
-            XmlAttribute attribute;
 
             if (stringsNode != null)
             {
@@ -1356,8 +1352,8 @@ private void ReplaceStrings(XmlNode node)
                 XmlNodeList stringKeyNodeList = node.SelectNodes("//" + BOOTSTRAPPER_PREFIX + ":*[@String]", _xmlNamespaceManager);
                 foreach (XmlNode currentNode in stringKeyNodeList)
                 {
-                    attribute = (XmlAttribute)(currentNode.Attributes.GetNamedItem("String"));
-                    stringNode = stringsNode.SelectSingleNode(string.Format(CultureInfo.InvariantCulture, stringNodeLookupTemplate, attribute.Value), _xmlNamespaceManager);
+                    var attribute = (XmlAttribute)(currentNode.Attributes.GetNamedItem("String"));
+                    XmlNode stringNode = stringsNode.SelectSingleNode(string.Format(CultureInfo.InvariantCulture, stringNodeLookupTemplate, attribute.Value), _xmlNamespaceManager);
                     if (stringNode != null)
                     {
                         AddAttribute(currentNode, "Text", stringNode.InnerText);
@@ -1370,7 +1366,7 @@ private void ReplaceStrings(XmlNode node)
             }
         }
 
-        private bool BuildPackages(BuildSettings settings, XmlElement configElement, ResourceUpdater resourceUpdater, ArrayList filesCopied, Hashtable eulas)
+        private bool BuildPackages(BuildSettings settings, XmlElement configElement, ResourceUpdater resourceUpdater, List<string> filesCopied, Dictionary<string, KeyValuePair<string, string>> eulas)
         {
             bool fSucceeded = true;
 
@@ -1421,11 +1417,11 @@ private bool BuildPackages(BuildSettings settings, XmlElement configElement, Res
                 XmlNode installChecksNode = node.SelectSingleNode(BOOTSTRAPPER_PREFIX + ":InstallChecks", _xmlNamespaceManager);
                 foreach (XmlNode packageFileNode in packageFileNodes)
                 {
-                    XmlAttribute packageFileSource = (XmlAttribute)(packageFileNode.Attributes.GetNamedItem("SourcePath"));
-                    XmlAttribute packageFileDestination = (XmlAttribute)(packageFileNode.Attributes.GetNamedItem("TargetPath"));
-                    XmlAttribute packageFileName = (XmlAttribute)(packageFileNode.Attributes.GetNamedItem("Name"));
-                    XmlAttribute packageFileCopy = (XmlAttribute)(packageFileNode.Attributes.GetNamedItem("CopyOnBuild"));
-                    if (packageFileSource != null && eulaAttribute != null && !String.IsNullOrEmpty(eulaAttribute.Value) && packageFileSource.Value == eulaAttribute.Value)
+                    var packageFileSource = (XmlAttribute)(packageFileNode.Attributes.GetNamedItem("SourcePath"));
+                    var packageFileDestination = (XmlAttribute)(packageFileNode.Attributes.GetNamedItem("TargetPath"));
+                    var packageFileName = (XmlAttribute)(packageFileNode.Attributes.GetNamedItem("Name"));
+                    var packageFileCopy = (XmlAttribute)(packageFileNode.Attributes.GetNamedItem("CopyOnBuild"));
+                    if (packageFileSource != null && !String.IsNullOrEmpty(eulaAttribute?.Value) && packageFileSource.Value == eulaAttribute.Value)
                     {
                         // need to remove EULA from the package file list
                         XmlNode packageFilesNode = node.SelectSingleNode(BOOTSTRAPPER_PREFIX + ":PackageFiles", _xmlNamespaceManager);
@@ -1437,8 +1433,16 @@ private bool BuildPackages(BuildSettings settings, XmlElement configElement, Res
                         (packageFileName != null))
                     {
                         // Calculate the hash of this file and add it to the PackageFileNode
-                        if (!AddVerificationInformation(packageFileNode, packageFileSource.Value, packageFileName.Value, builder, settings, _results))
+                        if (!AddVerificationInformation(
+                            packageFileNode,
+                            packageFileSource.Value,
+                            packageFileName.Value,
+                            builder,
+                            settings,
+                            _results))
+                        {
                             fSucceeded = false;
+                        }
                     }
 
                     if ((packageFileSource != null) && (packageFileDestination != null) &&
@@ -1456,8 +1460,7 @@ private bool BuildPackages(BuildSettings settings, XmlElement configElement, Res
                             {
                                 if (!File.Exists(packageFileSource.Value))
                                 {
-                                    if (_results != null)
-                                        _results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.PackageResourceFileNotFound", packageFileSource.Value, builder.Name));
+                                    _results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.PackageResourceFileNotFound", packageFileSource.Value, builder.Name));
                                     fSucceeded = false;
                                     continue;
                                 }
@@ -1475,8 +1478,7 @@ private bool BuildPackages(BuildSettings settings, XmlElement configElement, Res
                                     {
                                         if (!File.Exists(packageFileSource.Value))
                                         {
-                                            if (_results != null)
-                                                _results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.PackageFileNotFound", packageFileDestination.Value, builder.Name));
+                                            _results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.PackageFileNotFound", packageFileDestination.Value, builder.Name));
                                             fSucceeded = false;
                                             continue;
                                         }
@@ -1486,29 +1488,25 @@ private bool BuildPackages(BuildSettings settings, XmlElement configElement, Res
                                     }
                                     catch (UnauthorizedAccessException ex)
                                     {
-                                        if (_results != null)
-                                            _results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.CopyPackageError", packageFileSource.Value, builder.Name, ex.Message));
+                                        _results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.CopyPackageError", packageFileSource.Value, builder.Name, ex.Message));
                                         fSucceeded = false;
                                         continue;
                                     }
                                     catch (IOException ex)
                                     {
-                                        if (_results != null)
-                                            _results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.CopyPackageError", packageFileSource.Value, builder.Name, ex.Message));
+                                        _results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.CopyPackageError", packageFileSource.Value, builder.Name, ex.Message));
                                         fSucceeded = false;
                                         continue;
                                     }
                                     catch (ArgumentException ex)
                                     {
-                                        if (_results != null)
-                                            _results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.CopyPackageError", packageFileSource.Value, builder.Name, ex.Message));
+                                        _results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.CopyPackageError", packageFileSource.Value, builder.Name, ex.Message));
                                         fSucceeded = false;
                                         continue;
                                     }
                                     catch (NotSupportedException ex)
                                     {
-                                        if (_results != null)
-                                            _results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.CopyPackageError", packageFileSource.Value, builder.Name, ex.Message));
+                                        _results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.CopyPackageError", packageFileSource.Value, builder.Name, ex.Message));
                                         fSucceeded = false;
                                         continue;
                                     }
@@ -1521,7 +1519,7 @@ private bool BuildPackages(BuildSettings settings, XmlElement configElement, Res
 
                                 // Add the file size to the PackageFileNode
                                 XmlAttribute sizeAttribute = packageFileNode.OwnerDocument.CreateAttribute("Size");
-                                FileInfo fi = new FileInfo(packageFileSource.Value);
+                                var fi = new FileInfo(packageFileSource.Value);
                                 sizeAttribute.Value = "" + (fi.Length.ToString(CultureInfo.InvariantCulture));
                                 MergeAttribute(packageFileNode, sizeAttribute);
                             }
@@ -1529,26 +1527,26 @@ private bool BuildPackages(BuildSettings settings, XmlElement configElement, Res
                     }
                 }
                 // Add the Eula attribute correctly
-                if (eulas != null && eulaAttribute != null && !String.IsNullOrEmpty(eulaAttribute.Value))
+                if (eulas != null && !String.IsNullOrEmpty(eulaAttribute?.Value))
                 {
                     if (File.Exists(eulaAttribute.Value))
                     {
-                        // eulas[GetFileHash(eulaAttribute.Value)] = eulaAttribute.Value;
                         string key = GetFileHash(eulaAttribute.Value);
-                        if (eulas.ContainsKey(key))
-                            eulaAttribute.Value = ((DictionaryEntry)eulas[key]).Key.ToString();
+                        if (eulas.TryGetValue(key, out KeyValuePair<string, string> eulaInfo))
+                        {
+                            eulaAttribute.Value = eulaInfo.Key;
+                        }
                         else
                         {
                             string configFileKey = string.Format(CultureInfo.InvariantCulture, "EULA{0}", eulas.Count);
-                            DictionaryEntry de = new DictionaryEntry(configFileKey, eulaAttribute.Value);
+                            var de = new KeyValuePair<string ,string>(configFileKey, eulaAttribute.ToString());
                             eulas[key] = de;
                             eulaAttribute.Value = configFileKey;
                         }
                     }
                     else
                     {
-                        if (_results != null)
-                            _results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.PackageResourceFileNotFound", eulaAttribute.Value, builder.Name));
+                        _results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.PackageResourceFileNotFound", eulaAttribute.Value, builder.Name));
                         fSucceeded = false;
                         continue;
                     }
@@ -1568,10 +1566,9 @@ private XmlNode CreateProductNode(XmlNode node)
         {
             // create a new Product node for the passed-in product
             XmlNode productNode = _document.CreateElement("Product", BOOTSTRAPPER_NAMESPACE);
-            XmlAttribute sourceAttribute;
 
             // find the ProductCode attribute
-            sourceAttribute = (XmlAttribute)(node.Attributes.GetNamedItem("ProductCode"));
+            var sourceAttribute = (XmlAttribute)(node.Attributes.GetNamedItem("ProductCode"));
             Debug.Assert(sourceAttribute != null, "we should not be here if there is no ProductCode attribute");
 
             AddAttribute(productNode, "ProductCode", sourceAttribute.Value);
@@ -1581,17 +1578,14 @@ private XmlNode CreateProductNode(XmlNode node)
             return productNode;
         }
 
-        private string ReadAttribute(XmlNode node, string strAttributeName)
+        private static string ReadAttribute(XmlNode node, string strAttributeName)
         {
-            XmlAttribute attribute = (XmlAttribute)(node.Attributes.GetNamedItem(strAttributeName));
+            var attribute = (XmlAttribute)(node.Attributes.GetNamedItem(strAttributeName));
 
-            if (attribute != null)
-                return attribute.Value;
-
-            return null;
+            return attribute?.Value;
         }
 
-        private void EnsureFolderExists(string strFolderPath)
+        private static void EnsureFolderExists(string strFolderPath)
         {
             if (!Directory.Exists(strFolderPath))
             {
@@ -1599,7 +1593,7 @@ private void EnsureFolderExists(string strFolderPath)
             }
         }
 
-        private void ClearReadOnlyAttribute(string strFileName)
+        private static void ClearReadOnlyAttribute(string strFileName)
         {
             FileAttributes attribs = File.GetAttributes(strFileName);
             if ((attribs & FileAttributes.ReadOnly) != 0)
@@ -1609,21 +1603,23 @@ private void ClearReadOnlyAttribute(string strFileName)
             }
         }
 
-        private string ByteArrayToString(byte[] byteArray)
+        private static string ByteArrayToString(byte[] byteArray)
         {
             if (byteArray == null) return null;
 
-            System.Text.StringBuilder output = new System.Text.StringBuilder(byteArray.Length);
+            var output = new StringBuilder(byteArray.Length);
             foreach (byte byteValue in byteArray)
+            {
                 output.Append(byteValue.ToString("X02", CultureInfo.InvariantCulture));
+            }
 
             return output.ToString();
         }
 
-        private string GetFileHash(string filePath)
+        private static string GetFileHash(string filePath)
         {
-            FileInfo fi = new System.IO.FileInfo(filePath);
-            String retVal = null;
+            var fi = new FileInfo(filePath);
+            String retVal;
 
             // Bootstrapper is always signed with the SHA-256 algorithm, no matter which version of
             // the .NET Framework we are targeting.  In ideal situations, bootstrapper files will be
@@ -1641,12 +1637,14 @@ private string GetFileHash(string filePath)
         private void ReplaceAttributeString(XmlNode node, string attributeName, XmlNode stringsNode)
         {
             string stringNodeLookupTemplate = BOOTSTRAPPER_PREFIX + ":String[@Name='{0}']";
-            XmlAttribute attribute = (XmlAttribute)(node.Attributes.GetNamedItem(attributeName));
+            var attribute = (XmlAttribute)(node.Attributes.GetNamedItem(attributeName));
             if (attribute != null)
             {
                 XmlNode stringNode = stringsNode.SelectSingleNode(string.Format(CultureInfo.InvariantCulture, stringNodeLookupTemplate, attribute.Value), _xmlNamespaceManager);
                 if (stringNode != null)
+                {
                     attribute.Value = stringNode.InnerText;
+                }
             }
         }
 
@@ -1654,12 +1652,11 @@ private Package GetPackageForSettings(BuildSettings settings, ProductBuilder bui
         {
             CultureInfo ci = Util.GetCultureInfoFromString(settings.Culture);
             CultureInfo fallbackCI = Util.GetCultureInfoFromString(settings.FallbackCulture);
-            Package package = null;
+            Package package;
 
             if (builder.Product.Packages.Count == 0)
             {
-                if (results != null)
-                    results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.ProductCultureNotFound", builder.Name));
+                results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.ProductCultureNotFound", builder.Name));
                 return null;
             }
 
@@ -1673,7 +1670,7 @@ private Package GetPackageForSettings(BuildSettings settings, ProductBuilder bui
                 CultureInfo parentCulture = ci.Parent;
 
                 // Keep going up the chain of parents, stopping at the invariant culture
-                while (parentCulture != null && parentCulture != CultureInfo.InvariantCulture)
+                while (parentCulture != CultureInfo.InvariantCulture)
                 {
                     package = GetPackageForSettings_Helper(ci, parentCulture, builder, results, false);
                     if (package != null) return package;
@@ -1682,7 +1679,6 @@ private Package GetPackageForSettings(BuildSettings settings, ProductBuilder bui
                 }
             }
 
-
             if (fallbackCI != null)
             {
                 package = GetPackageForSettings_Helper(ci, fallbackCI, builder, results, true);
@@ -1709,15 +1705,19 @@ private Package GetPackageForSettings(BuildSettings settings, ProductBuilder bui
             return builder.Product.Packages.Item(0);
         }
 
-        private Package GetPackageForSettings_Helper(CultureInfo culture, CultureInfo altCulture, ProductBuilder builder, BuildResults results, bool fShowWarning)
+        private static Package GetPackageForSettings_Helper(CultureInfo culture, CultureInfo altCulture, ProductBuilder builder, BuildResults results, bool fShowWarning)
         {
             if (altCulture == null)
+            {
                 return null;
+            }
             Package package = builder.Product.Packages.Package(altCulture.Name);
             if (package != null)
             {
-                if (fShowWarning && culture != null && results != null)
-                    results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.UsingProductCulture", culture.Name, builder.Name, altCulture.Name));
+                if (fShowWarning && culture != null)
+                {
+                    results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.UsingProductCulture", culture.Name, builder.Name, altCulture.Name));
+                }
                 return package;
             }
             return null;
@@ -1727,8 +1727,7 @@ private bool BuildResources(BuildSettings settings, ResourceUpdater resourceUpda
         {
             if (_cultures.Count == 0)
             {
-                if (_results != null)
-                    _results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.NoResources"));
+                _results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.NoResources"));
                 return false;
             }
 
@@ -1739,8 +1738,7 @@ private bool BuildResources(BuildSettings settings, ResourceUpdater resourceUpda
 
             if (stringsNode == null)
             {
-                if (_results != null)
-                    _results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.NoStringsForCulture", resourcesNode.Attributes.GetNamedItem("Culture").Value));
+                _results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.NoStringsForCulture", resourcesNode.Attributes.GetNamedItem("Culture").Value));
                 return false;
             }
 
@@ -1767,7 +1765,9 @@ private bool BuildResources(BuildSettings settings, ResourceUpdater resourceUpda
                 DumpXmlToFile(fontsNode, "fonts.cfg.xml");
                 DumpStringToFile(fontsConfig, "fonts.cfg", false);
                 if (codePage != -1)
+                {
                     resourceUpdater.AddStringResource(RESOURCE_TABLE, "CODEPAGE", codePage.ToString(CultureInfo.InvariantCulture));
+                }
             }
             return true;
         }
@@ -1776,9 +1776,8 @@ private XmlNode GetResourcesNodeForSettings(BuildSettings settings, BuildResults
         {
             CultureInfo ci = Util.GetCultureInfoFromString(settings.Culture);
             CultureInfo fallbackCI = Util.GetCultureInfoFromString(settings.FallbackCulture);
-            XmlNode cultureNode = null;
-
-
+            XmlNode cultureNode;
+            
             if (ci != null)
             {
                 // Work through the progression of parent cultures (up until but excluding the invariant culture) -> fallback culture -> parent fallback culture -> default culture -> parent default culture -> any available culture
@@ -1787,7 +1786,7 @@ private XmlNode GetResourcesNodeForSettings(BuildSettings settings, BuildResults
                 CultureInfo parentCulture = ci.Parent;
 
                 // Keep going up the chain of parents, stopping at the invariant culture
-                while (parentCulture != null && parentCulture != CultureInfo.InvariantCulture)
+                while (parentCulture != CultureInfo.InvariantCulture)
                 {
                     cultureNode = GetResourcesNodeForSettings_Helper(ci, parentCulture, results, ref codepage, false);
                     if (cultureNode != null) return cultureNode;
@@ -1817,34 +1816,36 @@ private XmlNode GetResourcesNodeForSettings(BuildSettings settings, BuildResults
                 if (cultureNode != null) return cultureNode;
             }
 
-            IEnumerator keys = _cultures.Keys.GetEnumerator();
-            keys.MoveNext();
-            string altCulture = (string)keys.Current;
-            if (ci != null && results != null)
-                results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.UsingResourcesCulture", ci.Name, altCulture));
-            GetCodePage(altCulture, ref codepage);
-            return (XmlNode)_cultures[altCulture.ToLowerInvariant()];
+            KeyValuePair<string, XmlNode> altCulturePair = _cultures.FirstOrDefault();
+            if (ci != null)
+            {
+                results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.UsingResourcesCulture", ci.Name, altCulturePair.Key));
+            }
+            GetCodePage(altCulturePair.Key, ref codepage);
+            return altCulturePair.Value;
         }
 
         private XmlNode GetResourcesNodeForSettings_Helper(CultureInfo culture, CultureInfo altCulture, BuildResults results, ref int codepage, bool fShowWarning)
         {
-            if (altCulture != null && _cultures.Contains(altCulture.Name.ToLowerInvariant()))
+            if (altCulture != null && _cultures.TryGetValue(altCulture.Name, out XmlNode cultureNode))
             {
-                if (fShowWarning && culture != null && results != null)
-                    results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.UsingResourcesCulture", culture.Name, altCulture.Name));
+                if (fShowWarning && culture != null)
+                {
+                    results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.UsingResourcesCulture", culture.Name, altCulture.Name));
+                }
 
                 codepage = altCulture.TextInfo.ANSICodePage;
-                return (XmlNode)_cultures[altCulture.Name.ToLowerInvariant()];
+                return cultureNode;
             }
 
             return null;
         }
 
-        private void GetCodePage(string culture, ref int codePage)
+        private static void GetCodePage(string culture, ref int codePage)
         {
             try
             {
-                System.Globalization.CultureInfo info = new System.Globalization.CultureInfo(culture);
+                var info = new CultureInfo(culture);
                 codePage = info.TextInfo.ANSICodePage;
             }
             catch (ArgumentException ex)
@@ -1869,7 +1870,7 @@ private void ReplacePackageFileAttributes(XmlNode targetNodes, string targetAttr
             }
         }
 
-        private XmlElement CreateApplicationElement(XmlElement configElement, BuildSettings settings)
+        private static XmlElement CreateApplicationElement(XmlElement configElement, BuildSettings settings)
         {
             XmlElement applicationElement = null;
 
@@ -1895,7 +1896,7 @@ private XmlElement CreateApplicationElement(XmlElement configElement, BuildSetti
             return applicationElement;
         }
 
-        private void AddAttribute(XmlNode node, string attributeName, string attributeValue)
+        private static void AddAttribute(XmlNode node, string attributeName, string attributeValue)
         {
             XmlAttribute attrib = node.OwnerDocument.CreateAttribute(attributeName);
             attrib.Value = attributeValue;
@@ -1905,21 +1906,21 @@ private void AddAttribute(XmlNode node, string attributeName, string attributeVa
         [SuppressMessage("Microsoft.Security.Xml", "CA3073: ReviewTrustedXsltUse.", Justification = "Input style sheet comes from our own assemblies. Hence it is a trusted source.")]
         [SuppressMessage("Microsoft.Security.Xml", "CA3059: UseXmlReaderForXPathDocument.", Justification = "Input style sheet comes from our own assemblies. Hence it is a trusted source.")]
         [SuppressMessage("Microsoft.Security.Xml", "CA3052: UseXmlResolver.", Justification = "Input style sheet comes from our own assemblies. Hence it is a trusted source.")]
-        private string XmlToConfigurationFile(XmlNode input)
+        public static string XmlToConfigurationFile(XmlNode input)
         {
-            using (XmlNodeReader reader = new XmlNodeReader(input))
+            using (var reader = new XmlNodeReader(input))
             {
                 Stream s = GetEmbeddedResourceStream(CONFIG_TRANSFORM);
-                XPathDocument d = new XPathDocument(s);
-                XslCompiledTransform xslc = new XslCompiledTransform();
+                var d = new XPathDocument(s);
+                var xslc = new XslCompiledTransform();
                 // Using the Trusted Xslt is fine as the style sheet comes from our own assembly.
                 xslc.Load(d, XsltSettings.TrustedXslt, new XmlUrlResolver());
 
-                XPathDocument xml = new XPathDocument(reader);
+                var xml = new XPathDocument(reader);
 
-                using (MemoryStream m = new MemoryStream())
+                using (var m = new MemoryStream())
                 {
-                    using (StreamWriter w = new StreamWriter(m))
+                    using (var w = new StreamWriter(m))
                     {
                         xslc.Transform(xml, null, w);
 
@@ -1938,7 +1939,7 @@ private string XmlToConfigurationFile(XmlNode input)
             }
         }
 
-        private Stream GetEmbeddedResourceStream(string name)
+        private static Stream GetEmbeddedResourceStream(string name)
         {
             Assembly a = Assembly.GetExecutingAssembly();
             Stream s = a.GetManifestResourceStream(String.Format(CultureInfo.InvariantCulture, "{0}.{1}", typeof(BootstrapperBuilder).Namespace, name));
@@ -1946,18 +1947,13 @@ private Stream GetEmbeddedResourceStream(string name)
             return s;
         }
 
-        private string GetAssemblyPath()
-        {
-            return System.IO.Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
-        }
-
-        private void DumpXmlToFile(XmlNode node, string fileName)
+        private static void DumpXmlToFile(XmlNode node, string fileName)
         {
             if (s_logging)
             {
                 try
                 {
-                    using (XmlTextWriter xmlwriter = new XmlTextWriter(System.IO.Path.Combine(s_logPath, fileName), System.Text.Encoding.UTF8))
+                    using (var xmlwriter = new XmlTextWriter(System.IO.Path.Combine(s_logPath, fileName), Encoding.UTF8))
                     {
                         xmlwriter.Formatting = Formatting.Indented;
                         xmlwriter.Indentation = 4;
@@ -1992,13 +1988,13 @@ private void DumpXmlToFile(XmlNode node, string fileName)
             }
         }
 
-        private void DumpStringToFile(string text, string fileName, bool append)
+        private static void DumpStringToFile(string text, string fileName, bool append)
         {
             if (s_logging)
             {
                 try
                 {
-                    using (StreamWriter fileWriter = new StreamWriter(System.IO.Path.Combine(s_logPath, fileName), append))
+                    using (var fileWriter = new StreamWriter(System.IO.Path.Combine(s_logPath, fileName), append))
                     {
                         fileWriter.Write(text);
                     }
@@ -2026,7 +2022,7 @@ private void DumpStringToFile(string text, string fileName, bool append)
             }
         }
 
-        private bool VerifyHomeSiteInformation(XmlNode packageFileNode, ProductBuilder builder, BuildSettings settings, BuildResults results)
+        private static bool VerifyHomeSiteInformation(XmlNode packageFileNode, ProductBuilder builder, BuildSettings settings, BuildResults results)
         {
             if (settings.ComponentsLocation != ComponentsLocation.HomeSite)
             {
@@ -2037,8 +2033,7 @@ private bool VerifyHomeSiteInformation(XmlNode packageFileNode, ProductBuilder b
 
             if (homesiteAttribute == null && builder.Product.CopyAllPackageFiles != CopyAllFilesType.CopyAllFilesIfNotHomeSite)
             {
-                if (results != null)
-                    results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.PackageHomeSiteMissing", builder.Name));
+                results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.PackageHomeSiteMissing", builder.Name));
                 return false;
             }
 
@@ -2069,20 +2064,23 @@ private bool AddVerificationInformation(XmlNode packageFileNode, string fileSour
                 {
                     // Always use the PublicKey of the file on disk
                     if (publicKey != null)
+                    {
                         ReplaceAttribute(packageFileNode, PUBLICKEY_ATTRIBUTE, publicKey);
+                    }
                     else
                     {
                         // File on disk is not signed.  Remove the public key info, and make sure the hash is written instead
                         packageFileNode.Attributes.RemoveNamedItem(PUBLICKEY_ATTRIBUTE);
                         if (hashAttribute == null)
+                        {
                             AddAttribute(packageFileNode, HASH_ATTRIBUTE, GetFileHash(fileSource));
+                        }
                     }
 
                     // If the public key in the file doesn't match the public key on disk, issue a build warning
                     if (publicKey == null || !publicKey.ToLowerInvariant().Equals(publicKeyAttribute.Value.ToLowerInvariant()))
                     {
-                        if (results != null)
-                            results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.DifferingPublicKeys", PUBLICKEY_ATTRIBUTE, builder.Name, fileSource));
+                        results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.DifferingPublicKeys", PUBLICKEY_ATTRIBUTE, builder.Name, fileSource));
                     }
                 }
                 if (hashAttribute != null)
@@ -2095,8 +2093,7 @@ private bool AddVerificationInformation(XmlNode packageFileNode, string fileSour
                     // If the public key in the file doesn't match the public key on disk, issue a build warning
                     if (!fileHash.ToLowerInvariant().Equals(hashAttribute.Value.ToLowerInvariant()))
                     {
-                        if (results != null)
-                            results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.DifferingPublicKeys", "Hash", builder.Name, fileSource));
+                        results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.DifferingPublicKeys", "Hash", builder.Name, fileSource));
                     }
                 }
             }
@@ -2104,10 +2101,7 @@ private bool AddVerificationInformation(XmlNode packageFileNode, string fileSour
             {
                 if (hashAttribute == null && publicKeyAttribute == null)
                 {
-                    if (results != null)
-                    {
-                        results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.MissingVerificationInformation", fileName, builder.Name));
-                    }
+                    results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.MissingVerificationInformation", fileName, builder.Name));
                     return false;
                 }
             }
@@ -2115,13 +2109,13 @@ private bool AddVerificationInformation(XmlNode packageFileNode, string fileSour
             return true;
         }
 
-        private string GetPublicKeyOfFile(string fileSource)
+        private static string GetPublicKeyOfFile(string fileSource)
         {
             if (File.Exists(fileSource))
             {
                 try
                 {
-                    X509Certificate cert = new X509Certificate(fileSource);
+                    var cert = new X509Certificate(fileSource);
                     string publicKey = cert.GetPublicKeyString();
                     return publicKey;
                 }
@@ -2134,7 +2128,7 @@ private string GetPublicKeyOfFile(string fileSource)
             return null;
         }
 
-        private void ConvertChildsNodeToAttributes(XmlNode node)
+        private static void ConvertChildsNodeToAttributes(XmlNode node)
         {
             XmlNode childNode = node.FirstChild;
             while (childNode != null)
@@ -2157,18 +2151,18 @@ private static string GetLogPath()
             string logPath = System.IO.Path.Combine(
                 Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
                 @"Microsoft\VisualStudio\" + VisualStudioConstants.CurrentVisualStudioVersion + @"\VSPLOG");
-            if (!Directory.Exists(logPath))
-                Directory.CreateDirectory(logPath);
+            Directory.CreateDirectory(logPath);
             return logPath;
         }
 
-        private Dictionary<string, Product> GetIncludedProducts(Product product)
+        private static Dictionary<string, Product> GetIncludedProducts(Product product)
         {
-            Dictionary<string, Product> includedProducts = new Dictionary<string, Product>(StringComparer.OrdinalIgnoreCase);
-
-            // Add in this product in case there is a circular includes: 
-            // we won't continue to explore this product.  It will be removed later.
-            includedProducts.Add(product.ProductCode, product);
+            var includedProducts = new Dictionary<string, Product>(StringComparer.OrdinalIgnoreCase)
+            {
+                // Add in this product in case there is a circular includes: 
+                // we won't continue to explore this product.  It will be removed later.
+                { product.ProductCode, product }
+            };
 
             // Recursively add included products 
             foreach (Product p in product.Includes)
@@ -2180,7 +2174,7 @@ private Dictionary<string, Product> GetIncludedProducts(Product product)
             return includedProducts;
         }
 
-        private void AddIncludedProducts(Product product, Dictionary<string, Product> includedProducts)
+        private static void AddIncludedProducts(Product product, Dictionary<string, Product> includedProducts)
         {
             if (!includedProducts.ContainsKey(product.ProductCode))
             {
@@ -2192,14 +2186,16 @@ private void AddIncludedProducts(Product product, Dictionary<string, Product> in
             }
         }
 
-        private string MapLCIDToCultureName(int lcid)
+        private static string MapLCIDToCultureName(int lcid)
         {
             if (lcid == 0)
+            {
                 return Util.DefaultCultureInfo.Name;
+            }
 
             try
             {
-                CultureInfo ci = new CultureInfo(lcid);
+                var ci = new CultureInfo(lcid);
                 return ci.Name;
             }
             catch (ArgumentException)
diff --git a/src/Tasks/BootstrapperUtil/BuildMessage.cs b/src/Tasks/BootstrapperUtil/BuildMessage.cs
index 250ad90a8fc..d2131deb26d 100644
--- a/src/Tasks/BootstrapperUtil/BuildMessage.cs
+++ b/src/Tasks/BootstrapperUtil/BuildMessage.cs
@@ -2,9 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Globalization;
-using System.Runtime.InteropServices;
 using System.Text.RegularExpressions;
 using Microsoft.Build.Shared;
 
@@ -15,35 +13,27 @@ namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
     /// </summary>
     public class BuildMessage : IBuildMessage
     {
-        private BuildMessageSeverity _severity;
-        private string _message;
-        private string _helpKeyword;
-        private string _helpCode;
-        private int _helpId;
-
         private static readonly Regex s_msbuildMessageCodePattern = new Regex(@"(\d+)$");
 
         private BuildMessage(BuildMessageSeverity severity, string message, string helpKeyword, string helpCode)
         {
-            _severity = severity;
-            _message = message;
-            _helpKeyword = helpKeyword;
-            _helpCode = helpCode;
-            if (!String.IsNullOrEmpty(_helpCode))
+            Severity = severity;
+            Message = message;
+            HelpKeyword = helpKeyword;
+            HelpCode = helpCode;
+            if (!String.IsNullOrEmpty(HelpCode))
             {
-                Match match = s_msbuildMessageCodePattern.Match(_helpCode);
+                Match match = s_msbuildMessageCodePattern.Match(HelpCode);
                 if (match.Success)
                 {
-                    _helpId = int.Parse(match.Value, CultureInfo.InvariantCulture);
+                    HelpId = int.Parse(match.Value, CultureInfo.InvariantCulture);
                 }
             }
         }
 
         internal static BuildMessage CreateMessage(BuildMessageSeverity severity, string resourceName, params object[] args)
         {
-            string helpCode;
-            string helpKeyword;
-            string message = ResourceUtilities.FormatResourceString(out helpCode, out helpKeyword, resourceName, args);
+            string message = ResourceUtilities.FormatResourceString(out string helpCode, out string helpKeyword, resourceName, args);
 
             return new BuildMessage(severity, message, helpKeyword, helpCode);
         }
@@ -51,38 +41,23 @@ internal static BuildMessage CreateMessage(BuildMessageSeverity severity, string
         /// <summary>
         /// This severity of this build message
         /// </summary>
-        public BuildMessageSeverity Severity
-        {
-            get { return _severity; }
-        }
+        public BuildMessageSeverity Severity { get; }
 
         /// <summary>
         /// A text string describing the details of the build message
         /// </summary>
-        public string Message
-        {
-            get { return _message; }
-        }
+        public string Message { get; }
 
         /// <summary>
         /// The MSBuild F1-help keyword for the host IDE, or null
         /// </summary>
-        public string HelpKeyword
-        {
-            get { return _helpKeyword; }
-        }
+        public string HelpKeyword { get; }
 
         /// <summary>
         /// The MSBuild help id for the host IDE
         /// </summary>
-        public int HelpId
-        {
-            get { return _helpId; }
-        }
+        public int HelpId { get; }
 
-        internal string HelpCode
-        {
-            get { return _helpCode; }
-        }
+        internal string HelpCode { get; }
     }
 }
diff --git a/src/Tasks/BootstrapperUtil/BuildResults.cs b/src/Tasks/BootstrapperUtil/BuildResults.cs
index 23cfbf4f9d8..ef5b37fb35b 100644
--- a/src/Tasks/BootstrapperUtil/BuildResults.cs
+++ b/src/Tasks/BootstrapperUtil/BuildResults.cs
@@ -1,7 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections;
+using System.Collections.Generic;
 using System.Runtime.InteropServices;
 
 namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
@@ -9,38 +9,26 @@ namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
     /// <summary>
     /// Represents the results of the Build operation of the BootstrapperBuilder.
     /// </summary>
-    [ComVisible(true), GuidAttribute("FAD7BA7C-CA00-41e0-A5EF-2DA9A74E58E6"), ClassInterface(ClassInterfaceType.None)]
+    [ComVisible(true), Guid("FAD7BA7C-CA00-41e0-A5EF-2DA9A74E58E6"), ClassInterface(ClassInterfaceType.None)]
     public class BuildResults : IBuildResults
     {
-        private bool _succeeded;
-        private string _keyFile;
-        private ArrayList _componentFiles;
-        private ArrayList _messages;
+        private readonly List<string> _componentFiles = new List<string>();
+        private readonly List<BuildMessage> _messages = new List<BuildMessage>();
 
         internal BuildResults()
         {
-            _succeeded = false;
-            _keyFile = string.Empty;
-            _componentFiles = new ArrayList();
-            _messages = new ArrayList();
         }
 
         /// <summary>
         /// Returns true if the bootstrapper build was successful, false otherwise
         /// </summary>
-        public bool Succeeded
-        {
-            get { return _succeeded; }
-        }
+        public bool Succeeded { get; private set; }
 
         /// <summary>
         /// The file path to the generated primary bootstrapper file
         /// </summary>
         /// <value>Path to setup.exe</value>
-        public string KeyFile
-        {
-            get { return _keyFile; }
-        }
+        public string KeyFile { get; private set; } = string.Empty;
 
         /// <summary>
         /// File paths to copied component installer files
@@ -51,11 +39,11 @@ public string[] ComponentFiles
             get
             {
                 if (_componentFiles.Count == 0)
+                {
                     return null;
+                }
 
-                string[] files = new string[_componentFiles.Count];
-                _componentFiles.CopyTo(files);
-                return files;
+                return _componentFiles.ToArray();
             }
         }
 
@@ -67,11 +55,11 @@ public BuildMessage[] Messages
             get
             {
                 if (_messages.Count == 0)
+                {
                     return null;
+                }
 
-                BuildMessage[] msgs = new BuildMessage[_messages.Count];
-                _messages.CopyTo(msgs);
-                return msgs;
+                return _messages.ToArray();
             }
         }
 
@@ -87,12 +75,12 @@ internal void AddComponentFiles(string[] filePaths)
 
         internal void BuildSucceeded()
         {
-            _succeeded = true;
+            Succeeded = true;
         }
 
         internal void SetKeyFile(string filePath)
         {
-            _keyFile = filePath;
+            KeyFile = filePath;
         }
     }
 }
diff --git a/src/Tasks/BootstrapperUtil/BuildSettings.cs b/src/Tasks/BootstrapperUtil/BuildSettings.cs
index 7bf87c7c70d..d9d37baef45 100644
--- a/src/Tasks/BootstrapperUtil/BuildSettings.cs
+++ b/src/Tasks/BootstrapperUtil/BuildSettings.cs
@@ -8,156 +8,81 @@ namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
     /// <summary>
     /// This class defines the settings for the bootstrapper build operation.
     /// </summary>
-    [ComVisible(true), GuidAttribute("5D13802C-C830-4b41-8E7A-F69D9DD6A095"), ClassInterface(ClassInterfaceType.None)]
+    [ComVisible(true), Guid("5D13802C-C830-4b41-8E7A-F69D9DD6A095"), ClassInterface(ClassInterfaceType.None)]
     public class BuildSettings : IBuildSettings
     {
-        private string _applicationName = null;
-        private string _applicationFile = null;
-        private bool _applicationRequiresElevation = false;
-        private string _applicationUrl = null;
-        private ComponentsLocation _componentsLocation = ComponentsLocation.HomeSite;
-        private string _componentsUrl = null;
-        private bool _fCopyComponents = false;
-        private int _lcid = Util.DefaultCultureInfo.LCID;
-        private int _fallbackLCID = Util.DefaultCultureInfo.LCID;
-        private string _outputPath = null;
-        private string _supportUrl = null;
-        private ProductBuilderCollection _productBuilders = null;
-        private bool _fValidate = false;
-        private string _culture = null;
-        private string _fallbackCulture = null;
-
         public BuildSettings()
         {
-            _productBuilders = new ProductBuilderCollection();
+            ProductBuilders = new ProductBuilderCollection();
         }
 
         /// <summary>
         /// The name of the application to be installed after the bootstrapper has installed all required components.  If no application is to be installed, this parameter may be null
         /// </summary>
-        public string ApplicationName
-        {
-            get { return _applicationName; }
-            set { _applicationName = value; }
-        }
+        public string ApplicationName { get; set; }
 
         /// <summary>
         /// The file to be installed after the bootstrapper has installed the required components.  It is assumed that this file path is relative to the bootstrapper source path.  If no application is to be installed, this parameter may be null
         /// </summary>
-        public string ApplicationFile
-        {
-            get { return _applicationFile; }
-            set { _applicationFile = value; }
-        }
+        public string ApplicationFile { get; set; }
 
         /// <summary>
         /// A value of true indicates that the application should require elevation to install on Vista.
         /// </summary>
-        public bool ApplicationRequiresElevation
-        {
-            get { return _applicationRequiresElevation; }
-            set { _applicationRequiresElevation = value; }
-        }
+        public bool ApplicationRequiresElevation { get; set; }
 
         /// <summary>
         /// The expected source location if the bootstrapper is published to a website.  It is expected that the ApplicationFile, if specified, will be published to the location consistent to this value. If ComponentsLocation is Relative, required component files will also be published in a manner consistent with this value.  This value may be null if setup.exe is not to be published to the web
         /// </summary>
-        public string ApplicationUrl
-        {
-            get { return _applicationUrl; }
-            set { _applicationUrl = value; }
-        }
+        public string ApplicationUrl { get; set; }
 
         /// <summary>
         /// Specifies the install time location for bootstrapper components
         /// </summary>
-        public ComponentsLocation ComponentsLocation
-        {
-            get { return _componentsLocation; }
-            set { _componentsLocation = value; }
-        }
+        public ComponentsLocation ComponentsLocation { get; set; } = ComponentsLocation.HomeSite;
 
         /// <summary>
         /// The location the bootstrapper install time will use for components if ComponentsLocation is "Absolute"
         /// </summary>
-        public string ComponentsUrl
-        {
-            get { return _componentsUrl; }
-            set { _componentsUrl = value; }
-        }
+        public string ComponentsUrl { get; set; }
 
         /// <summary>
         /// If true, the bootstrapper components will be copied to the build output directory.  If false, the files will not be copied
         /// </summary>
-        public bool CopyComponents
-        {
-            get { return _fCopyComponents; }
-            set { _fCopyComponents = value; }
-        }
+        public bool CopyComponents { get; set; }
 
         /// <summary>
         /// The culture identifier for the bootstrapper to be built
         /// </summary>
-        public int LCID
-        {
-            get { return _lcid; }
-            set { _lcid = value; }
-        }
+        public int LCID { get; set; } = Util.DefaultCultureInfo.LCID;
 
         /// <summary>
         /// The culture identifier to use if the LCID identifier is not available
         /// </summary>
-        public int FallbackLCID
-        {
-            get { return _fallbackLCID; }
-            set { _fallbackLCID = value; }
-        }
+        public int FallbackLCID { get; set; } = Util.DefaultCultureInfo.LCID;
 
         /// <summary>
         /// The file location to copy output files to
         /// </summary>
-        public string OutputPath
-        {
-            get { return _outputPath; }
-            set { _outputPath = value; }
-        }
+        public string OutputPath { get; set; } = null;
 
         /// <summary>
         /// The product builders to use for generating the bootstrapper
         /// </summary>
-        public ProductBuilderCollection ProductBuilders
-        {
-            get { return _productBuilders; }
-        }
+        public ProductBuilderCollection ProductBuilders { get; }
 
         /// <summary>
         /// Specifies a URL for the Web site containing support information for the bootstrapper
         /// </summary>
-        public string SupportUrl
-        {
-            get { return _supportUrl; }
-            set { _supportUrl = value; }
-        }
+        public string SupportUrl { get; set; }
 
         /// <summary>
         /// True if the bootstrapper will perform XML validation on the component manifests
         /// </summary>
-        public bool Validate
-        {
-            get { return _fValidate; }
-            set { _fValidate = value; }
-        }
+        public bool Validate { get; set; }
 
-        internal string Culture
-        {
-            get { return _culture; }
-            set { _culture = value; }
-        }
+        internal string Culture { get; set; }
 
-        internal string FallbackCulture
-        {
-            get { return _fallbackCulture; }
-            set { _fallbackCulture = value; }
-        }
+        internal string FallbackCulture { get; set; }
     }
 }
diff --git a/src/Tasks/BootstrapperUtil/Interfaces.cs b/src/Tasks/BootstrapperUtil/Interfaces.cs
index 712396280b7..8858e85b242 100644
--- a/src/Tasks/BootstrapperUtil/Interfaces.cs
+++ b/src/Tasks/BootstrapperUtil/Interfaces.cs
@@ -1,8 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections;
 using System.Runtime.InteropServices;
 
 namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
@@ -11,8 +9,7 @@ namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
     /// This interface exposes functionality necessary to build a bootstrapper.
     /// </summary>
     [ComVisible(true)]
-    [Guid("1D202366-5EEA-4379-9255-6F8CDB8587C9"),
-    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
+    [Guid("1D202366-5EEA-4379-9255-6F8CDB8587C9"), InterfaceType(ComInterfaceType.InterfaceIsDual)]
     public interface IBootstrapperBuilder
     {
         /// <summary>
@@ -20,20 +17,13 @@ public interface IBootstrapperBuilder
         /// </summary>
         /// <value>Path to bootstrapper files.</value>
         [DispId(1)]
-        string Path
-        {
-            get;
-            set;
-        }
+        string Path { get; set; }
 
         /// <summary>
         /// Returns all products available at the current bootstrapper Path
         /// </summary>
         [DispId(4)]
-        ProductCollection Products
-        {
-            get;
-        }
+        ProductCollection Products { get; }
 
         /// <summary>
         /// Generates a bootstrapper based on the specified settings.
@@ -44,209 +34,136 @@ ProductCollection Products
         BuildResults Build(BuildSettings settings);
     }
 
-
     /// <summary>
     /// This interface defines the settings for the bootstrapper build operation.
     /// </summary>
     [ComVisible(true)]
-    [Guid("87EEBC69-0948-4ce6-A2DE-819162B87CC6"),
-    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
+    [Guid("87EEBC69-0948-4ce6-A2DE-819162B87CC6"), InterfaceType(ComInterfaceType.InterfaceIsDual)]
     public interface IBuildSettings
     {
         /// <summary>
         /// The name of the application to be installed after the bootstrapper has installed all required components.  If no application is to be installed, this parameter may be null
         /// </summary>
         [DispId(1)]
-        string ApplicationName
-        {
-            get;
-            set;
-        }
+        string ApplicationName { get; set; }
 
         /// <summary>
         /// The file to be installed after the bootstrapper has installed the required components.  It is assumed that this file path is relative to the bootstrapper source path.  If no application is to be installed, this parameter may be null
         /// </summary>
         [DispId(2)]
-        string ApplicationFile
-        {
-            get;
-            set;
-        }
+        string ApplicationFile { get; set; }
 
         /// <summary>
         /// The expected source location if the bootstrapper is published to a website.  It is expected that the ApplicationFile, if specified, will be published to the location consistent to this value. If ComponentsLocation is Relative, required component files will also be published in a manner consistent with this value.  This value may be null if setup.exe is not to be published to the web
         /// </summary>
         [DispId(3)]
-        string ApplicationUrl
-        {
-            get;
-            set;
-        }
+        string ApplicationUrl { get; set; }
 
         /// <summary>
         /// The location the bootstrapper install time will use for components if ComponentsLocation is "Absolute"
         /// </summary>
         [DispId(4)]
-        string ComponentsUrl
-        {
-            get;
-            set;
-        }
+        string ComponentsUrl { get; set; }
 
         /// <summary>
         /// If true, the bootstrapper components will be copied to the build output directory.  If false, the files will not be copied
         /// </summary>
         [DispId(5)]
-        bool CopyComponents
-        {
-            get;
-            set;
-        }
+        bool CopyComponents { get; set; }
 
         /// <summary>
         /// The culture identifier for the bootstrapper to be built
         /// </summary>
         [DispId(6)]
-        int LCID
-        {
-            get;
-            set;
-        }
+        int LCID { get; set; }
 
         /// <summary>
         /// The culture identifier to use if the LCID identifier is not available
         /// </summary>
         [DispId(7)]
-        int FallbackLCID
-        {
-            get;
-            set;
-        }
+        int FallbackLCID { get; set; }
 
         /// <summary>
         /// The file location to copy output files to
         /// </summary>
         [DispId(8)]
-        string OutputPath
-        {
-            get;
-            set;
-        }
+        string OutputPath { get; set; }
 
         /// <summary>
         /// The product builders to use for generating the bootstrapper
         /// </summary>
         [DispId(9)]
-        ProductBuilderCollection ProductBuilders
-        {
-            get;
-        }
+        ProductBuilderCollection ProductBuilders { get; }
 
         /// <summary>
         /// True if the bootstrapper will perform XML validation on the component manifests
         /// </summary>
         [DispId(10)]
-        bool Validate
-        {
-            get;
-            set;
-        }
+        bool Validate { get; set; }
 
         /// <summary>
         /// Specifies the install time location for bootstrapper components
         /// </summary>
         [DispId(11)]
-        ComponentsLocation ComponentsLocation
-        {
-            get;
-            set;
-        }
+        ComponentsLocation ComponentsLocation { get; set; }
 
         /// <summary>
         /// Specifies a URL for the Web site containing support information for the bootstrapper
         /// </summary>
         [DispId(12)]
-        string SupportUrl
-        {
-            get;
-            set;
-        }
+        string SupportUrl { get; set; }
 
         /// <summary>
         /// A value of true indicates that the application should require elevation to install on Windows Vista.
         /// </summary>
         [DispId(13)]
-        bool ApplicationRequiresElevation
-        {
-            get;
-            set;
-        }
+        bool ApplicationRequiresElevation { get; set; }
     }
 
-
-
-
     /// <summary>
     /// This interface represents a product in the found by the BootstrapperBuilder in the Path property.
     /// </summary>
     [ComVisible(true)]
-    [Guid("9E81BE3D-530F-4a10-8349-5D5947BA59AD"),
-    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
+    [Guid("9E81BE3D-530F-4a10-8349-5D5947BA59AD"), InterfaceType(ComInterfaceType.InterfaceIsDual)]
     public interface IProduct
     {
         /// <summary>
         /// The ProductBuilder representation of this Product
         /// </summary>
         [DispId(1)]
-        ProductBuilder ProductBuilder
-        {
-            get;
-        }
+        ProductBuilder ProductBuilder { get; }
 
         /// <summary>
         /// A human-readable name for this product
         /// </summary>
         [DispId(2)]
-        string Name
-        {
-            get;
-        }
+        string Name { get; }
 
         /// <summary>
         /// A string specifying the unique identifier of this product
         /// </summary>
         [DispId(3)]
-        string ProductCode
-        {
-            get;
-        }
+        string ProductCode { get; }
 
         /// <summary>
         /// All products which this product also installs
         /// </summary>
         [DispId(4)]
-        ProductCollection Includes
-        {
-            get;
-        }
+        ProductCollection Includes { get; }
     }
 
     /// <summary>
     /// This interface describes a collection of Product objects. This collection is a closed set that is generated by the BootstrapperBuilder based on the Path property. The client cannot add or remove items from this collection.
     /// </summary>
     [ComVisible(true)]
-    [Guid("63F63663-8503-4875-814C-09168E595367"),
-    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
+    [Guid("63F63663-8503-4875-814C-09168E595367"), InterfaceType(ComInterfaceType.InterfaceIsDual)]
     public interface IProductCollection
     {
         /// <summary>
         /// Gets the number of elements actually contained in the ProductCollection
         /// </summary>
         [DispId(1)]
-        int Count
-        {
-            get;
-        }
+        int Count { get; }
 
         /// <summary>
         /// Gets the Product at the specified index.
@@ -269,26 +186,21 @@ int Count
     /// This interface represents a buildable version of a Product.  Used for the BootstrapperBuilder's Build method.
     /// </summary>
     [ComVisible(true)]
-    [Guid("0777432F-A60D-48b3-83DB-90326FE8C96E"),
-    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
+    [Guid("0777432F-A60D-48b3-83DB-90326FE8C96E"), InterfaceType(ComInterfaceType.InterfaceIsDual)]
     public interface IProductBuilder
     {
         /// <summary>
         /// The product corresponding to this builder
         /// </summary>
         [DispId(1)]
-        Product Product
-        {
-            get;
-        }
+        Product Product { get; }
     }
 
     /// <summary>
     /// This class contains a collection of ProductBuilder objects. Used for the BootstrapperBuilder's Build method.
     /// </summary>
     [ComVisible(true)]
-    [Guid("0D593FC0-E3F1-4dad-A674-7EA4D327F79B"),
-    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
+    [Guid("0D593FC0-E3F1-4dad-A674-7EA4D327F79B"), InterfaceType(ComInterfaceType.InterfaceIsDual)]
     public interface IProductBuilderCollection
     {
         /// <summary>
@@ -311,84 +223,59 @@ public interface IBuildResults
         /// Returns true if the bootstrapper build was successful, false otherwise
         /// </summary>
         [DispId(1)]
-        bool Succeeded
-        {
-            get;
-        }
+        bool Succeeded { get; }
 
         /// <summary>
         /// The file path to the generated primary bootstrapper file
         /// </summary>
         /// <value>Path to setup.exe</value>
         [DispId(2)]
-        string KeyFile
-        {
-            get;
-        }
+        string KeyFile { get; }
 
         /// <summary>
         /// File paths to copied component installer files
         /// </summary>
         /// <value>Path to component files</value>
         [DispId(3)]
-        string[] ComponentFiles
-        {
-            get;
-        }
+        string[] ComponentFiles { get; }
 
         /// <summary>
         /// The build messages generated from a bootstrapper build
         /// </summary>
         [DispId(4)]
-        BuildMessage[] Messages
-        {
-            get;
-        }
+        BuildMessage[] Messages { get; }
     }
 
     /// <summary>
     /// Represents messages that occur during the BootstrapperBuilder's Build operation.
     /// </summary>
     [ComVisible(true)]
-    [Guid("E3C981EA-99E6-4f48-8955-1AAFDFB5ACE4"),
-    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
+    [Guid("E3C981EA-99E6-4f48-8955-1AAFDFB5ACE4"), InterfaceType(ComInterfaceType.InterfaceIsDual)]
     public interface IBuildMessage
     {
         /// <summary>
         /// This severity of this build message
         /// </summary>
         [DispId(1)]
-        BuildMessageSeverity Severity
-        {
-            get;
-        }
+        BuildMessageSeverity Severity { get; }
 
         /// <summary>
         /// A text string describing the details of the build message
         /// </summary>
         [DispId(2)]
-        string Message
-        {
-            get;
-        }
+        string Message { get; }
 
         /// <summary>
         /// The MSBuild F1-help keyword for the host IDE, or null
         /// </summary>
         [DispId(3)]
-        string HelpKeyword
-        {
-            get;
-        }
+        string HelpKeyword { get; }
 
         /// <summary>
         /// The MSBuild help id for the host IDE
         /// </summary>
         [DispId(4)]
-        int HelpId
-        {
-            get;
-        }
+        int HelpId { get; }
     }
 
     /// <summary>
diff --git a/src/Tasks/BootstrapperUtil/NativeMethods.cs b/src/Tasks/BootstrapperUtil/NativeMethods.cs
index 08149eda291..08907f653c6 100644
--- a/src/Tasks/BootstrapperUtil/NativeMethods.cs
+++ b/src/Tasks/BootstrapperUtil/NativeMethods.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
 using System.Runtime.InteropServices;
 
 namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
diff --git a/src/Tasks/BootstrapperUtil/Package.cs b/src/Tasks/BootstrapperUtil/Package.cs
index d46ba80d4eb..d05c8171b61 100644
--- a/src/Tasks/BootstrapperUtil/Package.cs
+++ b/src/Tasks/BootstrapperUtil/Package.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Xml;
 using System.Runtime.InteropServices;
 
@@ -10,54 +9,35 @@ namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
     [ComVisible(false)]
     internal class Package
     {
-        private string _name;
-        private string _culture;
-        private Product _product;
-        private XmlNode _node;
-        private XmlValidationResults _validationResults;
-
         public Package(Product product, XmlNode node, XmlValidationResults validationResults, string name, string culture)
         {
-            _product = product;
-            _node = node;
-            _name = name;
-            _culture = culture;
-            _validationResults = validationResults;
+            Product = product;
+            Node = node;
+            Name = name;
+            Culture = culture;
+            ValidationResults = validationResults;
         }
 
-        internal XmlNode Node
-        {
-            get { return _node; }
-        }
+        internal XmlNode Node { get; }
 
-        public string Name
-        {
-            get { return _name; }
-        }
+        public string Name { get; }
 
-        public string Culture
-        {
-            get { return _culture; }
-        }
+        public string Culture { get; }
 
-        public Product Product
-        {
-            get { return _product; }
-        }
+        public Product Product { get; }
 
         internal bool ValidationPassed
         {
             get
             {
-                if (_validationResults == null)
+                if (ValidationResults == null)
+                {
                     return true;
-                return _validationResults.ValidationPassed;
+                }
+                return ValidationResults.ValidationPassed;
             }
         }
 
-        internal XmlValidationResults ValidationResults
-        {
-            get { return _validationResults; }
-        }
+        internal XmlValidationResults ValidationResults { get; }
     }
 }
diff --git a/src/Tasks/BootstrapperUtil/PackageCollection.cs b/src/Tasks/BootstrapperUtil/PackageCollection.cs
index 64f2457ce39..0fe53b2c185 100644
--- a/src/Tasks/BootstrapperUtil/PackageCollection.cs
+++ b/src/Tasks/BootstrapperUtil/PackageCollection.cs
@@ -3,48 +3,34 @@
 
 using System;
 using System.Collections;
-using System.Runtime.InteropServices;
+using System.Collections.Generic;
 using System.Diagnostics;
 
 namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
 {
     internal class PackageCollection : IEnumerable
     {
-        private ArrayList _list;
-        private Hashtable _cultures;
-
-        public PackageCollection()
-        {
-            _list = new ArrayList();
-            _cultures = new Hashtable();
-        }
+        private readonly List<Package> _list = new List<Package>();
+        private readonly Dictionary<string, Package> _cultures = new Dictionary<string, Package>(StringComparer.OrdinalIgnoreCase);
 
         public Package Item(int index)
         {
-            return (Package)_list[index];
+            return _list[index];
         }
 
         public Package Package(string culture)
         {
-            if (_cultures.Contains(culture.ToLowerInvariant()))
-            {
-                return (Package)_cultures[culture.ToLowerInvariant()];
-            }
-
-            return null;
+            return _cultures.TryGetValue(culture, out Package package) ? package : null;
         }
 
-        public int Count
-        {
-            get { return _list.Count; }
-        }
+        public int Count => _list.Count;
 
         internal void Add(Package package)
         {
-            if (!_cultures.Contains(package.Culture.ToLowerInvariant()))
+            if (!_cultures.ContainsKey(package.Culture))
             {
                 _list.Add(package);
-                _cultures.Add(package.Culture.ToLowerInvariant(), package);
+                _cultures.Add(package.Culture, package);
             }
             else
             {
diff --git a/src/Tasks/BootstrapperUtil/Product.cs b/src/Tasks/BootstrapperUtil/Product.cs
index 5c1f28bf1ff..93fd74ef4ae 100644
--- a/src/Tasks/BootstrapperUtil/Product.cs
+++ b/src/Tasks/BootstrapperUtil/Product.cs
@@ -19,18 +19,10 @@ internal enum CopyAllFilesType
     /// <summary>
     /// This class represents a product in the found by the BootstrapperBuilder in the Path property.
     /// </summary>
-    [ComVisible(true), GuidAttribute("532BF563-A85D-4088-8048-41F51AC5239F"), ClassInterface(ClassInterfaceType.None)]
+    [ComVisible(true), Guid("532BF563-A85D-4088-8048-41F51AC5239F"), ClassInterface(ClassInterfaceType.None)]
     public class Product : IProduct
     {
-        private XmlNode _node;
-        private string _productCode;
-        private PackageCollection _packages;
-        private ProductCollection _includes;
-        private List<List<Product>> _dependencies;
-        private ArrayList _missingDependencies;
-        private Hashtable _cultures;
-        private CopyAllFilesType _copyAllPackageFiles;
-        private ProductValidationResults _validationResults;
+        private readonly Dictionary<string, Package> _cultures = new Dictionary<string, Package>(StringComparer.OrdinalIgnoreCase);
 
         public Product()
         {
@@ -40,47 +32,40 @@ public Product()
 
         internal Product(XmlNode node, string code, ProductValidationResults validationResults, string copyAll)
         {
-            _node = node;
-            _packages = new PackageCollection();
-            _includes = new ProductCollection();
-            _dependencies = new List<List<Product>>();
-            _missingDependencies = new ArrayList();
-            _productCode = code;
-            _validationResults = validationResults;
-            _cultures = new Hashtable();
+            Node = node;
+            Packages = new PackageCollection();
+            Includes = new ProductCollection();
+            Dependencies = new List<List<Product>>();
+            MissingDependencies = new List<List<string>>();
+            ProductCode = code;
+            ValidationResults = validationResults;
             if (copyAll == "IfNotHomeSite")
-                _copyAllPackageFiles = CopyAllFilesType.CopyAllFilesIfNotHomeSite;
+            {
+                CopyAllPackageFiles = CopyAllFilesType.CopyAllFilesIfNotHomeSite;
+            }
             else if (copyAll == "false")
-                _copyAllPackageFiles = CopyAllFilesType.CopyAllFilesFalse;
+            {
+                CopyAllPackageFiles = CopyAllFilesType.CopyAllFilesFalse;
+            }
             else
-                _copyAllPackageFiles = CopyAllFilesType.CopyAllFilesTrue;
+            {
+                CopyAllPackageFiles = CopyAllFilesType.CopyAllFilesTrue;
+            }
         }
 
-        internal XmlNode Node
-        {
-            get { return _node; }
-        }
+        internal XmlNode Node { get; }
 
-        internal CopyAllFilesType CopyAllPackageFiles
-        {
-            get { return _copyAllPackageFiles; }
-        }
+        internal CopyAllFilesType CopyAllPackageFiles { get; }
 
         /// <summary>
         /// The ProductBuilder representation of this Product
         /// </summary>
-        public ProductBuilder ProductBuilder
-        {
-            get { return new ProductBuilder(this); }
-        }
+        public ProductBuilder ProductBuilder => new ProductBuilder(this);
 
         /// <summary>
         /// A string specifying the unique identifier of this product
         /// </summary>
-        public string ProductCode
-        {
-            get { return _productCode; }
-        }
+        public string ProductCode { get; }
 
         /// <summary>
         /// A human-readable name for this product
@@ -90,7 +75,7 @@ public string Name
             get
             {
                 CultureInfo culture = Util.DefaultCultureInfo;
-                Package p = _packages.Package(culture.Name);
+                Package p = Packages.Package(culture.Name);
 
                 if (p != null)
                 {
@@ -99,7 +84,7 @@ public string Name
 
                 while (culture != null && culture != CultureInfo.InvariantCulture)
                 {
-                    p = _packages.Package(culture.Parent.Name);
+                    p = Packages.Package(culture.Parent.Name);
 
                     if (p != null)
                     {
@@ -109,36 +94,30 @@ public string Name
                     culture = culture.Parent;
                 }
 
-                if (_packages.Count > 0)
+                if (Packages.Count > 0)
                 {
-                    return _packages.Item(0).Name;
+                    return Packages.Item(0).Name;
                 }
 
-                return _productCode.ToString();
+                return ProductCode;
             }
         }
 
         /// <summary>
         /// All products which this product also installs
         /// </summary>
-        public ProductCollection Includes
-        {
-            get { return _includes; }
-        }
+        public ProductCollection Includes { get; }
 
-        internal List<List<Product>> Dependencies
-        {
-            get { return _dependencies; }
-        }
+        internal List<List<Product>> Dependencies { get; }
 
         internal bool ContainsCulture(string culture)
         {
-            return _cultures.Contains(culture.ToLowerInvariant());
+            return _cultures.ContainsKey(culture);
         }
 
         internal bool ContainsDependencies(List<Product> dependenciesToCheck)
         {
-            foreach (List<Product> d in _dependencies)
+            foreach (List<Product> d in Dependencies)
             {
                 bool found = true;
                 foreach (Product p in d)
@@ -146,7 +125,7 @@ internal bool ContainsDependencies(List<Product> dependenciesToCheck)
                     bool containedInDependencies = false;
                     foreach (Product pd in dependenciesToCheck)
                     {
-                        if (p._productCode == pd._productCode)
+                        if (p.ProductCode == pd.ProductCode)
                         {
                             containedInDependencies = true;
                             break;
@@ -168,23 +147,19 @@ internal bool ContainsDependencies(List<Product> dependenciesToCheck)
             return false;
         }
 
-        internal ArrayList MissingDependencies
-        {
-            get
-            {
-                return _missingDependencies;
-            }
-        }
+        internal List<List<string>> MissingDependencies { get; }
 
         internal void AddPackage(Package package)
         {
-            if (package == null || String.IsNullOrEmpty(package.Culture))
-                throw new ArgumentNullException("package");
+            if (String.IsNullOrEmpty(package?.Culture))
+            {
+                throw new ArgumentNullException(nameof(package));
+            }
 
-            if (!_cultures.Contains(package.Culture.ToLowerInvariant()))
+            if (!_cultures.ContainsKey(package.Culture))
             {
-                _packages.Add(package);
-                _cultures.Add(package.Culture.ToLowerInvariant(), package);
+                Packages.Add(package);
+                _cultures.Add(package.Culture, package);
             }
             else
             {
@@ -194,20 +169,19 @@ internal void AddPackage(Package package)
 
         internal void AddIncludedProduct(Product product)
         {
-            _includes.Add(product);
+            Includes.Add(product);
         }
 
         internal void AddDependentProduct(Product product)
         {
-            List<Product> newDependency = new List<Product>();
-            newDependency.Add(product);
-            _dependencies.Add(newDependency);
+            var newDependency = new List<Product> { product };
+            Dependencies.Add(newDependency);
         }
 
-        internal void AddMissingDependency(ArrayList productCodes)
+        internal void AddMissingDependency(List<string> productCodes)
         {
             bool found = false;
-            foreach (ArrayList md in _missingDependencies)
+            foreach (List<string> md in MissingDependencies)
             {
                 bool hasAll = true;
                 foreach (string dep in md)
@@ -228,35 +202,19 @@ internal void AddMissingDependency(ArrayList productCodes)
 
             if (!found)
             {
-                _missingDependencies.Add(productCodes);
+                MissingDependencies.Add(productCodes);
             }
         }
 
-        internal PackageCollection Packages
-        {
-            get { return _packages; }
-        }
+        internal PackageCollection Packages { get; }
 
         internal XmlValidationResults GetPackageValidationResults(string culture)
         {
-            if (_validationResults == null)
-                return null;
-            return _validationResults.PackageResults(culture);
+            return ValidationResults?.PackageResults(culture);
         }
 
-        internal bool ValidationPassed
-        {
-            get
-            {
-                if (_validationResults == null)
-                    return true;
-                return _validationResults.ValidationPassed;
-            }
-        }
+        internal bool ValidationPassed => ValidationResults == null || ValidationResults.ValidationPassed;
 
-        internal ProductValidationResults ValidationResults
-        {
-            get { return _validationResults; }
-        }
+        internal ProductValidationResults ValidationResults { get; }
     }
 }
diff --git a/src/Tasks/BootstrapperUtil/ProductBuilder.cs b/src/Tasks/BootstrapperUtil/ProductBuilder.cs
index 0fc5b866e91..55224e4b575 100644
--- a/src/Tasks/BootstrapperUtil/ProductBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/ProductBuilder.cs
@@ -1,11 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections;
-using System.Globalization;
-using System.Runtime.InteropServices;
-
 namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
 {
     /// <summary>
@@ -13,37 +8,18 @@ namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
     /// </summary>
     public class ProductBuilder : IProductBuilder
     {
-        private Product _product;
-        private string _culture;
-
         internal ProductBuilder(Product product)
         {
-            _product = product;
-            _culture = string.Empty;
-        }
-
-        internal ProductBuilder(Product product, string culture)
-        {
-            _product = product;
-            _culture = culture;
+            Product = product;
         }
 
         /// <summary>
         /// The Product corresponding to this ProductBuilder
         /// </summary>
-        public Product Product
-        {
-            get { return _product; }
-        }
+        public Product Product { get; }
 
-        internal string Name
-        {
-            get { return _product.Name; }
-        }
+        internal string Name => Product.Name;
 
-        internal string ProductCode
-        {
-            get { return _product.ProductCode; }
-        }
+        internal string ProductCode => Product.ProductCode;
     }
 }
diff --git a/src/Tasks/BootstrapperUtil/ProductBuilderCollection.cs b/src/Tasks/BootstrapperUtil/ProductBuilderCollection.cs
index 919ea3657b9..e4f74614f8e 100644
--- a/src/Tasks/BootstrapperUtil/ProductBuilderCollection.cs
+++ b/src/Tasks/BootstrapperUtil/ProductBuilderCollection.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Collections;
+using System.Collections.Generic;
 using System.Runtime.InteropServices;
 
 namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
@@ -9,14 +10,13 @@ namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
     /// <summary>
     /// This class contains a collection of ProductBuilder objects. Used for the BootstrapperBuilder's Build method.
     /// </summary>
-    [ComVisible(true), GuidAttribute("D25C0741-99CA-49f7-9460-95E5F25EEF43"), ClassInterface(ClassInterfaceType.None)]
+    [ComVisible(true), Guid("D25C0741-99CA-49f7-9460-95E5F25EEF43"), ClassInterface(ClassInterfaceType.None)]
     public class ProductBuilderCollection : IProductBuilderCollection, IEnumerable
     {
-        private ArrayList _list;
+        private readonly List<ProductBuilder> _list = new List<ProductBuilder>();
 
         internal ProductBuilderCollection()
         {
-            _list = new ArrayList();
         }
 
         /// <summary>
@@ -37,14 +37,11 @@ public IEnumerator GetEnumerator()
             return _list.GetEnumerator();
         }
 
-        internal int Count
-        {
-            get { return _list.Count; }
-        }
+        internal int Count => _list.Count;
 
         internal ProductBuilder Item(int index)
         {
-            return (ProductBuilder)_list[index];
+            return _list[index];
         }
 
         internal void Insert(int index, ProductBuilder builder)
diff --git a/src/Tasks/BootstrapperUtil/ProductCollection.cs b/src/Tasks/BootstrapperUtil/ProductCollection.cs
index 118c8d50018..71ae246ab13 100644
--- a/src/Tasks/BootstrapperUtil/ProductCollection.cs
+++ b/src/Tasks/BootstrapperUtil/ProductCollection.cs
@@ -3,7 +3,7 @@
 
 using System;
 using System.Collections;
-using System.Globalization;
+using System.Collections.Generic;
 using System.Runtime.InteropServices;
 
 namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
@@ -11,24 +11,22 @@ namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
     /// <summary>
     /// This class contains a collection of Product objects. This collection is a closed set that is generated by the BootstrapperBuilder based on the Path property. The client cannot add or remove items from this collection.
     /// </summary>
-    [ComVisible(true), GuidAttribute("EFFA164B-3E87-4195-88DB-8AC004DDFE2A"), ClassInterface(ClassInterfaceType.None)]
+    [ComVisible(true), Guid("EFFA164B-3E87-4195-88DB-8AC004DDFE2A"), ClassInterface(ClassInterfaceType.None)]
     public class ProductCollection : IProductCollection, IEnumerable
     {
-        private ArrayList _list;
-        private Hashtable _table;
+        private readonly List<Product> _list = new List<Product>();
+        private readonly Dictionary<string, Product> _table = new Dictionary<string, Product>(StringComparer.OrdinalIgnoreCase);
 
         internal ProductCollection()
         {
-            _list = new ArrayList();
-            _table = new Hashtable();
         }
 
         internal void Add(Product product)
         {
-            if (!_table.Contains(product.ProductCode.ToUpperInvariant()))
+            if (!_table.ContainsKey(product.ProductCode))
             {
                 _list.Add(product);
-                _table.Add(product.ProductCode.ToUpperInvariant(), product);
+                _table.Add(product.ProductCode, product);
             }
             else
             {
@@ -43,7 +41,7 @@ internal void Add(Product product)
         /// <returns>The Product at the specified index</returns>
         public Product Item(int index)
         {
-            return (Product)_list[index];
+            return _list[index];
         }
 
         /// <summary>
@@ -53,16 +51,14 @@ public Product Item(int index)
         /// <returns>The product with the given name, null if the spercified product code is not found</returns>
         public Product Product(string productCode)
         {
-            return (Product)_table[productCode.ToUpperInvariant()];
+            _table.TryGetValue(productCode, out Product product);
+            return product;
         }
 
         /// <summary>
         /// Gets the number of elements actually contained in the ProductCollection
         /// </summary>
-        public int Count
-        {
-            get { return _list.Count; }
-        }
+        public int Count => _list.Count;
 
         internal void Clear()
         {
diff --git a/src/Tasks/BootstrapperUtil/ResourceUpdater.cs b/src/Tasks/BootstrapperUtil/ResourceUpdater.cs
index 2e88a97b822..d28a9eb8178 100644
--- a/src/Tasks/BootstrapperUtil/ResourceUpdater.cs
+++ b/src/Tasks/BootstrapperUtil/ResourceUpdater.cs
@@ -2,12 +2,9 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
+using System.Collections.Generic;
 using System.Globalization;
 using System.IO;
-using System.Resources;
-using System.Reflection;
-using System.Diagnostics;
 using System.Runtime.InteropServices;
 using System.Threading;
 
@@ -16,14 +13,8 @@ namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
     internal class ResourceUpdater
     {
         private const int ERROR_SHARING_VIOLATION = -2147024864;
-        private ArrayList _stringResources;
-        private ArrayList _fileResources;
-
-        public ResourceUpdater()
-        {
-            _stringResources = new ArrayList();
-            _fileResources = new ArrayList();
-        }
+        private readonly List<StringResource> _stringResources = new List<StringResource>();
+        private readonly List<FileResource> _fileResources = new List<FileResource>();
 
         public void AddStringResource(int type, string name, string data)
         {
@@ -43,16 +34,18 @@ public bool UpdateResources(string filename, BuildResults results)
             bool endUpdate = false; // Only call EndUpdateResource() if this is true
 
             // Directory.GetCurrentDirectory() has previously been set to the project location
-            string filePath = System.IO.Path.Combine(Directory.GetCurrentDirectory(), filename);
+            string filePath = Path.Combine(Directory.GetCurrentDirectory(), filename);
 
             if (_stringResources.Count == 0 && _fileResources.Count == 0)
+            {
                 return true;
+            }
             IntPtr hUpdate = IntPtr.Zero;
 
             try
             {
                 hUpdate = NativeMethods.BeginUpdateResourceW(filePath, false);
-                while (IntPtr.Zero == hUpdate && Marshal.GetHRForLastWin32Error() == ResourceUpdater.ERROR_SHARING_VIOLATION && beginUpdateRetries > 0) // If it equals 0x80070020 (ERROR_SHARING_VIOLATION), sleep & retry
+                while (IntPtr.Zero == hUpdate && Marshal.GetHRForLastWin32Error() == ERROR_SHARING_VIOLATION && beginUpdateRetries > 0) // If it equals 0x80070020 (ERROR_SHARING_VIOLATION), sleep & retry
                 {
                     // This warning can be useful for debugging, but shouldn't be displayed to an actual user
                     // results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.General", String.Format("Unable to begin updating resource for {0} with error {1:X}, trying again after short sleep", filename, Marshal.GetHRForLastWin32Error())));
@@ -63,7 +56,8 @@ public bool UpdateResources(string filename, BuildResults results)
                 // If after all that we still failed, throw a build error
                 if (IntPtr.Zero == hUpdate)
                 {
-                    results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.General", String.Format("Unable to begin updating resource for {0} with error {1:X}", filename, Marshal.GetHRForLastWin32Error())));
+                    results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.General",
+                        $"Unable to begin updating resource for {filename} with error {Marshal.GetHRForLastWin32Error():X}"));
                     return false;
                 }
 
@@ -77,7 +71,8 @@ public bool UpdateResources(string filename, BuildResults results)
 
                         if (!NativeMethods.UpdateResourceW(hUpdate, (IntPtr)resource.Type, resource.Name, 0, data, data.Length))
                         {
-                            results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.General", String.Format("Unable to update resource for {0} with error {1:X}", filename, Marshal.GetHRForLastWin32Error())));
+                            results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.General",
+                                $"Unable to update resource for {filename} with error {Marshal.GetHRForLastWin32Error():X}"));
                             return false;
                         }
                     }
@@ -88,16 +83,17 @@ public bool UpdateResources(string filename, BuildResults results)
                         byte[] countArray = StringToByteArray(_fileResources.Count.ToString("G", CultureInfo.InvariantCulture));
                         if (!NativeMethods.UpdateResourceW(hUpdate, (IntPtr)42, "COUNT", 0, countArray, countArray.Length))
                         {
-                            results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.General", String.Format("Unable to update count resource for {0} with error {1:X}", filename, Marshal.GetHRForLastWin32Error())));
+                            results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.General",
+                                $"Unable to update count resource for {filename} with error {Marshal.GetHRForLastWin32Error():X}"));
                             return false;
                         }
 
                         foreach (FileResource resource in _fileResources)
                         {
                             // Read in the file data
-                            int fileLength = 0;
-                            byte[] fileContent = null;
-                            using (FileStream fs = System.IO.File.OpenRead(resource.Filename))
+                            int fileLength;
+                            byte[] fileContent;
+                            using (FileStream fs = File.OpenRead(resource.Filename))
                             {
                                 fileLength = (int)fs.Length;
                                 fileContent = new byte[fileLength];
@@ -110,7 +106,8 @@ public bool UpdateResources(string filename, BuildResults results)
 
                             if (!NativeMethods.UpdateResourceW(hUpdate, (IntPtr)42, dataName, 0, fileContent, fileLength))
                             {
-                                results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.General", String.Format("Unable to update data resource for {0} with error {1:X}", filename, Marshal.GetHRForLastWin32Error())));
+                                results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.General",
+                                    $"Unable to update data resource for {filename} with error {Marshal.GetHRForLastWin32Error():X}"));
                                 return false;
                             }
 
@@ -119,7 +116,8 @@ public bool UpdateResources(string filename, BuildResults results)
                             byte[] data = StringToByteArray(resource.Key);
                             if (!NativeMethods.UpdateResourceW(hUpdate, (IntPtr)42, keyName, 0, data, data.Length))
                             {
-                                results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.General", String.Format("Unable to update key resource for {0} with error {1:X}", filename, Marshal.GetHRForLastWin32Error())));
+                                results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.General",
+                                    $"Unable to update key resource for {filename} with error {Marshal.GetHRForLastWin32Error():X}"));
                                 return false;
                             }
 
@@ -132,7 +130,8 @@ public bool UpdateResources(string filename, BuildResults results)
             {
                 if (endUpdate && !NativeMethods.EndUpdateResource(hUpdate, false))
                 {
-                    results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.General", String.Format("Unable to finish updating resource for {0} with error {1:X}", filename, Marshal.GetHRForLastWin32Error())));
+                    results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.General",
+                        $"Unable to finish updating resource for {filename} with error {Marshal.GetHRForLastWin32Error():X}"));
                     returnValue = false;
                 }
             }
@@ -140,7 +139,7 @@ public bool UpdateResources(string filename, BuildResults results)
             return returnValue;
         }
 
-        private byte[] StringToByteArray(string str)
+        private static byte[] StringToByteArray(string str)
         {
             byte[] strBytes = System.Text.Encoding.Unicode.GetBytes(str);
             byte[] data = new byte[strBytes.Length + 2];
@@ -152,9 +151,9 @@ private byte[] StringToByteArray(string str)
 
         private class StringResource
         {
-            public int Type;
-            public string Name;
-            public string Data;
+            public readonly int Type;
+            public readonly string Name;
+            public readonly string Data;
 
             public StringResource(int type, string name, string data)
             {
@@ -166,8 +165,8 @@ public StringResource(int type, string name, string data)
 
         private class FileResource
         {
-            public string Filename;
-            public string Key;
+            public readonly string Filename;
+            public readonly string Key;
 
             public FileResource(string filename, string key)
             {
diff --git a/src/Tasks/BootstrapperUtil/Util.cs b/src/Tasks/BootstrapperUtil/Util.cs
index e49aa7e7300..0e224e828a6 100644
--- a/src/Tasks/BootstrapperUtil/Util.cs
+++ b/src/Tasks/BootstrapperUtil/Util.cs
@@ -2,12 +2,9 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Diagnostics;
 using System.Globalization;
 using System.IO;
-using System.Runtime.InteropServices;
 using Microsoft.Win32;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
 {
@@ -25,19 +22,22 @@ internal static class Util
         public static string AddTrailingChar(string str, char ch)
         {
             if (str.LastIndexOf(ch) == str.Length - 1)
+            {
                 return str;
+            }
             return str + ch;
         }
 
         public static bool IsUncPath(string path)
         {
             if (String.IsNullOrEmpty(path))
+            {
                 return false;
-
+            }
 
             try
             {
-                System.Uri uri = new System.Uri(path);
+                var uri = new Uri(path);
                 return uri.IsUnc;
             }
             catch (UriFormatException)
@@ -46,7 +46,6 @@ public static bool IsUncPath(string path)
             }
         }
 
-
         public static bool IsWebUrl(string path)
         {
             return path.StartsWith("http://", StringComparison.Ordinal) || path.StartsWith("https://", StringComparison.Ordinal);
@@ -56,7 +55,7 @@ public static CultureInfo GetCultureInfoFromString(string cultureName)
         {
             try
             {
-                CultureInfo ci = new System.Globalization.CultureInfo(cultureName);
+                var ci = new CultureInfo(cultureName);
                 return ci;
             }
             catch (ArgumentException)
@@ -66,13 +65,7 @@ public static CultureInfo GetCultureInfoFromString(string cultureName)
             return null;
         }
 
-        public static CultureInfo DefaultCultureInfo
-        {
-            get
-            {
-                return System.Threading.Thread.CurrentThread.CurrentUICulture;
-            }
-        }
+        public static CultureInfo DefaultCultureInfo => System.Threading.Thread.CurrentThread.CurrentUICulture;
 
         // This is the 4.0 property and will always point to the Dev10 registry key so that we don't break backwards compatibility.
         // Applications relying on 4.5 will need to use the new method that is introduced in 4.5.
@@ -82,13 +75,17 @@ public static string DefaultPath
             {
                 if (String.IsNullOrEmpty(s_defaultPath))
                 {
-                    s_defaultPath = ReadRegistryString(Win32.Registry.LocalMachine, String.Concat(BOOTSTRAPPER_REGISTRY_PATH_BASE, BOOTSTRAPPER_REGISTRY_PATH_VERSION_VS2010), REGISTRY_DEFAULTPATH);
+                    s_defaultPath = ReadRegistryString(Registry.LocalMachine, String.Concat(BOOTSTRAPPER_REGISTRY_PATH_BASE, BOOTSTRAPPER_REGISTRY_PATH_VERSION_VS2010), REGISTRY_DEFAULTPATH);
                     if (!String.IsNullOrEmpty(s_defaultPath))
+                    {
                         return s_defaultPath;
+                    }
 
-                    s_defaultPath = ReadRegistryString(Win32.Registry.LocalMachine, String.Concat(BOOTSTRAPPER_WOW64_REGISTRY_PATH_BASE, BOOTSTRAPPER_REGISTRY_PATH_VERSION_VS2010), REGISTRY_DEFAULTPATH);
+                    s_defaultPath = ReadRegistryString(Registry.LocalMachine, String.Concat(BOOTSTRAPPER_WOW64_REGISTRY_PATH_BASE, BOOTSTRAPPER_REGISTRY_PATH_VERSION_VS2010), REGISTRY_DEFAULTPATH);
                     if (!String.IsNullOrEmpty(s_defaultPath))
+                    {
                         return s_defaultPath;
+                    }
 
                     s_defaultPath = Directory.GetCurrentDirectory();
                 }
@@ -111,39 +108,44 @@ public static string GetDefaultPath(string visualStudioVersion)
             // For Dev10, we use 4.0.
             // For Dev15 this will go versionless as there will be singleton MSI setting the registry which will be common for all future VS.
 
-            int majorVersion = 0;
             int dotIndex = visualStudioVersion.IndexOf('.');
             if (dotIndex < 0)
             {
                 dotIndex = visualStudioVersion.Length;
             }
-            if (Int32.TryParse(visualStudioVersion.Substring(0, dotIndex), out majorVersion) && (majorVersion < 11))
+            if (Int32.TryParse(visualStudioVersion.Substring(0, dotIndex), out int majorVersion) && (majorVersion < 11))
             {
                 visualStudioVersion = BOOTSTRAPPER_REGISTRY_PATH_VERSION_VS2010;
             }
 
-            string defaultPath;
-
-            defaultPath = ReadRegistryString(Win32.Registry.LocalMachine, BOOTSTRAPPER_REGISTRY_PATH_BASE, REGISTRY_DEFAULTPATH);
+            string defaultPath = ReadRegistryString(Registry.LocalMachine, BOOTSTRAPPER_REGISTRY_PATH_BASE, REGISTRY_DEFAULTPATH);
             if (!String.IsNullOrEmpty(defaultPath))
+            {
                 return defaultPath;
+            }
 
-            defaultPath = ReadRegistryString(Win32.Registry.LocalMachine, BOOTSTRAPPER_WOW64_REGISTRY_PATH_BASE, REGISTRY_DEFAULTPATH);
+            defaultPath = ReadRegistryString(Registry.LocalMachine, BOOTSTRAPPER_WOW64_REGISTRY_PATH_BASE, REGISTRY_DEFAULTPATH);
             if (!String.IsNullOrEmpty(defaultPath))
+            {
                 return defaultPath;
+            }
 
-            defaultPath = ReadRegistryString(Win32.Registry.LocalMachine, String.Concat(BOOTSTRAPPER_REGISTRY_PATH_BASE, visualStudioVersion), REGISTRY_DEFAULTPATH);
+            defaultPath = ReadRegistryString(Registry.LocalMachine, String.Concat(BOOTSTRAPPER_REGISTRY_PATH_BASE, visualStudioVersion), REGISTRY_DEFAULTPATH);
             if (!String.IsNullOrEmpty(defaultPath))
+            {
                 return defaultPath;
+            }
 
-            defaultPath = ReadRegistryString(Win32.Registry.LocalMachine, String.Concat(BOOTSTRAPPER_WOW64_REGISTRY_PATH_BASE, visualStudioVersion), REGISTRY_DEFAULTPATH);
+            defaultPath = ReadRegistryString(Registry.LocalMachine, String.Concat(BOOTSTRAPPER_WOW64_REGISTRY_PATH_BASE, visualStudioVersion), REGISTRY_DEFAULTPATH);
             if (!String.IsNullOrEmpty(defaultPath))
+            {
                 return defaultPath;
+            }
 
             return Directory.GetCurrentDirectory();
         }
 
-        private static string ReadRegistryString(Win32.RegistryKey key, string path, string registryValue)
+        private static string ReadRegistryString(RegistryKey key, string path, string registryValue)
         {
             RegistryKey subKey = key.OpenSubKey(path, false);
 
diff --git a/src/Tasks/BootstrapperUtil/productvalidationresults.cs b/src/Tasks/BootstrapperUtil/productvalidationresults.cs
index ab6a9c76f4e..e82e338a107 100644
--- a/src/Tasks/BootstrapperUtil/productvalidationresults.cs
+++ b/src/Tasks/BootstrapperUtil/productvalidationresults.cs
@@ -2,8 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Xml;
+using System.Collections.Generic;
 
 namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
 {
@@ -12,11 +11,11 @@ namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
     /// </summary>
     internal sealed class ProductValidationResults : XmlValidationResults
     {
-        private Hashtable _packageValidationResults;
+        private readonly Dictionary<string, XmlValidationResults> _packageValidationResults =
+            new Dictionary<string, XmlValidationResults>(StringComparer.Ordinal);
 
         public ProductValidationResults(string filePath) : base(filePath)
         {
-            _packageValidationResults = new Hashtable();
         }
 
         /// <summary>
@@ -26,7 +25,7 @@ public ProductValidationResults(string filePath) : base(filePath)
         /// <param name="results">The vaue of the results to add.</param>
         public void AddPackageResults(string culture, XmlValidationResults results)
         {
-            if (!_packageValidationResults.Contains(culture))
+            if (!_packageValidationResults.ContainsKey(culture))
             {
                 _packageValidationResults.Add(culture, results);
             }
@@ -43,7 +42,8 @@ public void AddPackageResults(string culture, XmlValidationResults results)
         /// <returns>The XmlValidationResults associated with the specified culture.</returns>
         public XmlValidationResults PackageResults(string culture)
         {
-            return (XmlValidationResults)_packageValidationResults[culture];
+            _packageValidationResults.TryGetValue(culture, out XmlValidationResults results);
+            return results;
         }
     }
 }
diff --git a/src/Tasks/BootstrapperUtil/xmlvalidationresults.cs b/src/Tasks/BootstrapperUtil/xmlvalidationresults.cs
index e113b7d6323..42e1cd8ebd2 100644
--- a/src/Tasks/BootstrapperUtil/xmlvalidationresults.cs
+++ b/src/Tasks/BootstrapperUtil/xmlvalidationresults.cs
@@ -1,9 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections;
-using System.Xml;
+using System.Collections.Generic;
 
 namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
 {
@@ -12,9 +10,8 @@ namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
     /// </summary>
     internal class XmlValidationResults
     {
-        private string _filePath;
-        private ArrayList _validationErrors;
-        private ArrayList _validationWarnings;
+        private readonly List<string> _validationErrors = new List<string>();
+        private readonly List<string> _validationWarnings = new List<string>();
 
         /// <summary>
         /// Constructor which includes the path to the file being validated.
@@ -22,19 +19,14 @@ internal class XmlValidationResults
         /// <param name="filePath">The file which is being validated.</param>
         public XmlValidationResults(string filePath)
         {
-            _filePath = filePath;
-            _validationErrors = new ArrayList();
-            _validationWarnings = new ArrayList();
+            FilePath = filePath;
         }
 
         /// <summary>
         /// Gets a string containing the name of the file being validated.
         /// </summary>
         /// <value>The name of the file being validated.</value>
-        public string FilePath
-        {
-            get { return _filePath; }
-        }
+        public string FilePath { get; }
 
         /// <summary>
         /// The delegate which will handle validation events.
@@ -56,38 +48,19 @@ public void SchemaValidationEventHandler(object sender, System.Xml.Schema.Valida
         /// </summary>
         /// <value>An array of type string, containing all of the validation errors.</value>
         /// <remarks>This method uses ArrayList.Copy to copy the errors.</remarks>
-        public string[] ValidationErrors
-        {
-            get
-            {
-                string[] a = new string[_validationErrors.Count];
-                _validationErrors.CopyTo(a);
-                return a;
-            }
-        }
+        public string[] ValidationErrors => _validationErrors.ToArray();
 
         /// <summary>
         /// Gets a value indicating if there were no validation errors or warnings.
         /// </summary>
         /// <value>true if there were no validation errors or warnings; otherwise false.  The default value is false.</value>
-        public bool ValidationPassed
-        {
-            get { return _validationErrors.Count == 0 && _validationWarnings.Count == 0; }
-        }
+        public bool ValidationPassed => _validationErrors.Count == 0 && _validationWarnings.Count == 0;
 
         /// <summary>
         /// Gets all of the validation warnings of the file being validated.
         /// </summary>
         /// <value>An array of type string, containing all of the validation warnings.</value>
         /// <remarks>This method uses ArrayList.Copy to copy the warnings.</remarks>
-        public string[] ValidationWarnings
-        {
-            get
-            {
-                string[] a = new string[_validationWarnings.Count];
-                _validationWarnings.CopyTo(a);
-                return a;
-            }
-        }
+        public string[] ValidationWarnings => _validationWarnings.ToArray();
     }
 }
diff --git a/src/Tasks/BuildCacheDisposeWrapper.cs b/src/Tasks/BuildCacheDisposeWrapper.cs
index 7b77b617ab7..b81da47ed07 100644
--- a/src/Tasks/BuildCacheDisposeWrapper.cs
+++ b/src/Tasks/BuildCacheDisposeWrapper.cs
@@ -9,7 +9,6 @@
 //-----------------------------------------------------------------------
 
 using System;
-using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
 {
@@ -26,7 +25,7 @@ internal class BuildCacheDisposeWrapper : IDisposable
         /// <summary>
         /// Delegate to call when we are in dispose
         /// </summary>
-        private CallDuringDispose _callDuringDispose;
+        private readonly CallDuringDispose _callDuringDispose;
 
         /// <summary>
         /// Constructor
@@ -59,11 +58,8 @@ protected virtual void Dispose(bool disposing)
             if (!_disposed && disposing)
             {
                 _disposed = true;
-                if (_callDuringDispose != null)
-                {
-                    _callDuringDispose();
-                }
+                _callDuringDispose?.Invoke();
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Tasks/CSharpParserUtilities.cs b/src/Tasks/CSharpParserUtilities.cs
index 4229d2f3a78..b0f343dd06f 100644
--- a/src/Tasks/CSharpParserUtilities.cs
+++ b/src/Tasks/CSharpParserUtilities.cs
@@ -1,13 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.IO;
 using System.Text;
-using System.Resources;
-using System.Reflection;
-
-using System.Collections;
 using Microsoft.Build.Shared.LanguageParser;
 
 namespace Microsoft.Build.Tasks
@@ -22,17 +17,17 @@ internal static class CSharpParserUtilities
         /// </summary>
         /// <param name="binaryStream"></param>
         /// <returns></returns>
-        static internal ExtractedClassName GetFirstClassNameFullyQualified(Stream binaryStream)
+        internal static ExtractedClassName GetFirstClassNameFullyQualified(Stream binaryStream)
         {
             try
             {
-                CSharpTokenizer tokens = new CSharpTokenizer(binaryStream, /* forceANSI */ false);
+                var tokens = new CSharpTokenizer(binaryStream, /* forceANSI */ false);
                 return Extract(tokens);
             }
             catch (DecoderFallbackException)
             {
                 // There was no BOM and there are non UTF8 sequences. Fall back to ANSI.
-                CSharpTokenizer tokens = new CSharpTokenizer(binaryStream, /* forceANSI */ true);
+                var tokens = new CSharpTokenizer(binaryStream, /* forceANSI */ true);
                 return Extract(tokens);
             }
         }
@@ -41,12 +36,10 @@ static internal ExtractedClassName GetFirstClassNameFullyQualified(Stream binary
         /// <summary>
         /// Extract the class name.
         /// </summary>
-        /// <param name="tokens"></param>
-        /// <returns></returns>
         private static ExtractedClassName Extract(CSharpTokenizer tokens)
         {
-            ParseState state = new ParseState();
-            ExtractedClassName result = new ExtractedClassName();
+            var state = new ParseState();
+            var result = new ExtractedClassName();
 
             foreach (Token t in tokens)
             {
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index c755e4067a0..31966300c67 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -49,14 +49,10 @@ static CodeTaskFactory()
         /// <summary>
         /// Handles the <see cref="AppDomain.AssemblyResolve"/> event to return assemblies loaded from custom references.
         /// </summary>
-        /// <param name="sender"></param>
-        /// <param name="args"></param>
-        /// <returns></returns>
         private static Assembly CurrentDomainOnAssemblyResolve(object sender, ResolveEventArgs args)
         {
-            Assembly assembly = null;
             // Return the assembly loaded from the custom reference if the FullName matches what is being looked for
-            s_knownReferenceAssemblies.TryGetValue(args.Name, out assembly);
+            s_knownReferenceAssemblies.TryGetValue(args.Name, out Assembly assembly);
 
             return assembly;
         }
@@ -75,7 +71,7 @@ private static Assembly CurrentDomainOnAssemblyResolve(object sender, ResolveEve
         /// A collection of task assemblies which have been instantiated by any CodeTaskFactory.  Used to prevent us from creating
         /// duplicate assemblies.
         /// </summary>
-        private static ConcurrentDictionary<FullTaskSpecification, Assembly> s_compiledTaskCache = new ConcurrentDictionary<FullTaskSpecification, Assembly>();
+        private static readonly ConcurrentDictionary<FullTaskSpecification, Assembly> s_compiledTaskCache = new ConcurrentDictionary<FullTaskSpecification, Assembly>();
 
         /// <summary>
         /// The default assemblies to reference when compiling inline code. 
@@ -150,13 +146,7 @@ private static Assembly CurrentDomainOnAssemblyResolve(object sender, ResolveEve
         /// <summary>
         /// MSBuild engine uses this for logging where the task comes from
         /// </summary>
-        public string FactoryName
-        {
-            get
-            {
-                return "Code Task Factory";
-            }
-        }
+        public string FactoryName => "Code Task Factory";
 
         /// <summary>
         /// Gets the type of the generated task.
@@ -204,7 +194,7 @@ private static List<string> DefaultReferencedAssemblies
         /// </summary>
         public TaskPropertyInfo[] GetTaskParameters()
         {
-            TaskPropertyInfo[] properties = new TaskPropertyInfo[_taskParameterTypeInfo.Count];
+            var properties = new TaskPropertyInfo[_taskParameterTypeInfo.Count];
             _taskParameterTypeInfo.Values.CopyTo(properties, 0);
             return properties;
         }
@@ -215,12 +205,13 @@ public TaskPropertyInfo[] GetTaskParameters()
         public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> taskParameters, string taskElementContents, IBuildEngine taskFactoryLoggingHost)
         {
             _nameOfTask = taskName;
-            _log = new TaskLoggingHelper(taskFactoryLoggingHost, taskName);
-            _log.TaskResources = AssemblyResources.PrimaryResources;
-            _log.HelpKeywordPrefix = "MSBuild.";
+            _log = new TaskLoggingHelper(taskFactoryLoggingHost, taskName)
+            {
+                TaskResources = AssemblyResources.PrimaryResources,
+                HelpKeywordPrefix = "MSBuild."
+            };
 
             XmlNode taskContent = ExtractTaskContent(taskElementContents);
-
             if (taskContent == null)
             {
                 // Just return false because we have already logged the error in ExtractTaskContents
@@ -228,7 +219,6 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> ta
             }
 
             bool validatedTaskNode = ValidateTaskNode();
-
             if (!validatedTaskNode)
             {
                 return false;
@@ -335,8 +325,8 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> ta
                     }
                 }
 
-                this.TaskType = fullNameMatch ?? partialNameMatch;
-                if (this.TaskType == null)
+                TaskType = fullNameMatch ?? partialNameMatch;
+                if (TaskType == null)
                 {
                     _log.LogErrorWithCodeFromResources("CodeTaskFactory.CouldNotFindTaskInAssembly", _nameOfTask);
                 }
@@ -354,11 +344,13 @@ public ITask CreateTask(IBuildEngine loggingHost)
             if (_compiledAssembly != null)
             {
                 // In order to use the resource strings from the tasks assembly we need to register the resources with the task logging helper.
-                TaskLoggingHelper log = new TaskLoggingHelper(loggingHost, _nameOfTask);
-                log.TaskResources = AssemblyResources.PrimaryResources;
-                log.HelpKeywordPrefix = "MSBuild.";
+                var log = new TaskLoggingHelper(loggingHost, _nameOfTask)
+                {
+                    TaskResources = AssemblyResources.PrimaryResources,
+                    HelpKeywordPrefix = "MSBuild."
+                };
 
-                ITask taskInstance = Activator.CreateInstance(this.TaskType) as ITask;
+                ITask taskInstance = Activator.CreateInstance(TaskType) as ITask;
                 if (taskInstance == null)
                 {
                     log.LogErrorWithCodeFromResources("CodeTaskFactory.NeedsITaskInterface", _nameOfTask);
@@ -366,10 +358,7 @@ public ITask CreateTask(IBuildEngine loggingHost)
 
                 return taskInstance;
             }
-            else
-            {
-                return null;
-            }
+            return null;
         }
 
         /// <summary>
@@ -383,7 +372,7 @@ public ITask CreateTask(IBuildEngine loggingHost)
         /// </remarks>
         public void CleanupTask(ITask task)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(task, "task");
+            ErrorUtilities.VerifyThrowArgumentNull(task, nameof(task));
         }
 
         /// <summary>
@@ -391,8 +380,10 @@ public void CleanupTask(ITask task)
         /// </summary>
         private static void CreateProperty(CodeTypeDeclaration ctd, string propertyName, Type propertyType, object defaultValue)
         {
-            CodeMemberField field = new CodeMemberField(new CodeTypeReference(propertyType), "_" + propertyName);
-            field.Attributes = MemberAttributes.Private;
+            var field = new CodeMemberField(new CodeTypeReference(propertyType), "_" + propertyName)
+            {
+                Attributes = MemberAttributes.Private
+            };
             if (defaultValue != null)
             {
                 field.InitExpression = new CodePrimitiveExpression(defaultValue);
@@ -400,20 +391,23 @@ private static void CreateProperty(CodeTypeDeclaration ctd, string propertyName,
 
             ctd.Members.Add(field);
 
-            CodeMemberProperty prop = new CodeMemberProperty();
-            prop.Name = propertyName;
-            prop.Type = new CodeTypeReference(propertyType);
-            prop.Attributes = MemberAttributes.Public;
-            prop.HasGet = true;
-            prop.HasSet = true;
+            var prop = new CodeMemberProperty
+            {
+                Name = propertyName,
+                Type = new CodeTypeReference(propertyType),
+                Attributes = MemberAttributes.Public,
+                HasGet = true,
+                HasSet = true
+            };
 
-            CodeFieldReferenceExpression fieldRef = new CodeFieldReferenceExpression();
-            fieldRef.FieldName = field.Name;
+            var fieldRef = new CodeFieldReferenceExpression { FieldName = field.Name };
             prop.GetStatements.Add(new CodeMethodReturnStatement(fieldRef));
 
-            CodeAssignStatement fieldAssign = new CodeAssignStatement();
-            fieldAssign.Left = fieldRef;
-            fieldAssign.Right = new CodeArgumentReferenceExpression("value");
+            var fieldAssign = new CodeAssignStatement
+            {
+                Left = fieldRef,
+                Right = new CodeArgumentReferenceExpression("value")
+            };
             prop.SetStatements.Add(fieldAssign);
             ctd.Members.Add(prop);
         }
@@ -423,9 +417,11 @@ private static void CreateProperty(CodeTypeDeclaration ctd, string propertyName,
         /// </summary>
         private static void CreateExecuteMethodFromFragment(CodeTypeDeclaration codeTypeDeclaration, string executeCode)
         {
-            CodeMemberMethod executeMethod = new CodeMemberMethod();
-            executeMethod.Name = "Execute";
-            executeMethod.Attributes = MemberAttributes.Override | MemberAttributes.Public;
+            var executeMethod = new CodeMemberMethod
+            {
+                Name = "Execute",
+                Attributes = MemberAttributes.Override | MemberAttributes.Public
+            };
             executeMethod.Statements.Add(new CodeSnippetStatement(executeCode));
             executeMethod.ReturnType = new CodeTypeReference(typeof(Boolean));
             executeMethod.Statements.Add(new CodeMethodReturnStatement(new CodeFieldReferenceExpression(null, "_Success")));
@@ -437,7 +433,7 @@ private static void CreateExecuteMethodFromFragment(CodeTypeDeclaration codeType
         /// </summary>
         private static void CreateTaskBody(CodeTypeDeclaration codeTypeDeclaration, string taskCode)
         {
-            CodeSnippetTypeMember snippet = new CodeSnippetTypeMember(taskCode);
+            var snippet = new CodeSnippetTypeMember(taskCode);
             codeTypeDeclaration.Members.Add(snippet);
         }
 
@@ -456,12 +452,12 @@ private static void CreateProperty(CodeTypeDeclaration codeTypeDeclaration, Task
         private string[] ExtractReferencedAssemblies()
         {
             XmlNodeList referenceNodes = _taskNode.SelectNodes("//*[local-name()='Reference']");
-            List<string> references = new List<string>();
+            var references = new List<string>();
             for (int i = 0; i < referenceNodes.Count; i++)
             {
                 XmlAttribute attribute = referenceNodes[i].Attributes["Include"];
 
-                bool hasInvalidChildNodes = HasInvalidChildNodes(referenceNodes[i], new XmlNodeType[] { XmlNodeType.Comment, XmlNodeType.Whitespace });
+                bool hasInvalidChildNodes = HasInvalidChildNodes(referenceNodes[i], new[] { XmlNodeType.Comment, XmlNodeType.Whitespace });
 
                 if (hasInvalidChildNodes)
                 {
@@ -488,10 +484,10 @@ private string[] ExtractUsingNamespaces()
         {
             XmlNodeList usingNodes = _taskNode.SelectNodes("//*[local-name()='Using']");
 
-            List<string> usings = new List<string>();
+            var usings = new List<string>();
             for (int i = 0; i < usingNodes.Count; i++)
             {
-                bool hasInvalidChildNodes = HasInvalidChildNodes(usingNodes[i], new XmlNodeType[] { XmlNodeType.Comment, XmlNodeType.Whitespace });
+                bool hasInvalidChildNodes = HasInvalidChildNodes(usingNodes[i], new[] { XmlNodeType.Comment, XmlNodeType.Whitespace });
 
                 if (hasInvalidChildNodes)
                 {
@@ -520,7 +516,7 @@ private XmlNode ExtractTaskContent(string taskElementContents)
         {
             // We need to get the InnerXml of the <Task /> node back into
             // a root node so that we can execute the appropriate XPath on it
-            XmlDocument document = new XmlDocument();
+            var document = new XmlDocument();
 
             _taskNode = document.CreateElement("Task");
             document.AppendChild(_taskNode);
@@ -541,7 +537,7 @@ private XmlNode ExtractTaskContent(string taskElementContents)
                 return null;
             }
 
-            bool hasInvalidChildNodes = HasInvalidChildNodes(codeNodes[0], new XmlNodeType[] { XmlNodeType.Comment, XmlNodeType.Whitespace, XmlNodeType.Text, XmlNodeType.CDATA });
+            bool hasInvalidChildNodes = HasInvalidChildNodes(codeNodes[0], new[] { XmlNodeType.Comment, XmlNodeType.Whitespace, XmlNodeType.Text, XmlNodeType.CDATA });
 
             if (hasInvalidChildNodes)
             {
@@ -556,11 +552,11 @@ private XmlNode ExtractTaskContent(string taskElementContents)
         /// </summary>
         private bool ValidateTaskNode()
         {
-            bool foundInvalidNode = false;
             if (_taskNode.HasChildNodes)
             {
                 foreach (XmlNode childNode in _taskNode.ChildNodes)
                 {
+                    bool foundInvalidNode;
                     switch (childNode.NodeType)
                     {
                         case XmlNodeType.Comment:
@@ -640,7 +636,6 @@ private void AddReferenceAssemblyToReferenceList(List<string> referenceAssemblyL
             if (referenceAssemblyList != null)
             {
                 string candidateAssemblyLocation = null;
-                string extension = String.Empty;
 
                 if (!String.IsNullOrEmpty(referenceAssembly))
                 {
@@ -702,7 +697,7 @@ private void AddReferenceAssemblyToReferenceList(List<string> referenceAssemblyL
                     }
                     catch (Exception e)
                     {
-                        if (Microsoft.Build.Shared.ExceptionHandling.IsCriticalException(e))
+                        if (ExceptionHandling.IsCriticalException(e))
                         {
                             throw;
                         }
@@ -739,30 +734,33 @@ private Assembly CompileInMemoryAssembly()
             // "c#;cs;csharp", "vb;vbs;visualbasic;vbscript", "js;jscript;javascript", "vj#;vjs;vjsharp", "c++;mc;cpp"
             using (CodeDomProvider provider = CodeDomProvider.CreateProvider(_language))
             {
-                if (provider is Microsoft.CSharp.CSharpCodeProvider)
+                if (provider is CSharp.CSharpCodeProvider)
                 {
                     AddReferenceAssemblyToReferenceList(finalReferencedAssemblies, "System");
                 }
 
-                CompilerParameters compilerParameters = new CompilerParameters(finalReferencedAssemblies.ToArray());
-
-                // We don't need debug information
-                compilerParameters.IncludeDebugInformation = true;
+                var compilerParameters =
+                    new CompilerParameters(finalReferencedAssemblies.ToArray())
+                    {
+                        // We don't need debug information
+                        IncludeDebugInformation = true,
 
-                // Not a file based assembly
-                compilerParameters.GenerateInMemory = true;
+                        // Not a file based assembly
+                        GenerateInMemory = true,
 
-                // Indicates that a .dll should be generated.
-                compilerParameters.GenerateExecutable = false;
+                        // Indicates that a .dll should be generated.
+                        GenerateExecutable = false
+                    };
 
                 // Horrible code dom / compilation declarations
-                CodeTypeDeclaration codeTypeDeclaration;
-                StringBuilder codeBuilder = new StringBuilder();
-                StringWriter writer = new StringWriter(codeBuilder, CultureInfo.CurrentCulture);
-                CodeGeneratorOptions codeGeneratorOptions = new CodeGeneratorOptions();
-                codeGeneratorOptions.BlankLinesBetweenMembers = true;
-                codeGeneratorOptions.VerbatimOrder = true;
-                CodeCompileUnit compilationUnit = new CodeCompileUnit();
+                var codeBuilder = new StringBuilder();
+                var writer = new StringWriter(codeBuilder, CultureInfo.CurrentCulture);
+                var codeGeneratorOptions = new CodeGeneratorOptions
+                {
+                    BlankLinesBetweenMembers = true,
+                    VerbatimOrder = true
+                };
+                var compilationUnit = new CodeCompileUnit();
 
                 // If our code is in a separate file, then read it in here
                 if (_sourcePath != null)
@@ -770,14 +768,12 @@ private Assembly CompileInMemoryAssembly()
                     _sourceCode = File.ReadAllText(_sourcePath);
                 }
 
-                string fullCode = _sourceCode;
-
                 // A fragment is essentially the contents of the execute method (except the final return true/false)
                 // A method is the whole execute method specified
                 // Anything else assumes that the whole class is being supplied
                 if (_typeIsFragment || _typeIsMethod)
                 {
-                    codeTypeDeclaration = CreateTaskClass();
+                    CodeTypeDeclaration codeTypeDeclaration = CreateTaskClass();
 
                     CreateTaskProperties(codeTypeDeclaration);
 
@@ -790,7 +786,7 @@ private Assembly CompileInMemoryAssembly()
                         CreateTaskBody(codeTypeDeclaration, _sourceCode);
                     }
 
-                    CodeNamespace codeNamespace = new CodeNamespace("InlineCode");
+                    var codeNamespace = new CodeNamespace("InlineCode");
                     foreach (string importname in finalUsingNamespaces)
                     {
                         codeNamespace.Imports.Add(new CodeNamespaceImport(importname));
@@ -809,11 +805,10 @@ private Assembly CompileInMemoryAssembly()
                 }
 
                 // Our code generation is complete, grab the source from the builder ready for compilation
-                fullCode = codeBuilder.ToString();
+                string fullCode = codeBuilder.ToString();
 
-                FullTaskSpecification fullSpec = new FullTaskSpecification(finalReferencedAssemblies, fullCode);
-                Assembly existingAssembly;
-                if (!s_compiledTaskCache.TryGetValue(fullSpec, out existingAssembly))
+                var fullSpec = new FullTaskSpecification(finalReferencedAssemblies, fullCode);
+                if (!s_compiledTaskCache.TryGetValue(fullSpec, out Assembly existingAssembly))
                 {
                     // Invokes compilation. 
 
@@ -889,10 +884,7 @@ private string[] CombineUsingNamespaces()
 
             string[] finalUsingNamespaces = new string[usingNamespaceCount];
             _defaultUsingNamespaces.CopyTo(finalUsingNamespaces, 0);
-            if (_usingNamespaces != null)
-            {
-                _usingNamespaces.CopyTo(finalUsingNamespaces, _defaultUsingNamespaces.Length);
-            }
+            _usingNamespaces?.CopyTo(finalUsingNamespaces, _defaultUsingNamespaces.Length);
 
             return finalUsingNamespaces;
         }
@@ -920,11 +912,13 @@ private void CreateTaskProperties(CodeTypeDeclaration codeTypeDeclaration)
         /// </summary>
         private CodeTypeDeclaration CreateTaskClass()
         {
-            CodeTypeDeclaration codeTypeDeclaration = new CodeTypeDeclaration();
-            codeTypeDeclaration.IsClass = true;
-            codeTypeDeclaration.Name = _nameOfTask;
-            codeTypeDeclaration.TypeAttributes = TypeAttributes.Public;
-            codeTypeDeclaration.Attributes = MemberAttributes.Final;
+            CodeTypeDeclaration codeTypeDeclaration = new CodeTypeDeclaration
+            {
+                IsClass = true,
+                Name = _nameOfTask,
+                TypeAttributes = TypeAttributes.Public,
+                Attributes = MemberAttributes.Final
+            };
             codeTypeDeclaration.BaseTypes.Add("Microsoft.Build.Utilities.Task");
             return codeTypeDeclaration;
         }
@@ -937,12 +931,12 @@ private class FullTaskSpecification : IComparable<FullTaskSpecification>, IEquat
             /// <summary>
             /// The set of assemblies referenced by this task.
             /// </summary>
-            private List<string> _referenceAssemblies;
+            private readonly List<string> _referenceAssemblies;
 
             /// <summary>
             /// The complete source code for the task.
             /// </summary>
-            private string _fullCode;
+            private readonly string _fullCode;
 
             /// <summary>
             /// Constructor
@@ -966,13 +960,12 @@ public override int GetHashCode()
             /// </summary>
             public override bool Equals(object other)
             {
-                if (Object.ReferenceEquals(this, other))
+                if (ReferenceEquals(this, other))
                 {
                     return true;
                 }
 
-                FullTaskSpecification otherSpec = other as FullTaskSpecification;
-                if (otherSpec == null)
+                if (!(other is FullTaskSpecification otherSpec))
                 {
                     return false;
                 }
diff --git a/src/Tasks/CodeTaskFactoryInstance.cs b/src/Tasks/CodeTaskFactoryInstance.cs
deleted file mode 100644
index 01995296217..00000000000
--- a/src/Tasks/CodeTaskFactoryInstance.cs
+++ /dev/null
@@ -1,154 +0,0 @@
-//-----------------------------------------------------------------------
-// <copyright file="CodeTaskFactoryInstance.cs" company="Microsoft">
-//     Copyright (c) Microsoft Corporation.  All rights reserved.
-// </copyright>
-// <summary>A code task factory  instance which is instantiated for each batch</summary>
-//-----------------------------------------------------------------------
-using System;
-using System.Collections.Generic;
-using System.Text;
-using System.CodeDom.Compiler;
-using System.Reflection;
-using System.Xml;
-using System.IO;
-
-using Microsoft.Build.Framework;
-using System.CodeDom;
-using Microsoft.Build.Utilities;
-using System.Globalization;
-using System.Diagnostics.CodeAnalysis;
-using Microsoft.Build.Shared;
-
-namespace Microsoft.Build.Tasks
-{
-    /// <summary>
-    /// A task factory instance which actually create an ITaskInstance, this factory contains the data that needs to be refreshed for each task invocation.
-    /// </summary>
-    public class CodeTaskFactoryInstance : ITaskFactory
-    {
-        /// <summary>
-        /// Compiled assembly to use when instantiating the Itask
-        /// </summary>
-        private Assembly compiledAssembly;
-
-        /// <summary>
-        /// The instantiated Itask instance
-        /// </summary>
-        private ITask taskInstance;
-
-        /// <summary>
-        /// Name of the task
-        /// </summary>
-         private string nameOfTask;
-
-        /// <summary>
-        /// Create a new CodeTaskFactoryInstance using the compiled assembly and the task name
-        /// </summary>
-        public CodeTaskFactoryInstance(Assembly compiledAssembly, string taskName)
-        {
-            ErrorUtilities.VerifyThrowArgumentNull(taskName, "taskName");
-            ErrorUtilities.VerifyThrowArgumentNull(compiledAssembly, "compiledAssembly");
-
-            nameOfTask = taskName;
-            this.compiledAssembly = compiledAssembly;
-        }
-
-        /// <summary>
-        /// Create an instance of the ITask
-        /// </summary>
-        public ITask CreateTask(IBuildEngine taskFactoryLoggingHost)
-        {
-            // The assembly will have been compiled during class factory initialization, create an instance of it
-            if (this.compiledAssembly != null)
-            {
-                // In order to use the resource strings from the tasks assembly we need to register the resources with the task logging helper.
-                TaskLoggingHelper log = new TaskLoggingHelper(taskFactoryLoggingHost, nameOfTask);
-                log.TaskResources = AssemblyResources.PrimaryResources;
-                log.HelpKeywordPrefix = "MSBuild.";
-
-                Type[] exportedTypes = this.compiledAssembly.GetExportedTypes();
-
-                Type fullNameMatch = null;
-                Type partialNameMatch = null;
-
-                foreach (Type exportedType in exportedTypes)
-                {
-                    string exportedTypeName = exportedType.FullName;
-                    if (exportedTypeName.Equals(nameOfTask, StringComparison.OrdinalIgnoreCase))
-                    {
-                        fullNameMatch = exportedType;
-                        break;
-                    } 
-                    else if (partialNameMatch == null && exportedTypeName.EndsWith(nameOfTask, StringComparison.OrdinalIgnoreCase))
-                    {
-                        partialNameMatch = exportedType;
-                    }
-                }
-
-                if (fullNameMatch == null && partialNameMatch == null)
-                {
-                    log.LogErrorWithCodeFromResources("CodeTaskFactory.CouldNotFindTaskInAssembly", nameOfTask);
-                    return null;
-                }
-
-                this.taskInstance = this.compiledAssembly.CreateInstance(fullNameMatch != null ? fullNameMatch.FullName : partialNameMatch.FullName, true) as ITask;
-
-                if (this.taskInstance == null)
-                {
-                    log.LogErrorWithCodeFromResources("CodeTaskFactory.NeedsITaskInterface", nameOfTask);
-                    return null;
-                }
-
-                return this.taskInstance;
-            }
-            else
-            {
-                return null;
-            }
-        }
-
-        /// <summary>
-        /// Clean up any state created when the task was instantiated
-        /// </summary>
-        public void CleanupTask()
-        {
-            compiledAssembly = null;
-            taskInstance = null;
-        }
-
-        /// <summary>
-        /// Given a property info and a value set the parametervalue on the ITaskInstance
-        /// </summary>
-        public bool SetTaskParameterValue(PropertyInfo parameter, object parameterValue)
-        {
-            bool success = false;
-
-            PropertyInfo propInfo = this.taskInstance.GetType().GetProperty
-                (
-                parameter.Name,
-                BindingFlags.ExactBinding | BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.Public
-                );
-
-            propInfo.SetValue(taskInstance, parameterValue, null);
-            success = true;
-
-            return success;
-        }
-
-        /// <summary>
-        /// Given a property info get the value of the task parameter
-        /// </summary>
-        public object GetTaskParameterValue(PropertyInfo parameter)
-        {
-            // We need to work with the real propertyInfo object so that we can use reflection to collect the value
-            // so use our factory property info's name to get the real one, then use it.
-            PropertyInfo propInfo = this.taskInstance.GetType().GetProperty
-                (
-                parameter.Name,
-                BindingFlags.ExactBinding | BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.Public
-                );
-            return propInfo.GetValue(taskInstance, null);
-        }
-    }
-}
-
diff --git a/src/Tasks/ComDependencyWalker.cs b/src/Tasks/ComDependencyWalker.cs
index fb1a0b1fdfd..ca621fc1598 100644
--- a/src/Tasks/ComDependencyWalker.cs
+++ b/src/Tasks/ComDependencyWalker.cs
@@ -2,15 +2,10 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
-using System.Text;
 using System.Runtime.InteropServices.ComTypes;
 using System.Globalization;
 
-
-using Microsoft.Build.Shared;
-
 using Marshal = System.Runtime.InteropServices.Marshal;
 using COMException = System.Runtime.InteropServices.COMException;
 using VarEnum = System.Runtime.InteropServices.VarEnum;
@@ -28,10 +23,10 @@ internal class ComDependencyWalker
     {
         // Dependencies of all analyzed typelibs. Can be cleared to allow for analyzing typelibs one by one while
         // still skipping already seen types
-        private HashSet<TYPELIBATTR> _dependencies;
+        private readonly HashSet<TYPELIBATTR> _dependencies;
 
         // History of already seen types.
-        private HashSet<AnalyzedTypesInfoKey> _analyzedTypes;
+        private readonly HashSet<AnalyzedTypesInfoKey> _analyzedTypes;
 
         private sealed class TYPELIBATTRComparer : IEqualityComparer<TYPELIBATTR>
         {
@@ -97,20 +92,12 @@ public int GetHashCode(AnalyzedTypesInfoKey x)
             }
         }
 
-        private MarshalReleaseComObject _marshalReleaseComObject;
-
-        private List<Exception> _encounteredProblems;
+        private readonly MarshalReleaseComObject _marshalReleaseComObject;
 
         /// <summary>
         /// List of exceptions thrown by the components during scanning
         /// </summary>
-        internal List<Exception> EncounteredProblems
-        {
-            get
-            {
-                return _encounteredProblems;
-            }
-        }
+        internal List<Exception> EncounteredProblems { get; }
 
         /// <summary>
         /// Internal constructor
@@ -119,7 +106,7 @@ internal ComDependencyWalker(MarshalReleaseComObject marshalReleaseComObject)
         {
             _dependencies = new HashSet<TYPELIBATTR>(TYPELIBATTRComparer.Instance);
             _analyzedTypes = new HashSet<AnalyzedTypesInfoKey>(AnalyzedTypesInfoKeyComparer.Instance);
-            _encounteredProblems = new List<Exception>();
+            EncounteredProblems = new List<Exception>();
 
             _marshalReleaseComObject = marshalReleaseComObject;
         }
@@ -159,7 +146,7 @@ internal void AnalyzeTypeLibrary(ITypeLib typeLibrary)
             // that we got lots of exceptions thrown which was not only not very useful for the end user, but also horribly slow.
             catch (COMException ex)
             {
-                _encounteredProblems.Add(ex);
+                EncounteredProblems.Add(ex);
             }
         }
 
@@ -170,24 +157,21 @@ internal void AnalyzeTypeLibrary(ITypeLib typeLibrary)
         private void AnalyzeTypeInfo(ITypeInfo typeInfo)
         {
             ITypeLib containingTypeLib = null;
-            int indexInContainingTypeLib;
 
             try
             {
-                typeInfo.GetContainingTypeLib(out containingTypeLib, out indexInContainingTypeLib);
+                typeInfo.GetContainingTypeLib(out containingTypeLib, out int indexInContainingTypeLib);
 
-                TYPELIBATTR containingTypeLibAttributes;
-                ComReference.GetTypeLibAttrForTypeLib(ref containingTypeLib, out containingTypeLibAttributes);
+                ComReference.GetTypeLibAttrForTypeLib(ref containingTypeLib, out TYPELIBATTR containingTypeLibAttributes);
 
                 // Have we analyzed this type info already? If so skip it.
-                AnalyzedTypesInfoKey typeInfoId = new AnalyzedTypesInfoKey(
+                var typeInfoId = new AnalyzedTypesInfoKey(
                     containingTypeLibAttributes.guid, containingTypeLibAttributes.wMajorVerNum,
                     containingTypeLibAttributes.wMinorVerNum, containingTypeLibAttributes.lcid, indexInContainingTypeLib);
 
                 // Get enough information about the type to figure out if we want to register it as a dependency
-                TYPEATTR typeAttributes;
 
-                ComReference.GetTypeAttrForTypeInfo(typeInfo, out typeAttributes);
+                ComReference.GetTypeAttrForTypeInfo(typeInfo, out TYPEATTR typeAttributes);
 
                 // Is it one of the types we don't care about?
                 if (!CanSkipType(typeInfo, containingTypeLib, typeAttributes, containingTypeLibAttributes))
@@ -220,12 +204,7 @@ private void AnalyzeTypeInfo(ITypeInfo typeInfo)
         /// <summary>
         /// Returns true if we don't need to analyze this particular type.
         /// </summary>
-        /// <param name="typeInfo"></param>
-        /// <param name="typeLib"></param>
-        /// <param name="typeAttributes"></param>
-        /// <param name="typeLibAttributes"></param>
-        /// <returns></returns>
-        private bool CanSkipType(ITypeInfo typeInfo, ITypeLib typeLib, TYPEATTR typeAttributes, TYPELIBATTR typeLibAttributes)
+        private static bool CanSkipType(ITypeInfo typeInfo, ITypeLib typeLib, TYPEATTR typeAttributes, TYPELIBATTR typeLibAttributes)
         {
             // Well known OLE type?
             if ((typeAttributes.guid == NativeMethods.IID_IUnknown) ||
@@ -240,10 +219,7 @@ private bool CanSkipType(ITypeInfo typeInfo, ITypeLib typeLib, TYPEATTR typeAttr
             // Is this the Guid type? If so we should be using the corresponding .NET type. 
             if (typeLibAttributes.guid == NativeMethods.IID_StdOle)
             {
-                string typeName, ignoredDocString, ignoredHelpFile;
-                int ignoredHelpContext;
-
-                typeInfo.GetDocumentation(-1, out typeName, out ignoredDocString, out ignoredHelpContext, out ignoredHelpFile);
+                typeInfo.GetDocumentation(-1, out string typeName, out _, out _, out _);
 
                 if (string.CompareOrdinal(typeName, "GUID") == 0)
                 {
@@ -252,12 +228,9 @@ private bool CanSkipType(ITypeInfo typeInfo, ITypeLib typeLib, TYPEATTR typeAttr
             }
 
             // Skip types exported from .NET assemblies
-            ITypeLib2 typeLib2 = typeLib as ITypeLib2;
-
-            if (typeLib2 != null)
+            if (typeLib is ITypeLib2 typeLib2)
             {
-                object exportedFromComPlusObj;
-                typeLib2.GetCustData(ref NativeMethods.GUID_ExportedFromComPlus, out exportedFromComPlusObj);
+                typeLib2.GetCustData(ref NativeMethods.GUID_ExportedFromComPlus, out object exportedFromComPlusObj);
 
                 string exportedFromComPlus = exportedFromComPlusObj as string;
 
@@ -273,8 +246,6 @@ private bool CanSkipType(ITypeInfo typeInfo, ITypeLib typeLib, TYPEATTR typeAttr
         /// <summary>
         /// For a given type, analyze recursively all the types implemented by it.
         /// </summary>
-        /// <param name="typeInfo"></param>
-        /// <param name="typeAttributes"></param>
         private void ScanImplementedTypes(ITypeInfo typeInfo, TYPEATTR typeAttributes)
         {
             for (int implTypeIndex = 0; implTypeIndex < typeAttributes.cImplTypes; implTypeIndex++)
@@ -283,9 +254,8 @@ private void ScanImplementedTypes(ITypeInfo typeInfo, TYPEATTR typeAttributes)
 
                 try
                 {
-                    IntPtr hRef;
-                    IFixedTypeInfo fixedTypeInfo = (IFixedTypeInfo)typeInfo;
-                    fixedTypeInfo.GetRefTypeOfImplType(implTypeIndex, out hRef);
+                    var fixedTypeInfo = (IFixedTypeInfo)typeInfo;
+                    fixedTypeInfo.GetRefTypeOfImplType(implTypeIndex, out IntPtr hRef);
                     fixedTypeInfo.GetRefTypeInfo(hRef, out implementedType);
 
                     AnalyzeTypeInfo((ITypeInfo)implementedType);
@@ -303,8 +273,6 @@ private void ScanImplementedTypes(ITypeInfo typeInfo, TYPEATTR typeAttributes)
         /// <summary>
         /// For a given type, analyze all the variables defined by it
         /// </summary>
-        /// <param name="typeInfo"></param>
-        /// <param name="typeAttributes"></param>
         private void ScanDefinedVariables(ITypeInfo typeInfo, TYPEATTR typeAttributes)
         {
             for (int definedVarIndex = 0; definedVarIndex < typeAttributes.cVars; definedVarIndex++)
@@ -313,8 +281,7 @@ private void ScanDefinedVariables(ITypeInfo typeInfo, TYPEATTR typeAttributes)
 
                 try
                 {
-                    VARDESC varDesc;
-                    ComReference.GetVarDescForVarIndex(typeInfo, definedVarIndex, out varDesc, out varDescHandleToRelease);
+                    ComReference.GetVarDescForVarIndex(typeInfo, definedVarIndex, out VARDESC varDesc, out varDescHandleToRelease);
                     AnalyzeElement(typeInfo, varDesc.elemdescVar);
                 }
                 finally
@@ -330,8 +297,6 @@ private void ScanDefinedVariables(ITypeInfo typeInfo, TYPEATTR typeAttributes)
         /// <summary>
         /// For a given type, analyze all the functions implemented by it. That means all the argument and return types.
         /// </summary>
-        /// <param name="typeInfo"></param>
-        /// <param name="typeAttributes"></param>
         private void ScanDefinedFunctions(ITypeInfo typeInfo, TYPEATTR typeAttributes)
         {
             for (int definedFuncIndex = 0; definedFuncIndex < typeAttributes.cFuncs; definedFuncIndex++)
@@ -340,15 +305,14 @@ private void ScanDefinedFunctions(ITypeInfo typeInfo, TYPEATTR typeAttributes)
 
                 try
                 {
-                    FUNCDESC funcDesc;
-                    ComReference.GetFuncDescForDescIndex(typeInfo, definedFuncIndex, out funcDesc, out funcDescHandleToRelease);
+                    ComReference.GetFuncDescForDescIndex(typeInfo, definedFuncIndex, out FUNCDESC funcDesc, out funcDescHandleToRelease);
 
                     int offset = 0;
 
                     // Analyze the argument types
                     for (int paramIndex = 0; paramIndex < funcDesc.cParams; paramIndex++)
                     {
-                        ELEMDESC elemDesc = (ELEMDESC)Marshal.PtrToStructure(
+                        var elemDesc = (ELEMDESC)Marshal.PtrToStructure(
                             new IntPtr(funcDesc.lprgelemdescParam.ToInt64() + offset), typeof(ELEMDESC));
 
                         AnalyzeElement(typeInfo, elemDesc);
@@ -372,8 +336,6 @@ private void ScanDefinedFunctions(ITypeInfo typeInfo, TYPEATTR typeAttributes)
         /// <summary>
         /// Analyze the given element (i.e. composite type of an argument) recursively
         /// </summary>
-        /// <param name="elementDesc"></param>
-        /// <param name="typeInfo"></param>
         private void AnalyzeElement(ITypeInfo typeInfo, ELEMDESC elementDesc)
         {
             TYPEDESC typeDesc = elementDesc.tdesc;
@@ -381,7 +343,7 @@ private void AnalyzeElement(ITypeInfo typeInfo, ELEMDESC elementDesc)
             // If the current type is a pointer or an array, determine the child type and analyze that.
             while (((VarEnum)typeDesc.vt == VarEnum.VT_PTR) || ((VarEnum)typeDesc.vt == VarEnum.VT_SAFEARRAY))
             {
-                TYPEDESC childTypeDesc = (TYPEDESC)Marshal.PtrToStructure(typeDesc.lpValue, typeof(TYPEDESC));
+                var childTypeDesc = (TYPEDESC)Marshal.PtrToStructure(typeDesc.lpValue, typeof(TYPEDESC));
                 typeDesc = childTypeDesc;
             }
 
@@ -414,7 +376,7 @@ private void AnalyzeElement(ITypeInfo typeInfo, ELEMDESC elementDesc)
         /// <returns></returns>
         internal TYPELIBATTR[] GetDependencies()
         {
-            TYPELIBATTR[] returnArray = new TYPELIBATTR[_dependencies.Count];
+            var returnArray = new TYPELIBATTR[_dependencies.Count];
             _dependencies.CopyTo(returnArray);
             return returnArray;
         }
@@ -425,7 +387,7 @@ internal TYPELIBATTR[] GetDependencies()
         /// </summary>
         internal ICollection<string> GetAnalyzedTypeNames()
         {
-            string[] names = new string[_analyzedTypes.Count];
+            var names = new string[_analyzedTypes.Count];
             int i = 0;
             foreach (AnalyzedTypesInfoKey analyzedType in _analyzedTypes)
             {
diff --git a/src/Tasks/ComReferenceInfo.cs b/src/Tasks/ComReferenceInfo.cs
index 6c4474ee425..85e8cc3e3e2 100644
--- a/src/Tasks/ComReferenceInfo.cs
+++ b/src/Tasks/ComReferenceInfo.cs
@@ -112,8 +112,6 @@ internal ComReferenceInfo(ComReferenceInfo copyFrom)
         /// <summary>
         /// Initialize the object with type library attributes
         /// </summary>
-        /// <param name="attr"></param>
-        /// <param name="taskItem"></param>
         internal bool InitializeWithTypeLibAttrs(TaskLoggingHelper log, bool silent, TYPELIBATTR tlbAttr, ITaskItem originalTaskItem, string targetProcessorArchitecture)
         {
             TYPELIBATTR remappableTlbAttr = tlbAttr;
@@ -134,8 +132,6 @@ internal bool InitializeWithTypeLibAttrs(TaskLoggingHelper log, bool silent, TYP
         /// <summary>
         /// Initialize the object with a type library path 
         /// </summary>
-        /// <param name="path"></param>
-        /// <param name="taskItem"></param>
         internal bool InitializeWithPath(TaskLoggingHelper log, bool silent, string path, ITaskItem originalTaskItem, string targetProcessorArchitecture)
         {
             ErrorUtilities.VerifyThrowArgumentNull(path, "path");
@@ -150,7 +146,7 @@ internal bool InitializeWithPath(TaskLoggingHelper log, bool silent, string path
             // we're using tlbimp.exe, we need to pass the full path w/ type lib number to it, or it won't generate the interop 
             // assembly correctly. 
             this.fullTypeLibPath = path;
-            this.strippedTypeLibPath = ComReference.StripTypeLibNumberFromPath(path, new FileExists(File.Exists));
+            this.strippedTypeLibPath = ComReference.StripTypeLibNumberFromPath(path, File.Exists);
 
             // use the unstripped path to actually load the library
             switch (targetProcessorArchitecture)
@@ -181,7 +177,7 @@ internal bool InitializeWithPath(TaskLoggingHelper log, bool silent, string path
                     log,
                     silent,
                     this.typeLibPointer,
-                    this.GetTypeLibId(log),
+                    GetTypeLibId(log),
                     out this.typeLibName))
                 {
                     ReleaseTypeLibPtr();
@@ -216,17 +212,7 @@ private string GetTypeLibId(TaskLoggingHelper log)
         /// <summary>
         /// Get the source item, if available. Null otherwise.
         /// </summary>
-        internal string SourceItemSpec
-        {
-            get
-            {
-                if (taskItem == null)
-                {
-                    return null;
-                }
-                return taskItem.ItemSpec;
-            }
-        }
+        internal string SourceItemSpec => taskItem?.ItemSpec;
 
         /// <summary>
         /// Release the COM ITypeLib pointer for this reference
diff --git a/src/Tasks/ComReferenceItemAttributes.cs b/src/Tasks/ComReferenceItemAttributes.cs
index 0959fb496ce..e484d706082 100644
--- a/src/Tasks/ComReferenceItemAttributes.cs
+++ b/src/Tasks/ComReferenceItemAttributes.cs
@@ -1,8 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
diff --git a/src/Tasks/ComReferenceTypes.cs b/src/Tasks/ComReferenceTypes.cs
index e95da9858c1..c6b553c19ee 100644
--- a/src/Tasks/ComReferenceTypes.cs
+++ b/src/Tasks/ComReferenceTypes.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Globalization;
 
 namespace Microsoft.Build.Tasks
 {
@@ -43,8 +42,6 @@ internal static bool IsPia(string refType)
         /// <summary>
         /// returns true if refType equals primaryortlbimp, which is basically an unknown reference type
         /// </summary>
-        /// <param name="refType"></param>
-        /// <returns></returns>
         internal static bool IsPiaOrTlbImp(string refType)
         {
             return (string.Compare(refType, ComReferenceTypes.primaryortlbimp, StringComparison.OrdinalIgnoreCase) == 0);
diff --git a/src/Tasks/ComReferenceWrapperInfo.cs b/src/Tasks/ComReferenceWrapperInfo.cs
index b2ed7826e3a..3ef7a280a7d 100644
--- a/src/Tasks/ComReferenceWrapperInfo.cs
+++ b/src/Tasks/ComReferenceWrapperInfo.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Reflection;
 using Microsoft.Build.Shared;
 
@@ -12,14 +11,6 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     internal class ComReferenceWrapperInfo
     {
-        /// <summary>
-        /// Default constructor.
-        /// </summary>
-        internal ComReferenceWrapperInfo()
-        {
-            // do nothing
-        }
-
         // path to the wrapper assembly
         internal string path;
 
diff --git a/src/Tasks/CombinePath.cs b/src/Tasks/CombinePath.cs
index 646aba43200..4d132eca4af 100644
--- a/src/Tasks/CombinePath.cs
+++ b/src/Tasks/CombinePath.cs
@@ -3,9 +3,7 @@
 
 using System;
 using System.IO;
-using System.Collections;
 using System.Collections.Generic;
-using System.Resources;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
@@ -17,33 +15,13 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public class CombinePath : TaskExtension
     {
-        /// <summary>
-        /// Default constructor.  Does nothing.
-        /// </summary>
-        public CombinePath()
-        {
-        }
-
-        private string _basePath;
         private ITaskItem[] _paths;
-        private ITaskItem[] _combinedPaths;
 
         /// <summary>
         /// The base path, the first parameter into Path.Combine.  Can be a relative path,
         /// absolute path, or (blank).
         /// </summary>
-        public string BasePath
-        {
-            get
-            {
-                return _basePath;
-            }
-
-            set
-            {
-                _basePath = value;
-            }
-        }
+        public string BasePath { get; set; }
 
         /// <summary>
         /// The list of paths to combine with the base path.  These can be relative paths
@@ -54,14 +32,11 @@ public ITaskItem[] Paths
         {
             get
             {
-                ErrorUtilities.VerifyThrowArgumentNull(_paths, "paths");
+                ErrorUtilities.VerifyThrowArgumentNull(_paths, nameof(Paths));
                 return _paths;
             }
 
-            set
-            {
-                _paths = value;
-            }
+            set => _paths = value;
         }
 
         /// <summary>
@@ -69,18 +44,7 @@ public ITaskItem[] Paths
         /// path with each of the paths passed in.
         /// </summary>
         [Output]
-        public ITaskItem[] CombinedPaths
-        {
-            get
-            {
-                return _combinedPaths;
-            }
-
-            set
-            {
-                _combinedPaths = value;
-            }
-        }
+        public ITaskItem[] CombinedPaths { get; set; }
 
         /// <summary>
         /// Calls Path.Combine for each of the inputs.  Preserves metadata.
@@ -88,20 +52,20 @@ public ITaskItem[] CombinedPaths
         /// <returns>true on success, false on failure</returns>
         public override bool Execute()
         {
-            if (this.BasePath == null)
+            if (BasePath == null)
             {
-                this.BasePath = String.Empty;
+                BasePath = String.Empty;
             }
 
-            List<ITaskItem> combinedPathsList = new List<ITaskItem>();
+            var combinedPathsList = new List<ITaskItem>();
 
-            foreach (ITaskItem path in this.Paths)
+            foreach (ITaskItem path in Paths)
             {
-                TaskItem combinedPath = new TaskItem(path);
+                var combinedPath = new TaskItem(path);
 
                 try
                 {
-                    combinedPath.ItemSpec = Path.Combine(_basePath, path.ItemSpec);
+                    combinedPath.ItemSpec = Path.Combine(BasePath, path.ItemSpec);
                     combinedPathsList.Add(combinedPath);
                 }
                 catch (ArgumentException e)
@@ -110,7 +74,7 @@ public override bool Execute()
                 }
             }
 
-            this.CombinedPaths = combinedPathsList.ToArray();
+            CombinedPaths = combinedPathsList.ToArray();
             return !Log.HasLoggedErrors;
         }
     }
diff --git a/src/Tasks/CommandLineBuilderExtension.cs b/src/Tasks/CommandLineBuilderExtension.cs
index 1d5994f2355..d2b8ba10fc7 100644
--- a/src/Tasks/CommandLineBuilderExtension.cs
+++ b/src/Tasks/CommandLineBuilderExtension.cs
@@ -21,7 +21,6 @@ public class CommandLineBuilderExtension : CommandLineBuilder
         /// </summary>
         public CommandLineBuilderExtension()
         {
-            
         }
 
         /// <summary>
@@ -30,15 +29,11 @@ public CommandLineBuilderExtension()
         public CommandLineBuilderExtension(bool quoteHyphensOnCommandLine, bool useNewLineSeparator)
             : base(quoteHyphensOnCommandLine, useNewLineSeparator)
         {
-            
         }
 
         /// <summary>
         /// Set a boolean switch iff its value exists and its value is 'true'.
         /// </summary>
-        /// <param name="switchName"></param>
-        /// <param name="bag"></param>
-        /// <param name="parameterName"></param>
         internal void AppendWhenTrue
             (
             string switchName,
@@ -62,9 +57,6 @@ string parameterName
         /// <summary>
         /// Set a boolean switch only if its value exists.
         /// </summary>
-        /// <param name="switchName"></param>
-        /// <param name="bag"></param>
-        /// <param name="parameterName"></param>
         internal void AppendPlusOrMinusSwitch
             (
             string switchName,
@@ -101,11 +93,6 @@ internal void AppendPlusOrMinusSwitch
         /// <summary>
         /// Set a switch if its value exists by choosing from the input choices
         /// </summary>
-        /// <param name="switchName"></param>
-        /// <param name="bag"></param>
-        /// <param name="parameterName"></param>
-        /// <param name="choice1"></param>
-        /// <param name="choice2"></param>
         internal void AppendByChoiceSwitch
             (
             string switchName,
@@ -127,9 +114,6 @@ string choice2
         /// <summary>
         /// Set an integer switch only if its value exists.
         /// </summary>
-        /// <param name="switchName"></param>
-        /// <param name="bag"></param>
-        /// <param name="parameterName"></param>
         internal void AppendSwitchWithInteger
             (
             string switchName,
@@ -150,9 +134,6 @@ string parameterName
         /// Adds an aliased switch, used for ResGen:
         ///      /reference:Foo=System.Xml.dll
         /// </summary>
-        /// <param name="switchName"></param>
-        /// <param name="alias"></param>
-        /// <param name="parameter"></param>
         internal void AppendSwitchAliased(string switchName, string alias, string parameter)
         {
             AppendSwitchUnquotedIfNotNull(switchName, alias + "=");
@@ -209,9 +190,6 @@ string[] attributes
         /// Append a switch if 'parameter' is not null.
         /// Split on the characters provided.
         /// </summary>
-        /// <param name="switchName"></param>
-        /// <param name="parameters"></param>
-        /// <param name="quoteChars"></param>
         internal void AppendSwitchWithSplitting(string switchName, string parameter, string delimiter, params char[] splitOn)
         {
             if (parameter != null)
@@ -231,16 +209,14 @@ internal void AppendSwitchWithSplitting(string switchName, string parameter, str
         /// even if it contains the separators and white space only
         /// Split on the characters provided.
         /// </summary>
-        /// <param name="parameters"></param>
-        /// <param name="splitOn"></param>
         internal static bool IsParameterEmpty(string parameter, params char[] splitOn)
         {
             if (parameter != null)
             {
                 string[] splits = parameter.Split(splitOn, /* omitEmptyEntries */ StringSplitOptions.RemoveEmptyEntries);
-                for (int i = 0; i < splits.Length; ++i)
+                foreach (string s in splits)
                 {
-                    if (!String.IsNullOrEmpty(splits[i].Trim()))
+                    if (!String.IsNullOrEmpty(s.Trim()))
                     {
                         return false;
                     }
@@ -288,7 +264,7 @@ internal void AppendSwitchIfNotNull
                         {
                             string metadataValue = parameter.GetMetadata(metadataNames[i]);
 
-                            if ((metadataValue != null) && (metadataValue.Length > 0))
+                            if (!string.IsNullOrEmpty(metadataValue))
                             {
                                 // Treat attribute as a boolean flag?
                                 if (treatAsFlags == null || treatAsFlags[i] == false)
@@ -300,10 +276,7 @@ internal void AppendSwitchIfNotNull
                                 else
                                 {
                                     // A boolean flag.
-                                    bool flagSet = false;
-
-                                    flagSet = MetadataConversionUtilities.TryConvertItemMetadataToBool(parameter, metadataNames[i]);
-
+                                    bool flagSet = MetadataConversionUtilities.TryConvertItemMetadataToBool(parameter, metadataNames[i]);
                                     if (flagSet)
                                     {
                                         CommandLine.Append(',');
diff --git a/src/Tasks/ConvertToAbsolutePath.cs b/src/Tasks/ConvertToAbsolutePath.cs
index d48d1ff1330..b5df8f2ef20 100644
--- a/src/Tasks/ConvertToAbsolutePath.cs
+++ b/src/Tasks/ConvertToAbsolutePath.cs
@@ -3,11 +3,8 @@
 
 using System;
 using System.IO;
-using System.Collections;
 using System.Collections.Generic;
-using System.Resources;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -17,15 +14,7 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public class ConvertToAbsolutePath : TaskExtension
     {
-        /// <summary>
-        /// Default constructor.  Does nothing.
-        /// </summary>
-        public ConvertToAbsolutePath()
-        {
-        }
-
         private ITaskItem[] _paths;
-        private ITaskItem[] _absolutePaths;
 
         /// <summary>
         /// The list of paths to convert to absolute paths.
@@ -35,32 +24,18 @@ public ITaskItem[] Paths
         {
             get
             {
-                ErrorUtilities.VerifyThrowArgumentNull(_paths, "paths");
+                ErrorUtilities.VerifyThrowArgumentNull(_paths, nameof(Paths));
                 return _paths;
             }
 
-            set
-            {
-                _paths = value;
-            }
+            set => _paths = value;
         }
 
         /// <summary>
         /// This is the output of the task, a list of absolute paths for the items passed in
         /// </summary>
         [Output]
-        public ITaskItem[] AbsolutePaths
-        {
-            get
-            {
-                return _absolutePaths;
-            }
-
-            set
-            {
-                _absolutePaths = value;
-            }
-        }
+        public ITaskItem[] AbsolutePaths { get; set; }
 
         /// <summary>
         /// Calls Path.GetFullPath for each of the inputs.  Preserves metadata.
@@ -68,9 +43,9 @@ public ITaskItem[] AbsolutePaths
         /// <returns>true on success, false on failure</returns>
         public override bool Execute()
         {
-            List<ITaskItem> absolutePathsList = new List<ITaskItem>();
+            var absolutePathsList = new List<ITaskItem>();
 
-            foreach (ITaskItem path in this.Paths)
+            foreach (ITaskItem path in Paths)
             {
                 try
                 {
@@ -78,9 +53,9 @@ public override bool Execute()
                     // going to disk when it is not necessary
                     if (!Path.IsPathRooted(path.ItemSpec))
                     {
-                        if (path is ITaskItem2)
+                        if (path is ITaskItem2 item2)
                         {
-                            ((ITaskItem2)path).EvaluatedIncludeEscaped = ((ITaskItem2)path).GetMetadataValueEscaped("FullPath");
+                            item2.EvaluatedIncludeEscaped = item2.GetMetadataValueEscaped("FullPath");
                         }
                         else
                         {
@@ -95,7 +70,7 @@ public override bool Execute()
                 }
             }
 
-            this.AbsolutePaths = absolutePathsList.ToArray();
+            AbsolutePaths = absolutePathsList.ToArray();
             return !Log.HasLoggedErrors;
         }
     }
diff --git a/src/Tasks/CreateCSharpManifestResourceName.cs b/src/Tasks/CreateCSharpManifestResourceName.cs
index 5708817a9a5..1a2971efc20 100644
--- a/src/Tasks/CreateCSharpManifestResourceName.cs
+++ b/src/Tasks/CreateCSharpManifestResourceName.cs
@@ -27,7 +27,7 @@ public class CreateCSharpManifestResourceName : CreateManifestResourceName
         /// <param name="dependentUponFileName">The file name of the parent of this dependency (usually a .cs file). May be null</param>
         /// <param name="binaryStream">File contents binary stream, may be null</param>
         /// <returns>Returns the manifest name</returns>
-        override protected string CreateManifestName
+        protected override string CreateManifestName
         (
             string fileName,
             string linkFileName,
@@ -36,9 +36,8 @@ override protected string CreateManifestName
             Stream binaryStream
         )
         {
-            ITaskItem item = null;
             string culture = null;
-            if (fileName != null && itemSpecToTaskitem.TryGetValue(fileName, out item))
+            if (fileName != null && itemSpecToTaskitem.TryGetValue(fileName, out ITaskItem item))
             {
                 culture = item.GetMetadata("Culture");
             }
@@ -49,7 +48,7 @@ The reason is that CreateManifestName can't be static because it is an
                 override of a method declared in the base class, but its convenient 
                 to expose a static version anyway for unittesting purposes.
             */
-            return CreateCSharpManifestResourceName.CreateManifestNameImpl
+            return CreateManifestNameImpl
             (
                 fileName,
                 linkFileName,
@@ -58,7 +57,7 @@ The reason is that CreateManifestName can't be static because it is an
                 dependentUponFileName,
                 culture,
                 binaryStream,
-                this.Log
+                Log
             );
         }
 
@@ -92,7 +91,7 @@ TaskLoggingHelper log
         {
             // Use the link file name if there is one, otherwise, fall back to file name.
             string embeddedFileName = FileUtilities.FixFilePath(linkFileName);
-            if (embeddedFileName == null || embeddedFileName.Length == 0)
+            if (string.IsNullOrEmpty(embeddedFileName))
             {
                 embeddedFileName = FileUtilities.FixFilePath(fileName);
             }
@@ -106,24 +105,24 @@ TaskLoggingHelper log
                 info.culture = culture;
             }
 
-            StringBuilder manifestName = new StringBuilder();
+            var manifestName = new StringBuilder();
             if (binaryStream != null)
             {
                 // Resource depends on a form. Now, get the form's class name fully 
                 // qualified with a namespace.
                 ExtractedClassName result = CSharpParserUtilities.GetFirstClassNameFullyQualified(binaryStream);
 
-                if (result.IsInsideConditionalBlock && log != null)
+                if (result.IsInsideConditionalBlock)
                 {
-                    log.LogWarningWithCodeFromResources("CreateManifestResourceName.DefinitionFoundWithinConditionalDirective", dependentUponFileName, embeddedFileName);
+                    log?.LogWarningWithCodeFromResources("CreateManifestResourceName.DefinitionFoundWithinConditionalDirective", dependentUponFileName, embeddedFileName);
                 }
 
-                if (result.Name != null && result.Name.Length > 0)
+                if (!string.IsNullOrEmpty(result.Name))
                 {
                     manifestName.Append(result.Name);
 
                     // Append the culture if there is one.        
-                    if (info.culture != null && info.culture.Length > 0)
+                    if (!string.IsNullOrEmpty(info.culture))
                     {
                         manifestName.Append(".").Append(info.culture);
                     }
@@ -136,14 +135,14 @@ TaskLoggingHelper log
             {
                 // If Rootnamespace was null, then it wasn't set from the project resourceFile.
                 // Empty namespaces are allowed.
-                if ((rootNamespace != null) && (rootNamespace.Length > 0))
+                if (!string.IsNullOrEmpty(rootNamespace))
                 {
                     manifestName.Append(rootNamespace).Append(".");
                 }
 
                 // Replace spaces in the directory name with underscores. Needed for compatibility with Everett.
                 // Note that spaces in the file name itself are preserved.
-                string everettCompatibleDirectoryName = CreateManifestResourceName.MakeValidEverettIdentifier(Path.GetDirectoryName(info.cultureNeutralFilename));
+                string everettCompatibleDirectoryName = MakeValidEverettIdentifier(Path.GetDirectoryName(info.cultureNeutralFilename));
 
                 // only strip extension for .resx and .restext files
 
@@ -163,7 +162,7 @@ TaskLoggingHelper log
                     manifestName.Replace(Path.AltDirectorySeparatorChar, '.');
 
                     // Append the culture if there is one.        
-                    if (info.culture != null && info.culture.Length > 0)
+                    if (!string.IsNullOrEmpty(info.culture))
                     {
                         manifestName.Append(".").Append(info.culture);
                     }
@@ -185,7 +184,7 @@ TaskLoggingHelper log
                     if (prependCultureAsDirectory)
                     {
                         // Prepend the culture as a subdirectory if there is one.        
-                        if (info.culture != null && info.culture.Length > 0)
+                        if (!string.IsNullOrEmpty(info.culture))
                         {
                             manifestName.Insert(0, Path.DirectorySeparatorChar);
                             manifestName.Insert(0, info.culture);
@@ -202,7 +201,7 @@ TaskLoggingHelper log
         /// </summary>
         /// <param name="fileName">Name of the candidate source file.</param>
         /// <returns>True, if this is a validate source file.</returns>
-        override protected bool IsSourceFile(string fileName)
+        protected override bool IsSourceFile(string fileName)
         {
             string extension = Path.GetExtension(fileName);
             return (String.Compare(extension, ".cs", StringComparison.OrdinalIgnoreCase) == 0);
diff --git a/src/Tasks/CreateItem.cs b/src/Tasks/CreateItem.cs
index f0622f689d1..82098d355d4 100644
--- a/src/Tasks/CreateItem.cs
+++ b/src/Tasks/CreateItem.cs
@@ -2,15 +2,10 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
-using System.Diagnostics;
+using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
-using System.Collections;
-using System.Globalization;
-using System.Reflection;
-using System.Resources;
 
 namespace Microsoft.Build.Tasks
 {
@@ -21,53 +16,15 @@ public class CreateItem : TaskExtension
     {
         #region Properties
 
-        private ITaskItem[] _include;
-        private ITaskItem[] _exclude;
-        private string[] _additionalMetadata;
-        private bool _preserveExistingMetadata = false;
-
         [Output]
-        public ITaskItem[] Include
-        {
-            get
-            {
-                return _include;
-            }
-
-            set
-            {
-                _include = value;
-            }
-        }
+        public ITaskItem[] Include { get; set; }
 
-        public ITaskItem[] Exclude
-        {
-            get
-            {
-                return _exclude;
-            }
-
-            set
-            {
-                _exclude = value;
-            }
-        }
+        public ITaskItem[] Exclude { get; set; }
 
         /// <summary>
         /// Only apply the additional metadata is none already exists
         /// </summary>
-        public bool PreserveExistingMetadata
-        {
-            get
-            {
-                return _preserveExistingMetadata;
-            }
-
-            set
-            {
-                _preserveExistingMetadata = value;
-            }
-        }
+        public bool PreserveExistingMetadata { get; set; } = false;
 
         /// <summary>
         /// A list of metadata name/value pairs to apply to the output items.  
@@ -83,17 +40,7 @@ public bool PreserveExistingMetadata
         ///     <CreateItem
         ///         AdditionalMetadata="@(OutputPathItem->'TargetPath=%(Identity)')" />
         /// </remarks>
-        public string[] AdditionalMetadata
-        {
-            get
-            {
-                return _additionalMetadata;
-            }
-            set
-            {
-                _additionalMetadata = value;
-            }
-        }
+        public string[] AdditionalMetadata { get; set; }
 
         #endregion
 
@@ -105,7 +52,7 @@ public override bool Execute()
         {
             if (Include == null)
             {
-                _include = Array.Empty<TaskItem>();
+                Include = Array.Empty<ITaskItem>();
                 return true;
             }
 
@@ -121,20 +68,18 @@ public override bool Execute()
             }
 
             // Parse the global properties into a hashtable.
-            Hashtable metadataTable;
-            if (!PropertyParser.GetTable(Log, "AdditionalMetadata", this.AdditionalMetadata, out metadataTable))
+            if (!PropertyParser.GetTable(Log, "AdditionalMetadata", AdditionalMetadata, out Dictionary<string, string> metadataTable))
             {
                 return false;
             }
 
-
             // Build a table of unique items.
-            Hashtable excludeItems = GetUniqueItems(Exclude);
+            Dictionary<string, string> excludeItems = GetUniqueItems(Exclude);
 
             // Produce the output items, add attribute and honor exclude.
-            ArrayList outputItems = CreateOutputItems(metadataTable, excludeItems);
+            List<ITaskItem> outputItems = CreateOutputItems(metadataTable, excludeItems);
 
-            _include = (ITaskItem[])outputItems.ToArray(typeof(ITaskItem));
+            Include = outputItems.ToArray();
 
             return !Log.HasLoggedErrors;
         }
@@ -142,36 +87,34 @@ public override bool Execute()
         /// <summary>
         /// Create the list of output items.
         /// </summary>
-        /// <param name="needToSetAttributes">Whether attributes need to be set.</param>
-        /// <param name="excludeItems">Items to exclude.</param>
-        private ArrayList CreateOutputItems(Hashtable metadataTable, Hashtable excludeItems)
+        private List<ITaskItem> CreateOutputItems(Dictionary<string, string> metadataTable, Dictionary<string, string> excludeItems)
         {
-            ArrayList outputItems = new ArrayList();
+            var outputItems = new List<ITaskItem>();
 
-            for (int i = 0; i < Include.Length; i++)
+            foreach (ITaskItem i in Include)
             {
                 if (
                     (excludeItems.Count == 0) ||        // minor perf optimization
-                    (!excludeItems.ContainsKey(Include[i].ItemSpec))
-                   )
+                    (!excludeItems.ContainsKey(i.ItemSpec))
+                )
                 {
-                    ITaskItem newItem = _include[i];
+                    ITaskItem newItem = i;
                     if (null != metadataTable)
                     {
-                        foreach (DictionaryEntry nameAndValue in metadataTable)
+                        foreach (KeyValuePair<string, string> nameAndValue in metadataTable)
                         {
                             // 1. If we have been asked to not preserve existing metadata then overwrite
                             // 2. If there is no existing metadata then apply the new
-                            if ((!_preserveExistingMetadata) || String.IsNullOrEmpty(newItem.GetMetadata((string)nameAndValue.Key)))
+                            if ((!PreserveExistingMetadata) || String.IsNullOrEmpty(newItem.GetMetadata(nameAndValue.Key)))
                             {
-                                if (FileUtilities.ItemSpecModifiers.IsItemSpecModifier((string)nameAndValue.Key))
+                                if (FileUtilities.ItemSpecModifiers.IsItemSpecModifier(nameAndValue.Key))
                                 {
                                     // Explicitly setting built-in metadata, is not allowed. 
-                                    Log.LogErrorWithCodeFromResources("CreateItem.AdditionalMetadataError", (string)nameAndValue.Key);
+                                    Log.LogErrorWithCodeFromResources("CreateItem.AdditionalMetadataError", nameAndValue.Key);
                                     break;
                                 }
 
-                                newItem.SetMetadata((string)nameAndValue.Key, (string)nameAndValue.Value);
+                                newItem.SetMetadata(nameAndValue.Key, nameAndValue.Value);
                             }
                         }
                     }
@@ -184,8 +127,6 @@ private ArrayList CreateOutputItems(Hashtable metadataTable, Hashtable excludeIt
         /// <summary>
         /// Expand wildcards in the item list.
         /// </summary>
-        /// <param name="expand"></param>
-        /// <returns></returns>
         private static ITaskItem[] ExpandWildcards(ITaskItem[] expand)
         {
             if (expand == null)
@@ -194,7 +135,7 @@ private static ITaskItem[] ExpandWildcards(ITaskItem[] expand)
             }
             else
             {
-                ArrayList expanded = new ArrayList();
+                var expanded = new List<ITaskItem>();
                 foreach (ITaskItem i in expand)
                 {
                     if (FileMatcher.HasWildcards(i.ItemSpec))
@@ -202,14 +143,13 @@ private static ITaskItem[] ExpandWildcards(ITaskItem[] expand)
                         string[] files = FileMatcher.GetFiles(null /* use current directory */, i.ItemSpec);
                         foreach (string file in files)
                         {
-                            TaskItem newItem = new TaskItem((ITaskItem)i);
-                            newItem.ItemSpec = file;
+                            TaskItem newItem = new TaskItem(i) { ItemSpec = file };
 
                             // Compute the RecursiveDir portion.
                             FileMatcher.Result match = FileMatcher.FileMatch(i.ItemSpec, file);
                             if (match.isLegalFileSpec && match.isMatch)
                             {
-                                if (match.wildcardDirectoryPart != null && match.wildcardDirectoryPart.Length > 0)
+                                if (!string.IsNullOrEmpty(match.wildcardDirectoryPart))
                                 {
                                     newItem.SetMetadata(FileUtilities.ItemSpecModifiers.RecursiveDir, match.wildcardDirectoryPart);
                                 }
@@ -223,17 +163,16 @@ private static ITaskItem[] ExpandWildcards(ITaskItem[] expand)
                         expanded.Add(i);
                     }
                 }
-                return (ITaskItem[])expanded.ToArray(typeof(ITaskItem));
+                return expanded.ToArray();
             }
         }
 
         /// <summary>
         /// Create a table of unique items
         /// </summary>
-        /// <returns></returns>
-        private static Hashtable GetUniqueItems(ITaskItem[] items)
+        private static Dictionary<string, string> GetUniqueItems(ITaskItem[] items)
         {
-            Hashtable uniqueItems = new Hashtable(StringComparer.OrdinalIgnoreCase);
+            var uniqueItems = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
             if (items != null)
             {
diff --git a/src/Tasks/CreateManifestResourceName.cs b/src/Tasks/CreateManifestResourceName.cs
index 1c107948491..e491d34ebae 100644
--- a/src/Tasks/CreateManifestResourceName.cs
+++ b/src/Tasks/CreateManifestResourceName.cs
@@ -2,17 +2,14 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections.Generic;
+using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.IO;
-using System.Resources;
-using System.Reflection;
-using System.Diagnostics;
 using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
-using System.Collections.Generic;
-using System.Diagnostics.CodeAnalysis;
 
 namespace Microsoft.Build.Tasks
 {
@@ -24,11 +21,7 @@ public abstract class CreateManifestResourceName : TaskExtension
     {
         #region Properties
 
-        private ITaskItem[] _resourceFiles = null;
-        private string _rootNamespace = null;
-        private ITaskItem[] _manifestResourceNames = null;
-        private ITaskItem[] _resourceFilesWithManifestResourceNames = null;
-        private bool _prependCultureAsDirectory = true;
+        private ITaskItem[] _resourceFiles;
 
         [SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Justification = "Shipped this way in Dev11 Beta (go-live)")]
         [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Taskitem", Justification = "Shipped this way in Dev11 Beta (go-live)")]
@@ -38,11 +31,7 @@ public abstract class CreateManifestResourceName : TaskExtension
         /// Should the culture name be prepended to the manifest resource name as a directory?
         /// This is true by default.
         /// </summary>
-        public bool PrependCultureAsDirectory
-        {
-            get { return _prependCultureAsDirectory; }
-            set { _prependCultureAsDirectory = value; }
-        }
+        public bool PrependCultureAsDirectory { get; set; } = true;
 
         /// <summary>
         /// The possibly dependent resource files.
@@ -52,20 +41,16 @@ public ITaskItem[] ResourceFiles
         {
             get
             {
-                ErrorUtilities.VerifyThrowArgumentNull(_resourceFiles, "resourceFiles");
+                ErrorUtilities.VerifyThrowArgumentNull(_resourceFiles, nameof(ResourceFiles));
                 return _resourceFiles;
             }
-            set { _resourceFiles = value; }
+            set => _resourceFiles = value;
         }
 
         /// <summary>
         /// Rootnamespace to use for naming.
         /// </summary>
-        public string RootNamespace
-        {
-            get { return _rootNamespace; }
-            set { _rootNamespace = value; }
-        }
+        public string RootNamespace { get; set; } = null;
 
         /// <summary>
         /// The resulting manifest names.
@@ -73,34 +58,26 @@ public string RootNamespace
         /// <value></value>
 
         [Output]
-        public ITaskItem[] ManifestResourceNames
-        {
-            get { return _manifestResourceNames; }
-        }
+        public ITaskItem[] ManifestResourceNames { get; private set; }
 
         /// <summary>
         /// The initial list of resource names, with additional metadata for manifest resource names
         /// </summary>
         [Output]
-        public ITaskItem[] ResourceFilesWithManifestResourceNames
-        {
-            get { return _resourceFilesWithManifestResourceNames; }
-            set { _resourceFilesWithManifestResourceNames = value; }
-        }
-        #endregion
+        public ITaskItem[] ResourceFilesWithManifestResourceNames { get; set; }
 
+        #endregion
 
         /// <summary>
         /// Method in the derived class that composes the manifest name.
         /// </summary>
         /// <param name="fileName">The file name of the dependent (usually a .resx)</param>
         /// <param name="linkFileName">The name of the file specified by the Link attribute.</param>
-        /// <param name="rootNamespace">The root namespace (usually from the project file). May be null</param>
+        /// <param name="rootNamespaceName">The root namespace (usually from the project file). May be null</param>
         /// <param name="dependentUponFileName">The file name of the parent of this dependency. May be null</param>
-        /// <param name="culture">The override culture of this resource, if any</param>
         /// <param name="binaryStream">File contents binary stream, may be null</param>
         /// <returns>Returns the manifest name</returns>
-        abstract protected string CreateManifestName
+        protected abstract string CreateManifestName
         (
             string fileName,
             string linkFileName,
@@ -115,7 +92,7 @@ Stream binaryStream
         /// </summary>
         /// <param name="fileName">Name of the candidate source file.</param>
         /// <returns>True, if this is a validate source file.</returns>
-        abstract protected bool IsSourceFile(string fileName);
+        protected abstract bool IsSourceFile(string fileName);
 
         /// <summary>
         /// Given a file path, return a stream on top of that path.
@@ -124,7 +101,7 @@ Stream binaryStream
         /// <param name="mode">File mode</param>
         /// <param name="access">Access type</param>
         /// <returns>The FileStream</returns>
-        private Stream CreateFileStreamOverNewFileStream(string path, FileMode mode, FileAccess access)
+        private static Stream CreateFileStreamOverNewFileStream(string path, FileMode mode, FileAccess access)
         {
             return new FileStream(path, mode, access);
         }
@@ -140,8 +117,8 @@ internal bool Execute
             CreateFileStream createFileStream
         )
         {
-            _manifestResourceNames = new TaskItem[ResourceFiles.Length];
-            _resourceFilesWithManifestResourceNames = new TaskItem[ResourceFiles.Length];
+            ManifestResourceNames = new ITaskItem[ResourceFiles.Length];
+            ResourceFilesWithManifestResourceNames = new ITaskItem[ResourceFiles.Length];
 
             bool success = true;
             int i = 0;
@@ -150,7 +127,7 @@ CreateFileStream createFileStream
             // Empty namespaces are allowed.
             if (RootNamespace != null)
             {
-                Log.LogMessageFromResources(MessageImportance.Low, "CreateManifestResourceName.RootNamespace", _rootNamespace);
+                Log.LogMessageFromResources(MessageImportance.Low, "CreateManifestResourceName.RootNamespace", RootNamespace);
             }
             else
             {
@@ -163,10 +140,10 @@ CreateFileStream createFileStream
                 try
                 {
                     string fileName = resourceFile.ItemSpec;
-                    string dependentUpon = (string)resourceFile.GetMetadata(ItemMetadataNames.dependentUpon);
+                    string dependentUpon = resourceFile.GetMetadata(ItemMetadataNames.dependentUpon);
 
                     // Pre-log some information.
-                    bool isDependentOnSourceFile = (dependentUpon != null) && (dependentUpon.Length > 0) && IsSourceFile(dependentUpon);
+                    bool isDependentOnSourceFile = !string.IsNullOrEmpty(dependentUpon) && IsSourceFile(dependentUpon);
 
                     if (isDependentOnSourceFile)
                     {
@@ -205,20 +182,19 @@ CreateFileStream createFileStream
                     }
 
                     // Emit an item with our manifest name.
-                    _manifestResourceNames[i] = new TaskItem(resourceFile);
-                    _manifestResourceNames[i].ItemSpec = manifestName;
+                    ManifestResourceNames[i] = new TaskItem(resourceFile) { ItemSpec = manifestName };
 
                     // Emit a new item preserving the itemSpec of the resourceFile, but with new metadata for manifest resource name
-                    _resourceFilesWithManifestResourceNames[i] = new TaskItem(resourceFile);
-                    _resourceFilesWithManifestResourceNames[i].SetMetadata("ManifestResourceName", manifestName);
+                    ResourceFilesWithManifestResourceNames[i] = new TaskItem(resourceFile);
+                    ResourceFilesWithManifestResourceNames[i].SetMetadata("ManifestResourceName", manifestName);
 
                     // Add a LogicalName metadata to Non-Resx resources
                     // LogicalName isn't used for Resx resources because the ManifestResourceName metadata determines the filename of the 
                     // .resources file which then is used as the embedded resource manifest name                    
-                    if (String.IsNullOrEmpty(_resourceFilesWithManifestResourceNames[i].GetMetadata("LogicalName")) &&
-                        String.Equals(_resourceFilesWithManifestResourceNames[i].GetMetadata("Type"), "Non-Resx", StringComparison.OrdinalIgnoreCase))
+                    if (String.IsNullOrEmpty(ResourceFilesWithManifestResourceNames[i].GetMetadata("LogicalName")) &&
+                        String.Equals(ResourceFilesWithManifestResourceNames[i].GetMetadata("Type"), "Non-Resx", StringComparison.OrdinalIgnoreCase))
                     {
-                        _resourceFilesWithManifestResourceNames[i].SetMetadata("LogicalName", manifestName);
+                        ResourceFilesWithManifestResourceNames[i].SetMetadata("LogicalName", manifestName);
                     }
 
                     // Post-logging
@@ -242,10 +218,7 @@ CreateFileStream createFileStream
         /// <returns>True if succeeded.</returns>
         public override bool Execute()
         {
-            return Execute
-            (
-                new CreateFileStream(CreateFileStreamOverNewFileStream)
-            );
+            return Execute(CreateFileStreamOverNewFileStream);
         }
 
         #endregion
@@ -282,15 +255,17 @@ private static bool IsValidEverettIdChar(char c)
         /// </summary>
         private static string MakeValidEverettSubFolderIdentifier(string subName)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(subName, "subName");
+            ErrorUtilities.VerifyThrowArgumentNull(subName, nameof(subName));
 
             if (subName.Length == 0)
+            {
                 return subName;
+            }
 
             // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the
             // original - if the first character is an invalid first identifier character but a valid subsequent one,
             // we prepend an underscore to it.
-            StringBuilder everettId = new StringBuilder(subName.Length + 1);
+            var everettId = new StringBuilder(subName.Length + 1);
 
             // the first character has stronger restrictions than the rest
             if (!IsValidEverettIdFirstChar(subName[0]))
@@ -333,14 +308,14 @@ private static string MakeValidEverettSubFolderIdentifier(string subName)
         /// </summary>
         internal static string MakeValidEverettFolderIdentifier(string name)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(name, "name");
+            ErrorUtilities.VerifyThrowArgumentNull(name, nameof(name));
 
             // give string length to avoid reallocations; +1 since the resulting string may be one char longer than the
             // original - if the name is a single underscore we add another underscore to it
-            StringBuilder everettId = new StringBuilder(name.Length + 1);
+            var everettId = new StringBuilder(name.Length + 1);
 
             // split folder name into subnames separated by '.', if any
-            string[] subNames = name.Split(new char[] { '.' });
+            string[] subNames = name.Split('.');
 
             // convert each subname separately
             everettId.Append(MakeValidEverettSubFolderIdentifier(subNames[0]));
@@ -353,7 +328,9 @@ internal static string MakeValidEverettFolderIdentifier(string name)
 
             // folder name cannot be a single underscore - add another underscore to it
             if (everettId.ToString() == "_")
+            {
                 everettId.Append('_');
+            }
 
             return everettId.ToString();
         }
@@ -362,16 +339,14 @@ internal static string MakeValidEverettFolderIdentifier(string name)
         /// This method is provided for compatibility with Everett which used to convert parts of resource names into
         /// valid identifiers
         /// </summary>
-        /// <param name="name"></param>
-        /// <returns></returns>
         public static string MakeValidEverettIdentifier(string name)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(name, "name");
+            ErrorUtilities.VerifyThrowArgumentNull(name, nameof(name));
 
-            StringBuilder everettId = new StringBuilder(name.Length);
+            var everettId = new StringBuilder(name.Length);
 
             // split the name into folder names
-            string[] subNames = name.Split(new char[] { Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar });
+            string[] subNames = name.Split(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
 
             // convert every folder name
             everettId.Append(MakeValidEverettFolderIdentifier(subNames[0]));
@@ -387,4 +362,4 @@ public static string MakeValidEverettIdentifier(string name)
 
         #endregion
     }
-}
\ No newline at end of file
+}
diff --git a/src/Tasks/CreateProperty.cs b/src/Tasks/CreateProperty.cs
index e7a55e9f670..2d97dc4b6d0 100644
--- a/src/Tasks/CreateProperty.cs
+++ b/src/Tasks/CreateProperty.cs
@@ -2,14 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
-using System.Diagnostics;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
-using System.Collections;
-using System.Globalization;
-using System.Reflection;
-using System.Resources;
 
 namespace Microsoft.Build.Tasks
 {
@@ -18,8 +11,6 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public class CreateProperty : TaskExtension
     {
-        private string[] _prop;
-
         /// <summary>
         /// The in/out property value.
         /// </summary>
@@ -43,18 +34,7 @@ public class CreateProperty : TaskExtension
         /// that is set to "Clean%3BBuild", which is not what the user wanted.
         /// </remarks>
         [Output]
-        public string[] Value
-        {
-            get
-            {
-                return _prop;
-            }
-
-            set
-            {
-                _prop = value;
-            }
-        }
+        public string[] Value { get; set; }
 
         /// <summary>
         /// This is to fool MSBuild into not doing its little TLDA trick whereby even if 
@@ -66,13 +46,7 @@ public string[] Value
         /// for people who want to know whether a particular target was up-to-date or not.
         /// </summary>
         [Output]
-        public string[] ValueSetByTask
-        {
-            get
-            {
-                return _prop;
-            }
-        }
+        public string[] ValueSetByTask => Value;
 
         /// <summary>
         /// Create the property. Since the input property is the same as the
@@ -81,9 +55,9 @@ public string[] ValueSetByTask
         /// <returns></returns>
         public override bool Execute()
         {
-            if (_prop == null)
+            if (Value == null)
             {
-                _prop = Array.Empty<string>();
+                Value = Array.Empty<string>();
             }
 
             return true;
diff --git a/src/Tasks/CreateVisualBasicManifestResourceName.cs b/src/Tasks/CreateVisualBasicManifestResourceName.cs
index 1399fc12576..8d8a4a60a7b 100644
--- a/src/Tasks/CreateVisualBasicManifestResourceName.cs
+++ b/src/Tasks/CreateVisualBasicManifestResourceName.cs
@@ -4,13 +4,8 @@
 using System;
 using System.IO;
 using System.Text;
-using System.Resources;
-using System.Reflection;
-using System.Diagnostics;
-using System.Globalization;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
 {
@@ -30,7 +25,7 @@ public class CreateVisualBasicManifestResourceName : CreateManifestResourceName
         /// <param name="dependentUponFileName">The file name of the parent of this dependency (usually a .vb file). May be null</param>
         /// <param name="binaryStream">File contents binary stream, may be null</param>
         /// <returns>Returns the manifest name</returns>
-        override protected string CreateManifestName
+        protected override string CreateManifestName
         (
             string fileName,
             string linkFileName,
@@ -39,9 +34,8 @@ override protected string CreateManifestName
             Stream binaryStream // File contents binary stream, may be null
         )
         {
-            ITaskItem item = null;
             string culture = null;
-            if (fileName != null && itemSpecToTaskitem.TryGetValue(fileName, out item))
+            if (fileName != null && itemSpecToTaskitem.TryGetValue(fileName, out ITaskItem item))
             {
                 culture = item.GetMetadata("Culture");
             }
@@ -52,7 +46,7 @@ The reason is that CreateManifestName can't be static because it is an
                 override of a method declared in the base class, but its convenient 
                 to expose a static version anyway for unittesting purposes.
             */
-            return CreateVisualBasicManifestResourceName.CreateManifestNameImpl
+            return CreateManifestNameImpl
             (
                 fileName,
                 linkFileName,
@@ -61,7 +55,7 @@ The reason is that CreateManifestName can't be static because it is an
                 dependentUponFileName,
                 culture,
                 binaryStream,
-                this.Log
+                Log
             );
         }
 
@@ -95,7 +89,7 @@ TaskLoggingHelper log
         {
             // Use the link file name if there is one, otherwise, fall back to file name.
             string embeddedFileName = linkFileName;
-            if (embeddedFileName == null || embeddedFileName.Length == 0)
+            if (string.IsNullOrEmpty(embeddedFileName))
             {
                 embeddedFileName = fileName;
             }
@@ -108,21 +102,21 @@ TaskLoggingHelper log
                 info.culture = culture;
             }
 
-            StringBuilder manifestName = new StringBuilder();
+            var manifestName = new StringBuilder();
             if (binaryStream != null)
             {
                 // Resource depends on a form. Now, get the form's class name fully 
                 // qualified with a namespace.
                 ExtractedClassName result = VisualBasicParserUtilities.GetFirstClassNameFullyQualified(binaryStream);
 
-                if (result.IsInsideConditionalBlock && log != null)
+                if (result.IsInsideConditionalBlock)
                 {
-                    log.LogWarningWithCodeFromResources("CreateManifestResourceName.DefinitionFoundWithinConditionalDirective", dependentUponFileName, embeddedFileName);
+                    log?.LogWarningWithCodeFromResources("CreateManifestResourceName.DefinitionFoundWithinConditionalDirective", dependentUponFileName, embeddedFileName);
                 }
 
-                if (result.Name != null && result.Name.Length > 0)
+                if (!string.IsNullOrEmpty(result.Name))
                 {
-                    if (rootNamespace != null && rootNamespace.Length > 0)
+                    if (!string.IsNullOrEmpty(rootNamespace))
                     {
                         manifestName.Append(rootNamespace).Append(".").Append(result.Name);
                     }
@@ -132,7 +126,7 @@ TaskLoggingHelper log
                     }
 
                     // Append the culture if there is one.        
-                    if (info.culture != null && info.culture.Length > 0)
+                    if (!string.IsNullOrEmpty(info.culture))
                     {
                         manifestName.Append(".").Append(info.culture);
                     }
@@ -145,7 +139,7 @@ TaskLoggingHelper log
             {
                 // If Rootnamespace was null, then it wasn't set from the project resourceFile.
                 // Empty namespaces are allowed.
-                if (rootNamespace != null && rootNamespace.Length > 0)
+                if (!string.IsNullOrEmpty(rootNamespace))
                 {
                     manifestName.Append(rootNamespace).Append(".");
                 }
@@ -163,7 +157,7 @@ TaskLoggingHelper log
                     manifestName.Append(Path.GetFileNameWithoutExtension(info.cultureNeutralFilename));
 
                     // Append the culture if there is one.        
-                    if (info.culture != null && info.culture.Length > 0)
+                    if (!string.IsNullOrEmpty(info.culture))
                     {
                         manifestName.Append(".").Append(info.culture);
                     }
@@ -181,7 +175,7 @@ TaskLoggingHelper log
                     if (prependCultureAsDirectory)
                     {
                         // Prepend the culture as a subdirectory if there is one.        
-                        if (info.culture != null && info.culture.Length > 0)
+                        if (!string.IsNullOrEmpty(info.culture))
                         {
                             manifestName.Insert(0, Path.DirectorySeparatorChar);
                             manifestName.Insert(0, info.culture);
@@ -198,7 +192,7 @@ TaskLoggingHelper log
         /// </summary>
         /// <param name="fileName">Name of the candidate source file.</param>
         /// <returns>True, if this is a validate source file.</returns>
-        override protected bool IsSourceFile(string fileName)
+        protected override bool IsSourceFile(string fileName)
         {
             string extension = Path.GetExtension(fileName);
 
diff --git a/src/Tasks/Culture.cs b/src/Tasks/Culture.cs
index b69c497836f..30b61bd2c5b 100644
--- a/src/Tasks/Culture.cs
+++ b/src/Tasks/Culture.cs
@@ -3,13 +3,6 @@
 
 using System;
 using System.IO;
-using System.Diagnostics;
-using System.Resources;
-using System.Reflection;
-using System.Globalization;
-using System.Collections;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
 {
@@ -33,9 +26,6 @@ internal struct ItemCultureInfo
         /// <remarks>
         /// We've decided to ignore explicit Culture attributes on items.
         /// </remarks>
-        /// <param name="name"></param>
-        /// <param name="dependentUponFileName"></param>
-        /// <returns></returns>
         internal static ItemCultureInfo GetItemCultureInfo
         (
             string name,
@@ -44,7 +34,7 @@ string dependentUponFilename
         {
             ItemCultureInfo info;
             info.culture = null;
-            string parentName = dependentUponFilename == null ? String.Empty : dependentUponFilename;
+            string parentName = dependentUponFilename ?? String.Empty;
 
             if (0 == String.Compare(Path.GetFileNameWithoutExtension(parentName),
                                    Path.GetFileNameWithoutExtension(name),
diff --git a/src/Tasks/CultureInfoCache.cs b/src/Tasks/CultureInfoCache.cs
index c603e7566a6..fa8d6ab35f5 100644
--- a/src/Tasks/CultureInfoCache.cs
+++ b/src/Tasks/CultureInfoCache.cs
@@ -31,7 +31,7 @@ static CultureInfoCache()
             }
 #endif
 
-            foreach (var cultureName in AssemblyUtilities.GetAllCultures())
+            foreach (CultureInfo cultureName in AssemblyUtilities.GetAllCultures())
             {
                 ValidCultureNames.Add(cultureName.Name);
             }
diff --git a/src/Tasks/Delete.cs b/src/Tasks/Delete.cs
index f6f255f81a4..9bbb55ea8ba 100644
--- a/src/Tasks/Delete.cs
+++ b/src/Tasks/Delete.cs
@@ -2,15 +2,11 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
+using System.Collections.Generic;
 using System.IO;
-using System.Resources;
-using System.Reflection;
-using System.Diagnostics;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
-using System.Collections.Generic;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
 {
@@ -21,50 +17,28 @@ public class Delete : TaskExtension, ICancelableTask
     {
         #region Properties
 
-        private ITaskItem[] _files = null;
-        private bool _canceling = false;
+        private ITaskItem[] _files;
+        private bool _canceling;
 
         [Required]
         public ITaskItem[] Files
         {
             get
             {
-                ErrorUtilities.VerifyThrowArgumentNull(_files, "files");
+                ErrorUtilities.VerifyThrowArgumentNull(_files, nameof(Files));
                 return _files;
             }
 
-            set
-            {
-                _files = value;
-            }
+            set => _files = value;
         }
 
-        private bool _treatErrorsAsWarnings = false;
-
         /// <summary>
         /// When true, errors will be logged as warnings.
         /// </summary>
-        public bool TreatErrorsAsWarnings
-        {
-            get { return _treatErrorsAsWarnings; }
-            set { _treatErrorsAsWarnings = value; }
-        }
-
-        private ITaskItem[] _deletedFiles;
+        public bool TreatErrorsAsWarnings { get; set; } = false;
 
         [Output]
-        public ITaskItem[] DeletedFiles
-        {
-            get
-            {
-                return _deletedFiles;
-            }
-            set
-            {
-                _deletedFiles = value;
-            }
-        }
-
+        public ITaskItem[] DeletedFiles { get; set; }
 
         #endregion
 
@@ -83,8 +57,8 @@ public void Cancel()
         /// </summary>
         public override bool Execute()
         {
-            ArrayList deletedFilesList = new ArrayList();
-            HashSet<string> deletedFilesSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+            var deletedFilesList = new List<ITaskItem>();
+            var deletedFilesSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
             foreach (ITaskItem file in Files)
             {
@@ -125,7 +99,7 @@ public override bool Execute()
                 deletedFilesSet.Add(file.ItemSpec);
             }
             // convert the list of deleted files into an array of ITaskItems
-            DeletedFiles = (ITaskItem[])deletedFilesList.ToArray(typeof(ITaskItem));
+            DeletedFiles = deletedFilesList.ToArray();
             return !Log.HasLoggedErrors;
         }
 
@@ -134,7 +108,6 @@ public override bool Execute()
         /// </summary>
         /// <param name="file">The file that wasn't deleted.</param>
         /// <param name="e">The exception.</param>
-        /// <param name="success">Whether the task should return an error.</param>
         private void LogError(ITaskItem file, Exception e)
         {
             if (TreatErrorsAsWarnings)
diff --git a/src/Tasks/Dependencies.cs b/src/Tasks/Dependencies.cs
index 2bf73615808..80761d7464f 100644
--- a/src/Tasks/Dependencies.cs
+++ b/src/Tasks/Dependencies.cs
@@ -29,7 +29,6 @@ internal DependencyFile GetDependencyFile(string filename)
             return (DependencyFile)dependencies[filename];
         }
 
-
         /// <summary>
         /// Add a new dependency file.
         /// </summary>
@@ -41,8 +40,6 @@ internal void AddDependencyFile(string filename, DependencyFile file)
         /// <summary>
         /// Remove new dependency file.
         /// </summary>
-        /// <param name="filename"></param>
-        /// <returns></returns>
         internal void RemoveDependencyFile(string filename)
         {
             dependencies.Remove(filename);
diff --git a/src/Tasks/DependencyFile.cs b/src/Tasks/DependencyFile.cs
index 9e1ede515d7..ce8c8f44f55 100644
--- a/src/Tasks/DependencyFile.cs
+++ b/src/Tasks/DependencyFile.cs
@@ -11,6 +11,8 @@ namespace Microsoft.Build.Tasks
     /// <remarks>
     /// Represents a single input to a compilation-style task.
     /// Keeps track of timestamp for later comparison.
+    /// 
+    /// On-disk serialization format, don't change field names or types or use readonly.
     /// </remarks>
     [Serializable]
     internal class DependencyFile
@@ -27,7 +29,6 @@ internal class DependencyFile
         /// <summary>
         /// The name of the file.
         /// </summary>
-        /// <value></value>
         internal string FileName
         {
             get { return filename; }
@@ -36,7 +37,6 @@ internal string FileName
         /// <summary>
         /// The last-modified timestamp when the class was instantiated.
         /// </summary>
-        /// <value></value>
         internal DateTime LastModified
         {
             get { return lastModified; }
@@ -45,7 +45,6 @@ internal DateTime LastModified
         /// <summary>
         /// Returns true if the file existed when this class was instantiated.
         /// </summary>
-        /// <value></value>
         internal bool Exists
         {
             get { return exists; }
@@ -96,4 +95,4 @@ internal bool HasFileChanged()
             return false;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Tasks/DownloadFile.cs b/src/Tasks/DownloadFile.cs
index 506b4879640..688564d6044 100644
--- a/src/Tasks/DownloadFile.cs
+++ b/src/Tasks/DownloadFile.cs
@@ -1,11 +1,13 @@
-using Microsoft.Build.Framework;
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using System;
 using System.IO;
 using System.Net;
 using System.Net.Http;
 using System.Threading;
-using System.Threading.Tasks;
 using Task = System.Threading.Tasks.Task;
 
 namespace Microsoft.Build.Tasks
@@ -112,11 +114,10 @@ public override bool Execute()
         /// Attempts to download the file.
         /// </summary>
         /// <param name="uri">The parsed <see cref="Uri"/> of the request.</param>
-        /// <param name="filename">The filename to use when downloading the file.</param>
         private void Download(Uri uri)
         {
             // The main reason to use HttpClient vs WebClient is because we can pass a message handler for unit tests to mock
-            using (HttpClient client = new HttpClient(HttpMessageHandler ?? new HttpClientHandler(), disposeHandler: true))
+            using (var client = new HttpClient(HttpMessageHandler ?? new HttpClientHandler(), disposeHandler: true))
             {
                 // Only get the response without downloading the file so we can determine if the file is already up-to-date
                 using (HttpResponseMessage response = client.GetAsync(uri, HttpCompletionOption.ResponseHeadersRead, _cancellationTokenSource.Token)
@@ -135,7 +136,6 @@ private void Download(Uri uri)
                         throw new CustomHttpRequestException(e.Message, e.InnerException, response.StatusCode);
                     }
 
-
                     if (!TryGetFileName(response, out string filename))
                     {
                         Log.LogErrorFromResources("DownloadFile.ErrorUnknownFileName", SourceUrl, nameof(DestinationFileName));
@@ -144,7 +144,7 @@ private void Download(Uri uri)
 
                     DirectoryInfo destinationDirectory = Directory.CreateDirectory(DestinationFolder.ItemSpec);
 
-                    FileInfo destinationFile = new FileInfo(Path.Combine(destinationDirectory.FullName, filename));
+                    var destinationFile = new FileInfo(Path.Combine(destinationDirectory.FullName, filename));
 
                     // The file is considered up-to-date if its the same length.  This could be inaccurate, we can consider alternatives in the future
                     if (ShouldSkip(response, destinationFile))
@@ -158,7 +158,7 @@ private void Download(Uri uri)
 
                     try
                     {
-                        using (FileStream target = new FileStream(destinationFile.FullName, FileMode.Create, FileAccess.Write, FileShare.None))
+                        using (var target = new FileStream(destinationFile.FullName, FileMode.Create, FileAccess.Write, FileShare.None))
                         {
                             Log.LogMessageFromResources(MessageImportance.High, "DownloadFile.Downloading", SourceUrl, destinationFile.FullName, response.Content.Headers.ContentLength);
 
@@ -191,7 +191,7 @@ private void Download(Uri uri)
         /// <param name="exception">The originally thrown exception.</param>
         /// <param name="actualException">The actual exception to be used for logging errors.</param>
         /// <returns><code>true</code> if the exception is retriable, otherwise <code>false</code>.</returns>
-        private bool IsRetriable(Exception exception, out Exception actualException)
+        private static bool IsRetriable(Exception exception, out Exception actualException)
         {
             actualException = exception;
 
@@ -290,7 +290,6 @@ private bool ShouldSkip(HttpResponseMessage response, FileInfo destinationFile)
                    && destinationFile.Length == response.Content.Headers.ContentLength
                    && response.Content.Headers.LastModified.HasValue
                    && destinationFile.LastWriteTimeUtc < response.Content.Headers.LastModified.Value.UtcDateTime;
-
         }
     }
 }
diff --git a/src/Tasks/Exec.cs b/src/Tasks/Exec.cs
index be2734f9bd6..3fd1062ab77 100644
--- a/src/Tasks/Exec.cs
+++ b/src/Tasks/Exec.cs
@@ -339,17 +339,17 @@ protected override bool HandleTaskExecutionErrors()
         {
             if (IgnoreExitCode)
             {
-                Log.LogMessageFromResources(MessageImportance.Normal, "Exec.CommandFailedNoErrorCode", this.Command, ExitCode);
+                Log.LogMessageFromResources(MessageImportance.Normal, "Exec.CommandFailedNoErrorCode", Command, ExitCode);
                 return true;
             }
 
             if (ExitCode == NativeMethods.SE_ERR_ACCESSDENIED)
             {
-                Log.LogErrorWithCodeFromResources("Exec.CommandFailedAccessDenied", this.Command, ExitCode);
+                Log.LogErrorWithCodeFromResources("Exec.CommandFailedAccessDenied", Command, ExitCode);
             }
             else
             {
-                Log.LogErrorWithCodeFromResources("Exec.CommandFailed", this.Command, ExitCode);
+                Log.LogErrorWithCodeFromResources("Exec.CommandFailed", Command, ExitCode);
             }
             return false;
         }
diff --git a/src/Tasks/FileIO/ReadLinesFromFile.cs b/src/Tasks/FileIO/ReadLinesFromFile.cs
index 2d584f8d7df..43ecea0cc01 100644
--- a/src/Tasks/FileIO/ReadLinesFromFile.cs
+++ b/src/Tasks/FileIO/ReadLinesFromFile.cs
@@ -2,11 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
-using System.Collections;
-using System.Diagnostics;
-using System.Globalization;
-
+using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
@@ -18,28 +14,17 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public class ReadLinesFromFile : TaskExtension
     {
-        private ITaskItem _file = null;
-        private ITaskItem[] _lines = Array.Empty<TaskItem>();
-
         /// <summary>
         /// File to read lines from.
         /// </summary>
         [Required]
-        public ITaskItem File
-        {
-            get { return _file; }
-            set { _file = value; }
-        }
+        public ITaskItem File { get; set; }
 
         /// <summary>
         /// Receives lines from file.
         /// </summary>
         [Output]
-        public ITaskItem[] Lines
-        {
-            get { return _lines; }
-            set { _lines = value; }
-        }
+        public ITaskItem[] Lines { get; set; } = Array.Empty<ITaskItem>();
 
         /// <summary>
         /// Execute the task.
@@ -52,13 +37,12 @@ public override bool Execute()
             {
                 if (System.IO.File.Exists(File.ItemSpec))
                 {
-                    string[] textLines = null;
                     try
                     {
-                        textLines = System.IO.File.ReadAllLines(File.ItemSpec);
+                        string[] textLines = System.IO.File.ReadAllLines(File.ItemSpec);
 
-                        ArrayList nonEmptyLines = new ArrayList();
-                        char[] charsToTrim = new char[] { '\0', ' ', '\t' };
+                        var nonEmptyLines = new List<ITaskItem>();
+                        char[] charsToTrim = { '\0', ' ', '\t' };
 
                         foreach (string textLine in textLines)
                         {
@@ -75,28 +59,17 @@ public override bool Execute()
                             }
                         }
 
-                        Lines = (ITaskItem[])nonEmptyLines.ToArray(typeof(ITaskItem));
+                        Lines = nonEmptyLines.ToArray();
                     }
                     catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
                     {
-                        LogError(_file, e, ref success);
+                        Log.LogErrorWithCodeFromResources("ReadLinesFromFile.ErrorOrWarning", File.ItemSpec, e.Message);
+                        success = false;
                     }
                 }
             }
 
             return success;
         }
-
-        /// <summary>
-        /// Log an error.
-        /// </summary>
-        /// <param name="file">The being accessed</param>
-        /// <param name="e">The exception.</param>
-        /// <param name="success">Whether the task should return an error.</param>
-        private void LogError(ITaskItem fileName, Exception e, ref bool success)
-        {
-            Log.LogErrorWithCodeFromResources("ReadLinesFromFile.ErrorOrWarning", fileName.ItemSpec, e.Message);
-            success = false;
-        }
     }
 }
diff --git a/src/Tasks/FileIO/WriteLinesToFile.cs b/src/Tasks/FileIO/WriteLinesToFile.cs
index 88de0ef1b6e..ebcb3bea220 100644
--- a/src/Tasks/FileIO/WriteLinesToFile.cs
+++ b/src/Tasks/FileIO/WriteLinesToFile.cs
@@ -14,11 +14,6 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public class WriteLinesToFile : TaskExtension
     {
-        private ITaskItem _file = null;
-        private ITaskItem[] _lines = null;
-        private bool _overwrite = false;
-        private string _encoding = null;
-
         // Default encoding taken from System.IO.WriteAllText()
         private static readonly Encoding s_defaultEncoding = new UTF8Encoding(false, true);
 
@@ -26,38 +21,22 @@ public class WriteLinesToFile : TaskExtension
         /// File to write lines to.
         /// </summary>
         [Required]
-        public ITaskItem File
-        {
-            get { return _file; }
-            set { _file = value; }
-        }
+        public ITaskItem File { get; set; }
 
         /// <summary>
         /// Write each item as a line in the file.
         /// </summary>
-        public ITaskItem[] Lines
-        {
-            get { return _lines; }
-            set { _lines = value; }
-        }
+        public ITaskItem[] Lines { get; set; }
 
         /// <summary>
         /// If true, overwrite any existing file contents.
         /// </summary>
-        public bool Overwrite
-        {
-            get { return _overwrite; }
-            set { _overwrite = value; }
-        }
+        public bool Overwrite { get; set; }
 
         /// <summary>
         /// If true, overwrite any existing file contents.
         /// </summary>
-        public string Encoding
-        {
-            get { return _encoding; }
-            set { _encoding = value; }
-        }
+        public string Encoding { get; set; }
 
         /// <summary>
         /// If true, the target file specified, if it exists, will be read first to compare against
@@ -66,7 +45,6 @@ public string Encoding
         /// </summary>
         public bool WriteOnlyWhenDifferent { get; set; }
 
-
         /// <summary>
         /// Execute the task.
         /// </summary>
@@ -89,11 +67,11 @@ public override bool Execute()
                 }
 
                 Encoding encoding = s_defaultEncoding;
-                if (_encoding != null)
+                if (Encoding != null)
                 {
                     try
                     {
-                        encoding = System.Text.Encoding.GetEncoding(_encoding);
+                        encoding = System.Text.Encoding.GetEncoding(Encoding);
                     }
                     catch (ArgumentException)
                     {
@@ -153,23 +131,12 @@ public override bool Execute()
                 }
                 catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
                 {
-                    LogError(_file, e, ref success);
+                    Log.LogErrorWithCodeFromResources("WriteLinesToFile.ErrorOrWarning", File.ItemSpec, e.Message);
+                    success = false;
                 }
             }
 
             return success;
         }
-
-        /// <summary>
-        /// Log an error.
-        /// </summary>
-        /// <param name="file">The being accessed</param>
-        /// <param name="e">The exception.</param>
-        /// <param name="success">Whether the task should return an error.</param>
-        private void LogError(ITaskItem fileName, Exception e, ref bool success)
-        {
-            Log.LogErrorWithCodeFromResources("WriteLinesToFile.ErrorOrWarning", fileName.ItemSpec, e.Message);
-            success = false;
-        }
     }
 }
diff --git a/src/Tasks/FindInList.cs b/src/Tasks/FindInList.cs
index 65d07b92b9e..ba1e34b3ea6 100644
--- a/src/Tasks/FindInList.cs
+++ b/src/Tasks/FindInList.cs
@@ -15,15 +15,7 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public class FindInList : TaskExtension
     {
-        // The list to search through
         private ITaskItem[] _list;
-        // Whether to match just the file part, or the full item spec
-        // The item found, if any
-        // The itemspec to find
-        // Whether to match case sensitively
-        // Default is case insensitive
-        // Whether to return the last match
-        // (default is the first match)
 
         /// <summary>
         /// The list to search through
diff --git a/src/Tasks/ListOperators/FindUnderPath.cs b/src/Tasks/ListOperators/FindUnderPath.cs
index eff1901d9c8..876f06a6c9a 100644
--- a/src/Tasks/ListOperators/FindUnderPath.cs
+++ b/src/Tasks/ListOperators/FindUnderPath.cs
@@ -2,10 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-
+using System.Collections.Generic;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -15,68 +13,41 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public class FindUnderPath : TaskExtension
     {
-        private bool _updateToAbsolutePaths = false;
-        private ITaskItem _path = null;
-        private ITaskItem[] _files = Array.Empty<TaskItem>();
-        private ITaskItem[] _inPath = null;
-        private ITaskItem[] _outOfPath = null;
-
         /// <summary>
         /// Filter based on whether items fall under this path or not.
         /// </summary>
         [Required]
-        public ITaskItem Path
-        {
-            get { return _path; }
-            set { _path = value; }
-        }
+        public ITaskItem Path { get; set; }
 
         /// <summary>
         /// Files to consider.
         /// </summary>
-        public ITaskItem[] Files
-        {
-            get { return _files; }
-            set { _files = value; }
-        }
+        public ITaskItem[] Files { get; set; } = Array.Empty<ITaskItem>();
 
         /// <summary>
         /// Set to true if the paths of the output items should be updated to be absolute
         /// </summary>
-        public bool UpdateToAbsolutePaths
-        {
-            get { return _updateToAbsolutePaths; }
-            set { _updateToAbsolutePaths = value; }
-        }
+        public bool UpdateToAbsolutePaths { get; set; }
 
         /// <summary>
         /// Files that were inside of Path.
         /// </summary>
         [Output]
-        public ITaskItem[] InPath
-        {
-            get { return _inPath; }
-            set { _inPath = value; }
-        }
+        public ITaskItem[] InPath { get; set; }
 
         /// <summary>
         /// Files that were outside of Path.
         /// </summary>
         [Output]
-        public ITaskItem[] OutOfPath
-        {
-            get { return _outOfPath; }
-            set { _outOfPath = value; }
-        }
+        public ITaskItem[] OutOfPath { get; set; }
 
         /// <summary>
         /// Execute the task.
         /// </summary>
-        /// <returns></returns>
         public override bool Execute()
         {
-            ArrayList inPathList = new ArrayList();
-            ArrayList outOfPathList = new ArrayList();
+            var inPathList = new List<ITaskItem>();
+            var outOfPathList = new List<ITaskItem>();
 
             string conePath;
 
@@ -84,13 +55,13 @@ public override bool Execute()
             {
                 conePath =
                     OpportunisticIntern.InternStringIfPossible(
-                        System.IO.Path.GetFullPath(FileUtilities.FixFilePath(_path.ItemSpec)));
+                        System.IO.Path.GetFullPath(FileUtilities.FixFilePath(Path.ItemSpec)));
                 conePath = FileUtilities.EnsureTrailingSlash(conePath);
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
                 Log.LogErrorWithCodeFromResources(null, "", 0, 0, 0, 0,
-                    "FindUnderPath.InvalidParameter", "Path", _path.ItemSpec, e.Message);
+                    "FindUnderPath.InvalidParameter", "Path", Path.ItemSpec, e.Message);
                 return false;
             }
 
@@ -120,7 +91,7 @@ public override bool Execute()
                     // If we should use the absolute path, update the item contents
                     // Since ItemSpec, which fullPath comes from, is unescaped, re-escape when setting
                     // item.ItemSpec, since the setter for ItemSpec expects an escaped value. 
-                    if (_updateToAbsolutePaths)
+                    if (UpdateToAbsolutePaths)
                     {
                         item.ItemSpec = EscapingUtilities.Escape(fullPath);
                     }
@@ -133,8 +104,8 @@ public override bool Execute()
                 }
             }
 
-            InPath = (ITaskItem[])inPathList.ToArray(typeof(ITaskItem));
-            OutOfPath = (ITaskItem[])outOfPathList.ToArray(typeof(ITaskItem));
+            InPath = inPathList.ToArray();
+            OutOfPath = outOfPathList.ToArray();
             return true;
         }
     }
diff --git a/src/Tasks/ListOperators/RemoveDuplicates.cs b/src/Tasks/ListOperators/RemoveDuplicates.cs
index 41a576b6179..bdbed517f56 100644
--- a/src/Tasks/ListOperators/RemoveDuplicates.cs
+++ b/src/Tasks/ListOperators/RemoveDuplicates.cs
@@ -17,19 +17,19 @@ public class RemoveDuplicates : TaskExtension
         /// <summary>
         /// The left-hand set of items to be RemoveDuplicatesed from.
         /// </summary>
-        public ITaskItem[] Inputs { get; set; } = Array.Empty<TaskItem>();
+        public ITaskItem[] Inputs { get; set; } = Array.Empty<ITaskItem>();
 
         /// <summary>
         /// List of unique items.
         /// </summary>
         [Output]
-        public ITaskItem[] Filtered { get; set; } = null;
+        public ITaskItem[] Filtered { get; set; }
 
         /// <summary>
         /// True if any duplicate items were found. False otherwise.
         /// </summary>
         [Output]
-        public bool HadAnyDuplicates { get; set; } = false;
+        public bool HadAnyDuplicates { get; set; }
 
         /// <summary>
         /// Execute the task.
diff --git a/src/Tasks/MSBuild.cs b/src/Tasks/MSBuild.cs
index a77a49035cc..dfa14632992 100644
--- a/src/Tasks/MSBuild.cs
+++ b/src/Tasks/MSBuild.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.IO;
-using System.Collections;
 using System.Collections.Generic;
 
 using Microsoft.Build.Framework;
@@ -207,7 +206,7 @@ public override bool Execute()
             }
 
             // Parse the global properties into a hashtable.
-            if (!PropertyParser.GetTableWithEscaping(Log, ResourceUtilities.GetResourceString("General.GlobalProperties"), "Properties", Properties, out Hashtable propertiesTable))
+            if (!PropertyParser.GetTableWithEscaping(Log, ResourceUtilities.GetResourceString("General.GlobalProperties"), "Properties", Properties, out Dictionary<string, string> propertiesTable))
             {
                 return false;
             }
@@ -354,7 +353,7 @@ public override bool Execute()
         /// <summary>
         /// Build projects which have not been skipped. This will be done in parallel
         /// </summary>
-        private bool BuildProjectsInParallel(Hashtable propertiesTable, string[] undefinePropertiesArray, List<string[]> targetLists, bool success, bool[] skipProjects)
+        private bool BuildProjectsInParallel(Dictionary<string, string> propertiesTable, string[] undefinePropertiesArray, List<string[]> targetLists, bool success, bool[] skipProjects)
         {
             // There were some projects that were skipped so we need to recreate the
             // project array with those projects removed
@@ -468,7 +467,7 @@ internal static List<string[]> CreateTargetLists(string[] targets, bool runEachT
         internal static bool ExecuteTargets
             (
             ITaskItem[] projects,
-            Hashtable propertiesTable,
+            Dictionary<string, string> propertiesTable,
             string[] undefineProperties,
             List<string[]> targetLists,
             bool stopOnFirstFailure,
@@ -489,7 +488,7 @@ string toolsVersion
             var projectDirectory = new string[projects.Length];
             var projectNames = new string[projects.Length];
             var toolsVersions = new string[projects.Length];
-            var projectProperties = new IDictionary[projects.Length];
+            var projectProperties = new Dictionary<string, string>[projects.Length];
             var undefinePropertiesPerProject = new IList<string>[projects.Length];
 
             for (int i = 0; i < projectNames.Length; i++)
@@ -511,7 +510,7 @@ string toolsVersion
                     {
                         if (!PropertyParser.GetTableWithEscaping
                              (log, ResourceUtilities.FormatResourceString("General.OverridingProperties", projectNames[i]), "Properties", projects[i].GetMetadata("Properties").Split(';'),
-                              out Hashtable preProjectPropertiesTable)
+                              out Dictionary<string, string> preProjectPropertiesTable)
                            )
                         {
                             return false;
@@ -552,25 +551,25 @@ string toolsVersion
                     {
                         if (!PropertyParser.GetTableWithEscaping
                              (log, ResourceUtilities.FormatResourceString("General.AdditionalProperties", projectNames[i]), "AdditionalProperties", projects[i].GetMetadata("AdditionalProperties").Split(';'),
-                              out Hashtable additionalProjectPropertiesTable)
+                              out Dictionary<string, string> additionalProjectPropertiesTable)
                            )
                         {
                             return false;
                         }
-                        Hashtable combinedTable = new Hashtable(StringComparer.OrdinalIgnoreCase);
+                        var combinedTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                         // First copy in the properties from the global table that not in the additional properties table
                         if (projectProperties[i] != null)
                         {
-                            foreach (DictionaryEntry entry in projectProperties[i])
+                            foreach (KeyValuePair<string, string> entry in projectProperties[i])
                             {
-                                if (!additionalProjectPropertiesTable.Contains(entry.Key))
+                                if (!additionalProjectPropertiesTable.ContainsKey(entry.Key))
                                 {
                                     combinedTable.Add(entry.Key, entry.Value);
                                 }
                             }
                         }
                         // Add all the additional properties
-                        foreach (DictionaryEntry entry in additionalProjectPropertiesTable)
+                        foreach (KeyValuePair<string, string> entry in additionalProjectPropertiesTable)
                         {
                             combinedTable.Add(entry.Key, entry.Value);
                         }
@@ -613,7 +612,7 @@ string toolsVersion
                 {
                     for (int i = 0; i < projects.Length; i++)
                     {
-                        IEnumerable nonNullTargetList = targetList ?? targetOutputsPerProject[i].Keys;
+                        IEnumerable<string> nonNullTargetList = targetList ?? targetOutputsPerProject[i].Keys;
 
                         foreach (string targetName in nonNullTargetList)
                         {
diff --git a/src/Tasks/ManifestUtil/ApplicationIdentity.cs b/src/Tasks/ManifestUtil/ApplicationIdentity.cs
index 4d5ea30979c..6f818452bdc 100644
--- a/src/Tasks/ManifestUtil/ApplicationIdentity.cs
+++ b/src/Tasks/ManifestUtil/ApplicationIdentity.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Globalization;
 using System.Runtime.InteropServices;
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
@@ -26,11 +25,19 @@ public sealed class ApplicationIdentity
         public ApplicationIdentity(string url, string deployManifestPath, string applicationManifestPath)
         {
             if (String.IsNullOrEmpty(url))
-                throw new ArgumentNullException("url");
+            {
+                throw new ArgumentNullException(nameof(url));
+            }
+
             if (String.IsNullOrEmpty(deployManifestPath))
-                throw new ArgumentNullException("deployManifestPath");
+            {
+                throw new ArgumentNullException(nameof(deployManifestPath));
+            }
+
             if (String.IsNullOrEmpty(applicationManifestPath))
-                throw new ArgumentNullException("applicationManifestPath");
+            {
+                throw new ArgumentNullException(nameof(applicationManifestPath));
+            }
             _url = url;
             _deployManifestIdentity = AssemblyIdentity.FromManifest(deployManifestPath);
             _applicationManifestIdentity = AssemblyIdentity.FromManifest(applicationManifestPath);
@@ -40,19 +47,15 @@ public ApplicationIdentity(string url, string deployManifestPath, string applica
         /// Initializes a new instance of the ApplicationIdentity class.
         /// </summary>
         /// <param name="url">The deployment provider URL for the ClickOnce deployment manifest.</param>
-		/// <param name="deployManifestPath">Assembly identity of the ClickOnce deployment manifest.</param>
-		/// <param name="applicationManifestPath">Assembly identity of the ClickOnce application manifest.</param>
+		/// <param name="deployManifestIdentity">Assembly identity of the ClickOnce deployment manifest.</param>
+		/// <param name="applicationManifestIdentity">Assembly identity of the ClickOnce application manifest.</param>
 		public ApplicationIdentity(string url, AssemblyIdentity deployManifestIdentity, AssemblyIdentity applicationManifestIdentity)
         {
             if (String.IsNullOrEmpty(url))
-                throw new ArgumentNullException("url");
-            if (deployManifestIdentity == null)
-                throw new ArgumentNullException("deployManifestIdentity");
-            if (applicationManifestIdentity == null)
-                throw new ArgumentNullException("applicationManifestIdentity");
+                throw new ArgumentNullException(nameof(url));
             _url = url;
-            _deployManifestIdentity = deployManifestIdentity;
-            _applicationManifestIdentity = applicationManifestIdentity;
+            _deployManifestIdentity = deployManifestIdentity ?? throw new ArgumentNullException(nameof(deployManifestIdentity));
+            _applicationManifestIdentity = applicationManifestIdentity ?? throw new ArgumentNullException(nameof(applicationManifestIdentity));
         }
 
         /// <summary>
@@ -72,7 +75,7 @@ public override string ToString()
             {
                 aname = _applicationManifestIdentity.GetFullName(AssemblyIdentity.FullNameFlags.ProcessorArchitecture | AssemblyIdentity.FullNameFlags.Type);
             }
-            return String.Format(CultureInfo.InvariantCulture, "{0}#{1}/{2}", _url, dname, aname);
+            return $"{_url}#{dname}/{aname}";
         }
     }
 }
diff --git a/src/Tasks/ManifestUtil/ApplicationManifest.cs b/src/Tasks/ManifestUtil/ApplicationManifest.cs
index efa007e2395..655ac5b8e9b 100644
--- a/src/Tasks/ManifestUtil/ApplicationManifest.cs
+++ b/src/Tasks/ManifestUtil/ApplicationManifest.cs
@@ -16,35 +16,38 @@ namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
     /// <summary>
     /// Describes a ClickOnce or native Win32 application manifest.
     /// </summary>
+    /// <remarks>
+    /// This is a serialization format, don't remove the private fields.
+    /// </remarks>
     [ComVisible(false)]
     [XmlRoot("ApplicationManifest")]
     public sealed class ApplicationManifest : AssemblyManifest
     {
-        private string _configFile = null;
-        private AssemblyIdentity _entryPointIdentity = null;
-        private AssemblyReference _entryPoint = null;
-        private string _entryPointParameters = null;
-        private string _entryPointPath = null;
-        private string _errorReportUrl = null;
-        private string _iconFile = null;
+        private string _configFile;
+        private AssemblyIdentity _entryPointIdentity;
+        private AssemblyReference _entryPoint;
+        private string _entryPointParameters;
+        private string _entryPointPath;
+        private string _errorReportUrl;
+        private string _iconFile;
         private bool _isClickOnceManifest = true;
-        private string _oSMajor = null;
-        private string _oSMinor = null;
-        private string _oSBuild = null;
-        private string _oSRevision = null;
-        private string _oSSupportUrl = null;
-        private string _oSDescription = null;
-        private TrustInfo _trustInfo = null;
-        private int _maxTargetPath = 0;
-        private bool _hostInBrowser = false;
-        private bool _useApplicationTrust = false;
-        private string _product = null;
-        private string _publisher = null;
-        private string _suiteName = null;
-        private string _supportUrl = null;
+        private string _oSMajor;
+        private string _oSMinor;
+        private string _oSBuild;
+        private string _oSRevision;
+        private string _oSSupportUrl;
+        private string _oSDescription;
+        private TrustInfo _trustInfo;
+        private int _maxTargetPath;
+        private bool _hostInBrowser;
+        private bool _useApplicationTrust;
+        private string _product;
+        private string _publisher;
+        private string _suiteName;
+        private string _supportUrl;
         private FileAssociation[] _fileAssociations;
-        private FileAssociationCollection _fileAssociationList = null;
-        private string _targetFrameworkVersion = null;
+        private FileAssociationCollection _fileAssociationList;
+        private string _targetFrameworkVersion;
 
         /// <summary>
         /// Initializes a new instance of the ApplicationManifest class.
@@ -56,7 +59,6 @@ public ApplicationManifest()
         /// <summary>
         /// Initializes a new instance of the ApplicationManifest class.
         /// </summary>
-        /// <param name="targetFrameworkMoniker"></param>
         public ApplicationManifest(string targetFrameworkVersion)
         {
             _targetFrameworkVersion = targetFrameworkVersion;
@@ -69,8 +71,8 @@ public ApplicationManifest(string targetFrameworkVersion)
         [XmlIgnore]
         public string ConfigFile
         {
-            get { return _configFile; }
-            set { _configFile = value; }
+            get => _configFile;
+            set => _configFile = value;
         }
 
         [XmlIgnore]
@@ -94,8 +96,8 @@ public override AssemblyReference EntryPoint
         [XmlIgnore]
         public string TargetFrameworkVersion
         {
-            get { return _targetFrameworkVersion; }
-            set { _targetFrameworkVersion = value; }
+            get => _targetFrameworkVersion;
+            set => _targetFrameworkVersion = value;
         }
 
         /// <summary>
@@ -105,8 +107,8 @@ public string TargetFrameworkVersion
         [XmlIgnore]
         public string ErrorReportUrl
         {
-            get { return _errorReportUrl; }
-            set { _errorReportUrl = value; }
+            get => _errorReportUrl;
+            set => _errorReportUrl = value;
         }
 
         // Make sure we have a CLR dependency, add it if not...
@@ -115,11 +117,10 @@ private void FixupClrVersion()
             AssemblyReference CLRPlatformAssembly = AssemblyReferences.Find(Constants.CLRPlatformAssemblyName);
             if (CLRPlatformAssembly == null)
             {
-                CLRPlatformAssembly = new AssemblyReference();
-                CLRPlatformAssembly.IsPrerequisite = true;
+                CLRPlatformAssembly = new AssemblyReference { IsPrerequisite = true };
                 AssemblyReferences.Add(CLRPlatformAssembly);
             }
-            if (CLRPlatformAssembly.AssemblyIdentity == null || String.IsNullOrEmpty(CLRPlatformAssembly.AssemblyIdentity.Version))
+            if (String.IsNullOrEmpty(CLRPlatformAssembly.AssemblyIdentity?.Version))
             {
                 CLRPlatformAssembly.AssemblyIdentity = new AssemblyIdentity(Constants.CLRPlatformAssemblyName, Util.GetClrVersion(_targetFrameworkVersion));
             }
@@ -128,7 +129,9 @@ private void FixupClrVersion()
         private void FixupEntryPoint()
         {
             if (_entryPoint == null)
+            {
                 _entryPoint = AssemblyReferences.Find(_entryPointIdentity);
+            }
         }
 
         // WinXP is required if app has any native assembly references or any RegFree COM definitions...
@@ -137,25 +140,26 @@ private bool WinXPRequired
             get
             {
                 foreach (FileReference f in FileReferences)
+                {
                     if (f.ComClasses != null || f.TypeLibs != null || f.ProxyStubs != null)
+                    {
                         return true;
+                    }
+                }
                 foreach (AssemblyReference a in AssemblyReferences)
+                {
                     if (a.ReferenceType == AssemblyReferenceType.NativeAssembly)
+                    {
                         return true;
+                    }
+                }
                 return false;
             }
         }
 
         [XmlIgnore]
-        public FileAssociationCollection FileAssociations
-        {
-            get
-            {
-                if (_fileAssociationList == null)
-                    _fileAssociationList = new FileAssociationCollection(_fileAssociations);
-                return _fileAssociationList;
-            }
-        }
+        public FileAssociationCollection FileAssociations => _fileAssociationList ??
+                                                             (_fileAssociationList = new FileAssociationCollection(_fileAssociations));
 
         /// <summary>
         /// If true, the application will run in IE using WPF's xbap application model.
@@ -163,8 +167,8 @@ public FileAssociationCollection FileAssociations
         [XmlIgnore]
         public bool HostInBrowser
         {
-            get { return _hostInBrowser; }
-            set { _hostInBrowser = value; }
+            get => _hostInBrowser;
+            set => _hostInBrowser = value;
         }
 
         /// <summary>
@@ -176,8 +180,8 @@ public bool HostInBrowser
         [XmlIgnore]
         public string IconFile
         {
-            get { return _iconFile; }
-            set { _iconFile = value; }
+            get => _iconFile;
+            set => _iconFile = value;
         }
 
         /// <summary>
@@ -186,8 +190,8 @@ public string IconFile
         [XmlIgnore]
         public bool IsClickOnceManifest
         {
-            get { return _isClickOnceManifest; }
-            set { _isClickOnceManifest = value; }
+            get => _isClickOnceManifest;
+            set => _isClickOnceManifest = value;
         }
 
 
@@ -201,29 +205,34 @@ public bool IsClickOnceManifest
         [XmlIgnore]
         public int MaxTargetPath
         {
-            get { return _maxTargetPath; }
-            set { _maxTargetPath = value; }
+            get => _maxTargetPath;
+            set => _maxTargetPath = value;
         }
 
         internal override void OnBeforeSave()
         {
             FixupEntryPoint();
             if (_isClickOnceManifest)
+            {
                 FixupClrVersion();
+            }
             base.OnBeforeSave();
-            if (_isClickOnceManifest && AssemblyIdentity != null && String.IsNullOrEmpty(AssemblyIdentity.PublicKeyToken))
+            if (_isClickOnceManifest && AssemblyIdentity != null &&
+                String.IsNullOrEmpty(AssemblyIdentity.PublicKeyToken))
+            {
                 AssemblyIdentity.PublicKeyToken = "0000000000000000";
+            }
             UpdateEntryPoint();
             AssemblyIdentity.Type = "win32"; // Activation on WinXP gold will fail if type="win32" attribute is not present
             if (String.IsNullOrEmpty(OSVersion))
             {
-                if (!WinXPRequired)
-                    OSVersion = Constants.OSVersion_Win9X;
-                else
-                    OSVersion = Constants.OSVersion_WinXP;
+                OSVersion = !WinXPRequired ? Constants.OSVersion_Win9X : Constants.OSVersion_WinXP;
             }
+
             if (_fileAssociationList != null)
+            {
                 _fileAssociations = _fileAssociationList.ToArray();
+            }
         }
 
         /// <summary>
@@ -232,8 +241,8 @@ internal override void OnBeforeSave()
         [XmlIgnore]
         public string OSDescription
         {
-            get { return _oSDescription; }
-            set { _oSDescription = value; }
+            get => _oSDescription;
+            set => _oSDescription = value;
         }
 
         /// <summary>
@@ -242,8 +251,8 @@ public string OSDescription
         [XmlIgnore]
         public string OSSupportUrl
         {
-            get { return _oSSupportUrl; }
-            set { _oSSupportUrl = value; }
+            get => _oSSupportUrl;
+            set => _oSSupportUrl = value;
         }
 
         /// <summary>
@@ -260,10 +269,10 @@ public string OSVersion
             get
             {
                 if (String.IsNullOrEmpty(_oSMajor)) return null;
-                Version v = null;
+                Version v;
                 try
                 {
-                    v = new Version(String.Format(CultureInfo.InvariantCulture, "{0}.{1}.{2}.{3}", _oSMajor, _oSMinor, _oSBuild, _oSRevision));
+                    v = new Version($"{_oSMajor}.{_oSMinor}.{_oSBuild}.{_oSRevision}");
                 }
                 catch (FormatException)
                 {
@@ -284,7 +293,9 @@ public string OSVersion
                 {
                     Version v = new Version(value);
                     if (v.Build < 0 || v.Revision < 0)
+                    {
                         throw new FormatException();
+                    }
                     _oSMajor = v.Major.ToString("G", CultureInfo.InvariantCulture);
                     _oSMinor = v.Minor.ToString("G", CultureInfo.InvariantCulture);
                     _oSBuild = v.Build.ToString("G", CultureInfo.InvariantCulture);
@@ -301,8 +312,8 @@ public string OSVersion
         [XmlIgnore]
         public string Product
         {
-            get { return _product; }
-            set { _product = value; }
+            get => _product;
+            set => _product = value;
         }
 
         /// <summary>
@@ -313,8 +324,8 @@ public string Product
         [XmlIgnore]
         public string Publisher
         {
-            get { return _publisher; }
-            set { _publisher = value; }
+            get => _publisher;
+            set => _publisher = value;
         }
 
         /// <summary>
@@ -324,8 +335,8 @@ public string Publisher
         [XmlIgnore]
         public string SuiteName
         {
-            get { return _suiteName; }
-            set { _suiteName = value; }
+            get => _suiteName;
+            set => _suiteName = value;
         }
 
         /// <summary>
@@ -335,8 +346,8 @@ public string SuiteName
         [XmlIgnore]
         public string SupportUrl
         {
-            get { return _supportUrl; }
-            set { _supportUrl = value; }
+            get => _supportUrl;
+            set => _supportUrl = value;
         }
 
         /// <summary>
@@ -345,8 +356,8 @@ public string SupportUrl
         [XmlIgnore]
         public TrustInfo TrustInfo
         {
-            get { return _trustInfo; }
-            set { _trustInfo = value; }
+            get => _trustInfo;
+            set => _trustInfo = value;
         }
 
         /// <summary>
@@ -355,8 +366,8 @@ public TrustInfo TrustInfo
         [XmlIgnore]
         public bool UseApplicationTrust
         {
-            get { return _useApplicationTrust; }
-            set { _useApplicationTrust = value; }
+            get => _useApplicationTrust;
+            set => _useApplicationTrust = value;
         }
 
         private void UpdateEntryPoint()
@@ -395,8 +406,8 @@ private void ValidateCom()
         {
             int t1 = Environment.TickCount;
             string outputFileName = Path.GetFileName(SourcePath);
-            Dictionary<string, ComInfo> clsidList = new Dictionary<string, ComInfo>();
-            Dictionary<string, ComInfo> tlbidList = new Dictionary<string, ComInfo>();
+            var clsidList = new Dictionary<string, ComInfo>();
+            var tlbidList = new Dictionary<string, ComInfo>();
 
             // Check for duplicate COM definitions in all dependent manifests...
             foreach (AssemblyReference assembly in AssemblyReferences)
@@ -412,17 +423,25 @@ private void ValidateCom()
                             {
                                 string key = comInfo.ClsId.ToLowerInvariant();
                                 if (!clsidList.ContainsKey(key))
+                                {
                                     clsidList.Add(key, comInfo);
+                                }
                                 else
+                                {
                                     OutputMessages.AddErrorMessage("GenerateManifest.DuplicateComDefinition", "clsid", comInfo.ComponentFileName, comInfo.ClsId, comInfo.ManifestFileName, clsidList[key].ManifestFileName);
+                                }
                             }
                             if (!String.IsNullOrEmpty(comInfo.TlbId))
                             {
                                 string key = comInfo.TlbId.ToLowerInvariant();
                                 if (!tlbidList.ContainsKey(key))
+                                {
                                     tlbidList.Add(key, comInfo);
+                                }
                                 else
+                                {
                                     OutputMessages.AddErrorMessage("GenerateManifest.DuplicateComDefinition", "tlbid", comInfo.ComponentFileName, comInfo.TlbId, comInfo.ManifestFileName, tlbidList[key].ManifestFileName);
+                                }
                             }
                         }
                     }
@@ -433,23 +452,35 @@ private void ValidateCom()
             foreach (FileReference file in FileReferences)
             {
                 if (file.ComClasses != null)
+                {
                     foreach (ComClass comClass in file.ComClasses)
                     {
                         string key = comClass.ClsId.ToLowerInvariant();
                         if (!clsidList.ContainsKey(key))
+                        {
                             clsidList.Add(key, new ComInfo(outputFileName, file.TargetPath, comClass.ClsId, null));
+                        }
                         else
+                        {
                             OutputMessages.AddErrorMessage("GenerateManifest.DuplicateComDefinition", "clsid", file.ToString(), comClass.ClsId, outputFileName, clsidList[key].ManifestFileName);
+                        }
                     }
+                }
                 if (file.TypeLibs != null)
+                {
                     foreach (TypeLib typeLib in file.TypeLibs)
                     {
                         string key = typeLib.TlbId.ToLowerInvariant();
                         if (!tlbidList.ContainsKey(key))
+                        {
                             tlbidList.Add(key, new ComInfo(outputFileName, file.TargetPath, null, typeLib.TlbId));
+                        }
                         else
+                        {
                             OutputMessages.AddErrorMessage("GenerateManifest.DuplicateComDefinition", "tlbid", file.ToString(), typeLib.TlbId, outputFileName, tlbidList[key].ManifestFileName);
+                        }
                     }
+                }
             }
 
             Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "GenerateManifest.CheckForComDuplicates t={0}", Environment.TickCount - t1));
@@ -463,11 +494,8 @@ private void ValidateConfig()
 
             if (!TrustInfo.IsFullTrust)
             {
-                XmlDocument document = new XmlDocument();
-
-                XmlReaderSettings xrs = new XmlReaderSettings();
-                xrs.DtdProcessing = DtdProcessing.Ignore;
-
+                var document = new XmlDocument();
+                var xrs = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
                 using (XmlReader xr = XmlReader.Create(configFile.ResolvedPath, xrs))
                 {
                     document.Load(xr);
@@ -475,7 +503,9 @@ private void ValidateConfig()
                 XmlNamespaceManager nsmgr = XmlNamespaces.GetNamespaceManager(document.NameTable);
                 XmlNodeList nodes = document.SelectNodes(XPaths.configBindingRedirect, nsmgr);
                 if (nodes.Count > 0)
+                {
                     OutputMessages.AddWarningMessage("GenerateManifest.ConfigBindingRedirectsWithPartialTrust");
+                }
             }
         }
 
@@ -485,7 +515,9 @@ private void ValidateEntryPoint()
             {
                 bool isCorrectFileType = !String.IsNullOrEmpty(_entryPoint.TargetPath) && _entryPoint.TargetPath.EndsWith(".exe", StringComparison.OrdinalIgnoreCase);
                 if (!isCorrectFileType)
+                {
                     OutputMessages.AddErrorMessage("GenerateManifest.InvalidEntryPoint", _entryPoint.ToString());
+                }
             }
         }
 
@@ -498,7 +530,7 @@ private void ValidateFileAssociations()
                     OutputMessages.AddErrorMessage("GenerateManifest.FileAssociationsCountExceedsMaximum", Constants.MaxFileAssociationsCount.ToString(CultureInfo.CurrentUICulture));
                 }
 
-                Dictionary<string, FileAssociation> usedExtensions = new Dictionary<string, FileAssociation>(StringComparer.OrdinalIgnoreCase);
+                var usedExtensions = new Dictionary<string, FileAssociation>(StringComparer.OrdinalIgnoreCase);
                 foreach (FileAssociation fileAssociation in FileAssociations)
                 {
                     if (string.IsNullOrEmpty(fileAssociation.Extension) ||
@@ -561,8 +593,13 @@ private void ValidateReferencesForNativeApplication()
             foreach (AssemblyReference assembly in AssemblyReferences)
             {
                 // Check that the assembly identity matches the filename for all local dependencies...
-                if (!assembly.IsPrerequisite && !String.Equals(assembly.AssemblyIdentity.Name, Path.GetFileNameWithoutExtension(assembly.TargetPath), StringComparison.OrdinalIgnoreCase))
+                if (!assembly.IsPrerequisite && !String.Equals(
+                        assembly.AssemblyIdentity.Name,
+                        Path.GetFileNameWithoutExtension(assembly.TargetPath),
+                        StringComparison.OrdinalIgnoreCase))
+                {
                     OutputMessages.AddErrorMessage("GenerateManifest.IdentityFileNameMismatch", assembly.ToString(), assembly.AssemblyIdentity.Name, assembly.AssemblyIdentity.Name + Path.GetExtension(assembly.TargetPath));
+                }
             }
         }
 
@@ -570,20 +607,24 @@ private void ValidateReferencesForClickOnceApplication()
         {
             int t1 = Environment.TickCount;
             bool isPartialTrust = !TrustInfo.IsFullTrust;
-            Dictionary<string, NGen<bool>> targetPathList = new Dictionary<string, NGen<bool>>();
+            var targetPathList = new Dictionary<string, NGen<bool>>();
 
             foreach (AssemblyReference assembly in AssemblyReferences)
             {
                 // Check all resolved dependencies for partial trust apps...
                 if (isPartialTrust && (assembly != EntryPoint) && !String.IsNullOrEmpty(assembly.ResolvedPath))
+                {
                     ValidateReferenceForPartialTrust(assembly, TrustInfo);
+                }
 
                 // Check TargetPath for all local dependencies, ignoring any Prerequisites
                 if (!assembly.IsPrerequisite && !String.IsNullOrEmpty(assembly.TargetPath))
                 {
                     // Check target path does not exceed maximum...
                     if (_maxTargetPath > 0 && assembly.TargetPath.Length > _maxTargetPath)
+                    {
                         OutputMessages.AddWarningMessage("GenerateManifest.TargetPathTooLong", assembly.ToString(), _maxTargetPath.ToString(CultureInfo.CurrentCulture));
+                    }
 
                     // Check for two or more items with the same TargetPath...
                     string key = assembly.TargetPath.ToLowerInvariant();
@@ -601,24 +642,32 @@ private void ValidateReferencesForClickOnceApplication()
                 {
                     // Check assembly name does not exceed maximum...
                     if (_maxTargetPath > 0 && assembly.AssemblyIdentity.Name.Length > _maxTargetPath)
+                    {
                         OutputMessages.AddWarningMessage("GenerateManifest.TargetPathTooLong", assembly.AssemblyIdentity.Name, _maxTargetPath.ToString(CultureInfo.CurrentCulture));
+                    }
                 }
 
                 // Check that all prerequisites are strong named...
                 if (assembly.IsPrerequisite && !assembly.AssemblyIdentity.IsStrongName && !assembly.IsVirtual)
+                {
                     OutputMessages.AddErrorMessage("GenerateManifest.PrerequisiteNotSigned", assembly.ToString());
+                }
             }
             foreach (FileReference file in FileReferences)
             {
                 // Check that file is not an assembly...
                 if (!String.IsNullOrEmpty(file.ResolvedPath) && PathUtil.IsAssembly(file.ResolvedPath))
+                {
                     OutputMessages.AddWarningMessage("GenerateManifest.AssemblyAsFile", file.ToString());
+                }
 
                 if (!String.IsNullOrEmpty(file.TargetPath))
                 {
                     // Check target path does not exceed maximum...
                     if (_maxTargetPath > 0 && file.TargetPath.Length > _maxTargetPath)
+                    {
                         OutputMessages.AddWarningMessage("GenerateManifest.TargetPathTooLong", file.TargetPath, _maxTargetPath.ToString(CultureInfo.CurrentCulture));
+                    }
 
                     // Check for two or more items with the same TargetPath...
                     string key = file.TargetPath.ToLowerInvariant();
@@ -639,16 +688,20 @@ private void ValidateReferencesForClickOnceApplication()
         private void ValidateReferenceForPartialTrust(AssemblyReference assembly, TrustInfo trustInfo)
         {
             if (trustInfo.IsFullTrust)
+            {
                 return;
+            }
             string path = assembly.ResolvedPath;
-            AssemblyAttributeFlags flags = new AssemblyAttributeFlags(path);
+            var flags = new AssemblyAttributeFlags(path);
 
             // if it's targeting v2.0 CLR then use the old logic to check for partial trust callers.
-            if (Util.CompareFrameworkVersions(this.TargetFrameworkVersion, Constants.TargetFrameworkVersion35) <= 0)
+            if (Util.CompareFrameworkVersions(TargetFrameworkVersion, Constants.TargetFrameworkVersion35) <= 0)
             {
                 if (assembly.IsPrimary && flags.IsSigned
-                    && !flags.HasAllowPartiallyTrustedCallersAttribute)
+                                       && !flags.HasAllowPartiallyTrustedCallersAttribute)
+                {
                     OutputMessages.AddWarningMessage("GenerateManifest.AllowPartiallyTrustedCallers", Path.GetFileNameWithoutExtension(path));
+                }
             }
             else
             {
@@ -657,19 +710,26 @@ private void ValidateReferenceForPartialTrust(AssemblyReference assembly, TrustI
                     // if the binary is targeting v4.0 and it has the transparent attribute then we may allow partially trusted callers.
                     if (assembly.IsPrimary
                         && !(flags.HasAllowPartiallyTrustedCallersAttribute || flags.HasSecurityTransparentAttribute))
+                    {
                         OutputMessages.AddWarningMessage("GenerateManifest.AllowPartiallyTrustedCallers", Path.GetFileNameWithoutExtension(path));
+                    }
                 }
                 else
                 {
                     // if the binary is targeting v4.0 and it has the transparent attribute then we may allow partially trusted callers.
                     if (assembly.IsPrimary && flags.IsSigned
-                        && !(flags.HasAllowPartiallyTrustedCallersAttribute || flags.HasSecurityTransparentAttribute))
+                                           && !(flags.HasAllowPartiallyTrustedCallersAttribute ||
+                                                flags.HasSecurityTransparentAttribute))
+                    {
                         OutputMessages.AddWarningMessage("GenerateManifest.AllowPartiallyTrustedCallers", Path.GetFileNameWithoutExtension(path));
+                    }
                 }
             }
 
             if (flags.HasPrimaryInteropAssemblyAttribute || flags.HasImportedFromTypeLibAttribute)
+            {
                 OutputMessages.AddWarningMessage("GenerateManifest.UnmanagedCodePermission", Path.GetFileNameWithoutExtension(path));
+            }
         }
 
         #region " XmlSerializer "
@@ -679,8 +739,8 @@ private void ValidateReferenceForPartialTrust(AssemblyReference assembly, TrustI
         [XmlAttribute("ConfigFile")]
         public string XmlConfigFile
         {
-            get { return _configFile; }
-            set { _configFile = value; }
+            get => _configFile;
+            set => _configFile = value;
         }
 
         [Browsable(false)]
@@ -688,8 +748,8 @@ public string XmlConfigFile
         [XmlElement("EntryPointIdentity")]
         public AssemblyIdentity XmlEntryPointIdentity
         {
-            get { return _entryPointIdentity; }
-            set { _entryPointIdentity = value; }
+            get => _entryPointIdentity;
+            set => _entryPointIdentity = value;
         }
 
         [Browsable(false)]
@@ -697,8 +757,8 @@ public AssemblyIdentity XmlEntryPointIdentity
         [XmlAttribute("EntryPointParameters")]
         public string XmlEntryPointParameters
         {
-            get { return _entryPointParameters; }
-            set { _entryPointParameters = value; }
+            get => _entryPointParameters;
+            set => _entryPointParameters = value;
         }
 
         [Browsable(false)]
@@ -706,8 +766,8 @@ public string XmlEntryPointParameters
         [XmlAttribute("EntryPointPath")]
         public string XmlEntryPointPath
         {
-            get { return _entryPointPath; }
-            set { _entryPointPath = value; }
+            get => _entryPointPath;
+            set => _entryPointPath = value;
         }
 
         [Browsable(false)]
@@ -715,8 +775,8 @@ public string XmlEntryPointPath
         [XmlAttribute("ErrorReportUrl")]
         public string XmlErrorReportUrl
         {
-            get { return _errorReportUrl; }
-            set { _errorReportUrl = value; }
+            get => _errorReportUrl;
+            set => _errorReportUrl = value;
         }
 
         [Browsable(false)]
@@ -724,8 +784,8 @@ public string XmlErrorReportUrl
         [XmlArray("FileAssociations")]
         public FileAssociation[] XmlFileAssociations
         {
-            get { return _fileAssociations; }
-            set { _fileAssociations = value; }
+            get => _fileAssociations;
+            set => _fileAssociations = value;
         }
 
         [Browsable(false)]
@@ -733,8 +793,8 @@ public FileAssociation[] XmlFileAssociations
         [XmlAttribute("HostInBrowser")]
         public string XmlHostInBrowser
         {
-            get { return Convert.ToString(_hostInBrowser, CultureInfo.InvariantCulture).ToLowerInvariant(); }
-            set { _hostInBrowser = ConvertUtil.ToBoolean(value); }
+            get => Convert.ToString(_hostInBrowser, CultureInfo.InvariantCulture).ToLowerInvariant();
+            set => _hostInBrowser = ConvertUtil.ToBoolean(value);
         }
 
         [Browsable(false)]
@@ -742,8 +802,8 @@ public string XmlHostInBrowser
         [XmlAttribute("IconFile")]
         public string XmlIconFile
         {
-            get { return _iconFile; }
-            set { _iconFile = value; }
+            get => _iconFile;
+            set => _iconFile = value;
         }
 
         [Browsable(false)]
@@ -751,8 +811,8 @@ public string XmlIconFile
         [XmlAttribute("IsClickOnceManifest")]
         public string XmlIsClickOnceManifest
         {
-            get { return Convert.ToString(_isClickOnceManifest, CultureInfo.InvariantCulture).ToLowerInvariant(); }
-            set { _isClickOnceManifest = ConvertUtil.ToBoolean(value); }
+            get => Convert.ToString(_isClickOnceManifest, CultureInfo.InvariantCulture).ToLowerInvariant();
+            set => _isClickOnceManifest = ConvertUtil.ToBoolean(value);
         }
 
         [Browsable(false)]
@@ -760,8 +820,8 @@ public string XmlIsClickOnceManifest
         [XmlAttribute("OSMajor")]
         public string XmlOSMajor
         {
-            get { return _oSMajor; }
-            set { _oSMajor = value; }
+            get => _oSMajor;
+            set => _oSMajor = value;
         }
 
         [Browsable(false)]
@@ -769,8 +829,8 @@ public string XmlOSMajor
         [XmlAttribute("OSMinor")]
         public string XmlOSMinor
         {
-            get { return _oSMinor; }
-            set { _oSMinor = value; }
+            get => _oSMinor;
+            set => _oSMinor = value;
         }
 
         [Browsable(false)]
@@ -778,8 +838,8 @@ public string XmlOSMinor
         [XmlAttribute("OSBuild")]
         public string XmlOSBuild
         {
-            get { return _oSBuild; }
-            set { _oSBuild = value; }
+            get => _oSBuild;
+            set => _oSBuild = value;
         }
 
         [Browsable(false)]
@@ -787,8 +847,8 @@ public string XmlOSBuild
         [XmlAttribute("OSRevision")]
         public string XmlOSRevision
         {
-            get { return _oSRevision; }
-            set { _oSRevision = value; }
+            get => _oSRevision;
+            set => _oSRevision = value;
         }
 
         [Browsable(false)]
@@ -796,8 +856,8 @@ public string XmlOSRevision
         [XmlAttribute("OSSupportUrl")]
         public string XmlOSSupportUrl
         {
-            get { return _oSSupportUrl; }
-            set { _oSSupportUrl = value; }
+            get => _oSSupportUrl;
+            set => _oSSupportUrl = value;
         }
 
         [Browsable(false)]
@@ -805,8 +865,8 @@ public string XmlOSSupportUrl
         [XmlAttribute("OSDescription")]
         public string XmlOSDescription
         {
-            get { return _oSDescription; }
-            set { _oSDescription = value; }
+            get => _oSDescription;
+            set => _oSDescription = value;
         }
 
         [Browsable(false)]
@@ -814,8 +874,8 @@ public string XmlOSDescription
         [XmlAttribute("Product")]
         public string XmlProduct
         {
-            get { return _product; }
-            set { _product = value; }
+            get => _product;
+            set => _product = value;
         }
 
         [Browsable(false)]
@@ -823,8 +883,8 @@ public string XmlProduct
         [XmlAttribute("Publisher")]
         public string XmlPublisher
         {
-            get { return _publisher; }
-            set { _publisher = value; }
+            get => _publisher;
+            set => _publisher = value;
         }
 
         [Browsable(false)]
@@ -832,8 +892,8 @@ public string XmlPublisher
         [XmlAttribute("SuiteName")]
         public string XmlSuiteName
         {
-            get { return _suiteName; }
-            set { _suiteName = value; }
+            get => _suiteName;
+            set => _suiteName = value;
         }
 
         [Browsable(false)]
@@ -841,8 +901,8 @@ public string XmlSuiteName
         [XmlAttribute("SupportUrl")]
         public string XmlSupportUrl
         {
-            get { return _supportUrl; }
-            set { _supportUrl = value; }
+            get => _supportUrl;
+            set => _supportUrl = value;
         }
 
         [Browsable(false)]
@@ -850,8 +910,8 @@ public string XmlSupportUrl
         [XmlAttribute("UseApplicationTrust")]
         public string XmlUseApplicationTrust
         {
-            get { return Convert.ToString(_useApplicationTrust, CultureInfo.InvariantCulture).ToLowerInvariant(); }
-            set { _useApplicationTrust = ConvertUtil.ToBoolean(value); }
+            get => Convert.ToString(_useApplicationTrust, CultureInfo.InvariantCulture).ToLowerInvariant();
+            set => _useApplicationTrust = ConvertUtil.ToBoolean(value);
         }
 
         #endregion
@@ -864,7 +924,6 @@ private class AssemblyAttributeFlags
             public readonly bool HasPrimaryInteropAssemblyAttribute;
             public readonly bool HasImportedFromTypeLibAttribute;
             public readonly bool HasSecurityTransparentAttribute;
-            public readonly bool HasSecurityRulesAttribute;
 
             public AssemblyAttributeFlags(string path)
             {
@@ -876,7 +935,6 @@ public AssemblyAttributeFlags(string path)
                         HasSecurityTransparentAttribute = r.HasAssemblyAttribute("System.Security.SecurityTransparentAttribute");
                         HasPrimaryInteropAssemblyAttribute = r.HasAssemblyAttribute("System.Runtime.InteropServices.PrimaryInteropAssemblyAttribute");
                         HasImportedFromTypeLibAttribute = r.HasAssemblyAttribute("System.Runtime.InteropServices.ImportedFromTypeLibAttribute");
-                        HasSecurityRulesAttribute = r.HasAssemblyAttribute("System.Security.SecurityRulesAttribute");
                     }
             }
         }
diff --git a/src/Tasks/ManifestUtil/AssemblyIdentity.cs b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
index dddd9fdb459..e17fd0d64da 100644
--- a/src/Tasks/ManifestUtil/AssemblyIdentity.cs
+++ b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
@@ -5,11 +5,9 @@
 using System;
 using System.Collections.Generic;
 using System.ComponentModel;
-using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.IO;
-using System.Reflection;
 using System.Runtime.InteropServices;
 using System.Text;
 using System.Text.RegularExpressions;
@@ -22,6 +20,7 @@ namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
     /// <summary>
     /// Describes the identity of an assembly.
     /// </summary>
+    /// <remarks>This is a serialization format, do not remove or change the private fields.</remarks>
     [ComVisible(false)]
     [XmlRoot("AssemblyIdentity")]
     public sealed class AssemblyIdentity
@@ -50,12 +49,12 @@ public enum FullNameFlags
             All = 0x0003
         }
 
-        private string _name = null;
-        private string _version = null;
-        private string _publicKeyToken = null;
-        private string _culture = null;
-        private string _processorArchitecture = null;
-        private string _type = null;
+        private string _name;
+        private string _version;
+        private string _publicKeyToken;
+        private string _culture;
+        private string _processorArchitecture;
+        private string _type;
 
         /// <summary>
         /// Initializes a new instance of the AssemblyIdentity class.
@@ -181,14 +180,14 @@ public static AssemblyIdentity FromAssemblyName(string assemblyName)
         public static AssemblyIdentity FromManifest(string path)
         {
             if (!File.Exists(path))
+            {
                 return null;
+            }
 
-            XmlDocument document = new XmlDocument();
+            var document = new XmlDocument();
             try
             {
-                XmlReaderSettings readerSettings = new XmlReaderSettings();
-                readerSettings.DtdProcessing = DtdProcessing.Ignore;
-
+                var readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
                 using (XmlReader xmlReader = XmlReader.Create(path, readerSettings))
                 {
                     document.Load(xmlReader);
@@ -204,9 +203,8 @@ public static AssemblyIdentity FromManifest(string path)
 
         private static AssemblyIdentity FromManifest(Stream s)
         {
-            XmlDocument document = new XmlDocument();
-            XmlReaderSettings xrSettings = new XmlReaderSettings();
-            xrSettings.DtdProcessing = DtdProcessing.Ignore;
+            var document = new XmlDocument();
+            var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
             try
             {
                 using (XmlReader xr = XmlReader.Create(s, xrSettings))
@@ -224,22 +222,24 @@ private static AssemblyIdentity FromManifest(Stream s)
         private static AssemblyIdentity FromManifest(XmlDocument document)
         {
             XmlNamespaceManager nsmgr = XmlNamespaces.GetNamespaceManager(document.NameTable);
-            XmlElement element = (XmlElement)document.SelectSingleNode(XPaths.assemblyIdentityPath, nsmgr);
+            var element = (XmlElement)document.SelectSingleNode(XPaths.assemblyIdentityPath, nsmgr);
             if (element == null)
+            {
                 return null;
+            }
 
             XmlNode node = element.Attributes.GetNamedItem("name");
-            string name = node != null ? node.Value : null;
+            string name = node?.Value;
             node = element.Attributes.GetNamedItem("version");
-            string version = node != null ? node.Value : null;
+            string version = node?.Value;
             node = element.Attributes.GetNamedItem("publicKeyToken");
-            string publicKeyToken = node != null ? node.Value : null;
+            string publicKeyToken = node?.Value;
             node = element.Attributes.GetNamedItem("language");
-            string culture = node != null ? node.Value : null;
+            string culture = node?.Value;
             node = element.Attributes.GetNamedItem("processorArchitecture");
-            string processorArchitecture = node != null ? node.Value : null;
+            string processorArchitecture = node?.Value;
             node = element.Attributes.GetNamedItem("type");
-            string type = node != null ? node.Value : null;
+            string type = node?.Value;
             return new AssemblyIdentity(name, version, publicKeyToken, culture, processorArchitecture, type);
         }
 
@@ -253,7 +253,9 @@ private static AssemblyIdentity FromManifest(XmlDocument document)
         public static AssemblyIdentity FromManagedAssembly(string path)
         {
             if (!File.Exists(path))
+            {
                 return null;
+            }
 
             // NOTE: We're not using System.Reflection.AssemblyName class here because we need ProcessorArchitecture
             using (MetadataReader r = MetadataReader.Create(path))
@@ -289,17 +291,20 @@ public static AssemblyIdentity FromManagedAssembly(string path)
         public static AssemblyIdentity FromNativeAssembly(string path)
         {
             if (!File.Exists(path))
+            {
                 return null;
+            }
 
             if (PathUtil.IsPEFile(path))
             {
                 Stream m = EmbeddedManifestReader.Read(path);
                 if (m == null)
+                {
                     return null;
+                }
                 return FromManifest(m);
             }
-            else
-                return FromManifest(path);
+            return FromManifest(path);
         }
 
         /// <summary>
@@ -312,13 +317,11 @@ public static AssemblyIdentity FromNativeAssembly(string path)
         public static AssemblyIdentity FromFile(string path)
         {
             if (!File.Exists(path))
+            {
                 return null;
+            }
 
-            AssemblyIdentity id = null;
-            id = FromNativeAssembly(path); // if there's an xml manifest use that first
-            if (id == null)
-                id = FromManagedAssembly(path); // otherwise fallback to the complib manifest if it's there
-            return id;
+            return FromNativeAssembly(path) ?? FromManagedAssembly(path);
         }
 
         internal static bool IsEqual(AssemblyIdentity a1, AssemblyIdentity a2)
@@ -329,29 +332,25 @@ internal static bool IsEqual(AssemblyIdentity a1, AssemblyIdentity a2)
         internal static bool IsEqual(AssemblyIdentity a1, AssemblyIdentity a2, bool specificVersion)
         {
             if (a1 == null || a2 == null)
+            {
                 return false;
+            }
             if (specificVersion)
+            {
                 return String.Equals(a1._name, a2._name, StringComparison.OrdinalIgnoreCase)
                     && String.Equals(a1._publicKeyToken, a2._publicKeyToken, StringComparison.OrdinalIgnoreCase)
                     && String.Equals(a1._version, a2._version, StringComparison.OrdinalIgnoreCase)
                     && String.Equals(a1._culture, a2._culture, StringComparison.OrdinalIgnoreCase)
                     && String.Equals(a1._processorArchitecture, a2._processorArchitecture, StringComparison.OrdinalIgnoreCase);
-            else
-                return String.Equals(a1._name, a2._name, StringComparison.OrdinalIgnoreCase);
+            }
+            return String.Equals(a1._name, a2._name, StringComparison.OrdinalIgnoreCase);
         }
 
         /// <summary>
         /// Returns true if this assembly is part of the .NET Framework.
         /// </summary>
         [XmlIgnore]
-        public bool IsFrameworkAssembly
-        {
-            get
-            {
-                return IsInFramework(null, null);
-            }
-        }
-
+        public bool IsFrameworkAssembly => IsInFramework(null, null);
 
         /// <summary>
         /// Returns true if this assembly is part of the given framework.
@@ -378,10 +377,10 @@ public bool IsInFramework(string frameworkIdentifier, string frameworkVersion)
 
             if (string.IsNullOrEmpty(frameworkIdentifier) && version != null)
             {
-                throw new ArgumentNullException("frameworkIdentifier");
+                throw new ArgumentNullException(nameof(frameworkIdentifier));
             }
 
-            Dictionary<string, RedistList> redistDictionary = new Dictionary<string, RedistList>();
+            var redistDictionary = new Dictionary<string, RedistList>();
 
             foreach (string moniker in ToolLocationHelper.GetSupportedTargetFrameworks())
             {
@@ -401,11 +400,13 @@ public bool IsInFramework(string frameworkIdentifier, string frameworkVersion)
                 }
             }
 
-            string fullName = GetFullName(AssemblyIdentity.FullNameFlags.Default);
+            string fullName = GetFullName(FullNameFlags.Default);
             foreach (RedistList list in redistDictionary.Values)
             {
                 if (list != null && list.IsFrameworkAssembly(fullName))
+                {
                     return true;
+                }
             }
 
             return false;
@@ -417,8 +418,8 @@ public bool IsInFramework(string frameworkIdentifier, string frameworkVersion)
         [XmlIgnore]
         public string Culture
         {
-            get { return _culture; }
-            set { _culture = value; }
+            get => _culture;
+            set => _culture = value;
         }
 
         /// <summary>
@@ -428,18 +429,27 @@ public string Culture
         /// <returns>A string representation of the full name.</returns>
         public string GetFullName(FullNameFlags flags)
         {
-            StringBuilder sb = new StringBuilder();
-            sb.Append(_name);
+            var sb = new StringBuilder(_name);
             if (!String.IsNullOrEmpty(_version))
+            {
                 sb.Append(String.Format(CultureInfo.InvariantCulture, ", Version={0}", _version));
+            }
             if (!String.IsNullOrEmpty(_culture))
+            {
                 sb.Append(String.Format(CultureInfo.InvariantCulture, ", Culture={0}", _culture));
+            }
             if (!String.IsNullOrEmpty(_publicKeyToken))
+            {
                 sb.Append(String.Format(CultureInfo.InvariantCulture, ", PublicKeyToken={0}", _publicKeyToken));
+            }
             if (!String.IsNullOrEmpty(_processorArchitecture) && (flags & FullNameFlags.ProcessorArchitecture) != 0)
+            {
                 sb.Append(String.Format(CultureInfo.InvariantCulture, ", ProcessorArchitecture={0}", _processorArchitecture));
+            }
             if (!String.IsNullOrEmpty(_type) && (flags & FullNameFlags.Type) != 0)
+            {
                 sb.Append(String.Format(CultureInfo.InvariantCulture, ", Type={0}", _type));
+            }
             return sb.ToString();
         }
 
@@ -447,24 +457,15 @@ public string GetFullName(FullNameFlags flags)
         /// Specifies whether the assembly identity represents a neutral platform assembly.
         /// </summary>
         [XmlIgnore]
-        public bool IsNeutralPlatform
-        {
-            get { return String.IsNullOrEmpty(_processorArchitecture) || String.Equals(_processorArchitecture, "msil", StringComparison.OrdinalIgnoreCase); }
-        }
+        public bool IsNeutralPlatform => String.IsNullOrEmpty(_processorArchitecture) || String.Equals(_processorArchitecture, "msil", StringComparison.OrdinalIgnoreCase);
 
         /// <summary>
         /// Specifies whether the assembly identity is a strong name.
         /// </summary>
         [XmlIgnore]
-        public bool IsStrongName
-        {
-            get
-            {
-                return !String.IsNullOrEmpty(_name)
-                    && !String.IsNullOrEmpty(_version)
-                    && !String.IsNullOrEmpty(_publicKeyToken);
-            }
-        }
+        public bool IsStrongName => !String.IsNullOrEmpty(_name)
+                                    && !String.IsNullOrEmpty(_version)
+                                    && !String.IsNullOrEmpty(_publicKeyToken);
 
         /// <summary>
         /// Specifies the simple name of the assembly.
@@ -472,8 +473,8 @@ public bool IsStrongName
         [XmlIgnore]
         public string Name
         {
-            get { return _name; }
-            set { _name = value; }
+            get => _name;
+            set => _name = value;
         }
 
         /// <summary>
@@ -482,8 +483,8 @@ public string Name
         [XmlIgnore]
         public string ProcessorArchitecture
         {
-            get { return _processorArchitecture; }
-            set { _processorArchitecture = value; }
+            get => _processorArchitecture;
+            set => _processorArchitecture = value;
         }
 
         /// <summary>
@@ -492,8 +493,8 @@ public string ProcessorArchitecture
         [XmlIgnore]
         public string PublicKeyToken
         {
-            get { return _publicKeyToken; }
-            set { _publicKeyToken = value; }
+            get => _publicKeyToken;
+            set => _publicKeyToken = value;
         }
 
         internal string Resolve(string[] searchPaths)
@@ -504,19 +505,25 @@ internal string Resolve(string[] searchPaths)
         internal string Resolve(string[] searchPaths, bool specificVersion)
         {
             if (searchPaths == null)
-                searchPaths = new string[] { ".\\" };
+            {
+                searchPaths = new[] { ".\\" };
+            }
 
             foreach (string searchPath in searchPaths)
             {
                 string file = String.Format(CultureInfo.InvariantCulture, "{0}.dll", _name);
                 string path = Path.Combine(searchPath, file);
-                if (File.Exists(path) && AssemblyIdentity.IsEqual(this, AssemblyIdentity.FromFile(path), specificVersion))
+                if (File.Exists(path) && IsEqual(this, FromFile(path), specificVersion))
+                {
                     return path;
+                }
 
                 file = String.Format(CultureInfo.InvariantCulture, "{0}.manifest", _name);
                 path = Path.Combine(searchPath, file);
-                if (File.Exists(path) && AssemblyIdentity.IsEqual(this, AssemblyIdentity.FromManifest(path), specificVersion))
+                if (File.Exists(path) && IsEqual(this, FromManifest(path), specificVersion))
+                {
                     return path;
+                }
             }
 
             return null;
@@ -533,8 +540,8 @@ public override string ToString()
         [XmlIgnore]
         public string Type
         {
-            get { return _type; }
-            set { _type = value; }
+            get => _type;
+            set => _type = value;
         }
 
         /// <summary>
@@ -543,8 +550,8 @@ public string Type
         [XmlIgnore]
         public string Version
         {
-            get { return _version; }
-            set { _version = value; }
+            get => _version;
+            set => _version = value;
         }
 
         #region " XmlSerializer "
@@ -554,8 +561,8 @@ public string Version
         [XmlAttribute("Name")]
         public string XmlName
         {
-            get { return _name; }
-            set { _name = value; }
+            get => _name;
+            set => _name = value;
         }
 
         [Browsable(false)]
@@ -563,8 +570,8 @@ public string XmlName
         [XmlAttribute("Version")]
         public string XmlVersion
         {
-            get { return _version; }
-            set { _version = value; }
+            get => _version;
+            set => _version = value;
         }
 
         [Browsable(false)]
@@ -572,8 +579,8 @@ public string XmlVersion
         [XmlAttribute("PublicKeyToken")]
         public string XmlPublicKeyToken
         {
-            get { return _publicKeyToken; }
-            set { _publicKeyToken = value; }
+            get => _publicKeyToken;
+            set => _publicKeyToken = value;
         }
 
         [Browsable(false)]
@@ -581,8 +588,8 @@ public string XmlPublicKeyToken
         [XmlAttribute("Culture")]
         public string XmlCulture
         {
-            get { return _culture; }
-            set { _culture = value; }
+            get => _culture;
+            set => _culture = value;
         }
 
         [Browsable(false)]
@@ -590,8 +597,8 @@ public string XmlCulture
         [XmlAttribute("ProcessorArchitecture")]
         public string XmlProcessorArchitecture
         {
-            get { return _processorArchitecture; }
-            set { _processorArchitecture = value; }
+            get => _processorArchitecture;
+            set => _processorArchitecture = value;
         }
 
         [Browsable(false)]
@@ -599,8 +606,8 @@ public string XmlProcessorArchitecture
         [XmlAttribute("Type")]
         public string XmlType
         {
-            get { return _type; }
-            set { _type = value; }
+            get => _type;
+            set => _type = value;
         }
 
         #endregion
diff --git a/src/Tasks/ManifestUtil/AssemblyManifest.cs b/src/Tasks/ManifestUtil/AssemblyManifest.cs
index fb39281c90d..59a331a30a1 100644
--- a/src/Tasks/ManifestUtil/AssemblyManifest.cs
+++ b/src/Tasks/ManifestUtil/AssemblyManifest.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.ComponentModel;
 using System.Runtime.InteropServices;
 using System.Xml.Serialization;
@@ -11,27 +10,18 @@ namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
     /// <summary>
     /// Describes a Win32 assembly manifest.
     /// </summary>
+    /// <remarks>This is a serialization format, do not remove or rename private fields.</remarks>
     [ComVisible(false)]
     [XmlRoot("AssemblyManifest")]
     public class AssemblyManifest : Manifest
     {
-        private ProxyStub[] _externalProxyStubs = null;
-
-        /// <summary>
-        /// Initializes a new instance of the AssemblyManifest class.
-        /// </summary>
-        public AssemblyManifest()
-        {
-        }
+        private ProxyStub[] _externalProxyStubs;
 
         /// <summary>
         /// Specifies the set of external proxy stubs referenced by the manifest for isolated applications and Reg-Free COM.
         /// </summary>
         [XmlIgnore]
-        public ProxyStub[] ExternalProxyStubs
-        {
-            get { return _externalProxyStubs; }
-        }
+        public ProxyStub[] ExternalProxyStubs => _externalProxyStubs;
 
         #region " XmlSerializer "
 
@@ -40,8 +30,8 @@ public ProxyStub[] ExternalProxyStubs
         [XmlArray("ExternalProxyStubs")]
         public ProxyStub[] XmlExternalProxyStubs
         {
-            get { return _externalProxyStubs; }
-            set { _externalProxyStubs = value; }
+            get => _externalProxyStubs;
+            set => _externalProxyStubs = value;
         }
 
         #endregion
diff --git a/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs b/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs
index 774e77e6e09..e09397b053a 100644
--- a/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs
+++ b/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Runtime.InteropServices;
 using System.Collections;
+using System.Collections.Generic;
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
 {
@@ -13,12 +14,14 @@ namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
     [ComVisible(false)]
     public sealed class AssemblyReferenceCollection : IEnumerable
     {
-        private ArrayList _list = new ArrayList();
+        private readonly List<AssemblyReference> _list = new List<AssemblyReference>();
 
         internal AssemblyReferenceCollection(AssemblyReference[] array)
         {
             if (array == null)
+            {
                 return;
+            }
             _list.AddRange(array);
         }
 
@@ -27,10 +30,7 @@ internal AssemblyReferenceCollection(AssemblyReference[] array)
         /// </summary>
         /// <param name="index">The zero-based index of the entry to get.</param>
         /// <returns>The assembly reference instance.</returns>
-        public AssemblyReference this[int index]
-        {
-            get { return (AssemblyReference)_list[index]; }
-        }
+        public AssemblyReference this[int index] => _list[index];
 
         /// <summary>
         /// Adds the specified assembly reference to the collection.
@@ -64,10 +64,7 @@ public void Clear()
         /// <summary>
         /// Gets the number of objects contained in the collection.
         /// </summary>
-        public int Count
-        {
-            get { return _list.Count; }
-        }
+        public int Count => _list.Count;
 
         /// <summary>
         /// Finds an assembly reference in the collection by simple name.
@@ -77,10 +74,19 @@ public int Count
         public AssemblyReference Find(string name)
         {
             if (String.IsNullOrEmpty(name))
+            {
                 return null;
+            }
             foreach (AssemblyReference a in _list)
-                if (a.AssemblyIdentity != null && String.Compare(name, a.AssemblyIdentity.Name, StringComparison.OrdinalIgnoreCase) == 0)
+            {
+                if (a.AssemblyIdentity != null && String.Compare(
+                        name,
+                        a.AssemblyIdentity.Name,
+                        StringComparison.OrdinalIgnoreCase) == 0)
+                {
                     return a;
+                }
+            }
             return null;
         }
 
@@ -92,7 +98,9 @@ public AssemblyReference Find(string name)
         public AssemblyReference Find(AssemblyIdentity identity)
         {
             if (identity == null)
+            {
                 return null;
+            }
 
             foreach (AssemblyReference a in _list)
             {
@@ -143,10 +151,16 @@ public AssemblyReference Find(AssemblyIdentity identity)
         public AssemblyReference FindTargetPath(string targetPath)
         {
             if (String.IsNullOrEmpty(targetPath))
+            {
                 return null;
+            }
             foreach (AssemblyReference a in _list)
+            {
                 if (String.Compare(targetPath, a.TargetPath, StringComparison.OrdinalIgnoreCase) == 0)
+                {
                     return a;
+                }
+            }
             return null;
         }
 
@@ -170,7 +184,7 @@ public void Remove(AssemblyReference assemblyReference)
 
         internal AssemblyReference[] ToArray()
         {
-            return (AssemblyReference[])_list.ToArray(typeof(AssemblyReference));
+            return _list.ToArray();
         }
     }
 }
diff --git a/src/Tasks/ManifestUtil/BaseReference.cs b/src/Tasks/ManifestUtil/BaseReference.cs
index 35c98a9724d..c75dae4bc1a 100644
--- a/src/Tasks/ManifestUtil/BaseReference.cs
+++ b/src/Tasks/ManifestUtil/BaseReference.cs
@@ -13,18 +13,19 @@ namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
     /// <summary>
     /// Describes base functionality common to both file and assembly references.
     /// </summary>
+    /// <remarks>Note derived classes are serialization formats. Do not rename or remove private members.</remarks>
     [ComVisible(false)]
     public abstract class BaseReference
     {
         private bool _includeHash = true;
-        private string _group = null;
-        private string _hash = null;
-        private string _hashAlgorithm = null;
-        private string _isOptional = null;
-        private string _resolvedPath = null;
-        private string _size = null;
-        private string _sourcePath = null;
-        private string _targetPath = null;
+        private string _group;
+        private string _hash;
+        private string _hashAlgorithm;
+        private string _isOptional;
+        private string _resolvedPath;
+        private string _size;
+        private string _sourcePath;
+        private string _targetPath;
 
         protected internal BaseReference() // only internal classes can extend this class
         {
@@ -39,21 +40,27 @@ protected internal BaseReference(string path) // only internal classes can exten
         internal static string GetDefaultTargetPath(string path)
         {
             if (String.IsNullOrEmpty(path))
+            {
                 return path;
+            }
 
             if (path.EndsWith(Constants.DeployFileExtension, StringComparison.OrdinalIgnoreCase))
+            {
                 path = path.Substring(0, path.Length - Constants.DeployFileExtension.Length);
+            }
 
             if (!Path.IsPathRooted(path))
+            {
                 return path;
-            else
-                return Path.GetFileName(path);
+            }
+
+            return Path.GetFileName(path);
         }
 
         internal bool IncludeHash
         {
-            get { return _includeHash; }
-            set { _includeHash = value; }
+            get => _includeHash;
+            set => _includeHash = value;
         }
 
         /// <summary>
@@ -62,8 +69,8 @@ internal bool IncludeHash
         [XmlIgnore]
         public string Group
         {
-            get { return _group; }
-            set { _group = value; }
+            get => _group;
+            set => _group = value;
         }
 
         /// <summary>
@@ -75,10 +82,12 @@ public string Hash
             get
             {
                 if (!IncludeHash)
+                {
                     return string.Empty;
+                }
                 return _hash;
             }
-            set { _hash = value; }
+            set => _hash = value;
         }
 
         /// <summary>
@@ -87,8 +96,9 @@ public string Hash
         [XmlIgnore]
         public bool IsOptional
         {
-            get { return ConvertUtil.ToBoolean(_isOptional); }
-            set { _isOptional = value ? "true" : null; } // NOTE: optional=false is implied, and Fusion prefers them to be unspecified
+            get => ConvertUtil.ToBoolean(_isOptional);
+            set => _isOptional = value ? "true" : null;
+            // NOTE: optional=false is implied, and Fusion prefers them to be unspecified
         }
 
         /// <summary>
@@ -97,8 +107,8 @@ public bool IsOptional
         [XmlIgnore]
         public string ResolvedPath
         {
-            get { return _resolvedPath; }
-            set { _resolvedPath = value; }
+            get => _resolvedPath;
+            set => _resolvedPath = value;
         }
 
         /// <summary>
@@ -107,8 +117,8 @@ public string ResolvedPath
         [XmlIgnore]
         public long Size
         {
-            get { return Convert.ToInt64(_size, CultureInfo.InvariantCulture); }
-            set { _size = Convert.ToString(value, CultureInfo.InvariantCulture); }
+            get => Convert.ToInt64(_size, CultureInfo.InvariantCulture);
+            set => _size = Convert.ToString(value, CultureInfo.InvariantCulture);
         }
 
         protected internal abstract string SortName { get; }
@@ -119,8 +129,8 @@ public long Size
         [XmlIgnore]
         public string SourcePath
         {
-            get { return _sourcePath; }
-            set { _sourcePath = value; }
+            get => _sourcePath;
+            set => _sourcePath = value;
         }
 
         /// <summary>
@@ -129,18 +139,26 @@ public string SourcePath
         [XmlIgnore]
         public string TargetPath
         {
-            get { return _targetPath; }
-            set { _targetPath = value; }
+            get => _targetPath;
+            set => _targetPath = value;
         }
 
         public override string ToString()
         {
             if (!String.IsNullOrEmpty(_sourcePath))
+            {
                 return _sourcePath;
+            }
+
             if (!String.IsNullOrEmpty(_resolvedPath))
+            {
                 return _resolvedPath;
+            }
+
             if (!String.IsNullOrEmpty(_targetPath))
+            {
                 return _targetPath;
+            }
             return String.Empty;
         }
 
@@ -151,8 +169,8 @@ public override string ToString()
         [XmlAttribute("Group")]
         public string XmlGroup
         {
-            get { return _group; }
-            set { _group = value; }
+            get => _group;
+            set => _group = value;
         }
 
         [Browsable(false)]
@@ -160,8 +178,8 @@ public string XmlGroup
         [XmlAttribute("Hash")]
         public string XmlHash
         {
-            get { return Hash; }
-            set { _hash = value; }
+            get => Hash;
+            set => _hash = value;
         }
 
         [Browsable(false)]
@@ -169,8 +187,8 @@ public string XmlHash
         [XmlAttribute("HashAlg")]
         public string XmlHashAlgorithm
         {
-            get { return _hashAlgorithm; }
-            set { _hashAlgorithm = value; }
+            get => _hashAlgorithm;
+            set => _hashAlgorithm = value;
         }
 
         [Browsable(false)]
@@ -178,8 +196,8 @@ public string XmlHashAlgorithm
         [XmlAttribute("IsOptional")]
         public string XmlIsOptional
         {
-            get { return _isOptional != null ? _isOptional.ToLower(CultureInfo.InvariantCulture) : null; }
-            set { _isOptional = value; }
+            get => _isOptional?.ToLower(CultureInfo.InvariantCulture);
+            set => _isOptional = value;
         }
 
         [Browsable(false)]
@@ -187,8 +205,8 @@ public string XmlIsOptional
         [XmlAttribute("Path")]
         public string XmlPath
         {
-            get { return _targetPath; }
-            set { _targetPath = value; }
+            get => _targetPath;
+            set => _targetPath = value;
         }
 
         [Browsable(false)]
@@ -196,8 +214,8 @@ public string XmlPath
         [XmlAttribute("Size")]
         public string XmlSize
         {
-            get { return _size; }
-            set { _size = value; }
+            get => _size;
+            set => _size = value;
         }
 
         #endregion
diff --git a/src/Tasks/ManifestUtil/CngLightup.cs b/src/Tasks/ManifestUtil/CngLightup.cs
index bee2d154612..d89603de45a 100644
--- a/src/Tasks/ManifestUtil/CngLightup.cs
+++ b/src/Tasks/ManifestUtil/CngLightup.cs
@@ -174,9 +174,7 @@ internal static byte[] Pkcs1SignData(RSA rsa, byte[] data, string hashAlgorithmN
         {
             // Because RSACryptoServiceProvider existed in 4.5, but RSACng didn't, and RSA's SignData
             // method requires types that aren't in 4.5, try RSACryptoServiceProvider's way first.
-            RSACryptoServiceProvider rsaCsp = rsa as RSACryptoServiceProvider;
-
-            if (rsaCsp != null)
+            if (rsa is RSACryptoServiceProvider rsaCsp)
             {
                 return rsaCsp.SignData(data, hashAlgorithmName);
             }
@@ -231,9 +229,7 @@ internal static bool Pkcs1VerifyData(RSA rsa, byte[] data, byte[] signature, str
         {
             // Because RSACryptoServiceProvider existed in 4.5, but RSACng didn't, and RSA's SignData
             // method requires types that aren't in 4.5, try RSACryptoServiceProvider's way first.
-            RSACryptoServiceProvider rsaCsp = rsa as RSACryptoServiceProvider;
-
-            if (rsaCsp != null)
+            if (rsa is RSACryptoServiceProvider rsaCsp)
             {
                 return rsaCsp.VerifyData(data, hashAlgorithmName, signature);
             }
@@ -299,9 +295,7 @@ internal static byte[] Pkcs1Encrypt(RSA rsa, byte[] data)
         {
             // Because RSACryptoServiceProvider existed in 4.5, but RSACng didn't, and RSA's Encrypt
             // method requires types that aren't in 4.5, try RSACryptoServiceProvider's way first.
-            RSACryptoServiceProvider rsaCsp = rsa as RSACryptoServiceProvider;
-
-            if (rsaCsp != null)
+            if (rsa is RSACryptoServiceProvider rsaCsp)
             {
                 return rsaCsp.Encrypt(data, false);
             }
@@ -313,10 +307,7 @@ internal static byte[] Pkcs1Encrypt(RSA rsa, byte[] data)
                 Delegate openDelegate = BindRsaCryptMethod("Encrypt");
 
                 s_rsaPkcs1EncryptMethod =
-                    (delegateRsa, delegateData) =>
-                    {
-                        return (byte[])openDelegate.DynamicInvoke(delegateRsa, delegateData, s_pkcs1EncryptionPadding);
-                    };
+                    (delegateRsa, delegateData) => (byte[])openDelegate.DynamicInvoke(delegateRsa, delegateData, s_pkcs1EncryptionPadding);
             }
 
             Debug.Assert(s_rsaPkcs1EncryptMethod != null);
@@ -327,9 +318,7 @@ internal static byte[] Pkcs1Decrypt(RSA rsa, byte[] data)
         {
             // Because RSACryptoServiceProvider existed in 4.5, but RSACng didn't, and RSA's Decrypt
             // method requires types that aren't in 4.5, try RSACryptoServiceProvider's way first.
-            RSACryptoServiceProvider rsaCsp = rsa as RSACryptoServiceProvider;
-
-            if (rsaCsp != null)
+            if (rsa is RSACryptoServiceProvider rsaCsp)
             {
                 return rsaCsp.Decrypt(data, false);
             }
@@ -341,10 +330,7 @@ internal static byte[] Pkcs1Decrypt(RSA rsa, byte[] data)
                 Delegate openDelegate = BindRsaCryptMethod("Decrypt");
 
                 s_rsaPkcs1DecryptMethod =
-                    (delegateRsa, delegateData) =>
-                    {
-                        return (byte[])openDelegate.DynamicInvoke(delegateRsa, delegateData, s_pkcs1EncryptionPadding);
-                    };
+                    (delegateRsa, delegateData) => (byte[])openDelegate.DynamicInvoke(delegateRsa, delegateData, s_pkcs1EncryptionPadding);
             }
 
             Debug.Assert(s_rsaPkcs1DecryptMethod != null);
@@ -355,9 +341,8 @@ internal static byte[] OaepSha1Encrypt(RSA rsa, byte[] data)
         {
             // Because RSACryptoServiceProvider existed in 4.5, but RSACng didn't, and RSA's Encrypt
             // method requires types that aren't in 4.5, try RSACryptoServiceProvider's way first.
-            RSACryptoServiceProvider rsaCsp = rsa as RSACryptoServiceProvider;
 
-            if (rsaCsp != null)
+            if (rsa is RSACryptoServiceProvider rsaCsp)
             {
                 return rsaCsp.Encrypt(data, true);
             }
@@ -369,10 +354,7 @@ internal static byte[] OaepSha1Encrypt(RSA rsa, byte[] data)
                 Delegate openDelegate = BindRsaCryptMethod("Encrypt");
 
                 s_rsaOaepSha1EncryptMethod =
-                    (delegateRsa, delegateData) =>
-                    {
-                        return (byte[])openDelegate.DynamicInvoke(delegateRsa, delegateData, s_oaepSha1EncryptionPadding);
-                    };
+                    (delegateRsa, delegateData) => (byte[])openDelegate.DynamicInvoke(delegateRsa, delegateData, s_oaepSha1EncryptionPadding);
             }
 
             Debug.Assert(s_rsaOaepSha1EncryptMethod != null);
@@ -383,9 +365,7 @@ internal static byte[] OaepSha1Decrypt(RSA rsa, byte[] data)
         {
             // Because RSACryptoServiceProvider existed in 4.5, but RSACng didn't, and RSA's Decrypt
             // method requires types that aren't in 4.5, try RSACryptoServiceProvider's way first.
-            RSACryptoServiceProvider rsaCsp = rsa as RSACryptoServiceProvider;
-
-            if (rsaCsp != null)
+            if (rsa is RSACryptoServiceProvider rsaCsp)
             {
                 return rsaCsp.Decrypt(data, true);
             }
@@ -397,10 +377,7 @@ internal static byte[] OaepSha1Decrypt(RSA rsa, byte[] data)
                 Delegate openDelegate = BindRsaCryptMethod("Decrypt");
 
                 s_rsaOaepSha1DecryptMethod =
-                    (delegateRsa, delegateData) =>
-                    {
-                        return (byte[])openDelegate.DynamicInvoke(delegateRsa, delegateData, s_oaepSha1EncryptionPadding);
-                    };
+                    (delegateRsa, delegateData) => (byte[])openDelegate.DynamicInvoke(delegateRsa, delegateData, s_oaepSha1EncryptionPadding);
             }
 
             Debug.Assert(s_rsaOaepSha1DecryptMethod != null);
diff --git a/src/Tasks/ManifestUtil/ComImporter.cs b/src/Tasks/ManifestUtil/ComImporter.cs
index 2f60fd1390d..1f4766a09dc 100644
--- a/src/Tasks/ManifestUtil/ComImporter.cs
+++ b/src/Tasks/ManifestUtil/ComImporter.cs
@@ -3,8 +3,6 @@
 
 using Microsoft.Win32;
 using System;
-using System.IO;
-using System.Collections;
 using System.Collections.Generic;
 using System.Globalization;
 using System.Resources;
@@ -14,21 +12,18 @@ namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
 {
     internal class ComImporter
     {
-        private readonly TypeLib _typeLib;
-        private readonly ComClass[] _comClasses;
         private readonly OutputMessageCollection _outputMessages;
         private readonly string _outputDisplayName;
         private readonly ResourceManager _resources = new ResourceManager("Microsoft.Build.Tasks.Core.Strings.ManifestUtilities", System.Reflection.Assembly.GetExecutingAssembly());
-        private bool _success = true;
 
         // These must be defined in sorted order!
-        private readonly static string[] s_knownImplementedCategories = new string[]
+        private static readonly string[] s_knownImplementedCategories =
         {
             "{02496840-3AC4-11cf-87B9-00AA006C8166}", //CATID_VBFormat
             "{02496841-3AC4-11cf-87B9-00AA006C8166}", //CATID_VBGetControl
             "{40FC6ED5-2438-11CF-A3DB-080036F12502}",
         };
-        private readonly static string[] s_knownSubKeys = new string[]
+        private static readonly string[] s_knownSubKeys =
         {
             "Control",
             "Programmable",
@@ -56,60 +51,57 @@ public ComImporter(string path, OutputMessageCollection outputMessages, string o
             {
                 IntPtr typeLibAttrPtr = IntPtr.Zero;
                 tlib.GetLibAttr(out typeLibAttrPtr);
-                TYPELIBATTR typeLibAttr = (TYPELIBATTR)Marshal.PtrToStructure(typeLibAttrPtr, typeof(TYPELIBATTR));
+                var typeLibAttr = (TYPELIBATTR)Marshal.PtrToStructure(typeLibAttrPtr, typeof(TYPELIBATTR));
                 tlib.ReleaseTLibAttr(typeLibAttrPtr);
                 Guid tlbid = typeLibAttr.guid;
 
-                string name, docString, helpFile;
-                int helpContext;
-                tlib.GetDocumentation(-1, out name, out docString, out helpContext, out helpFile);
+                tlib.GetDocumentation(-1, out _, out string docString, out _, out string helpFile);
                 string helpdir = Util.FilterNonprintableChars(helpFile); //Path.GetDirectoryName(helpFile);
 
-                _typeLib = new TypeLib(tlbid, new Version(typeLibAttr.wMajorVerNum, typeLibAttr.wMinorVerNum), helpdir, typeLibAttr.lcid, Convert.ToInt32(typeLibAttr.wLibFlags, CultureInfo.InvariantCulture));
+                TypeLib = new TypeLib(tlbid, new Version(typeLibAttr.wMajorVerNum, typeLibAttr.wMinorVerNum), helpdir, typeLibAttr.lcid, Convert.ToInt32(typeLibAttr.wLibFlags, CultureInfo.InvariantCulture));
 
-                List<ComClass> comClassList = new List<ComClass>();
+                var comClassList = new List<ComClass>();
                 int count = tlib.GetTypeInfoCount();
                 for (int i = 0; i < count; ++i)
                 {
-                    TYPEKIND tkind;
-                    tlib.GetTypeInfoType(i, out tkind);
+                    tlib.GetTypeInfoType(i, out TYPEKIND tkind);
                     if (tkind == TYPEKIND.TKIND_COCLASS)
                     {
-                        UCOMITypeInfo tinfo;
-                        tlib.GetTypeInfo(i, out tinfo);
+                        tlib.GetTypeInfo(i, out UCOMITypeInfo tinfo);
 
                         IntPtr tinfoAttrPtr = IntPtr.Zero;
                         tinfo.GetTypeAttr(out tinfoAttrPtr);
                         TYPEATTR tinfoAttr = (TYPEATTR)Marshal.PtrToStructure(tinfoAttrPtr, typeof(TYPEATTR));
                         tinfo.ReleaseTypeAttr(tinfoAttrPtr);
                         Guid clsid = tinfoAttr.guid;
-                        string sclsid = clsid.ToString("B");
 
-                        tlib.GetDocumentation(i, out name, out docString, out helpContext, out helpFile);
+                        tlib.GetDocumentation(i, out _, out docString, out _, out helpFile);
                         string description = Util.FilterNonprintableChars(docString);
 
                         ClassInfo info = GetRegisteredClassInfo(clsid);
                         if (info == null)
+                        {
                             continue;
+                        }
 
                         comClassList.Add(new ComClass(tlbid, clsid, info.Progid, info.ThreadingModel, description));
                     }
                 }
                 if (comClassList.Count > 0)
                 {
-                    _comClasses = comClassList.ToArray();
-                    _success = true;
+                    ComClasses = comClassList.ToArray();
+                    Success = true;
                 }
                 else
                 {
                     outputMessages.AddErrorMessage("GenerateManifest.ComImport", outputDisplayName, _resources.GetString("ComImporter.NoRegisteredClasses"));
-                    _success = false;
+                    Success = false;
                 }
             }
             else
             {
                 outputMessages.AddErrorMessage("GenerateManifest.ComImport", outputDisplayName, _resources.GetString("ComImporter.TypeLibraryLoadFailure"));
-                _success = false;
+                Success = false;
             }
 #pragma warning restore 618
         }
@@ -122,9 +114,15 @@ private void CheckForUnknownSubKeys(RegistryKey key)
         private void CheckForUnknownSubKeys(RegistryKey key, string[] knownNames)
         {
             if (key.SubKeyCount > 0)
+            {
                 foreach (string name in key.GetSubKeyNames())
+                {
                     if (Array.BinarySearch(knownNames, name, StringComparer.OrdinalIgnoreCase) < 0)
+                    {
                         _outputMessages.AddWarningMessage("GenerateManifest.ComImport", _outputDisplayName, String.Format(CultureInfo.CurrentCulture, _resources.GetString("ComImporter.SubKeyNotImported"), key.Name + "\\" + name));
+                    }
+                }
+            }
         }
 
         private void CheckForUnknownValues(RegistryKey key)
@@ -135,9 +133,18 @@ private void CheckForUnknownValues(RegistryKey key)
         private void CheckForUnknownValues(RegistryKey key, string[] knownNames)
         {
             if (key.ValueCount > 0)
+            {
                 foreach (string name in key.GetValueNames())
-                    if (!String.IsNullOrEmpty(name) && Array.BinarySearch(knownNames, name, StringComparer.OrdinalIgnoreCase) < 0)
+                {
+                    if (!String.IsNullOrEmpty(name) && Array.BinarySearch(
+                            knownNames,
+                            name,
+                            StringComparer.OrdinalIgnoreCase) < 0)
+                    {
                         _outputMessages.AddWarningMessage("GenerateManifest.ComImport", _outputDisplayName, String.Format(CultureInfo.CurrentCulture, _resources.GetString("ComImporter.ValueNotImported"), key.Name + "\\@" + name));
+                    }
+                }
+            }
         }
 
         private ClassInfo GetRegisteredClassInfo(Guid clsid)
@@ -145,22 +152,30 @@ private ClassInfo GetRegisteredClassInfo(Guid clsid)
             ClassInfo info = null;
             RegistryKey userKey = Registry.CurrentUser.OpenSubKey("SOFTWARE\\CLASSES\\CLSID");
             if (GetRegisteredClassInfo(userKey, clsid, ref info))
+            {
                 return info;
+            }
             RegistryKey machineKey = Registry.ClassesRoot.OpenSubKey("CLSID");
             if (GetRegisteredClassInfo(machineKey, clsid, ref info))
+            {
                 return info;
+            }
             return null;
         }
 
         private bool GetRegisteredClassInfo(RegistryKey rootKey, Guid clsid, ref ClassInfo info)
         {
             if (rootKey == null)
+            {
                 return false;
+            }
 
             string sclsid = clsid.ToString("B");
             RegistryKey classKey = rootKey.OpenSubKey(sclsid);
             if (classKey == null)
+            {
                 return false;
+            }
 
             bool succeeded = true;
             string registeredPath = null;
@@ -180,7 +195,6 @@ private bool GetRegisteredClassInfo(RegistryKey rootKey, Guid clsid, ref ClassIn
                 }
                 else if (String.Equals(subKeyName, "ProgID", StringComparison.OrdinalIgnoreCase))
                 {
-                    RegistryKey progidKey = classKey.OpenSubKey(subKeyName);
                     progid = (string)subKey.GetValue(null);
                     CheckForUnknownSubKeys(subKey);
                     CheckForUnknownValues(subKey);
@@ -197,7 +211,9 @@ private bool GetRegisteredClassInfo(RegistryKey rootKey, Guid clsid, ref ClassIn
                 else
                 {
                     if (Array.BinarySearch(s_knownSubKeys, subKeyName, StringComparer.OrdinalIgnoreCase) < 0)
+                    {
                         _outputMessages.AddWarningMessage("GenerateManifest.ComImport", _outputDisplayName, String.Format(CultureInfo.CurrentCulture, _resources.GetString("ComImporter.SubKeyNotImported"), classKey.Name + "\\" + subKeyName));
+                    }
                 }
             }
 
@@ -207,24 +223,22 @@ private bool GetRegisteredClassInfo(RegistryKey rootKey, Guid clsid, ref ClassIn
                 succeeded = false;
             }
 
-            info = new ClassInfo(progid, registeredPath, threadingModel);
+            info = new ClassInfo(progid, threadingModel);
             return succeeded;
         }
 
-        public bool Success { get { return _success; } }
-        public ComClass[] ComClasses { get { return _comClasses; } }
-        public TypeLib TypeLib { get { return _typeLib; } }
+        public bool Success { get; } = true;
 
+        public ComClass[] ComClasses { get; }
+        public TypeLib TypeLib { get; }
 
         private class ClassInfo
         {
             internal readonly string Progid;
-            internal readonly string RegisteredPath;
             internal readonly string ThreadingModel;
-            internal ClassInfo(string progid, string registeredPath, string threadingModel)
+            internal ClassInfo(string progid, string threadingModel)
             {
                 Progid = progid;
-                RegisteredPath = registeredPath;
                 ThreadingModel = threadingModel;
             }
         }
diff --git a/src/Tasks/ManifestUtil/CompatibleFramework.cs b/src/Tasks/ManifestUtil/CompatibleFramework.cs
index 483d7f180d8..2105db6e2db 100644
--- a/src/Tasks/ManifestUtil/CompatibleFramework.cs
+++ b/src/Tasks/ManifestUtil/CompatibleFramework.cs
@@ -1,11 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.ComponentModel;
 using System.Runtime.InteropServices;
-using System.Text.RegularExpressions;
-using System.Xml;
 using System.Xml.Serialization;
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
@@ -16,36 +13,29 @@ namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
     [ComVisible(false)]
     public sealed class CompatibleFramework
     {
-        private string _version = null;
-        private string _profile = null;
-        private string _supportedRuntime = null;
-
-        /// <summary>
-        /// Initializes a new instance of the CompatibleFramework class
-        /// </summary>
-        public CompatibleFramework()
-        {
-        }
+        private string _version;
+        private string _profile;
+        private string _supportedRuntime;
 
         [XmlIgnore]
         public string Version
         {
-            get { return _version; }
-            set { _version = value; }
+            get => _version;
+            set => _version = value;
         }
 
         [XmlIgnore]
         public string Profile
         {
-            get { return _profile; }
-            set { _profile = value; }
+            get => _profile;
+            set => _profile = value;
         }
 
         [XmlIgnore]
         public string SupportedRuntime
         {
-            get { return _supportedRuntime; }
-            set { _supportedRuntime = value; }
+            get => _supportedRuntime;
+            set => _supportedRuntime = value;
         }
 
         #region " XmlSerializer "
@@ -55,8 +45,8 @@ public string SupportedRuntime
         [XmlAttribute("Version")]
         public string XmlVersion
         {
-            get { return _version; }
-            set { _version = value; }
+            get => _version;
+            set => _version = value;
         }
 
         [Browsable(false)]
@@ -64,8 +54,8 @@ public string XmlVersion
         [XmlAttribute("Profile")]
         public string XmlProfile
         {
-            get { return _profile; }
-            set { _profile = value; }
+            get => _profile;
+            set => _profile = value;
         }
 
         [Browsable(false)]
@@ -73,8 +63,8 @@ public string XmlProfile
         [XmlAttribute("SupportedRuntime")]
         public string XmlSupportedRuntime
         {
-            get { return _supportedRuntime; }
-            set { _supportedRuntime = value; }
+            get => _supportedRuntime;
+            set => _supportedRuntime = value;
         }
 
         #endregion
diff --git a/src/Tasks/ManifestUtil/CompatibleFrameworkCollection.cs b/src/Tasks/ManifestUtil/CompatibleFrameworkCollection.cs
index a4f0f42037a..fd08bc8446e 100644
--- a/src/Tasks/ManifestUtil/CompatibleFrameworkCollection.cs
+++ b/src/Tasks/ManifestUtil/CompatibleFrameworkCollection.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.Runtime.InteropServices;
@@ -11,19 +10,18 @@ namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
     [ComVisible(false)]
     public sealed class CompatibleFrameworkCollection : IEnumerable
     {
-        private List<CompatibleFramework> _list = new List<CompatibleFramework>();
+        private readonly List<CompatibleFramework> _list = new List<CompatibleFramework>();
 
         internal CompatibleFrameworkCollection(CompatibleFramework[] compatibleFrameworks)
         {
             if (compatibleFrameworks == null)
+            {
                 return;
+            }
             _list.AddRange(compatibleFrameworks);
         }
 
-        public CompatibleFramework this[int index]
-        {
-            get { return _list[index]; }
-        }
+        public CompatibleFramework this[int index] => _list[index];
 
         public void Add(CompatibleFramework compatibleFramework)
         {
@@ -35,10 +33,7 @@ public void Clear()
             _list.Clear();
         }
 
-        public int Count
-        {
-            get { return _list.Count; }
-        }
+        public int Count => _list.Count;
 
         public IEnumerator GetEnumerator()
         {
diff --git a/src/Tasks/ManifestUtil/Constants.cs b/src/Tasks/ManifestUtil/Constants.cs
index 227775923c5..f559bdf342a 100644
--- a/src/Tasks/ManifestUtil/Constants.cs
+++ b/src/Tasks/ManifestUtil/Constants.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Globalization;
-using System.IO;
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
 {
diff --git a/src/Tasks/ManifestUtil/DeployManifest.cs b/src/Tasks/ManifestUtil/DeployManifest.cs
index 3a7bab24b47..bc4ad3a9d42 100644
--- a/src/Tasks/ManifestUtil/DeployManifest.cs
+++ b/src/Tasks/ManifestUtil/DeployManifest.cs
@@ -8,7 +8,6 @@
 using System.IO;
 using System.Xml;
 using System.Xml.Serialization;
-using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
 using Microsoft.Build.Utilities;
 using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
 using System.Collections.Generic;
@@ -58,26 +57,26 @@ public enum UpdateUnit
     [XmlRoot("DeployManifest")]
     public sealed class DeployManifest : Manifest
     {
-        private string _createDesktopShortcut = null;
-        private string _deploymentUrl = null;
-        private string _disallowUrlActivation = null;
-        private AssemblyReference _entryPoint = null;
-        private string _errorReportUrl = null;
+        private string _createDesktopShortcut;
+        private string _deploymentUrl;
+        private string _disallowUrlActivation;
+        private AssemblyReference _entryPoint;
+        private string _errorReportUrl;
         private string _install = "true";
-        private string _mapFileExtensions = null;
-        private string _minimumRequiredVersion = null;
-        private string _product = null;
-        private string _publisher = null;
-        private string _suiteName = null;
-        private string _supportUrl = null;
-        private string _trustUrlParameters = null;
-        private string _updateEnabled = null;
+        private string _mapFileExtensions;
+        private string _minimumRequiredVersion;
+        private string _product;
+        private string _publisher;
+        private string _suiteName;
+        private string _supportUrl;
+        private string _trustUrlParameters;
+        private string _updateEnabled;
         private string _updateInterval = "0";
-        private string _updateMode = null;
+        private string _updateMode;
         private string _updateUnit = "days";
-        private CompatibleFrameworkCollection _compatibleFrameworkList = null;
-        private List<CompatibleFramework> _compatibleFrameworks = null;
-        private string _targetFrameworkMoniker = null;
+        private CompatibleFrameworkCollection _compatibleFrameworkList;
+        private List<CompatibleFramework> _compatibleFrameworks = new List<CompatibleFramework>();
+        private string _targetFrameworkMoniker;
 
         private const string _redistListFolder = "RedistList";
         private const string _redistListFile = "FrameworkList.xml";
@@ -87,7 +86,6 @@ public sealed class DeployManifest : Manifest
         /// </summary>
         public DeployManifest()
         {
-            _compatibleFrameworks = new List<CompatibleFramework>();
         }
 
         /// <summary>
@@ -95,7 +93,6 @@ public DeployManifest()
         /// </summary>
         public DeployManifest(string targetFrameworkMoniker)
         {
-            _compatibleFrameworks = new List<CompatibleFramework>();
             DiscoverCompatFrameworks(targetFrameworkMoniker);
         }
 
@@ -103,7 +100,7 @@ private void DiscoverCompatFrameworks(string moniker)
         {
             if (!string.IsNullOrEmpty(moniker))
             {
-                FrameworkNameVersioning frameworkName = new FrameworkNameVersioning(moniker);
+                var frameworkName = new FrameworkNameVersioning(moniker);
                 if (frameworkName.Version.Major >= 4)
                 {
                     _compatibleFrameworks.Clear();
@@ -132,12 +129,10 @@ private void DiscoverCompatibleFrameworks(FrameworkNameVersioning frameworkName)
         /// codes from GetInstallableFrameworkForTargetFxInternal in 
         /// env/vscore/package/FxMultiTargeting/FrameworkMultiTargetingInternal.cs
         /// </summary>
-        /// <param name="frameworkName"></param>
-        /// <returns></returns>
-        private FrameworkNameVersioning GetInstallableFrameworkName(FrameworkNameVersioning frameworkName)
+        private static FrameworkNameVersioning GetInstallableFrameworkName(FrameworkNameVersioning frameworkName)
         {
             string installableFramework = null;
-            FrameworkNameVersioning installableFrameworkObj = null;
+            FrameworkNameVersioning installableFrameworkObj;
 
             IList<string> referenceAssemblyPaths = GetPathToReferenceAssemblies(frameworkName);
 
@@ -178,7 +173,7 @@ private FrameworkNameVersioning GetInstallableFrameworkName(FrameworkNameVersion
             return installableFrameworkObj;
         }
 
-        private string GetRedistListFilePath(string referenceAssemblyPath)
+        private static string GetRedistListFilePath(string referenceAssemblyPath)
         {
             string redistListPath = Path.Combine(referenceAssemblyPath, _redistListFolder);
             redistListPath = Path.Combine(redistListPath, _redistListFile);
@@ -186,7 +181,7 @@ private string GetRedistListFilePath(string referenceAssemblyPath)
             return redistListPath;
         }
 
-        private IList<string> GetPathToReferenceAssemblies(FrameworkNameVersioning targetFrameworkMoniker)
+        private static IList<string> GetPathToReferenceAssemblies(FrameworkNameVersioning targetFrameworkMoniker)
         {
             IList<string> targetFrameworkPaths = null;
             try
@@ -210,29 +205,22 @@ private IList<string> GetPathToReferenceAssemblies(FrameworkNameVersioning targe
         /// </summary>
         /// <param name="redistListFilePath">the path to the redistlist file</param>
         /// <returns>InstallableFramework</returns>
-        private string GetInstallableFramework(string redistListFilePath)
+        private static string GetInstallableFramework(string redistListFilePath)
         {
             string installableFramework = null;
 
             try
             {
-                XmlDocument doc = new XmlDocument();
-                XmlReaderSettings xrSettings = new XmlReaderSettings();
-                xrSettings.DtdProcessing = DtdProcessing.Ignore;
+                var doc = new XmlDocument();
+                var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
                 using (XmlReader xr = XmlReader.Create(redistListFilePath, xrSettings))
                 {
                     doc.Load(xr);
                     XmlNode fileListNode = doc.DocumentElement;
-                    if (fileListNode != null)
+                    XmlAttribute nameattr = fileListNode?.Attributes["InstallableFramework"];
+                    if (!String.IsNullOrEmpty(nameattr?.Value))
                     {
-                        XmlAttribute nameattr = fileListNode.Attributes["InstallableFramework"];
-                        if (nameattr != null)
-                        {
-                            if (!String.IsNullOrEmpty(nameattr.Value))
-                            {
-                                installableFramework = nameattr.Value;
-                            }
-                        }
+                        installableFramework = nameattr.Value;
                     }
                 }
             }
@@ -244,7 +232,7 @@ private string GetInstallableFramework(string redistListFilePath)
         }
 
 
-        private CompatibleFramework GetSubsetCompatFramework(FrameworkNameVersioning frameworkName)
+        private static CompatibleFramework GetSubsetCompatFramework(FrameworkNameVersioning frameworkName)
         {
             CompatibleFramework compat = GetFullCompatFramework(frameworkName);
             compat.Profile = frameworkName.Profile;
@@ -252,13 +240,14 @@ private CompatibleFramework GetSubsetCompatFramework(FrameworkNameVersioning fra
             return compat;
         }
 
-        private CompatibleFramework GetFullCompatFramework(FrameworkNameVersioning frameworkName)
+        private static CompatibleFramework GetFullCompatFramework(FrameworkNameVersioning frameworkName)
         {
-            CompatibleFramework compat = new CompatibleFramework();
-            compat.Version = frameworkName.Version.ToString();
-
-            compat.SupportedRuntime = PatchCLRVersion(Util.GetClrVersion(frameworkName.Version.ToString()));
-            compat.Profile = "Full";
+            var compat = new CompatibleFramework
+            {
+                Version = frameworkName.Version.ToString(),
+                SupportedRuntime = PatchCLRVersion(Util.GetClrVersion(frameworkName.Version.ToString())),
+                Profile = "Full"
+            };
 
             return compat;
         }
@@ -268,12 +257,12 @@ private CompatibleFramework GetFullCompatFramework(FrameworkNameVersioning frame
         /// </summary>
         /// <param name="version"></param>
         /// <returns></returns>
-        private string PatchCLRVersion(string version)
+        private static string PatchCLRVersion(string version)
         {
             try
             {
-                Version ver = new Version(version);
-                Version result = new Version(ver.Major, ver.Minor, ver.Build);
+                var ver = new Version(version);
+                var result = new Version(ver.Major, ver.Minor, ver.Build);
                 return result.ToString();
             }
             catch (ArgumentException)
@@ -301,8 +290,8 @@ private string PatchCLRVersion(string version)
         [XmlIgnore]
         public bool CreateDesktopShortcut
         {
-            get { return ConvertUtil.ToBoolean(_createDesktopShortcut); }
-            set { _createDesktopShortcut = (value ? "true" : null); }
+            get => ConvertUtil.ToBoolean(_createDesktopShortcut);
+            set => _createDesktopShortcut = (value ? "true" : null);
         }
 
         /// <summary>
@@ -311,7 +300,7 @@ public bool CreateDesktopShortcut
         [XmlIgnore]
         public string TargetFrameworkMoniker
         {
-            get { return _targetFrameworkMoniker; }
+            get => _targetFrameworkMoniker;
             set
             {
                 _targetFrameworkMoniker = value;
@@ -328,7 +317,9 @@ public CompatibleFrameworkCollection CompatibleFrameworks
             get
             {
                 if (_compatibleFrameworkList == null && _compatibleFrameworks != null)
+                {
                     _compatibleFrameworkList = new CompatibleFrameworkCollection(_compatibleFrameworks.ToArray());
+                }
                 return _compatibleFrameworkList;
             }
         }
@@ -342,8 +333,8 @@ public CompatibleFrameworkCollection CompatibleFrameworks
         [XmlIgnore]
         public string DeploymentUrl
         {
-            get { return _deploymentUrl; }
-            set { _deploymentUrl = value; }
+            get => _deploymentUrl;
+            set => _deploymentUrl = value;
         }
 
         /// <summary>
@@ -355,21 +346,15 @@ public string DeploymentUrl
         [XmlIgnore]
         public bool DisallowUrlActivation
         {
-            get { return ConvertUtil.ToBoolean(_disallowUrlActivation); }
-            set { _disallowUrlActivation = value ? "true" : null; } // NOTE: disallowUrlActivation=false is implied, and Fusion prefers the false case to be unspecified
+            get => ConvertUtil.ToBoolean(_disallowUrlActivation);
+            set => _disallowUrlActivation = value ? "true" : null; // NOTE: disallowUrlActivation=false is implied, and Fusion prefers the false case to be unspecified
         }
 
         [XmlIgnore]
         public override AssemblyReference EntryPoint
         {
-            get
-            {
-                return _entryPoint;
-            }
-            set
-            {
-                _entryPoint = value;
-            }
+            get => _entryPoint;
+            set => _entryPoint = value;
         }
 
         /// <summary>
@@ -379,8 +364,8 @@ public override AssemblyReference EntryPoint
         [XmlIgnore]
         public string ErrorReportUrl
         {
-            get { return _errorReportUrl; }
-            set { _errorReportUrl = value; }
+            get => _errorReportUrl;
+            set => _errorReportUrl = value;
         }
 
         /// <summary>
@@ -392,8 +377,8 @@ public string ErrorReportUrl
         [XmlIgnore]
         public bool Install
         {
-            get { return ConvertUtil.ToBoolean(_install); }
-            set { _install = Convert.ToString(value, CultureInfo.InvariantCulture); }
+            get => ConvertUtil.ToBoolean(_install);
+            set => _install = Convert.ToString(value, CultureInfo.InvariantCulture);
         }
 
         /// <summary>
@@ -405,8 +390,8 @@ public bool Install
         [XmlIgnore]
         public bool MapFileExtensions
         {
-            get { return ConvertUtil.ToBoolean(_mapFileExtensions); }
-            set { _mapFileExtensions = value ? "true" : null; } // NOTE: mapFileExtensions=false is implied, and Fusion prefers the false case to be unspecified
+            get => ConvertUtil.ToBoolean(_mapFileExtensions);
+            set => _mapFileExtensions = value ? "true" : null; // NOTE: mapFileExtensions=false is implied, and Fusion prefers the false case to be unspecified
         }
 
         /// <summary>
@@ -418,8 +403,8 @@ public bool MapFileExtensions
         [XmlIgnore]
         public string MinimumRequiredVersion
         {
-            get { return _minimumRequiredVersion; }
-            set { _minimumRequiredVersion = value; }
+            get => _minimumRequiredVersion;
+            set => _minimumRequiredVersion = value;
         }
 
         internal override void OnAfterLoad()
@@ -436,7 +421,9 @@ internal override void OnBeforeSave()
         {
             base.OnBeforeSave();
             if (AssemblyIdentity != null && String.IsNullOrEmpty(AssemblyIdentity.PublicKeyToken))
+            {
                 AssemblyIdentity.PublicKeyToken = "0000000000000000";
+            }
         }
 
         /// <summary>
@@ -447,8 +434,8 @@ internal override void OnBeforeSave()
         [XmlIgnore]
         public string Product
         {
-            get { return _product; }
-            set { _product = value; }
+            get => _product;
+            set => _product = value;
         }
 
         /// <summary>
@@ -459,8 +446,8 @@ public string Product
         [XmlIgnore]
         public string Publisher
         {
-            get { return _publisher; }
-            set { _publisher = value; }
+            get => _publisher;
+            set => _publisher = value;
         }
 
         /// <summary>
@@ -470,8 +457,8 @@ public string Publisher
         [XmlIgnore]
         public string SuiteName
         {
-            get { return _suiteName; }
-            set { _suiteName = value; }
+            get => _suiteName;
+            set => _suiteName = value;
         }
 
         /// <summary>
@@ -481,8 +468,8 @@ public string SuiteName
         [XmlIgnore]
         public string SupportUrl
         {
-            get { return _supportUrl; }
-            set { _supportUrl = value; }
+            get => _supportUrl;
+            set => _supportUrl = value;
         }
 
         /// <summary>
@@ -492,8 +479,9 @@ public string SupportUrl
         [XmlIgnore]
         public bool TrustUrlParameters
         {
-            get { return ConvertUtil.ToBoolean(_trustUrlParameters); }
-            set { _trustUrlParameters = value ? "true" : null; } // NOTE: trustUrlParameters=false is implied, and Fusion prefers the false case to be unspecified
+            get => ConvertUtil.ToBoolean(_trustUrlParameters);
+            set => _trustUrlParameters = value ? "true" : null;
+            // NOTE: trustUrlParameters=false is implied, and Fusion prefers the false case to be unspecified
         }
 
         /// <summary>
@@ -504,8 +492,8 @@ public bool TrustUrlParameters
         [XmlIgnore]
         public bool UpdateEnabled
         {
-            get { return ConvertUtil.ToBoolean(_updateEnabled); }
-            set { _updateEnabled = Convert.ToString(value, CultureInfo.InvariantCulture); }
+            get => ConvertUtil.ToBoolean(_updateEnabled);
+            set => _updateEnabled = Convert.ToString(value, CultureInfo.InvariantCulture);
         }
 
         /// <summary>
@@ -522,7 +510,7 @@ public int UpdateInterval
                 catch (ArgumentException) { return 1; }
                 catch (FormatException) { return 1; }
             }
-            set { _updateInterval = Convert.ToString(value, CultureInfo.InvariantCulture); }
+            set => _updateInterval = Convert.ToString(value, CultureInfo.InvariantCulture);
         }
 
         /// <summary>
@@ -539,10 +527,7 @@ public UpdateMode UpdateMode
                 catch (FormatException) { return UpdateMode.Foreground; }
                 catch (ArgumentException) { return UpdateMode.Foreground; }
             }
-            set
-            {
-                _updateMode = value.ToString();
-            }
+            set => _updateMode = value.ToString();
         }
 
         /// <summary>
@@ -558,10 +543,7 @@ public UpdateUnit UpdateUnit
                 catch (FormatException) { return UpdateUnit.Days; }
                 catch (ArgumentException) { return UpdateUnit.Days; }
             }
-            set
-            {
-                _updateUnit = value.ToString();
-            }
+            set => _updateUnit = value.ToString();
         }
 
         public override void Validate()
@@ -576,33 +558,46 @@ public override void Validate()
         private void ValidateDeploymentProvider()
         {
             if (!String.IsNullOrEmpty(_deploymentUrl) && PathUtil.IsLocalPath(_deploymentUrl))
+            {
                 OutputMessages.AddWarningMessage("GenerateManifest.InvalidDeploymentProvider");
+            }
         }
 
         private void ValidateEntryPoint()
         {
             if (_entryPoint != null)
             {
-                if (!String.IsNullOrEmpty(_entryPoint.TargetPath) && !_entryPoint.TargetPath.EndsWith(".manifest", StringComparison.OrdinalIgnoreCase))
+                if (!String.IsNullOrEmpty(_entryPoint.TargetPath) && !_entryPoint.TargetPath.EndsWith(
+                        ".manifest",
+                        StringComparison.OrdinalIgnoreCase))
+                {
                     OutputMessages.AddErrorMessage("GenerateManifest.InvalidEntryPoint", _entryPoint.ToString());
+                }
 
-                string ManifestPath = _entryPoint.ResolvedPath;
-                if (ManifestPath == null)
-                    ManifestPath = Path.Combine(Path.GetDirectoryName(SourcePath), _entryPoint.TargetPath);
-                if (File.Exists(ManifestPath))
+                string manifestPath = _entryPoint.ResolvedPath;
+                if (manifestPath == null)
                 {
-                    ApplicationManifest entryPointManifest = ManifestReader.ReadManifest(ManifestPath, false) as ApplicationManifest;
+                    manifestPath = Path.Combine(Path.GetDirectoryName(SourcePath), _entryPoint.TargetPath);
+                }
+                if (File.Exists(manifestPath))
+                {
+                    ApplicationManifest entryPointManifest = ManifestReader.ReadManifest(manifestPath, false) as ApplicationManifest;
                     if (entryPointManifest != null)
                     {
                         if (Install)
                         {
                             if (entryPointManifest.HostInBrowser)
+                            {
                                 OutputMessages.AddErrorMessage("GenerateManifest.HostInBrowserNotOnlineOnly");
+                            }
                         }
                         else
                         {
-                            if (entryPointManifest.FileAssociations != null && entryPointManifest.FileAssociations.Count > 0)
+                            if (entryPointManifest.FileAssociations != null &&
+                                entryPointManifest.FileAssociations.Count > 0)
+                            {
                                 OutputMessages.AddErrorMessage("GenerateManifest.FileAssociationsNotInstalled");
+                            }
                         }
                     }
                 }
@@ -613,10 +608,12 @@ private void ValidateMinimumRequiredVersion()
         {
             if (!String.IsNullOrEmpty(_minimumRequiredVersion))
             {
-                Version v1 = new Version(_minimumRequiredVersion);
-                Version v2 = new Version(AssemblyIdentity.Version);
+                var v1 = new Version(_minimumRequiredVersion);
+                var v2 = new Version(AssemblyIdentity.Version);
                 if (v1 > v2)
+                {
                     OutputMessages.AddErrorMessage("GenerateManifest.GreaterMinimumRequiredVersion");
+                }
             }
         }
 
@@ -627,8 +624,8 @@ private void ValidateMinimumRequiredVersion()
         [XmlAttribute("CreateDesktopShortcut")]
         public string XmlCreateDesktopShortcut
         {
-            get { return _createDesktopShortcut != null ? _createDesktopShortcut.ToLowerInvariant() : null; }
-            set { _createDesktopShortcut = value; }
+            get => _createDesktopShortcut?.ToLowerInvariant();
+            set => _createDesktopShortcut = value;
         }
 
         [Browsable(false)]
@@ -636,8 +633,8 @@ public string XmlCreateDesktopShortcut
         [XmlArray("CompatibleFrameworks")]
         public CompatibleFramework[] XmlCompatibleFrameworks
         {
-            get { return _compatibleFrameworks.Count > 0 ? _compatibleFrameworks.ToArray() : null; }
-            set { _compatibleFrameworks = new List<CompatibleFramework>(value); }
+            get => _compatibleFrameworks.Count > 0 ? _compatibleFrameworks.ToArray() : null;
+            set => _compatibleFrameworks = new List<CompatibleFramework>(value);
         }
 
         [Browsable(false)]
@@ -645,8 +642,8 @@ public CompatibleFramework[] XmlCompatibleFrameworks
         [XmlAttribute("DeploymentUrl")]
         public string XmlDeploymentUrl
         {
-            get { return _deploymentUrl; }
-            set { _deploymentUrl = value; }
+            get => _deploymentUrl;
+            set => _deploymentUrl = value;
         }
 
         [Browsable(false)]
@@ -654,8 +651,8 @@ public string XmlDeploymentUrl
         [XmlAttribute("DisallowUrlActivation")]
         public string XmlDisallowUrlActivation
         {
-            get { return _disallowUrlActivation != null ? _disallowUrlActivation.ToLowerInvariant() : null; }
-            set { _disallowUrlActivation = value; }
+            get => _disallowUrlActivation?.ToLowerInvariant();
+            set => _disallowUrlActivation = value;
         }
 
         [Browsable(false)]
@@ -663,8 +660,8 @@ public string XmlDisallowUrlActivation
         [XmlAttribute("ErrorReportUrl")]
         public string XmlErrorReportUrl
         {
-            get { return _errorReportUrl; }
-            set { _errorReportUrl = value; }
+            get => _errorReportUrl;
+            set => _errorReportUrl = value;
         }
 
         [Browsable(false)]
@@ -672,8 +669,8 @@ public string XmlErrorReportUrl
         [XmlAttribute("Install")]
         public string XmlInstall
         {
-            get { return !String.IsNullOrEmpty(_install) ? _install.ToLower(CultureInfo.InvariantCulture) : "true"; } // NOTE: Install attribute shouldn't be null in the manifest, so specify install="true" by default
-            set { _install = value; }
+            get => !String.IsNullOrEmpty(_install) ? _install.ToLower(CultureInfo.InvariantCulture) : "true";  // NOTE: Install attribute shouldn't be null in the manifest, so specify install="true" by default
+            set => _install = value;
         }
 
         [Browsable(false)]
@@ -681,8 +678,8 @@ public string XmlInstall
         [XmlAttribute("MapFileExtensions")]
         public string XmlMapFileExtensions
         {
-            get { return _mapFileExtensions != null ? _mapFileExtensions.ToLowerInvariant() : null; }
-            set { _mapFileExtensions = value; }
+            get => _mapFileExtensions?.ToLowerInvariant();
+            set => _mapFileExtensions = value;
         }
 
         [Browsable(false)]
@@ -690,8 +687,8 @@ public string XmlMapFileExtensions
         [XmlAttribute("MinimumRequiredVersion")]
         public string XmlMinimumRequiredVersion
         {
-            get { return _minimumRequiredVersion; }
-            set { _minimumRequiredVersion = value; }
+            get => _minimumRequiredVersion;
+            set => _minimumRequiredVersion = value;
         }
 
         [Browsable(false)]
@@ -699,8 +696,8 @@ public string XmlMinimumRequiredVersion
         [XmlAttribute("Product")]
         public string XmlProduct
         {
-            get { return _product; }
-            set { _product = value; }
+            get => _product;
+            set => _product = value;
         }
 
         [Browsable(false)]
@@ -708,8 +705,8 @@ public string XmlProduct
         [XmlAttribute("Publisher")]
         public string XmlPublisher
         {
-            get { return _publisher; }
-            set { _publisher = value; }
+            get => _publisher;
+            set => _publisher = value;
         }
 
         [Browsable(false)]
@@ -717,8 +714,8 @@ public string XmlPublisher
         [XmlAttribute("SuiteName")]
         public string XmlSuiteName
         {
-            get { return _suiteName; }
-            set { _suiteName = value; }
+            get => _suiteName;
+            set => _suiteName = value;
         }
 
         [Browsable(false)]
@@ -726,8 +723,8 @@ public string XmlSuiteName
         [XmlAttribute("SupportUrl")]
         public string XmlSupportUrl
         {
-            get { return _supportUrl; }
-            set { _supportUrl = value; }
+            get => _supportUrl;
+            set => _supportUrl = value;
         }
 
         [Browsable(false)]
@@ -735,8 +732,8 @@ public string XmlSupportUrl
         [XmlAttribute("TrustUrlParameters")]
         public string XmlTrustUrlParameters
         {
-            get { return _trustUrlParameters != null ? _trustUrlParameters.ToLowerInvariant() : null; }
-            set { _trustUrlParameters = value; }
+            get => _trustUrlParameters?.ToLowerInvariant();
+            set => _trustUrlParameters = value;
         }
 
         [Browsable(false)]
@@ -744,8 +741,8 @@ public string XmlTrustUrlParameters
         [XmlAttribute("UpdateEnabled")]
         public string XmlUpdateEnabled
         {
-            get { return _updateEnabled != null ? _updateEnabled.ToLower(CultureInfo.InvariantCulture) : null; }
-            set { _updateEnabled = value; }
+            get => _updateEnabled?.ToLower(CultureInfo.InvariantCulture);
+            set => _updateEnabled = value;
         }
 
         [Browsable(false)]
@@ -753,8 +750,8 @@ public string XmlUpdateEnabled
         [XmlAttribute("UpdateInterval")]
         public string XmlUpdateInterval
         {
-            get { return _updateInterval; }
-            set { _updateInterval = value; }
+            get => _updateInterval;
+            set => _updateInterval = value;
         }
 
         [Browsable(false)]
@@ -762,8 +759,8 @@ public string XmlUpdateInterval
         [XmlAttribute("UpdateMode")]
         public string XmlUpdateMode
         {
-            get { return _updateMode; }
-            set { _updateMode = value; }
+            get => _updateMode;
+            set => _updateMode = value;
         }
 
         [Browsable(false)]
@@ -771,8 +768,8 @@ public string XmlUpdateMode
         [XmlAttribute("UpdateUnit")]
         public string XmlUpdateUnit
         {
-            get { return _updateUnit != null ? _updateUnit.ToLower(CultureInfo.InvariantCulture) : null; }
-            set { _updateUnit = value; }
+            get => _updateUnit?.ToLower(CultureInfo.InvariantCulture);
+            set => _updateUnit = value;
         }
 
         #endregion
diff --git a/src/Tasks/ManifestUtil/EmbeddedManifestReader.cs b/src/Tasks/ManifestUtil/EmbeddedManifestReader.cs
index 6a341e61fb6..8865e1f97ff 100644
--- a/src/Tasks/ManifestUtil/EmbeddedManifestReader.cs
+++ b/src/Tasks/ManifestUtil/EmbeddedManifestReader.cs
@@ -11,7 +11,7 @@ namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
     internal class EmbeddedManifestReader
     {
         private static readonly IntPtr s_id1 = new IntPtr(1);
-        private Stream _manifest = null;
+        private Stream _manifest;
 
         private EmbeddedManifestReader(string path)
         {
@@ -20,28 +20,36 @@ private EmbeddedManifestReader(string path)
             {
                 hModule = NativeMethods.LoadLibraryExW(path, IntPtr.Zero, NativeMethods.LOAD_LIBRARY_AS_DATAFILE);
                 if (hModule == IntPtr.Zero)
+                {
                     return;
-                NativeMethods.EnumResNameProc callback = new NativeMethods.EnumResNameProc(EnumResNameCallback);
+                }
+                NativeMethods.EnumResNameProc callback = EnumResNameCallback;
                 NativeMethods.EnumResourceNames(hModule, NativeMethods.RT_MANIFEST, callback, IntPtr.Zero);
             }
             finally
             {
                 if (hModule != IntPtr.Zero)
+                {
                     NativeMethods.FreeLibrary(hModule);
+                }
             }
         }
 
         private bool EnumResNameCallback(IntPtr hModule, IntPtr pType, IntPtr pName, IntPtr param)
         {
             if (pName != s_id1)
+            {
                 return false; // only look for resources with ID=1
+            }
             IntPtr hResInfo = NativeMethods.FindResource(hModule, pName, NativeMethods.RT_MANIFEST);
             if (hResInfo == IntPtr.Zero)
+            {
                 return false; //continue looking
+            }
             IntPtr hResource = NativeMethods.LoadResource(hModule, hResInfo);
             NativeMethods.LockResource(hResource);
             uint bufsize = NativeMethods.SizeofResource(hModule, hResInfo);
-            byte[] buffer = new byte[bufsize];
+            var buffer = new byte[bufsize];
 
             Marshal.Copy(hResource, buffer, 0, buffer.Length);
             _manifest = new MemoryStream(buffer, false);
@@ -50,7 +58,7 @@ private bool EnumResNameCallback(IntPtr hModule, IntPtr pType, IntPtr pName, Int
 
         public static Stream Read(string path)
         {
-            if (path == null) throw new ArgumentNullException("path");
+            if (path == null) throw new ArgumentNullException(nameof(path));
 
             if (!path.EndsWith(".manifest", StringComparison.Ordinal) && !path.EndsWith(".dll", StringComparison.Ordinal))
             {
diff --git a/src/Tasks/ManifestUtil/FileAssociation.cs b/src/Tasks/ManifestUtil/FileAssociation.cs
index 53977a28fe5..c9fd7f82053 100644
--- a/src/Tasks/ManifestUtil/FileAssociation.cs
+++ b/src/Tasks/ManifestUtil/FileAssociation.cs
@@ -1,11 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.ComponentModel;
 using System.Runtime.InteropServices;
-using System.Text.RegularExpressions;
-using System.Xml;
 using System.Xml.Serialization;
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
@@ -16,44 +13,37 @@ namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
     [ComVisible(false)]
     public sealed class FileAssociation
     {
-        private string _defaultIcon = null;
-        private string _description = null;
-        private string _extension = null;
-        private string _progid = null;
-
-        /// <summary>
-        /// Initializes a new instance of the FileAssociation class
-        /// </summary>
-        public FileAssociation()
-        {
-        }
+        private string _defaultIcon;
+        private string _description;
+        private string _extension;
+        private string _progid;
 
         [XmlIgnore]
         public string DefaultIcon
         {
-            get { return _defaultIcon; }
-            set { _defaultIcon = value; }
+            get => _defaultIcon;
+            set => _defaultIcon = value;
         }
 
         [XmlIgnore]
         public string Description
         {
-            get { return _description; }
-            set { _description = value; }
+            get => _description;
+            set => _description = value;
         }
 
         [XmlIgnore]
         public string Extension
         {
-            get { return _extension; }
-            set { _extension = value; }
+            get => _extension;
+            set => _extension = value;
         }
 
         [XmlIgnore]
         public string ProgId
         {
-            get { return _progid; }
-            set { _progid = value; }
+            get => _progid;
+            set => _progid = value;
         }
 
         #region " XmlSerializer "
@@ -63,8 +53,8 @@ public string ProgId
         [XmlAttribute("DefaultIcon")]
         public string XmlDefaultIcon
         {
-            get { return _defaultIcon; }
-            set { _defaultIcon = value; }
+            get => _defaultIcon;
+            set => _defaultIcon = value;
         }
 
         [Browsable(false)]
@@ -72,8 +62,8 @@ public string XmlDefaultIcon
         [XmlAttribute("Description")]
         public string XmlDescription
         {
-            get { return _description; }
-            set { _description = value; }
+            get => _description;
+            set => _description = value;
         }
 
         [Browsable(false)]
@@ -81,8 +71,8 @@ public string XmlDescription
         [XmlAttribute("Extension")]
         public string XmlExtension
         {
-            get { return _extension; }
-            set { _extension = value; }
+            get => _extension;
+            set => _extension = value;
         }
 
         [Browsable(false)]
@@ -90,8 +80,8 @@ public string XmlExtension
         [XmlAttribute("Progid")]
         public string XmlProgId
         {
-            get { return _progid; }
-            set { _progid = value; }
+            get => _progid;
+            set => _progid = value;
         }
 
         #endregion
diff --git a/src/Tasks/ManifestUtil/FileAssociationCollection.cs b/src/Tasks/ManifestUtil/FileAssociationCollection.cs
index 8008871ed7f..e187f0824b4 100644
--- a/src/Tasks/ManifestUtil/FileAssociationCollection.cs
+++ b/src/Tasks/ManifestUtil/FileAssociationCollection.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.Runtime.InteropServices;
@@ -11,19 +10,18 @@ namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
     [ComVisible(false)]
     public sealed class FileAssociationCollection : IEnumerable
     {
-        private List<FileAssociation> _list = new List<FileAssociation>();
+        private readonly List<FileAssociation> _list = new List<FileAssociation>();
 
         internal FileAssociationCollection(FileAssociation[] fileAssociations)
         {
             if (fileAssociations == null)
+            {
                 return;
+            }
             _list.AddRange(fileAssociations);
         }
 
-        public FileAssociation this[int index]
-        {
-            get { return _list[index]; }
-        }
+        public FileAssociation this[int index] => _list[index];
 
         public void Add(FileAssociation fileAssociation)
         {
@@ -35,10 +33,7 @@ public void Clear()
             _list.Clear();
         }
 
-        public int Count
-        {
-            get { return _list.Count; }
-        }
+        public int Count => _list.Count;
 
         public IEnumerator GetEnumerator()
         {
diff --git a/src/Tasks/ManifestUtil/FileReference.cs b/src/Tasks/ManifestUtil/FileReference.cs
index 66db68d20bd..1b46df71c7b 100644
--- a/src/Tasks/ManifestUtil/FileReference.cs
+++ b/src/Tasks/ManifestUtil/FileReference.cs
@@ -2,10 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
+using System.Collections.Generic;
 using System.ComponentModel;
-using System.Globalization;
-using System.IO;
 using System.Runtime.InteropServices;
 using System.Text;
 using System.Xml.Serialization;
@@ -18,15 +16,15 @@ namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
     [ComVisible(false)]
     public sealed class FileReference : BaseReference
     {
-        private ComClass[] _comClasses = null;
-        private string _writeableType = null;
-        private ProxyStub[] _proxyStubs = null;
-        private TypeLib[] _typeLibs = null;
+        private ComClass[] _comClasses;
+        private string _writeableType;
+        private ProxyStub[] _proxyStubs;
+        private TypeLib[] _typeLibs;
 
         /// <summary>
         /// Initializes a new instance of the FileReference class.
         /// </summary>
-        public FileReference() : base()
+        public FileReference()
         {
         }
 
@@ -42,32 +40,39 @@ public FileReference(string path) : base(path)
         /// Specifies the set of COM classes referenced by the manifest for isolated applications and Reg-Free COM.
         /// </summary>
         [XmlIgnore]
-        public ComClass[] ComClasses
-        {
-            get { return _comClasses; }
-        }
+        public ComClass[] ComClasses => _comClasses;
 
         internal bool ImportComComponent(string path, OutputMessageCollection outputMessages, string outputDisplayName)
         {
-            ComImporter importer = new ComImporter(path, outputMessages, outputDisplayName);
+            var importer = new ComImporter(path, outputMessages, outputDisplayName);
             if (importer.Success)
             {
-                ArrayList list = new ArrayList();
+                var typeLibs = new List<TypeLib>();
 
                 // Add TypeLib objects from importer...
                 if (_typeLibs != null)
-                    list.AddRange(_typeLibs);
+                {
+                    typeLibs.AddRange(_typeLibs);
+                }
+
                 if (importer.TypeLib != null)
-                    list.Add(importer.TypeLib);
-                _typeLibs = (TypeLib[])list.ToArray(typeof(TypeLib));
+                {
+                    typeLibs.Add(importer.TypeLib);
+                }
+                _typeLibs = typeLibs.ToArray();
 
                 // Add ComClass objects from importer...
-                list.Clear();
+                var comClasses = new List<ComClass>();
                 if (_comClasses != null)
-                    list.AddRange(_comClasses);
+                {
+                    comClasses.AddRange(_comClasses);
+                }
+
                 if (importer.ComClasses != null)
-                    list.AddRange(importer.ComClasses);
-                _comClasses = (ComClass[])list.ToArray(typeof(ComClass));
+                {
+                    comClasses.AddRange(importer.ComClasses);
+                }
+                _comClasses = comClasses.ToArray();
             }
             return importer.Success;
         }
@@ -78,32 +83,23 @@ internal bool ImportComComponent(string path, OutputMessageCollection outputMess
         [XmlIgnore]
         public bool IsDataFile
         {
-            get { return String.Compare(_writeableType, "applicationData", StringComparison.OrdinalIgnoreCase) == 0; }
-            set { _writeableType = value ? "applicationData" : null; }
+            get => String.Compare(_writeableType, "applicationData", StringComparison.OrdinalIgnoreCase) == 0;
+            set => _writeableType = value ? "applicationData" : null;
         }
 
         /// <summary>
         /// Specifies the set of proxy stubs referenced by the manifest for isolated applications and Reg-Free COM.
         /// </summary>
         [XmlIgnore]
-        public ProxyStub[] ProxyStubs
-        {
-            get { return _proxyStubs; }
-        }
+        public ProxyStub[] ProxyStubs => _proxyStubs;
 
-        protected internal override string SortName
-        {
-            get { return TargetPath; }
-        }
+        protected internal override string SortName => TargetPath;
 
         /// <summary>
         /// Specifies the set of type libraries referenced by the manifest.
         /// </summary>
         [XmlIgnore]
-        public TypeLib[] TypeLibs
-        {
-            get { return _typeLibs; }
-        }
+        public TypeLib[] TypeLibs => _typeLibs;
 
         #region " XmlSerializer "
 
@@ -112,8 +108,8 @@ public TypeLib[] TypeLibs
         [XmlArray("ComClasses")]
         public ComClass[] XmlComClasses
         {
-            get { return _comClasses; }
-            set { _comClasses = value; }
+            get => _comClasses;
+            set => _comClasses = value;
         }
 
         [Browsable(false)]
@@ -121,8 +117,8 @@ public ComClass[] XmlComClasses
         [XmlArray("ProxyStubs")]
         public ProxyStub[] XmlProxyStubs
         {
-            get { return _proxyStubs; }
-            set { _proxyStubs = value; }
+            get => _proxyStubs;
+            set => _proxyStubs = value;
         }
 
         [Browsable(false)]
@@ -130,8 +126,8 @@ public ProxyStub[] XmlProxyStubs
         [XmlArray("TypeLibs")]
         public TypeLib[] XmlTypeLibs
         {
-            get { return _typeLibs; }
-            set { _typeLibs = value; }
+            get => _typeLibs;
+            set => _typeLibs = value;
         }
 
         [Browsable(false)]
@@ -139,8 +135,8 @@ public TypeLib[] XmlTypeLibs
         [XmlAttribute("WriteableType")]
         public string XmlWriteableType
         {
-            get { return _writeableType; }
-            set { _writeableType = value; }
+            get => _writeableType;
+            set => _writeableType = value;
         }
 
         #endregion
@@ -169,34 +165,19 @@ internal ComClass(Guid tlbId, Guid clsId, string progId, string threadingModel,
         }
 
         [XmlIgnore]
-        public string ClsId
-        {
-            get { return _clsid; }
-        }
+        public string ClsId => _clsid;
 
         [XmlIgnore]
-        public string Description
-        {
-            get { return _description; }
-        }
+        public string Description => _description;
 
         [XmlIgnore]
-        public string ProgId
-        {
-            get { return _progid; }
-        }
+        public string ProgId => _progid;
 
         [XmlIgnore]
-        public string ThreadingModel
-        {
-            get { return _threadingModel; }
-        }
+        public string ThreadingModel => _threadingModel;
 
         [XmlIgnore]
-        public string TlbId
-        {
-            get { return _tlbid; }
-        }
+        public string TlbId => _tlbid;
 
         #region " XmlSerializer "
 
@@ -205,8 +186,8 @@ public string TlbId
         [XmlAttribute("Clsid")]
         public string XmlClsId
         {
-            get { return _clsid; }
-            set { _clsid = value; }
+            get => _clsid;
+            set => _clsid = value;
         }
 
         [Browsable(false)]
@@ -214,8 +195,8 @@ public string XmlClsId
         [XmlAttribute("Description")]
         public string XmlDescription
         {
-            get { return _description; }
-            set { _description = value; }
+            get => _description;
+            set => _description = value;
         }
 
         [Browsable(false)]
@@ -223,8 +204,8 @@ public string XmlDescription
         [XmlAttribute("Progid")]
         public string XmlProgId
         {
-            get { return _progid; }
-            set { _progid = value; }
+            get => _progid;
+            set => _progid = value;
         }
 
         [Browsable(false)]
@@ -232,8 +213,8 @@ public string XmlProgId
         [XmlAttribute("ThreadingModel")]
         public string XmlThreadingModel
         {
-            get { return _threadingModel; }
-            set { _threadingModel = value; }
+            get => _threadingModel;
+            set => _threadingModel = value;
         }
 
         [Browsable(false)]
@@ -241,8 +222,8 @@ public string XmlThreadingModel
         [XmlAttribute("Tlbid")]
         public string XmlTlbId
         {
-            get { return _tlbid; }
-            set { _tlbid = value; }
+            get => _tlbid;
+            set => _tlbid = value;
         }
 
         #endregion
@@ -271,48 +252,44 @@ internal TypeLib(Guid tlbId, Version version, string helpDirectory, int resource
         }
 
         [XmlIgnore]
-        public string Flags
-        {
-            get { return _flags; }
-        }
+        public string Flags => _flags;
 
         private static string FlagsFromInt(int flags)
         {
-            StringBuilder sb = new StringBuilder();
+            var sb = new StringBuilder();
             if ((flags & 1) != 0)
+            {
                 sb.Append("RESTRICTED,");
+            }
+
             if ((flags & 2) != 0)
+            {
                 sb.Append("CONTROL,");
+            }
+
             if ((flags & 4) != 0)
+            {
                 sb.Append("HIDDEN,");
+            }
+
             if ((flags & 8) != 0)
+            {
                 sb.Append("HASDISKIMAGE,");
+            }
             return sb.ToString().TrimEnd(',');
         }
 
         [XmlIgnore]
-        public string HelpDirectory
-        {
-            get { return _helpDirectory; }
-        }
+        public string HelpDirectory => _helpDirectory;
 
         [XmlIgnore]
-        public string ResourceId
-        {
-            get { return _resourceid; }
-        }
+        public string ResourceId => _resourceid;
 
         [XmlIgnore]
-        public string TlbId
-        {
-            get { return _tlbid; }
-        }
+        public string TlbId => _tlbid;
 
         [XmlIgnore]
-        public string Version
-        {
-            get { return _version; }
-        }
+        public string Version => _version;
 
         #region " XmlSerializer "
 
@@ -321,8 +298,8 @@ public string Version
         [XmlAttribute("Flags")]
         public string XmlFlags
         {
-            get { return _flags; }
-            set { _flags = value; }
+            get => _flags;
+            set => _flags = value;
         }
 
         [Browsable(false)]
@@ -330,8 +307,8 @@ public string XmlFlags
         [XmlAttribute("HelpDir")]
         public string XmlHelpDirectory
         {
-            get { return _helpDirectory; }
-            set { _helpDirectory = value; }
+            get => _helpDirectory;
+            set => _helpDirectory = value;
         }
 
         [Browsable(false)]
@@ -339,8 +316,8 @@ public string XmlHelpDirectory
         [XmlAttribute("ResourceId")]
         public string XmlResourceId
         {
-            get { return _resourceid; }
-            set { _resourceid = value; }
+            get => _resourceid;
+            set => _resourceid = value;
         }
 
         [Browsable(false)]
@@ -348,8 +325,8 @@ public string XmlResourceId
         [XmlAttribute("Tlbid")]
         public string XmlTlbId
         {
-            get { return _tlbid; }
-            set { _tlbid = value; }
+            get => _tlbid;
+            set => _tlbid = value;
         }
 
         [Browsable(false)]
@@ -357,8 +334,8 @@ public string XmlTlbId
         [XmlAttribute("Version")]
         public string XmlVersion
         {
-            get { return _version; }
-            set { _version = value; }
+            get => _version;
+            set => _version = value;
         }
 
         #endregion
@@ -381,10 +358,7 @@ public WindowClass(string name, bool versioned)
         }
 
         [XmlIgnore]
-        public string Name
-        {
-            get { return _name; }
-        }
+        public string Name => _name;
 
         [XmlIgnore]
         public bool Versioned
@@ -392,11 +366,15 @@ public bool Versioned
             get
             {
                 if (String.Compare(_versioned, "yes", StringComparison.OrdinalIgnoreCase) == 0)
+                {
                     return true;
+                }
+
                 if (String.Compare(_versioned, "no", StringComparison.OrdinalIgnoreCase) == 0)
+                {
                     return false;
-                else
-                    return true;
+                }
+                return true;
             }
         }
 
@@ -407,8 +385,8 @@ public bool Versioned
         [XmlAttribute("Name")]
         public string XmlName
         {
-            get { return _name; }
-            set { _name = value; }
+            get => _name;
+            set => _name = value;
         }
 
         [Browsable(false)]
@@ -416,8 +394,8 @@ public string XmlName
         [XmlAttribute("Versioned")]
         public string XmlVersioned
         {
-            get { return _versioned; }
-            set { _versioned = value; }
+            get => _versioned;
+            set => _versioned = value;
         }
 
         #endregion
@@ -432,39 +410,20 @@ public class ProxyStub
         private string _numMethods;
         private string _tlbid;
 
-        public ProxyStub()
-        {
-        }
-
         [XmlIgnore]
-        public string BaseInterface
-        {
-            get { return _baseInterface; }
-        }
+        public string BaseInterface => _baseInterface;
 
         [XmlIgnore]
-        public string IID
-        {
-            get { return _iid; }
-        }
+        public string IID => _iid;
 
         [XmlIgnore]
-        public string Name
-        {
-            get { return _name; }
-        }
+        public string Name => _name;
 
         [XmlIgnore]
-        public string NumMethods
-        {
-            get { return _numMethods; }
-        }
+        public string NumMethods => _numMethods;
 
         [XmlIgnore]
-        public string TlbId
-        {
-            get { return _tlbid; }
-        }
+        public string TlbId => _tlbid;
 
         #region " XmlSerializer "
 
@@ -473,8 +432,8 @@ public string TlbId
         [XmlAttribute("BaseInterface")]
         public string XmlBaseInterface
         {
-            get { return _baseInterface; }
-            set { _baseInterface = value; }
+            get => _baseInterface;
+            set => _baseInterface = value;
         }
 
         [Browsable(false)]
@@ -482,8 +441,8 @@ public string XmlBaseInterface
         [XmlAttribute("Iid")]
         public string XmlIID
         {
-            get { return _iid; }
-            set { _iid = value; }
+            get => _iid;
+            set => _iid = value;
         }
 
         [Browsable(false)]
@@ -491,8 +450,8 @@ public string XmlIID
         [XmlAttribute("Name")]
         public string XmlName
         {
-            get { return _name; }
-            set { _name = value; }
+            get => _name;
+            set => _name = value;
         }
 
         [Browsable(false)]
@@ -500,8 +459,8 @@ public string XmlName
         [XmlAttribute("NumMethods")]
         public string XmlNumMethods
         {
-            get { return _numMethods; }
-            set { _numMethods = value; }
+            get => _numMethods;
+            set => _numMethods = value;
         }
 
         [Browsable(false)]
@@ -509,8 +468,8 @@ public string XmlNumMethods
         [XmlAttribute("Tlbid")]
         public string XmlTlbId
         {
-            get { return _tlbid; }
-            set { _tlbid = value; }
+            get => _tlbid;
+            set => _tlbid = value;
         }
 
         #endregion
diff --git a/src/Tasks/ManifestUtil/FileReferenceCollection.cs b/src/Tasks/ManifestUtil/FileReferenceCollection.cs
index c21c81cdc6e..d044fba2cbc 100644
--- a/src/Tasks/ManifestUtil/FileReferenceCollection.cs
+++ b/src/Tasks/ManifestUtil/FileReferenceCollection.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections;
+using System.Collections.Generic;
 using System.Runtime.InteropServices;
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
@@ -13,12 +14,14 @@ namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
     [ComVisible(false)]
     public sealed class FileReferenceCollection : IEnumerable
     {
-        private ArrayList _list = new ArrayList();
+        private readonly List<FileReference> _list = new List<FileReference>();
 
         internal FileReferenceCollection(FileReference[] array)
         {
             if (array == null)
+            {
                 return;
+            }
             _list.AddRange(array);
         }
 
@@ -27,10 +30,7 @@ internal FileReferenceCollection(FileReference[] array)
         /// </summary>
         /// <param name="index">The zero-based index of the entry to get.</param>
         /// <returns>The file reference instance.</returns>
-        public FileReference this[int index]
-        {
-            get { return (FileReference)_list[index]; }
-        }
+        public FileReference this[int index] => _list[index];
 
         /// <summary>
         /// Adds the specified assembly reference to the collection.
@@ -45,7 +45,7 @@ public FileReference Add(string path)
         /// <summary>
         /// Adds the specified assembly reference to the collection.
         /// </summary>
-        /// <param name="path">The specified file reference to add.</param>
+        /// <param name="file">The specified file reference to add.</param>
         /// <returns>The added file reference instance.</returns>
         public FileReference Add(FileReference file)
         {
@@ -64,10 +64,7 @@ public void Clear()
         /// <summary>
         /// Gets the number of objects contained in the collection.
         /// </summary>
-        public int Count
-        {
-            get { return _list.Count; }
-        }
+        public int Count => _list.Count;
 
         /// <summary>
         /// Finds a file reference in the collection by the specified target path.
@@ -77,10 +74,16 @@ public int Count
         public FileReference FindTargetPath(string targetPath)
         {
             if (String.IsNullOrEmpty(targetPath))
+            {
                 return null;
+            }
             foreach (FileReference f in _list)
+            {
                 if (String.Compare(targetPath, f.TargetPath, StringComparison.OrdinalIgnoreCase) == 0)
+                {
                     return f;
+                }
+            }
             return null;
         }
 
@@ -96,7 +99,7 @@ public IEnumerator GetEnumerator()
         /// <summary>
         /// Removes the specified file reference from the collection.
         /// </summary>
-        /// <param name="assemblyReference">The specified file reference to remove.</param>
+        /// <param name="file">The specified file reference to remove.</param>
         public void Remove(FileReference file)
         {
             _list.Remove(file);
@@ -104,7 +107,7 @@ public void Remove(FileReference file)
 
         internal FileReference[] ToArray()
         {
-            return (FileReference[])_list.ToArray(typeof(FileReference));
+            return _list.ToArray();
         }
     }
 }
diff --git a/src/Tasks/ManifestUtil/Manifest.cs b/src/Tasks/ManifestUtil/Manifest.cs
index f0e5c3bc2ed..771ae51b7dc 100644
--- a/src/Tasks/ManifestUtil/Manifest.cs
+++ b/src/Tasks/ManifestUtil/Manifest.cs
@@ -6,12 +6,8 @@
 using System.Collections.Generic;
 using System.ComponentModel;
 using System.Diagnostics;
-using System.Globalization;
 using System.IO;
-using System.Reflection;
 using System.Runtime.InteropServices;
-using System.Security;
-using System.Text;
 using System.Xml;
 using System.Xml.Serialization;
 using Microsoft.Build.Shared;
@@ -24,17 +20,17 @@ namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
     [ComVisible(false)]
     public abstract class Manifest
     {
-        private AssemblyIdentity _assemblyIdentity = null;
-        private AssemblyReference[] _assemblyReferences = null;
-        private string _description = null;
-        private FileReference[] _fileReferences = null;
-        private string _sourcePath = null;
-        private Stream _inputStream = null;
-        private FileReferenceCollection _fileReferenceList = null;
-        private AssemblyReferenceCollection _assemblyReferenceList = null;
+        private AssemblyIdentity _assemblyIdentity;
+        private AssemblyReference[] _assemblyReferences;
+        private string _description;
+        private FileReference[] _fileReferences;
+        private string _sourcePath;
+        private Stream _inputStream;
+        private FileReferenceCollection _fileReferenceList;
+        private AssemblyReferenceCollection _assemblyReferenceList;
         private readonly OutputMessageCollection _outputMessages = new OutputMessageCollection();
-        private bool _treatUnfoundNativeAssembliesAsPrerequisites = false;
-        private bool _readOnly = false;
+        private bool _treatUnfoundNativeAssembliesAsPrerequisites;
+        private bool _readOnly;
 
         protected internal Manifest() // only internal classes can extend this class
         {
@@ -46,28 +42,16 @@ protected internal Manifest() // only internal classes can extend this class
         [XmlIgnore]
         public AssemblyIdentity AssemblyIdentity
         {
-            get
-            {
-                if (_assemblyIdentity == null)
-                    _assemblyIdentity = new AssemblyIdentity();
-                return _assemblyIdentity;
-            }
-            set { _assemblyIdentity = value; }
+            get => _assemblyIdentity ?? (_assemblyIdentity = new AssemblyIdentity());
+            set => _assemblyIdentity = value;
         }
 
         /// <summary>
         /// Specifies the set of assemblies referenced by the manifest.
         /// </summary>
         [XmlIgnore]
-        public AssemblyReferenceCollection AssemblyReferences
-        {
-            get
-            {
-                if (_assemblyReferenceList == null)
-                    _assemblyReferenceList = new AssemblyReferenceCollection(_assemblyReferences);
-                return _assemblyReferenceList;
-            }
-        }
+        public AssemblyReferenceCollection AssemblyReferences => _assemblyReferenceList ??
+                                                                 (_assemblyReferenceList = new AssemblyReferenceCollection(_assemblyReferences));
 
         private void CollectionToArray()
         {
@@ -89,8 +73,8 @@ private void CollectionToArray()
         [XmlIgnore]
         public string Description
         {
-            get { return _description; }
-            set { _description = value; }
+            get => _description;
+            set => _description = value;
         }
 
         /// <summary>
@@ -107,15 +91,7 @@ public virtual AssemblyReference EntryPoint
         /// Specifies the set of files referenced by the manifest.
         /// </summary>
         [XmlIgnore]
-        public FileReferenceCollection FileReferences
-        {
-            get
-            {
-                if (_fileReferenceList == null)
-                    _fileReferenceList = new FileReferenceCollection(_fileReferences);
-                return _fileReferenceList;
-            }
-        }
+        public FileReferenceCollection FileReferences => _fileReferenceList ?? (_fileReferenceList = new FileReferenceCollection(_fileReferences));
 
         /// <summary>
         /// The input stream from which the manifest was read.
@@ -124,8 +100,8 @@ public FileReferenceCollection FileReferences
         [XmlIgnore]
         public Stream InputStream
         {
-            get { return _inputStream; }
-            set { _inputStream = value; }
+            get => _inputStream;
+            set => _inputStream = value;
         }
 
         internal virtual void OnAfterLoad()
@@ -142,10 +118,7 @@ internal virtual void OnBeforeSave()
         /// Contains a collection of current error and warning messages.
         /// </summary>
         [XmlIgnore]
-        public OutputMessageCollection OutputMessages
-        {
-            get { return _outputMessages; }
-        }
+        public OutputMessageCollection OutputMessages => _outputMessages;
 
         /// <summary>
         /// Specifies whether the manifest is operating in read-only or read-write mode.
@@ -157,45 +130,59 @@ public OutputMessageCollection OutputMessages
         [XmlIgnore]
         public bool ReadOnly
         {
-            get { return _readOnly; }
-            set { _readOnly = value; }
+            get => _readOnly;
+            set => _readOnly = value;
         }
 
-        private bool ResolveAssembly(AssemblyReference a, string[] searchPaths)
+        private static bool ResolveAssembly(AssemblyReference a, string[] searchPaths)
         {
             if (a == null)
+            {
                 return false;
+            }
 
             a.ResolvedPath = ResolvePath(a.SourcePath, searchPaths);
             if (!String.IsNullOrEmpty(a.ResolvedPath))
+            {
                 return true;
+            }
 
             if (a.AssemblyIdentity != null)
             {
                 a.ResolvedPath = a.AssemblyIdentity.Resolve(searchPaths);
                 if (!String.IsNullOrEmpty(a.ResolvedPath))
+                {
                     return true;
+                }
             }
 
             a.ResolvedPath = ResolvePath(a.TargetPath, searchPaths);
             if (!String.IsNullOrEmpty(a.ResolvedPath))
+            {
                 return true;
+            }
 
             return false;
         }
 
-        private bool ResolveFile(BaseReference f, string[] searchPaths)
+        private static bool ResolveFile(BaseReference f, string[] searchPaths)
         {
             if (f == null)
+            {
                 return false;
+            }
 
             f.ResolvedPath = ResolvePath(f.SourcePath, searchPaths);
             if (!String.IsNullOrEmpty(f.ResolvedPath))
+            {
                 return true;
+            }
 
             f.ResolvedPath = ResolvePath(f.TargetPath, searchPaths);
             if (!String.IsNullOrEmpty(f.ResolvedPath))
+            {
                 return true;
+            }
 
             return false;
         }
@@ -209,9 +196,14 @@ public void ResolveFiles()
         {
             string defaultDir = String.Empty;
             if (!String.IsNullOrEmpty(_sourcePath))
+            {
                 defaultDir = Path.GetDirectoryName(_sourcePath);
+            }
+
             if (!Path.IsPathRooted(defaultDir))
+            {
                 defaultDir = Path.Combine(Directory.GetCurrentDirectory(), defaultDir);
+            }
             string[] searchPaths = { defaultDir };
             ResolveFiles(searchPaths);
         }
@@ -225,7 +217,7 @@ public void ResolveFiles()
         public void ResolveFiles(string[] searchPaths)
         {
             if (searchPaths == null)
-                throw new ArgumentNullException("searchPaths");
+                throw new ArgumentNullException(nameof(searchPaths));
             CollectionToArray();
             ResolveFiles_1(searchPaths);
             ResolveFiles_2(searchPaths);
@@ -234,8 +226,11 @@ public void ResolveFiles(string[] searchPaths)
         private void ResolveFiles_1(string[] searchPaths)
         {
             if (_assemblyReferences != null)
+            {
                 foreach (AssemblyReference a in _assemblyReferences)
+                {
                     if (!a.IsPrerequisite || a.AssemblyIdentity == null)
+                    {
                         if (!ResolveAssembly(a, searchPaths))
                         {
                             if (_treatUnfoundNativeAssembliesAsPrerequisites && a.ReferenceType == AssemblyReferenceType.NativeAssembly)
@@ -250,17 +245,26 @@ private void ResolveFiles_1(string[] searchPaths)
                                 // reporting the manifest is awkward and sometimes looks like a bug.
                                 // So we use the ReadOnly flag to tell the difference between the two cases...
                                 if (_readOnly)
-                                    OutputMessages.AddErrorMessage("GenerateManifest.ResolveFailedInReadOnlyMode", a.ToString(), this.ToString());
+                                {
+                                    OutputMessages.AddErrorMessage("GenerateManifest.ResolveFailedInReadOnlyMode", a.ToString(), ToString());
+                                }
                                 else
+                                {
                                     OutputMessages.AddErrorMessage("GenerateManifest.ResolveFailedInReadWriteMode", a.ToString());
+                                }
                             }
                         }
+                    }
+                }
+            }
         }
 
         private void ResolveFiles_2(string[] searchPaths)
         {
             if (_fileReferences != null)
+            {
                 foreach (FileReference f in _fileReferences)
+                {
                     if (!ResolveFile(f, searchPaths))
                     {
                         // When we're only reading a manifest (i.e. from ResolveNativeReference task), it's
@@ -269,44 +273,64 @@ private void ResolveFiles_2(string[] searchPaths)
                         // reporting the manifest is awkward and sometimes looks like a bug.
                         // So we use the ReadOnly flag to tell the difference between the two cases...
                         if (_readOnly)
+                        {
                             OutputMessages.AddErrorMessage("GenerateManifest.ResolveFailedInReadOnlyMode", f.ToString(), this.ToString());
+                        }
                         else
+                        {
                             OutputMessages.AddErrorMessage("GenerateManifest.ResolveFailedInReadWriteMode", f.ToString());
+                        }
                     }
+                }
+            }
         }
 
-        private string ResolvePath(string path, string[] searchPaths)
+        private static string ResolvePath(string path, string[] searchPaths)
         {
             if (String.IsNullOrEmpty(path))
+            {
                 return null;
+            }
             if (Path.IsPathRooted(path))
             {
                 if (File.Exists(path))
+                {
                     return path;
-                else
-                    return null;
+                }
+                return null;
             }
+
             if (searchPaths == null)
+            {
                 return null;
+            }
             foreach (string searchPath in searchPaths)
+            {
                 if (!String.IsNullOrEmpty(searchPath))
                 {
                     string resolvedPath = Path.Combine(searchPath, path);
                     resolvedPath = Path.GetFullPath(resolvedPath);
                     if (File.Exists(resolvedPath))
+                    {
                         return resolvedPath;
+                    }
                 }
+            }
             return null;
         }
 
         private void SortFiles()
         {
             CollectionToArray();
-            ReferenceComparer comparer = new ReferenceComparer();
+            var comparer = new ReferenceComparer();
             if (_assemblyReferences != null)
+            {
                 Array.Sort(_assemblyReferences, comparer);
+            }
             if (_fileReferences != null)
+            {
                 Array.Sort(_fileReferences, comparer);
+            }
         }
 
         /// <summary>
@@ -315,29 +339,25 @@ private void SortFiles()
         [XmlIgnore]
         public string SourcePath
         {
-            get { return _sourcePath; }
-            set { _sourcePath = value; }
+            get => _sourcePath;
+            set => _sourcePath = value;
         }
 
         public override string ToString()
         {
-            if (!String.IsNullOrEmpty(_sourcePath))
-                return _sourcePath;
-            else
-                return AssemblyIdentity.ToString();
+            return !String.IsNullOrEmpty(_sourcePath) ? _sourcePath : AssemblyIdentity.ToString();
         }
 
         internal bool TreatUnfoundNativeAssembliesAsPrerequisites
         {
-            get { return _treatUnfoundNativeAssembliesAsPrerequisites; }
-            set { _treatUnfoundNativeAssembliesAsPrerequisites = value; }
+            get => _treatUnfoundNativeAssembliesAsPrerequisites;
+            set => _treatUnfoundNativeAssembliesAsPrerequisites = value;
         }
 
         internal static void UpdateEntryPoint(string inputPath, string outputPath, string updatedApplicationPath, string applicationManifestPath, string targetFrameworkVersion)
         {
-            XmlDocument document = new XmlDocument();
-            XmlReaderSettings xrSettings = new XmlReaderSettings();
-            xrSettings.DtdProcessing = DtdProcessing.Ignore;
+            var document = new XmlDocument();
+            var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
             using (XmlReader xr = XmlReader.Create(inputPath, xrSettings))
             {
                 document.Load(xr);
@@ -351,24 +371,29 @@ internal static void UpdateEntryPoint(string inputPath, string outputPath, strin
             {
                 codeBaseNode = document.SelectSingleNode(xpath, nsmgr);
                 if (codeBaseNode != null)
+                {
                     break;
+                }
             }
+
             if (codeBaseNode == null)
+            {
                 throw new InvalidOperationException(String.Format(System.Globalization.CultureInfo.InvariantCulture, "XPath not found: {0}", XPaths.codebasePaths[0]));
+            }
 
             codeBaseNode.Value = updatedApplicationPath;
 
             // update Public key token of application manifest
             XmlNode publicKeyTokenNode = ((XmlAttribute)codeBaseNode).OwnerElement.SelectSingleNode(XPaths.dependencyPublicKeyTokenAttribute, nsmgr);
             if (publicKeyTokenNode == null)
+            {
                 throw new InvalidOperationException(String.Format(System.Globalization.CultureInfo.InvariantCulture, "XPath not found: {0}", XPaths.dependencyPublicKeyTokenAttribute));
+            }
 
             publicKeyTokenNode.Value = appManifest.PublicKeyToken;
 
             // update hash of application manifest
-            string hash;
-            long size;
-            Util.GetFileInfo(applicationManifestPath, targetFrameworkVersion, out hash, out size);
+            Util.GetFileInfo(applicationManifestPath, targetFrameworkVersion, out string hash, out long size);
 
             // Hash node may not be present with optional signing
             XmlNode hashNode = ((XmlAttribute)codeBaseNode).OwnerElement.SelectSingleNode(XPaths.hashElement, nsmgr);
@@ -380,7 +405,9 @@ internal static void UpdateEntryPoint(string inputPath, string outputPath, strin
             // update file size of application manifest
             XmlAttribute sizeAttribute = ((XmlAttribute)codeBaseNode).OwnerElement.Attributes[XmlUtil.TrimPrefix(XPaths.fileSizeAttribute)];
             if (sizeAttribute == null)
+            {
                 throw new InvalidOperationException(String.Format(System.Globalization.CultureInfo.InvariantCulture, "XPath not found: {0}", XPaths.fileSizeAttribute));
+            }
 
             sizeAttribute.Value = size.ToString(System.Globalization.CultureInfo.InvariantCulture);
 
@@ -390,9 +417,12 @@ internal static void UpdateEntryPoint(string inputPath, string outputPath, strin
         private void UpdateAssemblyReference(AssemblyReference a, string targetFrameworkVersion)
         {
             if (a.IsVirtual)
+            {
                 return;
+            }
 
             if (a.AssemblyIdentity == null)
+            {
                 switch (a.ReferenceType)
                 {
                     case AssemblyReferenceType.ClickOnceManifest:
@@ -408,8 +438,12 @@ private void UpdateAssemblyReference(AssemblyReference a, string targetFramework
                         a.AssemblyIdentity = AssemblyIdentity.FromFile(a.ResolvedPath);
                         break;
                 }
+            }
+
             if (!a.IsPrerequisite)
+            {
                 UpdateFileReference(a, targetFrameworkVersion);
+            }
 
             // If unspecified assembly type then let's figure out what it actually is...
             if (a.ReferenceType == AssemblyReferenceType.Unspecified)
@@ -423,9 +457,13 @@ private void UpdateAssemblyReference(AssemblyReference a, string targetFramework
                 else if (!String.IsNullOrEmpty(a.ResolvedPath))
                 {
                     if (PathUtil.IsNativeAssembly(a.ResolvedPath))
+                    {
                         a.ReferenceType = AssemblyReferenceType.NativeAssembly;
+                    }
                     else
+                    {
                         a.ReferenceType = AssemblyReferenceType.ManagedAssembly;
+                    }
                 }
                 // there's one other way we can tell, Type="win32" references are always native...
                 else if (a.AssemblyIdentity != null && String.Equals(a.AssemblyIdentity.Type, "win32", StringComparison.OrdinalIgnoreCase))
@@ -438,10 +476,12 @@ private void UpdateAssemblyReference(AssemblyReference a, string targetFramework
         private static void UpdateFileReference(BaseReference f, string targetFrameworkVersion)
         {
             if (String.IsNullOrEmpty(f.ResolvedPath))
+            {
                 throw new FileNotFoundException(null, f.SourcePath);
+            }
+
             string hash;
             long size;
-
             if (string.IsNullOrEmpty(targetFrameworkVersion))
             {
                 Util.GetFileInfo(f.ResolvedPath, out hash, out size);
@@ -455,9 +495,13 @@ private static void UpdateFileReference(BaseReference f, string targetFrameworkV
             if (String.IsNullOrEmpty(f.TargetPath))
             {
                 if (!String.IsNullOrEmpty(f.SourcePath))
+                {
                     f.TargetPath = BaseReference.GetDefaultTargetPath(f.SourcePath);
+                }
                 else
+                {
                     f.TargetPath = BaseReference.GetDefaultTargetPath(Path.GetFileName(f.ResolvedPath));
+                }
             }
         }
 
@@ -484,7 +528,9 @@ public void UpdateFileInfo(string targetFrameworkVersion)
         private void UpdateFileInfoImpl(string targetFrameworkVersion)
         {
             if (_assemblyReferences != null)
+            {
                 foreach (AssemblyReference a in _assemblyReferences)
+                {
                     if (!String.IsNullOrEmpty(a.ResolvedPath)) // only check resolved items...
                     {
                         try
@@ -496,24 +542,30 @@ private void UpdateFileInfoImpl(string targetFrameworkVersion)
                                 OutputMessages.AddErrorMessage("GenerateManifest.General", exception.Message);
                             }
                         }
-                        catch (System.Exception e)
+                        catch (Exception e)
                         {
                             OutputMessages.AddErrorMessage("GenerateManifest.General", e.Message);
                         }
                     }
+                }
+            }
             if (_fileReferences != null)
+            {
                 foreach (FileReference f in _fileReferences)
+                {
                     if (!String.IsNullOrEmpty(f.ResolvedPath)) // only check resolved items...
                     {
                         try
                         {
                             UpdateFileReference(f, targetFrameworkVersion);
                         }
-                        catch (System.Exception e)
+                        catch (Exception e)
                         {
                             OutputMessages.AddErrorMessage("GenerateManifest.General", e.Message);
                         }
                     }
+                }
+            }
         }
 
         /// <summary>
@@ -528,9 +580,11 @@ public virtual void Validate()
         private void ValidateReferences()
         {
             if (AssemblyReferences.Count <= 1)
+            {
                 return;
+            }
 
-            Dictionary<string, NGen<bool>> identityList = new Dictionary<string, NGen<bool>>();
+            var identityList = new Dictionary<string, NGen<bool>>();
             foreach (AssemblyReference assembly in AssemblyReferences)
             {
                 if (assembly.AssemblyIdentity != null)
@@ -551,38 +605,53 @@ private void ValidateReferences()
 
                 // Check that resolved assembly identity matches filename...
                 if (!assembly.IsPrerequisite)
+                {
                     if (assembly.AssemblyIdentity != null)
-                        if (!String.Equals(assembly.AssemblyIdentity.Name, Path.GetFileNameWithoutExtension(assembly.TargetPath), StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (!String.Equals(
+                            assembly.AssemblyIdentity.Name,
+                            Path.GetFileNameWithoutExtension(assembly.TargetPath),
+                            StringComparison.OrdinalIgnoreCase))
+                        {
                             OutputMessages.AddWarningMessage("GenerateManifest.IdentityFileNameMismatch", assembly.ToString(), assembly.AssemblyIdentity.Name, assembly.AssemblyIdentity.Name + Path.GetExtension(assembly.TargetPath));
+                        }
+                    }
+                }
             }
         }
 
-
-
         protected void ValidatePlatform()
         {
             foreach (AssemblyReference assembly in AssemblyReferences)
+            {
                 if (IsMismatchedPlatform(assembly))
+                {
                     OutputMessages.AddWarningMessage("GenerateManifest.PlatformMismatch", assembly.ToString());
+                }
+            }
         }
 
-
-
         // Determines whether the platform of the specified assembly reference is mismatched with the applicaion's platform.
         private bool IsMismatchedPlatform(AssemblyReference assembly)
         {
             // Never flag the "Microsoft.CommonLanguageRuntime" dependency as a mismatch...
             if (assembly.IsVirtual)
+            {
                 return false;
+            }
             // Can't tell anything if either of these are not resolved...
             if (AssemblyIdentity == null || assembly.AssemblyIdentity == null)
+            {
                 return false;
+            }
 
             if (AssemblyIdentity.IsNeutralPlatform)
             {
                 // If component is a native assembly then it is non-platform neutral by definition, so always flag as a mismatch...
                 if (assembly.ReferenceType == AssemblyReferenceType.NativeAssembly)
+                {
                     return true;
+                }
                 // Otherwise flag component as a mismatch only if it's not also platform neutral...
                 return !assembly.AssemblyIdentity.IsNeutralPlatform;
             }
@@ -594,7 +663,9 @@ private bool IsMismatchedPlatform(AssemblyReference assembly)
                 {
                     // If application IS NOT platform neutral but the component is, then component shouldn't be flagged as a mismatch...
                     if (assembly.AssemblyIdentity.IsNeutralPlatform)
+                    {
                         return false;
+                    }
                 }
 
                 // Either we are looking at the entry point assembly or the assembly is not platform neutral. 
@@ -611,8 +682,8 @@ private bool IsMismatchedPlatform(AssemblyReference assembly)
         [XmlElement("AssemblyIdentity")]
         public AssemblyIdentity XmlAssemblyIdentity
         {
-            get { return _assemblyIdentity; }
-            set { _assemblyIdentity = value; }
+            get => _assemblyIdentity;
+            set => _assemblyIdentity = value;
         }
 
         [Browsable(false)]
@@ -620,8 +691,8 @@ public AssemblyIdentity XmlAssemblyIdentity
         [XmlArray("AssemblyReferences")]
         public AssemblyReference[] XmlAssemblyReferences
         {
-            get { return _assemblyReferences; }
-            set { _assemblyReferences = value; }
+            get => _assemblyReferences;
+            set => _assemblyReferences = value;
         }
 
         [Browsable(false)]
@@ -629,8 +700,8 @@ public AssemblyReference[] XmlAssemblyReferences
         [XmlAttribute("Description")]
         public string XmlDescription
         {
-            get { return _description; }
-            set { _description = value; }
+            get => _description;
+            set => _description = value;
         }
 
         [Browsable(false)]
@@ -638,8 +709,8 @@ public string XmlDescription
         [XmlArray("FileReferences")]
         public FileReference[] XmlFileReferences
         {
-            get { return _fileReferences; }
-            set { _fileReferences = value; }
+            get => _fileReferences;
+            set => _fileReferences = value;
         }
 
         [Browsable(false)]
diff --git a/src/Tasks/ManifestUtil/ManifestFormatter.cs b/src/Tasks/ManifestUtil/ManifestFormatter.cs
index 12cf21a64a7..8a2a8fa0ddb 100644
--- a/src/Tasks/ManifestUtil/ManifestFormatter.cs
+++ b/src/Tasks/ManifestUtil/ManifestFormatter.cs
@@ -6,7 +6,6 @@
 using System.IO;
 using System.Text;
 using System.Xml;
-using System.Xml.Serialization;
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
 {
@@ -16,15 +15,19 @@ public static Stream Format(Stream input)
         {
             int t1 = Environment.TickCount;
 
-            XmlTextReader r = new XmlTextReader(input);
-            r.DtdProcessing = DtdProcessing.Ignore;
-            r.WhitespaceHandling = WhitespaceHandling.None;
+            var r = new XmlTextReader(input)
+            {
+                DtdProcessing = DtdProcessing.Ignore,
+                WhitespaceHandling = WhitespaceHandling.None
+            };
             XmlNamespaceManager nsmgr = XmlNamespaces.GetNamespaceManager(r.NameTable);
 
-            MemoryStream m = new MemoryStream();
-            XmlTextWriter w = new XmlTextWriter(m, Encoding.UTF8);
-            w.Formatting = Formatting.Indented;
-            w.Indentation = 2;
+            var m = new MemoryStream();
+            var w = new XmlTextWriter(m, Encoding.UTF8)
+            {
+                Formatting = Formatting.Indented,
+                Indentation = 2
+            };
             w.WriteStartDocument();
 
             while (r.Read())
@@ -42,11 +45,21 @@ public static Stream Format(Stream input)
                                 string attributeQName = XmlUtil.GetQName(r, nsmgr);
                                 string xpath = elementQName + "/@" + attributeQName;
                                 // Filter out language="*"
-                                if ((xpath.Equals(XPaths.languageAttribute1, StringComparison.Ordinal) || xpath.Equals(XPaths.languageAttribute2, StringComparison.Ordinal)) && String.Equals(r.Value, "*", StringComparison.Ordinal))
+                                if ((xpath.Equals(XPaths.languageAttribute1, StringComparison.Ordinal) || xpath.Equals(
+                                         XPaths.languageAttribute2,
+                                         StringComparison.Ordinal)) && String.Equals(
+                                        r.Value,
+                                        "*",
+                                        StringComparison.Ordinal))
+                                {
                                     continue;
+                                }
                                 // Filter out attributes with empty values if attribute is on the list...
-                                if (String.IsNullOrEmpty(r.Value) && Array.BinarySearch(XPaths.emptyAttributeList, xpath) >= 0)
+                                if (String.IsNullOrEmpty(r.Value) &&
+                                    Array.BinarySearch(XPaths.emptyAttributeList, xpath) >= 0)
+                                {
                                     continue;
+                                }
                                 w.WriteAttributeString(r.Prefix, r.LocalName, r.NamespaceURI, r.Value);
                             }
 
@@ -54,7 +67,9 @@ public static Stream Format(Stream input)
                         }
 
                         if (r.IsEmptyElement)
+                        {
                             w.WriteEndElement();
+                        }
 
                         break;
 
diff --git a/src/Tasks/ManifestUtil/ManifestReader.cs b/src/Tasks/ManifestUtil/ManifestReader.cs
index a19b3448635..88b5f8d4cc5 100644
--- a/src/Tasks/ManifestUtil/ManifestReader.cs
+++ b/src/Tasks/ManifestUtil/ManifestReader.cs
@@ -24,20 +24,24 @@ internal static ComInfo[] GetComInfo(string path)
             XmlNamespaceManager nsmgr = XmlNamespaces.GetNamespaceManager(document.NameTable);
             string manifestFileName = Path.GetFileName(path);
 
-            List<ComInfo> comInfoList = new List<ComInfo>();
+            var comInfoList = new List<ComInfo>();
             XmlNodeList comNodes = document.SelectNodes(XPaths.comFilesPath, nsmgr);
             foreach (XmlNode comNode in comNodes)
             {
                 XmlNode nameNode = comNode.SelectSingleNode(XPaths.fileNameAttribute, nsmgr);
-                string componentFileName = nameNode != null ? nameNode.Value : null;
+                string componentFileName = nameNode?.Value;
 
                 XmlNodeList clsidNodes = comNode.SelectNodes(XPaths.clsidAttribute, nsmgr);
                 foreach (XmlNode clsidNode in clsidNodes)
+                {
                     comInfoList.Add(new ComInfo(manifestFileName, componentFileName, clsidNode.Value, null));
+                }
 
                 XmlNodeList tlbidNodes = comNode.SelectNodes(XPaths.tlbidAttribute, nsmgr);
                 foreach (XmlNode tlbidNode in tlbidNodes)
+                {
                     comInfoList.Add(new ComInfo(manifestFileName, componentFileName, null, tlbidNode.Value));
+                }
             }
 
             return comInfoList.ToArray();
@@ -50,15 +54,16 @@ private static XmlDocument GetXmlDocument(string path)
                 byte[] buffer = new byte[2];
                 s.Read(buffer, 0, 2);
                 s.Position = 0;
-                XmlDocument document = new XmlDocument();
-                XmlReaderSettings xrSettings = new XmlReaderSettings();
-                xrSettings.DtdProcessing = DtdProcessing.Ignore;
+                var document = new XmlDocument();
+                var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
                 // if first two bytes are "MZ" then we're looking at an .exe or a .dll not a .manifest
                 if ((buffer[0] == 0x4D) && (buffer[1] == 0x5A))
                 {
                     Stream m = EmbeddedManifestReader.Read(path);
                     if (m == null)
+                    {
                         throw new BadImageFormatException(null, path);
+                    }
 
                     using (XmlReader xr = XmlReader.Create(m, xrSettings))
                     {
@@ -81,7 +86,9 @@ private static Manifest ReadEmbeddedManifest(string path)
         {
             Stream m = EmbeddedManifestReader.Read(path);
             if (m == null)
+            {
                 return null;
+            }
 
             Util.WriteLogFile(Path.GetFileNameWithoutExtension(path) + ".embedded.xml", m);
             Manifest manifest = ReadManifest(m, false);
@@ -97,12 +104,16 @@ private static Manifest ReadEmbeddedManifest(string path)
         /// <returns>A base object representation of the manifest. Can be cast to AssemblyManifest, ApplicationManifest, or DeployManifest to access more specific functionality.</returns>
         public static Manifest ReadManifest(string path, bool preserveStream)
         {
-            if (path == null) throw new ArgumentNullException("path");
+            if (path == null) throw new ArgumentNullException(nameof(path));
             string manifestType = null;
             if (path.EndsWith(".application", StringComparison.Ordinal))
+            {
                 manifestType = "DeployManifest";
+            }
             else if (path.EndsWith(".exe.manifest", StringComparison.Ordinal))
+            {
                 manifestType = "ApplicationManifest";
+            }
             return ReadManifest(manifestType, path, preserveStream);
         }
 
@@ -115,7 +126,7 @@ public static Manifest ReadManifest(string path, bool preserveStream)
         /// <returns>A base object representation of the manifest. Can be cast to AssemblyManifest, ApplicationManifest, or DeployManifest to access more specific functionality.</returns>
         public static Manifest ReadManifest(string manifestType, string path, bool preserveStream)
         {
-            Manifest m = null;
+            Manifest m;
             using (Stream s = File.Open(path, FileMode.Open, FileAccess.Read, FileShare.Read))
             {
                 byte[] buffer = new byte[2];
@@ -156,8 +167,8 @@ public static Manifest ReadManifest(Stream input, bool preserveStream)
         public static Manifest ReadManifest(string manifestType, Stream input, bool preserveStream)
         {
             int t1 = Environment.TickCount;
-            string resource = "read2.xsl";
-            Manifest m = null;
+            const string resource = "read2.xsl";
+            Manifest m;
             Stream s;
             if (manifestType != null)
             {
@@ -175,7 +186,7 @@ public static Manifest ReadManifest(string manifestType, Stream input, bool pres
                 m = Deserialize(s);
                 if (m.GetType() == typeof(ApplicationManifest))
                 {
-                    ApplicationManifest am = (ApplicationManifest)m;
+                    var am = (ApplicationManifest)m;
                     am.TrustInfo = new TrustInfo();
                     am.TrustInfo.ReadManifest(input);
                 }
@@ -188,7 +199,9 @@ public static Manifest ReadManifest(string manifestType, Stream input, bool pres
                 s.Position = 0;
                 string n = m.AssemblyIdentity.GetFullName(AssemblyIdentity.FullNameFlags.All);
                 if (String.IsNullOrEmpty(n))
+                {
                     n = m.GetType().Name;
+                }
                 Util.WriteLogFile(n + ".read.xml", s);
             }
             finally
@@ -200,40 +213,27 @@ public static Manifest ReadManifest(string manifestType, Stream input, bool pres
             return m;
         }
 
-        private static Manifest Deserialize(string path)
-        {
-            Manifest m = null;
-
-            using (Stream s = File.Open(path, FileMode.Open, FileAccess.Read, FileShare.Read))
-            {
-                m = Deserialize(s);
-            }
-
-            return m;
-        }
-
         private static Manifest Deserialize(Stream s)
         {
             s.Position = 0;
-            XmlTextReader r = new XmlTextReader(s);
-            r.DtdProcessing = DtdProcessing.Ignore;
+            var r = new XmlTextReader(s) { DtdProcessing = DtdProcessing.Ignore };
 
             do
+            {
                 r.Read();
-            while (r.NodeType != XmlNodeType.Element);
+            } while (r.NodeType != XmlNodeType.Element);
             string ns = typeof(Util).Namespace;
             string tn = String.Format(CultureInfo.InvariantCulture, "{0}.{1}", ns, r.Name);
             Type t = Type.GetType(tn);
             s.Position = 0;
 
-            XmlSerializer xs = new XmlSerializer(t);
+            var xs = new XmlSerializer(t);
 
             int t1 = Environment.TickCount;
-            XmlReaderSettings xrSettings = new XmlReaderSettings();
-            xrSettings.DtdProcessing = DtdProcessing.Ignore;
+            var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
             using (XmlReader xr = XmlReader.Create(s, xrSettings))
             {
-                Manifest m = (Manifest)xs.Deserialize(xr);
+                var m = (Manifest)xs.Deserialize(xr);
                 Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "ManifestReader.Deserialize t={0}", Environment.TickCount - t1));
                 return m;
             }
@@ -242,20 +242,18 @@ private static Manifest Deserialize(Stream s)
 
     internal class ComInfo
     {
-        private readonly string _componentFileName;
-        private readonly string _clsid;
-        private readonly string _manifestFileName;
-        private readonly string _tlbid;
         public ComInfo(string manifestFileName, string componentFileName, string clsid, string tlbid)
         {
-            _componentFileName = componentFileName;
-            _clsid = clsid;
-            _manifestFileName = manifestFileName;
-            _tlbid = tlbid;
+            ComponentFileName = componentFileName;
+            ClsId = clsid;
+            ManifestFileName = manifestFileName;
+            TlbId = tlbid;
         }
-        public string ComponentFileName { get { return _componentFileName; } }
-        public string ClsId { get { return _clsid; } }
-        public string ManifestFileName { get { return _manifestFileName; } }
-        public string TlbId { get { return _tlbid; } }
+        public string ComponentFileName { get; }
+
+        public string ClsId { get; }
+
+        public string ManifestFileName { get; }
+        public string TlbId { get; }
     }
 }
diff --git a/src/Tasks/ManifestUtil/ManifestWriter.cs b/src/Tasks/ManifestUtil/ManifestWriter.cs
index 07302c947e1..dfc220233fd 100644
--- a/src/Tasks/ManifestUtil/ManifestWriter.cs
+++ b/src/Tasks/ManifestUtil/ManifestWriter.cs
@@ -3,11 +3,9 @@
 
 using System;
 using System.Collections;
-using System.Diagnostics;
 using System.Globalization;
 using System.IO;
 using System.Runtime.InteropServices;
-using System.Xml;
 using System.Xml.Serialization;
 using Microsoft.Build.Shared;
 
@@ -22,9 +20,9 @@ public static class ManifestWriter
         private static Stream Serialize(Manifest manifest)
         {
             manifest.OnBeforeSave();
-            MemoryStream m = new MemoryStream();
-            XmlSerializer s = new XmlSerializer(manifest.GetType());
-            StreamWriter w = new StreamWriter(m);
+            var m = new MemoryStream();
+            var s = new XmlSerializer(manifest.GetType());
+            var w = new StreamWriter(m);
 
             int t1 = Environment.TickCount;
             s.Serialize(w, manifest);
@@ -42,9 +40,7 @@ private static Stream Serialize(Manifest manifest)
         /// <param name="manifest">The object representation of the manifest.</param>
         public static void WriteManifest(Manifest manifest)
         {
-            string path = manifest.SourcePath;
-            if (path == null)
-                path = "manifest.xml";
+            string path = manifest.SourcePath ?? "manifest.xml";
             WriteManifest(manifest, path);
         }
 
@@ -61,7 +57,6 @@ public static void WriteManifest(Manifest manifest, string path)
             }
         }
 
-
         /// <summary>
         /// Writes the specified object representation of a manifest to XML.
         /// </summary>
@@ -98,12 +93,14 @@ private static void WriteManifest(Manifest manifest, Stream output, string targe
             Stream s1 = Serialize(manifest);
             string n = manifest.AssemblyIdentity.GetFullName(AssemblyIdentity.FullNameFlags.All);
             if (String.IsNullOrEmpty(n))
+            {
                 n = manifest.GetType().Name;
+            }
             Util.WriteLogFile(n + ".write.0-serialized.xml", s1);
 
-            string resource = null;
+            string resource;
 
-            if (targetframeWorkVersion == null || targetframeWorkVersion.Length == 0 || Util.CompareFrameworkVersions(targetframeWorkVersion, Constants.TargetFrameworkVersion40) <= 0)
+            if (string.IsNullOrEmpty(targetframeWorkVersion) || Util.CompareFrameworkVersions(targetframeWorkVersion, Constants.TargetFrameworkVersion40) <= 0)
             {
                 resource = "write2.xsl";
             }
@@ -112,11 +109,11 @@ private static void WriteManifest(Manifest manifest, Stream output, string targe
                 resource = "write3.xsl";
             }
 
-            Stream s2 = null;
+            Stream s2;
 
             if (manifest.GetType() == typeof(ApplicationManifest))
             {
-                ApplicationManifest am = (ApplicationManifest)manifest;
+                var am = (ApplicationManifest)manifest;
                 if (am.TrustInfo == null)
                 {
                     s2 = XmlUtil.XslTransform(resource, s1);
@@ -147,7 +144,7 @@ private static void WriteManifest(Manifest manifest, Stream output, string targe
                         }
                     }
 
-                    DictionaryEntry arg = new DictionaryEntry("trust-file", temp);
+                    var arg = new DictionaryEntry("trust-file", temp);
                     try
                     {
                         s2 = XmlUtil.XslTransform(resource, s1, arg);
@@ -159,10 +156,12 @@ private static void WriteManifest(Manifest manifest, Stream output, string targe
                 }
             }
             else
+            {
                 s2 = XmlUtil.XslTransform(resource, s1);
+            }
             Util.WriteLogFile(n + ".write.1-transformed.xml", s2);
 
-            Stream s3 = null;
+            Stream s3;
             if (manifest.InputStream == null)
             {
                 s3 = s2;
@@ -170,7 +169,7 @@ private static void WriteManifest(Manifest manifest, Stream output, string targe
             else
             {
                 string temp = Util.WriteTempFile(manifest.InputStream);
-                DictionaryEntry arg = new DictionaryEntry("base-file", temp);
+                var arg = new DictionaryEntry("base-file", temp);
                 try
                 {
                     s3 = XmlUtil.XslTransform("merge.xsl", s2, arg);
diff --git a/src/Tasks/ManifestUtil/MetadataReader.cs b/src/Tasks/ManifestUtil/MetadataReader.cs
index 98478c4d3ad..be17ffc5e97 100644
--- a/src/Tasks/ManifestUtil/MetadataReader.cs
+++ b/src/Tasks/ManifestUtil/MetadataReader.cs
@@ -2,23 +2,19 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Diagnostics.CodeAnalysis;
-using System.Reflection;
-using System.Globalization;
 using System.Runtime.InteropServices;
 using System.Collections.Specialized;
-using Microsoft.Build.Tasks;
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
 {
     internal class MetadataReader : IDisposable
     {
-        private readonly string _path = null;
-        private StringDictionary _attributes = null;
+        private readonly string _path;
+        private StringDictionary _attributes;
 
-        private IMetaDataDispenser _metaDispenser = null;
-        private IMetaDataAssemblyImport _assemblyImport = null;
+        private IMetaDataDispenser _metaDispenser;
+        private IMetaDataAssemblyImport _assemblyImport;
 
         private static Guid s_importerGuid = GetGuidOfType(typeof(IMetaDataImport));
         private static Guid s_refidGuid = GetGuidOfType(typeof(IReferenceIdentity));
@@ -28,38 +24,34 @@ private MetadataReader(string path)
             _path = path;
             // Create the metadata dispenser and open scope on the source file.
             _metaDispenser = (IMetaDataDispenser)new CorMetaDataDispenser();
-            object obj;
-            int hr = _metaDispenser.OpenScope(path, 0, ref s_importerGuid, out obj);
+            int hr = _metaDispenser.OpenScope(path, 0, ref s_importerGuid, out object obj);
             if (hr == 0)
+            {
                 _assemblyImport = (IMetaDataAssemblyImport)obj;
+            }
         }
 
         public static MetadataReader Create(string path)
         {
-            MetadataReader r = new MetadataReader(path);
-            if (r._assemblyImport != null)
-                return r;
-            else
-                return null;
+            var r = new MetadataReader(path);
+            return r._assemblyImport != null ? r : null;
         }
 
         [SuppressMessage("Microsoft.Usage", "CA1806:DoNotIgnoreMethodResults", MessageId = "Microsoft.Build.Tasks.IMetaDataImport2.GetCustomAttributeByName(System.UInt32,System.String,System.IntPtr@,System.UInt32@)", Justification = "We verify the valueLen, we don't care what the return value is in this case")]
         public bool HasAssemblyAttribute(string name)
         {
-            UInt32 assemblyScope;
-            _assemblyImport.GetAssemblyFromScope(out assemblyScope);
+            _assemblyImport.GetAssemblyFromScope(out uint assemblyScope);
             IMetaDataImport2 import2 = (IMetaDataImport2)_assemblyImport;
             IntPtr valuePtr = IntPtr.Zero;
-            UInt32 valueLen = 0;
-            import2.GetCustomAttributeByName(assemblyScope, name, out valuePtr, out valueLen);
+            import2.GetCustomAttributeByName(assemblyScope, name, out valuePtr, out uint valueLen);
             return valueLen != 0;
         }
 
-        public string Name { get { return Attributes["Name"]; } }
-        public string Version { get { return Attributes["Version"]; } }
-        public string PublicKeyToken { get { return Attributes["PublicKeyToken"]; } }
-        public string Culture { get { return Attributes["Culture"]; } }
-        public string ProcessorArchitecture { get { return Attributes["ProcessorArchitecture"]; } }
+        public string Name => Attributes[nameof(Name)];
+        public string Version => Attributes[nameof(Version)];
+        public string PublicKeyToken => Attributes[nameof(PublicKeyToken)];
+        public string Culture => Attributes[nameof(Culture)];
+        public string ProcessorArchitecture => Attributes[nameof(ProcessorArchitecture)];
 
         private StringDictionary Attributes
         {
@@ -70,7 +62,9 @@ private StringDictionary Attributes
                     lock (this)
                     {
                         if (_attributes == null)
+                        {
                             ImportAttributes();
+                        }
                     }
                 }
 
@@ -81,9 +75,14 @@ private StringDictionary Attributes
         public void Close()
         {
             if (_assemblyImport != null)
+            {
                 Marshal.ReleaseComObject(_assemblyImport);
+            }
+
             if (_metaDispenser != null)
+            {
                 Marshal.ReleaseComObject(_metaDispenser);
+            }
             _attributes = null;
             _metaDispenser = null;
             _assemblyImport = null;
@@ -103,16 +102,18 @@ private void ImportAttributes()
             string culture = refid.GetAttribute(null, "culture");
             string processorArchitecture = refid.GetAttribute(null, "processorArchitecture");
             if (!String.IsNullOrEmpty(processorArchitecture))
+            {
                 processorArchitecture = processorArchitecture.ToLowerInvariant();
+            }
 
-            _attributes = new StringDictionary();
-            _attributes.Add("Name", name);
-            _attributes.Add("Version", version);
-            _attributes.Add("PublicKeyToken", publicKeyToken);
-            _attributes.Add("Culture", culture);
-            _attributes.Add("ProcessorArchitecture", processorArchitecture);
-
-            refid = null;
+            _attributes = new StringDictionary
+            {
+                { "Name", name },
+                { "Version", version },
+                { "PublicKeyToken", publicKeyToken },
+                { "Culture", culture },
+                { "ProcessorArchitecture", processorArchitecture }
+            };
         }
 
         void IDisposable.Dispose()
@@ -122,7 +123,7 @@ void IDisposable.Dispose()
 
         private static Guid GetGuidOfType(Type type)
         {
-            GuidAttribute guidAttr = (GuidAttribute)Attribute.GetCustomAttribute(type, typeof(GuidAttribute), false);
+            var guidAttr = (GuidAttribute)Attribute.GetCustomAttribute(type, typeof(GuidAttribute), false);
             return new Guid(guidAttr.Value);
         }
 
diff --git a/src/Tasks/ManifestUtil/NativeMethods.cs b/src/Tasks/ManifestUtil/NativeMethods.cs
index 759cf8b93fd..7b9131a90e7 100644
--- a/src/Tasks/ManifestUtil/NativeMethods.cs
+++ b/src/Tasks/ManifestUtil/NativeMethods.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Runtime.InteropServices;
-using System.Text;
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
 {
diff --git a/src/Tasks/ManifestUtil/OutputMessage.cs b/src/Tasks/ManifestUtil/OutputMessage.cs
index ce0f6389e9d..ff860109fdd 100644
--- a/src/Tasks/ManifestUtil/OutputMessage.cs
+++ b/src/Tasks/ManifestUtil/OutputMessage.cs
@@ -37,18 +37,13 @@ public enum OutputMessageType
     public sealed class OutputMessage
     {
         private readonly string[] _arguments;
-        private readonly string _name;
-        private readonly string _text;
-        private readonly OutputMessageType _type;
 
         internal OutputMessage(OutputMessageType type, string name, string text, params string[] arguments)
         {
-            if (name == null) throw new ArgumentNullException("name");
-            if (arguments == null) throw new ArgumentNullException("arguments");
-            _type = type;
-            _name = name;
-            _arguments = arguments;
-            _text = text;
+            Type = type;
+            Name = name ?? throw new ArgumentNullException(nameof(name));
+            _arguments = arguments ?? throw new ArgumentNullException(nameof(arguments));
+            Text = text;
         }
 
         /// <summary>
@@ -60,17 +55,17 @@ internal OutputMessage(OutputMessageType type, string name, string text, params
         /// <summary>
         /// Specifies an identifier for the message.
         /// </summary>
-        public string Name { get { return _name; } }
+        public string Name { get; }
 
         /// <summary>
         /// Contains the text of the message.
         /// </summary>
-        public string Text { get { return _text; } }
+        public string Text { get; }
 
         /// <summary>
         /// Indicates whether the message is an error, warning, or informational message.
         /// </summary>
-        public OutputMessageType Type { get { return _type; } }
+        public OutputMessageType Type { get; }
     }
 
     /// <summary>
@@ -79,10 +74,8 @@ internal OutputMessage(OutputMessageType type, string name, string text, params
     [ComVisible(false)]
     public sealed class OutputMessageCollection : IEnumerable
     {
-        private readonly System.Resources.ResourceManager _taskResources = Microsoft.Build.Shared.AssemblyResources.PrimaryResources;
+        private readonly System.Resources.ResourceManager _taskResources = Shared.AssemblyResources.PrimaryResources;
         private readonly List<OutputMessage> _list = new List<OutputMessage>();
-        private int _errorCount = 0;
-        private int _warningCount = 0;
 
         internal OutputMessageCollection()
         {
@@ -93,26 +86,27 @@ internal OutputMessageCollection()
         /// </summary>
         /// <param name="index">The zero-based index of the entry to get.</param>
         /// <returns>The file reference instance.</returns>
-        public OutputMessage this[int index]
-        {
-            get { return (OutputMessage)_list[index]; }
-        }
+        public OutputMessage this[int index] => _list[index];
 
         internal void AddErrorMessage(string taskResourceName, params string[] arguments)
         {
-            ++_errorCount;
+            ++ErrorCount;
             string taskText = _taskResources.GetString(taskResourceName);
             if (!String.IsNullOrEmpty(taskText))
+            {
                 taskText = String.Format(CultureInfo.CurrentCulture, taskText, arguments);
+            }
             _list.Add(new OutputMessage(OutputMessageType.Error, taskResourceName, taskText, arguments));
         }
 
         internal void AddWarningMessage(string taskResourceName, params string[] arguments)
         {
-            ++_warningCount;
+            ++WarningCount;
             string taskText = _taskResources.GetString(taskResourceName);
             if (!String.IsNullOrEmpty(taskText))
+            {
                 taskText = String.Format(CultureInfo.CurrentCulture, taskText, arguments);
+            }
             _list.Add(new OutputMessage(OutputMessageType.Warning, taskResourceName, taskText, arguments));
         }
 
@@ -122,20 +116,14 @@ internal void AddWarningMessage(string taskResourceName, params string[] argumen
         public void Clear()
         {
             _list.Clear();
-            _errorCount = 0;
-            _warningCount = 0;
+            ErrorCount = 0;
+            WarningCount = 0;
         }
 
         /// <summary>
         /// Gets the number of error messages in the collecction.
         /// </summary>
-        public int ErrorCount
-        {
-            get
-            {
-                return _errorCount;
-            }
-        }
+        public int ErrorCount { get; private set; }
 
         /// <summary>
         /// Returns an enumerator that can iterate through the collection.
@@ -160,18 +148,12 @@ internal bool LogTaskMessages(Task task)
                         break;
                 }
             }
-            return _errorCount <= 0;
+            return ErrorCount <= 0;
         }
 
         /// <summary>
         /// Gets the number of warning messages in the collecction.
         /// </summary>
-        public int WarningCount
-        {
-            get
-            {
-                return _warningCount;
-            }
-        }
+        public int WarningCount { get; private set; }
     }
 }
diff --git a/src/Tasks/ManifestUtil/PathUtil.cs b/src/Tasks/ManifestUtil/PathUtil.cs
index 21e8fbdde52..d164d77518d 100644
--- a/src/Tasks/ManifestUtil/PathUtil.cs
+++ b/src/Tasks/ManifestUtil/PathUtil.cs
@@ -2,10 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Globalization;
 using System.IO;
-using System.Text;
-using System.Text.RegularExpressions;
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
 {
@@ -46,7 +43,7 @@ public static string Format(string path)
 
         public static bool IsAssembly(string path)
         {
-            if (String.IsNullOrEmpty(path)) throw new ArgumentNullException("path");
+            if (String.IsNullOrEmpty(path)) throw new ArgumentNullException(nameof(path));
             if (String.Equals(Path.GetExtension(path), ".application", StringComparison.Ordinal)) return true;
             if (String.Equals(Path.GetExtension(path), ".manifest", StringComparison.Ordinal)) return true;
             if (!IsProgramFile(path)) return false; // optimization, don't want to sniff every every kind of file -- just dll's or exe's
@@ -81,14 +78,14 @@ public static bool IsLocalPath(string path)
 
         public static bool IsManagedAssembly(string path)
         {
-            if (String.IsNullOrEmpty(path)) throw new ArgumentNullException("path");
+            if (String.IsNullOrEmpty(path)) throw new ArgumentNullException(nameof(path));
             using (MetadataReader r = MetadataReader.Create(path))
                 return r != null;
         }
 
         public static bool IsNativeAssembly(string path)
         {
-            if (String.IsNullOrEmpty(path)) throw new ArgumentNullException("path");
+            if (String.IsNullOrEmpty(path)) throw new ArgumentNullException(nameof(path));
             if (String.Equals(Path.GetExtension(path), ".manifest", StringComparison.Ordinal)) return true;
             return EmbeddedManifestReader.Read(path) != null;
         }
@@ -122,8 +119,7 @@ public static bool IsUncPath(string path)
 
         public static bool IsUrl(string path)
         {
-            Uri u = null;
-            if (!Uri.TryCreate(path, UriKind.Absolute, out u) || u == null)
+            if (!Uri.TryCreate(path, UriKind.Absolute, out Uri u) || u == null)
                 return false;
             return !u.IsUnc && !String.IsNullOrEmpty(u.Host);
         }
@@ -137,19 +133,19 @@ public static string Resolve(string path)
             if (IsUrl(path)) // if it's a URL then need to check for "localhost"...
             {
                 // Replace "localhost" with the actual machine name...
-                const string LocalHost = "localhost";
-                Uri u = new Uri(path);
-                if (String.Equals(u.Host, LocalHost, StringComparison.OrdinalIgnoreCase))
+                const string localHost = "localhost";
+                var u = new Uri(path);
+                if (String.Equals(u.Host, localHost, StringComparison.OrdinalIgnoreCase))
                 {
                     // Unfortunatly Uri.Host is read-only, so we need to reconstruct it manually...
-                    int i = path.IndexOf(LocalHost, StringComparison.OrdinalIgnoreCase);
-                    return i >= 0 ? path.Substring(0, i) + Environment.MachineName.ToLowerInvariant() + path.Substring(i + LocalHost.Length) : path;
+                    int i = path.IndexOf(localHost, StringComparison.OrdinalIgnoreCase);
+                    return i >= 0 ? path.Substring(0, i) + Environment.MachineName.ToLowerInvariant() + path.Substring(i + localHost.Length) : path;
                 }
-                else
-                    return path;
+                return path;
             }
-            else // if not unc or url then it must be a local disk path...
-                return System.IO.Path.GetFullPath(path); // make sure it's a full path
+
+            // if not unc or url then it must be a local disk path...
+            return Path.GetFullPath(path); // make sure it's a full path
         }
     }
 }
diff --git a/src/Tasks/ManifestUtil/RSAPKCS1SHA256SignatureDescription.cs b/src/Tasks/ManifestUtil/RSAPKCS1SHA256SignatureDescription.cs
index 3ecbc91f06d..011248735db 100644
--- a/src/Tasks/ManifestUtil/RSAPKCS1SHA256SignatureDescription.cs
+++ b/src/Tasks/ManifestUtil/RSAPKCS1SHA256SignatureDescription.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Diagnostics.CodeAnalysis;
 using System.Security.Cryptography;
 
@@ -22,7 +21,9 @@ public RSAPKCS1SHA256SignatureDescription()
         public override AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key)
         {
             if (key == null)
-                throw new ArgumentNullException("key");
+            {
+                throw new ArgumentNullException(nameof(key));
+            }
 
             RSAPKCS1SignatureDeformatter deformatter = new RSAPKCS1SignatureDeformatter(key);
             deformatter.SetHashAlgorithm("SHA256");
@@ -32,7 +33,9 @@ public override AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgor
         public override AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key)
         {
             if (key == null)
-                throw new ArgumentNullException("key");
+            {
+                throw new ArgumentNullException(nameof(key));
+            }
 
             RSAPKCS1SignatureFormatter formatter = new RSAPKCS1SignatureFormatter(key);
             formatter.SetHashAlgorithm("SHA256");
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index 3f4dce48252..cd8f40c729b 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -5,7 +5,6 @@
 using Microsoft.Build.Utilities;
 using Microsoft.Win32;
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.ComponentModel;
 using System.Deployment.Internal.CodeSigning;
@@ -33,7 +32,6 @@ namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
     public static class SecurityUtilities
     {
         private const string PermissionSetsFolder = "PermissionSets";
-        private const string Everything = "Everything";
         private const string LocalIntranet = "LocalIntranet";
         private const string Internet = "Internet";
         private const string Custom = "Custom";
@@ -106,27 +104,27 @@ internal static PermissionSet ComputeZonePermissionSetHelper(string targetZone,
                 return includedPermissionSet.Copy();
             }
 
-            PermissionSet retSet = GetNamedPermissionSetFromZone(targetZone, dependencies, targetFrameworkMoniker);
+            PermissionSet retSet = GetNamedPermissionSetFromZone(targetZone, targetFrameworkMoniker);
 
             return retSet;
         }
 
-        private static PermissionSet GetNamedPermissionSetFromZone(string targetZone, ITaskItem[] dependencies, string targetFrameworkMoniker)
+        private static PermissionSet GetNamedPermissionSetFromZone(string targetZone, string targetFrameworkMoniker)
         {
             switch (targetZone)
             {
                 case LocalIntranet:
-                    return GetNamedPermissionSet(LocalIntranet, dependencies, targetFrameworkMoniker);
+                    return GetNamedPermissionSet(LocalIntranet, targetFrameworkMoniker);
                 case Internet:
-                    return GetNamedPermissionSet(Internet, dependencies, targetFrameworkMoniker);
+                    return GetNamedPermissionSet(Internet, targetFrameworkMoniker);
                 default:
-                    throw new ArgumentException(String.Empty /* no message */, "targetZone");
+                    throw new ArgumentException(String.Empty /* no message */, nameof(targetZone));
             }
         }
 
-        private static PermissionSet GetNamedPermissionSet(string targetZone, ITaskItem[] dependencies, string targetFrameworkMoniker)
+        private static PermissionSet GetNamedPermissionSet(string targetZone, string targetFrameworkMoniker)
         {
-            FrameworkNameVersioning fn = null;
+            FrameworkNameVersioning fn;
 
             if (!string.IsNullOrEmpty(targetFrameworkMoniker))
             {
@@ -141,15 +139,15 @@ private static PermissionSet GetNamedPermissionSet(string targetZone, ITaskItem[
 
             if (majorVersion == Fx2MajorVersion)
             {
-                return SecurityUtilities.XmlToPermissionSet((GetXmlElement(targetZone, majorVersion)));
+                return XmlToPermissionSet((GetXmlElement(targetZone, majorVersion)));
             }
             else if (majorVersion == Fx3MajorVersion)
             {
-                return SecurityUtilities.XmlToPermissionSet((GetXmlElement(targetZone, majorVersion)));
+                return XmlToPermissionSet((GetXmlElement(targetZone, majorVersion)));
             }
             else
             {
-                return SecurityUtilities.XmlToPermissionSet((GetXmlElement(targetZone, fn)));
+                return XmlToPermissionSet((GetXmlElement(targetZone, fn)));
             }
         }
 
@@ -167,7 +165,7 @@ private static XmlElement GetXmlElement(string targetZone, FrameworkNameVersioni
                 if (Directory.Exists(path))
                 {
                     string[] files = Directory.GetFiles(path, "*.xml");
-                    FileInfo[] filesInfo = new FileInfo[files.Length];
+                    var filesInfo = new FileInfo[files.Length];
 
                     int indexFound = -1;
 
@@ -187,30 +185,32 @@ private static XmlElement GetXmlElement(string targetZone, FrameworkNameVersioni
 
                     if (indexFound != -1)
                     {
-                        string data = string.Empty;
                         FileInfo resultFile = filesInfo[indexFound];
                         using (FileStream fs = resultFile.OpenRead())
                         {
                             try
                             {
-                                StreamReader sr = new StreamReader(fs);
-                                data = sr.ReadToEnd(); // fs.Position value will be the length of the stream.
+                                var sr = new StreamReader(fs);
+                                string data = sr.ReadToEnd();
                                 if (!string.IsNullOrEmpty(data))
                                 {
-                                    XmlDocument doc = new XmlDocument();
-                                    XmlReaderSettings xrSettings = new XmlReaderSettings();
-                                    xrSettings.DtdProcessing = DtdProcessing.Ignore;
+                                    var doc = new XmlDocument();
+                                    var xrSettings =
+                                        new XmlReaderSettings
+                                        {
+                                            DtdProcessing = DtdProcessing.Ignore,
+                                            ConformanceLevel = ConformanceLevel.Auto
+                                        };
 
                                     // http://msdn.microsoft.com/en-us/library/h2344bs2(v=vs.110).aspx
                                     // PermissionSets do not conform to document level, which is the default setting.
-                                    xrSettings.ConformanceLevel = ConformanceLevel.Auto;
                                     try
                                     {
                                         fs.Position = 0; // Reset to 0 before using this stream in any other reader.
                                         using (XmlReader xr = XmlReader.Create(fs, xrSettings))
                                         {
                                             doc.Load(xr);
-                                            return (XmlElement)doc.DocumentElement;
+                                            return doc.DocumentElement;
                                         }
                                     }
                                     catch (Exception)
@@ -234,8 +234,7 @@ private static XmlElement GetXmlElement(string targetZone, FrameworkNameVersioni
         [SuppressMessage("Microsoft.Security.Xml", "CA3057: DoNotUseLoadXml.")]
         private static XmlElement GetCurrentCLRPermissions(string targetZone)
         {
-            string resultInString = string.Empty;
-            SecurityZone zone = SecurityZone.NoZone;
+            SecurityZone zone;
             switch (targetZone)
             {
                 case LocalIntranet:
@@ -245,21 +244,21 @@ private static XmlElement GetCurrentCLRPermissions(string targetZone)
                     zone = SecurityZone.Internet;
                     break;
                 default:
-                    throw new ArgumentException(String.Empty /* no message */, "targetZone");
+                    throw new ArgumentException(String.Empty /* no message */, nameof(targetZone));
             }
 
-            Evidence evidence = new Evidence(new EvidenceBase[] { new Zone(zone), new System.Runtime.Hosting.ActivationArguments(new System.ApplicationIdentity("")) }, null);
+            var evidence = new Evidence(new EvidenceBase[] { new Zone(zone), new System.Runtime.Hosting.ActivationArguments(new System.ApplicationIdentity("")) }, null);
 
             PermissionSet sandbox = SecurityManager.GetStandardSandbox(evidence);
-            resultInString = sandbox.ToString();
+            string resultInString = sandbox.ToString();
 
             if (!string.IsNullOrEmpty(resultInString))
             {
-                XmlDocument doc = new XmlDocument();
+                var doc = new XmlDocument();
                 // CA3057: DoNotUseLoadXml. Suppressed since the xml being loaded is a string representation of the PermissionSet.
                 doc.LoadXml(resultInString);
 
-                return (XmlElement)doc.DocumentElement;
+                return doc.DocumentElement;
             }
 
             return null;
@@ -267,7 +266,7 @@ private static XmlElement GetCurrentCLRPermissions(string targetZone)
 
         private static XmlElement GetXmlElement(string targetZone, int majorVersion)
         {
-            XmlDocument doc = null;
+            XmlDocument doc;
 
             switch (majorVersion)
             {
@@ -278,13 +277,10 @@ private static XmlElement GetXmlElement(string targetZone, int majorVersion)
                     doc = CreateXmlDocV3(targetZone);
                     break;
                 default:
-                    throw new ArgumentException(String.Empty /* no message */, "majorVersion");
+                    throw new ArgumentException(String.Empty /* no message */, nameof(majorVersion));
             }
 
-            XmlElement rootElement = (XmlElement)doc.DocumentElement;
-
-            if (rootElement == null)
-                return null;
+            XmlElement rootElement = doc.DocumentElement;
 
             return rootElement;
         }
@@ -292,7 +288,7 @@ private static XmlElement GetXmlElement(string targetZone, int majorVersion)
         [SuppressMessage("Microsoft.Security.Xml", "CA3057: DoNotUseLoadXml.")]
         private static XmlDocument CreateXmlDocV2(string targetZone)
         {
-            XmlDocument doc = new XmlDocument();
+            var doc = new XmlDocument();
 
             switch (targetZone)
             {
@@ -305,14 +301,14 @@ private static XmlDocument CreateXmlDocV2(string targetZone)
                     doc.LoadXml(InternetPermissionSetXml);
                     return doc;
                 default:
-                    throw new ArgumentException(String.Empty /* no message */, "targetZone");
+                    throw new ArgumentException(String.Empty /* no message */, nameof(targetZone));
             }
         }
 
         [SuppressMessage("Microsoft.Security.Xml", "CA3057: DoNotUseLoadXml.")]
         private static XmlDocument CreateXmlDocV3(string targetZone)
         {
-            XmlDocument doc = new XmlDocument();
+            var doc = new XmlDocument();
 
             switch (targetZone)
             {
@@ -325,79 +321,8 @@ private static XmlDocument CreateXmlDocV3(string targetZone)
                     doc.LoadXml(InternetPermissionSetWithWPFXml);
                     return doc;
                 default:
-                    throw new ArgumentException(String.Empty /* no message */, "targetZone");
-            }
-        }
-
-        private static string[] GetRegistryPermissionSetByName(string name)
-        {
-            string[] extensibleNamedPermissionSetRegistryInfo = null;
-            RegistryKey localMachineKey = Registry.LocalMachine;
-
-            using (RegistryKey versionIndependentFXKey = localMachineKey.OpenSubKey(@"Software\Microsoft\.NETFramework", false))
-            {
-                if (versionIndependentFXKey != null)
-                {
-                    using (RegistryKey namedPermissionSetsKey = versionIndependentFXKey.OpenSubKey(@"Security\Policy\Extensions\NamedPermissionSets", false))
-                    {
-                        if (namedPermissionSetsKey != null)
-                        {
-                            using (RegistryKey permissionSetKey = namedPermissionSetsKey.OpenSubKey(name, false))
-                            {
-                                if (permissionSetKey != null)
-                                {
-                                    string[] permissionKeys = permissionSetKey.GetSubKeyNames();
-                                    extensibleNamedPermissionSetRegistryInfo = new string[permissionKeys.Length];
-                                    for (int i = 0; i < permissionKeys.Length; i++)
-                                    {
-                                        using (RegistryKey permissionKey = permissionSetKey.OpenSubKey(permissionKeys[i], false))
-                                        {
-                                            string permissionXml = permissionKey.GetValue("Xml") as string;
-                                            extensibleNamedPermissionSetRegistryInfo[i] = permissionXml;
-                                        }
-                                    }
-                                }
-                            }
-                        }
-                    }
-                }
+                    throw new ArgumentException(String.Empty /* no message */, nameof(targetZone));
             }
-            return extensibleNamedPermissionSetRegistryInfo;
-        }
-
-        private static PermissionSet RemoveNonReferencedPermissions(string[] setToFilter, ITaskItem[] dependencies)
-        {
-            PermissionSet retSet = new PermissionSet(PermissionState.None);
-            if (dependencies == null || setToFilter == null || setToFilter.Length == 0)
-                return retSet;
-
-            List<string> assemblyNameList = new List<string>();
-            foreach (ITaskItem dependency in dependencies)
-            {
-                AssemblyName dependentAssemblyName = AssemblyName.GetAssemblyName(dependency.ItemSpec);
-                assemblyNameList.Add(dependentAssemblyName.Name + ", " + dependentAssemblyName.Version.ToString());
-            }
-            SecurityElement retSetElement = retSet.ToXml();
-            foreach (string permissionXml in setToFilter)
-            {
-                if (!String.IsNullOrEmpty(permissionXml))
-                {
-                    string permissionAssemblyName;
-                    string className;
-                    string assemblyVersion;
-
-                    SecurityElement permission = SecurityElement.FromString(permissionXml);
-
-                    if (!ParseElementForAssemblyIdentification(permission, out className, out permissionAssemblyName, out assemblyVersion))
-                        continue;
-                    if (assemblyNameList.Contains(permissionAssemblyName + ", " + assemblyVersion))
-                    {
-                        retSetElement.AddChild(SecurityElement.FromString(permissionXml));
-                    }
-                }
-            }
-            retSet = new ReadOnlyPermissionSet(retSetElement);
-            return retSet;
         }
 
         internal static bool ParseElementForAssemblyIdentification(SecurityElement el,
@@ -421,7 +346,6 @@ internal static bool ParseElementForAssemblyIdentification(SecurityElement el,
             }
 
             int commaIndex = fullClassName.IndexOf(',');
-            int namespaceClassNameLength;
 
             // If the classname is tagged with assembly information, find where
             // the assembly information begins.
@@ -431,10 +355,10 @@ internal static bool ParseElementForAssemblyIdentification(SecurityElement el,
                 return false;
             }
 
-            namespaceClassNameLength = commaIndex;
+            int namespaceClassNameLength = commaIndex;
             className = fullClassName.Substring(0, namespaceClassNameLength);
             String assemblyFullName = fullClassName.Substring(commaIndex + 1);
-            AssemblyName an = new AssemblyName(assemblyFullName);
+            var an = new AssemblyName(assemblyFullName);
             assemblyName = an.Name;
             assemblyVersion = an.Version.ToString();
             return true;
@@ -448,7 +372,7 @@ internal static bool ParseElementForAssemblyIdentification(SecurityElement el,
         /// <returns>The converted permission set.</returns>
         public static PermissionSet IdentityListToPermissionSet(string[] ids)
         {
-            XmlDocument document = new XmlDocument();
+            var document = new XmlDocument();
             XmlElement permissionSetElement = document.CreateElement("PermissionSet");
             document.AppendChild(permissionSetElement);
             foreach (string id in ids)
@@ -470,8 +394,8 @@ public static PermissionSet IdentityListToPermissionSet(string[] ids)
         [SuppressMessage("Microsoft.Security.Xml", "CA3057: DoNotUseLoadXml.")]
         public static string[] PermissionSetToIdentityList(PermissionSet permissionSet)
         {
-            string psXml = permissionSet != null ? permissionSet.ToString() : "<PermissionSet/>";
-            XmlDocument psDocument = new XmlDocument();
+            string psXml = permissionSet?.ToString() ?? "<PermissionSet/>";
+            var psDocument = new XmlDocument();
             // CA3057: DoNotUseLoadXml.  Suppressed since 'psXml' is a trusted or a constant string.
             psDocument.LoadXml(psXml);
             return XmlToIdentityList(psDocument.DocumentElement);
@@ -481,11 +405,11 @@ public static string[] PermissionSetToIdentityList(PermissionSet permissionSet)
         internal static XmlDocument PermissionSetToXml(PermissionSet ps)
         {
             XmlDocument inputDocument = new XmlDocument();
-            string xml = (ps != null) ? ps.ToString() : "<PermissionSet/>";
+            string xml = ps?.ToString() ?? "<PermissionSet/>";
 
             // CA3057: DoNotUseLoadXml.  Suppressed since 'xml' is a trusted or a constant string.
             inputDocument.LoadXml(xml);
-            XmlDocument outputDocument = new XmlDocument();
+            var outputDocument = new XmlDocument();
             XmlElement psElement = XmlUtil.CloneElementToDocument(inputDocument.DocumentElement, outputDocument, XmlNamespaces.asmv2);
             outputDocument.AppendChild(psElement);
             return outputDocument;
@@ -514,10 +438,14 @@ private static string[] XmlToIdentityList(XmlElement psElement)
                 a = new string[nodes.Count];
                 int i = 0;
                 foreach (XmlNode node in nodes)
+                {
                     a[i++] = node.Value;
+                }
             }
             else
+            {
                 a = Array.Empty<string>();
+            }
             return a;
         }
 
@@ -529,11 +457,15 @@ private static string[] XmlToIdentityList(XmlElement psElement)
         public static PermissionSet XmlToPermissionSet(XmlElement element)
         {
             if (element == null)
+            {
                 return null;
+            }
 
             SecurityElement se = XmlElementToSecurityElement(element);
             if (se == null)
+            {
                 return null;
+            }
 
             PermissionSet ps = new PermissionSet(PermissionState.None);
             try
@@ -572,19 +504,24 @@ public static void SignFile(string certThumbprint, Uri timestampUrl, string path
             System.Resources.ResourceManager resources = new System.Resources.ResourceManager("Microsoft.Build.Tasks.Core.Strings.ManifestUtilities", typeof(SecurityUtilities).Module.Assembly);
 
             if (String.IsNullOrEmpty(certThumbprint))
-                throw new ArgumentNullException("certThumbprint");
+            {
+                throw new ArgumentNullException(nameof(certThumbprint));
+            }
 
             X509Certificate2 cert = GetCert(certThumbprint);
-
             if (cert == null)
-                throw new ArgumentException(resources.GetString("CertNotInStore"), "certThumbprint");
+            {
+                throw new ArgumentException(resources.GetString("CertNotInStore"), nameof(certThumbprint));
+            }
 
             if (!String.IsNullOrEmpty(targetFrameworkVersion))
             {
                 Version targetVersion = Util.GetTargetFrameworkVersion(targetFrameworkVersion);
 
                 if (targetVersion == null)
+                {
                     throw new ArgumentException("TargetFrameworkVersion");
+                }
 
                 // SHA-256 digest can be parsed only with .NET 4.5 or higher.
                 bool isTargetFrameworkSha256Supported = targetVersion.CompareTo(s_dotNet45Version) >= 0;
@@ -635,13 +572,19 @@ public static void SignFile(X509Certificate2 cert, Uri timestampUrl, string path
         private static void SignFileInternal(X509Certificate2 cert, Uri timestampUrl, string path, bool targetFrameworkSupportsSha256, System.Resources.ResourceManager resources)
         {
             if (cert == null)
-                throw new ArgumentNullException("cert");
+            {
+                throw new ArgumentNullException(nameof(cert));
+            }
 
             if (String.IsNullOrEmpty(path))
-                throw new ArgumentNullException("path");
+            {
+                throw new ArgumentNullException(nameof(path));
+            }
 
             if (!File.Exists(path))
+            {
                 throw new FileNotFoundException(String.Format(CultureInfo.InvariantCulture, resources.GetString("SecurityUtil.SignTargetNotFound"), path), path);
+            }
 
             bool useSha256 = UseSha256Algorithm(cert) && targetFrameworkSupportsSha256;
 
@@ -660,15 +603,13 @@ private static void SignFileInternal(X509Certificate2 cert, Uri timestampUrl, st
                         throw new ApplicationException(resources.GetString("SecurityUtil.OnlyRSACertsAreAllowed"));
                     try
                     {
-                        XmlDocument doc = new XmlDocument();
-                        doc.PreserveWhitespace = true;
-                        XmlReaderSettings xrSettings = new XmlReaderSettings();
-                        xrSettings.DtdProcessing = DtdProcessing.Ignore;
+                        var doc = new XmlDocument { PreserveWhitespace = true };
+                        var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
                         using (XmlReader xr = XmlReader.Create(path, xrSettings))
                         {
                             doc.Load(xr);
                         }
-                        SignedCmiManifest2 manifest = new SignedCmiManifest2(doc, useSha256);
+                        var manifest = new SignedCmiManifest2(doc, useSha256);
                         CmiManifestSigner2 signer;
                         if (useSha256 && rsa is RSACryptoServiceProvider)
                         {
@@ -688,7 +629,7 @@ private static void SignFileInternal(X509Certificate2 cert, Uri timestampUrl, st
                     }
                     catch (Exception ex)
                     {
-                        int exceptionHR = System.Runtime.InteropServices.Marshal.GetHRForException(ex);
+                        int exceptionHR = Marshal.GetHRForException(ex);
                         if (exceptionHR == -2147012889 || exceptionHR == -2147012867)
                         {
                             throw new ApplicationException(resources.GetString("SecurityUtil.TimestampUrlNotFound"), ex);
@@ -699,14 +640,17 @@ private static void SignFileInternal(X509Certificate2 cert, Uri timestampUrl, st
             }
         }
 
-
-        private static void SignPEFile(X509Certificate2 cert, System.Uri timestampUrl, string path, System.Resources.ResourceManager resources, bool useSha256)
+        private static void SignPEFile(X509Certificate2 cert, Uri timestampUrl, string path, System.Resources.ResourceManager resources, bool useSha256)
         {
-            ProcessStartInfo startInfo = new ProcessStartInfo(GetPathToTool(resources), GetCommandLineParameters(cert.Thumbprint, timestampUrl, path, useSha256));
-            startInfo.CreateNoWindow = true;
-            startInfo.UseShellExecute = false;
-            startInfo.RedirectStandardError = true;
-            startInfo.RedirectStandardOutput = true;
+            var startInfo = new ProcessStartInfo(
+                GetPathToTool(resources),
+                GetCommandLineParameters(cert.Thumbprint, timestampUrl, path, useSha256))
+            {
+                CreateNoWindow = true,
+                UseShellExecute = false,
+                RedirectStandardError = true,
+                RedirectStandardOutput = true
+            };
 
             Process signTool = null;
 
@@ -737,22 +681,26 @@ private static void SignPEFile(X509Certificate2 cert, System.Uri timestampUrl, s
             }
             finally
             {
-                if (signTool != null)
-                    signTool.Close();
+                signTool?.Close();
             }
         }
 
         internal static string GetCommandLineParameters(string certThumbprint, Uri timestampUrl, string path, bool useSha256)
         {
-            StringBuilder commandLine = new StringBuilder();
+            var commandLine = new StringBuilder();
             if (useSha256)
+            {
                 commandLine.Append(String.Format(CultureInfo.InvariantCulture, "sign /fd sha256 /sha1 {0} ", certThumbprint));
+            }
             else
             {
                 commandLine.Append(String.Format(CultureInfo.InvariantCulture, "sign /sha1 {0} ", certThumbprint));
             }
+
             if (timestampUrl != null)
+            {
                 commandLine.Append(String.Format(CultureInfo.InvariantCulture, "/t {0} ", timestampUrl.ToString()));
+            }
             commandLine.Append(string.Format(CultureInfo.InvariantCulture, "\"{0}\"", path));
             return commandLine.ToString();
         }
@@ -794,7 +742,7 @@ internal static string GetPathToTool(System.Resources.ResourceManager resources)
 
         internal static X509Certificate2 GetCert(string thumbprint)
         {
-            X509Store personalStore = new X509Store(StoreName.My, StoreLocation.CurrentUser);
+            var personalStore = new X509Store(StoreName.My, StoreLocation.CurrentUser);
             try
             {
                 personalStore.Open(OpenFlags.ReadOnly);
@@ -813,7 +761,7 @@ internal static X509Certificate2 GetCert(string thumbprint)
 
         private static bool IsCertInStore(X509Certificate2 cert)
         {
-            X509Store personalStore = new X509Store(StoreName.My, StoreLocation.CurrentUser);
+            var personalStore = new X509Store(StoreName.My, StoreLocation.CurrentUser);
             try
             {
                 personalStore.Open(OpenFlags.ReadOnly);
diff --git a/src/Tasks/ManifestUtil/TrustInfo.cs b/src/Tasks/ManifestUtil/TrustInfo.cs
index 1dd33944248..11afbd9d3a3 100644
--- a/src/Tasks/ManifestUtil/TrustInfo.cs
+++ b/src/Tasks/ManifestUtil/TrustInfo.cs
@@ -3,8 +3,6 @@
 
 using System;
 using System.Collections;
-using System.Collections.Generic;
-using System.Collections.Specialized;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
@@ -12,7 +10,6 @@
 using System.Runtime.InteropServices;
 using System.Security;
 using System.Security.Permissions;
-using System.Text;
 using System.Xml;
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
@@ -23,20 +20,12 @@ namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
     [ComVisible(false)]
     public sealed class TrustInfo
     {
-        private PermissionSet _inputPermissionSet = null;
-        private XmlDocument _inputTrustInfoDocument = null;
+        private PermissionSet _inputPermissionSet;
+        private XmlDocument _inputTrustInfoDocument;
         private bool _isFullTrust = true;
-        private PermissionSet _outputPermissionSet = null;
-        private bool _preserveFullTrustPermissionSet = false;
+        private PermissionSet _outputPermissionSet;
         private string _sameSiteSetting = "site";
-        private bool _sameSiteChanged = false;
-
-        /// <summary>
-        /// Initializes a new instance of the TrustInfo class.
-        /// </summary>
-        public TrustInfo()
-        {
-        }
+        private bool _sameSiteChanged;
 
         private void AddSameSiteAttribute(XmlElement permissionSetElement)
         {
@@ -66,9 +55,9 @@ private void FixupPermissionSetElement(XmlElement permissionSetElement)
             XmlDocument document = permissionSetElement.OwnerDocument;
             XmlNamespaceManager nsmgr = XmlNamespaces.GetNamespaceManager(document.NameTable);
 
-            if (_preserveFullTrustPermissionSet)
+            if (PreserveFullTrustPermissionSet)
             {
-                XmlAttribute unrestrictedAttribute = (XmlAttribute)permissionSetElement.Attributes.GetNamedItem(XmlUtil.TrimPrefix(XPaths.unrestrictedAttribute));
+                var unrestrictedAttribute = (XmlAttribute)permissionSetElement.Attributes.GetNamedItem(XmlUtil.TrimPrefix(XPaths.unrestrictedAttribute));
                 if (_isFullTrust)
                 {
                     if (unrestrictedAttribute == null)
@@ -81,14 +70,16 @@ private void FixupPermissionSetElement(XmlElement permissionSetElement)
                 else
                 {
                     if (unrestrictedAttribute != null)
+                    {
                         permissionSetElement.Attributes.RemoveNamedItem(XmlUtil.TrimPrefix(XPaths.unrestrictedAttribute));
+                    }
                 }
             }
             else
             {
                 if (_isFullTrust)
                 {
-                    XmlAttribute unrestrictedAttribute = (XmlAttribute)permissionSetElement.Attributes.GetNamedItem(XmlUtil.TrimPrefix(XPaths.unrestrictedAttribute));
+                    var unrestrictedAttribute = (XmlAttribute)permissionSetElement.Attributes.GetNamedItem(XmlUtil.TrimPrefix(XPaths.unrestrictedAttribute));
                     if (unrestrictedAttribute == null)
                     {
                         unrestrictedAttribute = document.CreateAttribute(XmlUtil.TrimPrefix(XPaths.unrestrictedAttribute));
@@ -96,12 +87,14 @@ private void FixupPermissionSetElement(XmlElement permissionSetElement)
                     }
                     unrestrictedAttribute.Value = "true";
                     while (permissionSetElement.FirstChild != null)
+                    {
                         permissionSetElement.RemoveChild(permissionSetElement.FirstChild);
+                    }
                 }
             }
 
             // Add ID="Custom" attribute if there's not one already
-            XmlAttribute idAttribute = (XmlAttribute)permissionSetElement.Attributes.GetNamedItem(XmlUtil.TrimPrefix(XPaths.idAttribute));
+            var idAttribute = (XmlAttribute)permissionSetElement.Attributes.GetNamedItem(XmlUtil.TrimPrefix(XPaths.idAttribute));
             if (idAttribute == null)
             {
                 idAttribute = document.CreateAttribute(XmlUtil.TrimPrefix(XPaths.idAttribute));
@@ -109,12 +102,17 @@ private void FixupPermissionSetElement(XmlElement permissionSetElement)
             }
 
             if (String.IsNullOrEmpty(idAttribute.Value))
+            {
                 idAttribute.Value = "Custom";
+            }
 
             AddSameSiteAttribute(permissionSetElement);
 
-            if (permissionSetElement.ParentNode == null || permissionSetElement.ParentNode.NodeType == XmlNodeType.Document)
+            if (permissionSetElement.ParentNode == null ||
+                permissionSetElement.ParentNode.NodeType == XmlNodeType.Document)
+            {
                 return;
+            }
 
             XmlAttribute idrefAttribute = null;
             XmlElement defaultAssemblyRequestElement = (XmlElement)permissionSetElement.ParentNode.SelectSingleNode(XPaths.defaultAssemblyRequestElement, nsmgr);
@@ -131,7 +129,9 @@ private void FixupPermissionSetElement(XmlElement permissionSetElement)
             }
 
             if (String.Compare(idAttribute.Value, idrefAttribute.Value, StringComparison.Ordinal) != 0)
+            {
                 idrefAttribute.Value = idAttribute.Value;
+            }
         }
 
         private PermissionSet GetInputPermissionSet()
@@ -139,7 +139,7 @@ private PermissionSet GetInputPermissionSet()
             if (_inputPermissionSet == null)
             {
                 XmlElement psElement = GetInputPermissionSetElement();
-                if (_preserveFullTrustPermissionSet)
+                if (PreserveFullTrustPermissionSet)
                 {
                     XmlAttribute unrestrictedAttribute = (XmlAttribute)psElement.Attributes.GetNamedItem(XmlUtil.TrimPrefix(XPaths.unrestrictedAttribute));
                     _isFullTrust = unrestrictedAttribute != null && Boolean.Parse(unrestrictedAttribute.Value);
@@ -166,7 +166,6 @@ private XmlElement GetInputPermissionSetElement()
             if (_inputTrustInfoDocument == null)
             {
                 _inputTrustInfoDocument = new XmlDocument();
-                XmlNamespaceManager nsmgr = XmlNamespaces.GetNamespaceManager(_inputTrustInfoDocument.NameTable);
                 XmlElement trustInfoElement = _inputTrustInfoDocument.CreateElement(XmlUtil.TrimPrefix(XPaths.trustInfoElement), XmlNamespaces.asmv2);
                 _inputTrustInfoDocument.AppendChild(trustInfoElement);
             }
@@ -179,18 +178,12 @@ private XmlElement GetInputRequestedPrivilegeElement()
                 return null;
             XmlNamespaceManager nsmgr = XmlNamespaces.GetNamespaceManager(_inputTrustInfoDocument.NameTable);
             XmlElement trustInfoElement = _inputTrustInfoDocument.DocumentElement;
-            if (trustInfoElement == null)
-                return null;
-            XmlElement securityElement = (XmlElement)trustInfoElement.SelectSingleNode(XPaths.securityElement, nsmgr);
-            if (securityElement == null)
-                return null;
-            XmlElement requestedPrivilegeElement = (XmlElement)securityElement.SelectSingleNode(XPaths.requestedPrivilegeElement, nsmgr);
-            if (requestedPrivilegeElement == null)
-                return null;
+            XmlElement securityElement = (XmlElement) trustInfoElement?.SelectSingleNode(XPaths.securityElement, nsmgr);
+            XmlElement requestedPrivilegeElement = (XmlElement) securityElement?.SelectSingleNode(XPaths.requestedPrivilegeElement, nsmgr);
             return requestedPrivilegeElement;
         }
 
-        private XmlElement GetRequestedPrivilegeElement(XmlElement inputRequestedPrivilegeElement, XmlDocument document)
+        private static XmlElement GetRequestedPrivilegeElement(XmlElement inputRequestedPrivilegeElement, XmlDocument document)
         {
             //  <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
             //      <!--
@@ -311,7 +304,7 @@ private XmlElement GetPermissionSetElement(XmlDocument document)
             Debug.Assert(document != null, "GetPermissionSetElement was passed a null document");
             XmlNamespaceManager nsmgr = XmlNamespaces.GetNamespaceManager(document.NameTable);
             XmlElement trustInfoElement = document.DocumentElement;
-            XmlElement securityElement = (XmlElement)trustInfoElement.SelectSingleNode(XPaths.securityElement, nsmgr);
+            var securityElement = (XmlElement)trustInfoElement.SelectSingleNode(XPaths.securityElement, nsmgr);
             if (securityElement == null)
             {
                 securityElement = document.CreateElement(XmlUtil.TrimPrefix(XPaths.securityElement), XmlNamespaces.asmv2);
@@ -367,8 +360,10 @@ public bool HasUnmanagedCodePermission
             {
                 PermissionSet ps = GetOutputPermissionSet();
                 if (ps == null)
+                {
                     return false;
-                PermissionSet ups = new PermissionSet(PermissionState.None);
+                }
+                var ups = new PermissionSet(PermissionState.None);
                 ups.AddPermission(new SecurityPermission(SecurityPermissionFlag.UnmanagedCode));
                 return ps.Intersect(ups) != null;
             }
@@ -384,10 +379,7 @@ public bool IsFullTrust
                 GetInputPermissionSet();
                 return _isFullTrust;
             }
-            set
-            {
-                _isFullTrust = value;
-            }
+            set => _isFullTrust = value;
         }
 
         /// <summary>
@@ -395,28 +387,15 @@ public bool IsFullTrust
         /// </summary>
         public PermissionSet PermissionSet
         {
-            get
-            {
-                return GetOutputPermissionSet();
-            }
-            set
-            {
-                // Can't allow null because we use that to track whether we should save or not, pass an empty permission set instead
-                if (value == null)
-                    throw new ArgumentNullException("PermissionSet cannot be set to null.");
-                _outputPermissionSet = value;
-            }
+            get => GetOutputPermissionSet();
+            set => _outputPermissionSet = value ?? throw new ArgumentNullException("PermissionSet cannot be set to null.");
         }
 
         /// <summary>
         /// Determines whether to preserve partial trust permission when the full trust flag is set.
         /// If this option is false with full trust specified, then any permissions defined in the permission set object will be dropped on save.
         /// </summary>
-        public bool PreserveFullTrustPermissionSet
-        {
-            get { return _preserveFullTrustPermissionSet; }
-            set { _preserveFullTrustPermissionSet = value; }
-        }
+        public bool PreserveFullTrustPermissionSet { get; set; }
 
         /// <summary>
         /// Reads the application trust from an XML file.
@@ -442,17 +421,18 @@ public void Read(Stream input)
         private void Read(Stream s, string xpath)
         {
             Clear();
-            XmlDocument document = new XmlDocument();
-            XmlReaderSettings xrSettings = new XmlReaderSettings();
-            xrSettings.DtdProcessing = DtdProcessing.Ignore;
+            var document = new XmlDocument();
+            var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
             using (XmlReader xr = XmlReader.Create(s, xrSettings))
             {
                 document.Load(xr);
             }
             XmlNamespaceManager nsmgr = XmlNamespaces.GetNamespaceManager(document.NameTable);
-            XmlElement trustInfoElement = (XmlElement)document.SelectSingleNode(xpath, nsmgr);
+            var trustInfoElement = (XmlElement)document.SelectSingleNode(xpath, nsmgr);
             if (trustInfoElement == null)
+            {
                 return; // no trustInfo element is okay
+            }
             ReadTrustInfo(trustInfoElement.OuterXml);
         }
 
@@ -497,7 +477,7 @@ private void ReadTrustInfo(string xml)
         /// </summary>
         public string SameSiteAccess
         {
-            get { return _sameSiteSetting; }
+            get => _sameSiteSetting;
             set
             {
                 _sameSiteSetting = value;
@@ -507,10 +487,10 @@ public string SameSiteAccess
 
         public override string ToString()
         {
-            MemoryStream m = new MemoryStream();
+            var m = new MemoryStream();
             Write(m);
             m.Position = 0;
-            StreamReader r = new StreamReader(m);
+            var r = new StreamReader(m);
             return r.ReadToEnd();
         }
 
@@ -533,7 +513,7 @@ public void Write(string path)
         /// <param name="output"></param>
         public void Write(Stream output)
         {
-            XmlDocument outputDocument = new XmlDocument();
+            var outputDocument = new XmlDocument();
             XmlElement inputPermissionSetElement = GetInputPermissionSetElement();
 
             //NOTE: XmlDocument.ImportNode munges "xmlns:asmv2" to "xmlns:d1p1" for some reason, use XmlUtil.CloneElementToDocument instead
@@ -542,17 +522,16 @@ public void Write(Stream output)
 
             string tempPrivilegeDocument = null;
 
-            XmlDocument privilegeDocument = new XmlDocument();
+            var privilegeDocument = new XmlDocument();
             XmlElement inputRequestedPrivilegeElement = GetInputRequestedPrivilegeElement();
-            XmlElement requestedPrivilegeElement = null;
 
-            requestedPrivilegeElement = GetRequestedPrivilegeElement(inputRequestedPrivilegeElement, privilegeDocument);
+            XmlElement requestedPrivilegeElement = GetRequestedPrivilegeElement(inputRequestedPrivilegeElement, privilegeDocument);
 
             if (requestedPrivilegeElement != null)
             {
                 privilegeDocument.AppendChild(requestedPrivilegeElement);
 
-                MemoryStream p = new MemoryStream();
+                var p = new MemoryStream();
                 privilegeDocument.Save(p);
                 p.Position = 0;
                 tempPrivilegeDocument = Util.WriteTempFile(p);
@@ -595,17 +574,15 @@ public void Write(Stream output)
                 }
 
                 // Wrap <PermissionSet> in a <TrustInfo> section
-                Stream s = null;
-                if (tempPrivilegeDocument != null)
-                    s = XmlUtil.XslTransform(trustInfoResource2, m, new DictionaryEntry("defaultRequestedPrivileges", tempPrivilegeDocument));
-                else
-                    s = XmlUtil.XslTransform(trustInfoResource2, m);
+                Stream s = tempPrivilegeDocument != null ? XmlUtil.XslTransform(trustInfoResource2, m, new DictionaryEntry("defaultRequestedPrivileges", tempPrivilegeDocument)) : XmlUtil.XslTransform(trustInfoResource2, m);
                 Util.CopyStream(s, output);
             }
             finally
             {
                 if (tempPrivilegeDocument != null)
+                {
                     File.Delete(tempPrivilegeDocument);
+                }
             }
         }
 
@@ -670,9 +647,8 @@ public void WriteManifest(Stream output)
         public void WriteManifest(Stream input, Stream output)
         {
             int t1 = Environment.TickCount;
-            XmlDocument document = new XmlDocument();
-            XmlReaderSettings xrSettings = new XmlReaderSettings();
-            xrSettings.DtdProcessing = DtdProcessing.Ignore;
+            var document = new XmlDocument();
+            var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
             using (XmlReader xr = XmlReader.Create(input, xrSettings))
             {
                 document.Load(xr);
@@ -680,9 +656,11 @@ public void WriteManifest(Stream input, Stream output)
             XmlNamespaceManager nsmgr = XmlNamespaces.GetNamespaceManager(document.NameTable);
             XmlElement assemblyElement = (XmlElement)document.SelectSingleNode(XPaths.assemblyElement, nsmgr);
             if (assemblyElement == null)
+            {
                 throw new BadImageFormatException();
+            }
 
-            XmlElement trustInfoElement = (XmlElement)assemblyElement.SelectSingleNode(XPaths.trustInfoElement, nsmgr);
+            var trustInfoElement = (XmlElement)assemblyElement.SelectSingleNode(XPaths.trustInfoElement, nsmgr);
             if (trustInfoElement == null)
             {
                 trustInfoElement = document.CreateElement(XmlUtil.TrimPrefix(XPaths.trustInfoElement), XmlNamespaces.asmv2);
@@ -697,13 +675,13 @@ public void WriteManifest(Stream input, Stream output)
             }
             else
             {
-                XmlElement securityElement = (XmlElement)trustInfoElement.SelectSingleNode(XPaths.securityElement, nsmgr);
+                var securityElement = (XmlElement)trustInfoElement.SelectSingleNode(XPaths.securityElement, nsmgr);
                 if (securityElement == null)
                 {
                     securityElement = document.CreateElement(XmlUtil.TrimPrefix(XPaths.securityElement), XmlNamespaces.asmv2);
                     trustInfoElement.AppendChild(securityElement);
                 }
-                XmlElement applicationRequestMinimumElement = (XmlElement)securityElement.SelectSingleNode(XPaths.applicationRequestMinimumElement, nsmgr);
+                var applicationRequestMinimumElement = (XmlElement)securityElement.SelectSingleNode(XPaths.applicationRequestMinimumElement, nsmgr);
                 if (applicationRequestMinimumElement == null)
                 {
                     applicationRequestMinimumElement = document.CreateElement(XmlUtil.TrimPrefix(XPaths.applicationRequestMinimumElement), XmlNamespaces.asmv2);
@@ -712,10 +690,12 @@ public void WriteManifest(Stream input, Stream output)
 
                 XmlNodeList permissionSetNodes = applicationRequestMinimumElement.SelectNodes(XPaths.permissionSetElement, nsmgr);
                 foreach (XmlNode permissionSetNode in permissionSetNodes)
+                {
                     applicationRequestMinimumElement.RemoveChild(permissionSetNode);
+                }
 
                 XmlDocument permissionSetDocument = GetOutputPermissionSetDocument();
-                XmlElement permissionSetElement = (XmlElement)document.ImportNode(permissionSetDocument.DocumentElement, true);
+                var permissionSetElement = (XmlElement)document.ImportNode(permissionSetDocument.DocumentElement, true);
                 applicationRequestMinimumElement.AppendChild(permissionSetElement);
                 FixupPermissionSetElement(permissionSetElement);
             }
diff --git a/src/Tasks/ManifestUtil/Util.cs b/src/Tasks/ManifestUtil/Util.cs
index d7ce5f4f45e..eb92ae1b1ac 100644
--- a/src/Tasks/ManifestUtil/Util.cs
+++ b/src/Tasks/ManifestUtil/Util.cs
@@ -14,7 +14,6 @@
 using System.Security;
 using System.Security.Cryptography;
 using System.Text;
-using System.Xml;
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
 {
@@ -23,14 +22,14 @@ internal static class Util
         internal static readonly string Schema = Environment.GetEnvironmentVariable("VSPSCHEMA");
         internal static readonly bool logging = !String.IsNullOrEmpty(Environment.GetEnvironmentVariable("VSPLOG"));
         internal static readonly string logPath = GetLogPath();
-        private static readonly char[] s_fileNameInvalidChars = new char[] { '\\', '/', ':', '*', '?', '"', '<', '>', '|' };
-        private static StreamWriter s_logFileWriter = null;
+        private static readonly char[] s_fileNameInvalidChars = { '\\', '/', ':', '*', '?', '"', '<', '>', '|' };
+        private static StreamWriter s_logFileWriter;
         // Major, Minor, Build and Revision of CLR v2.0
-        private static int[] s_clrVersion2 = new int[] { 2, 0, 50727, 0 };
+        private static readonly int[] s_clrVersion2 = { 2, 0, 50727, 0 };
 
         #region " Platform <-> ProcessorArchitecture mapping "
         // Note: These two arrays are parallel and must correspond to one another.
-        private readonly static string[] s_platforms = new string[]
+        private static readonly string[] s_platforms =
         {
             "AnyCPU",
             "x86",
@@ -38,7 +37,7 @@ internal static class Util
             "Itanium",
             "arm"
         };
-        private readonly static string[] s_processorArchitectures = new string[]
+        private static readonly string[] s_processorArchitectures =
         {
             "msil",
             "x86",
@@ -73,7 +72,7 @@ public static int CopyStream(Stream input, Stream output)
             const int bufferSize = 0x4000;
             byte[] buffer = new byte[bufferSize];
             int bytesCopied = 0;
-            int bytesRead = 0;
+            int bytesRead;
             do
             {
                 bytesRead = input.Read(buffer, 0, bufferSize);
@@ -105,7 +104,7 @@ public static string GetAssemblyPath()
 
         public static string GetClrVersion()
         {
-            Version v = System.Environment.Version;
+            Version v = Environment.Version;
             v = new Version(v.Major, v.Minor, v.Build, 0);
             return v.ToString();
         }
@@ -120,8 +119,8 @@ public static string GetClrVersion(string targetFrameworkVersion)
             if (string.IsNullOrEmpty(targetFrameworkVersion))
                 return GetClrVersion();
 
-            Version clrVersion = null;
-            Version currentVersion = System.Environment.Version;
+            Version clrVersion;
+            Version currentVersion = Environment.Version;
             Version frameworkVersion = GetTargetFrameworkVersion(targetFrameworkVersion);
 
             // for FX 4.0 or above use the current version.
@@ -191,9 +190,9 @@ private static void GetFileInfoImpl(string path, string targetFrameWorkVersion,
             try
             {
                 s = fi.OpenRead();
-                HashAlgorithm hashAlg = null;
+                HashAlgorithm hashAlg;
 
-                if (targetFrameWorkVersion == null || targetFrameWorkVersion.Length == 0 || Util.CompareFrameworkVersions(targetFrameWorkVersion, Constants.TargetFrameworkVersion40) <= 0)
+                if (string.IsNullOrEmpty(targetFrameWorkVersion) || CompareFrameworkVersions(targetFrameWorkVersion, Constants.TargetFrameworkVersion40) <= 0)
                 {
                     hashAlg = new SHA1CryptoServiceProvider();
                 }
@@ -206,8 +205,7 @@ private static void GetFileInfoImpl(string path, string targetFrameWorkVersion,
             }
             finally
             {
-                if (s != null)
-                    s.Close();
+                s?.Close();
             }
         }
 
@@ -226,8 +224,7 @@ public static string GetRegisteredOrganization()
             if (key != null)
             {
                 string org = (string)key.GetValue("RegisteredOrganization");
-                if (org != null)
-                    org = org.Trim();
+                org = org?.Trim();
                 if (!String.IsNullOrEmpty(org))
                     return org;
             }
@@ -327,10 +324,12 @@ private static ITaskItem[] RemoveDuplicateItems(ITaskItem[] items)
             foreach (ITaskItem item in items)
             {
                 if (String.IsNullOrEmpty(item.ItemSpec))
+                {
                     continue;
+                }
 
-                string key = null;
-                AssemblyIdentity id = new AssemblyIdentity(item.ItemSpec);
+                string key;
+                var id = new AssemblyIdentity(item.ItemSpec);
                 if (id.IsStrongName)
                 {
                     key = id.GetFullName(AssemblyIdentity.FullNameFlags.All);
diff --git a/src/Tasks/ManifestUtil/XmlUtil.cs b/src/Tasks/ManifestUtil/XmlUtil.cs
index 8198a165794..9f9c37c532b 100644
--- a/src/Tasks/ManifestUtil/XmlUtil.cs
+++ b/src/Tasks/ManifestUtil/XmlUtil.cs
@@ -8,7 +8,6 @@
 using System.Globalization;
 using System.IO;
 using System.Reflection;
-using System.Security.Policy;
 using System.Text;
 using System.Xml;
 using System.Xml.XPath;
@@ -40,6 +39,7 @@ public static XmlElement CloneElementToDocument(XmlElement element, XmlDocument
                 newElement.Attributes.Append(newAttribute);
             }
             foreach (XmlNode node in element.ChildNodes)
+            {
                 if (node.NodeType == XmlNodeType.Element)
                 {
                     XmlElement childElement = CloneElementToDocument((XmlElement)node, document, namespaceURI);
@@ -50,6 +50,7 @@ public static XmlElement CloneElementToDocument(XmlElement element, XmlDocument
                     XmlComment childComment = document.CreateComment(((XmlComment)node).Data);
                     newElement.AppendChild(childComment);
                 }
+            }
             return newElement;
         }
 
@@ -75,7 +76,7 @@ public static Stream XslTransform(string resource, Stream input, params Dictiona
             Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "new XPathDocument(1) t={0}", Environment.TickCount - t2));
 
             int t3 = Environment.TickCount;
-            XslCompiledTransform xslc = new XslCompiledTransform();
+            var xslc = new XslCompiledTransform();
             // Using the Trusted Xslt is fine as the style sheet comes from our own assemblies.
             // This is similar to the prior this.GetType().Assembly/Evidence method that was used in the now depricated XslTransform.
             xslc.Load(d, XsltSettings.TrustedXslt, s_resolver);
@@ -83,7 +84,7 @@ public static Stream XslTransform(string resource, Stream input, params Dictiona
 
             // Need to copy input stream because XmlReader will close it,
             // causing errors for later callers that access the same stream
-            MemoryStream clonedInput = new MemoryStream();
+            var clonedInput = new MemoryStream();
             Util.CopyStream(input, clonedInput);
 
             int t4 = Environment.TickCount;
@@ -103,8 +104,8 @@ public static Stream XslTransform(string resource, Stream input, params Dictiona
                 }
             }
 
-            MemoryStream m = new MemoryStream();
-            XmlTextWriter w = new XmlTextWriter(m, Encoding.UTF8);
+            var m = new MemoryStream();
+            var w = new XmlTextWriter(m, Encoding.UTF8);
             w.WriteStartDocument();
 
             int t5 = Environment.TickCount;
diff --git a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
index fa47c584135..613cb26d6bd 100644
--- a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
@@ -28,44 +28,36 @@ public class CommandLineGenerator
         /// <summary>
         /// The list of active switches in the order they should be emitted.
         /// </summary>
-        private IEnumerable<string> _switchOrderList;
+        private readonly IEnumerable<string> _switchOrderList;
 
         /// <summary>
         /// The dictionary that holds all set switches
         /// The string is the name of the property, and the CommandLineToolSwitch holds all of the relevant information
         /// i.e., switch, boolean value, type, etc.
         /// </summary>
-        private Dictionary<string, CommandLineToolSwitch> _activeCommandLineToolSwitches = new Dictionary<string, CommandLineToolSwitch>(StringComparer.OrdinalIgnoreCase);
-
-        /// <summary>
-        /// Any additional options (as a literal string) that may have been specified in the project file
-        /// We eventually want to get rid of this
-        /// </summary>
-        private string _additionalOptions = String.Empty;
+        private readonly Dictionary<string, CommandLineToolSwitch> _activeCommandLineToolSwitches = new Dictionary<string, CommandLineToolSwitch>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// Creates a generator that generates a command-line based on the specified Xaml file and parameters.
         /// </summary>
         public CommandLineGenerator(Rule rule, Dictionary<string, Object> parameterValues)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(rule, "rule");
-            ErrorUtilities.VerifyThrowArgumentNull(parameterValues, "parameterValues");
+            ErrorUtilities.VerifyThrowArgumentNull(rule, nameof(rule));
+            ErrorUtilities.VerifyThrowArgumentNull(parameterValues, nameof(parameterValues));
 
             // Parse the Xaml file
-            TaskParser parser = new TaskParser();
+            var parser = new TaskParser();
             bool success = parser.ParseXamlDocument(rule);
             ErrorUtilities.VerifyThrow(success, "Unable to parse specified file or contents.");
 
             // Generate the switch order list
             _switchOrderList = parser.SwitchOrderList;
 
-            _activeCommandLineToolSwitches = new Dictionary<string, CommandLineToolSwitch>(StringComparer.OrdinalIgnoreCase);
             foreach (Property property in parser.Properties)
             {
-                Object value = null;
-                if (parameterValues.TryGetValue(property.Name, out value))
+                if (parameterValues.TryGetValue(property.Name, out object value))
                 {
-                    CommandLineToolSwitch switchToAdd = new CommandLineToolSwitch();
+                    var switchToAdd = new CommandLineToolSwitch();
                     if (!String.IsNullOrEmpty(property.Reversible) && String.Equals(property.Reversible, "true", StringComparison.OrdinalIgnoreCase))
                     {
                         switchToAdd.Reversible = true;
@@ -190,45 +182,26 @@ internal CommandLineGenerator(Dictionary<string, CommandLineToolSwitch> activeCo
         }
 
         /// <summary>
-        /// Accessor for the additional options string.
+        /// Any additional options (as a literal string) that may have been specified in the project file
         /// </summary>
-        public string AdditionalOptions
-        {
-            get
-            {
-                return _additionalOptions;
-            }
-
-            set
-            {
-                _additionalOptions = value;
-            }
-        }
+        public string AdditionalOptions { get; set; } = String.Empty;
 
         /// <summary>
         /// The template which, if set, will be used to govern formatting of the command line(s)
         /// </summary>
-        public string CommandLineTemplate
-        {
-            get;
-            set;
-        }
+        public string CommandLineTemplate { get; set; }
 
         /// <summary>
         /// The string to append to the end of a non-templated commandline.
         /// </summary>
-        public string AlwaysAppend
-        {
-            get;
-            set;
-        }
+        public string AlwaysAppend { get; set; }
 
         /// <summary>
         /// Generate the command-line
         /// </summary>
         public string GenerateCommandLine()
         {
-            CommandLineBuilder commandLineBuilder = new CommandLineBuilder(true /* quote hyphens */);
+            var commandLineBuilder = new CommandLineBuilder(true /* quote hyphens */);
 
             if (!String.IsNullOrEmpty(CommandLineTemplate))
             {
@@ -252,9 +225,9 @@ public string GenerateCommandLine()
         internal void BuildAdditionalArgs(CommandLineBuilder cmdLine)
         {
             // We want additional options to be last so that this can always override other flags.
-            if ((cmdLine != null) && !String.IsNullOrEmpty(_additionalOptions))
+            if ((cmdLine != null) && !String.IsNullOrEmpty(AdditionalOptions))
             {
-                cmdLine.AppendSwitch(_additionalOptions);
+                cmdLine.AppendSwitch(AdditionalOptions);
             }
         }
 
@@ -397,9 +370,9 @@ private static void EmitTaskItemArraySwitch(CommandLineBuilder clb, CommandLineT
         /// e.g., AdditionalIncludeDirectores = "@(Files)" where Files has File1, File2, and File3, the switch
         /// /IFile1 /IFile2 /IFile3 or the switch /IFile1;File2;File3 is emitted (the latter case has a separator
         /// ";" specified)</remarks>
-        private void EmitStringArraySwitch(CommandLineBuilder clb, CommandLineToolSwitch commandLineToolSwitch)
+        private static void EmitStringArraySwitch(CommandLineBuilder clb, CommandLineToolSwitch commandLineToolSwitch)
         {
-            List<string> stringList = new List<string>(commandLineToolSwitch.StringList.Length);
+            var stringList = new List<string>(commandLineToolSwitch.StringList.Length);
             for (int i = 0; i < commandLineToolSwitch.StringList.Length; ++i)
             {
                 // Make sure the file doesn't contain escaped " (\")
@@ -443,7 +416,7 @@ private void EmitStringArraySwitch(CommandLineBuilder clb, CommandLineToolSwitch
         /// <summary>
         /// Substitute the value for the switch into the switch value where the [value] string is found, if it exists.
         /// </summary>
-        private bool PerformSwitchValueSubstition(CommandLineBuilder clb, CommandLineToolSwitch commandLineToolSwitch, string switchValue)
+        private static bool PerformSwitchValueSubstition(CommandLineBuilder clb, CommandLineToolSwitch commandLineToolSwitch, string switchValue)
         {
             Regex regex = new Regex(@"\[value]", RegexOptions.IgnoreCase);
             Match match = regex.Match(commandLineToolSwitch.SwitchValue);
@@ -475,7 +448,7 @@ private bool PerformSwitchValueSubstition(CommandLineBuilder clb, CommandLineToo
         /// <remarks>For integer switches (e.g., WarningLevel), the CommandLineToolSwitchName is emitted
         /// with the appropriate integer appended, as well as any arguments
         /// e.g., WarningLevel = "4" will emit /W4</remarks>
-        private void EmitIntegerSwitch(CommandLineBuilder clb, CommandLineToolSwitch commandLineToolSwitch)
+        private static void EmitIntegerSwitch(CommandLineBuilder clb, CommandLineToolSwitch commandLineToolSwitch)
         {
             if (commandLineToolSwitch.IsValid)
             {
@@ -556,8 +529,7 @@ private string GatherArguments(string parentSwitch, ICollection<Tuple<string, bo
             {
                 foreach (Tuple<string, bool> arg in arguments)
                 {
-                    CommandLineToolSwitch argSwitch;
-                    if (_activeCommandLineToolSwitches.TryGetValue(arg.Item1, out argSwitch))
+                    if (_activeCommandLineToolSwitches.TryGetValue(arg.Item1, out CommandLineToolSwitch argSwitch))
                     {
                         if (!String.IsNullOrEmpty(retVal))
                         {
@@ -584,7 +556,7 @@ private string GatherArguments(string parentSwitch, ICollection<Tuple<string, bo
         /// </summary>
         /// <remarks>A boolean switch is emitted if it is set to true. If it set to false, nothing is emitted.
         /// e.g. nologo = "true" will emit /Og, but nologo = "false" will emit nothing.</remarks>
-        private void EmitBooleanSwitch(CommandLineBuilder clb, CommandLineToolSwitch commandLineToolSwitch)
+        private static void EmitBooleanSwitch(CommandLineBuilder clb, CommandLineToolSwitch commandLineToolSwitch)
         {
             if (commandLineToolSwitch.BooleanValue)
             {
@@ -609,7 +581,7 @@ private void EmitBooleanSwitch(CommandLineBuilder clb, CommandLineToolSwitch com
         /// <remarks>A reversible boolean switch will emit a certain switch if set to true, but emit that
         /// exact same switch with a flag appended on the end if set to false.
         /// e.g., GlobalOptimizations = "true" will emit /Og, and GlobalOptimizations = "false" will emit /Og-</remarks>
-        private void EmitReversibleBooleanSwitch(CommandLineBuilder clb, CommandLineToolSwitch commandLineToolSwitch)
+        private static void EmitReversibleBooleanSwitch(CommandLineBuilder clb, CommandLineToolSwitch commandLineToolSwitch)
         {
             // if the value is set to true, append whatever the TrueSuffix is set to.
             // Otherwise, append whatever the FalseSuffix is set to.
diff --git a/src/Tasks/XamlTaskFactory/CommandLineToolSwitch.cs b/src/Tasks/XamlTaskFactory/CommandLineToolSwitch.cs
index 09ff60e571e..fd175695c9b 100644
--- a/src/Tasks/XamlTaskFactory/CommandLineToolSwitch.cs
+++ b/src/Tasks/XamlTaskFactory/CommandLineToolSwitch.cs
@@ -6,9 +6,7 @@
 //-----------------------------------------------------------------------
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -77,11 +75,6 @@ public class CommandLineToolSwitch
         /// </summary>
         private const string TypeInteger = "CommandLineToolSwitchType.Integer";
 
-        /// <summary>
-        /// ITaskItem switch type
-        /// </summary>
-        private const string TypeITaskItem = "CommandLineToolSwitchType.ITaskItem";
-
         /// <summary>
         /// ITaskItemArray switch type.
         /// </summary>
@@ -94,71 +87,6 @@ public class CommandLineToolSwitch
 
         #endregion
 
-        /// <summary>
-        /// The name of the switch.
-        /// </summary>
-        private string _name = String.Empty;
-
-        /// <summary>
-        /// The switch type
-        /// </summary>
-        private CommandLineToolSwitchType _type;
-
-        /// <summary>
-        /// "true" if this should be emitted on the command line.
-        /// </summary>
-        private bool _includeInCommandLine;
-
-        /// <summary>
-        /// The suffix to use when the switch is false/negated.
-        /// </summary>
-        private string _falseSuffix = String.Empty;
-
-        /// <summary>
-        /// The suffix to use when the switch is true.
-        /// </summary>
-        private string _trueSuffix = String.Empty;
-
-        /// <summary>
-        /// The separator to use between the switch name and its parameters.
-        /// </summary>
-        private string _separator = String.Empty;
-
-        /// <summary>
-        /// The fallback parameter.
-        /// </summary>
-        private string _fallback = String.Empty;
-
-        /// <summary>
-        /// Flag indicating if the switch is required.
-        /// </summary>
-        private bool _required;
-
-        /// <summary>
-        /// Parents for the switch.
-        /// </summary>
-        private LinkedList<string> _parents = new LinkedList<string>();
-
-        /// <summary>
-        /// Overrides for the switch.
-        /// </summary>
-        private LinkedList<KeyValuePair<string, string>> _overrides = new LinkedList<KeyValuePair<string, string>>();
-
-        /// <summary>
-        /// Flag indicating if the switch is valid.
-        /// </summary>
-        private bool _isValid;
-
-        /// <summary>
-        /// Flag for boolean switches, indicating the switch is reversible.
-        /// </summary>
-        private bool _reversible;
-
-        /// <summary>
-        /// Flag indicating if the switch has multiple values.
-        /// </summary>
-        private bool _allowMultipleValues;
-
         /// <summary>
         /// The value for a boolean switch.
         /// </summary>
@@ -179,36 +107,6 @@ public class CommandLineToolSwitch
         /// </summary>
         private ITaskItem[] _taskItemArray;
 
-        /// <summary>
-        /// The value for a string type.
-        /// </summary>
-        private string _value = String.Empty;
-
-        /// <summary>
-        /// The switch text.
-        /// </summary>
-        private string _switchValue = String.Empty;
-
-        /// <summary>
-        /// The reverse switch text, for reversible switches.
-        /// </summary>
-        private string _reverseSwitchValue = String.Empty;
-
-        /// <summary>
-        /// The arguments from which the value should be derived.
-        /// </summary>
-        private ICollection<Tuple<string, bool>> _arguments;
-
-        /// <summary>
-        /// Thw switch description.
-        /// </summary>
-        private string _description = String.Empty;
-
-        /// <summary>
-        /// The display name for the switch.
-        /// </summary>
-        private string _displayName = String.Empty;
-
         /// <summary>
         /// The default constructor creates a new CommandLineToolSwitch to hold the name of
         /// the tool, the attributes, the dependent switches, and the values (if they exist)
@@ -223,7 +121,7 @@ public CommandLineToolSwitch()
         /// </summary>
         public CommandLineToolSwitch(CommandLineToolSwitchType toolType)
         {
-            _type = toolType;
+            Type = toolType;
         }
 
         #region Properties
@@ -231,229 +129,75 @@ public CommandLineToolSwitch(CommandLineToolSwitchType toolType)
         /// <summary>
         /// The name of the parameter
         /// </summary>
-        public string Name
-        {
-            get
-            {
-                return _name;
-            }
-
-            set
-            {
-                _name = value;
-            }
-        }
+        public string Name { get; set; } = String.Empty;
 
         /// <summary>
         /// Specifies if this switch should be included on the command-line.
         /// </summary>
-        public bool IncludeInCommandLine
-        {
-            get
-            {
-                return _includeInCommandLine;
-            }
-
-            set
-            {
-                _includeInCommandLine = value;
-            }
-        }
+        public bool IncludeInCommandLine { get; set; }
 
         /// <summary>
         /// The Value of the parameter
         /// </summary>
-        public string Value
-        {
-            get
-            {
-                return _value;
-            }
-
-            set
-            {
-                _value = value;
-            }
-        }
+        public string Value { get; set; } = String.Empty;
 
         /// <summary>
         /// Flag indicating if the switch is valid.
         /// </summary>
-        public bool IsValid
-        {
-            get
-            {
-                return _isValid;
-            }
-
-            set
-            {
-                _isValid = value;
-            }
-        }
+        public bool IsValid { get; set; }
 
         /// <summary>
         /// The SwitchValue of the parameter
         /// </summary>
-        public string SwitchValue
-        {
-            get
-            {
-                return _switchValue;
-            }
-
-            set
-            {
-                _switchValue = value;
-            }
-        }
+        public string SwitchValue { get; set; } = String.Empty;
 
         /// <summary>
         /// The SwitchValue of the parameter
         /// </summary>
-        public string ReverseSwitchValue
-        {
-            get
-            {
-                return _reverseSwitchValue;
-            }
-
-            set
-            {
-                _reverseSwitchValue = value;
-            }
-        }
+        public string ReverseSwitchValue { get; set; } = String.Empty;
 
         /// <summary>
         /// The arguments.
         /// </summary>
-        public ICollection<Tuple<string, bool>> Arguments
-        {
-            get
-            {
-                return _arguments;
-            }
-
-            set
-            {
-                _arguments = value;
-            }
-        }
+        public ICollection<Tuple<string, bool>> Arguments { get; set; }
 
         /// <summary>
         /// The DisplayName of the parameter
         /// </summary>
-        public string DisplayName
-        {
-            get
-            {
-                return _displayName;
-            }
-
-            set
-            {
-                _displayName = value;
-            }
-        }
+        public string DisplayName { get; set; } = String.Empty;
 
         /// <summary>
         /// The Description of the parameter
         /// </summary>
-        public string Description
-        {
-            get
-            {
-                return _description;
-            }
-
-            set
-            {
-                _description = value;
-            }
-        }
+        public string Description { get; set; } = String.Empty;
 
         /// <summary>
         /// The type of the switch, i.e., boolean, string, stringarray, etc.
         /// </summary>
-        public CommandLineToolSwitchType Type
-        {
-            get
-            {
-                return _type;
-            }
-
-            set
-            {
-                _type = value;
-            }
-        }
+        public CommandLineToolSwitchType Type { get; set; }
 
         /// <summary>
         /// Indicates whether or not the switch is emitted with a flag when false
         /// </summary>
-        public bool Reversible
-        {
-            get
-            {
-                return _reversible;
-            }
-
-            set
-            {
-                _reversible = value;
-            }
-        }
+        public bool Reversible { get; set; }
 
         /// <summary>
         /// True if multiple values are allowed.
         /// </summary>
-        public bool AllowMultipleValues
-        {
-            get
-            {
-                return _allowMultipleValues;
-            }
-
-            set
-            {
-                _allowMultipleValues = value;
-            }
-        }
+        public bool AllowMultipleValues { get; set; }
 
         /// <summary>
         /// The flag to append at the end of a switch when the switch is set to false
         /// i.e., for all CL switches that are reversible, the FalseSuffix is "-"
         /// </summary>
-        public string FalseSuffix
-        {
-            get
-            {
-                return _falseSuffix;
-            }
-
-            set
-            {
-                _falseSuffix = value;
-            }
-        }
+        public string FalseSuffix { get; set; } = String.Empty;
 
         /// <summary>
         /// The flag to append to the end of the switch when that switch is true
         /// i.e., In the OptimizeForWindows98, the switch is OPT, the FalseSuffix is
         /// :NOWIN98, and the TrueSuffix is :WIN98
         /// </summary>
-        public string TrueSuffix
-        {
-            get
-            {
-                return _trueSuffix;
-            }
-
-            set
-            {
-                _trueSuffix = value;
-            }
-        }
+        public string TrueSuffix { get; set; } = String.Empty;
 
         /// <summary>
         /// The separator indicates the characters that go between the switch and the string
@@ -461,83 +205,34 @@ public string TrueSuffix
         /// string array case, or the characters that go between the switch and the 
         /// appendage for the boolean case.
         /// </summary>
-        public string Separator
-        {
-            get
-            {
-                return _separator;
-            }
-
-            set
-            {
-                _separator = value;
-            }
-        }
+        public string Separator { get; set; } = String.Empty;
 
         /// <summary>
         /// The Fallback attribute is used to specify which property to look at in the
         /// case that the argument property is not set, or if the file that the 
         /// argument property indicates is nonexistent.
         /// </summary>
-        public string FallbackArgumentParameter
-        {
-            get
-            {
-                return _fallback;
-            }
-
-            set
-            {
-                _fallback = value;
-            }
-        }
+        public string FallbackArgumentParameter { get; set; } = String.Empty;
 
         /// <summary>
         /// This attribute specifies whether or not an argument attribute is required.
         /// </summary>
-        public bool ArgumentRequired
-        {
-            get;
-            set;
-        }
+        public bool ArgumentRequired { get; set; }
 
         /// <summary>
         /// This property indicates whether or not the property is required in the project file
         /// </summary>
-        public bool Required
-        {
-            get
-            {
-                return _required;
-            }
-
-            set
-            {
-                _required = value;
-            }
-        }
+        public bool Required { get; set; }
 
         /// <summary>
         /// This property indicates the parent of the dependency
         /// </summary>
-        public LinkedList<string> Parents
-        {
-            get
-            {
-                return _parents;
-            }
-        }
+        public LinkedList<string> Parents { get; } = new LinkedList<string>();
 
         /// <summary>
         /// This property indicates the parent of the dependency
         /// </summary>
-        public LinkedList<KeyValuePair<string, string>> Overrides
-        {
-            get
-            {
-                return _overrides;
-            }
-        }
+        public LinkedList<KeyValuePair<string, string>> Overrides { get; } = new LinkedList<KeyValuePair<string, string>>();
 
         /// <summary>
         /// The BooleanValue is used for the boolean switches, and are set to true
@@ -547,13 +242,13 @@ public bool BooleanValue
         {
             get
             {
-                ErrorUtilities.VerifyThrow(_type == CommandLineToolSwitchType.Boolean, "InvalidType", TypeBoolean);
+                ErrorUtilities.VerifyThrow(Type == CommandLineToolSwitchType.Boolean, "InvalidType", TypeBoolean);
                 return _booleanValue;
             }
 
             set
             {
-                ErrorUtilities.VerifyThrow(_type == CommandLineToolSwitchType.Boolean, "InvalidType", TypeBoolean);
+                ErrorUtilities.VerifyThrow(Type == CommandLineToolSwitchType.Boolean, "InvalidType", TypeBoolean);
                 _booleanValue = value;
             }
         }
@@ -565,13 +260,13 @@ public int Number
         {
             get
             {
-                ErrorUtilities.VerifyThrow(_type == CommandLineToolSwitchType.Integer, "InvalidType", TypeInteger);
+                ErrorUtilities.VerifyThrow(Type == CommandLineToolSwitchType.Integer, "InvalidType", TypeInteger);
                 return _number;
             }
 
             set
             {
-                ErrorUtilities.VerifyThrow(_type == CommandLineToolSwitchType.Integer, "InvalidType", TypeInteger);
+                ErrorUtilities.VerifyThrow(Type == CommandLineToolSwitchType.Integer, "InvalidType", TypeInteger);
                 _number = value;
             }
         }
@@ -584,13 +279,13 @@ public string[] StringList
         {
             get
             {
-                ErrorUtilities.VerifyThrow(_type == CommandLineToolSwitchType.StringArray, "InvalidType", TypeStringArray);
+                ErrorUtilities.VerifyThrow(Type == CommandLineToolSwitchType.StringArray, "InvalidType", TypeStringArray);
                 return _stringList;
             }
 
             set
             {
-                ErrorUtilities.VerifyThrow(_type == CommandLineToolSwitchType.StringArray, "InvalidType", TypeStringArray);
+                ErrorUtilities.VerifyThrow(Type == CommandLineToolSwitchType.StringArray, "InvalidType", TypeStringArray);
                 _stringList = value;
             }
         }
@@ -603,13 +298,13 @@ public ITaskItem[] TaskItemArray
         {
             get
             {
-                ErrorUtilities.VerifyThrow(_type == CommandLineToolSwitchType.ITaskItemArray, "InvalidType", TypeITaskItemArray);
+                ErrorUtilities.VerifyThrow(Type == CommandLineToolSwitchType.ITaskItemArray, "InvalidType", TypeITaskItemArray);
                 return _taskItemArray;
             }
 
             set
             {
-                ErrorUtilities.VerifyThrow(_type == CommandLineToolSwitchType.ITaskItemArray, "InvalidType", TypeITaskItemArray);
+                ErrorUtilities.VerifyThrow(Type == CommandLineToolSwitchType.ITaskItemArray, "InvalidType", TypeITaskItemArray);
                 _taskItemArray = value;
             }
         }
@@ -633,37 +328,25 @@ public PropertyRelation()
         /// </summary>
         public PropertyRelation(string argument, string value, bool required)
         {
-            this.Argument = argument;
-            this.Value = value;
-            this.Required = required;
+            Argument = argument;
+            Value = value;
+            Required = required;
         }
 
         /// <summary>
         /// The name of the argument
         /// </summary>
-        public string Argument
-        {
-            get;
-            set;
-        }
+        public string Argument { get; set; }
 
         /// <summary>
         /// The value.
         /// </summary>
-        public string Value
-        {
-            get;
-            set;
-        }
+        public string Value { get; set; }
 
         /// <summary>
         /// Flag indicating if the argument is required or not.
         /// </summary>
-        public bool Required
-        {
-            get;
-            set;
-        }
+        public bool Required { get; set; }
     }
 
     /// <summary>
@@ -677,16 +360,12 @@ public class CommandLineArgumentRelation : PropertyRelation
         public CommandLineArgumentRelation(string argument, string value, bool required, string separator)
             : base(argument, value, required)
         {
-            this.Separator = separator;
+            Separator = separator;
         }
 
         /// <summary>
         /// The separator.
         /// </summary>
-        public string Separator
-        {
-            get;
-            set;
-        }
+        public string Separator { get; set; }
     }
 }
diff --git a/src/Tasks/XamlTaskFactory/Property.cs b/src/Tasks/XamlTaskFactory/Property.cs
index 4f167f97b55..029ba03c87d 100644
--- a/src/Tasks/XamlTaskFactory/Property.cs
+++ b/src/Tasks/XamlTaskFactory/Property.cs
@@ -7,8 +7,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
-using System.Collections;
 
 namespace Microsoft.Build.Tasks.Xaml
 {
@@ -54,287 +52,60 @@ internal enum PropertyType
     /// </summary>
     internal class Property
     {
-        /// <summary>
-        /// The property name
-        /// </summary>
-        private string _name = String.Empty;
-
-        /// <summary>
-        /// The property type
-        /// </summary>
-        private PropertyType _type = PropertyType.None;
-
-        /// <summary>
-        /// "true" if the property should itself be emitted on the command line.
-        /// </summary>
-        private bool _includeInCommandLine;
-
-        /// <summary>
-        /// "true" if the property is a reversible switch
-        /// </summary>
-        private string _reversible = String.Empty;
-
-        /// <summary>
-        /// The switch name
-        /// </summary>
-        private string _switchName = String.Empty;
-
-        /// <summary>
-        /// The reverse switch name.
-        /// </summary>
-        private string _reverseSwitchName = String.Empty;
-
-        /// <summary>
-        /// The false suffix.
-        /// </summary>
-        private string _falseSuffix = String.Empty;
-
-        /// <summary>
-        /// The true suffix
-        /// </summary>
-        private string _trueSuffix = String.Empty;
-
-        /// <summary>
-        /// The min value for an integer property.
-        /// </summary>
-        private string _max = String.Empty;
-
-        /// <summary>
-        /// The max value for an integer property.
-        /// </summary>
-        private string _min = String.Empty;
-
-        /// <summary>
-        /// The separator between the switch and its value.
-        /// </summary>
-        private string _separator = String.Empty;
-
-        /// <summary>
-        /// The default value for the property.
-        /// </summary>
-        private string _defaultValue = String.Empty;
-
-        /// <summary>
-        /// The argument from which the switch should derive its value.
-        /// </summary>
-        private string _argument = String.Empty;
-
-        /// <summary>
-        /// The fallback argument if the preferred argument is not specified.
-        /// </summary>
-        private string _fallback = String.Empty;
-
-        /// <summary>
-        /// "true" if the property is required.
-        /// </summary>
-        private string _required = String.Empty;
-
-        /// <summary>
-        /// True if this property is an output property.
-        /// </summary>
-        private bool _output = false;
-
-        /// <summary>
-        /// The prefix for thw property.
-        /// </summary>
-        private string _prefix = null;
-
-        /// <summary>
-        /// The property category
-        /// </summary>
-        private string _category = String.Empty;
-
-        /// <summary>
-        /// The display name.
-        /// </summary>
-        private string _displayName = String.Empty;
-
-        /// <summary>
-        /// The description.
-        /// </summary>
-        private string _description = String.Empty;
-
-        /// <summary>
-        /// The parents of this property.
-        /// </summary>
-        private LinkedList<string> _parents = new LinkedList<string>();
-
-        /// <summary>
-        /// The dependencies.
-        /// </summary>
-        private LinkedList<Property> _dependencies = new LinkedList<Property>();
-
-        /// <summary>
-        /// The values allowed for this property, if it is an enum.
-        /// </summary>
-        private List<Value> _values = new List<Value>();
-
-        /// <summary>
-        /// The arguments which can provide values to this property.
-        /// </summary>
-        private List<Argument> _arguments = new List<Argument>();
-
-        /// <summary>
-        /// Default constructor
-        /// </summary>
-        public Property()
-        {
-            // does nothing
-        }
-
         #region Properties
 
         /// <summary>
         /// The type of the switch, i.e., boolean, stringarray, etc.
         /// </summary>
-        public PropertyType Type
-        {
-            get
-            {
-                return _type;
-            }
-
-            set
-            {
-                _type = value;
-            }
-        }
+        public PropertyType Type { get; set; } = PropertyType.None;
 
         /// <summary>
         /// Specifies if the property should be included on the command line.
         /// </summary>
-        public bool IncludeInCommandLine
-        {
-            get
-            {
-                return _includeInCommandLine;
-            }
-
-            set
-            {
-                _includeInCommandLine = value;
-            }
-        }
+        public bool IncludeInCommandLine { get; set; }
 
         /// <summary>
         /// Specifies whether the switch is reversible (has a false suffix) or not
         /// </summary>
-        public string Reversible
-        {
-            get
-            {
-                return _reversible;
-            }
-
-            set
-            {
-                _reversible = value;
-            }
-        }
+        public string Reversible { get; set; } = String.Empty;
 
         /// <summary>
         /// The name of the switch, without the / in front of it
         /// i.e., Od for the Optimization property
         /// </summary>
-        public string SwitchName
-        {
-            get
-            {
-                return _switchName;
-            }
-
-            set
-            {
-                _switchName = value;
-            }
-        }
+        public string SwitchName { get; set; } = String.Empty;
 
         /// <summary>
         /// The name of the reverse switch, without the / in front of it
         /// </summary>
-        public string ReverseSwitchName
-        {
-            get
-            {
-                return _reverseSwitchName;
-            }
-
-            set
-            {
-                _reverseSwitchName = value;
-            }
-        }
+        public string ReverseSwitchName { get; set; } = String.Empty;
 
         /// <summary>
         /// The flag to append at the end of a switch when the switch is set to false
         /// i.e., for all CL switches that are reversible, the FalseSuffix is "-"
         /// </summary>
-        public string FalseSuffix
-        {
-            get
-            {
-                return _falseSuffix;
-            }
-
-            set
-            {
-                _falseSuffix = value;
-            }
-        }
+        public string FalseSuffix { get; set; } = String.Empty;
 
         /// <summary>
         /// The flag to append to the end of the switch when that switch is true
         /// i.e., In the OptimizeForWindows98, the switch is OPT, the FalseSuffix is
         /// :NOWIN98, and the TrueSuffix is :WIN98
         /// </summary>
-        public string TrueSuffix
-        {
-            get
-            {
-                return _trueSuffix;
-            }
-
-            set
-            {
-                _trueSuffix = value;
-            }
-        }
+        public string TrueSuffix { get; set; } = String.Empty;
 
         /// <summary>
         /// The max integer value an integer typed switch can have
         /// An exception should be thrown in the number the user specifies is 
         /// larger than the max
         /// </summary>
-        public string Max
-        {
-            get
-            {
-                return _max;
-            }
-
-            set
-            {
-                _max = value;
-            }
-        }
+        public string Max { get; set; } = String.Empty;
 
         /// <summary>
         /// The minimum integer value an integer typed switch can have
         /// An exception should be thrown in the number the user specifies is 
         /// less than the minimum
         /// </summary>
-        public string Min
-        {
-            get
-            {
-                return _min;
-            }
-
-            set
-            {
-                _min = value;
-            }
-        }
+        public string Min { get; set; } = String.Empty;
 
         /// <summary>
         /// The separator indicates the characters that go between the switch and the string
@@ -342,35 +113,13 @@ public string Min
         /// string array case, or the characters that go between the switch and the 
         /// appendage for the boolean case.
         /// </summary>
-        public string Separator
-        {
-            get
-            {
-                return _separator;
-            }
-
-            set
-            {
-                _separator = value;
-            }
-        }
+        public string Separator { get; set; } = String.Empty;
 
         /// <summary>
         /// The default value for the switch to have (in the case of reversibles, true
         /// or false, in the case of files, a default file name)
         /// </summary>
-        public string DefaultValue
-        {
-            get
-            {
-                return _defaultValue;
-            }
-
-            set
-            {
-                _defaultValue = value;
-            }
-        }
+        public string DefaultValue { get; set; } = String.Empty;
 
         /// <summary>
         /// The argument specifies which property to look for when appending a
@@ -381,197 +130,69 @@ public string DefaultValue
         /// If PrecompiledHeaderThrough has the value "myfile", then the emitted switch
         /// would be /Ycmyfile, /YXmyfile, or /Yumyfile
         /// </summary>
-        public string Argument
-        {
-            get
-            {
-                return _argument;
-            }
-
-            set
-            {
-                _argument = value;
-            }
-        }
+        public string Argument { get; set; } = String.Empty;
 
         /// <summary>
         /// The Fallback attribute is used to specify which property to look at in the
         /// case that the argument property is not set, or if the file that the 
         /// argument property indicates is nonexistent.
         /// </summary>
-        public string Fallback
-        {
-            get
-            {
-                return _fallback;
-            }
-
-            set
-            {
-                _fallback = value;
-            }
-        }
+        public string Fallback { get; set; } = String.Empty;
 
         /// <summary>
         /// This property whether or not the property is required in the project file
         /// </summary>
-        public string Required
-        {
-            get
-            {
-                return _required;
-            }
-
-            set
-            {
-                _required = value;
-            }
-        }
+        public string Required { get; set; } = String.Empty;
 
         /// <summary>
         /// This property indicates whether the property is an output, i.e., object files
         /// </summary>
-        public bool Output
-        {
-            get
-            {
-                return _output;
-            }
-
-            set
-            {
-                _output = value;
-            }
-        }
+        public bool Output { get; set; }
 
         /// <summary>
         /// The name of the property this one is dependent on.
         /// </summary>
-        public LinkedList<string> Parents
-        {
-            get
-            {
-                return _parents;
-            }
-        }
+        public LinkedList<string> Parents { get; } = new LinkedList<string>();
 
         /// <summary>
         /// The name of the property
         /// </summary>
-        public string Name
-        {
-            get
-            {
-                return _name;
-            }
-
-            set
-            {
-                _name = value;
-            }
-        }
+        public string Name { get; set; } = String.Empty;
 
         /// <summary>
         /// The list of switches that are dependent with this one.
         /// </summary>
-        public LinkedList<Property> DependentArgumentProperties
-        {
-            get
-            {
-                return _dependencies;
-            }
-        }
+        public LinkedList<Property> DependentArgumentProperties { get; } = new LinkedList<Property>();
 
         /// <summary>
         /// The different choices for each property, and the corresponding switch
         /// </summary>
-        public List<Value> Values
-        {
-            get
-            {
-                return _values;
-            }
-        }
+        public List<Value> Values { get; } = new List<Value>();
 
         /// <summary>
         /// The prefix for each switch.
         /// </summary>
-        public string Prefix
-        {
-            get
-            {
-                return _prefix;
-            }
-
-            set
-            {
-                _prefix = value;
-            }
-        }
+        public string Prefix { get; set; }
 
         /// <summary>
         /// The Category for each switch.
         /// </summary>
-        public string Category
-        {
-            get
-            {
-                return _category;
-            }
-
-            set
-            {
-                _category = value;
-            }
-        }
+        public string Category { get; set; } = String.Empty;
 
         /// <summary>
         /// The Display Name for each switch.
         /// </summary>
-        public string DisplayName
-        {
-            get
-            {
-                return _displayName;
-            }
-
-            set
-            {
-                _displayName = value;
-            }
-        }
+        public string DisplayName { get; set; } = String.Empty;
 
         /// <summary>
         /// The Description for each switch.
         /// </summary>
-        public string Description
-        {
-            get
-            {
-                return _description;
-            }
-
-            set
-            {
-                _description = value;
-            }
-        }
+        public string Description { get; set; } = String.Empty;
 
         /// <summary>
         /// The arguments which apply to this property.
         /// </summary>
-        public List<Argument> Arguments
-        {
-            get
-            {
-                return _arguments;
-            }
-
-            set
-            {
-                _arguments = value;
-            }
-        }
+        public List<Argument> Arguments { get; set; } = new List<Argument>();
 
         #endregion
 
@@ -580,23 +201,25 @@ public List<Argument> Arguments
         /// </summary>
         public Property Clone()
         {
-            Property cloned = new Property();
-            cloned.Type = _type;
-            cloned.SwitchName = _switchName;
-            cloned.ReverseSwitchName = _reverseSwitchName;
-            cloned.FalseSuffix = _falseSuffix;
-            cloned.TrueSuffix = _trueSuffix;
-            cloned.Max = _max;
-            cloned.Min = _min;
-            cloned.Separator = _separator;
-            cloned.DefaultValue = _defaultValue;
-            cloned.Argument = _argument;
-            cloned.Fallback = _fallback;
-            cloned.Required = _required;
-            cloned.Output = _output;
-            cloned.Reversible = _reversible;
-            cloned.Name = _name;
-            cloned.Prefix = _prefix;
+            var cloned = new Property
+            {
+                Type = Type,
+                SwitchName = SwitchName,
+                ReverseSwitchName = ReverseSwitchName,
+                FalseSuffix = FalseSuffix,
+                TrueSuffix = TrueSuffix,
+                Max = Max,
+                Min = Min,
+                Separator = Separator,
+                DefaultValue = DefaultValue,
+                Argument = Argument,
+                Fallback = Fallback,
+                Required = Required,
+                Output = Output,
+                Reversible = Reversible,
+                Name = Name,
+                Prefix = Prefix
+            };
             return cloned;
         }
     }
@@ -606,152 +229,40 @@ public Property Clone()
     /// </summary>
     internal class Value
     {
-        /// <summary>
-        /// The name of the value.
-        /// </summary>
-        private string _name = String.Empty;
-
-        /// <summary>
-        /// The switch name when this value is specified.
-        /// </summary>
-        private string _switchName = String.Empty;
-
-        /// <summary>
-        /// The reverse switch name.
-        /// </summary>
-        private string _reverseSwitchName = String.Empty;
-
-        /// <summary>
-        /// The description of the value.
-        /// </summary>
-        private string _description = String.Empty;
-
-        /// <summary>
-        /// The display name of the value.
-        /// </summary>
-        private string _displayName = String.Empty;
-
-        /// <summary>
-        /// The prefix.
-        /// </summary>
-        private string _prefix = null;
-
-        /// <summary>
-        /// The arguments for this value.
-        /// </summary>
-        private List<Argument> _arguments = new List<Argument>();
-
         /// <summary>
         /// The name of the property
         /// </summary>
-        public string Name
-        {
-            get
-            {
-                return _name;
-            }
-
-            set
-            {
-                _name = value;
-            }
-        }
+        public string Name { get; set; } = String.Empty;
 
         /// <summary>
         /// The switch Name of the property
         /// </summary>
-        public string SwitchName
-        {
-            get
-            {
-                return _switchName;
-            }
-
-            set
-            {
-                _switchName = value;
-            }
-        }
+        public string SwitchName { get; set; } = String.Empty;
 
         /// <summary>
         /// The switch Name of the property
         /// </summary>
-        public string ReverseSwitchName
-        {
-            get
-            {
-                return _reverseSwitchName;
-            }
-
-            set
-            {
-                _reverseSwitchName = value;
-            }
-        }
+        public string ReverseSwitchName { get; set; } = String.Empty;
 
         /// <summary>
         /// The switch Name of the property
         /// </summary>
-        public string Description
-        {
-            get
-            {
-                return _description;
-            }
-
-            set
-            {
-                _description = value;
-            }
-        }
+        public string Description { get; set; } = String.Empty;
 
         /// <summary>
         /// The switch Name of the property
         /// </summary>
-        public string DisplayName
-        {
-            get
-            {
-                return _displayName;
-            }
-
-            set
-            {
-                _displayName = value;
-            }
-        }
+        public string DisplayName { get; set; } = String.Empty;
 
         /// <summary>
         /// The prefix for each switch.
         /// </summary>
-        public string Prefix
-        {
-            get
-            {
-                return _prefix;
-            }
-
-            set
-            {
-                _prefix = value;
-            }
-        }
+        public string Prefix { get; set; }
 
         /// <summary>
         /// The switch Name of the property
         /// </summary>
-        public List<Argument> Arguments
-        {
-            get
-            {
-                return _arguments;
-            }
-
-            set
-            {
-                _arguments = value;
-            }
-        }
+        public List<Argument> Arguments { get; set; } = new List<Argument>();
     }
 
     /// <summary>
@@ -759,67 +270,19 @@ public List<Argument> Arguments
     /// </summary>
     internal class Argument
     {
-        /// <summary>
-        /// The parameter to which the argument refers.
-        /// </summary>
-        private string _parameter = String.Empty;
-
-        /// <summary>
-        /// The argument value separator.
-        /// </summary>
-        private string _separator = String.Empty;
-
-        /// <summary>
-        /// True if the argument is required.
-        /// </summary>
-        private bool _required = false;
-
         /// <summary>
         /// The switch Name of the property
         /// </summary>
-        public string Parameter
-        {
-            get
-            {
-                return _parameter;
-            }
-
-            set
-            {
-                _parameter = value;
-            }
-        }
+        public string Parameter { get; set; } = String.Empty;
 
         /// <summary>
         /// The switch Name of the property
         /// </summary>
-        public string Separator
-        {
-            get
-            {
-                return _separator;
-            }
-
-            set
-            {
-                _separator = value;
-            }
-        }
+        public string Separator { get; set; } = String.Empty;
 
         /// <summary>
         /// The switch Name of the property
         /// </summary>
-        public bool Required
-        {
-            get
-            {
-                return _required;
-            }
-
-            set
-            {
-                _required = value;
-            }
-        }
+        public bool Required { get; set; }
     }
 }
diff --git a/src/Tasks/XamlTaskFactory/RelationsParser.cs b/src/Tasks/XamlTaskFactory/RelationsParser.cs
index 78db36c8689..17065e10e34 100644
--- a/src/Tasks/XamlTaskFactory/RelationsParser.cs
+++ b/src/Tasks/XamlTaskFactory/RelationsParser.cs
@@ -6,11 +6,9 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 using System.Xml;
 using System.IO;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks.Xaml
 {
@@ -19,176 +17,64 @@ namespace Microsoft.Build.Tasks.Xaml
     /// </summary>
     internal class SwitchRelations
     {
-        private string _switchValue;
-        private string _status;
-        private List<string> _includedPlatforms;
-        private List<string> _excludedPlatforms;
-        private List<string> _conflicts;
-        private List<string> _overrides;
-        private List<string> _requires;
-        private Dictionary<string, List<string>> _externalOverrides;
-        private Dictionary<string, List<string>> _externalConflicts;
-        private Dictionary<string, List<string>> _externalRequires;
-
         public SwitchRelations()
         {
-            _switchValue = String.Empty;
-            _status = String.Empty;
-            _conflicts = new List<string>();
-            _overrides = new List<string>();
-            _requires = new List<string>();
-            _includedPlatforms = new List<string>();
-            _excludedPlatforms = new List<string>();
-            _externalOverrides = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
-            _externalConflicts = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
-            _externalRequires = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
+            SwitchValue = String.Empty;
+            Status = String.Empty;
+            Conflicts = new List<string>();
+            Overrides = new List<string>();
+            Requires = new List<string>();
+            IncludedPlatforms = new List<string>();
+            ExcludedPlatforms = new List<string>();
+            ExternalOverrides = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
+            ExternalConflicts = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
+            ExternalRequires = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
         }
 
         public SwitchRelations Clone()
         {
-            SwitchRelations cloned = new SwitchRelations();
-            cloned._switchValue = _switchValue;
-            cloned._status = _status;
-            cloned._conflicts = new List<string>(_conflicts);
-            cloned._overrides = new List<string>(_overrides);
-            cloned._requires = new List<string>(_requires);
-            cloned._excludedPlatforms = new List<string>(_excludedPlatforms);
-            cloned._includedPlatforms = new List<string>(_includedPlatforms);
-            cloned._externalConflicts = new Dictionary<string, List<string>>(_externalConflicts, StringComparer.OrdinalIgnoreCase);
-            cloned._externalOverrides = new Dictionary<string, List<string>>(_externalOverrides, StringComparer.OrdinalIgnoreCase);
-            cloned._externalRequires = new Dictionary<string, List<string>>(_externalRequires, StringComparer.OrdinalIgnoreCase);
+            var cloned = new SwitchRelations
+            {
+                SwitchValue = SwitchValue,
+                Status = Status,
+                Conflicts = new List<string>(Conflicts),
+                Overrides = new List<string>(Overrides),
+                Requires = new List<string>(Requires),
+                ExcludedPlatforms = new List<string>(ExcludedPlatforms),
+                IncludedPlatforms = new List<string>(IncludedPlatforms),
+                ExternalConflicts = new Dictionary<string, List<string>>(
+                    ExternalConflicts,
+                    StringComparer.OrdinalIgnoreCase),
+                ExternalOverrides = new Dictionary<string, List<string>>(
+                    ExternalOverrides,
+                    StringComparer.OrdinalIgnoreCase),
+                ExternalRequires = new Dictionary<string, List<string>>(
+                    ExternalRequires,
+                    StringComparer.OrdinalIgnoreCase)
+            };
 
             return cloned;
         }
 
-        public string SwitchValue
-        {
-            get
-            {
-                return _switchValue;
-            }
+        public string SwitchValue { get; set; }
 
-            set
-            {
-                _switchValue = value;
-            }
-        }
+        public string Status { get; set; }
 
-        public string Status
-        {
-            get
-            {
-                return _status;
-            }
+        public List<string> Conflicts { get; set; }
 
-            set
-            {
-                _status = value;
-            }
-        }
+        public List<string> IncludedPlatforms { get; set; }
 
-        public List<string> Conflicts
-        {
-            get
-            {
-                return _conflicts;
-            }
+        public List<string> ExcludedPlatforms { get; set; }
 
-            set
-            {
-                _conflicts = value;
-            }
-        }
+        public List<string> Overrides { get; set; }
 
-        public List<string> IncludedPlatforms
-        {
-            get
-            {
-                return _includedPlatforms;
-            }
+        public List<string> Requires { get; set; }
 
-            set
-            {
-                _includedPlatforms = value;
-            }
-        }
+        public Dictionary<string, List<string>> ExternalOverrides { get; set; }
 
-        public List<string> ExcludedPlatforms
-        {
-            get
-            {
-                return _excludedPlatforms;
-            }
+        public Dictionary<string, List<string>> ExternalConflicts { get; set; }
 
-            set
-            {
-                _excludedPlatforms = value;
-            }
-        }
-
-        public List<string> Overrides
-        {
-            get
-            {
-                return _overrides;
-            }
-
-            set
-            {
-                _overrides = value;
-            }
-        }
-
-        public List<string> Requires
-        {
-            get
-            {
-                return _requires;
-            }
-
-            set
-            {
-                _requires = value;
-            }
-        }
-
-        public Dictionary<string, List<string>> ExternalOverrides
-        {
-            get
-            {
-                return _externalOverrides;
-            }
-            set
-            {
-                _externalOverrides = value;
-            }
-        }
-
-        public Dictionary<string, List<string>> ExternalConflicts
-        {
-            get
-            {
-                return _externalConflicts;
-            }
-
-            set
-            {
-                _externalConflicts = value;
-            }
-        }
-
-        public Dictionary<string, List<string>> ExternalRequires
-        {
-            get
-            {
-                return _externalRequires;
-            }
-
-            set
-            {
-                _externalRequires = value;
-            }
-        }
+        public Dictionary<string, List<string>> ExternalRequires { get; set; }
     }
 
     /// <summary>
@@ -196,74 +82,11 @@ public Dictionary<string, List<string>> ExternalRequires
     /// </summary>
     internal class RelationsParser
     {
-        /// <summary>
-        /// The name of the task e.g., CL
-        /// </summary>
-        private string _name;
-
-        /// <summary>
-        /// The name of the executable e.g., cl.exe
-        /// </summary>
-        private string _toolName;
-
-        /// <summary>
-        /// The base class 
-        /// </summary>
-        private string _baseClass = "DataDrivenToolTask";
-
-        /// <summary>
-        /// The namespace to generate the class into
-        /// </summary>
-        private string _namespaceValue = "MyDataDrivenTasks";
-
-        /// <summary>
-        /// The resource namespace to pass to the base class, if any
-        /// </summary>
-        private string _resourceNamespaceValue = null;
-
-        /// <summary>
-        /// The prefix to append before a switch is emitted.
-        /// Is typically a "/", but can also be a "-"
-        /// </summary>
-        private string _defaultPrefix = "/";
-
-        /// <summary>
-        /// The list that contains all of the properties that can be set on a task
-        /// </summary>
-        private LinkedList<Property> _properties = new LinkedList<Property>();
-
-        /// <summary>
-        /// The list that contains all of the properties that can be set on a task
-        /// </summary>
-        private Dictionary<string, SwitchRelations> _switchRelationsList = new Dictionary<string, SwitchRelations>(StringComparer.OrdinalIgnoreCase);
-
-        /// <summary>
-        /// The list that contains all of the properties that have a default value
-        /// </summary>
-        private LinkedList<Property> _defaultSet = new LinkedList<Property>();
-
-        /// <summary>
-        /// The list of properties that serve as fallbacks for other properties.
-        /// That is, if a certain property is not set, but has a fallback, we need to check
-        /// to see if that fallback is set.
-        /// </summary>
-        private Dictionary<string, string> _fallbackSet = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-
         /// <summary>
         /// A boolean to see if the current file parsed is an import file.
         /// </summary>
         private bool _isImport;
 
-        /// <summary>
-        /// The number of errors that occurred while parsing the xml file or generating the code
-        /// </summary>
-        private int _errorCount;
-
-        /// <summary>
-        /// The errors that occurred while parsing the xml file or generating the code
-        /// </summary>
-        private LinkedList<string> _errorLog = new LinkedList<string>();
-
         #region Private const strings
         private const string xmlNamespace = "http://schemas.microsoft.com/developer/msbuild/tasks/2005";
         private const string toolNameString = "TOOLNAME";
@@ -273,16 +96,10 @@ internal class RelationsParser
         private const string resourceNamespaceAttribute = "RESOURCENAMESPACE";
         private const string importType = "IMPORT";
         private const string tasksAttribute = "TASKS";
-        private const string parameterType = "PARAMETER";
-        private const string parameterGroupType = "PARAMETERGROUP";
-        private const string enumType = "VALUE";
         private const string task = "TASK";
         private const string nameProperty = "NAME";
         private const string status = "STATUS";
         private const string switchName = "SWITCH";
-        private const string reverseSwitchName = "REVERSESWITCH";
-        private const string oldName = "OLDNAME";
-        private const string argumentType = "ARGUMENT";
         private const string argumentValueName = "ARGUMENTVALUE";
         private const string relations = "RELATIONS";
         private const string switchGroupType = "SWITCHGROUP";
@@ -290,177 +107,70 @@ internal class RelationsParser
         private const string includedPlatformType = "INCLUDEDPLATFORM";
         private const string excludedPlatformType = "EXCLUDEDPLATFORM";
         private const string overridesType = "OVERRIDES";
-        private const string conflictsType = "CONFLICTS";
         private const string requiresType = "REQUIRES";
-        private const string externalOverridesType = "EXTERNALOVERRIDES";
-        private const string externalConflictsType = "EXTERNALCONFLICTS";
-        private const string externalRequiresType = "EXTERNALREQUIRES";
         private const string toolAttribute = "TOOL";
         private const string switchAttribute = "SWITCH";
 
-        // properties
-        private const string typeProperty = "TYPE";
-        private const string typeAlways = "ALWAYS";
-        private const string trueProperty = "TRUE";
-        private const string falseProperty = "FALSE";
-        private const string minProperty = "MIN";
-        private const string maxProperty = "MAX";
-        private const string separatorProperty = "SEPARATOR";
-        private const string defaultProperty = "DEFAULT";
-        private const string fallbackProperty = "FALLBACKARGUMENTPARAMETER";
-        private const string outputProperty = "OUTPUT";
-        private const string argumentProperty = "ARGUMENTPARAMETER";
-        private const string argumentRequiredProperty = "REQUIRED";
-        private const string propertyRequiredProperty = "REQUIRED";
-        private const string reversibleProperty = "REVERSIBLE";
-        private const string categoryProperty = "CATEGORY";
-        private const string displayNameProperty = "DISPLAYNAME";
-        private const string descriptionProperty = "DESCRIPTION";
         #endregion
-
-        /// <summary>
-        /// The constructor.
-        /// </summary>
-        public RelationsParser()
-        {
-            // do nothing
-        }
-
+        
         #region Properties
 
         /// <summary>
         /// The name of the task
         /// </summary>
-        public string GeneratedTaskName
-        {
-            get
-            {
-                return _name;
-            }
-            set
-            {
-                _name = value;
-            }
-        }
+        public string GeneratedTaskName { get; set; }
 
         /// <summary>
         /// The base type of the class
         /// </summary>
-        public string BaseClass
-        {
-            get
-            {
-                return _baseClass;
-            }
-        }
+        public string BaseClass { get; private set; } = "DataDrivenToolTask";
 
         /// <summary>
         /// The namespace of the class
         /// </summary>
-        public string Namespace
-        {
-            get
-            {
-                return _namespaceValue;
-            }
-        }
+        public string Namespace { get; private set; } = "MyDataDrivenTasks";
 
         /// <summary>
         /// Namespace for the resources
         /// </summary>
-        public string ResourceNamespace
-        {
-            get
-            {
-                return _resourceNamespaceValue;
-            }
-        }
+        public string ResourceNamespace { get; private set; }
 
         /// <summary>
         /// The name of the executable
         /// </summary>
-        public string ToolName
-        {
-            get
-            {
-                return _toolName;
-            }
-        }
+        public string ToolName { get; private set; }
 
         /// <summary>
         /// The default prefix for each switch
         /// </summary>
-        public string DefaultPrefix
-        {
-            get
-            {
-                return _defaultPrefix;
-            }
-        }
+        public string DefaultPrefix { get; private set; } = "/";
 
         /// <summary>
         /// All of the parameters that were parsed
         /// </summary>
-        public LinkedList<Property> Properties
-        {
-            get
-            {
-                return _properties;
-            }
-        }
+        public LinkedList<Property> Properties { get; } = new LinkedList<Property>();
 
         /// <summary>
         /// All of the parameters that have a default value
         /// </summary>
-        public LinkedList<Property> DefaultSet
-        {
-            get
-            {
-                return _defaultSet;
-            }
-        }
+        public LinkedList<Property> DefaultSet { get; } = new LinkedList<Property>();
 
         /// <summary>
         /// All of the properties that serve as fallbacks for unset properties
         /// </summary>
-        public Dictionary<string, string> FallbackSet
-        {
-            get
-            {
-                return _fallbackSet;
-            }
-        }
+        public Dictionary<string, string> FallbackSet { get; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// Returns the number of errors encountered
         /// </summary>
-        public int ErrorCount
-        {
-            get
-            {
-                return _errorCount;
-            }
-        }
+        public int ErrorCount { get; private set; }
 
         /// <summary>
         /// Returns the log of errors
         /// </summary>
-        public LinkedList<string> ErrorLog
-        {
-            get
-            {
-                return _errorLog;
-            }
-        }
-
-        public Dictionary<string, SwitchRelations> SwitchRelationsList
-        {
-            get
-            {
-                return _switchRelationsList;
-            }
-        }
+        public LinkedList<string> ErrorLog { get; } = new LinkedList<string>();
 
+        public Dictionary<string, SwitchRelations> SwitchRelationsList { get; } = new Dictionary<string, SwitchRelations>(StringComparer.OrdinalIgnoreCase);
 
         #endregion
 
@@ -472,9 +182,8 @@ private XmlDocument LoadFile(string fileName)
         {
             try
             {
-                XmlDocument xmlDocument = new XmlDocument();
-                XmlReaderSettings settings = new XmlReaderSettings();
-                settings.DtdProcessing = DtdProcessing.Ignore;
+                var xmlDocument = new XmlDocument();
+                XmlReaderSettings settings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
                 XmlReader reader = XmlReader.Create(fileName, settings);
                 xmlDocument.Load(reader);
                 return xmlDocument;
@@ -499,9 +208,8 @@ internal XmlDocument LoadXml(string xml)
         {
             try
             {
-                XmlDocument xmlDocument = new XmlDocument();
-                XmlReaderSettings settings = new XmlReaderSettings();
-                settings.DtdProcessing = DtdProcessing.Ignore;
+                var xmlDocument = new XmlDocument();
+                XmlReaderSettings settings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
                 XmlReader reader = XmlReader.Create(new StringReader(xml), settings);
                 xmlDocument.Load(reader);
                 return xmlDocument;
@@ -516,8 +224,6 @@ internal XmlDocument LoadXml(string xml)
         /// <summary>
         /// Parses the xml file
         /// </summary>
-        /// <param name="fileName"></param>
-        /// <returns></returns>
         public bool ParseXmlDocument(string fileName)
         {
             XmlDocument xmlDocument = LoadFile(fileName);
@@ -536,7 +242,7 @@ public bool ParseXmlDocument(string fileName)
         /// </summary>
         internal bool ParseXmlDocument(XmlDocument xmlDocument)
         {
-            ErrorUtilities.VerifyThrow(xmlDocument != null, "NoXml");
+            ErrorUtilities.VerifyThrow(xmlDocument != null, nameof(xmlDocument));
 
             // find the root element
             XmlNode node = xmlDocument.FirstChild;
@@ -573,33 +279,33 @@ internal bool ParseXmlDocument(XmlDocument xmlDocument)
             {
                 if (String.Equals(attribute.Name, prefixString, StringComparison.OrdinalIgnoreCase))
                 {
-                    _defaultPrefix = attribute.InnerText;
+                    DefaultPrefix = attribute.InnerText;
                 }
                 else if (String.Equals(attribute.Name, toolNameString, StringComparison.OrdinalIgnoreCase))
                 {
-                    _toolName = attribute.InnerText;
+                    ToolName = attribute.InnerText;
                 }
                 else if (String.Equals(attribute.Name, nameProperty, StringComparison.OrdinalIgnoreCase))
                 {
-                    _name = attribute.InnerText;
+                    GeneratedTaskName = attribute.InnerText;
                 }
                 else if (String.Equals(attribute.Name, baseClassAttribute, StringComparison.OrdinalIgnoreCase))
                 {
-                    _baseClass = attribute.InnerText;
+                    BaseClass = attribute.InnerText;
                 }
                 else if (String.Equals(attribute.Name, namespaceAttribute, StringComparison.OrdinalIgnoreCase))
                 {
-                    _namespaceValue = attribute.InnerText;
+                    Namespace = attribute.InnerText;
                 }
                 else if (String.Equals(attribute.Name, resourceNamespaceAttribute, StringComparison.OrdinalIgnoreCase))
                 {
-                    _resourceNamespaceValue = attribute.InnerText;
+                    ResourceNamespace = attribute.InnerText;
                 }
             }
             // parse the child nodes if it has any
             if (node.HasChildNodes)
             {
-                return ParseSwitchGroupOrSwitch(node.FirstChild, _switchRelationsList, null);
+                return ParseSwitchGroupOrSwitch(node.FirstChild, SwitchRelationsList, null);
             }
             else
             {
@@ -611,9 +317,6 @@ internal bool ParseXmlDocument(XmlDocument xmlDocument)
         /// <summary>
         /// Checks to see if the "name" attribute exists
         /// </summary>
-        /// <param name="node"></param>
-        /// <param name="attributeName"></param>
-        /// <returns></returns>
         private static bool VerifyAttributeExists(XmlNode node, string attributeName)
         {
             if (node.Attributes != null)
@@ -632,8 +335,6 @@ private static bool VerifyAttributeExists(XmlNode node, string attributeName)
         /// <summary>
         /// Checks to see if the element's name is "task"
         /// </summary>
-        /// <param name="node"></param>
-        /// <returns></returns>
         private static bool VerifyNodeName(XmlNode node)
         {
             return String.Equals(node.Name, relations, StringComparison.OrdinalIgnoreCase);
@@ -707,12 +408,12 @@ private bool ParseImportOption(XmlNode node)
             return true;
         }
 
-        private bool ParseSwitch(XmlNode node, Dictionary<string, SwitchRelations> switchRelationsList, SwitchRelations switchRelations)
+        private static bool ParseSwitch(XmlNode node, Dictionary<string, SwitchRelations> switchRelationsList, SwitchRelations switchRelations)
         {
             SwitchRelations switchRelationsToAdd = ObtainAttributes(node, switchRelations);
 
             // make sure that the switchRelationsList has a name, unless it is type always
-            if (switchRelationsToAdd.SwitchValue == null || switchRelationsToAdd.SwitchValue == String.Empty)
+            if (string.IsNullOrEmpty(switchRelationsToAdd.SwitchValue))
             {
                 return false;
             }
@@ -723,7 +424,6 @@ private bool ParseSwitch(XmlNode node, Dictionary<string, SwitchRelations> switc
                 switchRelationsList.Remove(switchRelationsToAdd.SwitchValue);
             }
 
-
             // build the dependencies and the values for a parameter
             XmlNode child = node.FirstChild;
             while (child != null)
@@ -732,8 +432,7 @@ private bool ParseSwitch(XmlNode node, Dictionary<string, SwitchRelations> switc
                 {
                     if (String.Equals(child.Name, requiresType, StringComparison.OrdinalIgnoreCase))
                     {
-                        string Name = String.Empty;
-                        string Tool = String.Empty;
+                        string tool = String.Empty;
                         string Switch = String.Empty;
                         bool isExternal = false;
                         foreach (XmlAttribute attrib in child.Attributes)
@@ -741,11 +440,10 @@ private bool ParseSwitch(XmlNode node, Dictionary<string, SwitchRelations> switc
                             switch (attrib.Name.ToUpperInvariant())
                             {
                                 case nameProperty:
-                                    Name = attrib.InnerText;
                                     break;
                                 case toolAttribute:
                                     isExternal = true;
-                                    Tool = attrib.InnerText;
+                                    tool = attrib.InnerText;
                                     break;
                                 case switchAttribute:
                                     Switch = attrib.InnerText;
@@ -756,21 +454,26 @@ private bool ParseSwitch(XmlNode node, Dictionary<string, SwitchRelations> switc
                         }
 
                         if (!isExternal)
+                        {
                             if (Switch != String.Empty)
+                            {
                                 switchRelationsToAdd.Requires.Add(Switch);
+                            }
                             else
+                            {
                                 return false;
+                            }
+                        }
                         else
                         {
-                            if (!switchRelationsToAdd.ExternalRequires.ContainsKey(Tool))
+                            if (!switchRelationsToAdd.ExternalRequires.ContainsKey(tool))
                             {
-                                List<string> switches = new List<string>();
-                                switches.Add(Switch);
-                                switchRelationsToAdd.ExternalRequires.Add(Tool, switches);
+                                var switches = new List<string> { Switch };
+                                switchRelationsToAdd.ExternalRequires.Add(tool, switches);
                             }
                             else
                             {
-                                switchRelationsToAdd.ExternalRequires[Tool].Add(Switch);
+                                switchRelationsToAdd.ExternalRequires[tool].Add(Switch);
                             }
                         }
                     }
@@ -833,10 +536,7 @@ private bool ParseSwitch(XmlNode node, Dictionary<string, SwitchRelations> switc
         /// Gets all the attributes assigned in the xml file for this parameter or all of the nested switches for 
         /// this parameter group
         /// </summary>
-        /// <param name="node"></param>
-        /// <param name="switchGroup"></param>
-        /// <returns></returns>
-        private SwitchRelations ObtainAttributes(XmlNode node, SwitchRelations switchGroup)
+        private static SwitchRelations ObtainAttributes(XmlNode node, SwitchRelations switchGroup)
         {
             SwitchRelations switchRelations;
             if (switchGroup != null)
@@ -869,12 +569,10 @@ private SwitchRelations ObtainAttributes(XmlNode node, SwitchRelations switchGro
         /// <summary>
         /// Increases the error count by 1, and logs the error message
         /// </summary>
-        /// <param name="messageResourceName"></param>
-        /// <param name="messageArgs"></param>
         private void LogError(string messageResourceName, params object[] messageArgs)
         {
-            _errorLog.AddLast(ResourceUtilities.FormatResourceString(messageResourceName, messageArgs));
-            _errorCount++;
+            ErrorLog.AddLast(ResourceUtilities.FormatResourceString(messageResourceName, messageArgs));
+            ErrorCount++;
         }
 
         /// <summary>
diff --git a/src/Tasks/XamlTaskFactory/TaskGenerator.cs b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
index 9969cb215cc..e182e45bed1 100644
--- a/src/Tasks/XamlTaskFactory/TaskGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
@@ -22,31 +22,11 @@ internal class TaskGenerator
         // private static strings used in code for types
         // ---------------------------------------------
 
-        /// <summary>
-        /// The base class for the task
-        /// </summary>
-        private const string BaseClass = "DataDrivenToolTask";
-
-        /// <summary>
-        /// The namespace for the task.
-        /// </summary>
-        private const string NamespaceOfGeneratedTask = "MyDataDrivenTasks";
-
         /// <summary>
         /// The property for the tool name.
         /// </summary>
         private const string ToolNamePropertyName = "ToolName";
 
-        /// <summary>
-        /// The property for the tool exe.
-        /// </summary>
-        private const string ToolExePropertyName = "ToolExe";
-
-        /// <summary>
-        /// The field for the tool exe.
-        /// </summary>
-        private const string ToolExeFieldName = "toolExe";
-
         /// <summary>
         /// IsOn
         /// </summary>
@@ -57,11 +37,6 @@ internal class TaskGenerator
         /// </summary>
         private const string IsOff = "false";
 
-        /// <summary>
-        /// AlwaysType
-        /// </summary>
-        private const string AlwaysType = "always";
-
         /// <summary>
         /// The value attribute.
         /// </summary>
@@ -71,11 +46,6 @@ internal class TaskGenerator
         // ToolSwitchType types
         // --------------------
 
-        /// <summary>
-        /// The always type
-        /// </summary>
-        private const string TypeAlways = "always";
-
         /// <summary>
         /// The boolean type
         /// </summary>
@@ -96,21 +66,6 @@ internal class TaskGenerator
         /// </summary>
         private const string TypeStringArray = "StringArray";
 
-        /// <summary>
-        /// The file type
-        /// </summary>
-        private const string TypeFile = "File";
-
-        /// <summary>
-        /// The directory type
-        /// </summary>
-        private const string TypeDirectory = "Directory";
-
-        /// <summary>
-        /// The ITaskItem type
-        /// </summary>
-        private const string TypeITaskItem = "ITaskItem";
-
         /// <summary>
         /// The ITaskItemArray type
         /// </summary>
@@ -140,16 +95,6 @@ internal class TaskGenerator
         /// </summary>
         private const string TypeToolSwitchType = "CommandLineToolSwitchType";
 
-        /// <summary>
-        /// The AlwaysAppend type.
-        /// </summary>
-        private const string TypeAlwaysAppend = "AlwaysAppend";
-
-        /// <summary>
-        /// The ArgumentRelation type.
-        /// </summary>
-        private const string TypeArgumentRelation = "CommandLineArgumentRelation";
-
         // ----------------
         // Common variables
         // ----------------
@@ -164,11 +109,6 @@ internal class TaskGenerator
         /// </summary>
         private const string DictionaryOfSwitches = "ActiveToolSwitches";
 
-        /// <summary>
-        /// The ActiveToolSwitchesValues property.
-        /// </summary>
-        private const string DictionaryOfSwitchesValues = "ActiveToolSwitchesValues";
-
         /// <summary>
         /// The switchMap field.
         /// </summary>
@@ -179,30 +119,15 @@ internal class TaskGenerator
         /// </summary>
         private const string MultiValues = "AllowMultipleValues";
 
-        /// <summary>
-        /// The relation field.
-        /// </summary>
-        private const string Relation = "relation";
-
         // --------------
         // Common methods
         // --------------
 
-        /// <summary>
-        /// The Add method.
-        /// </summary>
-        private const string AddMethod = "Add";
-
         /// <summary>
         /// The AddLast method.
         /// </summary>
         private const string AddLastMethod = "AddLast";
 
-        /// <summary>
-        /// The AlwaysAppend method.
-        /// </summary>
-        private const string AppendAlwaysMethod = "AlwaysAppend";
-
         /// <summary>
         /// The ValidateInteger method.
         /// </summary>
@@ -213,11 +138,6 @@ internal class TaskGenerator
         /// </summary>
         private const string ReadSwitchMapMethod = "ReadSwitchMap2";
 
-        /// <summary>
-        /// The Remove method.
-        /// </summary>
-        private const string RemoveMethod = "Remove";
-
         /// <summary>
         /// The IsPropertySet method.
         /// </summary>
@@ -228,11 +148,6 @@ internal class TaskGenerator
         /// </summary>
         private const string IsSwitchValueSetMethod = "IsSwitchValueSet";
 
-        /// <summary>
-        /// The EnsureTrailingSlash method.
-        /// </summary>
-        private const string EnsureTrailingSlashMethod = "EnsureTrailingSlash";
-
         /// <summary>
         /// The AddDefaultsToActiveSwitchList method.
         /// </summary>
@@ -253,11 +168,6 @@ internal class TaskGenerator
         /// </summary>
         private const string ReplaceToolSwitchMethod = "ReplaceToolSwitch";
 
-        /// <summary>
-        /// The AddActiveSwitchToolValue method.
-        /// </summary>
-        private const string AddActiveSwitchToolValueMethod = "AddActiveSwitchToolValue";
-
         /// <summary>
         /// The Overrides method.
         /// </summary>
@@ -282,11 +192,6 @@ internal class TaskGenerator
         /// </summary>
         private const string FileNameProperty = "Value";
 
-        /// <summary>
-        /// The TaskItem property
-        /// </summary>
-        private const string TaskItemProperty = "TaskItem";
-
         /// <summary>
         /// The TaskItemArray property
         /// </summary>
@@ -332,11 +237,6 @@ internal class TaskGenerator
         /// </summary>
         private const string ArgumentProperty = "ArgumentParameter";
 
-        /// <summary>
-        /// The ArgumentRequired property
-        /// </summary>
-        private const string ArgumentRequiredProperty = "ArgumentRequired";
-
         /// <summary>
         /// The Required property
         /// </summary>
@@ -367,11 +267,6 @@ internal class TaskGenerator
         /// </summary>
         private const string RequiredProperty = "Required";
 
-        /// <summary>
-        /// The ArgumentRelationList property
-        /// </summary>
-        private const string ArgumentRelationList = "ArgumentRelationList";
-
         /// <summary>
         /// The DisplayName property
         /// </summary>
@@ -392,42 +287,22 @@ internal class TaskGenerator
         /// </summary>
         private const string IsValidProperty = "IsValid";
 
-        /// <summary>
-        /// The Type property
-        /// </summary>
-        private const string TypeProperty = "Type";
-
         /// <summary>
         /// Types to ignore.
         /// </summary>
-        private string[] _propertiesTypesToIgnore = { "AdditionalOptions", "CommandLineTemplate" };
+        private static readonly string[] PropertiesTypesToIgnore = { "AdditionalOptions", "CommandLineTemplate" };
 
         #endregion
 
-        /// <summary>
-        /// The current platform.
-        /// </summary>
-        private string _platform = String.Empty;
-
-        /// <summary>
-        /// The number of errors that occurred while parsing the xml file or generating the code
-        /// </summary>
-        private int _errorCount;
-
-        /// <summary>
-        /// The errors that occurred while parsing the xml file or generating the code
-        /// </summary>
-        private LinkedList<string> _errorLog = new LinkedList<string>();
-
         /// <summary>
         /// The xml parsers
         /// </summary>
-        private TaskParser _taskParser = new TaskParser();
+        private readonly TaskParser _taskParser = new TaskParser();
 
         /// <summary>
         /// The relations parser
         /// </summary>
-        private RelationsParser _relationsParser = new RelationsParser();
+        private readonly RelationsParser _relationsParser = new RelationsParser();
 
         #region Constructor
 
@@ -442,11 +317,7 @@ public TaskGenerator()
         /// <summary>
         /// When set to true, the generated code will include comments.
         /// </summary>
-        public bool GenerateComments
-        {
-            get;
-            set;
-        }
+        public bool GenerateComments { get; set; }
 
         /// <summary>
         /// Constructor that takes a parser
@@ -461,13 +332,7 @@ internal TaskGenerator(TaskParser parser)
         /// <summary>
         /// The platform
         /// </summary>
-        private string Platform
-        {
-            get
-            {
-                return _platform;
-            }
-        }
+        private string Platform { get; } = String.Empty;
 
         #region Generate code methods
 
@@ -476,10 +341,10 @@ private string Platform
         /// </summary>
         internal void RemovePropertiesWithIgnoredTypes(LinkedList<Property> propertyList)
         {
-            LinkedList<Property> propertyToIgnoreList = new LinkedList<Property>();
+            var propertyToIgnoreList = new LinkedList<Property>();
             foreach (Property property in propertyList)
             {
-                foreach (string propertyToIgnore in _propertiesTypesToIgnore)
+                foreach (string propertyToIgnore in PropertiesTypesToIgnore)
                 {
                     if (String.Equals(property.Name, propertyToIgnore, StringComparison.OrdinalIgnoreCase))
                     {
@@ -502,9 +367,9 @@ internal CodeCompileUnit GenerateCode()
             try
             {
                 // set up the class namespace
-                CodeCompileUnit compileUnit = new CodeCompileUnit();
-                CodeNamespace dataDrivenToolTaskNamespace = new CodeNamespace(_taskParser.Namespace);
-                CodeTypeDeclaration taskClass = new CodeTypeDeclaration(_taskParser.GeneratedTaskName);
+                var compileUnit = new CodeCompileUnit();
+                var dataDrivenToolTaskNamespace = new CodeNamespace(_taskParser.Namespace);
+                var taskClass = new CodeTypeDeclaration(_taskParser.GeneratedTaskName);
 
                 if (GenerateComments)
                 {
@@ -562,20 +427,31 @@ private void GenerateDefaultSetProperties(CodeTypeDeclaration taskClass)
         {
             if (_taskParser.DefaultSet.Count > 0)
             {
-                CodeMemberMethod addToActiveSwitchList = new CodeMemberMethod();
-                addToActiveSwitchList.Name = AddDefaultsToActiveSwitchList;
-                addToActiveSwitchList.Attributes = MemberAttributes.Family | MemberAttributes.Override;
-                foreach (Property Property in _taskParser.DefaultSet)
+                var addToActiveSwitchList = new CodeMemberMethod
                 {
-                    CodeConditionStatement removeExisting = new CodeConditionStatement();
-                    removeExisting.Condition = new CodeBinaryOperatorExpression(new CodeMethodInvokeExpression(new CodeMethodReferenceExpression(new CodeThisReferenceExpression(), IsPropertySetMethod), new CodeSnippetExpression(SurroundWithQuotes(Property.Name))), CodeBinaryOperatorType.IdentityEquality, new CodeSnippetExpression("false"));
-                    if (Property.Type == PropertyType.Boolean)
+                    Name = AddDefaultsToActiveSwitchList,
+                    Attributes = MemberAttributes.Family | MemberAttributes.Override
+                };
+                foreach (Property property in _taskParser.DefaultSet)
+                {
+                    var removeExisting = new CodeConditionStatement
+                    {
+                        Condition = new CodeBinaryOperatorExpression(
+                            new CodeMethodInvokeExpression(
+                                new CodeMethodReferenceExpression(
+                                    new CodeThisReferenceExpression(),
+                                    IsPropertySetMethod),
+                                new CodeSnippetExpression(SurroundWithQuotes(property.Name))),
+                            CodeBinaryOperatorType.IdentityEquality,
+                            new CodeSnippetExpression("false"))
+                    };
+                    if (property.Type == PropertyType.Boolean)
                     {
-                        removeExisting.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(Property.Name), new CodeSnippetExpression(Property.DefaultValue)));
+                        removeExisting.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(property.Name), new CodeSnippetExpression(property.DefaultValue)));
                     }
                     else
                     {
-                        removeExisting.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(Property.Name), new CodeSnippetExpression(SurroundWithQuotes(Property.DefaultValue))));
+                        removeExisting.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(property.Name), new CodeSnippetExpression(SurroundWithQuotes(property.DefaultValue))));
                     }
                     addToActiveSwitchList.Statements.Add(removeExisting);
                 }
@@ -600,14 +476,16 @@ private void GenerateFallbacks(CodeTypeDeclaration taskClass)
         {
             if (_taskParser.FallbackSet.Count > 0)
             {
-                CodeMemberMethod addToActiveSwitchList = new CodeMemberMethod();
-                addToActiveSwitchList.Name = AddFallbacksToActiveSwitchList;
-                addToActiveSwitchList.Attributes = MemberAttributes.Family | MemberAttributes.Override;
+                var addToActiveSwitchList = new CodeMemberMethod
+                {
+                    Name = AddFallbacksToActiveSwitchList,
+                    Attributes = MemberAttributes.Family | MemberAttributes.Override
+                };
                 foreach (KeyValuePair<string, string> fallbackParameter in _taskParser.FallbackSet)
                 {
-                    CodeConditionStatement removeExisting = new CodeConditionStatement();
-                    CodeMethodInvokeExpression isPropertySet = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), IsPropertySetMethod, new CodeSnippetExpression(SurroundWithQuotes(fallbackParameter.Value)));
-                    CodeBinaryOperatorExpression propertyNotSet = new CodeBinaryOperatorExpression(new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), IsPropertySetMethod, new CodeSnippetExpression(SurroundWithQuotes(fallbackParameter.Key))), CodeBinaryOperatorType.ValueEquality, new CodeSnippetExpression(IsOff));
+                    var removeExisting = new CodeConditionStatement();
+                    var isPropertySet = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), IsPropertySetMethod, new CodeSnippetExpression(SurroundWithQuotes(fallbackParameter.Value)));
+                    var propertyNotSet = new CodeBinaryOperatorExpression(new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), IsPropertySetMethod, new CodeSnippetExpression(SurroundWithQuotes(fallbackParameter.Key))), CodeBinaryOperatorType.ValueEquality, new CodeSnippetExpression(IsOff));
                     removeExisting.Condition = new CodeBinaryOperatorExpression(propertyNotSet, CodeBinaryOperatorType.BooleanAnd, isPropertySet);
                     removeExisting.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(fallbackParameter.Key), new CodeVariableReferenceExpression(fallbackParameter.Value)));
                     addToActiveSwitchList.Statements.Add(removeExisting);
@@ -635,14 +513,18 @@ private void GenerateProperties(CodeTypeDeclaration taskClass, LinkedList<Proper
                 if (!String.Equals(property.Name, ImportType, StringComparison.OrdinalIgnoreCase))
                 {
                     if (!ContainsCurrentPlatform(property))
+                    {
                         continue;
+                    }
 
-                    CodeAttributeDeclarationCollection collection = new CodeAttributeDeclarationCollection();
-                    CodeMemberProperty propertyName = new CodeMemberProperty();
-                    propertyName.Name = property.Name;
-                    propertyName.HasGet = true;
-                    propertyName.HasSet = true;
-                    propertyName.Attributes = MemberAttributes.Public;
+                    var collection = new CodeAttributeDeclarationCollection();
+                    var propertyName = new CodeMemberProperty
+                    {
+                        Name = property.Name,
+                        HasGet = true,
+                        HasSet = true,
+                        Attributes = MemberAttributes.Public
+                    };
 
                     // check to see if the property has a default value set
                     if (!String.IsNullOrEmpty(property.DefaultValue))
@@ -710,7 +592,7 @@ private void GenerateProperties(CodeTypeDeclaration taskClass, LinkedList<Proper
         /// Generates an assignment statment for the setters of properties, where the rhs is a string
         /// e.g., switchToAdd.Name = "Optimizations";
         /// </summary>
-        private void GenerateAssignPropertyToString(CodeMemberProperty propertyName, string property, string value)
+        private static void GenerateAssignPropertyToString(CodeMemberProperty propertyName, string property, string value)
         {
             if (!String.IsNullOrEmpty(value))
             {
@@ -723,7 +605,7 @@ private void GenerateAssignPropertyToString(CodeMemberProperty propertyName, str
         /// Generates an assignment statment for the setters of properties, where the rhs is an expression
         /// e.g., switchToAdd.ArgumentRequired = true;
         /// </summary>
-        private void GenerateAssignPropertyToValue(CodeMemberProperty propertyName, string property, CodeExpression value)
+        private static void GenerateAssignPropertyToValue(CodeMemberProperty propertyName, string property, CodeExpression value)
         {
             ErrorUtilities.VerifyThrow(value != null, "NullValue", property);
             CodeAssignStatement setStatement = new CodeAssignStatement(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(SwitchToAdd), property), value);
@@ -734,7 +616,7 @@ private void GenerateAssignPropertyToValue(CodeMemberProperty propertyName, stri
         /// Generates an assignment for the toolswitch, with a prefix included
         /// i.e., switchToAdd.ToolSwitchName = "/Ox";
         /// </summary>
-        private void GenerateAssignToolSwitch(CodeMemberProperty propertyName, string property, string prefix, string toolSwitchName)
+        private static void GenerateAssignToolSwitch(CodeMemberProperty propertyName, string property, string prefix, string toolSwitchName)
         {
             if (!String.IsNullOrEmpty(toolSwitchName))
             {
@@ -760,8 +642,13 @@ private void GenerateCommon(Property property, CodeMemberProperty propertyName,
         {
             // get statements
             propertyName.Type = new CodeTypeReference(returnType);
-            CodeConditionStatement isSet = new CodeConditionStatement();
-            isSet.Condition = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "IsPropertySet", new CodeExpression[] { new CodeSnippetExpression(SurroundWithQuotes(property.Name)) });
+            var isSet = new CodeConditionStatement
+            {
+                Condition = new CodeMethodInvokeExpression(
+                    new CodeThisReferenceExpression(),
+                    "IsPropertySet",
+                    new CodeSnippetExpression(SurroundWithQuotes(property.Name)))
+            };
             isSet.TrueStatements.Add(new CodeMethodReturnStatement(new CodePropertyReferenceExpression(new CodeArrayIndexerExpression(new CodeVariableReferenceExpression(DictionaryOfSwitches), new CodeVariableReferenceExpression(SurroundWithQuotes(property.Name))), valueName)));
             if (property.Type == PropertyType.Boolean)
             {
@@ -778,7 +665,7 @@ private void GenerateCommon(Property property, CodeMemberProperty propertyName,
             propertyName.GetStatements.Add(isSet);
 
             // set statements
-            CodeVariableDeclarationStatement createNewToolSwitch = new CodeVariableDeclarationStatement(new CodeTypeReference(TypeToolSwitch), SwitchToAdd, new CodeObjectCreateExpression(TypeToolSwitch, new CodeExpression[] { new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(TypeToolSwitchType), type) }));
+            var createNewToolSwitch = new CodeVariableDeclarationStatement(new CodeTypeReference(TypeToolSwitch), SwitchToAdd, new CodeObjectCreateExpression(TypeToolSwitch, new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(TypeToolSwitchType), type)));
             propertyName.SetStatements.Add(createNewToolSwitch);
             if (!String.IsNullOrEmpty(property.Reversible) && String.Equals(property.Reversible, IsOn, StringComparison.OrdinalIgnoreCase))
             {
@@ -789,8 +676,13 @@ private void GenerateCommon(Property property, CodeMemberProperty propertyName,
             GenerateAssignPropertyToString(propertyName, SeparatorProperty, property.Separator);
             GenerateAssignPropertyToString(propertyName, DisplayNameProperty, property.DisplayName);
             GenerateAssignPropertyToString(propertyName, DescriptionProperty, property.Description);
-            if (!String.IsNullOrEmpty(property.Required) && String.Equals(property.Required, IsOn, StringComparison.OrdinalIgnoreCase))
+            if (!String.IsNullOrEmpty(property.Required) && String.Equals(
+                    property.Required,
+                    IsOn,
+                    StringComparison.OrdinalIgnoreCase))
+            {
                 GenerateAssignPropertyToValue(propertyName, RequiredProperty, new CodeSnippetExpression(property.Required));
+            }
             GenerateAssignPropertyToString(propertyName, FallbackProperty, property.Fallback);
             GenerateAssignPropertyToString(propertyName, FalseSuffixProperty, property.FalseSuffix);
             GenerateAssignPropertyToString(propertyName, TrueSuffixProperty, property.TrueSuffix);
@@ -805,7 +697,7 @@ private void GenerateCommon(Property property, CodeMemberProperty propertyName,
 
             if (property.IncludeInCommandLine)
             {
-                CodeAssignStatement setInclude = new CodeAssignStatement(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(SwitchToAdd), "IncludeInCommandLine"), new CodePrimitiveExpression(true));
+                var setInclude = new CodeAssignStatement(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(SwitchToAdd), "IncludeInCommandLine"), new CodePrimitiveExpression(true));
                 propertyName.SetStatements.Add(setInclude);
             }
 
@@ -826,7 +718,7 @@ private void GenerateCommon(Property property, CodeMemberProperty propertyName,
         /// <summary>
         /// Generates standart set statements for properties.
         /// </summary>
-        private void GenerateCommonSetStatements(Property property, CodeMemberProperty propertyName, string referencedProperty)
+        private static void GenerateCommonSetStatements(CodeMemberProperty propertyName, string referencedProperty)
         {
             if (referencedProperty != null)
             {
@@ -834,7 +726,7 @@ private void GenerateCommonSetStatements(Property property, CodeMemberProperty p
                 propertyName.SetStatements.Add(setValue);
             }
 
-            propertyName.SetStatements.Add(new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), ReplaceToolSwitchMethod, new CodeExpression[] { new CodeSnippetExpression(SwitchToAdd) }));
+            propertyName.SetStatements.Add(new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), ReplaceToolSwitchMethod, new CodeSnippetExpression(SwitchToAdd)));
         }
 
         /// <summary>
@@ -842,19 +734,21 @@ private void GenerateCommonSetStatements(Property property, CodeMemberProperty p
         /// </summary>
         private void GenerateITaskItemArray(Property property, CodeMemberProperty propertyName)
         {
-            CodeTypeReference ctr = new CodeTypeReference();
-            ctr.BaseType = "ITaskItem";
-            ctr.ArrayRank = 1;
+            var ctr = new CodeTypeReference
+            {
+                BaseType = "ITaskItem",
+                ArrayRank = 1
+            };
             GenerateCommon(property, propertyName, TypeITaskItemArray, typeof(Array), TaskItemArrayProperty);
             propertyName.Type = ctr;
-            CodeAssignStatement setToolName = new CodeAssignStatement(
-              new CodePropertyReferenceExpression(
-                  new CodeVariableReferenceExpression(SwitchToAdd), NameProperty),
-                  new CodeSnippetExpression(SurroundWithQuotes(property.Name)));
+            var setToolName = new CodeAssignStatement(
+                new CodePropertyReferenceExpression(
+                    new CodeVariableReferenceExpression(SwitchToAdd), NameProperty),
+                    new CodeSnippetExpression(SurroundWithQuotes(property.Name)));
             propertyName.SetStatements.Add(setToolName);
 
             GenerateAssignToolSwitch(propertyName, SwitchValueProperty, property.Prefix, property.SwitchName);
-            GenerateCommonSetStatements(property, propertyName, TaskItemArrayProperty);
+            GenerateCommonSetStatements(propertyName, TaskItemArrayProperty);
         }
 
         /// <summary>
@@ -885,22 +779,22 @@ private void GenerateIntegers(Property property, CodeMemberProperty propertyName
                 parameters = new CodeExpression[] { new CodeSnippetExpression(SurroundWithQuotes(name)), new CodeSnippetExpression("Int32.MinValue"), new CodeSnippetExpression("Int32.MaxValue"), new CodePropertySetValueReferenceExpression() };
             }
 
-            CodeMethodReferenceExpression validateInt = new CodeMethodReferenceExpression(new CodeThisReferenceExpression(), ValidateIntegerMethod);
+            var validateInt = new CodeMethodReferenceExpression(new CodeThisReferenceExpression(), ValidateIntegerMethod);
 
-            CodeConditionStatement isValid = new CodeConditionStatement();
-            isValid.Condition = new CodeMethodInvokeExpression(validateInt, parameters);
+            var isValid =
+                new CodeConditionStatement { Condition = new CodeMethodInvokeExpression(validateInt, parameters) };
             isValid.TrueStatements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(SwitchToAdd), IsValidProperty), new CodeSnippetExpression(IsOn)));
             isValid.FalseStatements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(SwitchToAdd), IsValidProperty), new CodeSnippetExpression(IsOff)));
             propertyName.SetStatements.Add(isValid);
 
-            CodeAssignStatement setToolName = new CodeAssignStatement(
+            var setToolName = new CodeAssignStatement(
                   new CodePropertyReferenceExpression(
                       new CodeVariableReferenceExpression(SwitchToAdd), NameProperty),
                       new CodeSnippetExpression(SurroundWithQuotes(property.Name)));
             propertyName.SetStatements.Add(setToolName);
 
             GenerateAssignToolSwitch(propertyName, SwitchValueProperty, property.Prefix, property.SwitchName);
-            GenerateCommonSetStatements(property, propertyName, NumberProperty);
+            GenerateCommonSetStatements(propertyName, NumberProperty);
         }
 
         /// <summary>
@@ -913,13 +807,13 @@ private void GenerateBooleans(Property property, CodeMemberProperty propertyName
             GenerateAssignToolSwitch(propertyName, SwitchValueProperty, property.Prefix, property.SwitchName);
             GenerateAssignToolSwitch(propertyName, ReverseSwitchValueProperty, property.Prefix, property.ReverseSwitchName);
 
-            CodeAssignStatement setToolName = new CodeAssignStatement(
-            new CodePropertyReferenceExpression(
-                new CodeVariableReferenceExpression(SwitchToAdd), NameProperty),
-                new CodeSnippetExpression(SurroundWithQuotes(property.Name)));
+            var setToolName = new CodeAssignStatement(
+                new CodePropertyReferenceExpression(
+                    new CodeVariableReferenceExpression(SwitchToAdd), NameProperty),
+                    new CodeSnippetExpression(SurroundWithQuotes(property.Name)));
             propertyName.SetStatements.Add(setToolName);
 
-            GenerateCommonSetStatements(property, propertyName, BooleanValueProperty);
+            GenerateCommonSetStatements(propertyName, BooleanValueProperty);
         }
 
         /// <summary>
@@ -928,21 +822,20 @@ private void GenerateBooleans(Property property, CodeMemberProperty propertyName
         private void GenerateStrings(Property property, CodeMemberProperty propertyName)
         {
             GenerateCommon(property, propertyName, TypeString, typeof(string), FileNameProperty);
-            string propertyToReceiveValue = null;
+            string propertyToReceiveValue;
 
             // if there are no enums, the value is the fileName, otherwise, the value is the enum's name
             if (property.Values.Count > 0)
             {
-                CodeVariableDeclarationStatement createArray = new CodeVariableDeclarationStatement("Tuple<string, string, Tuple<string, bool>[]>[]", SwitchMap);
-                List<CodeExpression> codeExpressions = new List<CodeExpression>();
+                var createArray = new CodeVariableDeclarationStatement("Tuple<string, string, Tuple<string, bool>[]>[]", SwitchMap);
+                var codeExpressions = new List<CodeExpression>();
 
-                CodeTypeReference temporaryArrayType = new CodeTypeReference(typeof(string));
                 foreach (Value val in property.Values)
                 {
                     if (ContainsCurrentPlatform(val.SwitchName))
                     {
                         // Create the array of argument expressions.                        
-                        List<CodeObjectCreateExpression> argumentInitializers = new List<CodeObjectCreateExpression>(val.Arguments.Count);
+                        var argumentInitializers = new List<CodeObjectCreateExpression>(val.Arguments.Count);
                         foreach (Argument arg in val.Arguments)
                         {
                             argumentInitializers.Add(new CodeObjectCreateExpression(new CodeTypeReference("Tuple<string, bool>"),
@@ -951,7 +844,7 @@ private void GenerateStrings(Property property, CodeMemberProperty propertyName)
                         }
 
                         // Now create the entry for the switch itself.
-                        CodeObjectCreateExpression valueExpression = new CodeObjectCreateExpression(new CodeTypeReference("Tuple<string, string, Tuple<string, bool>[]>"),
+                        var valueExpression = new CodeObjectCreateExpression(new CodeTypeReference("Tuple<string, string, Tuple<string, bool>[]>"),
                             new CodeSnippetExpression(SurroundWithQuotes(val.Name)),
                             val.SwitchName != String.Empty ? new CodeSnippetExpression(SurroundWithQuotes(val.Prefix + val.SwitchName)) : new CodeSnippetExpression(SurroundWithQuotes("")),
                             new CodeArrayCreateExpression(new CodeTypeReference("Tuple<string, bool>"), argumentInitializers.ToArray()));
@@ -961,45 +854,44 @@ private void GenerateStrings(Property property, CodeMemberProperty propertyName)
                 }
 
                 // Initialize the switch array
-                CodeArrayCreateExpression initializeArray = new CodeArrayCreateExpression("Tuple<string, string, Tuple<string, bool>[]>[]", codeExpressions.ToArray());
+                var initializeArray = new CodeArrayCreateExpression("Tuple<string, string, Tuple<string, bool>[]>[]", codeExpressions.ToArray());
                 createArray.InitExpression = initializeArray;
                 propertyName.SetStatements.Add(createArray);
 
                 // Create an index variable to hold the entry in the array we matched
-                CodeVariableDeclarationStatement indexDecl = new CodeVariableDeclarationStatement(typeof(int), "i", new CodeMethodInvokeExpression(
+                var indexDecl = new CodeVariableDeclarationStatement(typeof(int), "i", new CodeMethodInvokeExpression(
                             new CodeThisReferenceExpression(), ReadSwitchMapMethod,
-                            new CodeExpression[] { new CodeSnippetExpression(SurroundWithQuotes(property.Name)),
-                                new CodeVariableReferenceExpression(SwitchMap),
-                                new CodeVariableReferenceExpression(ValueAttribute) }));
+                            new CodeSnippetExpression(SurroundWithQuotes(property.Name)),
+                            new CodeVariableReferenceExpression(SwitchMap),
+                            new CodeVariableReferenceExpression(ValueAttribute)));
                 propertyName.SetStatements.Add(indexDecl);
 
-
                 // Set the switch value from the index into the array
-                CodeAssignStatement setToolSwitchNameGoodIndex = new CodeAssignStatement(
+                var setToolSwitchNameGoodIndex = new CodeAssignStatement(
                     new CodePropertyReferenceExpression(
                         new CodeVariableReferenceExpression(SwitchToAdd), SwitchValueProperty),
                         new CodePropertyReferenceExpression(new CodeArrayIndexerExpression(new CodeVariableReferenceExpression("switchMap"), new CodeVariableReferenceExpression("i")), "Item2"));
 
                 // Set the arguments
-                CodeAssignStatement setArgumentsGoodIndex = new CodeAssignStatement(
+                var setArgumentsGoodIndex = new CodeAssignStatement(
                     new CodePropertyReferenceExpression(
                         new CodeVariableReferenceExpression(SwitchToAdd), "Arguments"),
                         new CodePropertyReferenceExpression(new CodeArrayIndexerExpression(new CodeVariableReferenceExpression("switchMap"), new CodeVariableReferenceExpression("i")), "Item3"));
 
                 // Set the switch value from the index into the array
-                CodeAssignStatement setToolSwitchNameBadIndex = new CodeAssignStatement(
+                var setToolSwitchNameBadIndex = new CodeAssignStatement(
                     new CodePropertyReferenceExpression(
                         new CodeVariableReferenceExpression(SwitchToAdd), SwitchValueProperty),
                         new CodePrimitiveExpression(String.Empty));
 
                 // Set the arguments
-                CodeAssignStatement setArgumentsBadIndex = new CodeAssignStatement(
+                var setArgumentsBadIndex = new CodeAssignStatement(
                     new CodePropertyReferenceExpression(
                         new CodeVariableReferenceExpression(SwitchToAdd), "Arguments"),
                        new CodePrimitiveExpression(null));
 
                 // Create a CodeConditionStatement that tests a boolean value named boolean.
-                CodeConditionStatement conditionalStatement = new CodeConditionStatement(
+                var conditionalStatement = new CodeConditionStatement(
                     // The condition to test.
                     new CodeVariableReferenceExpression("i >= 0"),
                     // The statements to execute if the condition evaluates to true.
@@ -1009,14 +901,14 @@ private void GenerateStrings(Property property, CodeMemberProperty propertyName)
 
                 propertyName.SetStatements.Add(conditionalStatement);
                 // Set the separator
-                CodeAssignStatement setSeparator = new CodeAssignStatement(
+                var setSeparator = new CodeAssignStatement(
                     new CodePropertyReferenceExpression(
                         new CodeVariableReferenceExpression(SwitchToAdd), "Separator"),
                         new CodeSnippetExpression(SurroundWithQuotes(property.Separator)));
                 propertyName.SetStatements.Add(setSeparator);
 
                 // Set the tool name
-                CodeAssignStatement setToolName = new CodeAssignStatement(
+                var setToolName = new CodeAssignStatement(
                     new CodePropertyReferenceExpression(
                         new CodeVariableReferenceExpression(SwitchToAdd), NameProperty),
                         new CodeSnippetExpression(SurroundWithQuotes(property.Name)));
@@ -1027,7 +919,7 @@ private void GenerateStrings(Property property, CodeMemberProperty propertyName)
             }
             else
             {
-                CodeAssignStatement setToolName = new CodeAssignStatement(
+                var setToolName = new CodeAssignStatement(
                     new CodePropertyReferenceExpression(
                         new CodeVariableReferenceExpression(SwitchToAdd), NameProperty),
                         new CodeSnippetExpression(SurroundWithQuotes(property.Name)));
@@ -1039,14 +931,12 @@ private void GenerateStrings(Property property, CodeMemberProperty propertyName)
                 GenerateAssignToolSwitch(propertyName, ReverseSwitchValueProperty, property.Prefix, property.ReverseSwitchName);
             }
 
-            GenerateCommonSetStatements(property, propertyName, propertyToReceiveValue);
+            GenerateCommonSetStatements(propertyName, propertyToReceiveValue);
         }
 
         /// <summary>
         /// Returns true if the property refers to the current platform.
         /// </summary>
-        /// <param name="property"></param>
-        /// <returns></returns>
         private bool ContainsCurrentPlatform(Property property)
         {
             if (Platform == null)
@@ -1057,7 +947,7 @@ private bool ContainsCurrentPlatform(Property property)
                 bool containsCurrentPlatform = false;
                 foreach (Value val in property.Values)
                 {
-                    containsCurrentPlatform = ContainsCurrentPlatform(val.SwitchName) ? true : containsCurrentPlatform;
+                    containsCurrentPlatform = ContainsCurrentPlatform(val.SwitchName) || containsCurrentPlatform;
                 }
                 return containsCurrentPlatform;
             }
@@ -1116,10 +1006,10 @@ private void GenerateOverrides(Property property, CodeMemberProperty propertyNam
                         propertyName.SetStatements.Add(new CodeMethodInvokeExpression(
                             new CodeFieldReferenceExpression(
                                 new CodeVariableReferenceExpression(SwitchToAdd), Overrides), AddLastMethod,
-                                        new CodeExpression[] { new CodeObjectCreateExpression(
-                                            new CodeTypeReference(TypeKeyValuePairStrings), new CodeExpression[] {
-                                                new CodeSnippetExpression(SurroundWithQuotes(rel.SwitchValue)),
-                                                new CodeSnippetExpression(SurroundWithQuotes(overrided))})}));
+                                    new CodeObjectCreateExpression(
+                                        new CodeTypeReference(TypeKeyValuePairStrings),
+                                        new CodeSnippetExpression(SurroundWithQuotes(rel.SwitchValue)),
+                                        new CodeSnippetExpression(SurroundWithQuotes(overrided)))));
                     }
                 }
 
@@ -1133,10 +1023,10 @@ private void GenerateOverrides(Property property, CodeMemberProperty propertyNam
                             propertyName.SetStatements.Add(new CodeMethodInvokeExpression(
                                 new CodeFieldReferenceExpression(
                                     new CodeVariableReferenceExpression(SwitchToAdd), Overrides), AddLastMethod,
-                                            new CodeExpression[] {  new CodeObjectCreateExpression(
-                                                new CodeTypeReference(TypeKeyValuePairStrings), new CodeExpression[] {
-                                                    new CodeSnippetExpression(SurroundWithQuotes(rel.SwitchValue)) ,
-                                                    new CodeSnippetExpression(SurroundWithQuotes(overrided))})}));
+                                new CodeObjectCreateExpression(
+                                    new CodeTypeReference(TypeKeyValuePairStrings),
+                                    new CodeSnippetExpression(SurroundWithQuotes(rel.SwitchValue)),
+                                    new CodeSnippetExpression(SurroundWithQuotes(overrided)))));
                         }
                     }
                 }
@@ -1149,9 +1039,11 @@ private void GenerateOverrides(Property property, CodeMemberProperty propertyNam
         /// </summary>
         private void GenerateStringArrays(Property property, CodeMemberProperty propertyName)
         {
-            CodeTypeReference ctr = new CodeTypeReference();
-            ctr.BaseType = "System.String";
-            ctr.ArrayRank = 1;
+            var ctr = new CodeTypeReference
+            {
+                BaseType = "System.String",
+                ArrayRank = 1
+            };
             GenerateCommon(property, propertyName, TypeStringArray, typeof(Array), StringListProperty);
             propertyName.Type = ctr;
             GenerateAssignToolSwitch(propertyName, SwitchValueProperty, property.Prefix, property.SwitchName);
@@ -1160,7 +1052,7 @@ private void GenerateStringArrays(Property property, CodeMemberProperty property
                        new CodeVariableReferenceExpression(SwitchToAdd), NameProperty),
                        new CodeSnippetExpression(SurroundWithQuotes(property.Name)));
             propertyName.SetStatements.Add(setToolName);
-            GenerateCommonSetStatements(property, propertyName, StringListProperty);
+            GenerateCommonSetStatements(propertyName, StringListProperty);
         }
 
         /// <summary>
@@ -1168,14 +1060,16 @@ private void GenerateStringArrays(Property property, CodeMemberProperty property
         /// </summary>
         private void GenerateToolNameProperty(CodeTypeDeclaration taskClass)
         {
-            CodeMemberProperty toolNameAccessor = new CodeMemberProperty();
-            toolNameAccessor.Name = ToolNamePropertyName;
-            toolNameAccessor.HasGet = true;
-            toolNameAccessor.HasSet = false;
-            toolNameAccessor.Attributes = MemberAttributes.Override | MemberAttributes.Family;
-            toolNameAccessor.Type = new CodeTypeReference(typeof(string));
+            var toolNameAccessor = new CodeMemberProperty
+            {
+                Name = ToolNamePropertyName,
+                HasGet = true,
+                HasSet = false,
+                Attributes = MemberAttributes.Override | MemberAttributes.Family,
+                Type = new CodeTypeReference(typeof(string))
+            };
 
-            string commentContent = null;
+            string commentContent;
 
             if (GenerateComments)
             {
@@ -1200,9 +1094,9 @@ private void GenerateToolNameProperty(CodeTypeDeclaration taskClass)
         /// <summary>
         /// This method generates the code that appears at the top of each class (that imports other libraries)
         /// </summary>
-        private void GenerateImports(CodeNamespace codeNamespace)
+        private static void GenerateImports(CodeNamespace codeNamespace)
         {
-            string[] imports = new string[]
+            string[] imports =
             {
                 "System",
                 "System.Globalization",
@@ -1226,25 +1120,24 @@ private void GenerateImports(CodeNamespace codeNamespace)
         /// </summary>
         private void GenerateConstructor(CodeTypeDeclaration taskClass)
         {
-            CodeConstructor defaultConstructor = new CodeConstructor();
-            defaultConstructor.Attributes = MemberAttributes.Public;
+            var defaultConstructor = new CodeConstructor { Attributes = MemberAttributes.Public };
 
             // new System.Resources.ResourceManager("Microsoft.Build.NativeTasks.Strings", System.Reflection.Assembly.GetExecutingAssembly()))
-            CodeTypeReference resourceManagerType = new CodeTypeReference("System.Resources.ResourceManager");
-            CodeSnippetExpression resourceNamespaceString = new CodeSnippetExpression(SurroundWithQuotes(_taskParser.ResourceNamespace));
-            CodeTypeReferenceExpression systemReflectionAssembly = new CodeTypeReferenceExpression("System.Reflection.Assembly");
-            CodeMethodReferenceExpression getExecutingAssemblyReference = new CodeMethodReferenceExpression(systemReflectionAssembly, "GetExecutingAssembly");
-            CodeMethodInvokeExpression getExecutingAssembly = new CodeMethodInvokeExpression(getExecutingAssemblyReference);
-            CodeObjectCreateExpression resourceManager = new CodeObjectCreateExpression(resourceManagerType, new CodeExpression[] { resourceNamespaceString, getExecutingAssembly });
-
-            CodeTypeReference switchOrderArrayType = new CodeTypeReference(new CodeTypeReference("System.String"), 1);
-            List<CodeExpression> valueExpressions = new List<CodeExpression>();
+            var resourceManagerType = new CodeTypeReference("System.Resources.ResourceManager");
+            var resourceNamespaceString = new CodeSnippetExpression(SurroundWithQuotes(_taskParser.ResourceNamespace));
+            var systemReflectionAssembly = new CodeTypeReferenceExpression("System.Reflection.Assembly");
+            var getExecutingAssemblyReference = new CodeMethodReferenceExpression(systemReflectionAssembly, "GetExecutingAssembly");
+            var getExecutingAssembly = new CodeMethodInvokeExpression(getExecutingAssemblyReference);
+            var resourceManager = new CodeObjectCreateExpression(resourceManagerType, resourceNamespaceString, getExecutingAssembly);
+
+            var switchOrderArrayType = new CodeTypeReference(new CodeTypeReference("System.String"), 1);
+            var valueExpressions = new List<CodeExpression>();
             foreach (string switchName in _taskParser.SwitchOrderList)
             {
                 valueExpressions.Add(new CodeSnippetExpression(SurroundWithQuotes(switchName)));
             }
 
-            CodeArrayCreateExpression arrayExpression = new CodeArrayCreateExpression(switchOrderArrayType, valueExpressions.ToArray());
+            var arrayExpression = new CodeArrayCreateExpression(switchOrderArrayType, valueExpressions.ToArray());
             defaultConstructor.BaseConstructorArgs.Add(arrayExpression);
             defaultConstructor.BaseConstructorArgs.Add(resourceManager);
 
@@ -1267,31 +1160,34 @@ private void GenerateRelations(CodeTypeDeclaration taskClass)
         {
             if (_relationsParser.SwitchRelationsList.Count > 0)
             {
-                CodeMemberMethod addValidateRelationsMethod = new CodeMemberMethod();
-                addValidateRelationsMethod.Name = ValidateRelationsMethod;
-                addValidateRelationsMethod.Attributes = MemberAttributes.Family | MemberAttributes.Override;
+                var addValidateRelationsMethod = new CodeMemberMethod
+                {
+                    Name = ValidateRelationsMethod,
+                    Attributes = MemberAttributes.Family | MemberAttributes.Override
+                };
 
                 foreach (KeyValuePair<string, SwitchRelations> switchRelations in _relationsParser.SwitchRelationsList)
                 {
                     if (switchRelations.Value.Requires.Count > 0)
                     {
-                        CodeConditionStatement checkRequired = new CodeConditionStatement();
-
-                        checkRequired.Condition = null;
-
+                        var checkRequired = new CodeConditionStatement { Condition = null };
+                        
                         foreach (string required in switchRelations.Value.Requires)
                         {
                             if (checkRequired.Condition != null)
+                            {
                                 checkRequired.Condition = new CodeBinaryOperatorExpression(
-                                checkRequired.Condition, CodeBinaryOperatorType.BooleanAnd, new CodeBinaryOperatorExpression(new CodeMethodInvokeExpression(new CodeMethodReferenceExpression(new CodeThisReferenceExpression(), IsSwitchValueSetMethod), new CodeSnippetExpression(SurroundWithQuotes(required))), CodeBinaryOperatorType.IdentityEquality, new CodeSnippetExpression("false")));
+                                    checkRequired.Condition, CodeBinaryOperatorType.BooleanAnd, new CodeBinaryOperatorExpression(new CodeMethodInvokeExpression(new CodeMethodReferenceExpression(new CodeThisReferenceExpression(), IsSwitchValueSetMethod), new CodeSnippetExpression(SurroundWithQuotes(required))), CodeBinaryOperatorType.IdentityEquality, new CodeSnippetExpression("false")));
+                            }
                             else
+                            {
                                 checkRequired.Condition = new CodeBinaryOperatorExpression(new CodeMethodInvokeExpression(new CodeMethodReferenceExpression(new CodeThisReferenceExpression(), IsSwitchValueSetMethod), new CodeSnippetExpression(SurroundWithQuotes(required))), CodeBinaryOperatorType.IdentityEquality, new CodeSnippetExpression("false"));
+                            }
                         }
 
                         checkRequired.TrueStatements.Add(new CodeMethodInvokeExpression
                             (new CodeThisReferenceExpression(), "RemoveSwitchToolBasedOnValue",
-                              new CodeExpression[]{new CodeSnippetExpression(SurroundWithQuotes(switchRelations.Key)),
-                              }));
+                            new CodeSnippetExpression(SurroundWithQuotes(switchRelations.Key))));
 
                         addValidateRelationsMethod.Statements.Add(checkRequired);
                     }
@@ -1319,14 +1215,14 @@ private void GenerateRelations(CodeTypeDeclaration taskClass)
         /// </summary>
         private void LogError(string messageResourceName, params object[] messageArgs)
         {
-            _errorLog.AddLast(ResourceUtilities.FormatResourceString(messageResourceName, messageArgs));
-            _errorCount++;
+            ErrorLog.AddLast(ResourceUtilities.FormatResourceString(messageResourceName, messageArgs));
+            ErrorCount++;
         }
 
         /// <summary>
         /// Puts a string inside two quotes
         /// </summary>
-        private string SurroundWithQuotes(string unformattedText)
+        private static string SurroundWithQuotes(string unformattedText)
         {
             if (String.IsNullOrEmpty(unformattedText))
             {
@@ -1343,23 +1239,11 @@ private string SurroundWithQuotes(string unformattedText)
         /// <summary>
         /// Returns the number of errors encountered
         /// </summary>
-        internal int ErrorCount
-        {
-            get
-            {
-                return _errorCount;
-            }
-        }
+        internal int ErrorCount { get; private set; }
 
         /// <summary>
         /// Returns the log of errors
         /// </summary>
-        internal LinkedList<string> ErrorLog
-        {
-            get
-            {
-                return _errorLog;
-            }
-        }
+        internal LinkedList<string> ErrorLog { get; } = new LinkedList<string>();
     }
 }
diff --git a/src/Tasks/XamlTaskFactory/TaskParser.cs b/src/Tasks/XamlTaskFactory/TaskParser.cs
index 6934b470f7f..c427a02cbd9 100644
--- a/src/Tasks/XamlTaskFactory/TaskParser.cs
+++ b/src/Tasks/XamlTaskFactory/TaskParser.cs
@@ -13,9 +13,7 @@
 using System.Globalization;
 using System.Text;
 using System.Xaml;
-using System.Xml;
 using System.IO;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 using XamlTypes = Microsoft.Build.Framework.XamlTypes;
@@ -27,204 +25,73 @@ namespace Microsoft.Build.Tasks.Xaml
     /// </summary>
     internal class TaskParser
     {
-        /// <summary>
-        /// The name of the task e.g., CL
-        /// </summary>
-        private string _name;
-
-        /// <summary>
-        /// The name of the executable e.g., cl.exe
-        /// </summary>
-        private string _toolName;
-
-        /// <summary>
-        /// The base class 
-        /// </summary>
-        private string _baseClass = "DataDrivenToolTask";
-
-        /// <summary>
-        /// The namespace to generate the class into
-        /// </summary>
-        private string _namespaceValue = "XamlTaskNamespace";
-
-        /// <summary>
-        /// The resource namespace to pass to the base class, if any
-        /// </summary>
-        private string _resourceNamespaceValue = null;
-
-        /// <summary>
-        /// The prefix to append before a switch is emitted.
-        /// Is typically a "/", but can also be a "-"
-        /// </summary>
-        private string _defaultPrefix = String.Empty;
-
-        /// <summary>
-        /// The list that contains all of the properties that can be set on a task
-        /// </summary>
-        private LinkedList<Property> _properties = new LinkedList<Property>();
-
-        /// <summary>
-        /// The list that contains all of the properties that have a default value
-        /// </summary>
-        private LinkedList<Property> _defaultSet = new LinkedList<Property>();
-
-        /// <summary>
-        /// The list of properties that serve as fallbacks for other properties.
-        /// That is, if a certain property is not set, but has a fallback, we need to check
-        /// to see if that fallback is set.
-        /// </summary>
-        private Dictionary<string, string> _fallbackSet = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-
         /// <summary>
         /// The set of switches added so far.
         /// </summary>
-        private HashSet<string> _switchesAdded = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+        private readonly HashSet<string> _switchesAdded = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// The ordered list of how the switches get emitted.
         /// </summary>
-        private List<string> _switchOrderList = new List<string>();
-
-        /// <summary>
-        /// The errors that occurred while parsing the xml file or generating the code
-        /// </summary>
-        private LinkedList<string> _errorLog = new LinkedList<string>();
-
-        /// <summary>
-        /// The constructor.
-        /// </summary>
-        public TaskParser()
-        {
-            // do nothing
-        }
+        private readonly List<string> _switchOrderList = new List<string>();
 
         #region Properties
 
         /// <summary>
         /// The name of the task
         /// </summary>
-        public string GeneratedTaskName
-        {
-            get
-            {
-                return _name;
-            }
-
-            set
-            {
-                _name = value;
-            }
-        }
+        public string GeneratedTaskName { get; set; }
 
         /// <summary>
         /// The base type of the class
         /// </summary>
-        public string BaseClass
-        {
-            get
-            {
-                return _baseClass;
-            }
-        }
+        public string BaseClass { get; } = "DataDrivenToolTask";
 
         /// <summary>
         /// The namespace of the class
         /// </summary>
-        public string Namespace
-        {
-            get
-            {
-                return _namespaceValue;
-            }
-        }
+        public string Namespace { get; } = "XamlTaskNamespace";
 
         /// <summary>
         /// Namespace for the resources
         /// </summary>
-        public string ResourceNamespace
-        {
-            get
-            {
-                return _resourceNamespaceValue;
-            }
-        }
+        public string ResourceNamespace { get; }
 
         /// <summary>
         /// The name of the executable
         /// </summary>
-        public string ToolName
-        {
-            get
-            {
-                return _toolName;
-            }
-        }
+        public string ToolName { get; private set; }
 
         /// <summary>
         /// The default prefix for each switch
         /// </summary>
-        public string DefaultPrefix
-        {
-            get
-            {
-                return _defaultPrefix;
-            }
-        }
+        public string DefaultPrefix { get; private set; } = String.Empty;
 
         /// <summary>
         /// All of the parameters that were parsed
         /// </summary>
-        public LinkedList<Property> Properties
-        {
-            get
-            {
-                return _properties;
-            }
-        }
+        public LinkedList<Property> Properties { get; } = new LinkedList<Property>();
 
         /// <summary>
         /// All of the parameters that have a default value
         /// </summary>
-        public LinkedList<Property> DefaultSet
-        {
-            get
-            {
-                return _defaultSet;
-            }
-        }
+        public LinkedList<Property> DefaultSet { get; } = new LinkedList<Property>();
 
         /// <summary>
         /// All of the properties that serve as fallbacks for unset properties
         /// </summary>
-        public Dictionary<string, string> FallbackSet
-        {
-            get
-            {
-                return _fallbackSet;
-            }
-        }
+        public Dictionary<string, string> FallbackSet { get; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// The ordered list of properties
         /// </summary>
-        public IEnumerable<string> SwitchOrderList
-        {
-            get
-            {
-                return _switchOrderList;
-            }
-        }
+        public IEnumerable<string> SwitchOrderList => _switchOrderList;
 
         /// <summary>
         /// Returns the log of errors
         /// </summary>
-        public LinkedList<string> ErrorLog
-        {
-            get
-            {
-                return _errorLog;
-            }
-        }
+        public LinkedList<string> ErrorLog { get; } = new LinkedList<string>();
+
         #endregion
 
         /// <summary>
@@ -232,13 +99,13 @@ public LinkedList<string> ErrorLog
         /// </summary>
         public bool Parse(string contentOrFile, string desiredRule)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(contentOrFile, "contentOrFile");
-            ErrorUtilities.VerifyThrowArgumentLength(desiredRule, "desiredRule");
+            ErrorUtilities.VerifyThrowArgumentLength(contentOrFile, nameof(contentOrFile));
+            ErrorUtilities.VerifyThrowArgumentLength(desiredRule, nameof(desiredRule));
 
             bool parseSuccessful = ParseAsContentOrFile(contentOrFile, desiredRule);
             if (!parseSuccessful)
             {
-                StringBuilder parseErrors = new StringBuilder();
+                var parseErrors = new StringBuilder();
                 parseErrors.AppendLine();
                 foreach (string error in ErrorLog)
                 {
@@ -318,8 +185,8 @@ private bool ParseAsContentOrFile(string contentOrFile, string desiredRule)
         /// </summary>
         internal bool ParseXamlDocument(TextReader reader, string desiredRule)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(reader, "reader");
-            ErrorUtilities.VerifyThrowArgumentLength(desiredRule, "desiredRule");
+            ErrorUtilities.VerifyThrowArgumentNull(reader, nameof(reader));
+            ErrorUtilities.VerifyThrowArgumentLength(desiredRule, nameof(desiredRule));
 
             object rootObject = XamlServices.Load(reader);
             if (null != rootObject)
@@ -360,23 +227,23 @@ internal bool ParseXamlDocument(XamlTypes.Rule rule)
                 return false;
             }
 
-            _defaultPrefix = rule.SwitchPrefix;
+            DefaultPrefix = rule.SwitchPrefix;
 
-            _toolName = rule.ToolName;
-            _name = rule.Name;
+            ToolName = rule.ToolName;
+            GeneratedTaskName = rule.Name;
 
             // Dictionary of property name strings to property objects. If a property is in the argument list of the current property then we want to make sure
             // that the argument property is a dependency of the current property.
 
             // As properties are parsed they are added to this dictionary so that after we can find the property instances from the names quickly.
-            Dictionary<string, Property> argumentDependencyLookup = new Dictionary<string, Property>(StringComparer.OrdinalIgnoreCase);
+            var argumentDependencyLookup = new Dictionary<string, Property>(StringComparer.OrdinalIgnoreCase);
 
             // baseClass = attribute.InnerText;
             // namespaceValue = attribute.InnerText;
             // resourceNamespaceValue = attribute.InnerText;
             foreach (XamlTypes.BaseProperty property in rule.Properties)
             {
-                if (!ParseParameterGroupOrParameter(property, _properties, null, argumentDependencyLookup /*Add to the dictionary properties as they are parsed*/))
+                if (!ParseParameterGroupOrParameter(property, Properties, null, argumentDependencyLookup /*Add to the dictionary properties as they are parsed*/))
                 {
                     return false;
                 }
@@ -391,8 +258,7 @@ internal bool ParseXamlDocument(XamlTypes.Rule rule)
                 // Find all of the properties in arguments list.
                 foreach (Argument argument in arguments)
                 {
-                    Property argumentProperty = null;
-                    if (argumentDependencyLookup.TryGetValue(argument.Parameter, out argumentProperty))
+                    if (argumentDependencyLookup.TryGetValue(argument.Parameter, out Property argumentProperty))
                     {
                         property.DependentArgumentProperties.AddLast(argumentProperty);
                     }
@@ -407,9 +273,7 @@ internal bool ParseXamlDocument(XamlTypes.Rule rule)
                     List<Argument> valueArguments = value.Arguments;
                     foreach (Argument argument in valueArguments)
                     {
-                        Property argumentProperty = null;
-
-                        if (argumentDependencyLookup.TryGetValue(argument.Parameter, out argumentProperty))
+                        if (argumentDependencyLookup.TryGetValue(argument.Parameter, out Property argumentProperty))
                         {
                             // If the property contains a value sub property that has a argument then we will declare that the original property has the same dependenecy.
                             property.DependentArgumentProperties.AddLast(argumentProperty);
@@ -465,10 +329,12 @@ private bool ParseParameter(XamlTypes.BaseProperty baseProperty, LinkedList<Prop
             {
                 foreach (XamlTypes.EnumValue enumValue in enumProperty.AdmissibleValues)
                 {
-                    Value value = new Value();
+                    var value = new Value
+                    {
+                        Name = enumValue.Name,
+                        SwitchName = enumValue.Switch
+                    };
 
-                    value.Name = enumValue.Name;
-                    value.SwitchName = enumValue.Switch;
                     if (value.SwitchName == null)
                     {
                         value.SwitchName = String.Empty;
@@ -492,10 +358,12 @@ private bool ParseParameter(XamlTypes.BaseProperty baseProperty, LinkedList<Prop
                         value.Arguments = new List<Argument>();
                         foreach (XamlTypes.Argument argument in enumValue.Arguments)
                         {
-                            Argument arg = new Argument();
-                            arg.Parameter = argument.Property;
-                            arg.Separator = argument.Separator;
-                            arg.Required = argument.IsRequired;
+                            var arg = new Argument
+                            {
+                                Parameter = argument.Property,
+                                Separator = argument.Separator,
+                                Required = argument.IsRequired
+                            };
                             value.Arguments.Add(arg);
                         }
                     }
@@ -518,10 +386,12 @@ private bool ParseParameter(XamlTypes.BaseProperty baseProperty, LinkedList<Prop
                     propertyToAdd.Arguments = new List<Argument>();
                 }
 
-                Argument arg = new Argument();
-                arg.Parameter = argument.Property;
-                arg.Separator = argument.Separator;
-                arg.Required = argument.IsRequired;
+                var arg = new Argument
+                {
+                    Parameter = argument.Property,
+                    Separator = argument.Separator,
+                    Required = argument.IsRequired
+                };
                 propertyToAdd.Arguments.Add(arg);
             }
 
@@ -540,7 +410,7 @@ private bool ParseParameter(XamlTypes.BaseProperty baseProperty, LinkedList<Prop
         /// Gets all the attributes assigned in the xml file for this parameter or all of the nested switches for 
         /// this parameter group
         /// </summary>
-        private Property ObtainAttributes(XamlTypes.BaseProperty baseProperty, Property parameterGroup)
+        private static Property ObtainAttributes(XamlTypes.BaseProperty baseProperty, Property parameterGroup)
         {
             Property parameter;
             if (parameterGroup != null)
diff --git a/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs b/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
index 7343f27bc2e..7a6f2878b6c 100644
--- a/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
+++ b/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
@@ -18,31 +18,6 @@ namespace Microsoft.Build.Tasks.Xaml
     /// </summary>
     public abstract class XamlDataDrivenToolTask : ToolTask
     {
-        /// <summary>
-        /// The list of switches in the order they should appear, if set.
-        /// </summary>
-        private IEnumerable<String> _switchOrderList;
-
-        /// <summary>
-        /// The dictionary that holds all set switches
-        /// The string is the name of the property, and the CommandLineToolSwitch holds all of the relevant information
-        /// i.e., switch, boolean value, type, etc.
-        /// </summary>
-        private Dictionary<string, CommandLineToolSwitch> _activeToolSwitches = new Dictionary<string, CommandLineToolSwitch>(StringComparer.OrdinalIgnoreCase);
-
-        /// <summary>
-        /// The dictionary holds all of the legal values that are associated with a certain switch.
-        /// For example, the key Optimization would hold another dictionary as the value, that had the string pairs
-        /// "Disabled", "/Od"; "MaxSpeed", "/O1"; "MinSpace", "/O2"; "Full", "/Ox" in it.
-        /// </summary>
-        private Dictionary<string, Dictionary<string, string>> _values = new Dictionary<string, Dictionary<string, string>>(StringComparer.OrdinalIgnoreCase);
-
-        /// <summary>
-        /// Any additional options (as a literal string) that may have been specified in the project file
-        /// We eventually want to get rid of this
-        /// </summary>
-        private string _additionalOptions = String.Empty;
-
         /// <summary>
         /// True if we returned our commands directly from the command line generation and do not need to use the
         /// response file (because the command-line is short enough)
@@ -54,20 +29,10 @@ public abstract class XamlDataDrivenToolTask : ToolTask
         /// </summary>
         private TaskLoggingHelper _logPrivate;
 
-        /// <summary>
-        /// The set of active tool switch values.
-        /// </summary>
-        private Dictionary<string, CommandLineToolSwitch> _activeToolSwitchesValues = new Dictionary<string, CommandLineToolSwitch>(StringComparer.OrdinalIgnoreCase);
-
-        /// <summary>
-        /// An array of non-zero codes which don't cause an error.
-        /// </summary>
-        private string[] _acceptableNonZeroExitCodes = null;
-
         /// <summary>
         /// The command line for this task. 
         /// </summary>
-        private string _commandLine = null;
+        private string _commandLine;
 
         /// <summary>
         /// Constructor called by the generated task.
@@ -75,124 +40,61 @@ public abstract class XamlDataDrivenToolTask : ToolTask
         protected XamlDataDrivenToolTask(string[] switchOrderList, ResourceManager taskResources)
             : base(taskResources)
         {
-            this.InitializeLogger(taskResources);
-            _switchOrderList = switchOrderList;
+            InitializeLogger(taskResources);
+            SwitchOrderList = switchOrderList;
 
-            _logPrivate = new TaskLoggingHelper(this);
-            _logPrivate.TaskResources = AssemblyResources.PrimaryResources;
-            _logPrivate.HelpKeywordPrefix = "MSBuild.";
+            _logPrivate = new TaskLoggingHelper(this)
+            {
+                TaskResources = AssemblyResources.PrimaryResources,
+                HelpKeywordPrefix = "MSBuild."
+            };
         }
 
         /// <summary>
         /// The command-line template to use, if any.
         /// </summary>
-        public string CommandLineTemplate
-        {
-            get;
-            set;
-        }
+        public string CommandLineTemplate { get; set; }
 
         /// <summary>
         /// The additional options that have been set. These are raw switches that
         /// go last on the command line.
         /// </summary>
-        public string AdditionalOptions
-        {
-            get
-            {
-                return _additionalOptions;
-            }
-
-            set
-            {
-                _additionalOptions = value;
-            }
-        }
+        public string AdditionalOptions { get; set; } = String.Empty;
 
         /// <summary>
         /// Retrieves the list of acceptable non-zero exit codes.
         /// </summary>
         [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "NonZero", Justification = "Already shipped as public API")]
-        public virtual string[] AcceptableNonZeroExitCodes
-        {
-            get
-            {
-                return _acceptableNonZeroExitCodes;
-            }
-            set
-            {
-                _acceptableNonZeroExitCodes = value;
-            }
-        }
+        public virtual string[] AcceptableNonZeroExitCodes { get; set; }
 
         /// <summary>
         /// Gets or set the dictionary of active tool switch values.
         /// </summary>
-        public Dictionary<string, CommandLineToolSwitch> ActiveToolSwitchesValues
-        {
-            get
-            {
-                return _activeToolSwitchesValues;
-            }
-
-            set
-            {
-                _activeToolSwitchesValues = value;
-            }
-        }
+        public Dictionary<string, CommandLineToolSwitch> ActiveToolSwitchesValues { get; set; } = new Dictionary<string, CommandLineToolSwitch>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// Ordered list of switches
         /// </summary>
         /// <returns>ArrayList of switches in declaration order</returns>
-        internal virtual IEnumerable<string> SwitchOrderList
-        {
-            get
-            {
-                return _switchOrderList;
-            }
-        }
+        internal virtual IEnumerable<string> SwitchOrderList { get; }
 
         /// <summary>
         /// The list of all the switches that have been set
         /// </summary>
-        protected internal Dictionary<string, CommandLineToolSwitch> ActiveToolSwitches
-        {
-            get
-            {
-                return _activeToolSwitches;
-            }
-        }
+        protected internal Dictionary<string, CommandLineToolSwitch> ActiveToolSwitches { get; } = new Dictionary<string, CommandLineToolSwitch>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// Overridden to use UTF16, which works better than UTF8 for older versions of CL, LIB, etc. 
         /// </summary>
-        protected override Encoding ResponseFileEncoding
-        {
-            get
-            {
-                return Encoding.Unicode;
-            }
-        }
+        protected override Encoding ResponseFileEncoding { get; } = Encoding.Unicode;
 
         /// <summary>
         /// Made a property to abstract out the "if null, call GenerateCommands()" logic. 
         /// </summary>
         private string CommandLine
         {
-            get
-            {
-                if (_commandLine == null)
-                {
-                    _commandLine = GenerateCommands();
-                }
-
-                return _commandLine;
-            }
-            set
-            {
-                _commandLine = value;
-            }
+            get => _commandLine ?? (_commandLine = GenerateCommands());
+            set => _commandLine = value;
         }
 
         /// <summary>
@@ -202,12 +104,10 @@ public bool IsPropertySet(string propertyName)
         {
             if (!String.IsNullOrEmpty(propertyName))
             {
-                return _activeToolSwitches.ContainsKey(propertyName);
-            }
-            else
-            {
-                return false;
+                return ActiveToolSwitches.ContainsKey(propertyName);
             }
+
+            return false;
         }
 
         /// <summary>
@@ -215,7 +115,7 @@ public bool IsPropertySet(string propertyName)
         /// </summary>
         public void ReplaceToolSwitch(CommandLineToolSwitch switchToAdd)
         {
-            _activeToolSwitches[switchToAdd.Name] = switchToAdd;
+            ActiveToolSwitches[switchToAdd.Name] = switchToAdd;
         }
 
         /// <summary>
@@ -223,17 +123,16 @@ public void ReplaceToolSwitch(CommandLineToolSwitch switchToAdd)
         /// </summary>
         public void AddActiveSwitchToolValue(CommandLineToolSwitch switchToAdd)
         {
-            if (((switchToAdd.Type != CommandLineToolSwitchType.Boolean)
-                            || (switchToAdd.BooleanValue == true)))
+            if (switchToAdd.Type != CommandLineToolSwitchType.Boolean || switchToAdd.BooleanValue)
             {
-                if ((switchToAdd.SwitchValue != String.Empty))
+                if (switchToAdd.SwitchValue != String.Empty)
                 {
                     ActiveToolSwitchesValues.Add(switchToAdd.SwitchValue, switchToAdd);
                 }
             }
             else
             {
-                if ((switchToAdd.ReverseSwitchValue != String.Empty))
+                if (switchToAdd.ReverseSwitchValue != String.Empty)
                 {
                     ActiveToolSwitchesValues.Add(switchToAdd.ReverseSwitchValue, switchToAdd);
                 }
@@ -245,7 +144,7 @@ public void AddActiveSwitchToolValue(CommandLineToolSwitch switchToAdd)
         /// </summary>
         public override bool Execute()
         {
-            if (!String.IsNullOrEmpty(this.CommandLineTemplate))
+            if (!String.IsNullOrEmpty(CommandLineTemplate))
             {
                 UseCommandProcessor = true;
             }
@@ -279,7 +178,7 @@ internal bool HasSwitch(string propertyName)
         {
             if (IsPropertySet(propertyName))
             {
-                return !String.IsNullOrEmpty(_activeToolSwitches[propertyName].Name);
+                return !String.IsNullOrEmpty(ActiveToolSwitches[propertyName].Name);
             }
             else
             {
@@ -357,7 +256,7 @@ internal void ValidateOverrides()
                 }
             }
 
-            //Remove the overrided switches
+            // Remove the overridden switches
             foreach (string overridenSwitch in overriddenSwitches)
             {
                 ActiveToolSwitches.Remove(overridenSwitch);
@@ -398,11 +297,11 @@ protected override bool HandleTaskExecutionErrors()
             // We don't want to use ToolTask's implementation because it doesn't report the command line that failed. 
             if (ExitCode == NativeMethods.SE_ERR_ACCESSDENIED)
             {
-                _logPrivate.LogErrorWithCodeFromResources("Xaml.CommandFailedAccessDenied", this.CommandLine, ExitCode);
+                _logPrivate.LogErrorWithCodeFromResources("Xaml.CommandFailedAccessDenied", CommandLine, ExitCode);
             }
             else
             {
-                _logPrivate.LogErrorWithCodeFromResources("Xaml.CommandFailed", this.CommandLine, ExitCode);
+                _logPrivate.LogErrorWithCodeFromResources("Xaml.CommandFailed", CommandLine, ExitCode);
             }
             return false;
         }
@@ -414,9 +313,12 @@ private string GenerateCommands()
         {
             PostProcessSwitchList();
 
-            CommandLineGenerator generator = new CommandLineGenerator(_activeToolSwitches, SwitchOrderList);
-            generator.CommandLineTemplate = this.CommandLineTemplate;
-            generator.AdditionalOptions = _additionalOptions;
+            var generator =
+                new CommandLineGenerator(ActiveToolSwitches, SwitchOrderList)
+                {
+                    CommandLineTemplate = CommandLineTemplate,
+                    AdditionalOptions = AdditionalOptions
+                };
 
             CommandLine = generator.GenerateCommandLine();
             return CommandLine;
@@ -447,11 +349,11 @@ public string ReadSwitchMap(string propertyName, string[][] switchMap, string va
         {
             if (switchMap != null)
             {
-                for (int i = 0; i < switchMap.Length; ++i)
+                foreach (string[] switches in switchMap)
                 {
-                    if (String.Equals(switchMap[i][0], value, StringComparison.OrdinalIgnoreCase))
+                    if (String.Equals(switches[0], value, StringComparison.OrdinalIgnoreCase))
                     {
-                        return switchMap[i][1];
+                        return switches[1];
                     }
                 }
 
@@ -461,7 +363,6 @@ public string ReadSwitchMap(string propertyName, string[][] switchMap, string va
             return String.Empty;
         }
 
-
         /// <summary>
         /// A method for the enumerated values a property can have
         /// This method checks the value a property is set to, and finds the corresponding switch
@@ -490,7 +391,7 @@ public int ReadSwitchMap2(string propertyName, Tuple<string, string, Tuple<strin
         /// </summary>
         public string CreateSwitchValue(string propertyName, string baseSwitch, string separator, Tuple<string, bool>[] arguments)
         {
-            StringBuilder switchValue = new StringBuilder(baseSwitch);
+            var switchValue = new StringBuilder(baseSwitch);
             foreach (Tuple<string, bool> argument in arguments)
             {
                 string argName = argument.Item1;
@@ -521,9 +422,11 @@ public string CreateSwitchValue(string propertyName, string baseSwitch, string s
         /// </summary>
         internal void InitializeLogger(ResourceManager taskResources)
         {
-            _logPrivate = new TaskLoggingHelper(this);
-            _logPrivate.TaskResources = AssemblyResources.PrimaryResources;
-            _logPrivate.HelpKeywordPrefix = "MSBuild.";
+            _logPrivate = new TaskLoggingHelper(this)
+            {
+                TaskResources = AssemblyResources.PrimaryResources,
+                HelpKeywordPrefix = "MSBuild."
+            };
         }
 
         #region ToolTask Members
diff --git a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
index 57693a029cb..d2e1e6eb2a0 100644
--- a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
+++ b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
@@ -47,41 +47,23 @@ public class XamlTaskFactory : ITaskFactory
         /// <summary>
         /// The name of the task pulled from the XAML.
         /// </summary>
-        public string TaskName
-        {
-            get;
-            private set;
-        }
+        public string TaskName { get; private set; }
 
         /// <summary>
         /// The namespace of the task pulled from the XAML.
         /// </summary>
-        public string TaskNamespace
-        {
-            get;
-            private set;
-        }
+        public string TaskNamespace { get; private set; }
 
         /// <summary>
         /// The contents of the UsingTask body.
         /// </summary>
-        public string TaskElementContents
-        {
-            get;
-            private set;
-        }
+        public string TaskElementContents { get; private set; }
 
         /// <summary>
         /// The name of this factory. This factory name will be used in error messages. For example
         /// Task "Mytask" failed to load from "FactoryName".
         /// </summary>
-        public string FactoryName
-        {
-            get
-            {
-                return "XamlTaskFactory";
-            }
-        }
+        public string FactoryName { get; } = "XamlTaskFactory";
 
         /// <summary>
         /// The task type object.
@@ -108,9 +90,11 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> ta
             ErrorUtilities.VerifyThrowArgumentNull(taskName, "taskName");
             ErrorUtilities.VerifyThrowArgumentNull(taskParameters, "taskParameters");
 
-            TaskLoggingHelper log = new TaskLoggingHelper(taskFactoryLoggingHost, taskName);
-            log.TaskResources = AssemblyResources.PrimaryResources;
-            log.HelpKeywordPrefix = "MSBuild.";
+            var log = new TaskLoggingHelper(taskFactoryLoggingHost, taskName)
+            {
+                TaskResources = AssemblyResources.PrimaryResources,
+                HelpKeywordPrefix = "MSBuild."
+            };
 
             if (taskElementContents == null)
             {
@@ -127,7 +111,7 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> ta
 
             TaskName = parser.GeneratedTaskName;
             TaskNamespace = parser.Namespace;
-            TaskGenerator generator = new TaskGenerator(parser);
+            var generator = new TaskGenerator(parser);
 
             CodeCompileUnit dom = generator.GenerateCode();
 
@@ -135,32 +119,34 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> ta
 
             // create the code generator options    
             // Since we are running msbuild 12.0 these had better load.
-            CompilerParameters compilerParameters = new CompilerParameters
-                (
-                    new string[]
-                    {
-                        "System.dll",
-                        Path.Combine(pathToMSBuildBinaries, "Microsoft.Build.Framework.dll"),
-                        Path.Combine(pathToMSBuildBinaries, "Microsoft.Build.Utilities.Core.dll"),
-                        Path.Combine(pathToMSBuildBinaries, "Microsoft.Build.Tasks.Core.dll")
-                    }
-
-                );
-
-            compilerParameters.GenerateInMemory = true;
-            compilerParameters.TreatWarningsAsErrors = false;
+            var compilerParameters = new CompilerParameters
+            (
+                new[]
+                {
+                    "System.dll",
+                    Path.Combine(pathToMSBuildBinaries, "Microsoft.Build.Framework.dll"),
+                    Path.Combine(pathToMSBuildBinaries, "Microsoft.Build.Utilities.Core.dll"),
+                    Path.Combine(pathToMSBuildBinaries, "Microsoft.Build.Tasks.Core.dll")
+                }
+            )
+            {
+                GenerateInMemory = true,
+                TreatWarningsAsErrors = false
+            };
 
             // create the code provider
-            CodeDomProvider codegenerator = CodeDomProvider.CreateProvider("cs");
+            var codegenerator = CodeDomProvider.CreateProvider("cs");
             CompilerResults results;
             bool debugXamlTask = Environment.GetEnvironmentVariable("MSBUILDWRITEXAMLTASK") == "1";
             if (debugXamlTask)
             {
-                using (StreamWriter outputWriter = new StreamWriter(taskName + "_XamlTask.cs"))
+                using (var outputWriter = new StreamWriter(taskName + "_XamlTask.cs"))
                 {
-                    CodeGeneratorOptions options = new CodeGeneratorOptions();
-                    options.BlankLinesBetweenMembers = true;
-                    options.BracingStyle = "C";
+                    var options = new CodeGeneratorOptions
+                    {
+                        BlankLinesBetweenMembers = true,
+                        BracingStyle = "C"
+                    };
 
                     codegenerator.GenerateCodeFromCompileUnit(dom, outputWriter, options);
                 }
@@ -169,7 +155,7 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> ta
             }
             else
             {
-                results = codegenerator.CompileAssemblyFromDom(compilerParameters, new[] { dom });
+                results = codegenerator.CompileAssemblyFromDom(compilerParameters, dom);
             }
 
             try
@@ -183,7 +169,7 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> ta
 
             if (_taskAssembly == null)
             {
-                StringBuilder errorList = new StringBuilder();
+                var errorList = new StringBuilder();
                 errorList.AppendLine();
                 foreach (CompilerError error in results.Errors)
                 {
diff --git a/src/Tasks/system.design/stronglytypedresourcebuilder.cs b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
index 332ff638bbb..dc6a4e5d19e 100644
--- a/src/Tasks/system.design/stronglytypedresourcebuilder.cs
+++ b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
@@ -35,8 +35,6 @@
 using System.Globalization;
 using System.Diagnostics.CodeAnalysis;
 
-using Microsoft.Build.Shared;
-
 /*
   Plan for the future:
   Ideally we will be able to change the property getters here to use a
@@ -85,27 +83,17 @@ internal static class StronglyTypedResourceBuilder
         // Save the strings for better doc comments.
         internal sealed class ResourceData
         {
-            private Type _type;
-            private String _valueAsString;
-
             internal ResourceData(Type type, String valueAsString)
             {
-                _type = type;
-                _valueAsString = valueAsString;
+                Type = type;
+                ValueAsString = valueAsString;
             }
 
-            internal Type Type
-            {
-                get { return _type; }
-            }
+            internal Type Type { get; }
 
-            internal String ValueAsString
-            {
-                get { return _valueAsString; }
-            }
+            internal String ValueAsString { get; }
         }
 
-
         internal static CodeCompileUnit Create(IDictionary resourceList, String baseName, String generatedCodeNamespace, CodeDomProvider codeProvider, bool internalClass, out String[] unmatchable)
         {
             return Create(resourceList, baseName, generatedCodeNamespace, null, codeProvider, internalClass, out unmatchable);
@@ -114,18 +102,22 @@ internal static CodeCompileUnit Create(IDictionary resourceList, String baseName
         internal static CodeCompileUnit Create(IDictionary resourceList, String baseName, String generatedCodeNamespace, String resourcesNamespace, CodeDomProvider codeProvider, bool internalClass, out String[] unmatchable)
         {
             if (resourceList == null)
-                throw new ArgumentNullException("resourceList");
+            {
+                throw new ArgumentNullException(nameof(resourceList));
+            }
 
-            Dictionary<String, ResourceData> resourceTypes = new Dictionary<String, ResourceData>(StringComparer.InvariantCultureIgnoreCase);
+            var resourceTypes = new Dictionary<String, ResourceData>(StringComparer.InvariantCultureIgnoreCase);
             foreach (DictionaryEntry de in resourceList)
             {
-                ResXDataNode node = de.Value as ResXDataNode;
+                var node = de.Value as ResXDataNode;
                 ResourceData data;
                 if (node != null)
                 {
                     string keyname = (string)de.Key;
                     if (keyname != node.Name)
+                    {
                         throw new ArgumentException(SR.GetString(SR.MismatchedResourceName, keyname, node.Name));
+                    }
 
                     String typeName = node.GetValueTypeName((AssemblyName[])null);
                     Type type = Type.GetType(typeName);
@@ -137,8 +129,8 @@ internal static CodeCompileUnit Create(IDictionary resourceList, String baseName
                     // If the object is null, we don't have a good way of guessing the
                     // type.  Use Object.  This will be rare after WinForms gets away
                     // from their resource pull model in Whidbey M3.
-                    Type type = (de.Value == null) ? typeof(Object) : de.Value.GetType();
-                    data = new ResourceData(type, de.Value == null ? null : de.Value.ToString());
+                    Type type = de.Value?.GetType() ?? typeof(Object);
+                    data = new ResourceData(type, de.Value?.ToString());
                 }
                 resourceTypes.Add((String)de.Key, data);
             }
@@ -152,22 +144,24 @@ internal static CodeCompileUnit Create(IDictionary resourceList, String baseName
         private static CodeCompileUnit InternalCreate(Dictionary<String, ResourceData> resourceList, String baseName, String generatedCodeNamespace, String resourcesNamespace, CodeDomProvider codeProvider, bool internalClass, out String[] unmatchable)
         {
             if (baseName == null)
-                throw new ArgumentNullException("baseName");
+            {
+                throw new ArgumentNullException(nameof(baseName));
+            }
             if (codeProvider == null)
-                throw new ArgumentNullException("codeProvider");
+            {
+                throw new ArgumentNullException(nameof(codeProvider));
+            }
 
             // Keep a list of errors describing known strings that couldn't be
             // fixed up (like "4"), as well as listing all duplicate resources that
             // were fixed up to the same name (like "A B" and "A-B" both going to
             // "A_B").
-            ArrayList errors = new ArrayList(0);
+            var errors = new List<string>();
 
             // Verify the resource names are valid property names, and they don't
             // conflict.  This includes checking for language-specific keywords,
             // translating spaces to underscores, etc.
-            SortedList cleanedResourceList;
-            Hashtable reverseFixupTable;
-            cleanedResourceList = VerifyResourceNames(resourceList, codeProvider, errors, out reverseFixupTable);
+            SortedList<string, ResourceData> cleanedResourceList = VerifyResourceNames(resourceList, codeProvider, errors, out Dictionary<string, string> reverseFixupTable);
 
             // Verify the class name is legal.
             String className = baseName;
@@ -176,10 +170,15 @@ private static CodeCompileUnit InternalCreate(Dictionary<String, ResourceData> r
             {
                 String fixedClassName = VerifyResourceName(className, codeProvider);
                 if (fixedClassName != null)
+                {
                     className = fixedClassName;
+                }
             }
+
             if (!codeProvider.IsValidIdentifier(className))
+            {
                 throw new ArgumentException(SR.GetString(SR.InvalidIdentifier, className));
+            }
 
             // If we have a namespace, verify the namespace is legal, 
             // attempting to fix it up if needed.
@@ -189,25 +188,27 @@ private static CodeCompileUnit InternalCreate(Dictionary<String, ResourceData> r
                 {
                     String fixedNamespace = VerifyResourceName(generatedCodeNamespace, codeProvider, true);
                     if (fixedNamespace != null)
+                    {
                         generatedCodeNamespace = fixedNamespace;
+                    }
                 }
                 // Note we cannot really ensure that the generated code namespace
                 // is a valid identifier, as namespaces can have '.' and '::', but
                 // identifiers cannot.
             }
 
-            CodeCompileUnit ccu = new CodeCompileUnit();
+            var ccu = new CodeCompileUnit();
             ccu.ReferencedAssemblies.Add("System.dll");
 
             ccu.UserData.Add("AllowLateBound", false);
             ccu.UserData.Add("RequireVariableDeclaration", true);
 
-            CodeNamespace ns = new CodeNamespace(generatedCodeNamespace);
+            var ns = new CodeNamespace(generatedCodeNamespace);
             ns.Imports.Add(new CodeNamespaceImport("System"));
             ccu.Namespaces.Add(ns);
 
             // Generate class
-            CodeTypeDeclaration srClass = new CodeTypeDeclaration(className);
+            var srClass = new CodeTypeDeclaration(className);
             ns.Types.Add(srClass);
             AddGeneratedCodeAttributeforMember(srClass);
 
@@ -217,42 +218,47 @@ private static CodeCompileUnit InternalCreate(Dictionary<String, ResourceData> r
             srClass.Comments.Add(new CodeCommentStatement(DocCommentSummaryStart, true));
             srClass.Comments.Add(new CodeCommentStatement(SR.GetString(SR.ClassDocComment), true));
 
-            CodeCommentStatement comment = new CodeCommentStatement(SR.GetString(SR.ClassComments1), true);
+            var comment = new CodeCommentStatement(SR.GetString(SR.ClassComments1), true);
             srClass.Comments.Add(comment);
             comment = new CodeCommentStatement(SR.GetString(SR.ClassComments3), true);
             srClass.Comments.Add(comment);
 
             srClass.Comments.Add(new CodeCommentStatement(DocCommentSummaryEnd, true));
-            CodeTypeReference debuggerAttrib = new CodeTypeReference(typeof(System.Diagnostics.DebuggerNonUserCodeAttribute));
-            debuggerAttrib.Options = CodeTypeReferenceOptions.GlobalReference;
+            var debuggerAttrib =
+                new CodeTypeReference(typeof(System.Diagnostics.DebuggerNonUserCodeAttribute))
+                {
+                    Options = CodeTypeReferenceOptions.GlobalReference
+                };
             srClass.CustomAttributes.Add(new CodeAttributeDeclaration(debuggerAttrib));
 
-            CodeTypeReference compilerGenedAttrib = new CodeTypeReference(typeof(System.Runtime.CompilerServices.CompilerGeneratedAttribute));
-            compilerGenedAttrib.Options = CodeTypeReferenceOptions.GlobalReference;
+            var compilerGenedAttrib =
+                new CodeTypeReference(typeof(System.Runtime.CompilerServices.CompilerGeneratedAttribute))
+                {
+                    Options = CodeTypeReferenceOptions.GlobalReference
+                };
             srClass.CustomAttributes.Add(new CodeAttributeDeclaration(compilerGenedAttrib));
 
             // Figure out some basic restrictions to the code generation
             bool useStatic = internalClass || codeProvider.Supports(GeneratorSupport.PublicStaticMembers);
-            bool supportsTryCatch = codeProvider.Supports(GeneratorSupport.TryCatchStatements);
-            EmitBasicClassMembers(srClass, generatedCodeNamespace, baseName, resourcesNamespace, internalClass, useStatic, supportsTryCatch);
+            EmitBasicClassMembers(srClass, generatedCodeNamespace, baseName, resourcesNamespace, internalClass, useStatic);
 
             // Now for each resource, add a property
-            foreach (DictionaryEntry entry in cleanedResourceList)
+            foreach (KeyValuePair<string, ResourceData> entry in cleanedResourceList)
             {
-                String propertyName = (String)entry.Key;
-                // The resourceName will be the original value, before fixups,
-                // if any.
-                String resourceName = (String)reverseFixupTable[propertyName];
-                if (resourceName == null)
+                String propertyName = entry.Key;
+                // The resourceName will be the original value, before fixups, if any.
+                if (reverseFixupTable.TryGetValue(propertyName, out string resourceName))
+                {
                     resourceName = propertyName;
-                bool r = DefineResourceFetchingProperty(propertyName, resourceName, (ResourceData)entry.Value, srClass, internalClass, useStatic);
+                }
+                bool r = DefineResourceFetchingProperty(propertyName, resourceName, entry.Value, srClass, internalClass, useStatic);
                 if (!r)
                 {
-                    errors.Add(entry.Key);
+                    errors.Add(propertyName);
                 }
             }
 
-            unmatchable = (String[])errors.ToArray(typeof(String));
+            unmatchable = errors.ToArray();
 
             // Validate the generated class now
             CodeGenerator.ValidateIdentifiers(ccu);
@@ -269,7 +275,9 @@ internal static CodeCompileUnit Create(String resxFile, String baseName, String
         internal static CodeCompileUnit Create(String resxFile, String baseName, String generatedCodeNamespace, String resourcesNamespace, CodeDomProvider codeProvider, bool internalClass, out String[] unmatchable)
         {
             if (resxFile == null)
-                throw new ArgumentNullException("resxFile");
+            {
+                throw new ArgumentNullException(nameof(resxFile));
+            }
 
             // Read the resources from a ResX file into a dictionary - name & type name
             Dictionary<String, ResourceData> resourceList = new Dictionary<String, ResourceData>(StringComparer.InvariantCultureIgnoreCase);
@@ -278,11 +286,11 @@ internal static CodeCompileUnit Create(String resxFile, String baseName, String
                 rr.UseResXDataNodes = true;
                 foreach (DictionaryEntry de in rr)
                 {
-                    ResXDataNode node = (ResXDataNode)de.Value;
+                    var node = (ResXDataNode)de.Value;
                     String typeName = node.GetValueTypeName((AssemblyName[])null);
                     Type type = Type.GetType(typeName);
                     String valueAsString = node.GetValue((AssemblyName[])null).ToString();
-                    ResourceData data = new ResourceData(type, valueAsString);
+                    var data = new ResourceData(type, valueAsString);
                     resourceList.Add((String)de.Key, data);
                 }
             }
@@ -295,10 +303,10 @@ internal static CodeCompileUnit Create(String resxFile, String baseName, String
 
         private static void AddGeneratedCodeAttributeforMember(CodeTypeMember typeMember)
         {
-            CodeAttributeDeclaration generatedCodeAttrib = new CodeAttributeDeclaration(new CodeTypeReference(typeof(System.CodeDom.Compiler.GeneratedCodeAttribute)));
+            var generatedCodeAttrib = new CodeAttributeDeclaration(new CodeTypeReference(typeof(GeneratedCodeAttribute)));
             generatedCodeAttrib.AttributeType.Options = CodeTypeReferenceOptions.GlobalReference;
-            CodeAttributeArgument toolArg = new CodeAttributeArgument(new CodePrimitiveExpression(typeof(StronglyTypedResourceBuilder).FullName));
-            CodeAttributeArgument versionArg = new CodeAttributeArgument(new CodePrimitiveExpression(MSBuildConstants.CurrentAssemblyVersion));
+            var toolArg = new CodeAttributeArgument(new CodePrimitiveExpression(typeof(StronglyTypedResourceBuilder).FullName));
+            var versionArg = new CodeAttributeArgument(new CodePrimitiveExpression(MSBuildConstants.CurrentAssemblyVersion));
 
             generatedCodeAttrib.Arguments.Add(toolArg);
             generatedCodeAttrib.Arguments.Add(versionArg);
@@ -307,7 +315,7 @@ private static void AddGeneratedCodeAttributeforMember(CodeTypeMember typeMember
         }
 
         [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters")]
-        private static void EmitBasicClassMembers(CodeTypeDeclaration srClass, String nameSpace, String baseName, String resourcesNamespace, bool internalClass, bool useStatic, bool supportsTryCatch)
+        private static void EmitBasicClassMembers(CodeTypeDeclaration srClass, String nameSpace, String baseName, String resourcesNamespace, bool internalClass, bool useStatic)
         {
             const String tmpVarName = "temp";
             String resMgrCtorParam;
@@ -319,7 +327,7 @@ private static void EmitBasicClassMembers(CodeTypeDeclaration srClass, String na
                 else
                     resMgrCtorParam = baseName;
             }
-            else if ((nameSpace != null) && (nameSpace.Length > 0))
+            else if (!string.IsNullOrEmpty(nameSpace))
             {
                 resMgrCtorParam = nameSpace + '.' + baseName;
             }
@@ -328,7 +336,7 @@ private static void EmitBasicClassMembers(CodeTypeDeclaration srClass, String na
                 resMgrCtorParam = baseName;
             }
 
-            CodeAttributeDeclaration suppressMessageAttrib = new CodeAttributeDeclaration(new CodeTypeReference(typeof(System.Diagnostics.CodeAnalysis.SuppressMessageAttribute)));
+            var suppressMessageAttrib = new CodeAttributeDeclaration(new CodeTypeReference(typeof(SuppressMessageAttribute)));
             suppressMessageAttrib.AttributeType.Options = CodeTypeReferenceOptions.GlobalReference;
             suppressMessageAttrib.Arguments.Add(new CodeAttributeArgument(new CodePrimitiveExpression("Microsoft.Performance")));
             suppressMessageAttrib.Arguments.Add(new CodeAttributeArgument(new CodePrimitiveExpression("CA1811:AvoidUncalledPrivateCode")));
@@ -343,15 +351,17 @@ private static void EmitBasicClassMembers(CodeTypeDeclaration srClass, String na
             srClass.Members.Add(ctor);
 
             // Emit _resMgr field.
-            CodeTypeReference ResMgrCodeTypeReference = new CodeTypeReference(typeof(ResourceManager), CodeTypeReferenceOptions.GlobalReference);
-            CodeMemberField field = new CodeMemberField(ResMgrCodeTypeReference, ResMgrFieldName);
-            field.Attributes = MemberAttributes.Private;
+            var ResMgrCodeTypeReference = new CodeTypeReference(typeof(ResourceManager), CodeTypeReferenceOptions.GlobalReference);
+            var field = new CodeMemberField(ResMgrCodeTypeReference, ResMgrFieldName)
+            {
+                Attributes = MemberAttributes.Private
+            };
             if (useStatic)
                 field.Attributes |= MemberAttributes.Static;
             srClass.Members.Add(field);
 
             // Emit _resCulture field, and leave it set to null.
-            CodeTypeReference CultureTypeReference = new CodeTypeReference(typeof(CultureInfo), CodeTypeReferenceOptions.GlobalReference);
+            var CultureTypeReference = new CodeTypeReference(typeof(CultureInfo), CodeTypeReferenceOptions.GlobalReference);
             field = new CodeMemberField(CultureTypeReference, CultureInfoFieldName);
             field.Attributes = MemberAttributes.Private;
             if (useStatic)
@@ -373,17 +383,19 @@ private static void EmitBasicClassMembers(CodeTypeDeclaration srClass, String na
                 resMgr.Attributes |= MemberAttributes.Static;
 
             // Mark the ResMgr property as advanced
-            CodeTypeReference editorBrowsableStateTypeRef = new CodeTypeReference(typeof(System.ComponentModel.EditorBrowsableState));
-            editorBrowsableStateTypeRef.Options = CodeTypeReferenceOptions.GlobalReference;
+            var editorBrowsableStateTypeRef =
+                new CodeTypeReference(typeof(System.ComponentModel.EditorBrowsableState))
+                {
+                    Options = CodeTypeReferenceOptions.GlobalReference
+                };
 
-            CodeAttributeArgument editorBrowsableStateAdvanced = new CodeAttributeArgument(new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(editorBrowsableStateTypeRef), "Advanced"));
-            CodeAttributeDeclaration editorBrowsableAdvancedAttribute = new CodeAttributeDeclaration("System.ComponentModel.EditorBrowsableAttribute",
-                                                                                                     new CodeAttributeArgument[] { editorBrowsableStateAdvanced });
+            var editorBrowsableStateAdvanced = new CodeAttributeArgument(new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(editorBrowsableStateTypeRef), "Advanced"));
+            var editorBrowsableAdvancedAttribute = new CodeAttributeDeclaration("System.ComponentModel.EditorBrowsableAttribute", editorBrowsableStateAdvanced);
             editorBrowsableAdvancedAttribute.AttributeType.Options = CodeTypeReferenceOptions.GlobalReference;
             resMgr.CustomAttributes.Add(editorBrowsableAdvancedAttribute);
 
             // Emit the Culture property (read/write)
-            CodeMemberProperty culture = new CodeMemberProperty();
+            var culture = new CodeMemberProperty();
             srClass.Members.Add(culture);
             culture.Name = CultureInfoPropertyName;
             culture.HasGet = true;
@@ -399,8 +411,7 @@ private static void EmitBasicClassMembers(CodeTypeDeclaration srClass, String na
 
             // Mark the Culture property as advanced
             culture.CustomAttributes.Add(editorBrowsableAdvancedAttribute);
-
-
+            
             /*
               // Here's what I'm trying to emit.  Since not all languages support
               // try/finally, we'll avoid our double lock pattern here.
@@ -416,18 +427,18 @@ private static void EmitBasicClassMembers(CodeTypeDeclaration srClass, String na
               }
               return _resMgr;
              */
-            CodeFieldReferenceExpression field_resMgr = new CodeFieldReferenceExpression(null, ResMgrFieldName);
-            CodeMethodReferenceExpression object_equalsMethod = new CodeMethodReferenceExpression(new CodeTypeReferenceExpression(typeof(Object)), "ReferenceEquals");
+            var field_resMgr = new CodeFieldReferenceExpression(null, ResMgrFieldName);
+            var object_equalsMethod = new CodeMethodReferenceExpression(new CodeTypeReferenceExpression(typeof(Object)), "ReferenceEquals");
 
-            CodeMethodInvokeExpression isResMgrNull = new CodeMethodInvokeExpression(object_equalsMethod, new CodeExpression[] { field_resMgr, new CodePrimitiveExpression(null) });
+            var isResMgrNull = new CodeMethodInvokeExpression(object_equalsMethod, field_resMgr, new CodePrimitiveExpression(null));
 
             // typeof(<class-name>).Assembly
-            CodePropertyReferenceExpression getAssembly = new CodePropertyReferenceExpression(new CodeTypeOfExpression(new CodeTypeReference(srClass.Name)), "Assembly");
+            var getAssembly = new CodePropertyReferenceExpression(new CodeTypeOfExpression(new CodeTypeReference(srClass.Name)), "Assembly");
 
             // new ResourceManager(resMgrCtorParam, typeof(<class-name>).Assembly);
-            CodeObjectCreateExpression newResMgr = new CodeObjectCreateExpression(ResMgrCodeTypeReference, new CodePrimitiveExpression(resMgrCtorParam), getAssembly);
+            var newResMgr = new CodeObjectCreateExpression(ResMgrCodeTypeReference, new CodePrimitiveExpression(resMgrCtorParam), getAssembly);
 
-            CodeStatement[] init = new CodeStatement[2];
+            var init = new CodeStatement[2];
             init[0] = new CodeVariableDeclarationStatement(ResMgrCodeTypeReference, tmpVarName, newResMgr);
             init[1] = new CodeAssignStatement(field_resMgr, new CodeVariableReferenceExpression(tmpVarName));
 
@@ -439,12 +450,11 @@ private static void EmitBasicClassMembers(CodeTypeDeclaration srClass, String na
             resMgr.Comments.Add(new CodeCommentStatement(SR.GetString(SR.ResMgrPropertyComment), true));
             resMgr.Comments.Add(new CodeCommentStatement(DocCommentSummaryEnd, true));
 
-
             // Emit code for Culture property
-            CodeFieldReferenceExpression field_resCulture = new CodeFieldReferenceExpression(null, CultureInfoFieldName);
+            var field_resCulture = new CodeFieldReferenceExpression(null, CultureInfoFieldName);
             culture.GetStatements.Add(new CodeMethodReturnStatement(field_resCulture));
 
-            CodePropertySetValueReferenceExpression newCulture = new CodePropertySetValueReferenceExpression();
+            var newCulture = new CodePropertySetValueReferenceExpression();
             culture.SetStatements.Add(new CodeAssignStatement(field_resCulture, newCulture));
 
             // Add a doc comment to Culture property
@@ -483,20 +493,23 @@ private static string TruncateAndFormatCommentStringForOutput(string commentStri
         [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters")]
         private static bool DefineResourceFetchingProperty(String propertyName, String resourceName, ResourceData data, CodeTypeDeclaration srClass, bool internalClass, bool useStatic)
         {
-            CodeMemberProperty prop = new CodeMemberProperty();
-            prop.Name = propertyName;
-            prop.HasGet = true;
-            prop.HasSet = false;
+            var prop = new CodeMemberProperty
+            {
+                Name = propertyName,
+                HasGet = true,
+                HasSet = false
+            };
 
             Type type = data.Type;
-
             if (type == null)
             {
                 return false;
             }
 
             if (type == typeof(MemoryStream))
+            {
                 type = typeof(UnmanagedMemoryStream);
+            }
 
             // Ensure type is internalally visible.  This is necessary to ensure
             // users can access classes via a base type.  Imagine a class like
@@ -510,9 +523,11 @@ private static bool DefineResourceFetchingProperty(String propertyName, String r
             // special casing collection interfaces & ignoring serialization 
             // interfaces or IDisposable.
             while (!type.IsPublic)
+            {
                 type = type.BaseType;
+            }
 
-            CodeTypeReference valueType = new CodeTypeReference(type);
+            var valueType = new CodeTypeReference(type);
             prop.Type = valueType;
             if (internalClass)
                 prop.Attributes = MemberAttributes.Assembly;
@@ -529,18 +544,20 @@ private static bool DefineResourceFetchingProperty(String propertyName, String r
             // For Objects, emit this:
             //    Object obj = ResourceManager.GetObject("name", _resCulture);
             //    return (MyValueType) obj;
-            CodePropertyReferenceExpression resMgr = new CodePropertyReferenceExpression(null, "ResourceManager");
-            CodeFieldReferenceExpression resCultureField = new CodeFieldReferenceExpression((useStatic) ? null : new CodeThisReferenceExpression(), CultureInfoFieldName);
+            var resMgr = new CodePropertyReferenceExpression(null, "ResourceManager");
+            var resCultureField = new CodeFieldReferenceExpression((useStatic) ? null : new CodeThisReferenceExpression(), CultureInfoFieldName);
 
             bool isString = type == typeof(String);
             bool isStream = type == typeof(UnmanagedMemoryStream) || type == typeof(MemoryStream);
-            String getMethodName = String.Empty;
-            String text = String.Empty;
+            String getMethodName;
+            String text;
             String valueAsString = TruncateAndFormatCommentStringForOutput(data.ValueAsString);
             String typeName = String.Empty;
 
             if (!isString) // Stream or Object
+            {
                 typeName = TruncateAndFormatCommentStringForOutput(type.ToString());
+            }
 
             if (isString)
                 getMethodName = "GetString";
@@ -550,7 +567,9 @@ private static bool DefineResourceFetchingProperty(String propertyName, String r
                 getMethodName = "GetObject";
 
             if (isString)
+            {
                 text = SR.GetString(SR.StringPropertyComment, valueAsString);
+            }
             else
             { // Stream or Object
                 if (valueAsString == null ||
@@ -564,7 +583,7 @@ private static bool DefineResourceFetchingProperty(String propertyName, String r
             prop.Comments.Add(new CodeCommentStatement(text, true));
             prop.Comments.Add(new CodeCommentStatement(DocCommentSummaryEnd, true));
 
-            CodeExpression getValue = new CodeMethodInvokeExpression(resMgr, getMethodName, new CodePrimitiveExpression(resourceName), resCultureField);
+            var getValue = new CodeMethodInvokeExpression(resMgr, getMethodName, new CodePrimitiveExpression(resourceName), resCultureField);
             CodeMethodReturnStatement ret;
             if (isString || isStream)
             {
@@ -572,7 +591,7 @@ private static bool DefineResourceFetchingProperty(String propertyName, String r
             }
             else
             {
-                CodeVariableDeclarationStatement returnObj = new CodeVariableDeclarationStatement(typeof(Object), "obj", getValue);
+                var returnObj = new CodeVariableDeclarationStatement(typeof(Object), "obj", getValue);
                 prop.GetStatements.Add(returnObj);
 
                 ret = new CodeMethodReturnStatement(new CodeCastExpression(valueType, new CodeVariableReferenceExpression("obj")));
@@ -593,9 +612,9 @@ internal static String VerifyResourceName(String key, CodeDomProvider provider)
         private static String VerifyResourceName(String key, CodeDomProvider provider, bool isNameSpace)
         {
             if (key == null)
-                throw new ArgumentNullException("key");
+                throw new ArgumentNullException(nameof(key));
             if (provider == null)
-                throw new ArgumentNullException("provider");
+                throw new ArgumentNullException(nameof(provider));
 
             foreach (char c in s_charsToReplace)
             {
@@ -620,10 +639,18 @@ private static String VerifyResourceName(String key, CodeDomProvider provider, b
             return null;
         }
 
-        private static SortedList VerifyResourceNames(Dictionary<String, ResourceData> resourceList, CodeDomProvider codeProvider, ArrayList errors, out Hashtable reverseFixupTable)
+        private static SortedList<string, ResourceData> VerifyResourceNames(
+            Dictionary<String, ResourceData> resourceList,
+            CodeDomProvider codeProvider,
+            List<string> errors,
+            out Dictionary<string, string> reverseFixupTable)
         {
-            reverseFixupTable = new Hashtable(0, StringComparer.InvariantCultureIgnoreCase);
-            SortedList cleanedResourceList = new SortedList(StringComparer.InvariantCultureIgnoreCase, resourceList.Count);
+            reverseFixupTable = new Dictionary<string, string>(0, StringComparer.InvariantCultureIgnoreCase);
+            var cleanedResourceList =
+                new SortedList<string, ResourceData>(StringComparer.InvariantCultureIgnoreCase)
+                {
+                    Capacity = resourceList.Count
+                };
 
             foreach (KeyValuePair<String, ResourceData> entry in resourceList)
             {
@@ -661,15 +688,15 @@ private static SortedList VerifyResourceNames(Dictionary<String, ResourceData> r
 
                     // Now see if we've already mapped another key to the 
                     // same name.
-                    String oldDuplicateKey = (String)reverseFixupTable[newKey];
-                    if (oldDuplicateKey != null)
+                    if (reverseFixupTable.TryGetValue(newKey, out string oldDuplicateKey))
                     {
                         // We can't handle this key nor the previous one.
                         // Remove the old one.
                         if (!errors.Contains(oldDuplicateKey))
+                        {
                             errors.Add(oldDuplicateKey);
-                        if (cleanedResourceList.Contains(newKey))
-                            cleanedResourceList.Remove(newKey);
+                        }
+                        cleanedResourceList.Remove(newKey);
                         errors.Add(key);
                         continue;
                     }
@@ -677,18 +704,21 @@ private static SortedList VerifyResourceNames(Dictionary<String, ResourceData> r
                     key = newKey;
                 }
                 ResourceData value = entry.Value;
-                if (!cleanedResourceList.Contains(key))
+                if (!cleanedResourceList.ContainsKey(key))
+                {
                     cleanedResourceList.Add(key, value);
+                }
                 else
                 {
                     // There was a case-insensitive conflict between two keys.
                     // Or possibly one key was fixed up in a way that conflicts 
                     // with another key (ie, "A B" and "A_B").
-                    String fixedUp = (String)reverseFixupTable[key];
-                    if (fixedUp != null)
+                    if (reverseFixupTable.TryGetValue(key, out string fixedUp))
                     {
                         if (!errors.Contains(fixedUp))
+                        {
                             errors.Add(fixedUp);
+                        }
                         reverseFixupTable.Remove(key);
                     }
                     errors.Add(entry.Key);
@@ -699,4 +729,3 @@ private static SortedList VerifyResourceNames(Dictionary<String, ResourceData> r
         }
     }
 }
-
