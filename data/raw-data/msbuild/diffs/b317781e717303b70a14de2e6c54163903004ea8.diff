diff --git a/.editorconfig b/.editorconfig
index 72c7d4a2b87..b8e856dc62d 100644
--- a/.editorconfig
+++ b/.editorconfig
@@ -1,25 +1,199 @@
-# EditorConfig is awesome:
-http://EditorConfig.org
+# editorconfig.org
 
 # top-most EditorConfig file
 root = true
 
 # Default settings:
+# A newline ending every file
 # Use 4 spaces as indentation
 [*]
+insert_final_newline = true
 indent_style = space
 indent_size = 4
-insert_final_newline = true
 trim_trailing_whitespace = true
 
+[project.json]
+indent_size = 2
+
+# C# files
+[*.cs]
+# New line preferences
+csharp_new_line_before_open_brace = all
+csharp_new_line_before_else = true
+csharp_new_line_before_catch = true
+csharp_new_line_before_finally = true
+csharp_new_line_before_members_in_object_initializers = true
+csharp_new_line_before_members_in_anonymous_types = true
+csharp_new_line_between_query_expression_clauses = true
+
+# Indentation preferences
+csharp_indent_block_contents = true
+csharp_indent_braces = false
+csharp_indent_case_contents = true
+csharp_indent_case_contents_when_block = true
+csharp_indent_switch_labels = true
+csharp_indent_labels = one_less_than_current
+
+# Modifier preferences
+csharp_preferred_modifier_order = public,private,protected,internal,static,extern,new,virtual,abstract,sealed,override,readonly,unsafe,volatile,async:suggestion
+
+# avoid this. unless absolutely necessary
+dotnet_style_qualification_for_field = false:suggestion
+dotnet_style_qualification_for_property = false:suggestion
+dotnet_style_qualification_for_method = false:suggestion
+dotnet_style_qualification_for_event = false:suggestion
+
+# Types: use keywords instead of BCL types, and permit var only when the type is clear
+csharp_style_var_for_built_in_types = false:suggestion
+csharp_style_var_when_type_is_apparent = false:none
+csharp_style_var_elsewhere = false:suggestion
+dotnet_style_predefined_type_for_locals_parameters_members = true:suggestion
+dotnet_style_predefined_type_for_member_access = true:suggestion
+
+# name all constant fields using PascalCase
+dotnet_naming_rule.constant_fields_should_be_pascal_case.severity = suggestion
+dotnet_naming_rule.constant_fields_should_be_pascal_case.symbols  = constant_fields
+dotnet_naming_rule.constant_fields_should_be_pascal_case.style    = pascal_case_style
+dotnet_naming_symbols.constant_fields.applicable_kinds   = field
+dotnet_naming_symbols.constant_fields.required_modifiers = const
+dotnet_naming_style.pascal_case_style.capitalization = pascal_case
+
+# static fields should have s_ prefix
+dotnet_naming_rule.static_fields_should_have_prefix.severity = suggestion
+dotnet_naming_rule.static_fields_should_have_prefix.symbols  = static_fields
+dotnet_naming_rule.static_fields_should_have_prefix.style    = static_prefix_style
+dotnet_naming_symbols.static_fields.applicable_kinds   = field
+dotnet_naming_symbols.static_fields.required_modifiers = static
+dotnet_naming_symbols.static_fields.applicable_accessibilities = private, internal, private_protected
+dotnet_naming_style.static_prefix_style.required_prefix = s_
+dotnet_naming_style.static_prefix_style.capitalization = camel_case
+
+# internal and private fields should be _camelCase
+dotnet_naming_rule.camel_case_for_private_internal_fields.severity = suggestion
+dotnet_naming_rule.camel_case_for_private_internal_fields.symbols  = private_internal_fields
+dotnet_naming_rule.camel_case_for_private_internal_fields.style    = camel_case_underscore_style
+dotnet_naming_symbols.private_internal_fields.applicable_kinds = field
+dotnet_naming_symbols.private_internal_fields.applicable_accessibilities = private, internal
+dotnet_naming_style.camel_case_underscore_style.required_prefix = _
+dotnet_naming_style.camel_case_underscore_style.capitalization = camel_case
+
+# Code style defaults
+csharp_using_directive_placement = outside_namespace:suggestion
+dotnet_sort_system_directives_first = true
+csharp_prefer_braces = true:silent
+csharp_preserve_single_line_blocks = true:none
+csharp_preserve_single_line_statements = false:none
+csharp_prefer_static_local_function = true:suggestion
+csharp_prefer_simple_using_statement = false:none
+csharp_style_prefer_switch_expression = true:suggestion
+
+# Code quality
+dotnet_style_readonly_field = true:suggestion
+dotnet_code_quality_unused_parameters = non_public:suggestion
+
+# Expression-level preferences
+dotnet_style_object_initializer = true:suggestion
+dotnet_style_collection_initializer = true:suggestion
+dotnet_style_explicit_tuple_names = true:suggestion
+dotnet_style_coalesce_expression = true:suggestion
+dotnet_style_null_propagation = true:suggestion
+dotnet_style_prefer_is_null_check_over_reference_equality_method = true:suggestion
+dotnet_style_prefer_inferred_tuple_names = true:suggestion
+dotnet_style_prefer_inferred_anonymous_type_member_names = true:suggestion
+dotnet_style_prefer_auto_properties = true:suggestion
+dotnet_style_prefer_conditional_expression_over_assignment = true:silent
+dotnet_style_prefer_conditional_expression_over_return = true:silent
+csharp_prefer_simple_default_expression = true:suggestion
+
+# Expression-bodied members
+csharp_style_expression_bodied_methods = true:silent
+csharp_style_expression_bodied_constructors = true:silent
+csharp_style_expression_bodied_operators = true:silent
+csharp_style_expression_bodied_properties = true:silent
+csharp_style_expression_bodied_indexers = true:silent
+csharp_style_expression_bodied_accessors = true:silent
+csharp_style_expression_bodied_lambdas = true:silent
+csharp_style_expression_bodied_local_functions = true:silent
+
+# Pattern matching
+csharp_style_pattern_matching_over_is_with_cast_check = true:suggestion
+csharp_style_pattern_matching_over_as_with_null_check = true:suggestion
+csharp_style_inlined_variable_declaration = true:suggestion
+
+# Null checking preferences
+csharp_style_throw_expression = true:suggestion
+csharp_style_conditional_delegate_call = true:suggestion
+
+# Other features
+csharp_style_prefer_index_operator = false:none
+csharp_style_prefer_range_operator = false:none
+csharp_style_pattern_local_over_anonymous_function = false:none
+
+# Space preferences
+csharp_space_after_cast = false
+csharp_space_after_colon_in_inheritance_clause = true
+csharp_space_after_comma = true
+csharp_space_after_dot = false
+csharp_space_after_keywords_in_control_flow_statements = true
+csharp_space_after_semicolon_in_for_statement = true
+csharp_space_around_binary_operators = before_and_after
+csharp_space_around_declaration_statements = do_not_ignore
+csharp_space_before_colon_in_inheritance_clause = true
+csharp_space_before_comma = false
+csharp_space_before_dot = false
+csharp_space_before_open_square_brackets = false
+csharp_space_before_semicolon_in_for_statement = false
+csharp_space_between_empty_square_brackets = false
+csharp_space_between_method_call_empty_parameter_list_parentheses = false
+csharp_space_between_method_call_name_and_opening_parenthesis = false
+csharp_space_between_method_call_parameter_list_parentheses = false
+csharp_space_between_method_declaration_empty_parameter_list_parentheses = false
+csharp_space_between_method_declaration_name_and_open_parenthesis = false
+csharp_space_between_method_declaration_parameter_list_parentheses = false
+csharp_space_between_parentheses = false
+csharp_space_between_square_brackets = false
+
+# Analyzers
+dotnet_code_quality.ca1802.api_surface = private, internal
+dotnet_code_quality.ca2208.api_surface = public
+
+# License header
+file_header_template = Licensed to the .NET Foundation under one or more agreements.\nThe .NET Foundation licenses this file to you under the MIT license.\n
+
+# C++ Files
+[*.{cpp,h,in}]
+curly_bracket_next_line = true
+indent_brace_style = Allman
+
 # Xml project files
-[*.{csproj,vbproj,vcxproj,vcxproj.filters,proj,projitems,shproj}]
+[*.{csproj,vbproj,vcxproj,vcxproj.filters,proj,nativeproj,locproj}]
+indent_size = 2
+
+[*.{csproj,vbproj,proj,nativeproj,locproj}]
+charset = utf-8
+
+# Xml build files
+[*.builds]
+indent_size = 2
+
+# Xml files
+[*.{xml,stylecop,resx,ruleset}]
 indent_size = 2
 
 # Xml config files
-[*.{props,targets,ruleset,config,nuspec,resx,vsixmanifest,vsct}]
+[*.{props,targets,config,nuspec}]
 indent_size = 2
 
+# YAML config files
+[*.{yml,yaml}]
+indent_size = 2
+
+# Shell scripts
+[*.sh]
+end_of_line = lf
+[*.{cmd, bat}]
+end_of_line = crlf
+
 [src/**/*.{cs,vb}]
 # IDE0005: Remove unnecessary usings/imports
 dotnet_diagnostic.IDE0005.severity = warning
diff --git a/Directory.Build.props b/Directory.Build.props
index 2cc17a1372f..35246a8e8ec 100644
--- a/Directory.Build.props
+++ b/Directory.Build.props
@@ -62,10 +62,21 @@
     <MachineIndependentBuild>true</MachineIndependentBuild>
   </PropertyGroup>
 
+  <PropertyGroup>
+    <AssemblyInformationCachePaths Condition="Exists('$(NetCoreRoot)sdk\$(NetCoreSdkVersion)\SdkPrecomputedAssemblyReferences.cache')">$(AssemblyInformationCachePaths);$(NetCoreRoot)sdk\$(NetCoreSdkVersion)\SDKPrecomputedAssemblyReferences.cache</AssemblyInformationCachePaths>
+  </PropertyGroup>
+
   <PropertyGroup>
     <DefaultItemExcludes>$(DefaultItemExcludes);*.log</DefaultItemExcludes>
     <DefaultItemExcludes>$(DefaultItemExcludes);*.binlog</DefaultItemExcludes>
 
     <DisableImplicitNuGetFallbackFolder>true</DisableImplicitNuGetFallbackFolder>
   </PropertyGroup>
+  
+  <Import Project="$(RepositoryEngineeringDir)Analyzers.props" />
+
+  <PropertyGroup>
+    <EnableAnalyzers>true</EnableAnalyzers>
+  </PropertyGroup>
+  
 </Project>
diff --git a/documentation/Changelog.md b/documentation/Changelog.md
index ba4b17b5963..19f97e2e2e7 100644
--- a/documentation/Changelog.md
+++ b/documentation/Changelog.md
@@ -2,16 +2,20 @@
 
 ## MSBuild 16.11.0
 
-This version of MSBuild will ship with Visual Studio 2019 version 16.11.0 and .NET SDK 5.0.400.
+This version of MSBuild shipped with Visual Studio 2019 version 16.11.0 and .NET SDK 5.0.400.
 
 ### What's new
 
+* MSBuild now supports long paths in the 64-bit `amd64\MSBuild.exe` executable.
+* New version properties `MSBuildFileVersion` (4-part, matches file version) and `MSBuildSemanticVersion` (matches package versions) are now available for use (#6534).
+
 ### Detailed release notes
 
 #### Added
 
-* Additional properties documented and available for completion in Visual Studio (#6500).
+* Additional properties documented and available for completion in Visual Studio (#6500, #6530).
 * The `SignFile` task is now available in MSBuild on .NET 5.0 (#6509). Thanks, @Zastai!
+* New version properties `MSBuildFileVersion` (4-part, matches file version) and `MSBuildSemanticVersion` (matches package versions) are now available for use (#6534).
 #### Changed
 
 * When using the experimental cache API, schedule proxy builds to the in-proc node for performance (#6386).
@@ -24,14 +28,39 @@ This version of MSBuild will ship with Visual Studio 2019 version 16.11.0 and .N
 * Added locking to avoid race conditions in `BuildManager` (#6412).
 * Allow `ResolveAssemblyReferences` precomputed cache files to be in read-only locations (#6393).
 * 64-bit `al.exe` is used when targeting 64-bit architectures (for real this time) (#6484).
+* Builds with `ProduceOnlyReferenceAssembly` no longer expect debug symbols to be produced (#6511). Thanks, @Zastai!
+* 64-bit `MSBuild.exe` supports long paths (and other .NET default behaviors) (#6562).
+* Non-graph builds no longer crash in the experimental project cache (#6568).
+* The experimental project cache is initialized only once (#6569).
+* The experimental project cache no longer tries to schedule proxy builds to the in-proc node (#6635).
 
 #### Infrastructure
 
 * Use a packaged C# compiler to avoid changes in reference assembly generation caused by compiler changes (#6431).
 * Use more resilient test-result upload patterns (#6489).
 * Conditional compilation for .NET Core within our repo now includes new .NET 5.0+ runtimes (#6538).
+* Switched to OneLocBuild for localization PRs (#6561).
+* Moved to latest Ubuntu image for PR test legs (#6573).
 
-#### Documentation
+## MSBuild 16.10.2
+
+This version of MSBuild shipped with Visual Studio 2019 version 16.10.2 and will ship with .NET SDK 5.0.302.
+
+#### Fixed
+
+* Fixed a regression in the `MakeRelative` property function that dropped trailing slashes (#6513). Thanks, @dsparkplug and @pmisik!
+* Fixed a regression in glob matching where files without extensions were erroneously not matched (#6531).
+* Fixed a change in logging that caused crashes in Azure DevOps loggers (#6520).
+
+## MSBuild 16.10.2
+
+This version of MSBuild shipped with Visual Studio 2019 version 16.10.2 and will ship with .NET SDK 5.0.302.
+
+#### Fixed
+
+* Fixed a regression in the `MakeRelative` property function that dropped trailing slashes (#6513). Thanks, @dsparkplug and @pmisik!
+* Fixed a regression in glob matching where files without extensions were erroneously not matched (#6531).
+* Fixed a change in logging that caused crashes in Azure DevOps loggers (#6520).
 
 ## MSBuild 16.10.1
 
diff --git a/documentation/ProjectReference-Protocol.md b/documentation/ProjectReference-Protocol.md
index f5363b9f43f..5e2a138e3d5 100644
--- a/documentation/ProjectReference-Protocol.md
+++ b/documentation/ProjectReference-Protocol.md
@@ -58,6 +58,7 @@ If implementing a project with an “outer” (determine what properties to pass
     * `TargetFrameworks` indicating what TargetFrameworks are available in the project
     * `TargetFrameworkMonikers` and `TargetPlatformMonikers` indicating what framework / platform the `TargetFrameworks` map to.  This is to support implicitly setting the target platform version (for example inferring that `net5.0-windows` means the same as `net5.0-windows7.0`) as well as treating the `TargetFramework` values [as aliases](https://github.com/NuGet/Home/issues/5154)
     * Boolean metadata for `HasSingleTargetFramework` and `IsRidAgnostic`.
+    * `Platforms` indicating what platforms are available for the project to build as, and boolean metadata `IsVcxOrNativeProj` (used for [SetPlatform Negotiation](#setplatform-negotiation))
   * The `GetReferenceNearestTargetFrameworkTask` (provided by NuGet) is responsible for selecting the best matching `TargetFramework` of the referenced project
   * This target is _optional_. If not present, the reference will be built with no additional properties.
   * **New** in MSBuild 15.5.  (`TargetFrameworkMonikers` and `TargetPlatformMonikers` metadata is new in MSBuild 16.8)
@@ -84,7 +85,6 @@ If implementing a project with an “outer” (determine what properties to pass
   * As of 15.7, this is _optional_. If a project does not contain a `GetCopyToOutputDirectoryItems` target, projects that reference it will not copy any of its outputs to their own output folders, but the build can succeed.
 * `Clean` should delete all outputs of the project.
   * It is not called during a normal build, only during "Clean" and "Rebuild".
-
 ## Other protocol requirements
 
 As with all MSBuild logic, targets can be added to do other work with `ProjectReference`s.
@@ -106,6 +106,8 @@ As of MSBuild 16.10, it is possible to gather additional properties from referen
 
 These properties will then be gathered via the `GetTargetFrameworks` call.  They will be available to the referencing project via the `AdditionalPropertiesFromProject` metadata on the `_MSBuildProjectReferenceExistent` item.  The `AdditionalPropertiesFromProject` value will be an XML string which contains the values of the properties for each `TargetFramework` in the referenced project.  For example:
 
+> :warning: This format is being changed. Soon, the schema will replace <net5.0> with <TargetFramework Name="net5.0">. You can opt into that behavior early by setting the _UseAttributeForTargetFrameworkInfoPropertyNames property to true. This property will have no effect after the transition is complete.
+
 ```xml
 <AdditionalProjectProperties>
   <net5.0>
@@ -119,4 +121,66 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They
 </AdditionalProjectProperties>
 ```
 
-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.
\ No newline at end of file
+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.
+
+## SetPlatform Negotiation
+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. This includes a new target and task to determine what the `SetPlatform` metadata should be, or whether to undefine the platform so the referenced project builds with its default platform.
+
+* `_GetProjectReferenceTargetFrameworkProperties` target performs the majority of the work for assigning `SetPlatform` metadata to project references.
+  * Calls the `GetCompatiblePlatform` task, which is responsible for negotiating between the current project's platform and the platforms of the referenced project to assign a `NearestPlatform` metadata to the item.
+  * Sets or undefines `SetPlatform` based on the `NearestPlatform` assignment from `GetCompatiblePlatform`
+  * This target explicitly runs after `_GetProjectReferenceTargetFrameworkProperties` because it needs to use the `IsVcxOrNativeProj` and `Platforms` properties returned by the `GetTargetFrameworks` call.
+
+Note: If a `ProjectReference` has `SetPlatform` metadata defined already, the negotiation logic is skipped over.
+### Impact on the build
+In addition to the above task and target, `.vcxproj` and `.nativeproj` projects will receive an extra MSBuild call to the `GetTargetFrameworks` target. Previously, TargetFramework negotiation skipped over these projects because they could not multi-target in the first place. Because SetPlatform negotiation needs information given from the `GetTargetFrameworks` target, it is required that the `_GetProjectReferenceTargetFrameworkProperties` target calls the MSBuild task on the ProjectReference.
+
+This means most projects will see an evaluation with no global properties defined, unless set by the user.
+
+### How To Opt In
+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:
+
+```xml
+<Project>
+  <PropertyGroup>
+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>
+  </PropertyGroup>
+</Project>
+```
+
+If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.
+
+Next, every referenced project is required to define a `Platforms` property, where `Platforms` is a semicolon-delimited list of platforms that project could build as. For `.vcxproj` or `.nativeproj` projects, `Platforms` is constructed from the `ProjectConfiguration` items that already exist in the project. For managed SDK projects, the default is `AnyCPU`. Managed non-SDK projects need to define this manually.
+
+Lastly, a `PlatformLookupTable` may need to be defined for more complex scenarios. A `PlatformLookupTable` is a semicolon-delimited list of mappings between platforms. `<PlatformLookupTable>Win32=x86</PlatformLookupTable>`, for example. This means that when the current project is building as `Win32`, it will attempt to build the referenced project as x86. This property is **required** when a managed AnyCPU project references an unmanaged project because `AnyCPU` does not directly map to an architecture-specific platform. You can define the table in two ways:
+
+1. A standard property within the current project, in a Directory.Build.props/targets
+2. Metadata on the `ProjectReference` item. This option takes priority over the first to allow customizations per `ProjectReference`.
+
+### References between managed and unmanaged projects
+Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as. References between managed and unmanaged projects also get a default lookup table that can be opted out of by setting the property `UseDefaultPlatformLookupTables` to false. See the table below for details.
+
+Note: Defining a `PlatformLookupTable` overrides the default mapping.
+| Project Reference Type | `PlatformLookupTable` Required? | Notes |
+| :--  | :-: | :-: |
+| Unmanaged -> Unmanaged | No |  |
+| Managed -> Managed | No |  |
+| Unmanaged -> Managed | Optional | Uses default mapping: `Win32=x86` |
+| Managed -> Unmanaged | **Yes** when the project is AnyCPU | Uses default mapping: `x86=Win32` |
+
+Example:
+Project A: Managed, building as `AnyCPU`, has a `ProjectReference` on Project B.
+Project B: Unmanaged, has `$(Platforms)` constructed from its `Platform` metadata from its `ProjectConfiguration` items, defined as `x64;Win32`.
+
+Because `AnyCPU` does not map to anything architecture-specific, a custom mapping must be defined. Project A can either:
+1. Define `PlatformLookupTable` in its project or a Directory.Build.props as `AnyCPU=x64` or `AnyCPU=Win32`.
+2. Define `PlatformLookupTable` as metadata on the `ProjectReference` item, which would take priority over a lookup table defined elsewhere.
+     *  When only one mapping is valid, you could also directly define `SetPlatform` metadata as `Platform=foo` (for unmanaged) or `PlatformTarget=bar` (for managed). This would skip over most negotiation logic.
+
+Example of project A defining a lookup table directly on the `ProjectReference`:
+```xml
+<ItemGroup>
+  <ProjectReference Include="B.csproj" PlatformLookupTable="AnyCPU=Win32">
+</ItemGroup>
+```
diff --git a/documentation/specs/project-cache.md b/documentation/specs/project-cache.md
index a9da734d26f..6a0095354ca 100644
--- a/documentation/specs/project-cache.md
+++ b/documentation/specs/project-cache.md
@@ -1,16 +1,3 @@
-- [Summary](#summary)
-- [Motivation](#motivation)
-- [Plugin requirements](#plugin-requirements)
-- [High-level design](#high-level-design)
-- [APIs and calling patterns](#apis-and-calling-patterns)
-  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)
-  - [From command line](#from-command-line)
-  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)
-- [Details](#details)
-- [Caveats](#caveats)
-- [Future work](#future-work)
-- [Potential work of dubious value](#potential-work-of-dubious-value)
-
 # Summary
 
 Project cache is a new assembly-based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and/or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).
diff --git a/documentation/specs/static-graph-implementation-details.md b/documentation/specs/static-graph-implementation-details.md
index 028fb333359..d8a109a0133 100644
--- a/documentation/specs/static-graph-implementation-details.md
+++ b/documentation/specs/static-graph-implementation-details.md
@@ -1,8 +1,3 @@
-- [Single project isolated builds: implementation details](#single-project-isolated-builds-implementation-details)
-  - [Input / Output cache implementation](#input--output-cache-implementation)
-  - [Isolation implementation](#isolation-implementation)
-    - [How isolation exemption complicates everything](#how-isolation-exemption-complicates-everything)
-
 # Single project isolated builds: implementation details
 
 <!-- workflow -->
@@ -17,7 +12,7 @@ The presence of either input or output caches turns on [isolated build constrain
 
 ## Input / Output cache implementation
 <!-- cache structure -->
-The cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/dotnet/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results. For example, it is these caches which ensure that a target is only built once per build submission. The `ConfigCache` entries are instances of [BuildRequestConfiguration](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25). The `ResultsCache` entries are instances of [BuildResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34), which contain or more instances of [TargetResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22). 
+The cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/dotnet/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results. For example, it is these caches which ensure that a target is only built once per build submission. The `ConfigCache` entries are instances of [BuildRequestConfiguration](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25). The `ResultsCache` entries are instances of [BuildResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34), which contain or more instances of [TargetResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22).
 
 One can view the two caches as the following mapping: `(project path, global properties) -> results`. `(project path, global properties)` is represented by a `BuildRequestConfiguration`, and the results are represented by `BuildResult` and `TargetResult`.
 
diff --git a/documentation/specs/static-graph.md b/documentation/specs/static-graph.md
index 6e4527a7470..90349da4c7e 100644
--- a/documentation/specs/static-graph.md
+++ b/documentation/specs/static-graph.md
@@ -1,36 +1,5 @@
 # Static Graph
 
-- [Static Graph](#static-graph)
-  - [What is static graph for?](#what-is-static-graph-for)
-    - [Weakness of the old model: project-level scheduling](#weakness-of-the-old-model-project-level-scheduling)
-    - [Weakness of the old model: incrementality](#weakness-of-the-old-model-incrementality)
-    - [Weakness of the old model: caching and distributability](#weakness-of-the-old-model-caching-and-distributability)
-  - [What is static graph?](#what-is-static-graph)
-  - [Design documentation](#design-documentation)
-    - [Design goals](#design-goals)
-  - [Project Graph](#project-graph)
-    - [Constructing the project graph](#constructing-the-project-graph)
-    - [Build dimensions](#build-dimensions)
-      - [Multitargeting](#multitargeting)
-    - [Executing targets on a graph](#executing-targets-on-a-graph)
-      - [Command line](#command-line)
-      - [APIs](#apis)
-    - [Inferring which targets to run for a project within the graph](#inferring-which-targets-to-run-for-a-project-within-the-graph)
-      - [Multitargeting details](#multitargeting-details)
-    - [Underspecified graphs](#underspecified-graphs)
-    - [Public API](#public-api)
-  - [Isolated builds](#isolated-builds)
-    - [Isolated graph builds](#isolated-graph-builds)
-    - [Single project isolated builds](#single-project-isolated-builds)
-      - [APIs](#apis-1)
-      - [Command line](#command-line-1)
-      - [Exempting references from isolation constraints](#exempting-references-from-isolation-constraints)
-  - [I/O Tracking](#io-tracking)
-    - [Detours](#detours)
-    - [Isolation requirement](#isolation-requirement)
-    - [Tool servers](#tool-servers)
-  - [Examples](#examples)
-
 ## What is static graph for?
 
 As a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent. MSBuild's static graph features are intended to ameliorate these weaknesses while remaining as compatible as possible with existing projects and SDKs.
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 7f2ca5375ff..5b152e7c1a7 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -31,7 +31,6 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Scheduler should honor BuildParameters.DisableInprocNode](https://github.com/dotnet/msbuild/pull/6400)
 - [Don't compile globbing regexes on .NET Framework](https://github.com/dotnet/msbuild/pull/6632)
 - [Default to transitively copying content items](https://github.com/dotnet/msbuild/pull/6622)
-- [Reference assemblies are now no longer placed in the `bin` directory by default](https://github.com/dotnet/msbuild/pull/6560)
 - [Improve debugging experience: add global switch MSBuildDebugEngine; Inject binary logger from BuildManager; print static graph as .dot file](https://github.com/dotnet/msbuild/pull/6639)
 
 ## Change Waves No Longer In Rotation
diff --git a/documentation/wiki/Localization.md b/documentation/wiki/Localization.md
index e0d31a285b8..e58212cd5d9 100644
--- a/documentation/wiki/Localization.md
+++ b/documentation/wiki/Localization.md
@@ -35,17 +35,8 @@ Code completion ("IntelliSense") for MSBuild project files is provided minimally
 
 ### If there is a bug in XSD localization
 
-File xsd localization bugs in this repo. The MSBuild team will coordinate with the Visual Studio localization team to redirect it appropriately.
+File XSD localization bugs in this repo. The MSBuild team will coordinate with the Visual Studio localization team to redirect it appropriately.
 
 ### When an XSD has been updated
 
-After updating an XSD in the GitHub repo, someone with internal access must update the copy in the `VS` repo. To do so:
-
-1. Locally clone VS following the standard instructions.
-2. Locally update your clone of the GitHub msbuild repo to include the merge of the change.
-3. Start a new branch in the VS repository from the current working branch (probably `master`).
-4. Copy from the msbuild path `src/MSBuild/MSBuild/*.xsd` to the VS path `src/xmake/XMakeCommandLine`.
-5. Ensure that the commit message has a full link to the commit used to update the `.xsd` files, like `https://github.com/microsoft/msbuild/commit/ba9a1d64a7abf15a8505827c00413156a3eb7f62`.
-6. Push and submit through the usual VS PR process, including the `MSBuild` team as reviewers.
-
-Example PR doing this: https://dev.azure.com/devdiv/DevDiv/_git/VS/pullrequest/186890.
+After updating an XSD in the GitHub repo, the MSBuild-to-VS-repo insertion process automatically updates the canonical Visual Studio copy of the XSD.
diff --git a/eng/Analyzers.props b/eng/Analyzers.props
new file mode 100644
index 00000000000..2a523c21b2c
--- /dev/null
+++ b/eng/Analyzers.props
@@ -0,0 +1,7 @@
+<Project>
+  <PropertyGroup>
+    <CodeAnalysisRuleset>$(MSBuildThisFileDirectory)CodeAnalysis.ruleset</CodeAnalysisRuleset>
+    <!-- Disable analyzers in sourcebuild -->
+    <EnableAnalyzers Condition="'$(DotNetBuildFromSource)' == 'true'">false</EnableAnalyzers>
+  </PropertyGroup>
+</Project>
diff --git a/eng/CodeAnalysis.ruleset b/eng/CodeAnalysis.ruleset
new file mode 100644
index 00000000000..2078c42fe6c
--- /dev/null
+++ b/eng/CodeAnalysis.ruleset
@@ -0,0 +1,389 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<RuleSet Name="Microsoft.Analyzers.ManagedCodeAnalysis" Description="Microsoft.Analyzers.ManagedCodeAnalysis" ToolsVersion="16.0">
+  <Rules AnalyzerId="Microsoft.DotNet.CodeAnalysis" RuleNamespace="Microsoft.DotNet.CodeAnalysis.Analyzers"> 
+    <Rule Id="BCL0001" Action="Warning" />         <!-- Ensure minimum API surface is respected --> 
+    <Rule Id="BCL0010" Action="Warning" />         <!-- AppContext default value expected to be true --> 
+    <Rule Id="BCL0011" Action="Warning" />         <!-- AppContext default value defined in if statement with incorrect pattern --> 
+    <Rule Id="BCL0012" Action="Warning" />         <!-- AppContext default value defined in if statement at root of switch case --> 
+    <Rule Id="BCL0015" Action="None" />            <!-- Invalid P/Invoke call --> 
+    <Rule Id="BCL0020" Action="Warning" />         <!-- Invalid SR.Format call --> 
+  </Rules> 
+  <Rules AnalyzerId="Microsoft.CodeAnalysis.NetAnalyzers" RuleNamespace="Microsoft.CodeAnalysis.NetAnalyzers"> 
+    <Rule Id="CA1000" Action="None" />             <!-- Do not declare static members on generic types --> 
+    <Rule Id="CA1001" Action="None" />             <!-- Types that own disposable fields should be disposable --> 
+    <Rule Id="CA1002" Action="None" />             <!-- Do not expose generic lists --> 
+    <Rule Id="CA1003" Action="None" />             <!-- Use generic event handler instances --> 
+    <Rule Id="CA1005" Action="None" />             <!-- Avoid excessive parameters on generic types --> 
+    <Rule Id="CA1008" Action="None" />             <!-- Enums should have zero value --> 
+    <Rule Id="CA1010" Action="None" />             <!-- Generic interface should also be implemented --> 
+    <Rule Id="CA1012" Action="None" />             <!-- Abstract types should not have constructors --> 
+    <Rule Id="CA1014" Action="None" />             <!-- Mark assemblies with CLSCompliant --> 
+    <Rule Id="CA1016" Action="None" />             <!-- Mark assemblies with assembly version --> 
+    <Rule Id="CA1017" Action="None" />             <!-- Mark assemblies with ComVisible --> 
+    <Rule Id="CA1018" Action="Warning" />          <!-- Mark attributes with AttributeUsageAttribute --> 
+    <Rule Id="CA1019" Action="None" />             <!-- Define accessors for attribute arguments --> 
+    <Rule Id="CA1024" Action="None" />             <!-- Use properties where appropriate --> 
+    <Rule Id="CA1027" Action="None" />             <!-- Mark enums with FlagsAttribute --> 
+    <Rule Id="CA1028" Action="None" />             <!-- Enum Storage should be Int32 --> 
+    <Rule Id="CA1030" Action="None" />             <!-- Use events where appropriate --> 
+    <Rule Id="CA1031" Action="None" />             <!-- Do not catch general exception types --> 
+    <Rule Id="CA1032" Action="None" />
+    <Rule Id="CA1033" Action="None" />             <!-- Interface methods should be callable by child types --> 
+    <Rule Id="CA1034" Action="None" />
+    <Rule Id="CA1036" Action="None" />             <!-- Override methods on comparable types --> 
+    <Rule Id="CA1040" Action="None" />             <!-- Avoid empty interfaces --> 
+    <Rule Id="CA1041" Action="None" />             <!-- Provide ObsoleteAttribute message --> 
+    <Rule Id="CA1043" Action="None" />             <!-- Use Integral Or String Argument For Indexers --> 
+    <Rule Id="CA1044" Action="None" />             <!-- Properties should not be write only --> 
+    <Rule Id="CA1046" Action="None" />             <!-- Do not overload equality operator on reference types --> 
+    <Rule Id="CA1047" Action="Warning" />          <!-- Do not declare protected member in sealed type --> 
+    <Rule Id="CA1050" Action="Info" />             <!-- Declare types in namespaces --> 
+    <Rule Id="CA1051" Action="None" />             <!-- Do not declare visible instance fields --> 
+    <Rule Id="CA1052" Action="None" />             <!-- Static holder types should be Static or NotInheritable --> 
+    <Rule Id="CA1054" Action="None" />             <!-- Uri parameters should not be strings --> 
+    <Rule Id="CA1055" Action="None" />             <!-- Uri return values should not be strings --> 
+    <Rule Id="CA1056" Action="None" />             <!-- Uri properties should not be strings --> 
+    <Rule Id="CA1058" Action="None" />             <!-- Types should not extend certain base types --> 
+    <Rule Id="CA1061" Action="None" />             <!-- Do not hide base class methods --> 
+    <Rule Id="CA1062" Action="None" />             <!-- Validate arguments of public methods --> 
+    <Rule Id="CA1063" Action="None" />             <!-- Implement IDisposable Correctly --> 
+    <Rule Id="CA1064" Action="None" />             <!-- Exceptions should be public --> 
+    <Rule Id="CA1065" Action="None" />             <!-- Do not raise exceptions in unexpected locations --> 
+    <Rule Id="CA1066" Action="None" />             <!-- Implement IEquatable when overriding Object.Equals --> 
+    <Rule Id="CA1067" Action="None" />             <!-- Override Object.Equals(object) when implementing IEquatable<T> --> 
+    <Rule Id="CA1068" Action="None" />             <!-- CancellationToken parameters must come last --> 
+    <Rule Id="CA1069" Action="None" />             <!-- Enums values should not be duplicated --> 
+    <Rule Id="CA1070" Action="Info" />             <!-- Do not declare event fields as virtual --> 
+    <Rule Id="CA1200" Action="Info" />             <!-- Avoid using cref tags with a prefix --> 
+    <Rule Id="CA1303" Action="None" />             <!-- Do not pass literals as localized parameters --> 
+    <Rule Id="CA1304" Action="None" />             <!-- Specify CultureInfo --> 
+    <Rule Id="CA1305" Action="None" />             <!-- Specify IFormatProvider --> 
+    <Rule Id="CA1307" Action="None" />             <!-- Specify StringComparison --> 
+    <Rule Id="CA1308" Action="None" />             <!-- Normalize strings to uppercase --> 
+    <Rule Id="CA1309" Action="None" />             <!-- Use ordinal stringcomparison --> 
+    <Rule Id="CA1401" Action="Warning" />          <!-- P/Invokes should not be visible --> 
+    <Rule Id="CA1417" Action="Warning" />          <!-- Do not use 'OutAttribute' on string parameters for P/Invokes --> 
+    <Rule Id="CA1502" Action="None" />             <!-- Avoid excessive complexity --> 
+    <Rule Id="CA1505" Action="None" />             <!-- Avoid unmaintainable code --> 
+    <Rule Id="CA1506" Action="None" />             <!-- Avoid excessive class coupling --> 
+    <Rule Id="CA1507" Action="Info" />             <!-- Use nameof to express symbol names --> 
+    <Rule Id="CA1508" Action="None" />             <!-- Avoid dead conditional code --> 
+    <Rule Id="CA1509" Action="None" />             <!-- Invalid entry in code metrics rule specification file --> 
+    <Rule Id="CA1700" Action="None" />             <!-- Do not name enum values 'Reserved' --> 
+    <Rule Id="CA1707" Action="None" />
+    <Rule Id="CA1710" Action="None" />             <!-- Identifiers should have correct suffix --> 
+    <Rule Id="CA1711" Action="None" />             <!-- Identifiers should not have incorrect suffix --> 
+    <Rule Id="CA1712" Action="None" />             <!-- Do not prefix enum values with type name --> 
+    <Rule Id="CA1714" Action="None" />
+    <Rule Id="CA1715" Action="None" />             <!-- Identifiers should have correct prefix --> 
+    <Rule Id="CA1716" Action="None" />             <!-- Identifiers should not match keywords --> 
+    <Rule Id="CA1717" Action="None" />
+    <Rule Id="CA1720" Action="None" />             <!-- Identifier contains type name --> 
+    <Rule Id="CA1721" Action="None" />             <!-- Property names should not match get methods --> 
+    <Rule Id="CA1724" Action="None" />             <!-- Type names should not match namespaces --> 
+    <Rule Id="CA1801" Action="None" />             <!-- Review unused parameters --> 
+    <Rule Id="CA1802" Action="Info" />             <!-- Use literals where appropriate --> 
+    <Rule Id="CA1805" Action="Info" />             <!-- Do not initialize unnecessarily --> 
+    <Rule Id="CA1806" Action="None" />
+    <Rule Id="CA1810" Action="Info" />             <!-- Initialize reference type static fields inline --> 
+    <Rule Id="CA1812" Action="None" />             <!-- Avoid uninstantiated internal classes --> 
+    <Rule Id="CA1814" Action="None" />
+    <Rule Id="CA1815" Action="None" />
+    <Rule Id="CA1816" Action="None" />             <!-- Dispose methods should call SuppressFinalize --> 
+    <Rule Id="CA1819" Action="None" />
+    <Rule Id="CA1820" Action="None" />             <!-- Test for empty strings using string length --> 
+    <Rule Id="CA1821" Action="Warning" />          <!-- Remove empty Finalizers --> 
+    <Rule Id="CA1822" Action="None" />             <!-- Mark members as static --> 
+    <Rule Id="CA1823" Action="Info" />             <!-- Avoid unused private fields --> 
+    <Rule Id="CA1824" Action="Warning" />          <!-- Mark assemblies with NeutralResourcesLanguageAttribute -->
+    <Rule Id="CA1825" Action="Info" />             <!-- Avoid zero-length array allocations. --> 
+    <Rule Id="CA1827" Action="Warning" />          <!-- Do not use Count() or LongCount() when Any() can be used --> 
+    <Rule Id="CA1828" Action="Warning" />          <!-- Do not use CountAsync() or LongCountAsync() when AnyAsync() can be used --> 
+    <Rule Id="CA1829" Action="Info" />             <!-- Use Length/Count property instead of Count() when available --> 
+    <Rule Id="CA1830" Action="Warning" />          <!-- Prefer strongly-typed Append and Insert method overloads on StringBuilder. --> 
+    <Rule Id="CA1831" Action="Warning" />          <!-- Use AsSpan or AsMemory instead of Range-based indexers when appropriate --> 
+    <Rule Id="CA1832" Action="Warning" />          <!-- Use AsSpan or AsMemory instead of Range-based indexers when appropriate --> 
+    <Rule Id="CA1833" Action="Warning" />          <!-- Use AsSpan or AsMemory instead of Range-based indexers when appropriate --> 
+    <Rule Id="CA1834" Action="Info" />             <!-- Consider using 'StringBuilder.Append(char)' when applicable. --> 
+    <Rule Id="CA1835" Action="Info" />             <!-- Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync' --> 
+    <Rule Id="CA1836" Action="Info" />             <!-- Prefer IsEmpty over Count --> 
+    <Rule Id="CA1837" Action="Info" />             <!-- Use 'Environment.ProcessId' -->  
+    <Rule Id="CA1838" Action="Info" />             <!-- Avoid 'StringBuilder' parameters for P/Invokes --> 
+    <Rule Id="CA2000" Action="None" />             <!-- Dispose objects before losing scope --> 
+    <Rule Id="CA2002" Action="None" />             <!-- Do not lock on objects with weak identity --> 
+    <Rule Id="CA2007" Action="Info" />             <!-- Consider calling ConfigureAwait on the awaited task --> 
+    <Rule Id="CA2008" Action="Info" />             <!-- Do not create tasks without passing a TaskScheduler --> 
+    <Rule Id="CA2009" Action="Warning" />          <!-- Do not call ToImmutableCollection on an ImmutableCollection value --> 
+    <Rule Id="CA2011" Action="Warning" />          <!-- Avoid infinite recursion --> 
+    <Rule Id="CA2012" Action="Warning" />          <!-- Use ValueTasks correctly --> 
+    <Rule Id="CA2013" Action="Warning" />          <!-- Do not use ReferenceEquals with value types --> 
+    <Rule Id="CA2014" Action="Warning" />          <!-- Do not use stackalloc in loops. --> 
+    <Rule Id="CA2015" Action="Warning" />          <!-- Do not define finalizers for types derived from MemoryManager<T> --> 
+    <Rule Id="CA2016" Action="Info" />             <!-- Forward the 'CancellationToken' parameter to methods that take one --> 
+    <Rule Id="CA2100" Action="None" />             <!-- Review SQL queries for security vulnerabilities --> 
+    <Rule Id="CA2101" Action="None" />             <!-- Specify marshaling for P/Invoke string arguments --> 
+    <Rule Id="CA2109" Action="None" />             <!-- Review visible event handlers --> 
+    <Rule Id="CA2119" Action="None" />             <!-- Seal methods that satisfy private interfaces --> 
+    <Rule Id="CA2153" Action="None" />             <!-- Do Not Catch Corrupted State Exceptions --> 
+    <Rule Id="CA2201" Action="None" />             <!-- Do not raise reserved exception types --> 
+    <Rule Id="CA2208" Action="Info" />             <!-- Instantiate argument exceptions correctly --> 
+    <Rule Id="CA2211" Action="None" />             <!-- Non-constant fields should not be visible --> 
+    <Rule Id="CA2213" Action="None" />             <!-- Disposable fields should be disposed --> 
+    <Rule Id="CA2215" Action="None" />             <!-- Dispose methods should call base class dispose --> 
+    <Rule Id="CA2216" Action="None" />             <!-- Disposable types should declare finalizer --> 
+    <Rule Id="CA2219" Action="None" />
+    <Rule Id="CA2224" Action="None" />             <!-- Override Equals on overloading operator equals --> 
+    <Rule Id="CA2225" Action="None" />             <!-- Operator overloads have named alternates --> 
+    <Rule Id="CA2226" Action="None" />             <!-- Operators should have symmetrical overloads --> 
+    <Rule Id="CA2227" Action="None" />             <!-- Collection properties should be read only --> 
+    <Rule Id="CA2231" Action="None" />             <!-- Overload operator equals on overriding value type Equals --> 
+    <Rule Id="CA2234" Action="None" />             <!-- Pass system uri objects instead of strings --> 
+    <Rule Id="CA2235" Action="None" />             <!-- Mark all non-serializable fields --> 
+    <Rule Id="CA2241" Action="Info" />             <!-- Provide correct arguments to formatting methods --> 
+    <Rule Id="CA2242" Action="Warning" />          <!-- Test for NaN correctly --> 
+    <Rule Id="CA2243" Action="None" />             <!-- Attribute string literals should parse correctly --> 
+    <Rule Id="CA2244" Action="None" />             <!-- Do not duplicate indexed element initializations --> 
+    <Rule Id="CA2245" Action="Warning" />          <!-- Do not assign a property to itself. --> 
+    <Rule Id="CA2246" Action="None" />             <!-- Assigning symbol and its member in the same statement. --> 
+    <Rule Id="CA2247" Action="Warning" />          <!-- Argument passed to TaskCompletionSource constructor should be TaskCreationOptions enum instead of TaskContinuationOptions enum. --> 
+    <Rule Id="CA2248" Action="Warning" />          <!-- Provide correct 'enum' argument to 'Enum.HasFlag' --> 
+    <Rule Id="CA2249" Action="Info" />             <!-- Consider using 'string.Contains' instead of 'string.IndexOf' --> 
+    <Rule Id="CA2300" Action="None" />             <!-- Do not use insecure deserializer BinaryFormatter --> 
+    <Rule Id="CA2301" Action="None" />             <!-- Do not call BinaryFormatter.Deserialize without first setting BinaryFormatter.Binder --> 
+    <Rule Id="CA2302" Action="None" />             <!-- Ensure BinaryFormatter.Binder is set before calling BinaryFormatter.Deserialize --> 
+    <Rule Id="CA2305" Action="None" />             <!-- Do not use insecure deserializer LosFormatter --> 
+    <Rule Id="CA2310" Action="None" />             <!-- Do not use insecure deserializer NetDataContractSerializer --> 
+    <Rule Id="CA2311" Action="None" />             <!-- Do not deserialize without first setting NetDataContractSerializer.Binder --> 
+    <Rule Id="CA2312" Action="None" />             <!-- Ensure NetDataContractSerializer.Binder is set before deserializing --> 
+    <Rule Id="CA2315" Action="None" />             <!-- Do not use insecure deserializer ObjectStateFormatter --> 
+    <Rule Id="CA2321" Action="None" />             <!-- Do not deserialize with JavaScriptSerializer using a SimpleTypeResolver --> 
+    <Rule Id="CA2322" Action="None" />             <!-- Ensure JavaScriptSerializer is not initialized with SimpleTypeResolver before deserializing --> 
+    <Rule Id="CA2326" Action="None" />             <!-- Do not use TypeNameHandling values other than None --> 
+    <Rule Id="CA2350" Action="None" />             <!-- Do not use DataTable.ReadXml() with untrusted data --> 
+    <Rule Id="CA2351" Action="None" />             <!-- Do not use DataSet.ReadXml() with untrusted data --> 
+    <Rule Id="CA2352" Action="None" />             <!-- Unsafe DataSet or DataTable in serializable type can be vulnerable to remote code execution attacks --> 
+    <Rule Id="CA2353" Action="None" />             <!-- Unsafe DataSet or DataTable in serializable type --> 
+    <Rule Id="CA2354" Action="None" />             <!-- Unsafe DataSet or DataTable in deserialized object graph can be vulnerable to remote code execution attacks --> 
+    <Rule Id="CA2355" Action="None" />             <!-- Unsafe DataSet or DataTable type found in deserializable object graph --> 
+    <Rule Id="CA2356" Action="None" />             <!-- Unsafe DataSet or DataTable type in web deserializable object graph --> 
+    <Rule Id="CA2361" Action="None" />             <!-- Ensure autogenerated class containing DataSet.ReadXml() is not used with untrusted data --> 
+    <Rule Id="CA2362" Action="None" />             <!-- Unsafe DataSet or DataTable in autogenerated serializable type can be vulnerable to remote code execution attacks --> 
+    <Rule Id="CA3001" Action="None" />             <!-- Review code for SQL injection vulnerabilities --> 
+    <Rule Id="CA3002" Action="None" />             <!-- Review code for XSS vulnerabilities --> 
+    <Rule Id="CA3003" Action="None" />             <!-- Review code for file path injection vulnerabilities --> 
+    <Rule Id="CA3004" Action="None" />             <!-- Review code for information disclosure vulnerabilities --> 
+    <Rule Id="CA3005" Action="None" />             <!-- Review code for LDAP injection vulnerabilities --> 
+    <Rule Id="CA3006" Action="None" />             <!-- Review code for process command injection vulnerabilities --> 
+    <Rule Id="CA3007" Action="None" />             <!-- Review code for open redirect vulnerabilities --> 
+    <Rule Id="CA3008" Action="None" />             <!-- Review code for XPath injection vulnerabilities --> 
+    <Rule Id="CA3009" Action="None" />             <!-- Review code for XML injection vulnerabilities --> 
+    <Rule Id="CA3010" Action="None" />             <!-- Review code for XAML injection vulnerabilities --> 
+    <Rule Id="CA3011" Action="None" />             <!-- Review code for DLL injection vulnerabilities --> 
+    <Rule Id="CA3012" Action="None" />             <!-- Review code for regex injection vulnerabilities --> 
+    <Rule Id="CA3061" Action="Warning" />          <!-- Do Not Add Schema By URL --> 
+    <Rule Id="CA3075" Action="Warning" />          <!-- Insecure DTD processing in XML --> 
+    <Rule Id="CA3076" Action="Warning" />          <!-- Insecure XSLT script processing. --> 
+    <Rule Id="CA3077" Action="Warning" />          <!-- Insecure Processing in API Design, XmlDocument and XmlTextReader --> 
+    <Rule Id="CA3147" Action="Warning" />          <!-- Mark Verb Handlers With Validate Antiforgery Token --> 
+    <Rule Id="CA5350" Action="Warning" />          <!-- Do Not Use Weak Cryptographic Algorithms --> 
+    <Rule Id="CA5351" Action="Warning" />          <!-- Do Not Use Broken Cryptographic Algorithms --> 
+    <Rule Id="CA5358" Action="None" />             <!-- Review cipher mode usage with cryptography experts --> 
+    <Rule Id="CA5359" Action="Warning" />          <!-- Do Not Disable Certificate Validation --> 
+    <Rule Id="CA5360" Action="Warning" />          <!-- Do Not Call Dangerous Methods In Deserialization --> 
+    <Rule Id="CA5361" Action="Warning" />          <!-- Do Not Disable SChannel Use of Strong Crypto --> 
+    <Rule Id="CA5362" Action="None" />             <!-- Potential reference cycle in deserialized object graph --> 
+    <Rule Id="CA5363" Action="Warning" />          <!-- Do Not Disable Request Validation --> 
+    <Rule Id="CA5364" Action="Warning" />          <!-- Do Not Use Deprecated Security Protocols --> 
+    <Rule Id="CA5365" Action="Warning" />          <!-- Do Not Disable HTTP Header Checking --> 
+    <Rule Id="CA5366" Action="None" />             <!-- Use XmlReader For DataSet Read Xml --> 
+    <Rule Id="CA5367" Action="None" />             <!-- Do Not Serialize Types With Pointer Fields --> 
+    <Rule Id="CA5368" Action="Warning" />          <!-- Set ViewStateUserKey For Classes Derived From Page --> 
+    <Rule Id="CA5369" Action="None" />             <!-- Use XmlReader For Deserialize --> 
+    <Rule Id="CA5370" Action="Warning" />          <!-- Use XmlReader For Validating Reader --> 
+    <Rule Id="CA5371" Action="None" />             <!-- Use XmlReader For Schema Read --> 
+    <Rule Id="CA5372" Action="None" />             <!-- Use XmlReader For XPathDocument --> 
+    <Rule Id="CA5373" Action="Warning" />          <!-- Do not use obsolete key derivation function --> 
+    <Rule Id="CA5374" Action="Warning" />          <!-- Do Not Use XslTransform --> 
+    <Rule Id="CA5375" Action="None" />             <!-- Do Not Use Account Shared Access Signature --> 
+    <Rule Id="CA5376" Action="Warning" />          <!-- Use SharedAccessProtocol HttpsOnly --> 
+    <Rule Id="CA5377" Action="Warning" />          <!-- Use Container Level Access Policy --> 
+    <Rule Id="CA5378" Action="Warning" />          <!-- Do not disable ServicePointManagerSecurityProtocols --> 
+    <Rule Id="CA5379" Action="Warning" />          <!-- Do Not Use Weak Key Derivation Function Algorithm --> 
+    <Rule Id="CA5380" Action="Warning" />          <!-- Do Not Add Certificates To Root Store --> 
+    <Rule Id="CA5381" Action="Warning" />          <!-- Ensure Certificates Are Not Added To Root Store --> 
+    <Rule Id="CA5382" Action="None" />             <!-- Use Secure Cookies In ASP.Net Core --> 
+    <Rule Id="CA5383" Action="None" />             <!-- Ensure Use Secure Cookies In ASP.Net Core --> 
+    <Rule Id="CA5384" Action="Warning" />          <!-- Do Not Use Digital Signature Algorithm (DSA) --> 
+    <Rule Id="CA5385" Action="Warning" />          <!-- Use Rivest–Shamir–Adleman (RSA) Algorithm With Sufficient Key Size --> 
+    <Rule Id="CA5386" Action="None" />             <!-- Avoid hardcoding SecurityProtocolType value --> 
+    <Rule Id="CA5387" Action="None" />             <!-- Do Not Use Weak Key Derivation Function With Insufficient Iteration Count --> 
+    <Rule Id="CA5388" Action="None" />             <!-- Ensure Sufficient Iteration Count When Using Weak Key Derivation Function --> 
+    <Rule Id="CA5389" Action="None" />             <!-- Do Not Add Archive Item's Path To The Target File System Path --> 
+    <Rule Id="CA5390" Action="None" />             <!-- Do not hard-code encryption key --> 
+    <Rule Id="CA5391" Action="None" />             <!-- Use antiforgery tokens in ASP.NET Core MVC controllers --> 
+    <Rule Id="CA5392" Action="None" />             <!-- Use DefaultDllImportSearchPaths attribute for P/Invokes --> 
+    <Rule Id="CA5393" Action="None" />             <!-- Do not use unsafe DllImportSearchPath value --> 
+    <Rule Id="CA5394" Action="None" />             <!-- Do not use insecure randomness --> 
+    <Rule Id="CA5395" Action="None" />             <!-- Miss HttpVerb attribute for action methods --> 
+    <Rule Id="CA5396" Action="None" />             <!-- Set HttpOnly to true for HttpCookie --> 
+    <Rule Id="CA5397" Action="None" />             <!-- Do not use deprecated SslProtocols values --> 
+    <Rule Id="CA5398" Action="None" />             <!-- Avoid hardcoded SslProtocols values --> 
+    <Rule Id="CA5399" Action="None" />             <!-- HttpClients should enable certificate revocation list checks --> 
+    <Rule Id="CA5400" Action="None" />             <!-- Ensure HttpClient certificate revocation list check is not disabled --> 
+    <Rule Id="CA5401" Action="None" />             <!-- Do not use CreateEncryptor with non-default IV --> 
+    <Rule Id="CA5402" Action="None" />             <!-- Use CreateEncryptor with the default IV  --> 
+    <Rule Id="CA5403" Action="None" />             <!-- Do not hard-code certificate --> 
+    <Rule Id="IL3000" Action="None" />             <!-- Avoid using accessing Assembly file path when publishing as a single-file --> 
+    <Rule Id="IL3001" Action="None" />             <!-- Avoid using accessing Assembly file path when publishing as a single-file --> 
+  </Rules> 
+  <Rules AnalyzerId="StyleCop.Analyzers" RuleNamespace="StyleCop.Analyzers"> 
+    <Rule Id="AD0001" Action="Info" /> <!-- Analyzer threw an exception --> 
+    <Rule Id="SA0001" Action="Info" /> <!-- XML comments --> 
+    <Rule Id="SA1000" Action="None" />
+    <Rule Id="SA1001" Action="None" />
+    <Rule Id="SA1002" Action="Info" /> <!-- Semicolons should not be preceded by a space --> 
+    <Rule Id="SA1003" Action="None" />
+    <Rule Id="SA1004" Action="Info" /> <!-- Documentation line should begin with a space --> 
+    <Rule Id="SA1005" Action="Info" /> <!-- Single line comment should begin with a space -->
+    <Rule Id="SA1006" Action="Info" /> <!-- Region should not be preceded by a space -->
+    <Rule Id="SA1008" Action="Info" /> <!-- Opening parenthesis should not be preceded by a space --> 
+    <Rule Id="SA1009" Action="Info" /> <!-- Closing parenthesis should not be followed by a space --> 
+    <Rule Id="SA1010" Action="Info" /> <!-- Opening square brackets should not be preceded by a space --> 
+    <Rule Id="SA1011" Action="Info" /> <!-- Closing square bracket should be followed by a space --> 
+    <Rule Id="SA1012" Action="Info" /> <!-- Opening brace should be followed by a space --> 
+    <Rule Id="SA1013" Action="Info" /> <!-- Closing brace should be preceded by a space --> 
+    <Rule Id="SA1015" Action="Info" /> <!-- Closing generic bracket should not be followed by a space --> 
+    <Rule Id="SA1019" Action="None" />
+    <Rule Id="SA1021" Action="Info" /> <!-- Negative sign should be preceded by a space --> 
+    <Rule Id="SA1023" Action="Info" /> <!-- Dereference symbol '*' should not be preceded by a space." --> 
+    <Rule Id="SA1024" Action="Info" /> <!-- Colon should be followed by a space --> 
+    <Rule Id="SA1025" Action="Info" /> <!-- Code should not contain multiple whitespace characters in a row --> 
+    <Rule Id="SA1026" Action="None" />
+    <Rule Id="SA1027" Action="None" />
+    <Rule Id="SA1028" Action="None" />
+    <Rule Id="SA1100" Action="Info" /> <!-- Do not prefix calls with base unless local implementation exists --> 
+    <Rule Id="SA1101" Action="None" />
+    <Rule Id="SA1102" Action="Info" />
+    <Rule Id="SA1106" Action="Info" /> <!-- Code should not contain empty statements --> 
+    <Rule Id="SA1107" Action="Info" /> <!-- Code should not contain multiple statements on one line --> 
+    <Rule Id="SA1108" Action="None" />
+    <Rule Id="SA1110" Action="Info" /> <!-- Opening parenthesis or bracket should be on declaration line --> 
+    <Rule Id="SA1111" Action="Info" /> <!-- Closing parenthesis should be on line of last parameter --> 
+    <Rule Id="SA1112" Action="None" />
+    <Rule Id="SA1113" Action="None" />
+    <Rule Id="SA1114" Action="Info" /> <!-- Parameter list should follow declaration --> 
+    <Rule Id="SA1115" Action="None" />
+    <Rule Id="SA1116" Action="Info" /> <!-- Split parameters should start on line after declaration --> 
+    <Rule Id="SA1117" Action="Info" /> <!-- Parameters should be on same line or separate lines --> 
+    <Rule Id="SA1118" Action="None" />
+    <Rule Id="SA1119" Action="None" />
+    <Rule Id="SA1120" Action="Info" /> <!-- Comments should contain text --> 
+    <Rule Id="SA1121" Action="None" />
+    <Rule Id="SA1122" Action="Info" /> <!-- Use string.Empty for empty strings --> 
+    <Rule Id="SA1123" Action="Info" /> <!-- Region should not be located within a code element --> 
+    <Rule Id="SA1124" Action="None" />
+    <Rule Id="SA1125" Action="Info" /> <!-- Use shorthand for nullable types --> 
+    <Rule Id="SA1127" Action="Info" /> <!-- Generic type constraints should be on their own line --> 
+    <Rule Id="SA1128" Action="Info" /> <!-- Put constructor initializers on their own line --> 
+    <Rule Id="SA1129" Action="None" />
+    <Rule Id="SA1130" Action="Info" /> <!-- Use lambda syntax --> 
+    <Rule Id="SA1131" Action="Info" /> <!-- Constant values should appear on the right-hand side of comparisons --> 
+    <Rule Id="SA1132" Action="Info" /> <!-- Do not combine fields --> 
+    <Rule Id="SA1133" Action="Info" /> <!-- Do not combine attributes --> 
+    <Rule Id="SA1134" Action="Info" /> <!-- Each attribute should be placed on its own line of code --> 
+    <Rule Id="SA1135" Action="Info" /> <!-- Using directive should be qualified --> 
+    <Rule Id="SA1136" Action="Info" /> <!-- Enum values should be on separate lines --> 
+    <Rule Id="SA1137" Action="Info" /> <!-- Elements should have the same indentation --> 
+    <Rule Id="SA1139" Action="None" />
+    <Rule Id="SA1200" Action="None" />
+    <Rule Id="SA1201" Action="Info" /> <!-- Elements should appear in the correct order --> 
+    <Rule Id="SA1202" Action="Info" /> <!-- Elements should be ordered by access --> 
+    <Rule Id="SA1203" Action="Info" /> <!-- Constants should appear before fields --> 
+    <Rule Id="SA1204" Action="Info" /> <!-- Static elements should appear before instance elements --> 
+    <Rule Id="SA1205" Action="None" />
+    <Rule Id="SA1206" Action="None" />
+    <Rule Id="SA1208" Action="Info" /> <!-- Using directive ordering --> 
+    <Rule Id="SA1209" Action="Info" /> <!-- Using alias directives should be placed after all using namespace directives --> 
+    <Rule Id="SA1210" Action="Info" /> <!-- Using directives should be ordered alphabetically by the namespaces --> 
+    <Rule Id="SA1211" Action="Info" /> <!-- Using alias directive ordering --> 
+    <Rule Id="SA1212" Action="None" />
+    <Rule Id="SA1214" Action="Info" /> <!-- Readonly fields should appear before non-readonly fields --> 
+    <Rule Id="SA1216" Action="Info" /> <!-- Using static directives should be placed at the correct location --> 
+    <Rule Id="SA1300" Action="Info" /> <!-- Element should begin with an uppercase letter --> 
+    <Rule Id="SA1303" Action="Info" /> <!-- Const field names should begin with upper-case letter --> 
+    <Rule Id="SA1304" Action="Info" /> <!-- Non-private readonly fields should begin with upper-case letter --> 
+    <Rule Id="SA1306" Action="Info" /> <!-- Field should begin with lower-case letter --> 
+    <Rule Id="SA1307" Action="None" />
+    <Rule Id="SA1308" Action="Info" /> <!-- Field should not begin with the prefix 's_' --> 
+    <Rule Id="SA1309" Action="None" />
+    <Rule Id="SA1310" Action="None" />
+    <Rule Id="SA1311" Action="Info" /> <!-- Static readonly fields should begin with upper-case letter --> 
+    <Rule Id="SA1312" Action="Info" /> <!-- Variable should begin with lower-case letter --> 
+    <Rule Id="SA1313" Action="Info" /> <!-- Parameter should begin with lower-case letter --> 
+    <Rule Id="SA1314" Action="None" />
+    <Rule Id="SA1316" Action="Info" /> <!-- Tuple element names should use correct casing --> 
+    <Rule Id="SA1400" Action="None" />
+    <Rule Id="SA1401" Action="Info" /> <!-- Fields should be private --> 
+    <Rule Id="SA1402" Action="Info" /> <!-- File may only contain a single type --> 
+    <Rule Id="SA1403" Action="Info" /> <!-- File may only contain a single namespace --> 
+    <Rule Id="SA1404" Action="Info" /> <!-- Code analysis suppression should have justification --> 
+    <Rule Id="SA1405" Action="Info" /> <!-- Debug.Assert should provide message text --> 
+    <Rule Id="SA1407" Action="Info" /> <!-- Arithmetic expressions should declare precedence --> 
+    <Rule Id="SA1408" Action="Info" /> <!-- Conditional expressions should declare precedence --> 
+    <Rule Id="SA1410" Action="None" />
+    <Rule Id="SA1411" Action="None" />
+    <Rule Id="SA1413" Action="Info" /> <!-- Use trailing comma in multi-line initializers --> 
+    <Rule Id="SA1414" Action="Info" /> <!-- Tuple types in signatures should have element names --> 
+    <Rule Id="SA1500" Action="Info" /> <!-- Braces for multi-line statements should not share line --> 
+    <Rule Id="SA1501" Action="Info" /> <!-- Statement should not be on a single line --> 
+    <Rule Id="SA1502" Action="Info" /> <!-- Element should not be on a single line --> 
+    <Rule Id="SA1503" Action="Info" /> <!-- Braces should not be omitted --> 
+    <Rule Id="SA1504" Action="Info" /> <!-- All accessors should be single-line or multi-line --> 
+    <Rule Id="SA1505" Action="Info" /> <!-- An opening brace should not be followed by a blank line --> 
+    <Rule Id="SA1506" Action="Info" /> <!-- Element documentation headers should not be followed by blank line --> 
+    <Rule Id="SA1507" Action="Info" /> <!-- Code should not contain multiple blank lines in a row --> 
+    <Rule Id="SA1508" Action="Info" /> <!-- A closing brace should not be preceded by a blank line --> 
+    <Rule Id="SA1509" Action="Info" /> <!-- Opening braces should not be preceded by blank line --> 
+    <Rule Id="SA1510" Action="Info" /> <!-- 'else' statement should not be preceded by a blank line --> 
+    <Rule Id="SA1512" Action="Info" /> <!-- Single-line comments should not be followed by blank line --> 
+    <Rule Id="SA1513" Action="Info" /> <!-- Closing brace should be followed by blank line --> 
+    <Rule Id="SA1514" Action="Info" /> <!-- Element documentation header should be preceded by blank line --> 
+    <Rule Id="SA1515" Action="Info" /> <!-- Single-line comment should be preceded by blank line --> 
+    <Rule Id="SA1516" Action="Info" /> <!-- Elements should be separated by blank line --> 
+    <Rule Id="SA1517" Action="None" />
+    <Rule Id="SA1518" Action="Info" /> <!-- Code should not contain blank lines at the end of the file -->
+    <Rule Id="SA1519" Action="Info" /> <!-- Braces should not be omitted from multi-line child statement --> 
+    <Rule Id="SA1520" Action="Info" /> <!-- Use braces consistently --> 
+    <Rule Id="SA1600" Action="None" />
+    <Rule Id="SA1601" Action="Info" /> <!-- Partial elements should be documented --> 
+    <Rule Id="SA1602" Action="Info" /> <!-- Enumeration items should be documented --> 
+    <Rule Id="SA1604" Action="Info" /> <!-- Element documentation should have summary --> 
+    <Rule Id="SA1605" Action="Info" /> <!-- Partial element documentation should have summary --> 
+    <Rule Id="SA1606" Action="Info" /> <!-- Element documentation should have summary text --> 
+    <Rule Id="SA1608" Action="Info" /> <!-- Element documentation should not have default summary --> 
+    <Rule Id="SA1610" Action="Info" /> <!-- Property documentation should have value text --> 
+    <Rule Id="SA1611" Action="Info" /> <!-- The documentation for parameter 'message' is missing --> 
+    <Rule Id="SA1612" Action="Info" /> <!-- The parameter documentation is at incorrect position --> 
+    <Rule Id="SA1614" Action="Info" /> <!-- Element parameter documentation should have text --> 
+    <Rule Id="SA1615" Action="None" />
+    <Rule Id="SA1616" Action="Info" /> <!-- Element return value documentation should have text --> 
+    <Rule Id="SA1617" Action="None" />
+    <Rule Id="SA1618" Action="Info" /> <!-- The documentation for type parameter is missing --> 
+    <Rule Id="SA1619" Action="Info" /> <!-- The documentation for type parameter is missing --> 
+    <Rule Id="SA1622" Action="Info" /> <!-- Generic type parameter documentation should have text --> 
+    <Rule Id="SA1623" Action="Info" /> <!-- Property documentation text --> 
+    <Rule Id="SA1624" Action="Info" /> <!-- Because the property only contains a visible get accessor, the documentation summary text should begin with 'Gets' --> 
+    <Rule Id="SA1625" Action="None" />
+    <Rule Id="SA1626" Action="Info" /> <!-- Single-line comments should not use documentation style slashes --> 
+    <Rule Id="SA1627" Action="Info" /> <!-- The documentation text within the \'exception\' tag should not be empty --> 
+    <Rule Id="SA1629" Action="Info" /> <!-- Documentation text should end with a period --> 
+    <Rule Id="SA1633" Action="Info" /> <!-- File should have header --> 
+    <Rule Id="SA1642" Action="Info" /> <!-- Constructor summary documentation should begin with standard text --> 
+    <Rule Id="SA1643" Action="Info" /> <!-- Destructor summary documentation should begin with standard text --> 
+    <Rule Id="SA1649" Action="Info" /> <!-- File name should match first type name --> 
+    <Rule Id="SA1652" Action="None" />
+  </Rules> 
+  <Rules AnalyzerId="xunit.analyzers" RuleNamespace="xunit.analyzers"> 
+    <Rule Id="xUnit2013" Action="None" /> <!-- Do not use equality check to check for collection size. --> 
+  </Rules> 
+</RuleSet> 
diff --git a/eng/Packages.props b/eng/Packages.props
index d6312348572..095ffd991cf 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -9,6 +9,7 @@
     <PackageReference Update="LargeAddressAware" Version="1.0.5" />
     <PackageReference Update="Microsoft.Build.NuGetSdkResolver" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="Microsoft.CodeAnalysis.Build.Tasks" Version="$(MicrosoftNetCompilersToolsetVersion)" />
+    <PackageReference Update="Microsoft.CodeQuality.Analyzers" Version="3.3.0" PrivateAssets="all" />
     <PackageReference Update="Microsoft.DotNet.GenAPI" Version="2.1.0-prerelease-02404-02" />
     <PackageReference Update="Microsoft.DotNet.XUnitExtensions" Version="$(MicrosoftDotNetXUnitExtensionsVersion)" />
     <PackageReference Update="Microsoft.Net.Compilers.Toolset" Version="$(MicrosoftNetCompilersToolsetVersion)" />
@@ -20,6 +21,7 @@
     <PackageReference Update="PdbGit" Version="3.0.41" />
     <PackageReference Update="Shouldly" Version="3.0.0" />
     <PackageReference Update="SourceLink.Create.CommandLine" Version="2.1.2" />
+    <PackageReference Update="StyleCop.Analyzers" Version="1.2.0-beta.164" PrivateAssets="all" />
     <PackageReference Update="System.CodeDom" Version="4.4.0" />
     <PackageReference Update="System.Collections.Immutable" Version="5.0.0" />
     <PackageReference Update="System.Configuration.ConfigurationManager" Version="4.7.0" />
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 686a1ec5c2a..913016f5165 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -5,9 +5,9 @@
       <Uri>https://github.com/dotnet/roslyn-analyzers</Uri>
       <Sha />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.21369.3">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.21379.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>e97027cf100d2b532adce387e5cb93a373de93c9</Sha>
+      <Sha>62a8aafffd4c68ef887680f6837abdff906a662c</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="NuGet.Build.Tasks" Version="6.0.0-preview.1.107">
@@ -18,9 +18,9 @@
       <Uri>https://github.com/dotnet/roslyn</Uri>
       <Sha>5f124755232afa7b9903d6bdfcaeb47f39c8838e</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.21369.3">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.21379.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>e97027cf100d2b532adce387e5cb93a373de93c9</Sha>
+      <Sha>62a8aafffd4c68ef887680f6837abdff906a662c</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 7bcd695ca9a..d9ffb13fe57 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -32,7 +32,7 @@
     <!-- DotNetCliVersion MUST match the dotnet version in global.json.
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.21369.3</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.21379.2</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftCodeAnalysisBannedApiAnalyzersVersion>3.3.2</MicrosoftCodeAnalysisBannedApiAnalyzersVersion>
     <MicrosoftExtensionsDependencyModelVersion>6.0.0-preview.2.21154.6</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftNetCompilersToolsetVersion>4.0.0-3.21373.8</MicrosoftNetCompilersToolsetVersion>
diff --git a/eng/build.ps1 b/eng/build.ps1
index d9f579c7eec..9245a71a0f4 100644
--- a/eng/build.ps1
+++ b/eng/build.ps1
@@ -151,11 +151,25 @@ function Set-OptProfVariables() {
 function Check-EditedFiles() {
   # Log VSTS errors for changed lines
   git --no-pager diff HEAD --unified=0 --no-color --exit-code | ForEach-Object { "##vso[task.logissue type=error] $_" }
-  if($LASTEXITCODE -ne 0) {
+  if ($LASTEXITCODE -ne 0) {
     throw "##vso[task.logissue type=error] After building, there are changed files.  Please build locally and include these changes in your pull request."
   }
 }
 
+function Check-RequiredVersionBumps() {
+  # Log VSTS errors for missing required version bumps
+  if ($env:SYSTEM_PULLREQUEST_TARGETBRANCH) {
+    $versionLineChanged = $false
+    git --no-pager diff --unified --no-color --exit-code -w origin/$env:SYSTEM_PULLREQUEST_TARGETBRANCH HEAD src\Framework\EngineServices.cs `
+      | Select-String -Pattern "int Version =" | ForEach-Object -process { $versionLineChanged = $true }
+    if (($LASTEXITCODE -ne 0) -and (-not $versionLineChanged)) {
+      throw "##vso[task.logissue type=error] Detected changes in Framework\EngineServices.cs without a version bump.  " +
+            "If you are making API changes, please bump the version.  " +
+            "If the changes in the file are cosmetic, please add/change a comment on the Version prop to silence the error."
+    }
+  }
+}
+
 try {
   Process-Arguments
 
@@ -165,6 +179,10 @@ try {
 
   $VSSetupDir = Join-Path $ArtifactsDir "VSSetup\$configuration"
 
+  if ($ci -and $build) {
+    Check-RequiredVersionBumps
+  }
+
   Build-Repo
 
   if ($ci -and $build) {
diff --git a/eng/common/internal/Tools.csproj b/eng/common/internal/Tools.csproj
index f46d5efe2e3..beb9c4648ea 100644
--- a/eng/common/internal/Tools.csproj
+++ b/eng/common/internal/Tools.csproj
@@ -1,5 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (c)  Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information. -->
+<!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
 <Project Sdk="Microsoft.NET.Sdk">
   <PropertyGroup>
     <TargetFramework>net472</TargetFramework>
diff --git a/eng/common/templates/steps/source-build.yml b/eng/common/templates/steps/source-build.yml
index e20637ed6a1..705b7a1c847 100644
--- a/eng/common/templates/steps/source-build.yml
+++ b/eng/common/templates/steps/source-build.yml
@@ -29,6 +29,11 @@ steps:
       officialBuildArgs='/p:DotNetPublishUsingPipelines=true /p:OfficialBuildId=$(BUILD.BUILDNUMBER)'
     fi
 
+    internalRuntimeDownloadArgs=
+    if [ '$(dotnetclimsrc-read-sas-token-base64)' != '$''(dotnetclimsrc-read-sas-token-base64)' ]; then
+      internalRuntimeDownloadArgs='--runtimesourcefeed https://dotnetclimsrc.blob.core.windows.net/dotnet --runtimesourcefeedkey $(dotnetclimsrc-read-sas-token-base64)'
+    fi
+
     targetRidArgs=
     if [ '${{ parameters.platform.targetRID }}' != '' ]; then
       targetRidArgs='/p:TargetRid=${{ parameters.platform.targetRID }}'
@@ -43,6 +48,7 @@ steps:
       --configuration $buildConfig \
       --restore --build --pack $publishArgs -bl \
       $officialBuildArgs \
+      $internalRuntimeDownloadArgs \
       $targetRidArgs \
       /p:SourceBuildNonPortable=${{ parameters.platform.nonPortable }} \
       /p:ArcadeBuildFromSource=true
diff --git a/eng/config/OptProf.json b/eng/config/OptProf.json
index 53061450ff8..84b2c0bd27d 100644
--- a/eng/config/OptProf.json
+++ b/eng/config/OptProf.json
@@ -22,6 +22,12 @@
           "testCases": [
             "ManagedLangs.OptProfTests.DDRIT_RPS_ManagedLangs"
           ]
+        },
+        {
+          "container": "Microsoft.VisualStudio.ProjectSystem.DDRIT",
+          "testCases": [
+            "Microsoft.VisualStudio.ProjectSystem.DDRIT.OptProfOpenCloseTest.OpenAndCloseProjectTestSolution"
+          ]
         }  
       ]
     }
diff --git a/global.json b/global.json
index 023d2b2e6d4..3dc6a657bbb 100644
--- a/global.json
+++ b/global.json
@@ -3,7 +3,7 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "6.0.100-preview.4.21255.9",
+    "dotnet": "6.0.100-preview.6.21355.2",
     "runtimes": {
       "dotnet/x64": [
         "2.1.7"
@@ -15,6 +15,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.21369.3"
+    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.21379.2"
   }
 }
diff --git a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
index a75f66a8753..fb2f2bd0733 100644
--- a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
@@ -152,6 +152,13 @@ protected CustomBuildEventArgs(string message, string helpKeyword, string sender
         protected CustomBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
     }
     public delegate void CustomBuildEventHandler(object sender, Microsoft.Build.Framework.CustomBuildEventArgs e);
+    public abstract partial class EngineServices
+    {
+        public const int Version1 = 1;
+        protected EngineServices() { }
+        public virtual int Version { get { throw null; } }
+        public virtual bool LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) { throw null; }
+    }
     public partial class EnvironmentVariableReadEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
     {
         public EnvironmentVariableReadEventArgs() { }
@@ -186,6 +193,10 @@ public partial interface IBuildEngine
         void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e);
         void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e);
     }
+    public partial interface IBuildEngine10 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6, Microsoft.Build.Framework.IBuildEngine7, Microsoft.Build.Framework.IBuildEngine8, Microsoft.Build.Framework.IBuildEngine9
+    {
+        Microsoft.Build.Framework.EngineServices EngineServices { get; }
+    }
     public partial interface IBuildEngine2 : Microsoft.Build.Framework.IBuildEngine
     {
         bool IsRunningMultipleNodes { get; }
diff --git a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
index b4eefc32fab..98e39ce8b4c 100644
--- a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
@@ -152,6 +152,13 @@ protected CustomBuildEventArgs(string message, string helpKeyword, string sender
         protected CustomBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
     }
     public delegate void CustomBuildEventHandler(object sender, Microsoft.Build.Framework.CustomBuildEventArgs e);
+    public abstract partial class EngineServices
+    {
+        public const int Version1 = 1;
+        protected EngineServices() { }
+        public virtual int Version { get { throw null; } }
+        public virtual bool LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) { throw null; }
+    }
     public partial class EnvironmentVariableReadEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
     {
         public EnvironmentVariableReadEventArgs() { }
@@ -186,6 +193,10 @@ public partial interface IBuildEngine
         void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e);
         void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e);
     }
+    public partial interface IBuildEngine10 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6, Microsoft.Build.Framework.IBuildEngine7, Microsoft.Build.Framework.IBuildEngine8, Microsoft.Build.Framework.IBuildEngine9
+    {
+        Microsoft.Build.Framework.EngineServices EngineServices { get; }
+    }
     public partial interface IBuildEngine2 : Microsoft.Build.Framework.IBuildEngine
     {
         bool IsRunningMultipleNodes { get; }
diff --git a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
index 0e39d539eba..0c71f5d7390 100644
--- a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
@@ -164,6 +164,7 @@ public CombineTargetFrameworkInfoProperties() { }
         [Microsoft.Build.Framework.OutputAttribute]
         public string Result { get { throw null; } set { } }
         public string RootElementName { get { throw null; } set { } }
+        public bool UseAttributeForTargetFrameworkInfoPropertyNames { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
     public partial class CombineXmlElements : Microsoft.Build.Tasks.TaskExtension
@@ -613,6 +614,18 @@ public GetAssemblyIdentity() { }
         public Microsoft.Build.Framework.ITaskItem[] AssemblyFiles { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
+    public partial class GetCompatiblePlatform : Microsoft.Build.Tasks.TaskExtension
+    {
+        public GetCompatiblePlatform() { }
+        [Microsoft.Build.Framework.RequiredAttribute]
+        public Microsoft.Build.Framework.ITaskItem[] AnnotatedProjects { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem[] AssignedProjectsWithPlatform { get { throw null; } set { } }
+        [Microsoft.Build.Framework.RequiredAttribute]
+        public string CurrentProjectPlatform { get { throw null; } set { } }
+        public string PlatformLookupTable { get { throw null; } set { } }
+        public override bool Execute() { throw null; }
+    }
     public sealed partial class GetFileHash : Microsoft.Build.Tasks.TaskExtension
     {
         public GetFileHash() { }
diff --git a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
index 18bd0c97245..032e84fecf9 100644
--- a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
@@ -94,6 +94,7 @@ public CombineTargetFrameworkInfoProperties() { }
         [Microsoft.Build.Framework.OutputAttribute]
         public string Result { get { throw null; } set { } }
         public string RootElementName { get { throw null; } set { } }
+        public bool UseAttributeForTargetFrameworkInfoPropertyNames { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
     public partial class CombineXmlElements : Microsoft.Build.Tasks.TaskExtension
@@ -506,6 +507,18 @@ public GetAssemblyIdentity() { }
         public Microsoft.Build.Framework.ITaskItem[] AssemblyFiles { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
+    public partial class GetCompatiblePlatform : Microsoft.Build.Tasks.TaskExtension
+    {
+        public GetCompatiblePlatform() { }
+        [Microsoft.Build.Framework.RequiredAttribute]
+        public Microsoft.Build.Framework.ITaskItem[] AnnotatedProjects { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem[] AssignedProjectsWithPlatform { get { throw null; } set { } }
+        [Microsoft.Build.Framework.RequiredAttribute]
+        public string CurrentProjectPlatform { get { throw null; } set { } }
+        public string PlatformLookupTable { get { throw null; } set { } }
+        public override bool Execute() { throw null; }
+    }
     public sealed partial class GetFileHash : Microsoft.Build.Tasks.TaskExtension
     {
         public GetFileHash() { }
diff --git a/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs b/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
index 25d9b341e72..a9f91065f53 100644
--- a/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
+++ b/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
@@ -423,6 +423,7 @@ public void LogMessageFromResources(string messageResourceName, params object[]
         public bool LogMessagesFromFile(string fileName) { throw null; }
         public bool LogMessagesFromFile(string fileName, Microsoft.Build.Framework.MessageImportance messageImportance) { throw null; }
         public bool LogMessagesFromStream(System.IO.TextReader stream, Microsoft.Build.Framework.MessageImportance messageImportance) { throw null; }
+        public bool LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) { throw null; }
         public void LogTelemetry(string eventName, System.Collections.Generic.IDictionary<string, string> properties) { }
         public void LogWarning(string message, params object[] messageArgs) { }
         public void LogWarning(string subcategory, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
diff --git a/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs b/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
index 3fbc85bcf6e..26fb8b5075c 100644
--- a/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
+++ b/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
@@ -265,6 +265,7 @@ public void LogMessageFromResources(string messageResourceName, params object[]
         public bool LogMessagesFromFile(string fileName) { throw null; }
         public bool LogMessagesFromFile(string fileName, Microsoft.Build.Framework.MessageImportance messageImportance) { throw null; }
         public bool LogMessagesFromStream(System.IO.TextReader stream, Microsoft.Build.Framework.MessageImportance messageImportance) { throw null; }
+        public bool LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) { throw null; }
         public void LogTelemetry(string eventName, System.Collections.Generic.IDictionary<string, string> properties) { }
         public void LogWarning(string message, params object[] messageArgs) { }
         public void LogWarning(string subcategory, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
diff --git a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
index def0ed804d5..32e5a1a9ce1 100644
--- a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
@@ -545,7 +545,6 @@ public void AssemblyNameWithAllFields()
                 HashAlgorithm = System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA256,
                 VersionCompatibility = AssemblyVersionCompatibility.SameMachine,
                 CodeBase = "C:\\src",
-                KeyPair = new StrongNameKeyPair(new byte[] { 4, 3, 2, 1 }),
                 ContentType = AssemblyContentType.WindowsRuntime,
                 CultureName = "zh-HK",
             };
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
index 008efd6ab92..eb37f60b029 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
@@ -26,7 +26,6 @@ public class BuildRequestConfiguration_Tests : IDisposable
         public BuildRequestConfiguration_Tests(ITestOutputHelper testOutput)
         {
             _env = TestEnvironment.Create(testOutput);
-            _env.DoNotLaunchDebugger();
         }
 
         public void Dispose()
diff --git a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
index 9a485cb0d49..4d84c33b60f 100644
--- a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
@@ -665,6 +665,11 @@ public void Properties()
             Assert.Equal(1, loggingService.MaxCPUCount);
             loggingService.MaxCPUCount = 5;
             Assert.Equal(5, loggingService.MaxCPUCount);
+
+            // Test MinimumRequiredMessageImportance
+            Assert.Equal(MessageImportance.Low, loggingService.MinimumRequiredMessageImportance);
+            loggingService.RegisterLogger(new ConsoleLogger(LoggerVerbosity.Normal));
+            Assert.Equal(MessageImportance.Normal, loggingService.MinimumRequiredMessageImportance);
         }
 
         #endregion
@@ -718,6 +723,8 @@ public void LoggingPacketReceived()
 
         #endregion
 
+        #region WarningsAsErrors Tests
+
         private static readonly BuildWarningEventArgs BuildWarningEventForTreatAsErrorOrMessageTests = new BuildWarningEventArgs("subcategory", "C94A41A90FFB4EF592BF98BA59BEE8AF", "file", 1, 2, 3, 4, "message", "helpKeyword", "senderName");
 
         /// <summary>
@@ -1000,6 +1007,76 @@ private MockLogger GetLoggedEventsWithWarningsAsErrorsOrMessages(
             return logger;
         }
 
+        #endregion
+
+        #region MinimumRequiredMessageImportance Tests
+
+        [Fact]
+        public void ImportanceReflectsConsoleLoggerVerbosity()
+        {
+            _initializedService.RegisterLogger(new ConsoleLogger(LoggerVerbosity.Quiet));
+            _initializedService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.High - 1);
+            _initializedService.RegisterLogger(new ConsoleLogger(LoggerVerbosity.Minimal));
+            _initializedService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.High);
+            _initializedService.RegisterLogger(new ConsoleLogger(LoggerVerbosity.Normal));
+            _initializedService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.Normal);
+            _initializedService.RegisterLogger(new ConsoleLogger(LoggerVerbosity.Detailed));
+            _initializedService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.Low);
+            _initializedService.RegisterLogger(new ConsoleLogger(LoggerVerbosity.Diagnostic));
+            _initializedService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.Low);
+        }
+
+        [Fact]
+        public void ImportanceReflectsConfigurableForwardingLoggerVerbosity()
+        {
+            _initializedService.RegisterLogger(CreateConfigurableForwardingLogger(LoggerVerbosity.Quiet));
+            _initializedService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.High - 1);
+            _initializedService.RegisterLogger(CreateConfigurableForwardingLogger(LoggerVerbosity.Minimal));
+            _initializedService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.High);
+            _initializedService.RegisterLogger(CreateConfigurableForwardingLogger(LoggerVerbosity.Normal));
+            _initializedService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.Normal);
+            _initializedService.RegisterLogger(CreateConfigurableForwardingLogger(LoggerVerbosity.Detailed));
+            _initializedService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.Low);
+            _initializedService.RegisterLogger(CreateConfigurableForwardingLogger(LoggerVerbosity.Diagnostic));
+            _initializedService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.Low);
+        }
+
+        [Fact]
+        public void ImportanceReflectsCentralForwardingLoggerVerbosity()
+        {
+            MockHost mockHost = new MockHost();
+            ILoggingService node1LoggingService = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
+            ((IBuildComponent)node1LoggingService).InitializeComponent(mockHost);
+            ILoggingService node2LoggingService = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 2);
+            ((IBuildComponent)node2LoggingService).InitializeComponent(mockHost);
+
+            // CentralForwardingLogger is always registered in in-proc nodes and it does not affect minimum importance.
+            node1LoggingService.RegisterLogger(CreateConfigurableForwardingLogger(LoggerVerbosity.Minimal));
+            node1LoggingService.RegisterLogger(new CentralForwardingLogger());
+            node1LoggingService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.High);
+
+            // CentralForwardingLogger in out-of-proc nodes means that we are forwarding everything and the minimum importance
+            // is Low regardless of what other loggers are registered.
+            node2LoggingService.RegisterLogger(CreateConfigurableForwardingLogger(LoggerVerbosity.Minimal));
+            node2LoggingService.RegisterLogger(new CentralForwardingLogger());
+            node2LoggingService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.Low);
+            // Register another ConsoleLogger and verify that minimum importance hasn't changed.
+            node2LoggingService.RegisterLogger(CreateConfigurableForwardingLogger(LoggerVerbosity.Minimal));
+            node2LoggingService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.Low);
+        }
+
+        [Fact]
+        public void ImportanceReflectsUnknownLoggerVerbosity()
+        {
+            // Minimum message importance is Low (i.e. we're logging everything) even when all registered loggers have
+            // Normal verbosity if at least of one them is not on our whitelist.
+            _initializedService.RegisterLogger(new ConsoleLogger(LoggerVerbosity.Normal));
+            _initializedService.RegisterLogger(new MockLogger() { Verbosity = LoggerVerbosity.Normal });
+            _initializedService.RegisterLogger(CreateConfigurableForwardingLogger(LoggerVerbosity.Normal));
+            _initializedService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.Low);
+        }
+        #endregion
+
         #region PrivateMethods
 
         /// <summary>
@@ -1084,6 +1161,17 @@ private LoggerDescription CreateLoggerDescription(string loggerClassName, string
                                                                              );
             return centralLoggerDescrption;
         }
+
+        /// <summary>
+        /// Creates a new <see cref="ConfigurableForwardingLogger"/> with the given verbosity.
+        /// </summary>
+        private ConfigurableForwardingLogger CreateConfigurableForwardingLogger(LoggerVerbosity verbosity)
+        {
+            return new ConfigurableForwardingLogger()
+            {
+                Verbosity = verbosity
+            };
+        }
         #endregion
 
         #region HelperClasses
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index ac9b733f8d2..2d4ed73b93d 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -223,6 +223,11 @@ public bool IncludeTaskInputs
             set { }
         }
 
+        public MessageImportance MinimumRequiredMessageImportance
+        {
+            get => MessageImportance.Low;
+        }
+
         public void AddWarningsAsMessages(BuildEventContext buildEventContext, ISet<string> codes)
         {
             throw new NotImplementedException();
diff --git a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
index a160284d78a..232d22c62dd 100644
--- a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
+++ b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
@@ -125,8 +125,6 @@ public void PassedInFileSystemShouldBeReusedInSharedContext()
         [Fact]
         public void IsolatedContextShouldNotSupportBeingPassedAFileSystem()
         {
-            _env.DoNotLaunchDebugger();
-
             var fileSystem = new Helpers.LoggingFileSystem();
             Should.Throw<ArgumentException>(() => EvaluationContext.Create(EvaluationContext.SharingPolicy.Isolated, fileSystem));
         }
diff --git a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
index c1f0161e91d..bed09d043ec 100644
--- a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
+++ b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
@@ -33,8 +33,6 @@ public GraphLoadedFromSolutionTests(ITestOutputHelper output)
         [InlineData("1.sln", "2.proj")]
         public void ASolutionShouldBeTheSingleEntryPoint(params string[] files)
         {
-            _env.DoNotLaunchDebugger();
-
             for (var i = 0; i < files.Length; i++)
             {
                 files[i] = _env.CreateFile(files[i], string.Empty).Path;
@@ -52,8 +50,6 @@ public void ASolutionShouldBeTheSingleEntryPoint(params string[] files)
         [Fact]
         public void GraphConstructionFailsOnNonExistentSolution()
         {
-            _env.DoNotLaunchDebugger();
-
             var exception = Should.Throw<InvalidProjectFileException>(
                 () =>
                 {
@@ -80,8 +76,6 @@ public void StaticGraphShouldNotSupportNestedSolutions()
                 defaultTargets: null,
                 extraContent: referenceToSolution);
 
-            _env.DoNotLaunchDebugger();
-
             var exception = Should.Throw<InvalidOperationException>(
                 () =>
                 {
@@ -621,8 +615,6 @@ IEnumerable<ProjectItemInstance> GetIncomingEdgeItemsToNode(ProjectGraphNode nod
         [Fact]
         public void GraphConstructionShouldThrowOnMissingSolutionDependencies()
         {
-            _env.DoNotLaunchDebugger();
-
             var solutionContents = SolutionFileBuilder.FromGraphEdges(
                 _env,
                 new Dictionary<int, int[]> {{1, null}, {2, null}},
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index c766c843e8d..28af920a861 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -106,7 +106,6 @@ public void ConstructWithSingleNodeWithProjectInstanceFactory()
         [Fact]
         public void ProjectGraphNodeConstructorNoNullArguments()
         {
-            _env.DoNotLaunchDebugger();
             Assert.Throws<InternalErrorException>(() => new ProjectGraphNode(null));
         }
 
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index 004c7e50289..fce4c51b159 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -233,6 +233,30 @@ public enum ErrorKind
             LoggedError
         }
 
+        public class ConfigurableMockCache : ProjectCachePluginBase
+        {
+            public Func<BuildRequestData, PluginLoggerBase, CancellationToken, Task<CacheResult>>? GetCacheResultImplementation { get; set; }
+            public override Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken)
+            {
+                return Task.CompletedTask;
+            }
+
+            public override Task<CacheResult> GetCacheResultAsync(
+                BuildRequestData buildRequest,
+                PluginLoggerBase logger,
+                CancellationToken cancellationToken)
+            {
+                return GetCacheResultImplementation != null
+                    ? GetCacheResultImplementation(buildRequest, logger, cancellationToken)
+                    : Task.FromResult(CacheResult.IndicateNonCacheHit(CacheResultType.CacheNotApplicable));
+            }
+
+            public override Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken)
+            {
+                return Task.CompletedTask;
+            }
+        }
+
         public class InstanceMockCache : ProjectCachePluginBase
         {
             private readonly GraphCacheResponse? _testData;
@@ -272,6 +296,8 @@ public override async Task<CacheResult> GetCacheResultAsync(
 
                 logger.LogMessage($"MockCache: GetCacheResultAsync for {buildRequest.ProjectFullPath}", MessageImportance.High);
 
+                buildRequest.ProjectInstance.ShouldNotBeNull("The cache plugin expects evaluated projects.");
+
                 if (_projectQuerySleepTime is not null)
                 {
                     await Task.Delay(_projectQuerySleepTime.Value);
@@ -430,10 +456,14 @@ public void ProjectCacheByBuildParametersAndGraphBuildWorks(GraphCacheResponse t
             var graph = testData.CreateGraph(_env);
             var mockCache = new InstanceMockCache(testData);
 
-            buildParameters.ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
-                mockCache,
-                null,
-                graph);
+            // Reset the environment variables stored in the build params to take into account TestEnvironmentChanges.
+            buildParameters = new BuildParameters(buildParameters, resetEnvironment: true)
+            {
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
+                    mockCache,
+                    null,
+                    graph)
+            };
 
             using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
 
@@ -460,7 +490,12 @@ public void ProjectCacheByBuildParametersAndBottomUpBuildWorks(GraphCacheRespons
                 null,
                 graph);
 
-            buildParameters.ProjectCacheDescriptor = projectCacheDescriptor;
+            // Reset the environment variables stored in the build params to take into account TestEnvironmentChanges.
+            buildParameters = new BuildParameters(buildParameters, resetEnvironment: true)
+            {
+                ProjectCacheDescriptor = projectCacheDescriptor
+            };
+
 
             using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
             var nodesToBuildResults = new Dictionary<ProjectGraphNode, BuildResult>();
@@ -497,6 +532,9 @@ public void ProjectCacheByVsWorkaroundWorks(GraphCacheResponse testData, BuildPa
                         runningInVisualStudio: true,
                         visualStudioPath: currentBuildEnvironment.VisualStudioInstallRootDirectory));
 
+                // Reset the environment variables stored in the build params to take into account TestEnvironmentChanges.
+                buildParameters = new BuildParameters(buildParameters, resetEnvironment: true);
+
                 BuildManager.ProjectCacheItems.ShouldBeEmpty();
 
                 var graph = testData.CreateGraph(_env);
@@ -519,6 +557,7 @@ public void ProjectCacheByVsWorkaroundWorks(GraphCacheResponse testData, BuildPa
                 }
 
                 buildSession.Logger.FullLog.ShouldContain("Visual Studio Workaround based");
+                buildSession.Logger.FullLog.ShouldContain("Running project cache with Visual Studio workaround");
 
                 AssertCacheBuild(graph, testData, null, buildSession.Logger, nodesToBuildResults);
             }
@@ -584,6 +623,9 @@ public void DesignTimeBuildsDuringVsWorkaroundShouldDisableTheCache()
 
                 buildSession.Logger.FullLog.ShouldContain("Visual Studio Workaround based");
 
+                // Design time builds should not initialize the plugin.
+                buildSession.Logger.FullLog.ShouldNotContain("Running project cache with Visual Studio workaround");
+
                 // Cache doesn't get initialized and queried.
                 buildSession.Logger.FullLog.ShouldNotContain("BeginBuildAsync");
                 buildSession.Logger.FullLog.ShouldNotContain("GetCacheResultAsync for");
@@ -905,8 +947,6 @@ public void BuildFailsWhenCacheBuildResultIsWrong()
         [Fact]
         public void GraphBuildErrorsIfMultiplePluginsAreFound()
         {
-            _env.DoNotLaunchDebugger();
-
             var graph = Helpers.CreateProjectGraph(
                 _env,
                 new Dictionary<int, int[]>
@@ -931,8 +971,6 @@ public void GraphBuildErrorsIfMultiplePluginsAreFound()
         [Fact]
         public void GraphBuildErrorsIfNotAllNodeDefineAPlugin()
         {
-            _env.DoNotLaunchDebugger();
-
             var graph = Helpers.CreateProjectGraph(
                 _env,
                 dependencyEdges: new Dictionary<int, int[]>
@@ -985,8 +1023,6 @@ public static IEnumerable<object[]> CacheExceptionLocationsTestData
         [MemberData(nameof(CacheExceptionLocationsTestData))]
         public void EngineShouldHandleExceptionsFromCachePluginViaBuildParameters(ErrorLocations errorLocations, ErrorKind errorKind)
         {
-            _env.DoNotLaunchDebugger();
-
             SetEnvironmentForErrorLocations(errorLocations, errorKind.ToString());
 
             var project = _env.CreateFile("1.proj", @$"
@@ -1106,8 +1142,6 @@ public void EngineShouldHandleExceptionsFromCachePluginViaBuildParameters(ErrorL
         [MemberData(nameof(CacheExceptionLocationsTestData))]
         public void EngineShouldHandleExceptionsFromCachePluginViaGraphBuild(ErrorLocations errorLocations, ErrorKind errorKind)
         {
-            _env.DoNotLaunchDebugger();
-
             SetEnvironmentForErrorLocations(errorLocations, errorKind.ToString());
 
             var graph = Helpers.CreateProjectGraph(
@@ -1195,8 +1229,6 @@ public void EngineShouldHandleExceptionsFromCachePluginViaGraphBuild(ErrorLocati
         [Fact]
         public void EndBuildShouldGetCalledOnceWhenItThrowsExceptionsFromGraphBuilds()
         {
-            _env.DoNotLaunchDebugger();
-
             var project = _env.CreateFile(
                 "1.proj",
                 @$"
@@ -1316,6 +1348,83 @@ Task<BuildResult> BuildProjectFileAsync(int projectNumber)
             }
         }
 
+        [Theory]
+        [InlineData(false, false)]
+        // TODO: Reenable when this gets into the main branch.
+        //[InlineData(true, true)]
+        public void ParallelStressTestForVsWorkaround(bool useSynchronousLogging, bool disableInprocNode)
+        {
+            var currentBuildEnvironment = BuildEnvironmentHelper.Instance;
+
+            try
+            {
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly(
+                    new BuildEnvironment(
+                        currentBuildEnvironment.Mode,
+                        currentBuildEnvironment.CurrentMSBuildExePath,
+                        currentBuildEnvironment.RunningTests,
+                        runningInVisualStudio: true,
+                        visualStudioPath: currentBuildEnvironment.VisualStudioInstallRootDirectory));
+
+                BuildManager.ProjectCacheItems.ShouldBeEmpty();
+
+                var referenceNumbers = Enumerable.Range(2, NativeMethodsShared.GetLogicalCoreCount() * 2).ToArray();
+
+                var testData = new GraphCacheResponse(
+                    new Dictionary<int, int[]>
+                    {
+                        {1, referenceNumbers}
+                    },
+                    referenceNumbers.ToDictionary(k => k, k => GraphCacheResponse.SuccessfulProxyTargetResult())
+                );
+
+                var graph = testData.CreateGraph(_env);
+
+                // Even though the assembly cache is discovered, we'll be overriding it with a descriptor based cache.
+                BuildManager.ProjectCacheItems.ShouldHaveSingleItem();
+
+                using var buildSession = new Helpers.BuildManagerSession(_env, new BuildParameters
+                {
+                    MaxNodeCount = NativeMethodsShared.GetLogicalCoreCount(),
+                    UseSynchronousLogging = useSynchronousLogging,
+                    DisableInProcNode = disableInprocNode
+                });
+
+                var buildResultTasks = new List<Task<BuildResult>>();
+
+                foreach (var node in graph.ProjectNodes.Where(n => referenceNumbers.Contains(GetProjectNumber(n))))
+                {
+                    var buildResultTask = buildSession.BuildProjectFileAsync(
+                        node.ProjectInstance.FullPath,
+                        globalProperties:
+                        new Dictionary<string, string> { { "SolutionPath", graph.GraphRoots.First().ProjectInstance.FullPath } });
+
+                    buildResultTasks.Add(buildResultTask);
+                }
+
+                foreach (var buildResultTask in buildResultTasks)
+                {
+                    buildResultTask.Result.OverallResult.ShouldBe(BuildResultCode.Success);
+                }
+
+                buildSession.BuildProjectFile(
+                        graph.GraphRoots.First().ProjectInstance.FullPath,
+                        globalProperties:
+                        new Dictionary<string, string> {{"SolutionPath", graph.GraphRoots.First().ProjectInstance.FullPath}})
+                    .OverallResult.ShouldBe(BuildResultCode.Success);
+
+                StringShouldContainSubstring(buildSession.Logger.FullLog, $"{AssemblyMockCache}: GetCacheResultAsync for", graph.ProjectNodes.Count);
+
+                buildSession.Logger.FullLog.ShouldContain("Visual Studio Workaround based");
+                buildSession.Logger.FullLog.ShouldContain("Running project cache with Visual Studio workaround");
+            }
+            finally
+            {
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly(currentBuildEnvironment);
+                BuildManager.ProjectCacheItems.Clear();
+            }
+        }
+
         [Theory]
         [InlineData(false, false)]
         [InlineData(true, true)]
@@ -1351,6 +1460,97 @@ public void ParallelStressTest(bool useSynchronousLogging, bool disableInprocNod
             cache.QueryStartStops.Count.ShouldBe(graph.ProjectNodes.Count * 2);
         }
 
+        [Fact]
+        // Schedules different requests for the same BuildRequestConfiguration in parallel.
+        // The first batch of the requests are cache misses, the second batch are cache hits via proxy builds.
+        // The first batch is delayed so it starts intermingling with the second batch.
+        // This test ensures that scheduling proxy builds on the inproc node works nicely within the Scheduler
+        // if the BuildRequestConfigurations for those proxy builds have built before (or are still building) on
+        // the out of proc node.
+        // More details: https://github.com/dotnet/msbuild/pull/6635 
+        public void ProxyCacheHitsOnPreviousCacheMissesShouldWork()
+        {
+            var cacheNotApplicableTarget = "NATarget";
+            var cacheHitTarget = "CacheHitTarget";
+            var proxyTarget = "ProxyTarget";
+
+            var project =
+@$"
+<Project>
+    <Target Name='{cacheNotApplicableTarget}'>
+        <Exec Command=`{Helpers.GetSleepCommand(TimeSpan.FromMilliseconds(200))}` />
+        <Message Text='{cacheNotApplicableTarget} in $(MSBuildThisFile)' />
+    </Target>
+
+    <Target Name='{cacheHitTarget}'>
+        <Message Text='{cacheHitTarget} in $(MSBuildThisFile)' />
+    </Target>
+
+    <Target Name='{proxyTarget}'>
+        <Message Text='{proxyTarget} in $(MSBuildThisFile)' />
+    </Target>
+</Project>
+".Cleanup();
+
+            var projectPaths = Enumerable.Range(0, NativeMethodsShared.GetLogicalCoreCount())
+                .Select(i => _env.CreateFile($"project{i}.proj", project).Path)
+                .ToArray();
+
+            var cacheHitCount = 0;
+            var nonCacheHitCount = 0;
+
+            var buildParameters = new BuildParameters
+            {
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
+                    new ConfigurableMockCache
+                    {
+                        GetCacheResultImplementation = (request, _, _) =>
+                        {
+                            var projectFile = request.ProjectFullPath;
+
+                            if (request.TargetNames.Contains(cacheNotApplicableTarget))
+                            {
+                                Interlocked.Increment(ref nonCacheHitCount);
+                                return Task.FromResult(CacheResult.IndicateNonCacheHit(CacheResultType.CacheNotApplicable));
+                            }
+                            else
+                            {
+                                Interlocked.Increment(ref cacheHitCount);
+                                return Task.FromResult(
+                                    CacheResult.IndicateCacheHit(
+                                        new ProxyTargets(new Dictionary<string, string> {{proxyTarget, cacheHitTarget}})));
+                            }
+                        }
+                    },
+                    projectPaths.Select(p => new ProjectGraphEntryPoint(p)).ToArray(),
+                    projectGraph: null),
+                MaxNodeCount = NativeMethodsShared.GetLogicalCoreCount()
+            };
+
+            using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
+
+            var buildRequests = new List<(string, string)>();
+            buildRequests.AddRange(projectPaths.Select(r => (r, cacheNotApplicableTarget)));
+            buildRequests.AddRange(projectPaths.Select(r => (r, cacheHitTarget)));
+
+            var buildTasks = new List<Task<BuildResult>>();
+            foreach (var (projectPath, target) in buildRequests)
+            {
+                buildTasks.Add(buildSession.BuildProjectFileAsync(projectPath, new[] {target}));
+            }
+
+            foreach (var buildResult in buildTasks.Select(buildTask => buildTask.Result))
+            {
+                buildResult.Exception.ShouldBeNull();
+                buildResult.OverallResult.ShouldBe(BuildResultCode.Success);
+            }
+
+            buildSession.Logger.ProjectStartedEvents.Count.ShouldBe(2 * projectPaths.Length);
+
+            cacheHitCount.ShouldBe(projectPaths.Length);
+            nonCacheHitCount.ShouldBe(projectPaths.Length);
+        }
+
         private static void StringShouldContainSubstring(string aString, string substring, int expectedOccurrences)
         {
             aString.ShouldContain(substring);
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 42c230c97cb..b98b15bbe8c 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -1069,36 +1069,38 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread
             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));
             ErrorUtilities.VerifyThrow(!submission.IsCompleted, "Submission already complete.");
 
-            lock (_syncLock)
+            BuildRequestConfiguration resolvedConfiguration = null;
+            bool shuttingDown = false;
+
+            try
             {
-                ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;
-                if (projectInstance != null)
+                lock (_syncLock)
                 {
-                    if (_acquiredProjectRootElementCacheFromProjectInstance)
+                    ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;
+                    if (projectInstance != null)
                     {
-                        ErrorUtilities.VerifyThrowArgument(
-                            _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,
-                            "OM_BuildSubmissionsMultipleProjectCollections");
+                        if (_acquiredProjectRootElementCacheFromProjectInstance)
+                        {
+                            ErrorUtilities.VerifyThrowArgument(
+                                _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,
+                                "OM_BuildSubmissionsMultipleProjectCollections");
+                        }
+                        else
+                        {
+                            _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;
+                            _acquiredProjectRootElementCacheFromProjectInstance = true;
+                        }
                     }
-                    else
+                    else if (_buildParameters.ProjectRootElementCache == null)
                     {
-                        _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;
-                        _acquiredProjectRootElementCacheFromProjectInstance = true;
+                        // Create our own cache; if we subsequently get a build submission with a project instance attached,
+                        // we'll dump our cache and use that one.
+                        _buildParameters.ProjectRootElementCache =
+                            new ProjectRootElementCache(false /* do not automatically reload from disk */);
                     }
-                }
-                else if (_buildParameters.ProjectRootElementCache == null)
-                {
-                    // Create our own cache; if we subsequently get a build submission with a project instance attached,
-                    // we'll dump our cache and use that one.
-                    _buildParameters.ProjectRootElementCache =
-                        new ProjectRootElementCache(false /* do not automatically reload from disk */);
-                }
 
-                VerifyStateInternal(BuildManagerState.Building);
+                    VerifyStateInternal(BuildManagerState.Building);
 
-                BuildRequestConfiguration resolvedConfiguration = null;
-                try
-                {
                     // If we have an unnamed project, assign it a temporary name.
                     if (string.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))
                     {
@@ -1129,45 +1131,48 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread
 
                     resolvedConfiguration.ExplicitlyLoaded = true;
 
-                    if (_shuttingDown)
+                    // assign shutting down to local variable to avoid race condition: "setting _shuttingDown after this point during this method execution"
+                    shuttingDown = _shuttingDown;
+                    if (!shuttingDown)
                     {
-                        // We were already canceled!
-                        AddBuildRequestToSubmission(submission, resolvedConfiguration.ConfigurationId);
-                        BuildResult result = new BuildResult(submission.BuildRequest, new BuildAbortedException());
-                        submission.CompleteResults(result);
-                        submission.CompleteLogging(true);
-                        CheckSubmissionCompletenessAndRemove(submission);
-                        return;
-                    }
-
-                    if (ProjectCacheIsPresent())
-                    {
-                        IssueCacheRequestForBuildSubmission(new CacheRequest(submission, resolvedConfiguration));
-                    }
-                    else
-                    {
-                        AddBuildRequestToSubmission(submission, resolvedConfiguration.ConfigurationId);
-                        IssueBuildRequestForBuildSubmission(submission, allowMainThreadBuild);
+                        if (ProjectCacheIsPresent())
+                        {
+                            IssueCacheRequestForBuildSubmission(new CacheRequest(submission, resolvedConfiguration));
+                        }
+                        else
+                        {
+                            AddBuildRequestToSubmission(submission, resolvedConfiguration.ConfigurationId);
+                            IssueBuildRequestForBuildSubmission(submission, resolvedConfiguration, allowMainThreadBuild);
+                        }
                     }
                 }
-                catch (ProjectCacheException ex)
+            }
+            catch (ProjectCacheException ex)
+            {
+                ErrorUtilities.VerifyThrow(resolvedConfiguration is not null, "Cannot call project cache without having BuildRequestConfiguration");
+                CompleteSubmissionWithException(submission, resolvedConfiguration, ex);
+            }
+            catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
+            {
+                if (resolvedConfiguration is not null)
                 {
-                    ErrorUtilities.VerifyThrow(resolvedConfiguration is not null, "Cannot call project cache without having ");
                     CompleteSubmissionWithException(submission, resolvedConfiguration, ex);
                 }
-                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
+                else
                 {
-                    if (resolvedConfiguration is not null)
-                    {
-                        CompleteSubmissionWithException(submission, resolvedConfiguration, ex);
-                    }
-                    else
-                    {
-                        HandleSubmissionException(submission, ex);
-                        throw;
-                    }
+                    HandleSubmissionException(submission, ex);
+                    throw;
                 }
             }
+
+            // We are shutting down so submission has to be completed with BuildAbortedException
+            Debug.Assert(!Monitor.IsEntered(_syncLock));
+            if (shuttingDown)
+            {
+                ErrorUtilities.VerifyThrow(resolvedConfiguration is not null, "Cannot call project cache without having BuildRequestConfiguration");
+                // We were already canceled!
+                CompleteSubmissionWithException(submission, resolvedConfiguration, new BuildAbortedException());
+            }
         }
 
         bool ProjectCacheIsPresent()
@@ -1516,24 +1521,34 @@ private void ProcessPacket(int node, INodePacket packet)
             }
         }
 
+        /// <remarks>
+        /// To avoid deadlock possibility, this method MUST NOT be called inside of 'lock (_syncLock)'
+        /// </remarks>
         private void CompleteSubmissionWithException(BuildSubmission submission, BuildRequestConfiguration configuration, Exception exception)
         {
+            Debug.Assert(!Monitor.IsEntered(_syncLock));
+
             lock (_syncLock)
             {
                 if (submission.BuildRequest is null)
                 {
                     AddBuildRequestToSubmission(submission, configuration.ConfigurationId);
                 }
-
-                HandleSubmissionException(submission, exception);
             }
+
+            HandleSubmissionException(submission, exception);
         }
 
         /// <summary>
         /// Deals with exceptions that may be thrown when handling a submission.
         /// </summary>
+        /// <remarks>
+        /// To avoid deadlock possibility, this method MUST NOT be called inside of 'lock (_syncLock)'
+        /// </remarks>
         private void HandleSubmissionException(BuildSubmission submission, Exception ex)
         {
+            Debug.Assert(!Monitor.IsEntered(_syncLock));
+
             if (ex is AggregateException ae && ae.InnerExceptions.Count == 1)
             {
                 ex = ae.InnerExceptions.First();
@@ -1548,14 +1563,28 @@ private void HandleSubmissionException(BuildSubmission submission, Exception ex)
                 }
             }
 
-            lock(_syncLock)
+            bool submissionNeedsCompletion;
+            lock (_syncLock)
             {
                 // BuildRequest may be null if the submission fails early on.
-                if (submission.BuildRequest != null)
+                submissionNeedsCompletion = submission.BuildRequest != null;
+                if (submissionNeedsCompletion)
                 {
                     var result = new BuildResult(submission.BuildRequest, ex);
                     submission.CompleteResults(result);
-                    submission.CompleteLogging(true);
+                }
+            }
+
+            if (submissionNeedsCompletion)
+            {
+                WaitForAllLoggingServiceEventsToBeProcessed();
+            }
+
+            lock (_syncLock)
+            {
+                if (submissionNeedsCompletion)
+                {
+                    submission.CompleteLogging();
                 }
 
                 _overallBuildSuccess = false;
@@ -1563,6 +1592,21 @@ private void HandleSubmissionException(BuildSubmission submission, Exception ex)
             }
         }
 
+        /// <summary>
+        /// Waits to drain all events of logging service.
+        /// This method shall be used carefully because during draining, LoggingService will block all incoming events.
+        /// </summary>
+        /// <remarks>
+        /// To avoid deadlock possibility, this method MUST NOT be called inside of 'lock (_syncLock)'
+        /// </remarks>
+        private void WaitForAllLoggingServiceEventsToBeProcessed()
+        {
+            // this has to be called out of the lock (_syncLock)
+            // because processing events can callback to 'this' instance and cause deadlock
+            Debug.Assert(!Monitor.IsEntered(_syncLock));
+            ((LoggingService) ((IBuildComponentHost) this).LoggingService).WaitForThreadToProcessEvents();
+        }
+
         /// <summary>
         /// Deals with exceptions that may be thrown as a result of ExecuteSubmission.
         /// </summary>
@@ -1624,7 +1668,7 @@ private static void AddProxyBuildRequestToSubmission(BuildSubmission submission,
         /// The submission is a top level build request entering the BuildManager.
         /// Sends the request to the scheduler with optional legacy threading semantics behavior.
         /// </summary>
-        private void IssueBuildRequestForBuildSubmission(BuildSubmission submission, bool allowMainThreadBuild = false)
+        private void IssueBuildRequestForBuildSubmission(BuildSubmission submission, BuildRequestConfiguration configuration, bool allowMainThreadBuild = false)
         {
             _workQueue.Post(
                 () =>
@@ -1635,11 +1679,7 @@ private void IssueBuildRequestForBuildSubmission(BuildSubmission submission, boo
                     }
                     catch (BuildAbortedException bae)
                     {
-                        // We were canceled before we got issued by the work queue.
-                        var result = new BuildResult(submission.BuildRequest, bae);
-                        submission.CompleteResults(result);
-                        submission.CompleteLogging(true);
-                        CheckSubmissionCompletenessAndRemove(submission);
+                        CompleteSubmissionWithException(submission, configuration, bae);
                     }
                     catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
                     {
@@ -1703,11 +1743,17 @@ void IssueBuildSubmissionToSchedulerImpl(BuildSubmission submission, bool allowM
                             var buildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
                             ((IBuildComponentHost)this).LoggingService.LogFatalBuildError(buildEventContext, ex, new BuildEventFileInfo(submission.BuildRequestData.ProjectFullPath));
                         }
+                    }
 
-                        submission.CompleteLogging(true);
+                    WaitForAllLoggingServiceEventsToBeProcessed();
+
+                    lock (_syncLock)
+                    {
+                        submission.CompleteLogging();
                         ReportResultsToSubmission(new BuildResult(submission.BuildRequest, ex));
                         _overallBuildSuccess = false;
                     }
+
                 }
             }
         }
@@ -2259,14 +2305,14 @@ void HandleCacheResult()
                         {
                             // Issue the real build request.
                             AddBuildRequestToSubmission(submission, configuration.ConfigurationId);
-                            IssueBuildRequestForBuildSubmission(submission, allowMainThreadBuild: false);
+                            IssueBuildRequestForBuildSubmission(submission, configuration, allowMainThreadBuild: false);
                         }
                         else if (cacheResult.ResultType == CacheResultType.CacheHit && cacheResult.ProxyTargets != null)
                         {
                             // Setup submission.BuildRequest with proxy targets. The proxy request is built on the inproc node (to avoid
                             // ProjectInstance serialization). The proxy target results are used as results for the real targets.
                             AddProxyBuildRequestToSubmission(submission, configuration.ConfigurationId, cacheResult.ProxyTargets);
-                            IssueBuildRequestForBuildSubmission(submission, allowMainThreadBuild: false);
+                            IssueBuildRequestForBuildSubmission(submission, configuration, allowMainThreadBuild: false);
                         }
                         else if (cacheResult.ResultType == CacheResultType.CacheHit && cacheResult.BuildResult != null)
                         {
@@ -2282,7 +2328,7 @@ void HandleCacheResult()
                             }
 
                             _resultsCache.AddResult(result);
-                            submission.CompleteLogging(false);
+                            submission.CompleteLogging();
                             ReportResultsToSubmission(result);
                         }
                     }
@@ -2496,7 +2542,7 @@ private void CheckForActiveNodesAndCleanUpSubmissions()
 
                     // If we never received a project started event, consider logging complete anyhow, since the nodes have
                     // shut down.
-                    submission.CompleteLogging(waitForLoggingThread: false);
+                    submission.CompleteLogging();
 
                     _overallBuildSuccess = _overallBuildSuccess && (submission.BuildResult.OverallResult == BuildResultCode.Success);
                     CheckSubmissionCompletenessAndRemove(submission);
@@ -2625,7 +2671,7 @@ private void ReportResultsToSubmission(BuildResult result)
                     */
                     if (!submission.LoggingCompleted && result.Exception != null)
                     {
-                        submission.CompleteLogging(waitForLoggingThread: false);
+                        submission.CompleteLogging();
                     }
 
                     submission.CompleteResults(result);
@@ -2782,7 +2828,7 @@ private void OnThreadException(Exception e)
                         {
                             submission.BuildResult.Exception = e;
                         }
-                        submission.CompleteLogging(waitForLoggingThread: false);
+                        submission.CompleteLogging();
                         submission.CompleteResults(new BuildResult(submission.BuildRequest, e));
 
                         CheckSubmissionCompletenessAndRemove(submission);
@@ -2823,7 +2869,7 @@ private void OnProjectFinished(object sender, ProjectFinishedEventArgs e)
                         _projectStartedEvents.Remove(e.BuildEventContext.SubmissionId);
                         if (_buildSubmissions.TryGetValue(e.BuildEventContext.SubmissionId, out var submission))
                         {
-                            submission.CompleteLogging(false);
+                            submission.CompleteLogging();
                             CheckSubmissionCompletenessAndRemove(submission);
                         }
                     }
@@ -3113,7 +3159,7 @@ private void CancelAndMarkAsFailure()
         /// <summary>
         /// The logger registered to the logging service when no other one is.
         /// </summary>
-        private class NullLogger : ILogger
+        internal class NullLogger : ILogger
         {
             #region ILogger Members
 
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 1259648e255..93d21956172 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -253,7 +253,7 @@ private BuildParameters(ITranslator translator)
         /// <summary>
         /// Copy constructor
         /// </summary>
-        private BuildParameters(BuildParameters other)
+        internal BuildParameters(BuildParameters other, bool resetEnvironment = false)
         {
             ErrorUtilities.VerifyThrowInternalNull(other, nameof(other));
 
@@ -261,7 +261,11 @@ private BuildParameters(BuildParameters other)
             _culture = other._culture;
             _defaultToolsVersion = other._defaultToolsVersion;
             _enableNodeReuse = other._enableNodeReuse;
-            _buildProcessEnvironment = other._buildProcessEnvironment != null ? new Dictionary<string, string>(other._buildProcessEnvironment) : null;
+            _buildProcessEnvironment = resetEnvironment
+                ? CommunicationsUtilities.GetEnvironmentVariables()
+                : other._buildProcessEnvironment != null
+                    ? new Dictionary<string, string>(other._buildProcessEnvironment)
+                    : null;
             _environmentProperties = other._environmentProperties != null ? new PropertyDictionary<ProjectPropertyInstance>(other._environmentProperties) : null;
             _forwardingLoggers = other._forwardingLoggers != null ? new List<ForwardingLoggerRecord>(other._forwardingLoggers) : null;
             _globalProperties = other._globalProperties != null ? new PropertyDictionary<ProjectPropertyInstance>(other._globalProperties) : null;
diff --git a/src/Build/BackEnd/BuildManager/BuildSubmission.cs b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
index 91356f814c6..5b574b82b20 100644
--- a/src/Build/BackEnd/BuildManager/BuildSubmission.cs
+++ b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
@@ -165,13 +165,8 @@ internal void CompleteResults(BuildResult result)
         /// <summary>
         /// Indicates that all logging events for this submission are complete.
         /// </summary>
-        internal void CompleteLogging(bool waitForLoggingThread)
+        internal void CompleteLogging()
         {
-            if (waitForLoggingThread)
-            {
-                ((BackEnd.Logging.LoggingService)((IBuildComponentHost)BuildManager).LoggingService).WaitForThreadToProcessEvents();
-            }
-
             LoggingCompleted = true;
             CheckForCompletion();
         }
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index 86d4e070d33..096fb99283f 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -207,6 +207,15 @@ bool IncludeTaskInputs
             set;
         }
 
+        /// <summary>
+        /// Returns the minimum logging importance that must be logged because there is a possibility that
+        /// at least one registered logger consumes it.
+        /// </summary>
+        MessageImportance MinimumRequiredMessageImportance
+        {
+            get;
+        }
+
         #endregion
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index eb11739f920..19ed313b922 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.Globalization;
 using System.Linq;
 using System.Reflection;
@@ -222,6 +223,12 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         /// </summary>
         private IDictionary<int, ISet<string>> _warningsAsMessagesByProject;
 
+        /// <summary>
+        /// The minimum message importance that must be logged because there is a possibility that a logger consumes it.
+        /// Null means that the optimization is disabled or no relevant logger has been registered.
+        /// </summary>
+        private MessageImportance? _minimumRequiredMessageImportance;
+
         #region LoggingThread Data
 
         /// <summary>
@@ -702,6 +709,19 @@ public ICollection<string> RegisteredSinkNames
             }
         }
 
+        /// <summary>
+        /// Returns the minimum logging importance that must be logged because there is a possibility that
+        /// at least one registered logger consumes it.
+        /// </summary>
+        public MessageImportance MinimumRequiredMessageImportance
+        {
+            get
+            {
+                // If we haven't set the field return the default of "all messages must be logged".
+                return _minimumRequiredMessageImportance ?? MessageImportance.Low;
+            }
+        }
+
         #endregion
 
         #region Members
@@ -1120,7 +1140,7 @@ public void LogBuildEvent(BuildEventArgs buildEvent)
         #endregion
 
         /// <summary>
-        /// This method will becalled from multiple threads in asynchronous mode.
+        /// This method will be called from multiple threads in asynchronous mode.
         ///
         /// Determine where to send the buildevent either to the filters or to a specific sink.
         /// When in Asynchronous mode the event should to into the logging queue (as long as we are initialized).
@@ -1163,8 +1183,29 @@ internal void WaitForThreadToProcessEvents()
             // shutdown and nulled out the events we were going to wait on.
             if (_logMode == LoggerMode.Asynchronous && _loggingQueue != null)
             {
-                TerminateLoggingEventQueue();
-                CreateLoggingEventQueue();
+                BufferBlock<object> loggingQueue = null;
+                ActionBlock<object> loggingQueueProcessor = null;
+
+                lock (_lockObject)
+                {
+                    loggingQueue = _loggingQueue;
+                    loggingQueueProcessor = _loggingQueueProcessor;
+
+                    // Replaces _loggingQueue and _loggingQueueProcessor with new one, this will assure that
+                    // no further messages could possibly be trying to be added into queue we are about to drain
+                    CreateLoggingEventQueue();
+                }
+
+                // Drain queue.
+                // This shall not be locked to avoid possible deadlock caused by
+                // event handlers to reenter 'this' instance while trying to log something.
+                if (loggingQueue != null)
+                {
+                    Debug.Assert(!Monitor.IsEntered(_lockObject));
+
+                    loggingQueue.Complete();
+                    loggingQueueProcessor.Completion.Wait();
+                }
             }
         }
 
@@ -1225,21 +1266,27 @@ private void CreateLoggingEventQueue()
                 BoundedCapacity = Convert.ToInt32(_queueCapacity)
             };
 
-            _loggingQueue = new BufferBlock<object>(dataBlockOptions);
+            var loggingQueue = new BufferBlock<object>(dataBlockOptions);
 
             var executionDataBlockOptions = new ExecutionDataflowBlockOptions
             {
                 BoundedCapacity = 1
             };
 
-            _loggingQueueProcessor = new ActionBlock<object>(loggingEvent => LoggingEventProcessor(loggingEvent), executionDataBlockOptions);
+            var loggingQueueProcessor = new ActionBlock<object>(loggingEvent => LoggingEventProcessor(loggingEvent), executionDataBlockOptions);
 
             var dataLinkOptions = new DataflowLinkOptions
             {
                 PropagateCompletion = true
             };
 
-            _loggingQueue.LinkTo(_loggingQueueProcessor, dataLinkOptions);
+            loggingQueue.LinkTo(loggingQueueProcessor, dataLinkOptions);
+
+            lock (_lockObject)
+            {
+                _loggingQueue = loggingQueue;
+                _loggingQueueProcessor = loggingQueueProcessor;
+            }
         }
 
         /// <summary>
@@ -1553,10 +1600,57 @@ private void InitializeLogger(ILogger logger, IEventSource sourceForLogger)
                 InternalLoggerException.Throw(e, null, "FatalErrorWhileInitializingLogger", true, logger.GetType().Name);
             }
 
+            // Update the minimum guaranteed message importance based on the newly added logger.
+            UpdateMinimumMessageImportance(logger);
+
             // Keep track of the loggers so they can be unregistered later on
             _loggers.Add(logger);
         }
 
+        /// <summary>
+        /// Updates <see cref="_minimumRequiredMessageImportance"/> based on the given <paramref name="logger"/>.
+        /// </summary>
+        /// <param name="logger">The newly registered logger.</param>
+        /// <remarks>
+        /// This method contains knowledge about several logger classes used by MSBuild. The goal is to optimize common scenarios,
+        /// such as building on the command line with normal or minimum verbosity. If the user registers an external custom logger,
+        /// we will fall back to "minimum importance" == Low because we don't know how the logger processes messages, therefore we
+        /// must feed it everything.
+        /// </remarks>
+        private void UpdateMinimumMessageImportance(ILogger logger)
+        {
+            var innerLogger = (logger is Evaluation.ProjectCollection.ReusableLogger reusableLogger) ? reusableLogger.OriginalLogger : logger;
+
+            MessageImportance? minimumImportance = innerLogger switch
+            {
+                Build.Logging.ConsoleLogger consoleLogger => consoleLogger.GetMinimumMessageImportance(),
+                Build.Logging.ConfigurableForwardingLogger forwardingLogger => forwardingLogger.GetMinimumMessageImportance(),
+
+                // Central forwarding loggers are used in worker nodes if logging verbosity could not be optimized, i.e. in cases
+                // where we must log everything. They can be ignored in inproc nodes.
+                CentralForwardingLogger => (_nodeId > 1 ? MessageImportance.Low : null),
+
+                // The null logger has no effect on minimum verbosity.
+                Execution.BuildManager.NullLogger => null,
+
+                // If the logger is not on our whitelist, there are no importance guarantees. Fall back to "any importance".
+                _ => MessageImportance.Low
+            };
+
+            if (minimumImportance != null)
+            {
+                if (_minimumRequiredMessageImportance == null)
+                {
+                    _minimumRequiredMessageImportance = minimumImportance;
+                }
+                else
+                {
+                    int newMinImportance = Math.Max((int)_minimumRequiredMessageImportance, (int)minimumImportance);
+                    _minimumRequiredMessageImportance = (MessageImportance)newMinImportance;
+                }
+            }
+        }
+
         /// <summary>
         /// When an exception is raised in the logging thread, we do not want the application to terminate right away.
         /// Whidbey and orcas msbuild have the logger exceptions occurring on the engine thread so that the host can
@@ -1609,8 +1703,7 @@ private void TryRaiseProjectFinishedEvent(BuildEventArgs args)
         /// </summary>
         private string GetAndVerifyProjectFileFromContext(BuildEventContext context)
         {
-            string projectFile;
-            _projectFileMap.TryGetValue(context.ProjectContextId, out projectFile);
+            _projectFileMap.TryGetValue(context.ProjectContextId, out string projectFile);
 
             // PERF: Not using VerifyThrow to avoid boxing an int in the non-error case.
             if (projectFile == null)
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index 13e70263473..c5c3555f201 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -450,13 +450,10 @@ public void LogBuildStarted()
 
                 // Raise the event with the filters
                 ProcessLoggingEvent(buildEvent);
-
-                // Make sure we process this event before going any further
-                if (_logMode == LoggerMode.Asynchronous)
-                {
-                    WaitForThreadToProcessEvents();
-                }
             }
+
+            // Make sure we process this event before going any further
+            WaitForThreadToProcessEvents();
         }
 
         /// <summary>
@@ -478,12 +475,10 @@ public void LogBuildFinished(bool success)
                 BuildFinishedEventArgs buildEvent = new BuildFinishedEventArgs(message, null /* no help keyword */, success);
 
                 ProcessLoggingEvent(buildEvent);
-
-                if (_logMode == LoggerMode.Asynchronous)
-                {
-                    WaitForThreadToProcessEvents();
-                }
             }
+
+            // Make sure we process this event before going any further
+            WaitForThreadToProcessEvents();
         }
 
         /// <inheritdoc />
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index 4d6ad7af480..bf7b0033794 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -4,6 +4,7 @@
 #nullable enable
 using System;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.Linq;
 using System.Reflection;
 using System.Threading;
@@ -27,6 +28,15 @@ internal record NullableBool(bool Value)
         public static implicit operator bool(NullableBool? d) => d is not null && d.Value;
     }
 
+    internal enum ProjectCacheServiceState
+    {
+        NotInitialized,
+        BeginBuildStarted,
+        BeginBuildFinished,
+        ShutdownStarted,
+        ShutdownFinished
+    }
+
     internal class ProjectCacheService
     {
         private readonly BuildManager _buildManager;
@@ -34,6 +44,7 @@ internal class ProjectCacheService
         private readonly ProjectCacheDescriptor _projectCacheDescriptor;
         private readonly CancellationToken _cancellationToken;
         private readonly ProjectCachePluginBase _projectCachePlugin;
+        private ProjectCacheServiceState _serviceState = ProjectCacheServiceState.NotInitialized;
 
         /// <summary>
         /// An instanatiable version of MSBuildFileSystemBase not overriding any methods,
@@ -46,6 +57,7 @@ private sealed class DefaultMSBuildFileSystem : MSBuildFileSystemBase { }
         // Volatile because it is read by the BuildManager thread and written by one project cache service thread pool thread.
         // TODO: remove after we change VS to set the cache descriptor via build parameters.
         public volatile NullableBool? DesignTimeBuildsDetected;
+        private TaskCompletionSource<bool>? LateInitializationForVSWorkaroundCompleted;
 
         private ProjectCacheService(
             ProjectCachePluginBase projectCachePlugin,
@@ -75,39 +87,51 @@ public static async Task<ProjectCacheService> FromDescriptorAsync(
             // their verbosity levels.
             var loggerFactory = new Func<PluginLoggerBase>(() => new LoggingServiceToPluginLoggerAdapter(LoggerVerbosity.Normal, loggingService));
 
-            // TODO: remove after we change VS to set the cache descriptor via build parameters.
-            if (pluginDescriptor.VsWorkaround)
+            var service = new ProjectCacheService(plugin, buildManager, loggerFactory, pluginDescriptor, cancellationToken);
+
+            // TODO: remove the if after we change VS to set the cache descriptor via build parameters and always call BeginBuildAsync in FromDescriptorAsync.
+            // When running under VS we can't initialize the plugin until we evaluate a project (any project) and extract
+            // further information (set by VS) from it required by the plugin.
+            if (!pluginDescriptor.VsWorkaround)
             {
-                // When running under VS we can't initialize the plugin until we evaluate a project (any project) and extract
-                // further information (set by VS) from it required by the plugin.
-                return new ProjectCacheService(plugin, buildManager, loggerFactory, pluginDescriptor, cancellationToken);
+                await service.BeginBuildAsync();
             }
 
-            await InitializePlugin(pluginDescriptor, cancellationToken, loggerFactory, plugin);
-
-            return new ProjectCacheService(plugin, buildManager, loggerFactory, pluginDescriptor, cancellationToken);
+            return service;
         }
 
-        private static async Task InitializePlugin(
-            ProjectCacheDescriptor pluginDescriptor,
-            CancellationToken cancellationToken,
-            Func<PluginLoggerBase> loggerFactory,
-            ProjectCachePluginBase plugin
-        )
+        // TODO: remove vsWorkaroundOverrideDescriptor after we change VS to set the cache descriptor via build parameters.
+        private async Task BeginBuildAsync(ProjectCacheDescriptor? vsWorkaroundOverrideDescriptor = null)
         {
-            var logger = loggerFactory();
+            var logger = _loggerFactory();
 
             try
             {
-                await plugin.BeginBuildAsync(
+                SetState(ProjectCacheServiceState.BeginBuildStarted);
+
+                logger.LogMessage("Initializing project cache plugin", MessageImportance.Low);
+                var timer = Stopwatch.StartNew();
+
+                if (_projectCacheDescriptor.VsWorkaround)
+                {
+                    logger.LogMessage("Running project cache with Visual Studio workaround");
+                }
+
+                var projectDescriptor = vsWorkaroundOverrideDescriptor ?? _projectCacheDescriptor;
+                await _projectCachePlugin.BeginBuildAsync(
                     new CacheContext(
-                        pluginDescriptor.PluginSettings,
+                        projectDescriptor.PluginSettings,
                         new DefaultMSBuildFileSystem(),
-                        pluginDescriptor.ProjectGraph,
-                        pluginDescriptor.EntryPoints),
+                        projectDescriptor.ProjectGraph,
+                        projectDescriptor.EntryPoints),
                     // TODO: Detect verbosity from logging service.
                     logger,
-                    cancellationToken);
+                    _cancellationToken);
+
+                timer.Stop();
+                logger.LogMessage($"Finished initializing project cache plugin in {timer.Elapsed.TotalMilliseconds} ms", MessageImportance.Low);
+
+                SetState(ProjectCacheServiceState.BeginBuildFinished);
             }
             catch (Exception e)
             {
@@ -215,13 +239,20 @@ async Task<CacheResult> ProcessCacheRequest(CacheRequest request)
 
                 EvaluateProjectIfNecessary(request);
 
+                // Detect design time builds.
                 if (_projectCacheDescriptor.VsWorkaround)
                 {
-                    Interlocked.CompareExchange(
+                    var isDesignTimeBuild = IsDesignTimeBuild(request.Configuration.Project);
+
+                    var previousValue = Interlocked.CompareExchange(
                         ref DesignTimeBuildsDetected,
-                        new NullableBool(IsDesignTimeBuild(request.Configuration.Project)),
+                        new NullableBool(isDesignTimeBuild),
                         null);
 
+                    ErrorUtilities.VerifyThrowInternalError(
+                        previousValue is null || previousValue == false || isDesignTimeBuild,
+                        "Either all builds in a build session or design time builds, or none");
+
                     // No point progressing with expensive plugin initialization or cache query if design time build detected.
                     if (DesignTimeBuildsDetected)
                     {
@@ -230,13 +261,35 @@ async Task<CacheResult> ProcessCacheRequest(CacheRequest request)
                     }
                 }
 
+                // TODO: remove after we change VS to set the cache descriptor via build parameters.
+                // VS workaround needs to wait until the first project is evaluated to extract enough information to initialize the plugin.
+                // No cache request can progress until late initialization is complete.
                 if (_projectCacheDescriptor.VsWorkaround)
                 {
-                    // TODO: remove after we change VS to set the cache descriptor via build parameters.
-                    await LateInitializePluginForVsWorkaround(request);
+                    if (Interlocked.CompareExchange(
+                            ref LateInitializationForVSWorkaroundCompleted,
+                            new TaskCompletionSource<bool>(),
+                            null) is null)
+                    {
+                        await LateInitializePluginForVsWorkaround(request);
+                        LateInitializationForVSWorkaroundCompleted.SetResult(true);
+                    }
+                    else
+                    {
+                        // Can't be null. If the thread got here it means another thread initialized the completion source.
+                        await LateInitializationForVSWorkaroundCompleted!.Task;
+                    }
                 }
 
-                return await GetCacheResultAsync(cacheRequest.Submission.BuildRequestData);
+                ErrorUtilities.VerifyThrowInternalError(
+                    LateInitializationForVSWorkaroundCompleted is null ||
+                    _projectCacheDescriptor.VsWorkaround && LateInitializationForVSWorkaroundCompleted.Task.IsCompleted,
+                    "Completion source should be null when this is not the VS workaround");
+
+                return await GetCacheResultAsync(
+                    new BuildRequestData(
+                        request.Configuration.Project,
+                        request.Submission.BuildRequestData.TargetNames.ToArray()));
             }
 
             static bool IsDesignTimeBuild(ProjectInstance project)
@@ -284,7 +337,7 @@ async Task LateInitializePluginForVsWorkaround(CacheRequest request)
                     FileSystems.Default.FileExists(solutionPath),
                     $"Solution file does not exist: {solutionPath}");
 
-                await InitializePlugin(
+                await BeginBuildAsync(
                     ProjectCacheDescriptor.FromAssemblyPath(
                         _projectCacheDescriptor.PluginAssemblyPath!,
                         new[]
@@ -294,10 +347,7 @@ await InitializePlugin(
                                 configuration.Project.GlobalProperties)
                         },
                         projectGraph: null,
-                        _projectCacheDescriptor.PluginSettings),
-                    _cancellationToken,
-                    _loggerFactory,
-                    _projectCachePlugin);
+                        _projectCacheDescriptor.PluginSettings));
             }
 
             static bool MSBuildStringIsTrue(string msbuildString) =>
@@ -306,6 +356,19 @@ static bool MSBuildStringIsTrue(string msbuildString) =>
 
         private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest)
         {
+            lock (this)
+            {
+                CheckNotInState(ProjectCacheServiceState.NotInitialized);
+                CheckNotInState(ProjectCacheServiceState.BeginBuildStarted);
+
+                if (_serviceState is ProjectCacheServiceState.ShutdownStarted or ProjectCacheServiceState.ShutdownFinished)
+                {
+                    return CacheResult.IndicateNonCacheHit(CacheResultType.CacheNotApplicable);
+                }
+            }
+			
+            ErrorUtilities.VerifyThrowInternalNull(buildRequest.ProjectInstance, nameof(buildRequest.ProjectInstance));
+
             var queryDescription = $"{buildRequest.ProjectFullPath}" +
                                    $"\n\tTargets:[{string.Join(", ", buildRequest.TargetNames)}]" +
                                    $"\n\tGlobal Properties: {{{string.Join(",", buildRequest.GlobalProperties.Select(kvp => $"{kvp.Name}={kvp.EvaluatedValue}"))}}}";
@@ -361,16 +424,28 @@ public async Task ShutDown()
 
             try
             {
+                SetState(ProjectCacheServiceState.ShutdownStarted);
+
+                logger.LogMessage("Shutting down project cache plugin", MessageImportance.Low);
+                var timer = Stopwatch.StartNew();
+
                 await _projectCachePlugin.EndBuildAsync(logger, _cancellationToken);
+
+                timer.Stop();
+                logger.LogMessage($"Finished shutting down project cache plugin in {timer.Elapsed.TotalMilliseconds} ms", MessageImportance.Low);
+
+                if (logger.HasLoggedErrors)
+                {
+                    ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheShutdownFailed");
+                }
             }
-            catch (Exception e)
+            catch (Exception e) when (e is not ProjectCacheException)
             {
                 HandlePluginException(e, nameof(ProjectCachePluginBase.EndBuildAsync));
             }
-
-            if (logger.HasLoggedErrors)
+            finally
             {
-                ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheShutdownFailed");
+                SetState(ProjectCacheServiceState.ShutdownFinished);
             }
         }
 
@@ -387,6 +462,52 @@ private static void HandlePluginException(Exception e, string apiExceptionWasThr
                 apiExceptionWasThrownFrom);
         }
 
+        private void SetState(ProjectCacheServiceState newState)
+        {
+            lock (this)
+            {
+                switch (newState)
+                {
+                    case ProjectCacheServiceState.NotInitialized:
+                        ErrorUtilities.ThrowInternalError($"Cannot transition to {ProjectCacheServiceState.NotInitialized}");
+                        break;
+                    case ProjectCacheServiceState.BeginBuildStarted:
+                        CheckInState(ProjectCacheServiceState.NotInitialized);
+                        break;
+                    case ProjectCacheServiceState.BeginBuildFinished:
+                        CheckInState(ProjectCacheServiceState.BeginBuildStarted);
+                        break;
+                    case ProjectCacheServiceState.ShutdownStarted:
+                        CheckNotInState(ProjectCacheServiceState.ShutdownStarted);
+                        CheckNotInState(ProjectCacheServiceState.ShutdownFinished);
+                        break;
+                    case ProjectCacheServiceState.ShutdownFinished:
+                        CheckInState(ProjectCacheServiceState.ShutdownStarted);
+                        break;
+                    default:
+                        throw new ArgumentOutOfRangeException(nameof(newState), newState, null);
+                }
+
+                _serviceState = newState;
+            }
+        }
+
+        private void CheckInState(ProjectCacheServiceState expectedState)
+        {
+            lock (this)
+            {
+                ErrorUtilities.VerifyThrowInternalError(_serviceState == expectedState, $"Expected state {expectedState}, actual state {_serviceState}");
+            }
+        }
+
+        private void CheckNotInState(ProjectCacheServiceState unexpectedState)
+        {
+            lock (this)
+            {
+                ErrorUtilities.VerifyThrowInternalError(_serviceState != unexpectedState, $"Unexpected state {_serviceState}");
+            }
+        }
+
         private class LoggingServiceToPluginLoggerAdapter : PluginLoggerBase
         {
             private readonly ILoggingService _loggingService;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index be1bb7b8250..1601b3e29c6 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -34,7 +34,7 @@ internal class TaskHost :
 #if FEATURE_APPDOMAIN
         MarshalByRefObject,
 #endif
-        IBuildEngine9
+        IBuildEngine10
     {
         /// <summary>
         /// True if the "secret" environment variable MSBUILDNOINPROCNODE is set.
@@ -130,6 +130,7 @@ public TaskHost(IBuildComponentHost host, BuildRequestEntry requestEntry, Elemen
             _disableInprocNode = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
                 ? s_disableInprocNodeByEnvironmentVariable || host.BuildParameters.DisableInProcNode
                 : s_disableInprocNodeByEnvironmentVariable;
+            EngineServices = new EngineServicesImpl(this);
         }
 
         /// <summary>
@@ -874,6 +875,39 @@ internal void ReleaseAllCores()
 
         #endregion
 
+        #region IBuildEngine10 Members
+
+        [Serializable]
+        private sealed class EngineServicesImpl : EngineServices
+        {
+            private TaskHost _taskHost;
+
+            internal EngineServicesImpl(TaskHost taskHost)
+            {
+                _taskHost = taskHost;
+            }
+
+            /// <inheritdoc/>
+            public override bool LogsMessagesOfImportance(MessageImportance importance)
+            {
+#if FEATURE_APPDOMAIN
+                if (RemotingServices.IsTransparentProxy(_taskHost))
+                {
+                    // If the check would be a cross-domain call, chances are that it wouldn't be worth it.
+                    // Simply disable the optimization in such a case.
+                    return true;
+                }
+#endif
+                MessageImportance minimumImportance = _taskHost._taskLoggingContext?.LoggingService.MinimumRequiredMessageImportance ?? MessageImportance.Low;
+                return importance <= minimumImportance;
+
+            }
+        }
+
+        public EngineServices EngineServices{ get; }
+
+        #endregion
+
         /// <summary>
         /// Called by the internal MSBuild task.
         /// Does not take the lock because it is called by another request builder thread.
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 377e6805897..65af9d8c8a7 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -177,6 +177,7 @@ internal class Scheduler : IScheduler
         /// </summary>
         public Scheduler()
         {
+            // Be careful moving these to Traits, changing the timing of reading environment variables has a breaking potential.
             _debugDumpState = Traits.Instance.DebugScheduler;
             _debugDumpPath = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
                 ? DebugUtils.DebugPath
@@ -1385,7 +1386,7 @@ private void AssignUnscheduledRequestToNode(SchedulableRequest request, int node
 
             void WarnWhenProxyBuildsGetScheduledOnOutOfProcNode()
             {
-                if (request.IsProxyBuildRequest() && nodeId != InProcNodeId)
+                if (request.IsProxyBuildRequest() && nodeId != InProcNodeId && _schedulingData.CanScheduleRequestToNode(request, InProcNodeId))
                 {
                     ErrorUtilities.VerifyThrow(
                         _componentHost.BuildParameters.DisableInProcNode || ForceAffinityOutOfProc,
@@ -1763,7 +1764,25 @@ private void HandleRequestBlockedByNewRequests(SchedulableRequest parentRequest,
 
                         if (affinityMismatch)
                         {
-                            BuildResult result = new BuildResult(request, new InvalidOperationException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("AffinityConflict", requestAffinity, existingRequestAffinity)));
+                            ErrorUtilities.VerifyThrowInternalError(
+                                _configCache.HasConfiguration(request.ConfigurationId),
+                                "A request should have a configuration if it makes it this far in the build process.");
+
+                            var config = _configCache[request.ConfigurationId];
+                            var globalProperties = string.Join(
+                                ";",
+                                config.GlobalProperties.ToDictionary().Select(kvp => $"{kvp.Key}={kvp.Value}"));
+
+                            var result = new BuildResult(
+                                request,
+                                new InvalidOperationException(
+                                    ResourceUtilities.FormatResourceStringStripCodeAndKeyword(
+                                        "AffinityConflict",
+                                        requestAffinity,
+                                        existingRequestAffinity,
+                                        config.ProjectFullPath,
+                                        globalProperties
+                                        )));
                             response = GetResponseForResult(nodeForResults, request, result);
                             responses.Add(response);
                             continue;
@@ -2107,7 +2126,11 @@ private NodeAffinity GetNodeAffinityForRequest(BuildRequest request)
                 return NodeAffinity.InProc;
             }
 
-            if (request.IsProxyBuildRequest())
+            ErrorUtilities.VerifyThrow(request.ConfigurationId != BuildRequestConfiguration.InvalidConfigurationId, "Requests should have a valid configuration id at this point");
+            // If this configuration has been previously built on an out of proc node, scheduling it on the inproc node can cause either an affinity mismatch error when
+            // there are other pending requests for the same configuration or "unscheduled requests remain in the presence of free out of proc nodes" errors if there's no pending requests.
+            // So only assign proxy builds to the inproc node if their config hasn't been previously assigned to an out of proc node.
+            if (_schedulingData.CanScheduleConfigurationToNode(request.ConfigurationId, InProcNodeId) && request.IsProxyBuildRequest())
             {
                 return NodeAffinity.InProc;
             }
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
index 0edc83f296e..9aeb9009c80 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
@@ -647,7 +647,12 @@ public int GetAssignedNodeForRequestConfiguration(int configurationId)
         /// </summary>
         public bool CanScheduleRequestToNode(SchedulableRequest request, int nodeId)
         {
-            int requiredNodeId = GetAssignedNodeForRequestConfiguration(request.BuildRequest.ConfigurationId);
+            return CanScheduleConfigurationToNode(request.BuildRequest.ConfigurationId, nodeId);
+        }
+
+        public bool CanScheduleConfigurationToNode(int configurationId, int nodeId)
+        {
+            int requiredNodeId = GetAssignedNodeForRequestConfiguration(configurationId);
             return requiredNodeId == Scheduler.InvalidNodeId || requiredNodeId == nodeId;
         }
 
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index 237ea72d01e..6f170c430d0 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -117,7 +117,7 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
                 {
                     result = (SdkResult)sdkResolver.Resolve(sdk, context, resultFactory);
                 }
-                catch (Exception e) when (e is FileNotFoundException || (e is FileLoadException && sdkResolver.GetType().GetTypeInfo().Name.Equals("NuGetSdkResolver", StringComparison.Ordinal)))
+                catch (Exception e) when ((e is FileNotFoundException || e is FileLoadException) && sdkResolver.GetType().GetTypeInfo().Name.Equals("NuGetSdkResolver", StringComparison.Ordinal))
                 {
                     // Since we explicitly add the NuGetSdkResolver, we special case this.  The NuGetSdkResolver has special logic
                     // to load NuGet assemblies at runtime which could fail if the user is not running installed MSBuild.  Rather
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 07519d583ba..8629bd94317 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -1801,6 +1801,11 @@ internal class ReusableLogger : INodeLogger, IEventSource4
             /// </summary>
             private readonly ILogger _originalLogger;
 
+            /// <summary>
+            /// Returns the logger we are wrapping.
+            /// </summary>
+            internal ILogger OriginalLogger => _originalLogger;
+
             /// <summary>
             /// The design-time event source
             /// </summary>
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index 2fea1b7c5ee..167a67e396e 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -331,6 +331,33 @@ internal void IsRunningWithCharacterFileType()
         /// </summary>
         internal bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity) => Verbosity >= checkVerbosity;
 
+        /// <summary>
+        /// Returns the minimum logger verbosity required to log a message with the given importance.
+        /// </summary>
+        /// <param name="importance">The message importance.</param>
+        /// <param name="lightenText">True if the message should be rendered using lighter colored text.</param>
+        /// <returns>The logger verbosity required to log a message of the given <paramref name="importance"/>.</returns>
+        internal static LoggerVerbosity ImportanceToMinimumVerbosity(MessageImportance importance, out bool lightenText)
+        {
+            switch (importance)
+            {
+                case MessageImportance.High:
+                    lightenText = false;
+                    return LoggerVerbosity.Minimal;
+                case MessageImportance.Normal:
+                    lightenText = true;
+                    return LoggerVerbosity.Normal;
+                case MessageImportance.Low:
+                    lightenText = true;
+                    return LoggerVerbosity.Detailed;
+
+                default:
+                    ErrorUtilities.VerifyThrow(false, "Impossible");
+                    lightenText = false;
+                    return LoggerVerbosity.Detailed;
+            }
+        }
+
         /// <summary>
         /// Sets foreground color to color specified
         /// </summary>
diff --git a/src/Build/Logging/ConsoleLogger.cs b/src/Build/Logging/ConsoleLogger.cs
index 3af25e3ce19..c6358a9badb 100644
--- a/src/Build/Logging/ConsoleLogger.cs
+++ b/src/Build/Logging/ConsoleLogger.cs
@@ -164,8 +164,6 @@ private void InitializeBaseConsoleLogger()
                 _parameters = null;
             }
 
-            
-
             _consoleLogger.SkipProjectStartedText = _skipProjectStartedText;
         }
 
@@ -477,6 +475,31 @@ public void CustomEventHandler(object sender, CustomBuildEventArgs e)
             _consoleLogger.CustomEventHandler(sender, e);
         }
 
+        /// <summary>
+        /// Returns the minimum importance of messages logged by this logger.
+        /// </summary>
+        /// <returns>
+        /// The minimum message importance corresponding to this logger's verbosity or (MessageImportance.High - 1)
+        /// if this logger does not log messages of any importance.
+        /// </returns>
+        internal MessageImportance GetMinimumMessageImportance()
+        {
+            if (Verbosity >= BaseConsoleLogger.ImportanceToMinimumVerbosity(MessageImportance.Low, out _))
+            {
+                return MessageImportance.Low;
+            }
+            else if (Verbosity >= BaseConsoleLogger.ImportanceToMinimumVerbosity(MessageImportance.Normal, out _))
+            {
+                return MessageImportance.Normal;
+            }
+            else if (Verbosity >= BaseConsoleLogger.ImportanceToMinimumVerbosity(MessageImportance.High, out _))
+            {
+                return MessageImportance.High;
+            }
+            // The logger does not log messages of any importance.
+            return MessageImportance.High - 1;
+        }
+
         #endregion
     }
 }
diff --git a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
index d530bd07264..83c2499aefa 100644
--- a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
@@ -75,7 +75,7 @@ public int NodeId
         /// </summary>
         private void InitializeForwardingTable()
         {
-            _forwardingTable = new Dictionary<string, int>(15, StringComparer.OrdinalIgnoreCase);
+            _forwardingTable = new Dictionary<string, int>(17, StringComparer.OrdinalIgnoreCase);
             _forwardingTable[BuildStartedEventDescription] = 0;
             _forwardingTable[BuildFinishedEventDescription] = 0;
             _forwardingTable[ProjectStartedEventDescription] = 0;
@@ -258,6 +258,31 @@ private void SetForwardingBasedOnVerbosity()
             }
         }
 
+        /// <summary>
+        /// Returns the minimum importance of messages logged by this logger.
+        /// </summary>
+        /// <returns>
+        /// The minimum message importance corresponding to this logger's verbosity or (MessageImportance.High - 1)
+        /// if this logger does not log messages of any importance.
+        /// </returns>
+        internal MessageImportance GetMinimumMessageImportance()
+        {
+            if (_forwardingTable[LowMessageEventDescription] == 1)
+            {
+                return MessageImportance.Low;
+            }
+            if (_forwardingTable[NormalMessageEventDescription] == 1)
+            {
+                return MessageImportance.Normal;
+            }
+            if (_forwardingTable[HighMessageEventDescription] == 1)
+            {
+                return MessageImportance.High;
+            }
+            // The logger does not log messages of any importance.
+            return MessageImportance.High - 1;
+        }
+
         /// <summary>
         /// Reset the states of per-build member variables.
         /// Used when a build is finished, but the logger might be needed for the next build.
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index d9d42add607..26ed295bc8b 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -1100,23 +1100,8 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
             }
             else
             {
-                switch (e.Importance)
-                {
-                    case MessageImportance.High:
-                        print = IsVerbosityAtLeast(LoggerVerbosity.Minimal);
-                        break;
-                    case MessageImportance.Normal:
-                        print = IsVerbosityAtLeast(LoggerVerbosity.Normal);
-                        lightenText = true;
-                        break;
-                    case MessageImportance.Low:
-                        print = IsVerbosityAtLeast(LoggerVerbosity.Detailed);
-                        lightenText = true;
-                        break;
-                    default:
-                        ErrorUtilities.VerifyThrow(false, "Impossible");
-                        break;
-                }
+                LoggerVerbosity minimumVerbosity = ImportanceToMinimumVerbosity(e.Importance, out lightenText);
+                print = IsVerbosityAtLeast(minimumVerbosity);
             }
 
             if (print)
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index c47c5ed976d..9deedd88b0e 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -497,28 +497,8 @@ public override void WarningHandler(object sender, BuildWarningEventArgs e)
         /// </summary>
         public override void MessageHandler(object sender, BuildMessageEventArgs e)
         {
-            bool print = false;
-            bool lightenText = false;
-            switch (e.Importance)
-            {
-                case MessageImportance.High:
-                    print = IsVerbosityAtLeast(LoggerVerbosity.Minimal);
-                    break;
-
-                case MessageImportance.Normal:
-                    print = IsVerbosityAtLeast(LoggerVerbosity.Normal);
-                    lightenText = true;
-                    break;
-
-                case MessageImportance.Low:
-                    print = IsVerbosityAtLeast(LoggerVerbosity.Detailed);
-                    lightenText = true;
-                    break;
-
-                default:
-                    ErrorUtilities.VerifyThrow(false, "Impossible");
-                    break;
-            }
+            LoggerVerbosity minimumVerbosity = ImportanceToMinimumVerbosity(e.Importance, out bool lightenText);
+            bool print = IsVerbosityAtLeast(minimumVerbosity);
 
             if (print)
             {
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 2441874fb8f..747e1b197e1 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1353,7 +1353,7 @@
     <comment>{StrBegin="MSB4209: "}</comment>
   </data>
   <data name="AffinityConflict" xml:space="preserve">
-    <value>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for this project.</value>
+    <value>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</value>
     <comment>{StrBegin="MSB4213: "}</comment>
   </data>
   <data name="UnableToCreateNode" xml:space="preserve">
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index fd04936e305..b3861309d5c 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -1790,8 +1790,8 @@
         <note>{StrBegin="MSB4209: "}</note>
       </trans-unit>
       <trans-unit id="AffinityConflict">
-        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for this project.</source>
-        <target state="translated">MSB4213: Určené spřažení požadavku {0} je v konfliktu s předchozím spřažením {1} určeným pro tento projekt.</target>
+        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</source>
+        <target state="new">MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</target>
         <note>{StrBegin="MSB4213: "}</note>
       </trans-unit>
       <trans-unit id="UnableToCreateNode">
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index d3c84a65998..f8a63950797 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -1790,8 +1790,8 @@
         <note>{StrBegin="MSB4209: "}</note>
       </trans-unit>
       <trans-unit id="AffinityConflict">
-        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for this project.</source>
-        <target state="translated">MSB4213: Die angegebene Anforderungsaffinität {0} steht mit einer früheren Affinität {1} in Konflikt, die für dieses Projekt angegeben wurde.</target>
+        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</source>
+        <target state="new">MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</target>
         <note>{StrBegin="MSB4213: "}</note>
       </trans-unit>
       <trans-unit id="UnableToCreateNode">
diff --git a/src/Build/Resources/xlf/Strings.en.xlf b/src/Build/Resources/xlf/Strings.en.xlf
index 2e20e50527d..d628e3aac14 100644
--- a/src/Build/Resources/xlf/Strings.en.xlf
+++ b/src/Build/Resources/xlf/Strings.en.xlf
@@ -1870,8 +1870,8 @@
         <note>{StrBegin="MSB4209: "}</note>
       </trans-unit>
       <trans-unit id="AffinityConflict">
-        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for this project.</source>
-        <target state="new">MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for this project.</target>
+        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</source>
+        <target state="new">MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</target>
         <note>{StrBegin="MSB4213: "}</note>
       </trans-unit>
       <trans-unit id="UnableToCreateNode">
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index f580cb75fab..39d606c3376 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -1790,8 +1790,8 @@
         <note>{StrBegin="MSB4209: "}</note>
       </trans-unit>
       <trans-unit id="AffinityConflict">
-        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for this project.</source>
-        <target state="translated">MSB4213: La afinidad de solicitud {0} especificada está en conflicto con una afinidad {1} anterior especificada para este proyecto.</target>
+        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</source>
+        <target state="new">MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</target>
         <note>{StrBegin="MSB4213: "}</note>
       </trans-unit>
       <trans-unit id="UnableToCreateNode">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 7949e02cabc..4fb148b8f3f 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -1790,8 +1790,8 @@
         <note>{StrBegin="MSB4209: "}</note>
       </trans-unit>
       <trans-unit id="AffinityConflict">
-        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for this project.</source>
-        <target state="translated">MSB4213: L'affinité de requête spécifiée {0} est en conflit avec une affinité précédente {1} spécifiée pour ce projet.</target>
+        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</source>
+        <target state="new">MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</target>
         <note>{StrBegin="MSB4213: "}</note>
       </trans-unit>
       <trans-unit id="UnableToCreateNode">
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 52645cf5e12..6c438cb90c0 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -1790,8 +1790,8 @@
         <note>{StrBegin="MSB4209: "}</note>
       </trans-unit>
       <trans-unit id="AffinityConflict">
-        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for this project.</source>
-        <target state="translated">MSB4213: l'affinità della richiesta specificata {0} è in conflitto con l'affinità {1} precedentemente specificata per il progetto.</target>
+        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</source>
+        <target state="new">MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</target>
         <note>{StrBegin="MSB4213: "}</note>
       </trans-unit>
       <trans-unit id="UnableToCreateNode">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 56ac6773c8a..83660d1cd01 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -1790,8 +1790,8 @@
         <note>{StrBegin="MSB4209: "}</note>
       </trans-unit>
       <trans-unit id="AffinityConflict">
-        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for this project.</source>
-        <target state="translated">MSB4213: 指定された要求の関係 {0} は、このプロジェクトに対して以前に指定された関係 {1} と競合しています。</target>
+        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</source>
+        <target state="new">MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</target>
         <note>{StrBegin="MSB4213: "}</note>
       </trans-unit>
       <trans-unit id="UnableToCreateNode">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index e682e068149..2886ef13d83 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -1790,8 +1790,8 @@
         <note>{StrBegin="MSB4209: "}</note>
       </trans-unit>
       <trans-unit id="AffinityConflict">
-        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for this project.</source>
-        <target state="translated">MSB4213: 지정한 요청 선호도 {0}이(가) 이 프로젝트에 대해 이전에 지정한 선호도 {1}과(와) 충돌합니다.</target>
+        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</source>
+        <target state="new">MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</target>
         <note>{StrBegin="MSB4213: "}</note>
       </trans-unit>
       <trans-unit id="UnableToCreateNode">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index bf49e4af42e..f679567d179 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -1790,8 +1790,8 @@
         <note>{StrBegin="MSB4209: "}</note>
       </trans-unit>
       <trans-unit id="AffinityConflict">
-        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for this project.</source>
-        <target state="translated">MSB4213: Podana koligacja żądania {0} jest w konflikcie z poprzednią koligacją {1} określoną dla tego projektu.</target>
+        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</source>
+        <target state="new">MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</target>
         <note>{StrBegin="MSB4213: "}</note>
       </trans-unit>
       <trans-unit id="UnableToCreateNode">
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 05415ba0bfa..389764664b3 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -1790,8 +1790,8 @@
         <note>{StrBegin="MSB4209: "}</note>
       </trans-unit>
       <trans-unit id="AffinityConflict">
-        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for this project.</source>
-        <target state="translated">MSB4213: A afinidade de solicitação especificada {0} está em conflito com uma afinidade anterior {1} especificada para este projeto.</target>
+        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</source>
+        <target state="new">MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</target>
         <note>{StrBegin="MSB4213: "}</note>
       </trans-unit>
       <trans-unit id="UnableToCreateNode">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 096b82fd9b8..bceaac58024 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -1790,8 +1790,8 @@
         <note>{StrBegin="MSB4209: "}</note>
       </trans-unit>
       <trans-unit id="AffinityConflict">
-        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for this project.</source>
-        <target state="translated">MSB4213: указанное сходство запроса {0} конфликтует с предыдущим сходством {1}, заданным для данного проекта.</target>
+        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</source>
+        <target state="new">MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</target>
         <note>{StrBegin="MSB4213: "}</note>
       </trans-unit>
       <trans-unit id="UnableToCreateNode">
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 07e20b02e39..cccbf728f7f 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -1790,8 +1790,8 @@
         <note>{StrBegin="MSB4209: "}</note>
       </trans-unit>
       <trans-unit id="AffinityConflict">
-        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for this project.</source>
-        <target state="translated">MSB4213: Belirtilen istek benzeşimi {0} bu proje için daha önce belirtilen {1} benzeşimi ile çakışıyor.</target>
+        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</source>
+        <target state="new">MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</target>
         <note>{StrBegin="MSB4213: "}</note>
       </trans-unit>
       <trans-unit id="UnableToCreateNode">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 5f687d7838f..973d8288178 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -1790,8 +1790,8 @@
         <note>{StrBegin="MSB4209: "}</note>
       </trans-unit>
       <trans-unit id="AffinityConflict">
-        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for this project.</source>
-        <target state="translated">MSB4213: 指定的请求关联 {0} 与先前为此项目指定的关联 {1} 冲突。</target>
+        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</source>
+        <target state="new">MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</target>
         <note>{StrBegin="MSB4213: "}</note>
       </trans-unit>
       <trans-unit id="UnableToCreateNode">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index ef4f8832a45..2a863be7542 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -1790,8 +1790,8 @@
         <note>{StrBegin="MSB4209: "}</note>
       </trans-unit>
       <trans-unit id="AffinityConflict">
-        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for this project.</source>
-        <target state="translated">MSB4213: 指定的要求親和性 {0} 與先前為這個專案指定的親和性 {1} 衝突。</target>
+        <source>MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</source>
+        <target state="new">MSB4213: The specified request affinity {0} conflicts with a previous affinity {1} specified for project {2} with global properties {3}</target>
         <note>{StrBegin="MSB4213: "}</note>
       </trans-unit>
       <trans-unit id="UnableToCreateNode">
diff --git a/src/Framework/EngineServices.cs b/src/Framework/EngineServices.cs
new file mode 100644
index 00000000000..b2b5fa9b281
--- /dev/null
+++ b/src/Framework/EngineServices.cs
@@ -0,0 +1,41 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// Exposes build engine functionality that was made available in newer versions of MSBuild.
+    /// </summary>
+    /// <remarks>
+    /// Make all members virtual but not abstract, ensuring that implementations can override them and external implementations
+    /// won't break when the class is extended with new members. This base implementation should be throwing <see cref="NotImplementedException"/>.
+    /// </remarks>
+    [Serializable]
+    public abstract class EngineServices
+    {
+        /// <summary>
+        /// Initial version with LogsMessagesOfImportance() as the only exposed member.
+        /// </summary>
+        public const int Version1 = 1;
+
+        /// <summary>
+        /// An explicit version of this class. Must be incremented whenever new members are added. Derived classes should override
+        /// the property to return the version actually being implemented.
+        /// </summary>
+        public virtual int Version => Version1;
+
+        /// <summary>
+        /// Returns <see langword="true"/> if the given message importance is not guaranteed to be ignored by registered loggers.
+        /// </summary>
+        /// <param name="importance">The importance to check.</param>
+        /// <returns>True if messages of the given importance should be logged, false if it's guaranteed that such messages would be ignored.</returns>
+        /// <remarks>
+        /// Example: If we know that no logger is interested in <see cref="MessageImportance.Low"/>, this method returns <see langword="true"/>
+        /// for <see cref="MessageImportance.Normal"/> and <see cref="MessageImportance.High"/>, and returns <see langword="false"/>
+        /// for <see cref="MessageImportance.Low"/>.
+        /// </remarks>
+        public virtual bool LogsMessagesOfImportance(MessageImportance importance) => throw new NotImplementedException();
+    }
+}
diff --git a/src/Framework/IBuildEngine10.cs b/src/Framework/IBuildEngine10.cs
new file mode 100644
index 00000000000..7a7805d9791
--- /dev/null
+++ b/src/Framework/IBuildEngine10.cs
@@ -0,0 +1,17 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// This interface extends <see cref="IBuildEngine9" /> to provide a reference to the <see cref="EngineServices" /> class.
+    /// Future engine API should be added to the class as opposed to introducing yet another version of the IBuildEngine interface.
+    /// </summary>
+    public interface IBuildEngine10 : IBuildEngine9
+    {
+        /// <summary>
+        /// Returns the new build engine interface.
+        /// </summary>
+        EngineServices EngineServices { get; }
+    }
+}
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index 859e78fd133..3581225789d 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -103,100 +103,100 @@ public void EvaluateConditionStop(string condition, bool result)
         /// <summary>
         /// Call this method to notify listeners of how the project data was evaluated.
         /// </summary>
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        [Event(11, Keywords = Keywords.All)]
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
+        [Event(11, Keywords = Keywords.All | Keywords.PerformanceLog)]
         public void EvaluateStart(string projectFile)
         {
             WriteEvent(11, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        [Event(12, Keywords = Keywords.All)]
-        public void EvaluatePass0Start(string projectFile)
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
+        [Event(12, Keywords = Keywords.All | Keywords.PerformanceLog)]
+        public void EvaluateStop(string projectFile)
         {
             WriteEvent(12, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(13, Keywords = Keywords.All)]
-        public void EvaluatePass0Stop(string projectFile)
+        public void EvaluatePass0Start(string projectFile)
         {
             WriteEvent(13, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(14, Keywords = Keywords.All)]
-        public void EvaluatePass1Start(string projectFile)
+        public void EvaluatePass0Stop(string projectFile)
         {
             WriteEvent(14, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(15, Keywords = Keywords.All)]
-        public void EvaluatePass1Stop(string projectFile)
+        public void EvaluatePass1Start(string projectFile)
         {
             WriteEvent(15, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(16, Keywords = Keywords.All)]
-        public void EvaluatePass2Start(string projectFile)
+        public void EvaluatePass1Stop(string projectFile)
         {
             WriteEvent(16, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(17, Keywords = Keywords.All)]
-        public void EvaluatePass2Stop(string projectFile)
+        public void EvaluatePass2Start(string projectFile)
         {
             WriteEvent(17, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(18, Keywords = Keywords.All)]
-        public void EvaluatePass3Start(string projectFile)
+        public void EvaluatePass2Stop(string projectFile)
         {
             WriteEvent(18, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(19, Keywords = Keywords.All)]
-        public void EvaluatePass3Stop(string projectFile)
+        public void EvaluatePass3Start(string projectFile)
         {
             WriteEvent(19, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(20, Keywords = Keywords.All)]
-        public void EvaluatePass4Start(string projectFile)
+        public void EvaluatePass3Stop(string projectFile)
         {
             WriteEvent(20, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(21, Keywords = Keywords.All)]
-        public void EvaluatePass4Stop(string projectFile)
+        public void EvaluatePass4Start(string projectFile)
         {
             WriteEvent(21, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(22, Keywords = Keywords.All)]
-        public void EvaluatePass5Start(string projectFile)
+        public void EvaluatePass4Stop(string projectFile)
         {
             WriteEvent(22, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(23, Keywords = Keywords.All)]
-        public void EvaluatePass5Stop(string projectFile)
+        public void EvaluatePass5Start(string projectFile)
         {
             WriteEvent(23, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(24, Keywords = Keywords.All)]
-        public void EvaluateStop(string projectFile)
+        public void EvaluatePass5Stop(string projectFile)
         {
             WriteEvent(24, projectFile);
         }
@@ -278,15 +278,15 @@ public void RarLogResultsStop()
         /// <summary>
         /// Call this method to notify listeners of profiling for the function that parses an XML document into a ProjectRootElement.
         /// </summary>
-        /// <param name="projectFileName">Relevant information about where in the run of the progam it is.</param>
-        [Event(33, Keywords = Keywords.All | Keywords.PerformanceLog)]
+        /// <param name="projectFileName">Filename of the project being evaluated.</param>
+        [Event(33, Keywords = Keywords.All)]
         public void ParseStart(string projectFileName)
         {
             WriteEvent(33, projectFileName);
         }
 
-        /// <param name="projectFileName">Relevant information about where in the run of the progam it is.</param>
-        [Event(34, Keywords = Keywords.All | Keywords.PerformanceLog)]
+        /// <param name="projectFileName">Filename of the project being evaluated.</param>
+        [Event(34, Keywords = Keywords.All)]
         public void ParseStop(string projectFileName)
         {
             WriteEvent(34, projectFileName);
@@ -429,6 +429,31 @@ public void TargetUpToDateStop(int result)
         {
             WriteEvent(57, result);
         }
+        
+        [Event(58, Keywords = Keywords.All)]
+        public void CopyUpToDateStart(string path)
+        {
+            WriteEvent(58, path);
+        }
+
+        [Event(59, Keywords = Keywords.All)]
+        public void CopyUpToDateStop(string path, bool wasUpToDate)
+        {
+            WriteEvent(59, path, wasUpToDate);
+        }
+
+        [Event(60, Keywords = Keywords.All)]
+        public void WriteLinesToFileUpToDateStart()
+        {
+            WriteEvent(60);
+        }
+
+        [Event(61, Keywords = Keywords.All)]
+        public void WriteLinesToFileUpToDateStop(string fileItemSpec, bool wasUpToDate)
+        {
+            WriteEvent(61, fileItemSpec, wasUpToDate);
+        }
+
         #endregion
     }
 }
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index b3111ac86db..c9dbd905e72 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -19,6 +19,7 @@
 using Shouldly;
 using System.IO.Compression;
 using System.Reflection;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -2274,6 +2275,67 @@ public void BuildSlnOutOfProc()
             output.ShouldContain(testMessage);
         }
 
+        /// <summary>
+        /// Helper task used by <see cref="EndToEndMinimumMessageImportance"/> to verify <see cref="TaskLoggingHelper.LogsMessagesOfImportance"/>.
+        /// </summary>
+        public class MessageImportanceCheckingTask : Task
+        {
+            public int ExpectedMinimumMessageImportance { get; set; }
+
+            public override bool Execute()
+            {
+                bool shouldLogHigh = Log.LogsMessagesOfImportance(MessageImportance.High);
+                bool shouldLogNormal = Log.LogsMessagesOfImportance(MessageImportance.Normal);
+                bool shouldLogLow = Log.LogsMessagesOfImportance(MessageImportance.Low);
+                return (MessageImportance)ExpectedMinimumMessageImportance switch
+                {
+                    MessageImportance.High - 1 => !shouldLogHigh && !shouldLogNormal && !shouldLogLow,
+                    MessageImportance.High => shouldLogHigh && !shouldLogNormal && !shouldLogLow,
+                    MessageImportance.Normal => shouldLogHigh && shouldLogNormal && !shouldLogLow,
+                    MessageImportance.Low => shouldLogHigh && shouldLogNormal && shouldLogLow,
+                    _ => false
+                };
+            }
+        }
+
+        [Theory]
+        [InlineData("/v:diagnostic", MessageImportance.Low)]
+        [InlineData("/v:detailed", MessageImportance.Low)]
+        [InlineData("/v:normal", MessageImportance.Normal)]
+        [InlineData("/v:minimal", MessageImportance.High)]
+        [InlineData("/v:quiet", MessageImportance.High - 1)]
+        [InlineData("/v:diagnostic /bl", MessageImportance.Low)]
+        [InlineData("/v:detailed /bl", MessageImportance.Low)]
+        [InlineData("/v:normal /bl", MessageImportance.Low)] // v:normal but with binary logger so everything must be logged
+        [InlineData("/v:minimal /bl", MessageImportance.Low)] // v:minimal but with binary logger so everything must be logged
+        [InlineData("/v:quiet /bl", MessageImportance.Low)] // v:quiet but with binary logger so everything must be logged
+        public void EndToEndMinimumMessageImportance(string arguments, MessageImportance expectedMinimumMessageImportance)
+        {
+            using TestEnvironment testEnvironment = UnitTests.TestEnvironment.Create();
+
+            string projectContents = ObjectModelHelpers.CleanupFileContents(@"<Project>
+
+  <UsingTask TaskName=""" + typeof(MessageImportanceCheckingTask).FullName + @""" AssemblyFile=""" + Assembly.GetExecutingAssembly().Location + @"""/>
+
+  <Target Name=""CheckMessageImportance"">
+    <MessageImportanceCheckingTask ExpectedMinimumMessageImportance=""" + (int)expectedMinimumMessageImportance + @""" />
+  </Target>
+
+</Project>");
+
+            TransientTestProjectWithFiles testProject = testEnvironment.CreateTestProjectWithFiles(projectContents);
+
+            // Build in-proc.
+            RunnerUtilities.ExecMSBuild($"{arguments} \"{testProject.ProjectFile}\"", out bool success, _output);
+            success.ShouldBeTrue();
+
+            // Build out-of-proc to exercise both logging code paths.
+            testEnvironment.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
+            testEnvironment.SetEnvironmentVariable("MSBUILDDISABLENODEREUSE", "1");
+            RunnerUtilities.ExecMSBuild($"{arguments} \"{testProject.ProjectFile}\"", out success, _output);
+            success.ShouldBeTrue();
+        }
+
 #if FEATURE_ASSEMBLYLOADCONTEXT
         /// <summary>
         /// Ensure that tasks get loaded into their own <see cref="System.Runtime.Loader.AssemblyLoadContext"/>.
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 6f5c50b7343..e999b30afc7 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -1552,6 +1552,18 @@ elementFormDefault="qualified">
     <xs:element name="GenerateSerializationAssemblies" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="HostInBrowser" type="msb:boolean" substitutionGroup="msb:Property"/>
     <xs:element name="IgnoreImportLibrary" type="msb:boolean" substitutionGroup="msb:Property"/>
+    <xs:element name="ImplicitUsings" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="ImplicitUsings" _locComment="" -->Enable implicit global usings for the C# project. Possible values are enable, true, and disable.</xs:documentation>
+      </xs:annotation>
+      <xs:simpleType>
+        <xs:restriction base="xs:string">
+          <xs:enumeration value="enable" />
+          <xs:enumeration value="true" />
+          <xs:enumeration value="disable" />
+        </xs:restriction>
+      </xs:simpleType>
+    </xs:element>
     <xs:element name="Install" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="InstallFrom" type="msb:StringPropertyType" substitutionGroup="msb:Property">
         <xs:annotation>
@@ -5761,4 +5773,39 @@ elementFormDefault="qualified">
         </xs:complexType>
     </xs:element>
 
+    <xs:element name="Using" substitutionGroup="msb:Item">
+    <xs:annotation>
+      <xs:documentation>
+        <!-- _locID_text="Using" _locComment="" -->A C# global using to add to the project.
+      </xs:documentation>
+    </xs:annotation>
+    <xs:complexType>
+      <xs:complexContent>
+        <xs:extension base="msb:SimpleItemType">
+          <xs:attribute name="Include" type="xs:string">
+            <xs:annotation>
+              <xs:documentation>
+                <!-- _locID_text="Using_Include" _locComment="" -->The namespace or type identifier to add, e.g. Microsoft.AspNetCore
+              </xs:documentation>
+            </xs:annotation>
+          </xs:attribute>
+          <xs:attribute name="Alias" type="xs:string" use="optional">
+            <xs:annotation>
+              <xs:documentation>
+                <!-- _locID_text="Using_Alias" _locComment="" -->Optional alias for the namespace or type.
+              </xs:documentation>
+            </xs:annotation>
+          </xs:attribute>
+          <xs:attribute name="Static" type="msb:boolean" use="optional">
+            <xs:annotation>
+              <xs:documentation>
+                <!-- _locID_text="Using_Static" _locComment="" -->Determines whether the identifier should be registered as a static import.
+              </xs:documentation>
+            </xs:annotation>
+          </xs:attribute>
+        </xs:extension>
+      </xs:complexContent>
+    </xs:complexType>
+  </xs:element>
+
 </xs:schema>
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index c0ca960bb76..9ee7405d822 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -33,7 +33,7 @@ internal class OutOfProcTaskHostNode :
 #if CLR2COMPATIBILITY
         IBuildEngine3
 #else
-        IBuildEngine9
+        IBuildEngine10
 #endif
     {
         /// <summary>
@@ -492,6 +492,22 @@ public void ReleaseCores(int coresToRelease)
         }
 
         #endregion
+
+        #region IBuildEngine10 Members
+
+        [Serializable]
+        private sealed class EngineServicesImpl : EngineServices
+        {
+            /// <summary>
+            /// No logging verbosity optimization in OOP nodes.
+            /// </summary>
+            public override bool LogsMessagesOfImportance(MessageImportance importance) => true;
+        }
+
+        public EngineServices EngineServices { get; } = new EngineServicesImpl();
+
+        #endregion
+
 #endif
 
         #region INodePacketFactory Members
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index b34392b1273..5769d82fa59 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -494,10 +494,10 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
                         ErrorsOnly – zobrazí jenom chyby.
                         WarningsOnly – zobrazí jenom upozornění.
                         NoItemAndPropertyList – nezobrazí na začátku sestavení každého
-                            projektu seznamy položek a vlastností.    
-                        ShowCommandLine – zobrazí zprávy TaskCommandLineEvent.  
+                            projektu seznamy položek a vlastností.
+                        ShowCommandLine – zobrazí zprávy TaskCommandLineEvent.
                         ShowTimestamp – před každou zprávou zobrazí
-                            časové razítko.                                           
+                            časové razítko.
                         ShowEventId – zobrazí ID události pro spuštěné a dokončené
                             události a zprávy.
                         ForceNoAlign – nenastavuje text podle velikosti vyrovnávací
@@ -634,7 +634,7 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
                      Setting this also turns on isolated builds (-isolate).
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:&lt;souborMezipaměti&gt;...
+        <target state="translated">  -outputResultsCache:[souborMezipaměti]...
                      Výstupní soubor mezipaměti, do něhož bude MSBuild
                      zapisovat obsah svých mezipamětí výsledků sestavení.
                      Nastavením této možnosti zapnete také izolované buildy (-isolate).
@@ -794,7 +794,7 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
                      template and append the node id to this fileName to
                      create a log file for each node.
     </source>
-        <target state="translated">  -distributedFileLogger                                                       
+        <target state="translated">  -distributedFileLogger
                      Uloží výstup sestavení do více souborů protokolu, po jednom
                      pro každý uzel nástroje MSBuild. Tyto soubory jsou na počátku
                      umístěny v aktuálním adresáři. Standardně mají tyto soubory
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 140c72a56e9..9ccad6d1801 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -505,7 +505,7 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
                             bei der Mehrprozessorprotokollierung im Modus mit nur einem Prozessor.
                         EnableMPLogging: Aktiviert das Format der
                             Mehrprozessorprotokollierung auch bei der Ausführung
-                            im Modus mit nur einem Prozessor. Dieses Protokollierungsformat ist standardmäßig aktiviert.  
+                            im Modus mit nur einem Prozessor. Dieses Protokollierungsformat ist standardmäßig aktiviert. 
                         ForceConsoleColor: Verwendet selbst dann
                             ANSI-Konsolenfarben, wenn
                             die Konsole dies nicht unterstützt.
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 86f63c97eb7..ecd04ae29ab 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -844,13 +844,12 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
          Paramètres supplémentaires pour les journaliseurs de fichiers.
          La présence de ce commutateur implique l'utilisation du
          commutateur -fileLogger[n] correspondant.
-         S'il est spécifié, "n" doit être un chiffre entre 1 et 9.
+         S'il est spécifié, "n" doit être un chiffre entre 1 et 9.
          -fileLoggerParameters est également utilisé par tous les
-         journaliseurs vers des fichiers. Consultez la description
-         de -distributedFileLogger.
-         (Forme abrégée : -flp[n])
+         journaliseurs vers des fichiers. Consultez la description de -distributedFileLogger.
+         (Forme abrégée : -flp[n])
          Les mêmes paramètres que ceux listés pour le journaliseur de la
-         console sont disponibles. Paramètres supplémentaires disponibles :
+         console sont disponibles. Paramètres supplémentaires disponibles :
             LogFile--Chemin du fichier journal dans lequel
                 le journal de génération est écrit.
             Append--Détermine si le journal de génération est ajouté
@@ -862,7 +861,7 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
             Encoding--Spécifie l'encodage du fichier,
                 par exemple, UTF-8, Unicode ou ASCII
          Le niveau de détail par défaut est Detailed.
-         Exemples :
+         Exemples :
            -fileLoggerParameters:LogFile=MyLog.log;Append;
                    Verbosity=diagnostic;Encoding=UTF-8
 
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 7dd1902d871..c37e60c4dc4 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -315,7 +315,7 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
         <target state="translated">  @&lt;file&gt;            Inserisce le impostazioni della riga di comando da un file di testo. Per specificare
                      più file di risposta, specificare ciascun file
                      separatamente.
-                     
+
                      Qualsiasi file di risposta denominato "msbuild.rsp" viene usato
                      automaticamente dai percorsi seguenti: 
                      (1) la directory di msbuild.exe
@@ -815,6 +815,7 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
                      file viene assegnato il nome "MSBuild&lt;idnodo&gt;.log". Il
                      percorso dei file e altri parametri di fileLogger possono
                      essere specificati aggiungendo l'opzione
+
                      "-fileLoggerParameters".
                      Se il nome di un file di log viene impostato con l'opzione
                      fileLoggerParameters, il logger distribuito userà il nome
@@ -1685,7 +1686,8 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
                      file is '.md', the result is generated in markdown
                      format. Otherwise, a tab separated file is produced.
     </source>
-        <target state="translated">  -profileEvaluation:&lt;file&gt;                     Esegue la profilatura della valutazione di MSBuild e scrive
+        <target state="translated">  -profileEvaluation:&lt;file&gt;
+Esegue la profilatura della valutazione di MSBuild e scrive
                      il risultato nel file specificato. Se l'estensione del file
                      specificato è '.md', il risultato viene generato in formato
                      Markdown. In caso contrario, viene prodotto un file
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index d0e360c5c80..548f0673c44 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -412,7 +412,7 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
                         [&lt;klasa rejestratora&gt;,]&lt;zestaw rejestratora&gt;
                         [;&lt;parametry rejestratora&gt;]
                      Składnia elementu &lt;klasa rejestratora&gt;:
-                        &lt;częściowa lub pełna przestrzeń nazw&gt;.]
+                        [&lt;częściowa lub pełna przestrzeń nazw&gt;.]
                         &lt;nazwa klasy rejestratora&gt;
                      Składnia elementu &lt;zestaw rejestratora&gt;:
                         {&lt;nazwa zestawu&gt;[,&lt;strong name&gt;] | &lt;plik zestawu&gt;}
@@ -807,6 +807,7 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
                      Domyślnie pliki mają nazwę
                      „MSBuild&lt;identyfikator węzła&gt;.log”. Lokalizację plików
                      i inne parametry rejestratora plików można określić
+
                      przez dodanie przełącznika „-fileLoggerParameters”.
 
                      Jeśli nazwa pliku zostanie ustawiona za pomocą przełącznika
@@ -1641,7 +1642,7 @@ dzienników                     tekstowych i wykorzystać w innych narzędziach
                      przywrócenia pakietów przed ich skompilowaniem. Podanie parametru 
                      -restore jest równoznaczne z podaniem parametru -restore:True.
                      Za pomocą tego parametru można przesłonić wartość pochodzącą
-                     z pliku odpowiedzi.                     
+                     z pliku odpowiedzi.
                      (Krótka forma: -r)
     </target>
         <note>
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index fc828bbf856..e41b484c1a6 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -1623,9 +1623,12 @@ isoladamente.
     </source>
         <target state="translated">  -restore[:True|False]
                      Executa um destino chamado Restore antes de compilar
-                     outros destinos e garante o build desses                                                                          destinos usando uma lógica de build restaurada.                                                             Isso é útil quando sua árvore de
-projeto precisar                                                                       que pacotes sejam restaurados antes de serem compilados.                          Especificar -restore é o mesmo que
-                     especificar                            -restore:True. Use o parâmetro para
+                     outros destinos e garante o build desses
+                     destinos usando uma lógica de build restaurada.
+                     Isso é útil quando sua árvore de  projeto precisar
+                     que pacotes sejam restaurados antes de serem compilados.
+                     Especificar -restore é o mesmo que
+                     -restore:True. Use o parâmetro para
                      substituir um valor originado de um arquivo de resposta.
                      (Forma abreviada: -r)
     </target>
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 58372693c4e..4ef8b52a05a 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -366,7 +366,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                        -property:WarningLevel=2;OutDir=bin\Debug\
 </source>
         <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  Установите или переопределите свойства уровня проекта. &lt;n&gt; является
-                     именем свойства, а &lt;v&gt; —  его значением. Используйте 
+                     именем свойства, а &lt;v&gt; —  его значением. Используйте
                      точку с запятой или запятую, чтобы разделить несколько свойств, или
                      укажите каждое свойство отдельно. (Краткая форма: -p)
                      Пример:
@@ -572,12 +572,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                      MSBuild will use up to the number of processors on the
                      computer. (Short form: -m[:n])
       </source>
-        <target state="translated">  -maxCpuCount[:n]   Указывает максимальное количество
-                     параллельных процессов сборки. Если ключ
-                     не используется, применяется значение по умолчанию 1.
-                     Если ключ используется без значения, MSBuild
-                     будет использовать то количество процессоров,
-                     которое установлено на компьютере. (Краткая форма: -m[:n])
+        <target state="translated">  -maxCpuCount[:n]   Указывает максимальное количество параллельных
+                     процессов сборки.  Если ключ не используется, применяется значение
+                     по умолчанию 1.  Если ключ используется без значения,
+                     MSBuild будет использовать то количество процессоров, которое установлено на
+                     компьютере. (Краткая форма: -m[:n])
       </target>
         <note>
           LOCALIZATION: "maxCpuCount" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index a9f98271477..8bed4f53eff 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -506,7 +506,7 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
                             devre dışı bırak.
                         EnableMPLogging--Çok işlemci olmayan modda çalışırken 
                             bile çok işlemcili günlük stilini etkinleştir. Bu 
-                            günlük stili varsayılan olarak açıktır.  
+                            günlük stili varsayılan olarak açıktır.
                         ForceConsoleColor--Konsol desteklemese bile ANSI
                             konsol renklerini kullan
                                                 Verbosity--Bu günlükçü için /verbosity ayarını
@@ -789,7 +789,7 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
                      template and append the node id to this fileName to
                      create a log file for each node.
     </source>
-        <target state="translated">  -distributedFileLogger                                                       
+        <target state="translated">  -distributedFileLogger
                      Derleme çıkışını, her MSBuild düğümü için bir günlük
                      dosyası olmak üzere birden çok günlük dosyasına kaydeder. Bu
                      dosyaların ilk konumu geçerli dizindir. Dosyaların 
@@ -1631,7 +1631,7 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
                      Bu, proje ağacınızın paketlerin oluşturulabilmesi için
                      önce geri yüklenmesini gerektirdiği durumlarda yararlıdır.
                      -restore değerinin belirtilmesi, -restore:True değerinin
-                     belirtilmesiyle aynıdır.  Yanıt dosyasından gelen bir değeri
+                     belirtilmesiyle aynıdır. Yanıt dosyasından gelen bir değeri
                      geçersiz kılmak için parametreyi kullanın.
                      (Kısa biçim: -r)
     </target>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 64d2ad270db..011389fa1a6 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -800,7 +800,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
            开关设置的，分布式记录器将使用 fileName 作为
            模板并将节点 ID 附加到此 fileName 
            以便为每个节点创建一个日志文件。
-  </target>
+    </target>
         <note>
       LOCALIZATION: The following should not be localized:
       1) "MSBuild", "MSBuild.exe" and "MSBuild.rsp"
@@ -868,7 +868,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
             -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
             -flp1:warningsonly;logfile=msbuild.wrn 
             -flp2:errorsonly;logfile=msbuild.err
-  </target>
+    </target>
         <note>
       LOCALIZATION: The following should not be localized:
       1) "MSBuild", "MSBuild.exe" and "MSBuild.rsp"
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 09a0f38eaf3..3a62d532f86 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -3133,7 +3133,9 @@ private static void ProcessFileLoggers(string[][] groupedFileLoggerParameters, L
                 LoggerVerbosity defaultFileLoggerVerbosity = LoggerVerbosity.Detailed;
                 fileLogger.Verbosity = defaultFileLoggerVerbosity;
 
-                if (cpuCount == 1)
+                // Check to see if there is a possibility we will be logging from an out-of-proc node.
+                // If so (we're multi-proc or the in-proc node is disabled), we register a distributed logger.
+                if (cpuCount == 1 && Environment.GetEnvironmentVariable("MSBUILDNOINPROCNODE") != "1")
                 {
                     // We've decided to use the MP logger even in single proc mode.
                     // Switch it on here, rather than in the logger, so that other hosts that use
@@ -3197,7 +3199,9 @@ List<ILogger> loggers
                     consoleParameters = AggregateParameters(consoleParameters, consoleLoggerParameters);
                 }
 
-                if (cpuCount == 1)
+                // Check to see if there is a possibility we will be logging from an out-of-proc node.
+                // If so (we're multi-proc or the in-proc node is disabled), we register a distributed logger.
+                if (cpuCount == 1 && Environment.GetEnvironmentVariable("MSBUILDNOINPROCNODE") != "1")
                 {
                     // We've decided to use the MP logger even in single proc mode.
                     // Switch it on here, rather than in the logger, so that other hosts that use
diff --git a/src/Samples/ProjectCachePlugin/AssemblyMockCache.cs b/src/Samples/ProjectCachePlugin/AssemblyMockCache.cs
index 3b26b82d942..7f049a6c699 100644
--- a/src/Samples/ProjectCachePlugin/AssemblyMockCache.cs
+++ b/src/Samples/ProjectCachePlugin/AssemblyMockCache.cs
@@ -2,11 +2,13 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Diagnostics;
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
+using Shouldly;
 
 namespace MockCacheFromAssembly
 {
@@ -33,6 +35,8 @@ public override Task<CacheResult> GetCacheResultAsync(
         {
             logger.LogMessage($"{nameof(AssemblyMockCache)}: GetCacheResultAsync for {buildRequest.ProjectFullPath}", MessageImportance.High);
 
+            buildRequest.ProjectInstance.ShouldNotBeNull("The cache plugin expects evaluated projects.");
+
             ErrorFrom(nameof(GetCacheResultAsync), logger);
 
             return Task.FromResult(CacheResult.IndicateNonCacheHit(CacheResultType.CacheNotApplicable));
diff --git a/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj b/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
index 4f7a5e8d6ad..f96f6412f45 100644
--- a/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
+++ b/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
@@ -12,4 +12,7 @@
     <ProjectReference Include="..\..\Build\Microsoft.Build.csproj" />
     <ProjectReference Include="..\..\Framework\Microsoft.Build.Framework.csproj" />
   </ItemGroup>
+  <ItemGroup>
+    <PackageReference Include="Shouldly" Version="3.0.0" />
+  </ItemGroup>
 </Project>
diff --git a/src/Shared/AssemblyNameExtension.cs b/src/Shared/AssemblyNameExtension.cs
index 8c62a178e05..99db41274e3 100644
--- a/src/Shared/AssemblyNameExtension.cs
+++ b/src/Shared/AssemblyNameExtension.cs
@@ -148,7 +148,6 @@ private AssemblyNameExtension(SerializationInfo info, StreamingContext context)
                 var hashAlgorithm = (System.Configuration.Assemblies.AssemblyHashAlgorithm) info.GetInt32("hashAlg");
                 var versionCompatibility = (AssemblyVersionCompatibility) info.GetInt32("verCompat");
                 var codeBase = info.GetString("codebase");
-                var keyPair = (StrongNameKeyPair) info.GetValue("keypair", typeof(StrongNameKeyPair));
 
                 asAssemblyName = new AssemblyName
                 {
@@ -160,7 +159,6 @@ private AssemblyNameExtension(SerializationInfo info, StreamingContext context)
                     HashAlgorithm = hashAlgorithm,
                     VersionCompatibility = versionCompatibility,
                     CodeBase = codeBase,
-                    KeyPair = keyPair
                 };
 
                 asAssemblyName.SetPublicKey(publicKey);
@@ -635,7 +633,7 @@ private static int CompareBaseNamesStringWise(string asString1, string asString2
         /// </summary>
         internal AssemblyNameExtension Clone()
         {
-            AssemblyNameExtension newExtension = new AssemblyNameExtension();
+            AssemblyNameExtension newExtension = new();
 
             if (asAssemblyName != null)
             {
@@ -1001,7 +999,6 @@ public void GetObjectData(SerializationInfo info, StreamingContext context)
                 info.AddValue("hashAlg", asAssemblyName.HashAlgorithm);
                 info.AddValue("verCompat", asAssemblyName.VersionCompatibility);
                 info.AddValue("codebase", asAssemblyName.CodeBase);
-                info.AddValue("keypair", asAssemblyName.KeyPair);
             }
 
             info.AddValue("asStr", asString);
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index 6f739d163b8..f35dc2f8a6e 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -220,7 +220,7 @@ private static BuildEnvironment TryFromMSBuildExeUnderVisualStudio(string msbuil
                 string visualStudioRoot = GetVsRootFromMSBuildAssembly(msbuildExe);
                 return new BuildEnvironment(
                         BuildEnvironmentMode.VisualStudio,
-                        msbuildExe,
+                        GetMSBuildExeFromVsRoot(visualStudioRoot),
                         runningTests: s_runningTests(),
                         runningInVisualStudio: false,
                         visualStudioPath: visualStudioRoot);
diff --git a/src/Shared/ErrorUtilities.cs b/src/Shared/ErrorUtilities.cs
index 2731c90b61a..9bb3502596b 100644
--- a/src/Shared/ErrorUtilities.cs
+++ b/src/Shared/ErrorUtilities.cs
@@ -47,6 +47,14 @@ public static void DebugTraceMessage(string category, string formatstring, param
 #if !BUILDINGAPPXTASKS
         #region VerifyThrow -- for internal errors
 
+        internal static void VerifyThrowInternalError(bool condition, string message, params object[] args)
+        {
+            if (s_throwExceptions && !condition)
+            {
+                throw new InternalErrorException(ResourceUtilities.FormatString(message, args));
+            }
+        }
+
         /// <summary>
         /// Throws InternalErrorException. 
         /// This is only for situations that would mean that there is a bug in MSBuild itself.
diff --git a/src/Shared/NativeMethodsShared.cs b/src/Shared/NativeMethodsShared.cs
index 4e23aae1096..09314174d36 100644
--- a/src/Shared/NativeMethodsShared.cs
+++ b/src/Shared/NativeMethodsShared.cs
@@ -632,6 +632,9 @@ internal static bool IsMaxPathLegacyWindows()
             }
         }
 
+        // CA1416 warns about code that can only run on Windows, but we verified we're running on Windows before this.
+        // This is the most reasonable way to resolve this part because other ways would require ifdef'ing on NET472.
+#pragma warning disable CA1416
         private static bool IsLongPathsEnabledRegistry()
         {
             using (RegistryKey fileSystemKey = Registry.LocalMachine.OpenSubKey(WINDOWS_FILE_SYSTEM_REGISTRY_KEY))
@@ -640,6 +643,7 @@ private static bool IsLongPathsEnabledRegistry()
                 return fileSystemKey != null && Convert.ToInt32(longPathsEnabledValue) == 1;
             }
         }
+#pragma warning restore CA1416
 
         /// <summary>
         /// Cached value for IsUnixLike (this method is called frequently during evaluation).
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index 9d9fdc1c1b4..66a202fd6b8 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -156,9 +156,9 @@ protected IBuildEngine BuildEngine
         /// </summary>
         public bool HasLoggedErrors { get; private set; }
 
-#endregion
+        #endregion
 
-#region Utility methods
+        #region Utility methods
 
         /// <summary>
         /// Extracts the message code (if any) prefixed to the given message string. Message code prefixes must match the
@@ -235,9 +235,20 @@ public virtual string GetResourceMessage(string resourceName)
             string resourceString = FormatResourceString(resourceName, null);
             return resourceString;
         }
-#endregion
+        #endregion
+
+        #region Message logging methods
 
-#region Message logging methods
+        /// <summary>
+        /// Returns true if a message of given importance should be logged because it is possible that a logger consuming it exists.
+        /// </summary>
+        /// <param name="importance">The importance to check.</param>
+        /// <returns>True if messages of the given importance should be logged, false if it's guaranteed that such messages would be ignored.</returns>
+        public bool LogsMessagesOfImportance(MessageImportance importance)
+        {
+            return BuildEngine is not IBuildEngine10 buildEngine10
+                || buildEngine10.EngineServices.LogsMessagesOfImportance(importance);
+        }
 
         /// <summary>
         /// Logs a message using the specified string.
@@ -279,6 +290,10 @@ public void LogMessage(MessageImportance importance, string message, params obje
                 ResourceUtilities.FormatString(message, messageArgs);
             }
 #endif
+            if (!LogsMessagesOfImportance(importance))
+            {
+                return;
+            }
 
             BuildMessageEventArgs e = new BuildMessageEventArgs
                 (
@@ -343,6 +358,11 @@ params object[] messageArgs
             // No lock needed, as BuildEngine methods from v4.5 onwards are thread safe.
             ErrorUtilities.VerifyThrowArgumentNull(message, nameof(message));
 
+            if (!LogsMessagesOfImportance(importance))
+            {
+                return;
+            }
+
             // If BuildEngine is null, task attempted to log before it was set on it,
             // presumably in its constructor. This is not allowed, and all
             // we can do is throw.
@@ -470,6 +490,11 @@ public void LogMessageFromResources(MessageImportance importance, string message
             // global state.
             ErrorUtilities.VerifyThrowArgumentNull(messageResourceName, nameof(messageResourceName));
 
+            if (!LogsMessagesOfImportance(importance))
+            {
+                return;
+            }
+
             LogMessage(importance, GetResourceMessage(messageResourceName), messageArgs);
 #if DEBUG
             // Assert that the message does not contain an error code.  Only errors and warnings
@@ -552,6 +577,11 @@ public void LogCommandLine(MessageImportance importance, string commandLine)
             // No lock needed, as BuildEngine methods from v4.5 onwards are thread safe.
             ErrorUtilities.VerifyThrowArgumentNull(commandLine, nameof(commandLine));
 
+            if (!LogsMessagesOfImportance(importance))
+            {
+                return;
+            }
+
             var e = new TaskCommandLineEventArgs(commandLine, TaskName, importance);
 
             // If BuildEngine is null, the task attempted to log before it was set on it,
diff --git a/src/Shared/UnitTests/TestAssemblyInfo.cs b/src/Shared/UnitTests/TestAssemblyInfo.cs
index e1e7ef66d5a..627aa0d465e 100644
--- a/src/Shared/UnitTests/TestAssemblyInfo.cs
+++ b/src/Shared/UnitTests/TestAssemblyInfo.cs
@@ -35,6 +35,8 @@ public MSBuildTestAssemblyFixture()
 
         _testEnvironment = TestEnvironment.Create();
 
+        _testEnvironment.DoNotLaunchDebugger();
+
         //  Reset the VisualStudioVersion environment variable.  This will be set if tests are run from a VS command prompt.  However,
         //  if the environment variable is set, it will interfere with tests which set the SubToolsetVersion
         //  (VerifySubToolsetVersionSetByConstructorOverridable), as the environment variable would take precedence.
diff --git a/src/StringTools/StringTools.csproj b/src/StringTools/StringTools.csproj
index e7713cb359a..fef9909ce6f 100644
--- a/src/StringTools/StringTools.csproj
+++ b/src/StringTools/StringTools.csproj
@@ -15,6 +15,7 @@
     <SemanticVersioningV1>true</SemanticVersioningV1>
 
     <AssemblyName>Microsoft.NET.StringTools</AssemblyName>
+    <PackageDescription>This package contains the $(AssemblyName) assembly which implements common string-related functionality such as weak interning.</PackageDescription>
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(TargetFramework)' == 'net35'">
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index 373805aa30f..e932aba587b 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -2493,6 +2493,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
             };
         }
 
+#pragma warning disable CA1416
         /// <summary>
         /// Registry access delegate. Given a hive and a view, return the registry base key.
         /// </summary>
@@ -2901,6 +2902,7 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
             Assert.True(false, $"New GetRegistrySubKeyDefaultValue parameters encountered, need to add unittesting support for subKey={subKey}");
             return null;
         }
+#pragma warning restore CA1416
 
         /// <summary>
         /// Delegate for System.IO.File.GetLastWriteTime
diff --git a/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs b/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
new file mode 100644
index 00000000000..91bbc2269b3
--- /dev/null
+++ b/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
@@ -0,0 +1,203 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.UnitTests;
+using Microsoft.Build.Utilities;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace Microsoft.Build.Tasks.UnitTests
+{
+    sealed public class GetCompatiblePlatform_Tests
+    {
+        private readonly ITestOutputHelper _output;
+
+        public GetCompatiblePlatform_Tests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
+        [Fact]
+        public void ResolvesViaPlatformLookupTable()
+        {
+            // PlatformLookupTable always takes priority. It is typically user-defined.
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", "x64;x86;AnyCPU");
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "win32",
+                PlatformLookupTable = "win32=x64",
+                AnnotatedProjects = new TaskItem[] { projectReference }
+            };
+
+            task.Execute().ShouldBeTrue();
+
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe("x64");
+        }
+
+        [Fact]
+        public void ResolvesViaProjectReferencesPlatformLookupTable()
+        {
+            // A ProjectReference's PlatformLookupTable takes priority over the current project's table.
+            // This allows overrides on a per-ProjectItem basis.
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", "x64;x86;AnyCPU");
+
+            // ProjectReference will be assigned x86 because its table takes priority
+            projectReference.SetMetadata("PlatformLookupTable", "win32=x86");
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "win32",
+                PlatformLookupTable = "win32=x64",
+                AnnotatedProjects = new TaskItem[] { projectReference }
+            };
+
+            task.Execute().ShouldBeTrue();
+
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe("x86");
+        }
+
+        [Fact]
+        public void ResolvesViaAnyCPUDefault()
+        {
+            // No valid mapping via the lookup table, should default to AnyCPU when the current project
+            // and ProjectReference platforms don't match.
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", "x64;AnyCPU");
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "x86",
+                PlatformLookupTable = "AnyCPU=x64", 
+                AnnotatedProjects = new TaskItem[] { projectReference }
+            };
+
+            task.Execute().ShouldBeTrue();
+
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe("AnyCPU");
+        }
+
+        [Fact]
+        public void ResolvesViaSamePlatform()
+        {
+            // No valid mapping via the lookup table. If the ProjectReference's platform
+            // matches the current project's platform, it takes priority over AnyCPU default.
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", "x86;x64;AnyCPU");
+            projectReference.SetMetadata("PlatformLookupTable", "x86=AnyCPU"); // matching platform takes priority over lookup tables
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "x86",
+                PlatformLookupTable = "x86=AnyCPU",
+                AnnotatedProjects = new TaskItem[] { projectReference }
+            };
+
+            task.Execute().ShouldBeTrue();
+
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe("x86");
+        }
+
+        [Fact]
+        public void FailsToResolve()
+        {
+            // No valid mapping via the lookup table, ProjectReference can't default to AnyCPU,
+            // it also can't match with current project, log a warning.
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", "x64");
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "x86",
+                PlatformLookupTable = "AnyCPU=x64",
+                AnnotatedProjects = new TaskItem[] { projectReference },
+            };
+
+            task.Execute().ShouldBeTrue();
+            // When the task logs a warning, it does not set NearestPlatform
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe(string.Empty);
+            ((MockEngine)task.BuildEngine).AssertLogContains("MSB3981");
+        }
+
+        [Fact]
+        public void WarnsWhenProjectReferenceHasNoPlatformOptions()
+        {
+            // Task should log a warning when a ProjectReference has no options to build as.
+            // It will continue and have no NearestPlatform metadata.
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", string.Empty);
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "x86",
+                PlatformLookupTable = "AnyCPU=x64",
+                AnnotatedProjects = new TaskItem[] { projectReference },
+            };
+
+            task.Execute().ShouldBeTrue();
+            // When the task logs a warning, it does not set NearestPlatform
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe(string.Empty);
+            ((MockEngine)task.BuildEngine).AssertLogContains("MSB3982");
+        }
+
+        /// <summary>
+        /// Invalid format on PlatformLookupTable results in an exception being thrown.
+        /// </summary>
+        [Fact]
+        public void WarnsOnInvalidFormatLookupTable()
+        {
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", "x64");
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "AnyCPU",
+                PlatformLookupTable = "AnyCPU=;A=B", // invalid format
+                AnnotatedProjects = new TaskItem[] { projectReference },
+            };
+
+            task.Execute().ShouldBeTrue();
+            // When the platformlookuptable is in an invalid format, it is discarded.
+            // There shouldn't have been a translation found from AnyCPU to anything.
+            // Meaning the projectreference would not have NearestPlatform set.
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe(string.Empty);
+            ((MockEngine)task.BuildEngine).AssertLogContains("MSB3983");
+        }
+
+        /// <summary>
+        /// Invalid format on PlatformLookupTable from the projectreference results in an exception being thrown.
+        /// </summary>
+        [Fact]
+        public void WarnsOnInvalidFormatProjectReferenceLookupTable()
+        {
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", "x64;x86");
+            projectReference.SetMetadata("PlatformLookupTable", "x86=;b=d");
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "AnyCPU",
+                PlatformLookupTable = "AnyCPU=x86;A=B", // invalid format
+                AnnotatedProjects = new TaskItem[] { projectReference },
+            };
+
+            task.Execute().ShouldBeTrue();
+
+            // A ProjectReference PlatformLookupTable should take priority, but is thrown away when
+            // it has an invalid format. The current project's PLT should be the next priority.
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe("x86");
+            ((MockEngine)task.BuildEngine).AssertLogContains("MSB3983");
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/AssemblyInformation.cs b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
index 4af1396f59e..9a6e36c008e 100644
--- a/src/Tasks/AssemblyDependency/AssemblyInformation.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
@@ -405,6 +405,11 @@ private void CorePopulateMetadata()
                         }
 
                         var container = metadataReader.GetMemberReference((MemberReferenceHandle) ctorHandle).Parent;
+                        if (container.Kind != HandleKind.TypeReference)
+                        {
+                            continue;
+                        }
+
                         var name = metadataReader.GetTypeReference((TypeReferenceHandle) container).Name;
                         if (!string.Equals(metadataReader.GetString(name), "TargetFrameworkAttribute"))
                         {
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index ace96711c25..7ed21691a98 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -1247,7 +1247,8 @@ quiet at the engine level.
             }
 
 #if FEATURE_WIN32_REGISTRY
-            if (dependencyTable.Resolvers != null)
+            MessageImportance messageImportance = MessageImportance.Low;
+            if (dependencyTable.Resolvers != null && Log.LogsMessagesOfImportance(messageImportance))
             {
                 foreach (Resolver r in dependencyTable.Resolvers)
                 {
@@ -1255,7 +1256,6 @@ quiet at the engine level.
                     {
                         AssemblyFoldersEx assemblyFoldersEx = ((AssemblyFoldersExResolver)r).AssemblyFoldersExLocations;
 
-                        MessageImportance messageImportance = MessageImportance.Low;
                         if (assemblyFoldersEx != null && _showAssemblyFoldersExLocations.TryGetValue(r.SearchPath, out messageImportance))
                         {
                             Log.LogMessageFromResources(messageImportance, "ResolveAssemblyReference.AssemblyFoldersExSearchLocations", r.SearchPath);
@@ -1347,6 +1347,10 @@ private void LogReference(Reference reference, string fusionName)
         {
             // Set an importance level to be used for secondary messages.
             MessageImportance importance = ChooseReferenceLoggingImportance(reference);
+            if (!Log.LogsMessagesOfImportance(importance))
+            {
+                return;
+            }
 
             // Log the fusion name and whether this is a primary or a dependency.
             LogPrimaryOrDependency(reference, fusionName, importance);
@@ -1413,7 +1417,8 @@ private MessageImportance ChooseReferenceLoggingImportance(Reference reference)
         /// </summary>
         private void LogInputs()
         {
-            if (Traits.Instance.EscapeHatches.LogTaskInputs || Silent)
+            MessageImportance importance = MessageImportance.Low;
+            if (Traits.Instance.EscapeHatches.LogTaskInputs || Silent || !Log.LogsMessagesOfImportance(importance))
             {
                 // the inputs will be logged automatically anyway, avoid duplication in the logs
                 return;
@@ -1421,7 +1426,6 @@ private void LogInputs()
 
             string indent = Strings.FourSpaces;
             string property = Strings.LogTaskPropertyFormat;
-            MessageImportance importance = MessageImportance.Low;
 
             Log.LogMessage(importance, property, "TargetFrameworkMoniker");
             Log.LogMessage(importance, indent + _targetedFrameworkMoniker);
diff --git a/src/Tasks/CombineTargetFrameworkInfoProperties.cs b/src/Tasks/CombineTargetFrameworkInfoProperties.cs
index 612f27d3b88..bfd7caae236 100644
--- a/src/Tasks/CombineTargetFrameworkInfoProperties.cs
+++ b/src/Tasks/CombineTargetFrameworkInfoProperties.cs
@@ -2,11 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Framework;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
+using Microsoft.Build.Shared;
 using System.Xml.Linq;
 
 namespace Microsoft.Build.Tasks
@@ -26,6 +22,11 @@ public class CombineTargetFrameworkInfoProperties : TaskExtension
         /// </summary>
         public ITaskItem[] PropertiesAndValues { get; set; }
 
+        /// <summary>
+        /// Opts into or out of using the new schema with Property Name=... rather than just specifying the RootElementName.
+        /// </summary>
+        public bool UseAttributeForTargetFrameworkInfoPropertyNames { get; set; } = false;
+
         /// <summary>
         /// The generated XML representation of the properties and values.
         /// </summary>
@@ -36,9 +37,11 @@ public override bool Execute()
         {
             if (PropertiesAndValues != null)
             {
-                XElement root = new XElement(RootElementName);
+                XElement root = UseAttributeForTargetFrameworkInfoPropertyNames ?
+                    new("TargetFramework", new XAttribute("Name", EscapingUtilities.Escape(RootElementName))) :
+                    new(RootElementName);
 
-                foreach (var item in PropertiesAndValues)
+                foreach (ITaskItem item in PropertiesAndValues)
                 {
                     root.Add(new XElement(item.ItemSpec, item.GetMetadata("Value")));
                 }
diff --git a/src/Tasks/CombineXmlElements.cs b/src/Tasks/CombineXmlElements.cs
index c42aed7f1bd..214207b1b6e 100644
--- a/src/Tasks/CombineXmlElements.cs
+++ b/src/Tasks/CombineXmlElements.cs
@@ -2,11 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Framework;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using System.Xml.Linq;
 
 namespace Microsoft.Build.Tasks
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index e22b7cc2372..6c91abeaab3 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -12,6 +12,7 @@
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.Eventing;
 
 namespace Microsoft.Build.Tasks
 {
@@ -437,6 +438,7 @@ private bool CopySingleThreaded(
             {
                 bool copyComplete = false;
                 string destPath = DestinationFiles[i].ItemSpec;
+                MSBuildEventSource.Log.CopyUpToDateStart(destPath);
                 if (filesActuallyCopied.TryGetValue(destPath, out string originalSource))
                 {
                     if (String.Equals(originalSource, SourceFiles[i].ItemSpec, StringComparison.OrdinalIgnoreCase))
@@ -458,6 +460,10 @@ private bool CopySingleThreaded(
                         success = false;
                     }
                 }
+                else
+                {
+                    MSBuildEventSource.Log.CopyUpToDateStop(destPath, true);
+                }
 
                 if (copyComplete)
                 {
@@ -540,6 +546,7 @@ private bool CopyParallel(
                         string sourcePath = sourceItem.ItemSpec;
 
                         // Check if we just copied from this location to the destination, don't copy again.
+                        MSBuildEventSource.Log.CopyUpToDateStart(destItem.ItemSpec);
                         bool copyComplete = partitionIndex > 0 &&
                                             String.Equals(
                                                 sourcePath,
@@ -561,6 +568,10 @@ private bool CopyParallel(
                                 success = false;
                             }
                         }
+                        else
+                        {
+                            MSBuildEventSource.Log.CopyUpToDateStop(destItem.ItemSpec, true);
+                        }
 
                         if (copyComplete)
                         {
@@ -716,6 +727,7 @@ private bool DoCopyIfNecessary(FileState sourceFileState, FileState destinationF
                         "SkipUnchangedFiles",
                         "true"
                     );
+                    MSBuildEventSource.Log.CopyUpToDateStop(destinationFileState.Name, true);
                 }
                 // We only do the cheap check for identicalness here, we try the more expensive check
                 // of comparing the fullpaths of source and destination to see if they are identical,
@@ -725,8 +737,13 @@ private bool DoCopyIfNecessary(FileState sourceFileState, FileState destinationF
                              destinationFileState.Name,
                              StringComparison.OrdinalIgnoreCase))
                 {
+                    MSBuildEventSource.Log.CopyUpToDateStop(destinationFileState.Name, false);
                     success = DoCopyWithRetries(sourceFileState, destinationFileState, copyFile);
                 }
+                else
+                {
+                    MSBuildEventSource.Log.CopyUpToDateStop(destinationFileState.Name, true);
+                }
             }
             catch (OperationCanceledException)
             {
diff --git a/src/Tasks/FileIO/WriteLinesToFile.cs b/src/Tasks/FileIO/WriteLinesToFile.cs
index c4fdfbb1a50..776e48bbddb 100644
--- a/src/Tasks/FileIO/WriteLinesToFile.cs
+++ b/src/Tasks/FileIO/WriteLinesToFile.cs
@@ -1,6 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using System;
@@ -87,27 +88,33 @@ public override bool Execute()
                     {
                         Directory.CreateDirectory(directoryPath);
                         string contentsAsString = buffer.ToString();
-                        try
+
+                        // When WriteOnlyWhenDifferent is set, read the file and if they're the same return.
+                        if (WriteOnlyWhenDifferent)
                         {
-                            // When WriteOnlyWhenDifferent is set, read the file and if they're the same return.
-                            if (WriteOnlyWhenDifferent && FileUtilities.FileExistsNoThrow(File.ItemSpec))
+                            MSBuildEventSource.Log.WriteLinesToFileUpToDateStart();
+                            try
                             {
-                                string existingContents = System.IO.File.ReadAllText(File.ItemSpec);
-                                if (existingContents.Length == buffer.Length)
+                                if (FileUtilities.FileExistsNoThrow(File.ItemSpec))
                                 {
-                                    if (existingContents.Equals(contentsAsString))
+                                    string existingContents = System.IO.File.ReadAllText(File.ItemSpec);
+                                    if (existingContents.Length == buffer.Length)
                                     {
-                                        Log.LogMessageFromResources(MessageImportance.Low, "WriteLinesToFile.SkippingUnchangedFile", File.ItemSpec);
-                                        return true;
+                                        if (existingContents.Equals(contentsAsString))
+                                        {
+                                            Log.LogMessageFromResources(MessageImportance.Low, "WriteLinesToFile.SkippingUnchangedFile", File.ItemSpec);
+                                            MSBuildEventSource.Log.WriteLinesToFileUpToDateStop(File.ItemSpec, true);
+                                            return true;
+                                        }
                                     }
                                 }
                             }
+                            catch (IOException)
+                            {
+                                Log.LogMessageFromResources(MessageImportance.Low, "WriteLinesToFile.ErrorReadingFile", File.ItemSpec);
+                            }
+                            MSBuildEventSource.Log.WriteLinesToFileUpToDateStop(File.ItemSpec, false);
                         }
-                        catch (IOException)
-                        {
-                            Log.LogMessageFromResources(MessageImportance.Low, "WriteLinesToFile.ErrorReadingFile", File.ItemSpec);
-                        }
-
 
                         System.IO.File.WriteAllText(File.ItemSpec, contentsAsString, encoding);
                     }
diff --git a/src/Tasks/GetCompatiblePlatform.cs b/src/Tasks/GetCompatiblePlatform.cs
new file mode 100644
index 00000000000..c86c88199d7
--- /dev/null
+++ b/src/Tasks/GetCompatiblePlatform.cs
@@ -0,0 +1,154 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
+using System;
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Tasks
+{
+    /// <summary>
+    /// Performs SetPlatform negotiation for all project references when opted
+    /// in via the EnableDynamicPlatformResolution property.
+    /// 
+    /// See ProjectReference-Protocol.md for details.
+    /// </summary>
+    public class GetCompatiblePlatform : TaskExtension
+    {
+        /// <summary>
+        /// All ProjectReference items.
+        /// </summary>
+        [Required]
+        public ITaskItem[] AnnotatedProjects { get; set; }
+
+        /// <summary>
+        /// The platform the current project is building as. 
+        /// </summary>
+        [Required]
+        public string CurrentProjectPlatform { get; set; }
+
+        /// <summary>
+        /// Optional parameter that defines mappings from current project platforms
+        /// to what the ProjectReference should build as.
+        /// Win32=x86, for example.
+        /// </summary>
+        public string PlatformLookupTable { get; set; }
+
+        /// <summary>
+        /// The resulting items with NearestPlatform metadata set.
+        /// </summary>
+        [Output]
+        public ITaskItem[]? AssignedProjectsWithPlatform { get; set; }
+
+        public GetCompatiblePlatform()
+        {
+            AnnotatedProjects = new ITaskItem[0];
+            CurrentProjectPlatform = string.Empty;
+            PlatformLookupTable = string.Empty;
+        }
+
+        public override bool Execute()
+        {
+            Dictionary<string, string>? currentProjectLookupTable = ExtractLookupTable(PlatformLookupTable);
+
+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];
+            for (int i = 0; i < AnnotatedProjects.Length; i++)
+            {
+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);
+
+                string projectReferencePlatformMetadata = AssignedProjectsWithPlatform[i].GetMetadata("Platforms");
+
+                if (string.IsNullOrEmpty(projectReferencePlatformMetadata))
+                {
+                    Log.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoPlatformsListed", AssignedProjectsWithPlatform[i].ItemSpec);
+                    continue;
+                }
+
+                string projectReferenceLookupTableMetadata = AssignedProjectsWithPlatform[i].GetMetadata("PlatformLookupTable");
+                // Pull platformlookuptable metadata from the referenced project. This allows custom
+                // mappings on a per-ProjectReference basis.
+                Dictionary<string, string>? projectReferenceLookupTable = ExtractLookupTable(projectReferenceLookupTableMetadata);
+
+                HashSet<string> projectReferencePlatforms = new HashSet<string>();
+                foreach (string s in projectReferencePlatformMetadata.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
+                {
+                    projectReferencePlatforms.Add(s);
+                }
+
+                string buildProjectReferenceAs = string.Empty;
+
+                // Prefer matching platforms
+                if (projectReferencePlatforms.Contains(CurrentProjectPlatform))
+                {
+                    buildProjectReferenceAs = CurrentProjectPlatform;
+                    Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.SamePlatform");
+                }
+                // Prioritize PlatformLookupTable **metadata** attached to the ProjectReference item
+                // before the current project's table. We do this to allow per-ProjectReference fine tuning.
+                else if (projectReferenceLookupTable != null &&
+                        projectReferenceLookupTable.ContainsKey(CurrentProjectPlatform) &&
+                        projectReferencePlatforms.Contains(projectReferenceLookupTable[CurrentProjectPlatform]))
+                {
+                    buildProjectReferenceAs = projectReferenceLookupTable[CurrentProjectPlatform];
+                    Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", CurrentProjectPlatform, buildProjectReferenceAs, projectReferenceLookupTableMetadata);
+                }
+                // Current project's translation table follows
+                else if (currentProjectLookupTable != null &&
+                        currentProjectLookupTable.ContainsKey(CurrentProjectPlatform) &&
+                        projectReferencePlatforms.Contains(currentProjectLookupTable[CurrentProjectPlatform]))
+                {
+                    buildProjectReferenceAs = currentProjectLookupTable[CurrentProjectPlatform];
+                    Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", CurrentProjectPlatform, buildProjectReferenceAs, PlatformLookupTable);
+                }
+                // AnyCPU if possible
+                else if (projectReferencePlatforms.Contains("AnyCPU"))
+                {
+                    buildProjectReferenceAs = "AnyCPU";
+                    Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.AnyCPUDefault");
+                }
+                else
+                {
+                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine 
+                    // Platform/PlatformTarget when this is the case.
+                    Log.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoCompatiblePlatformFound", AssignedProjectsWithPlatform[i].ItemSpec);
+                }
+
+                AssignedProjectsWithPlatform[i].SetMetadata("NearestPlatform", buildProjectReferenceAs);
+                Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.DisplayChosenPlatform", AssignedProjectsWithPlatform[i].ItemSpec, buildProjectReferenceAs);
+            }
+
+            return !Log.HasLoggedErrors;
+        }
+
+        private Dictionary<string, string>? ExtractLookupTable(string stringTable)
+        {
+            if (string.IsNullOrEmpty(stringTable))
+            {
+                return null;
+            }
+
+            Dictionary<string, string> table = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+
+            foreach (string s in stringTable.Trim().Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
+            {
+                string[] keyVal = s.Trim().Split(MSBuildConstants.EqualsChar);
+
+                // Invalid table, don't use it.
+                if (keyVal.Length != 2 || string.IsNullOrEmpty(keyVal[0]) || string.IsNullOrEmpty(keyVal[1]))
+                {
+                    Log.LogWarningWithCodeFromResources("GetCompatiblePlatform.InvalidLookupTableFormat", stringTable);
+                    return null;
+                }
+
+                table[keyVal[0]] = keyVal[1];
+            }
+
+            Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.LookupTableParsed", stringTable);
+
+            return table;
+        }
+    }
+}
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index f060dad8a13..e5418ee4bad 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -342,6 +342,7 @@
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="ResourceHandling\*.cs" />
+    <Compile Include="GetCompatiblePlatform.cs" />
     <Compile Include="ResolveComReference.cs" />
     <Compile Include="BuildCacheDisposeWrapper.cs" />
     <Compile Include="DownloadFile.cs" />
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index 46c03bec65c..c7d553aecd3 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -46,6 +46,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->
         <IsRidAgnostic>false</IsRidAgnostic>
         <IsRidAgnostic Condition=" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
+        <!-- Extract necessary information for SetPlatform negotiation -->
+        <!-- This target does not run for cpp projects. -->
+        <IsVcxOrNativeProj>false</IsVcxOrNativeProj>
+        <Platforms>$(Platforms)</Platforms>
       </_ThisProjectBuildMetadata>
     </ItemGroup>
 
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 7226919f37b..8854b0cd156 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -324,8 +324,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <!-- Example, C:\MyProjects\MyProject\bin\Debug\MyAssembly.dll -->
     <TargetPath Condition=" '$(TargetPath)' == '' ">$(TargetDir)$(TargetFileName)</TargetPath>
 
-    <TargetRefPath Condition=" '$(TargetRefPath)' == '' and '$(ProduceReferenceAssembly)' == 'true' and ('$(ProduceReferenceAssemblyInOutDir)' == 'true' or '$([MSBuild]::AreFeaturesEnabled(17.0))' != 'true' ) ">$([MSBuild]::NormalizePath($(TargetDir), 'ref', $(TargetFileName)))</TargetRefPath>
-    <TargetRefPath Condition=" '$(TargetRefPath)' == '' and '$(ProduceReferenceAssembly)' == 'true' ">$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(IntermediateOutputPath), 'ref', $(TargetFileName)))</TargetRefPath>
+    <TargetRefPath Condition=" '$(TargetRefPath)' == '' and '$(ProduceReferenceAssembly)' == 'true' ">$([MSBuild]::NormalizePath($(TargetDir), 'ref', $(TargetFileName)))</TargetRefPath>
 
     <!-- Example, C:\MyProjects\MyProject\ -->
     <ProjectDir Condition=" '$(ProjectDir)' == '' ">$([MSBuild]::EnsureTrailingSlash($(MSBuildProjectDirectory)))</ProjectDir>
@@ -394,10 +393,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </ItemGroup>
 
   <ItemGroup Condition="'$(ProduceReferenceAssembly)' == 'true'">
-    <IntermediateRefAssembly Include="$(IntermediateOutputPath)refint\$(TargetName)$(TargetExt)" Condition="'@(IntermediateRefAssembly)' == ''" />
+    <IntermediateRefAssembly Include="$(IntermediateOutputPath)ref\$(TargetName)$(TargetExt)" Condition="'@(IntermediateRefAssembly)' == ''" />
     <CreateDirectory Include="@(IntermediateRefAssembly->'%(RootDir)%(Directory)')" />
-    <CreateDirectory Include="$(OutDir)ref" Condition=" '$(ProduceReferenceAssemblyInOutDir)' == 'true'" />
-    <CreateDirectory Include="$(IntermediateOutputPath)ref" Condition=" '$(ProduceReferenceAssemblyInOutDir)' != 'true'" />
+    <CreateDirectory Include="$(OutDir)ref" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(_DebugSymbolsProduced)' == 'true'">
@@ -1605,6 +1603,93 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
+  <!--
+    ====================================================================================
+                                        _GetProjectReferencePlatformProperties
+
+    If a project is opted in via $(EnableDynamicPlatformResolution), this target calls the 
+    GetCompatiblePlatform task on all ProjectReference items to determine the most compatible 
+    platform for each project. It then sets SetPlatform metadata on each ProjectReference.
+    This prevents overbuilding a project when 'AnyCPU' is available.
+
+    ======================================================================================
+  -->
+
+  <!-- Managed projects need to have PlatformTarget set for SetPlatform negotiation. Default to $(Platform), which is AnyCPU by default. -->
+  <PropertyGroup>
+    <PlatformTarget Condition="'$(EnableDynamicPlatformResolution)' == 'true' and '$(PlatformTarget)' == ''
+                                and '$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj'">$(Platform)</PlatformTarget>
+
+    <UseDefaultPlatformLookupTables Condition="'$(UseDefaultPlatformLookupTables)' == ''">true</UseDefaultPlatformLookupTables>
+  </PropertyGroup>
+
+  <!-- This target skips VS builds because they already supply Platform and
+       Configuration information. -->
+  <Target Name="_GetProjectReferencePlatformProperties"
+          Condition="'$(EnableDynamicPlatformResolution)' == 'true'
+                     and '$(BuildingInsideVisualStudio)' != 'true'
+                     and '@(_MSBuildProjectReferenceExistent)' != ''">
+
+    <!-- Allow preset SetPlatform to override this operation -->
+    <ItemGroup>
+      <_MSBuildProjectReferenceExistent Condition="'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''">
+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>
+      </_MSBuildProjectReferenceExistent>
+    </ItemGroup>
+
+    <ItemGroup>
+      <_ProjectReferencePlatformPossibilities Include="@(_MSBuildProjectReferenceExistent)" 
+                                              Condition="'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'"/>
+    </ItemGroup>
+
+    <!-- Managed Platform "source of truth" is $(PlatformTarget). For cpp it's $(Platform) -->
+    <PropertyGroup>
+      <CurrentPlatform>$(PlatformTarget)</CurrentPlatform>
+      <CurrentPlatform Condition="'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'">$(Platform)</CurrentPlatform>
+    </PropertyGroup>
+
+    <!-- Assign default PlatformLookupTables when doing Managed <-> Unmanaged hops -->
+    <ItemGroup>
+      <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->
+      <_ProjectReferencePlatformPossibilities Condition="'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'">
+        <!-- Taken from https://docs.microsoft.com/visualstudio/msbuild/assignprojectconfiguration-task -->
+        <PlatformLookupTable Condition="'$(UseDefaultPlatformLookupTables)' == 'true' and '$(PlatformLookupTable)' == ''">x86=Win32</PlatformLookupTable>
+      </_ProjectReferencePlatformPossibilities>
+
+      <!-- If we're looking at a managed project from a cpp project, map native to managed platforms. -->
+      <_ProjectReferencePlatformPossibilities Condition="('$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj') and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' != 'true'">
+        <PlatformLookupTable Condition="'$(UseDefaultPlatformLookupTables)' == 'true' and '$(PlatformLookupTable)' == ''">Win32=x86</PlatformLookupTable>
+      </_ProjectReferencePlatformPossibilities>
+    </ItemGroup>
+
+    <GetCompatiblePlatform AnnotatedProjects="@(_ProjectReferencePlatformPossibilities)"
+                           CurrentProjectPlatform="$(CurrentPlatform)"
+                           PlatformLookupTable="$(PlatformLookupTable)"
+                           Condition="'@(_ProjectReferencePlatformPossibilities)' != ''">
+      <Output ItemName="_ProjectsWithPlatformAssignment" TaskParameter="AssignedProjectsWithPlatform" />
+    </GetCompatiblePlatform>
+
+    <!-- If GetCompatiblePlatform didn't run, @(ProjectsWithPlatformAssignment) will be empty.
+         Don't do anything in this case. Ex: A project references many projects
+         that can't multiplatform.  -->
+    <ItemGroup Condition="'@(_ProjectsWithPlatformAssignment)' != ''">
+      <ProjectsWithNearestPlatform Include="@(_ProjectsWithPlatformAssignment)"/>
+      <ProjectsWithNearestPlatform Condition="'@(ProjectsWithNearestPlatform)' == '%(Identity)' and '%(ProjectsWithNearestPlatform.NearestPlatform)' != ''">
+        <SetPlatform>PlatformTarget=%(ProjectsWithNearestPlatform.NearestPlatform)</SetPlatform>
+        <SetPlatform Condition="'%(ProjectsWithNearestPlatform.IsVcxOrNativeProj)' == 'true'">Platform=%(ProjectsWithNearestPlatform.NearestPlatform)</SetPlatform>
+      </ProjectsWithNearestPlatform>
+
+      <ProjectsWithNearestPlatform Condition="'@(ProjectsWithNearestPlatform)' == '%(Identity)' and '%(ProjectsWithNearestPlatform.NearestPlatform)' == ''">
+        <UndefineProperties Condition="'%(ProjectsWithNearestPlatform.IsVcxOrNativeProj)' == 'true'">%(ProjectsWithNearestPlatform.UndefineProperties);Platform</UndefineProperties>
+        <UndefineProperties Condition="'%(ProjectsWithNearestPlatform.IsVcxOrNativeProj)' != 'true'">%(ProjectsWithNearestPlatform.UndefineProperties);PlatformTarget</UndefineProperties>
+      </ProjectsWithNearestPlatform>
+
+      <_MSBuildProjectReferenceExistent Remove="@(_MSBuildProjectReferenceExistent)" Condition="'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'"/>
+      <_MSBuildProjectReferenceExistent Include="@(ProjectsWithNearestPlatform)"/>
+    </ItemGroup>
+
+  </Target>
+
   <!--
     ====================================================================================
                                         _GetProjectReferenceTargetFrameworkProperties
@@ -1660,7 +1745,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
    -->
    <ItemGroup>
       <_MSBuildProjectReferenceExistent Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' == '' and ('%(Extension)' == '.vcxproj' or '%(Extension)' == '.nativeproj')">
-        <SkipGetTargetFrameworkProperties>true</SkipGetTargetFrameworkProperties>
+        <!-- 
+          Platform negotiation requires the MSBuild task call to GetTargetFrameworks.
+          Don't skip when opted into the feature.
+        -->
+        <SkipGetTargetFrameworkProperties Condition="'$(EnableDynamicPlatformResolution)' != 'true'">true</SkipGetTargetFrameworkProperties>
         <UndefineProperties>%(_MSBuildProjectReferenceExistent.UndefineProperties);TargetFramework</UndefineProperties>
       </_MSBuildProjectReferenceExistent>
    </ItemGroup>
@@ -1678,7 +1767,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     -->
     <ItemGroup>
       <_MSBuildProjectReferenceExistent Condition="'%(_MSBuildProjectReferenceExistent.SetTargetFramework)' != ''">
-        <SkipGetTargetFrameworkProperties>true</SkipGetTargetFrameworkProperties>
+        <!-- 
+          Platform negotiation requires the MSBuild task call to GetTargetFrameworks.
+          Don't skip when opted into the feature.
+        -->
+        <SkipGetTargetFrameworkProperties Condition="'$(EnableDynamicPlatformResolution)' != 'true'">true</SkipGetTargetFrameworkProperties>
       </_MSBuildProjectReferenceExistent>
     </ItemGroup>
 
@@ -1722,8 +1815,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                                             CurrentProjectTargetPlatform="$(TargetPlatformMoniker)"
                                             CurrentProjectName="$(MSBuildProjectName)"
                                             FallbackTargetFrameworks="$(AssetTargetFallback)"
-                                            Condition="'@(_ProjectReferenceTargetFrameworkPossibilities->Count())' != '0' and '$(ReferringTargetFrameworkForProjectReferences)' != ''
-                                                        And '$(GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter)' == 'true'">
+                                            Condition="'@(_ProjectReferenceTargetFrameworkPossibilities)' != '' and '$(ReferringTargetFrameworkForProjectReferences)' != ''
+                                                        And '$(GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter)' == 'true' and '%(_ProjectReferenceTargetFrameworkPossibilities.IsVcxOrNativeProj)' != 'true'">
       <Output ItemName="AnnotatedProjects" TaskParameter="AssignedProjects" />
     </GetReferenceNearestTargetFrameworkTask>
 
@@ -1731,8 +1824,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                                             CurrentProjectTargetFramework="$(ReferringTargetFrameworkForProjectReferences)"
                                             CurrentProjectName="$(MSBuildProjectName)"
                                             FallbackTargetFrameworks="$(AssetTargetFallback)"
-                                            Condition="'@(_ProjectReferenceTargetFrameworkPossibilities->Count())' != '0' and '$(ReferringTargetFrameworkForProjectReferences)' != ''
-                                                        And '$(GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter)' != 'true'">
+                                            Condition="'@(_ProjectReferenceTargetFrameworkPossibilities)' != '' and '$(ReferringTargetFrameworkForProjectReferences)' != ''
+                                                        And '$(GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter)' != 'true' and '%(_ProjectReferenceTargetFrameworkPossibilities.IsVcxOrNativeProj)' != 'true'">
       <Output ItemName="AnnotatedProjects" TaskParameter="AssignedProjects" />
     </GetReferenceNearestTargetFrameworkTask>
 
@@ -1741,9 +1834,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
          If the task was skipped or the current TargetFramework is empty, AnnotatedProjects will be empty.
          In this case, copy _ProjectReferenceTargetFrameworkPossibilities as is. See:
             https://github.com/dotnet/sdk/issues/416
+
+        Furthermore, if we're referencing a .vcxproj or .nativeproj, those items won't be populated into `AnnotatedProjects`
+        by `GetReferenceNearestTargetFrameworkTask`, so let them flow when `EnableDynamicPlatformResolution` is set. 
       -->
       <AnnotatedProjects Include="@(_ProjectReferenceTargetFrameworkPossibilities)"
-                         Condition="'$(ReferringTargetFrameworkForProjectReferences)' == ''" />
+                         Condition="'$(ReferringTargetFrameworkForProjectReferences)' == '' or
+                                    ('$(EnableDynamicPlatformResolution)' == 'true' and '%(_ProjectReferenceTargetFrameworkPossibilities.IsVcxOrNativeProj)' == 'true')" />
+
       <!-- If the NearestTargetFramework property was set and the project multi-targets, SetTargetFramework must be set. -->
       <AnnotatedProjects Condition="'@(AnnotatedProjects)' == '%(Identity)' and '%(AnnotatedProjects.NearestTargetFramework)' != '' and '%(AnnotatedProjects.HasSingleTargetFramework)' != 'true'">
         <SetTargetFramework>TargetFramework=%(AnnotatedProjects.NearestTargetFramework)</SetTargetFramework>
@@ -1795,6 +1893,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->
         <IsRidAgnostic>false</IsRidAgnostic>
         <IsRidAgnostic Condition=" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
+        <!-- Extract necessary information for SetPlatform negotiation -->
+        <IsVcxOrNativeProj Condition="'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'">true</IsVcxOrNativeProj>
+        <Platforms>$(Platforms)</Platforms>
+        <!-- .vcxproj and .nativeproj contain a `ProjectConfiguration` item that have `Platform` metadata within.
+             Build the `Platforms` property from that. -->
+        <Platforms Condition="'@(ProjectConfiguration)' != '' and ('$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj')">@(ProjectConfiguration->'%(Platform)'->Distinct())</Platforms>
       </_ThisProjectBuildMetadata>
     </ItemGroup>
 
@@ -1809,9 +1913,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </_AdditionalTargetFrameworkInfoPropertyWithValue>
     </ItemGroup>
 
+    <PropertyGroup>
+      <_UseAttributeForTargetFrameworkInfoPropertyNames Condition="'$(_UseAttributeForTargetFrameworkInfoPropertyNames)' == ''">false</_UseAttributeForTargetFrameworkInfoPropertyNames>
+    </PropertyGroup>
+
     <CombineTargetFrameworkInfoProperties
         RootElementName="$(TargetFramework)"
-        PropertiesAndValues="@(_AdditionalTargetFrameworkInfoPropertyWithValue)">
+        PropertiesAndValues="@(_AdditionalTargetFrameworkInfoPropertyWithValue)"
+        UseAttributeForTargetFrameworkInfoPropertyNames="$(_UseAttributeForTargetFrameworkInfoPropertyNames)">
       <Output TaskParameter="Result"
               PropertyName="_AdditionalTargetFrameworkInfoProperties"/>
     </CombineTargetFrameworkInfoProperties>
@@ -1862,7 +1971,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <PrepareProjectReferencesDependsOn>
       AssignProjectConfiguration;
       _SplitProjectReferencesByFileExistence;
-      _GetProjectReferenceTargetFrameworkProperties
+      _GetProjectReferenceTargetFrameworkProperties;
+      _GetProjectReferencePlatformProperties
     </PrepareProjectReferencesDependsOn>
   </PropertyGroup>
 
@@ -2317,9 +2427,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ====================================================================================================
   -->
   <Target Name="GenerateBindingRedirects"
-    Inputs="$(MSBuildAllProjects);@(AppConfigFile);$(ResolveAssemblyReferencesStateFile);$(IntermediateOutputPath);@(SuggestedBindingRedirects)"
+    Inputs="$(MSBuildAllProjects);@(AppConfigFile);$(ResolveAssemblyReferencesStateFile);$(SuggestedBindingRedirectsCacheFile)"
     Outputs="$(_GenerateBindingRedirectsIntermediateAppConfig)"
-    Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true'">
+    Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true'"
+    DependsOnTargets="_GenerateSuggestedBindingRedirectsCache">
 
     <GenerateBindingRedirects
       AppConfigFile="@(AppConfigWithTargetPath)"
@@ -3519,6 +3630,33 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
+  <!--
+    ============================================================
+                                        _GenerateSuggestedBindingRedirectsCache
+    Generate a file used to track whether suggested binding redirects changed between builds.
+    @(SuggestedBindingRedirects) never contains a file on disk, so create a file
+    that contains a hash of the items to prevent `GenerateBindingRedirects`
+    from running every build.
+
+    See https://github.com/dotnet/msbuild/issues/5943 for details.
+    ============================================================
+    -->
+  <Target Name="_GenerateSuggestedBindingRedirectsCache" Condition="'$(DesignTimeBuild)' != 'true' and '$(BuildingProject)' == 'true'" DependsOnTargets="ResolveAssemblyReferences">
+    <PropertyGroup>
+      <SuggestedBindingRedirectsCacheFile>$(IntermediateOutputPath)$(MSBuildProjectFile).SuggestedBindingRedirects.cache</SuggestedBindingRedirectsCacheFile>
+    </PropertyGroup>
+
+      <Hash ItemsToHash="@(SuggestedBindingRedirects)">
+        <Output TaskParameter="HashResult" PropertyName="SuggestedBindingRedirectsHash"/>
+      </Hash>
+
+      <WriteLinesToFile Lines="$(SuggestedBindingRedirectsHash)" File="$(SuggestedBindingRedirectsCacheFile)" Overwrite="true" WriteOnlyWhenDifferent="true"/>
+
+      <ItemGroup>
+        <FileWrites Include="$(SuggestedBindingRedirectsCacheFile)"/>
+      </ItemGroup>
+  </Target>
+
   <!--
     ============================================================
                                         _GenerateCompileDependencyCache
@@ -4728,13 +4866,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                                         GetCopyToOutputDirectoryItems
 
     Get all project items that may need to be transferred to the output directory.
-    This includes baggage items from transitively referenced projects. It would appear
-    that this target computes full transitive closure of content items for all referenced
-    projects; however that is not the case. It only collects the content items from its
-    immediate children and not children of children. The reason this happens is that
-    the ProjectReferenceWithConfiguration list that is consumed by _SplitProjectReferencesByFileExistence
-    is only populated in the current project and is empty in the children. The empty list
-    causes _MSBuildProjectReferenceExistent to be empty and terminates the recursion.
+    This includes baggage items from transitively referenced projects.
+
+    As of 17.0, content items are copied transitively by default.
+    Set `MSBuildCopyContentTransitively` to false to opt out.
+    See https://github.com/dotnet/msbuild/pull/6622 for more info.
     ============================================================
     -->
   <PropertyGroup>
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index 6cef8ef8661..f6b98da83af 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -127,6 +127,7 @@
 
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateTrustInfo"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.GetAssemblyIdentity"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.GetCompatiblePlatform"                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.GetFileHash"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkPath"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkSdkPath"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index 48b0bfb05a3..45b52e509f0 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -2893,6 +2893,37 @@
     <value>MSB3965: No output path specified in build settings.</value>
     <comment>{StrBegin="MSB3965: "}</comment>
   </data>
+
+  <!--
+        MSB3981 - MSB3990   Task: GetCompatiblePlatform
+  -->
+  <data name="GetCompatiblePlatform.NoCompatiblePlatformFound">
+    <value>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</value>
+    <comment>{StrBegin="MSB3981: "}</comment>
+  </data>
+  <data name="GetCompatiblePlatform.NoPlatformsListed">
+    <value>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</value>
+    <comment>{StrBegin="MSB3982: "}</comment>
+  </data>
+  <data name="GetCompatiblePlatform.InvalidLookupTableFormat">
+    <value>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</value>
+    <comment>{StrBegin="MSB3983: "}</comment>
+  </data>
+  <data name="GetCompatiblePlatform.LookupTableParsed">
+    <value>Parsed lookup table:'{0}'.</value>
+  </data>
+    <data name="GetCompatiblePlatform.FoundMappingInTable">
+    <value>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</value>
+  </data>
+  <data name="GetCompatiblePlatform.DisplayChosenPlatform">
+    <value>Project '{0}' will build with platform: '{1}'.</value>
+  </data>
+  <data name="GetCompatiblePlatform.SamePlatform">
+    <value>ProjectReference and current project have the same platform.</value>
+  </data>
+  <data name="GetCompatiblePlatform.AnyCPUDefault">
+    <value>Choosing AnyCPU by default.</value>
+  </data>
   <!--
         The tasks message bucket is: MSB3001 - MSB3999
 
@@ -2978,6 +3009,7 @@
             MSB3951 - MSB3960   Task: VerifyFileHash
             MSB3961 - MSB3970   Task: GenerateLauncher
             MSB3971 - MSB3980   Task: GetReferenceAssemblyPaths overflow
+            MSB3981 - MSB3990   Task: GetCompatiblePlatform
 
             MSB4000 - MSB4200   Portable targets & tasks (vsproject\flavors\portable\msbuild)
             MSB9000 - MSB9900   MSBuild targets files (C++)
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index d3b826e07fa..4dffc40b6a4 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: Nelze získat název sestavení pro {0}. {1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">Očekávaná verze sady Microsoft Windows SDK nebyla nalezena. Při hledání bylo použito umístění určené hodnotou {0} klíče registru {1}. Pokud daný proces sestavení sadu SDK nepotřebuje, lze tuto chybu ignorovat. V opačném případě můžete potíže odstranit provedením jedné z následujících akcí: 1) instalací sady Microsoft Windows SDK,  2) Instalací sady Visual Studio 2010. 3) Ručním nastavením uvedeného klíče registru na správné umístění.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 55412a39a12..b2967c6f62b 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: Der Assemblyname für "{0}" kann nicht abgerufen werden. {1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">Die erwartete Version des Microsoft Windows SDK wurde nicht gefunden. Es wurde nach einem im Wert "{0}" des Registrierungsschlüssels "{1}" angegebenen Speicherort gesucht. Wenn das SDK für den Buildprozess nicht erforderlich ist, kann diese Meldung ignoriert werden. Andernfalls können Sie das Problem mit einem der folgenden Verfahren beheben:  1) Installieren Sie das Microsoft Windows SDK.  2) Installieren Sie Visual Studio 2010.  3) Legen Sie den obigen Registrierungsschlüssel manuell auf den korrekten Speicherort fest.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.en.xlf b/src/Tasks/Resources/xlf/Strings.en.xlf
index 14b9fb2399b..751a0a265bf 100644
--- a/src/Tasks/Resources/xlf/Strings.en.xlf
+++ b/src/Tasks/Resources/xlf/Strings.en.xlf
@@ -1371,6 +1371,46 @@
         <target state="new">MSB3441: Cannot get assembly name for "{0}". {1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="new">Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 9055e7583fb..f192095b546 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: No se puede obtener el nombre del ensamblado para "{0}". {1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">No se encuentra la versión esperada de Microsoft Windows SDK. Se buscó una ubicación especificada en el valor "{0}" de la clave del Registro "{1}". Si el proceso de compilación no necesita el SDK, se puede omitir. De lo contrario, puede solucionar el problema realizando alguna de las siguientes acciones:  1) Instale Microsoft Windows SDK.  2) Instale Visual Studio 2010.  3) Establezca manualmente la clave del Registro indicada en la ubicación correcta.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index f3e5a1bb004..227e4e0ada5 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: Impossible d'obtenir le nom d'assembly de "{0}". {1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">Impossible de trouver la version attendue du SDK Microsoft Windows. Recherche d'un emplacement indiqué dans la valeur "{0}" de la clé de Registre "{1}". Si votre processus de génération n'a pas besoin du SDK, cette erreur peut être ignorée. Sinon, essayez de résoudre le problème de l'une des manières suivantes : 1) Installez le SDK Microsoft Windows.  2) Installez Visual Studio 2010. 3) Indiquez l'emplacement approprié dans la clé de Registre ci-dessus.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 04cdbd3ac62..c9de2ea77a7 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: non è possibile ottenere il nome dell'assembly per "{0}". {1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">Non è stato possibile trovare la versione prevista di Microsoft Windows SDK. È stato cercato il percorso specificato nel valore "{0}" della chiave del Registro di sistema "{1}". Se il processo di compilazione non richiede l'SDK, è possibile ignorare il problema. In caso contrario, per risolvere il problema eseguire una di queste operazioni: 1) Installare Microsoft Windows SDK.  2) Installare Visual Studio 2010. 3) Impostare manualmente la chiave del Registro di sistema specificata in precedenza sul percorso corretto.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index 632c22f62e2..505b8abd5d6 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: "{0}" のアセンブリ名を取得できません。{1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">必要なバージョンの Microsoft Windows SDK が見つかりませんでした。レジストリ キー "{1}" の値 "{0}" で指定されている場所を探しました。このエラーは、ビルド処理で SDK が不要な場合は無視できます。SDK が必要な場合は、次のいずれかを行うことによって問題を解決できます。1) Microsoft Windows SDK をインストールする。2) Visual Studio 2010 をインストールする。3) 上記のレジストリ キーを正しい場所に手動で設定する。</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 89a5cbab6d3..8f3abe83e5e 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: "{0}"의 어셈블리 이름을 가져올 수 없습니다. {1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">원하는 Microsoft Windows SDK 버전을 찾을 수 없습니다. "{1}" 레지스트리 키의 "{0}" 값에 지정된 위치를 검색했습니다. 빌드 프로세스에서 SDK가 필요하지 않으면 이 메시지를 무시해도 됩니다. 그렇지 않으면 다음 중 하나를 수행하여 문제를 해결할 수 있습니다. 1) Microsoft Windows SDK를 설치합니다.  2) Visual Studio 2010을 설치합니다. 3) 위의 레지스트리 키를 올바른 위치로 직접 설정합니다.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 44502232a54..75fc8e7f976 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: Nie można pobrać nazwy zestawu dla „{0}”. {1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">Nie można zlokalizować oczekiwanej wersji zestawu Microsoft Windows SDK. Poszukiwano lokalizacji określonej w wartości „{0}” klucza rejestru „{1}”. Jeżeli proces kompilacji nie wymaga zestawu SDK, można zignorować ten element. W przeciwnym przypadku problem można rozwiązać, wykonując jedną z następujących czynności: 1) zainstalowanie zestawu Microsoft Windows SDK,  2) zainstalowanie programu Visual Studio 2010, 3) ręczne ustawienie poprawnej lokalizacji w powyższym kluczu rejestru.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index 5dcf3a0da1f..1ed2d4d14ee 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: Não foi possível obter o nome de assembly para "{0}". {1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">Não foi possível localizar a versão esperada do SDK do Microsoft Windows. Ela foi procurada em uma localização especificada no valor "{0}" da chave do Registro "{1}". Se o seu processo de build não precisar do SDK, isso poderá ser ignorado. Caso contrário, você poderá resolver o problema executando um destes procedimentos: 1) Instalar o SDK do Microsoft Windows.  2) Instalar o Visual Studio 2010. 3) Definir manualmente a chave do Registro acima para a localização correta.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index baf169c57cc..b2fe1cecf3d 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: Не удалось получить имя сборки для "{0}". {1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">Не удалось обнаружить требуемую версию Microsoft Windows SDK. Поиск выполнен в расположении, заданном значением "{0}" раздела реестра "{1}". Если данному процессу сборки не требуется пакет SDK, на это сообщение можно не обращать внимания. В противном случае неполадку, возможно, удастся устранить, выполнив одно из следующих действий: (1) установите Microsoft Windows SDK;  (2) установите Visual Studio 2010; (3) вручную задайте в указанном выше разделе реестра правильное расположение.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 63653985939..8322c625cfd 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: "{0}" için derleme adı alınamıyor. {1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">Beklenen Microsoft Windows SDK sürümü bulunamadı. "{1}" kayıt defteri anahtarının "{0}" değerinde belirtilen konum arandı. Derleme işleminiz SDK’ya ihtiyaç duymuyorsa bu yoksayılabilir. Aksi halde, şu işlemlerden birini yaparak sorunu çözebilirsiniz: 1) Microsoft Windows SDK’yı yükleyin.  2) Visual Studio 2010’u yükleyin. 3) Yukarıdaki kayıt defteri anahtarını el ile doğru konuma ayarlayın.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index f30189bfe95..93d8a13443c 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: 无法获取“{0}”的程序集名称。{1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">未能找到 Microsoft Windows SDK 的预期版本。已查找过注册表项“{1}”的“{0}”值中指定的位置。如果生成过程不需要该 SDK，则可以忽略此问题。否则，通过执行下列操作之一可以解决此问题: 1) 安装 Microsoft Windows SDK。2) 安装 Visual Studio 2010。 3) 手动向正确的位置设置上面的注册表项。</target>
@@ -2647,7 +2687,7 @@
       </trans-unit>
       <trans-unit id="Xaml.MissingTaskBody">
         <source>MSB3692: Unable to create Xaml task.  The &lt;UsingTask&gt; does not contain a &lt;Task&gt; definition.</source>
-        <target state="translated">MSB3692:  无法创建 Xaml 任务。  &lt;UsingTask&gt; 未包含 &lt;Task&gt; 定义。</target>
+        <target state="translated">MSB3692: 无法创建 Xaml 任务。  &lt;UsingTask&gt; 未包含 &lt;Task&gt; 定义。</target>
         <note>{StrBegin="MSB3692: "}</note>
       </trans-unit>
       <trans-unit id="Xaml.ArgumentOutOfRange">
@@ -3242,7 +3282,7 @@
       </trans-unit>
       <trans-unit id="ErrorAndWarning.EmptyMessage">
         <source>(No message specified)</source>
-        <target state="translated">（未指定任何消息）</target>
+        <target state="translated">(未指定任何消息)</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskFactoryNotSupportedFailure">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 288e6c5423c..e206b7cccfc 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: 無法取得 "{0}" 的組件名稱。{1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">找不到預期的 Microsoft Windows SDK 版本。已在登錄機碼 "{1}" 的 "{0}" 值中指定的位置尋找。如果您的建置程序不需要這個 SDK，您可以忽略此訊息。否則，您可以執行下列其中一個動作以解決此問題:  1) 安裝 Microsoft Windows SDK。2) 安裝 Visual Studio 2010。  3) 手動將上方登錄機碼設為正確位置。</target>
