diff --git a/.gitattributes b/.gitattributes
index a8bb4d389ee..af9d9e931ae 100644
--- a/.gitattributes
+++ b/.gitattributes
@@ -20,7 +20,7 @@ src/Tasks/*.targets linguist-detectable=true
 src/Tasks/*.tasks linguist-detectable=true
 
 # Don't include Arcade-owned path
-eng/common/** linguist-detectable=false
+eng/common/** linguist-vendored linguist-generated
 
 # Display XLF files collapsed by default in PR diffs
 *.xlf linguist-generated=true
diff --git a/.github/ISSUE_TEMPLATE/04_blankissue.md b/.github/ISSUE_TEMPLATE/04_blankissue.md
new file mode 100644
index 00000000000..9be0e37587f
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/04_blankissue.md
@@ -0,0 +1,6 @@
+---
+name: 📄 Blank Issue
+about: Doesn't fit the other categories? File a blank ticket here.
+title: ''
+labels: untriaged
+---
\ No newline at end of file
diff --git a/.github/ISSUE_TEMPLATE/config.yml b/.github/ISSUE_TEMPLATE/config.yml
index 63f52d67500..0b4875ecad3 100644
--- a/.github/ISSUE_TEMPLATE/config.yml
+++ b/.github/ISSUE_TEMPLATE/config.yml
@@ -1,4 +1,4 @@
-blank_issues_enabled: true
+blank_issues_enabled: false
 contact_links:
   - name: Issue with .NET (Core) SDK
     url:  https://github.com/dotnet/sdk/issues/new/choose
diff --git a/.github/PULL_REQUEST_TEMPLATE/pull_request_template.md b/.github/PULL_REQUEST_TEMPLATE/pull_request_template.md
deleted file mode 100644
index 95898c21f51..00000000000
--- a/.github/PULL_REQUEST_TEMPLATE/pull_request_template.md
+++ /dev/null
@@ -1,5 +0,0 @@
-Fixes #
-
-<!--
-Insert a brief description of your changes here.
--->
\ No newline at end of file
diff --git a/.github/pull_request_template.md b/.github/pull_request_template.md
new file mode 100644
index 00000000000..bc70eea23e5
--- /dev/null
+++ b/.github/pull_request_template.md
@@ -0,0 +1,12 @@
+Fixes #
+
+### Context
+
+
+### Changes Made
+
+
+### Testing
+
+
+### Notes
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index df5f8f2bc6d..260f46914b1 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -209,6 +209,8 @@ jobs:
     condition: always()
 
 - job: MonoOnMac
+  # Mono CI disabled until it can parse C# 9 syntax: https://github.com/dotnet/msbuild/issues/6058
+  condition: eq(1,2)
   displayName: "macOS Mono"
   pool:
     vmImage: 'macOS-10.14'
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index ef8f9b7cb82..eefef30630a 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -94,6 +94,7 @@ stages:
                 /p:DotNetSymbolServerTokenSymWeb=$(symweb-symbol-server-pat)
                 /p:TeamName=MSBuild
                 /p:DotNetPublishUsingPipelines=true
+                /p:VisualStudioIbcDrop=$(OptProfDropName)
       displayName: Build
       condition: succeeded()
 
diff --git a/Directory.Build.props b/Directory.Build.props
index 1683a4c99e3..3da3ed640c0 100644
--- a/Directory.Build.props
+++ b/Directory.Build.props
@@ -6,7 +6,7 @@
     <Copyright>$(CopyrightNetFoundation)</Copyright>
     <PackageLicenseExpression>MIT</PackageLicenseExpression>
   </PropertyGroup>
-  
+
   <PropertyGroup>
     <Product>Microsoft® Build Tools®</Product>
     <Configurations>Debug;Release;Debug-MONO;Release-MONO;MachineIndependent</Configurations>
@@ -16,19 +16,6 @@
     <FullFrameworkTFM>net472</FullFrameworkTFM>
   </PropertyGroup>
 
-  <PropertyGroup>
-    <OsEnvironment Condition="$([MSBuild]::IsOSPlatform('windows'))">windows</OsEnvironment>
-    <OsEnvironment Condition="$([MSBuild]::IsOSPlatform('linux'))">linux</OsEnvironment>
-    <OsEnvironment Condition="$([MSBuild]::IsOSPlatform('osx'))">osx</OsEnvironment>
-    <!-- Replace with MSBuild::IsBsdLike once the initial msbuild knows about it -->
-    <OsEnvironment Condition="$([MSBuild]::IsOSPlatform('FREEBSD')) Or $([MSBuild]::IsOSPlatform('NETBSD')) Or $([MSBuild]::IsOSPlatform('OPENBSD'))">bsd</OsEnvironment>
-
-    <OsUnixLike>false</OsUnixLike>
-    <OsUnixLike Condition="$([MSBuild]::IsOsUnixLike())">true</OsUnixLike>
-
-    <TargetPlatformIdentifier Condition="'$(TargetPlatformIdentifier)'==''">$(OS)</TargetPlatformIdentifier>
-  </PropertyGroup>
-
   <PropertyGroup>
     <DOTNET_INSTALL_DIR Condition="'$(DOTNET_INSTALL_DIR)' == ''">$(RepoRoot).dotnet\</DOTNET_INSTALL_DIR>
 
@@ -49,9 +36,10 @@
         CS1701 and CS1702 are by default ignored by Microsoft.NET.Sdk, but if you define the NoWarn property in Directory.Build.props,
         you don't get those defaults.
         NU5125: Arcade uses licenseUrl when doing pack, which now causes NU5125 warning. This disables that warning until arcade can switch over.
+        SYSLIB0011: Removing binary formatter will happen as part of a larger .NET-wide effort.
     -->
 
-    <NoWarn>$(NoWarn);NU1603;NU5105;NU5125;1701;1702</NoWarn>
+    <NoWarn>$(NoWarn);NU1603;NU5105;NU5125;1701;1702;SYSLIB0011</NoWarn>
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(Configuration)' == 'Debug-MONO'">
diff --git a/MSBuild.Dev.sln b/MSBuild.Dev.sln
deleted file mode 100644
index 395bc1d6691..00000000000
--- a/MSBuild.Dev.sln
+++ /dev/null
@@ -1,422 +0,0 @@
-﻿
-Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio 15
-VisualStudioVersion = 15.0.27004.2009
-MinimumVisualStudioVersion = 10.0.40219.1
-Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{4900B3B8-4310-4D5B-B1F7-2FDF9199765F}"
-	ProjectSection(SolutionItems) = preProject
-		NuGet.Config = NuGet.Config
-		src\Shared\UnitTests\xunit.runner.json = src\Shared\UnitTests\xunit.runner.json
-	EndProjectSection
-EndProject
-Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build", "src\Build\Microsoft.Build.csproj", "{69BE05E2-CBDA-4D27-9733-44E12B0F5627}"
-EndProject
-Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.Engine.OM.UnitTests", "src\Build.OM.UnitTests\Microsoft.Build.Engine.OM.UnitTests.csproj", "{5C53E4FD-0985-432D-B9E4-7BC354A057E5}"
-EndProject
-Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.Engine.UnitTests", "src\Build.UnitTests\Microsoft.Build.Engine.UnitTests.csproj", "{774DCE9B-F775-4B6D-943D-C841F755DBDE}"
-EndProject
-Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.Framework", "src\Framework\Microsoft.Build.Framework.csproj", "{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}"
-EndProject
-Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.Framework.UnitTests", "src\Framework.UnitTests\Microsoft.Build.Framework.UnitTests.csproj", "{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}"
-EndProject
-Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MSBuild", "src\MSBuild\MSBuild.csproj", "{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}"
-EndProject
-Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.CommandLine.UnitTests", "src\MSBuild.UnitTests\Microsoft.Build.CommandLine.UnitTests.csproj", "{0ADDBC02-0076-4159-B351-2BF33FAA46B2}"
-EndProject
-Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.Tasks", "src\Tasks\Microsoft.Build.Tasks.csproj", "{2AB5D52E-3C4D-4572-B140-9EED600ECE59}"
-EndProject
-Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.Tasks.UnitTests", "src\Tasks.UnitTests\Microsoft.Build.Tasks.UnitTests.csproj", "{CF999BDE-02B3-431B-95E6-E88D621D9CBF}"
-EndProject
-Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.Utilities", "src\Utilities\Microsoft.Build.Utilities.csproj", "{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}"
-EndProject
-Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.Utilities.UnitTests", "src\Utilities.UnitTests\Microsoft.Build.Utilities.UnitTests.csproj", "{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}"
-EndProject
-Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Xunit.NetCore.Extensions", "src\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj", "{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}"
-EndProject
-Global
-	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|Any CPU = Debug|Any CPU
-		Debug|x64 = Debug|x64
-		Debug|x86 = Debug|x86
-		Debug-MONO|Any CPU = Debug-MONO|Any CPU
-		Debug-MONO|x64 = Debug-MONO|x64
-		Debug-MONO|x86 = Debug-MONO|x86
-		MachineIndependent|Any CPU = MachineIndependent|Any CPU
-		MachineIndependent|x64 = MachineIndependent|x64
-		MachineIndependent|x86 = MachineIndependent|x86
-		Release|Any CPU = Release|Any CPU
-		Release|x64 = Release|x64
-		Release|x86 = Release|x86
-		Release-MONO|Any CPU = Release-MONO|Any CPU
-		Release-MONO|x64 = Release-MONO|x64
-		Release-MONO|x86 = Release-MONO|x86
-	EndGlobalSection
-	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug|x64.ActiveCfg = Debug|x64
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug|x64.Build.0 = Debug|x64
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug|x86.ActiveCfg = Debug|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug|x86.Build.0 = Debug|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release|Any CPU.Build.0 = Release|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release|x64.ActiveCfg = Release|x64
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release|x64.Build.0 = Release|x64
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release|x86.ActiveCfg = Release|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release|x86.Build.0 = Release|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release-MONO|Any CPU.ActiveCfg = Release|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release-MONO|Any CPU.Build.0 = Release|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release-MONO|x64.ActiveCfg = Release|x64
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release-MONO|x64.Build.0 = Release|x64
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release-MONO|x86.ActiveCfg = Release|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release-MONO|x86.Build.0 = Release|Any CPU
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug|x64.ActiveCfg = Debug|x64
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug|x64.Build.0 = Debug|x64
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug|x86.ActiveCfg = Debug|Any CPU
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug|x86.Build.0 = Debug|Any CPU
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release|Any CPU.Build.0 = Release|Any CPU
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release|x64.ActiveCfg = Release|x64
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release|x64.Build.0 = Release|x64
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release|x86.ActiveCfg = Release|Any CPU
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release|x86.Build.0 = Release|Any CPU
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release-MONO|Any CPU.ActiveCfg = Release|Any CPU
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release-MONO|Any CPU.Build.0 = Release|Any CPU
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release-MONO|x64.ActiveCfg = Release|x64
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release-MONO|x64.Build.0 = Release|x64
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release-MONO|x86.ActiveCfg = Release|Any CPU
-		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release-MONO|x86.Build.0 = Release|Any CPU
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug|x64.ActiveCfg = Debug|x64
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug|x64.Build.0 = Debug|x64
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug|x86.ActiveCfg = Debug|Any CPU
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug|x86.Build.0 = Debug|Any CPU
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release|Any CPU.Build.0 = Release|Any CPU
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release|x64.ActiveCfg = Release|x64
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release|x64.Build.0 = Release|x64
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release|x86.ActiveCfg = Release|Any CPU
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release|x86.Build.0 = Release|Any CPU
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release-MONO|Any CPU.ActiveCfg = Release|Any CPU
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release-MONO|Any CPU.Build.0 = Release|Any CPU
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release-MONO|x64.ActiveCfg = Release|x64
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release-MONO|x64.Build.0 = Release|x64
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release-MONO|x86.ActiveCfg = Release|Any CPU
-		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release-MONO|x86.Build.0 = Release|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug|x64.ActiveCfg = Debug|x64
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug|x64.Build.0 = Debug|x64
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug|x86.ActiveCfg = Debug|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug|x86.Build.0 = Debug|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release|Any CPU.Build.0 = Release|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release|x64.ActiveCfg = Release|x64
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release|x64.Build.0 = Release|x64
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release|x86.ActiveCfg = Release|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release|x86.Build.0 = Release|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release-MONO|Any CPU.ActiveCfg = Release|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release-MONO|Any CPU.Build.0 = Release|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release-MONO|x64.ActiveCfg = Release|x64
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release-MONO|x64.Build.0 = Release|x64
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release-MONO|x86.ActiveCfg = Release|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release-MONO|x86.Build.0 = Release|Any CPU
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug|x64.ActiveCfg = Debug|x64
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug|x64.Build.0 = Debug|x64
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug|x86.ActiveCfg = Debug|Any CPU
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug|x86.Build.0 = Debug|Any CPU
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release|Any CPU.Build.0 = Release|Any CPU
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release|x64.ActiveCfg = Release|x64
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release|x64.Build.0 = Release|x64
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release|x86.ActiveCfg = Release|Any CPU
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release|x86.Build.0 = Release|Any CPU
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release-MONO|Any CPU.ActiveCfg = Release|Any CPU
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release-MONO|Any CPU.Build.0 = Release|Any CPU
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release-MONO|x64.ActiveCfg = Release|x64
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release-MONO|x64.Build.0 = Release|x64
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release-MONO|x86.ActiveCfg = Release|Any CPU
-		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release-MONO|x86.Build.0 = Release|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug|x64.ActiveCfg = Debug|x64
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug|x64.Build.0 = Debug|x64
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug|x86.ActiveCfg = Debug|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug|x86.Build.0 = Debug|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release|Any CPU.Build.0 = Release|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release|x64.ActiveCfg = Release|x64
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release|x64.Build.0 = Release|x64
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release|x86.ActiveCfg = Release|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release|x86.Build.0 = Release|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release-MONO|Any CPU.ActiveCfg = Release|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release-MONO|Any CPU.Build.0 = Release|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release-MONO|x64.ActiveCfg = Release|x64
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release-MONO|x64.Build.0 = Release|x64
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release-MONO|x86.ActiveCfg = Release|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release-MONO|x86.Build.0 = Release|Any CPU
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug|x64.ActiveCfg = Debug|x64
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug|x64.Build.0 = Debug|x64
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug|x86.ActiveCfg = Debug|Any CPU
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug|x86.Build.0 = Debug|Any CPU
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release|Any CPU.Build.0 = Release|Any CPU
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release|x64.ActiveCfg = Release|x64
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release|x64.Build.0 = Release|x64
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release|x86.ActiveCfg = Release|Any CPU
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release|x86.Build.0 = Release|Any CPU
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release-MONO|Any CPU.ActiveCfg = Release|Any CPU
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release-MONO|Any CPU.Build.0 = Release|Any CPU
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release-MONO|x64.ActiveCfg = Release|x64
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release-MONO|x64.Build.0 = Release|x64
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release-MONO|x86.ActiveCfg = Release|Any CPU
-		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release-MONO|x86.Build.0 = Release|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug|x64.ActiveCfg = Debug|x64
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug|x64.Build.0 = Debug|x64
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug|x86.ActiveCfg = Debug|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug|x86.Build.0 = Debug|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release|Any CPU.Build.0 = Release|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release|x64.ActiveCfg = Release|x64
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release|x64.Build.0 = Release|x64
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release|x86.ActiveCfg = Release|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release|x86.Build.0 = Release|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release-MONO|Any CPU.ActiveCfg = Release|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release-MONO|Any CPU.Build.0 = Release|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release-MONO|x64.ActiveCfg = Release|x64
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release-MONO|x64.Build.0 = Release|x64
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release-MONO|x86.ActiveCfg = Release|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release-MONO|x86.Build.0 = Release|Any CPU
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug|x64.ActiveCfg = Debug|x64
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug|x64.Build.0 = Debug|x64
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug|x86.ActiveCfg = Debug|Any CPU
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug|x86.Build.0 = Debug|Any CPU
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug-MONO|x64.ActiveCfg = Debug|x64
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug-MONO|x64.Build.0 = Debug|x64
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug-MONO|x86.ActiveCfg = Debug|Any CPU
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug-MONO|x86.Build.0 = Debug|Any CPU
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release|Any CPU.Build.0 = Release|Any CPU
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release|x64.ActiveCfg = Release|x64
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release|x64.Build.0 = Release|x64
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release|x86.ActiveCfg = Release|Any CPU
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release|x86.Build.0 = Release|Any CPU
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release-MONO|Any CPU.ActiveCfg = Release|Any CPU
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release-MONO|Any CPU.Build.0 = Release|Any CPU
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release-MONO|x64.ActiveCfg = Release|x64
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release-MONO|x64.Build.0 = Release|x64
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release-MONO|x86.ActiveCfg = Release|Any CPU
-		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release-MONO|x86.Build.0 = Release|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug|x64.ActiveCfg = Debug|x64
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug|x64.Build.0 = Debug|x64
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug|x86.ActiveCfg = Debug|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug|x86.Build.0 = Debug|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug-MONO|x64.ActiveCfg = Debug|x64
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug-MONO|x64.Build.0 = Debug|x64
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug-MONO|x86.ActiveCfg = Debug|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug-MONO|x86.Build.0 = Debug|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release|Any CPU.Build.0 = Release|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release|x64.ActiveCfg = Release|x64
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release|x64.Build.0 = Release|x64
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release|x86.ActiveCfg = Release|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release|x86.Build.0 = Release|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release-MONO|Any CPU.ActiveCfg = Release|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release-MONO|Any CPU.Build.0 = Release|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release-MONO|x64.ActiveCfg = Release|x64
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release-MONO|x64.Build.0 = Release|x64
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release-MONO|x86.ActiveCfg = Release|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release-MONO|x86.Build.0 = Release|Any CPU
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug|x64.ActiveCfg = Debug|x64
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug|x64.Build.0 = Debug|x64
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug|x86.ActiveCfg = Debug|Any CPU
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug|x86.Build.0 = Debug|Any CPU
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug-MONO|x64.ActiveCfg = Debug|x64
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug-MONO|x64.Build.0 = Debug|x64
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug-MONO|x86.ActiveCfg = Debug|Any CPU
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug-MONO|x86.Build.0 = Debug|Any CPU
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release|Any CPU.Build.0 = Release|Any CPU
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release|x64.ActiveCfg = Release|x64
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release|x64.Build.0 = Release|x64
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release|x86.ActiveCfg = Release|Any CPU
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release|x86.Build.0 = Release|Any CPU
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release-MONO|Any CPU.ActiveCfg = Release|Any CPU
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release-MONO|Any CPU.Build.0 = Release|Any CPU
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release-MONO|x64.ActiveCfg = Release|x64
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release-MONO|x64.Build.0 = Release|x64
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release-MONO|x86.ActiveCfg = Release|Any CPU
-		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release-MONO|x86.Build.0 = Release|Any CPU
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug|x64.ActiveCfg = Debug|x64
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug|x64.Build.0 = Debug|x64
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug|x86.ActiveCfg = Debug|Any CPU
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug|x86.Build.0 = Debug|Any CPU
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug-MONO|x64.ActiveCfg = Debug|x64
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug-MONO|x64.Build.0 = Debug|x64
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug-MONO|x86.ActiveCfg = Debug|Any CPU
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug-MONO|x86.Build.0 = Debug|Any CPU
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release|Any CPU.Build.0 = Release|Any CPU
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release|x64.ActiveCfg = Release|x64
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release|x64.Build.0 = Release|x64
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release|x86.ActiveCfg = Release|Any CPU
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release|x86.Build.0 = Release|Any CPU
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release-MONO|Any CPU.ActiveCfg = Release|Any CPU
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release-MONO|Any CPU.Build.0 = Release|Any CPU
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release-MONO|x64.ActiveCfg = Release|x64
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release-MONO|x64.Build.0 = Release|x64
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release-MONO|x86.ActiveCfg = Release|Any CPU
-		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release-MONO|x86.Build.0 = Release|Any CPU
-	EndGlobalSection
-	GlobalSection(SolutionProperties) = preSolution
-		HideSolutionNode = FALSE
-	EndGlobalSection
-	GlobalSection(ExtensibilityGlobals) = postSolution
-		SolutionGuid = {F948D667-14E3-4F98-BA50-3F3C948BF4C2}
-	EndGlobalSection
-EndGlobal
diff --git a/MSBuild.Dev.slnf b/MSBuild.Dev.slnf
new file mode 100644
index 00000000000..1157c36a866
--- /dev/null
+++ b/MSBuild.Dev.slnf
@@ -0,0 +1,19 @@
+{
+  "solution": {
+    "path": "MSBuild.sln",
+    "projects": [
+      "src\\Build.OM.UnitTests\\Microsoft.Build.Engine.OM.UnitTests.csproj",
+      "src\\Build.UnitTests\\Microsoft.Build.Engine.UnitTests.csproj",
+      "src\\Build\\Microsoft.Build.csproj",
+      "src\\Framework.UnitTests\\Microsoft.Build.Framework.UnitTests.csproj",
+      "src\\Framework\\Microsoft.Build.Framework.csproj",
+      "src\\MSBuild.UnitTests\\Microsoft.Build.CommandLine.UnitTests.csproj",
+      "src\\MSBuild\\MSBuild.csproj",
+      "src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj",
+      "src\\Tasks\\Microsoft.Build.Tasks.csproj",
+      "src\\Utilities.UnitTests\\Microsoft.Build.Utilities.UnitTests.csproj",
+      "src\\Utilities\\Microsoft.Build.Utilities.csproj",
+      "src\\Xunit.NetCore.Extensions\\Xunit.NetCore.Extensions.csproj"
+    ]
+  }
+}
\ No newline at end of file
diff --git a/MSBuild.SourceBuild.sln b/MSBuild.SourceBuild.sln
deleted file mode 100644
index 7fb2942d65d..00000000000
--- a/MSBuild.SourceBuild.sln
+++ /dev/null
@@ -1,224 +0,0 @@
-﻿
-Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio 15
-VisualStudioVersion = 15.0.27004.2009
-MinimumVisualStudioVersion = 10.0.40219.1
-Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build", "src\Build\Microsoft.Build.csproj", "{69BE05E2-CBDA-4D27-9733-44E12B0F5627}"
-EndProject
-Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.Framework", "src\Framework\Microsoft.Build.Framework.csproj", "{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}"
-EndProject
-Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MSBuild", "src\MSBuild\MSBuild.csproj", "{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}"
-EndProject
-Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.Tasks", "src\Tasks\Microsoft.Build.Tasks.csproj", "{2AB5D52E-3C4D-4572-B140-9EED600ECE59}"
-EndProject
-Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.Utilities", "src\Utilities\Microsoft.Build.Utilities.csproj", "{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}"
-EndProject
-Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Localization", "src\Package\Localization\Localization.csproj", "{243181BA-73D1-4B14-BA29-EBB8D183F573}"
-EndProject
-Global
-	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|Any CPU = Debug|Any CPU
-		Debug|x64 = Debug|x64
-		Debug|x86 = Debug|x86
-		Debug-MONO|Any CPU = Debug-MONO|Any CPU
-		Debug-MONO|x64 = Debug-MONO|x64
-		Debug-MONO|x86 = Debug-MONO|x86
-		MachineIndependent|Any CPU = MachineIndependent|Any CPU
-		MachineIndependent|x64 = MachineIndependent|x64
-		MachineIndependent|x86 = MachineIndependent|x86
-		Release|Any CPU = Release|Any CPU
-		Release|x64 = Release|x64
-		Release|x86 = Release|x86
-		Release-MONO|Any CPU = Release-MONO|Any CPU
-		Release-MONO|x64 = Release-MONO|x64
-		Release-MONO|x86 = Release-MONO|x86
-	EndGlobalSection
-	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug|x64.ActiveCfg = Debug|x64
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug|x64.Build.0 = Debug|x64
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug|x86.ActiveCfg = Debug|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug|x86.Build.0 = Debug|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release|Any CPU.Build.0 = Release|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release|x64.ActiveCfg = Release|x64
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release|x64.Build.0 = Release|x64
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release|x86.ActiveCfg = Release|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release|x86.Build.0 = Release|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release-MONO|Any CPU.ActiveCfg = Release|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release-MONO|Any CPU.Build.0 = Release|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release-MONO|x64.ActiveCfg = Release|x64
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release-MONO|x64.Build.0 = Release|x64
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release-MONO|x86.ActiveCfg = Release|Any CPU
-		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release-MONO|x86.Build.0 = Release|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug|x64.ActiveCfg = Debug|x64
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug|x64.Build.0 = Debug|x64
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug|x86.ActiveCfg = Debug|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug|x86.Build.0 = Debug|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release|Any CPU.Build.0 = Release|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release|x64.ActiveCfg = Release|x64
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release|x64.Build.0 = Release|x64
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release|x86.ActiveCfg = Release|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release|x86.Build.0 = Release|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release-MONO|Any CPU.ActiveCfg = Release|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release-MONO|Any CPU.Build.0 = Release|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release-MONO|x64.ActiveCfg = Release|x64
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release-MONO|x64.Build.0 = Release|x64
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release-MONO|x86.ActiveCfg = Release|Any CPU
-		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release-MONO|x86.Build.0 = Release|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug|x64.ActiveCfg = Debug|x64
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug|x64.Build.0 = Debug|x64
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug|x86.ActiveCfg = Debug|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug|x86.Build.0 = Debug|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release|Any CPU.Build.0 = Release|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release|x64.ActiveCfg = Release|x64
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release|x64.Build.0 = Release|x64
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release|x86.ActiveCfg = Release|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release|x86.Build.0 = Release|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release-MONO|Any CPU.ActiveCfg = Release|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release-MONO|Any CPU.Build.0 = Release|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release-MONO|x64.ActiveCfg = Release|x64
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release-MONO|x64.Build.0 = Release|x64
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release-MONO|x86.ActiveCfg = Release|Any CPU
-		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release-MONO|x86.Build.0 = Release|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug|x64.ActiveCfg = Debug|x64
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug|x64.Build.0 = Debug|x64
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug|x86.ActiveCfg = Debug|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug|x86.Build.0 = Debug|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release|Any CPU.Build.0 = Release|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release|x64.ActiveCfg = Release|x64
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release|x64.Build.0 = Release|x64
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release|x86.ActiveCfg = Release|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release|x86.Build.0 = Release|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release-MONO|Any CPU.ActiveCfg = Release|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release-MONO|Any CPU.Build.0 = Release|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release-MONO|x64.ActiveCfg = Release|x64
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release-MONO|x64.Build.0 = Release|x64
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release-MONO|x86.ActiveCfg = Release|Any CPU
-		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release-MONO|x86.Build.0 = Release|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug|x64.ActiveCfg = Debug|x64
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug|x64.Build.0 = Debug|x64
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug|x86.ActiveCfg = Debug|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug|x86.Build.0 = Debug|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug-MONO|x64.ActiveCfg = Debug|x64
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug-MONO|x64.Build.0 = Debug|x64
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug-MONO|x86.ActiveCfg = Debug|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug-MONO|x86.Build.0 = Debug|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release|Any CPU.Build.0 = Release|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release|x64.ActiveCfg = Release|x64
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release|x64.Build.0 = Release|x64
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release|x86.ActiveCfg = Release|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release|x86.Build.0 = Release|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release-MONO|Any CPU.ActiveCfg = Release|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release-MONO|Any CPU.Build.0 = Release|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release-MONO|x64.ActiveCfg = Release|x64
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release-MONO|x64.Build.0 = Release|x64
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release-MONO|x86.ActiveCfg = Release|Any CPU
-		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release-MONO|x86.Build.0 = Release|Any CPU
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Debug|x64.ActiveCfg = Debug|x64
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Debug|x64.Build.0 = Debug|x64
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Debug|x86.ActiveCfg = Debug|Any CPU
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Debug|x86.Build.0 = Debug|Any CPU
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Release|Any CPU.Build.0 = Release|Any CPU
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Release|x64.ActiveCfg = Release|x64
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Release|x64.Build.0 = Release|x64
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Release|x86.ActiveCfg = Release|Any CPU
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Release|x86.Build.0 = Release|Any CPU
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Release-MONO|x64.Build.0 = Release-MONO|x64
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
-		{243181BA-73D1-4B14-BA29-EBB8D183F573}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
-	EndGlobalSection
-	GlobalSection(SolutionProperties) = preSolution
-		HideSolutionNode = FALSE
-	EndGlobalSection
-	GlobalSection(ExtensibilityGlobals) = postSolution
-		SolutionGuid = {F948D667-14E3-4F98-BA50-3F3C948BF4C2}
-	EndGlobalSection
-EndGlobal
diff --git a/MSBuild.SourceBuild.slnf b/MSBuild.SourceBuild.slnf
new file mode 100644
index 00000000000..d69d4de7ab3
--- /dev/null
+++ b/MSBuild.SourceBuild.slnf
@@ -0,0 +1,14 @@
+{
+  "solution": {
+    "path": "MSBuild.sln",
+    "projects": [
+      "src\\Build\\Microsoft.Build.csproj",
+      "src\\Framework\\Microsoft.Build.Framework.csproj",
+      "src\\MSBuild\\MSBuild.csproj",
+      "src\\Package\\Localization\\Localization.csproj",
+      "src\\Tasks\\Microsoft.Build.Tasks.csproj",
+      "src\\Utilities\\Microsoft.Build.Utilities.csproj",
+      "src\\StringTools\\StringTools.csproj"
+    ]
+  }
+}
\ No newline at end of file
diff --git a/MSBuild.sln b/MSBuild.sln
index 966817afd12..74de884bad7 100644
--- a/MSBuild.sln
+++ b/MSBuild.sln
@@ -1,7 +1,7 @@
 ﻿
 Microsoft Visual Studio Solution File, Format Version 12.00
 # Visual Studio Version 16
-VisualStudioVersion = 16.0.30320.27
+VisualStudioVersion = 16.0.30413.136
 MinimumVisualStudioVersion = 10.0.40219.1
 Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{4900B3B8-4310-4D5B-B1F7-2FDF9199765F}"
 	ProjectSection(SolutionItems) = preProject
@@ -65,8 +65,18 @@ Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MSBuild.Engine.Corext", "sr
 EndProject
 Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MSBuild.Bootstrap", "src\MSBuild.Bootstrap\MSBuild.Bootstrap.csproj", "{CEAEE4FE-9298-443B-AFC5-0F72472484B6}"
 EndProject
+Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "StringTools", "src\StringTools\StringTools.csproj", "{639C178E-368F-4384-869E-7C6D18B4CC1F}"
+EndProject
+Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "StringTools.UnitTests", "src\StringTools.UnitTests\StringTools.UnitTests.csproj", "{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}"
+EndProject
+Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "StringTools.UnitTests.net35", "src\StringTools.UnitTests\StringTools.UnitTests.net35.csproj", "{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}"
+EndProject
 Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.UnGAC", "src\Package\Microsoft.Build.UnGAC\Microsoft.Build.UnGAC.csproj", "{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}"
 EndProject
+Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "ProjectCachePlugin", "src\Samples\ProjectCachePlugin\ProjectCachePlugin.csproj", "{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}"
+EndProject
+Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "StringTools.Benchmark", "src\StringTools.Benchmark\StringTools.Benchmark.csproj", "{65749C80-47E7-42FE-B441-7A86289D46AA}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
@@ -836,6 +846,96 @@ Global
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug|x64.ActiveCfg = Debug|x64
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug|x64.Build.0 = Debug|x64
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug|x86.ActiveCfg = Debug|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug|x86.Build.0 = Debug|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release|Any CPU.Build.0 = Release|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release|x64.ActiveCfg = Release|x64
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release|x64.Build.0 = Release|x64
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release|x86.ActiveCfg = Release|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release|x86.Build.0 = Release|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release-MONO|x64.Build.0 = Release-MONO|x64
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug|x64.ActiveCfg = Debug|x64
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug|x64.Build.0 = Debug|x64
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug|x86.ActiveCfg = Debug|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug|x86.Build.0 = Debug|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release|Any CPU.Build.0 = Release|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release|x64.ActiveCfg = Release|x64
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release|x64.Build.0 = Release|x64
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release|x86.ActiveCfg = Release|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release|x86.Build.0 = Release|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release-MONO|x64.Build.0 = Release-MONO|x64
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug|x64.ActiveCfg = Debug|x64
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug|x64.Build.0 = Debug|x64
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug|x86.ActiveCfg = Debug|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug|x86.Build.0 = Debug|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release|Any CPU.Build.0 = Release|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release|x64.ActiveCfg = Release|x64
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release|x64.Build.0 = Release|x64
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release|x86.ActiveCfg = Release|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release|x86.Build.0 = Release|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release-MONO|x64.Build.0 = Release-MONO|x64
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|x64.ActiveCfg = Debug|x64
@@ -866,6 +966,66 @@ Global
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug|x64.ActiveCfg = Debug|x64
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug|x64.Build.0 = Debug|x64
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug|x86.ActiveCfg = Debug|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug|x86.Build.0 = Debug|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release|Any CPU.Build.0 = Release|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release|x64.ActiveCfg = Release|x64
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release|x64.Build.0 = Release|x64
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release|x86.ActiveCfg = Release|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release|x86.Build.0 = Release|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release-MONO|x64.Build.0 = Release-MONO|x64
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug|x64.ActiveCfg = Debug|x64
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug|x64.Build.0 = Debug|x64
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug|x86.ActiveCfg = Debug|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug|x86.Build.0 = Debug|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release|Any CPU.Build.0 = Release|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release|x64.ActiveCfg = Release|x64
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release|x64.Build.0 = Release|x64
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release|x86.ActiveCfg = Release|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release|x86.Build.0 = Release|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release-MONO|x64.Build.0 = Release-MONO|x64
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
@@ -883,6 +1043,7 @@ Global
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9} = {9BAD9352-DEFB-45E5-B8A4-4816B9B22A33}
 		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7} = {9BAD9352-DEFB-45E5-B8A4-4816B9B22A33}
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F} = {9BAD9352-DEFB-45E5-B8A4-4816B9B22A33}
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943} = {760FF85D-8BEB-4992-8095-A9678F88FD47}
 	EndGlobalSection
 	GlobalSection(ExtensibilityGlobals) = postSolution
 		SolutionGuid = {F948D667-14E3-4F98-BA50-3F3C948BF4C2}
diff --git a/NuGet.config b/NuGet.config
index cda7383f71e..cfa8997361c 100644
--- a/NuGet.config
+++ b/NuGet.config
@@ -2,12 +2,8 @@
 <configuration>
   <packageSources>
     <clear />
-    <add key="dotnet-core" value="https://dotnetfeed.blob.core.windows.net/dotnet-core/index.json" />
     <add key="arcade" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json" />
-    <add key="nuget.org" value="https://api.nuget.org/v3/index.json" />
-    <add key="roslyn" value="https://dotnet.myget.org/F/roslyn/api/v3/index.json" />
-    <add key="nuget-build" value="https://dotnet.myget.org/F/nuget-build/api/v3/index.json" />
-    <add key="roslyn-tools" value="https://dotnet.myget.org/F/roslyn-tools/api/v3/index.json" />
+    <add key="dotnet-public" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public/nuget/v3/index.json" />
     <add key="dotnet-tools" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json" />
   </packageSources>
   <disabledPackageSources />
diff --git a/README.md b/README.md
index 799a130a51b..631504a1702 100644
--- a/README.md
+++ b/README.md
@@ -6,13 +6,13 @@ For more information on MSBuild, see the [MSBuild documentation](https://docs.mi
 
 ### Build Status
 
-The current development branch is `master`. Changes in `master` will go into a future update of MSBuild, which will release with Visual Studio 16.9 and a corresponding version of the .NET Core SDK.
+The current development branch is `master`. Changes in `master` will go into a future update of MSBuild, which will release with Visual Studio 16.10 and a corresponding version of the .NET Core SDK.
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=master)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=master)
 
-We have forked for MSBuild 16.8 in the branch [`vs16.8`](https://github.com/Microsoft/msbuild/tree/vs16.8). Changes to that branch need special approval.
+We have forked for MSBuild 16.9 in the branch [`vs16.9`](https://github.com/Microsoft/msbuild/tree/vs16.9). Changes to that branch need special approval.
 
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.8)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=vs16.8)
+[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.9)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=vs16.9)
 
 MSBuild 16.7 builds from the branch [`vs16.7`](https://github.com/Microsoft/msbuild/tree/vs16.7). Only high-priority bugfixes will be considered for servicing 16.7.
 
@@ -22,10 +22,6 @@ MSBuild 16.4 builds from the branch [`vs16.4`](https://github.com/Microsoft/msbu
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.4)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=vs16.4)
 
-MSBuild 16.0 builds from the branch [`vs16.0`](https://github.com/Microsoft/msbuild/tree/vs16.0). Only high-priority bugfixes will be considered for servicing 16.0.
-
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.0)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=vs16.0)
-
 MSBuild 15.9 builds from the branch [`vs15.9`](https://github.com/Microsoft/msbuild/tree/vs15.9). Only very-high-priority bugfixes will be considered for servicing 15.9.
 
 ## Building
@@ -43,7 +39,7 @@ To get started on **Visual Studio 2019**:
 3. Clone the source code: `git clone https://github.com/Microsoft/msbuild.git`
   - You may have to [download Git](https://git-scm.com/downloads) first.
 4. Run `.\build.cmd` from the root of the repo to build the code. This also restores packages needed to open the projects in Visual Studio.
-5. Open `MSBuild.sln` or `MSBuild.Dev.sln` in Visual Studio 2019.
+5. Open `MSBuild.sln` or `MSBuild.Dev.slnf` in Visual Studio 2019.
 
 Note: To create a usable MSBuild with your changes, run `.\build.cmd /p:CreateBootstrap=true`.
 
diff --git a/documentation/ProjectReference-Protocol.md b/documentation/ProjectReference-Protocol.md
index f464ca17374..8f6a76fd036 100644
--- a/documentation/ProjectReference-Protocol.md
+++ b/documentation/ProjectReference-Protocol.md
@@ -61,6 +61,7 @@ If implementing a project with an “outer” (determine what properties to pass
   * The `GetReferenceNearestTargetFrameworkTask` (provided by NuGet) is responsible for selecting the best matching `TargetFramework` of the referenced project
   * This target is _optional_. If not present, the reference will be built with no additional properties.
   * **New** in MSBuild 15.5.  (`TargetFrameworkMonikers` and `TargetPlatformMonikers` metadata is new in MSBuild 16.8)
+  * It is possible to gather additional information from referenced projects.  See the below section on "Getting additional properties from referenced projects" for more information
 * `GetTargetFrameworkProperties` determines what properties should be passed to the “main” target for a given `ReferringTargetFramework`.
   * **Deprecated** in MSBuild 15.5.
   * New for MSBuild 15/Visual Studio 2017. Supports the cross-targeting feature allowing a project to have multiple `TargetFrameworks`.
@@ -91,3 +92,31 @@ As with all MSBuild logic, targets can be added to do other work with `ProjectRe
 In particular, NuGet depends on being able to identify referenced projects' package dependencies, and calls some targets that are imported through `Microsoft.Common.targets` to do so. At the time of writing this this is in [`NuGet.targets`](https://github.com/NuGet/NuGet.Client/blob/79264a74262354c1a8f899c2c9ddcaff58afaf62/src/NuGet.Core/NuGet.Build.Tasks/NuGet.targets).
 
 `Microsoft.AppxPackage.targets` adds a dependency on the target `GetPackagingOutputs`.
+
+## Getting additional properties from referenced projects
+
+As of MSBuild 16.10, it is possible to gather additional properties from referenced projects.  To do this, the referenced project should declare an `AdditionalTargetFrameworkInfoProperty` item for each property that should be gathered for referencing projects.  For example:
+
+```xml
+  <ItemGroup>
+    <AdditionalTargetFrameworkInfoProperty Include="SelfContained"/>
+    <AdditionalTargetFrameworkInfoProperty Include="_IsExecutable"/>
+  </ItemGroup>
+```
+
+These properties will then be gathered via the `GetTargetFrameworks` call.  They will be available to the referencing project via the `AdditionalPropertiesFromProject` metadata on the `_MSBuildProjectReferenceExistent` item.  The `AdditionalPropertiesFromProject` value will be an XML string which contains the values of the properties for each `TargetFramework` in the referenced project.  For example:
+
+```xml
+<AdditionalProjectProperties>
+  <net5.0>
+    <SelfContained>true</SelfContained>
+    <_IsExecutable>true</_IsExecutable>
+  </net5.0>
+  <net5.0-windows>
+    <SelfContained>false</SelfContained>
+    <_IsExecutable>true</_IsExecutable>
+  </net5.0-windows>
+</AdditionalProjectProperties>
+```
+
+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.
\ No newline at end of file
diff --git a/documentation/specs/project-cache.md b/documentation/specs/project-cache.md
new file mode 100644
index 00000000000..a9da734d26f
--- /dev/null
+++ b/documentation/specs/project-cache.md
@@ -0,0 +1,132 @@
+- [Summary](#summary)
+- [Motivation](#motivation)
+- [Plugin requirements](#plugin-requirements)
+- [High-level design](#high-level-design)
+- [APIs and calling patterns](#apis-and-calling-patterns)
+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)
+  - [From command line](#from-command-line)
+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)
+- [Details](#details)
+- [Caveats](#caveats)
+- [Future work](#future-work)
+- [Potential work of dubious value](#potential-work-of-dubious-value)
+
+# Summary
+
+Project cache is a new assembly-based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and/or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).
+
+# Motivation
+
+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, large and complex repos expose the weaknesses in MSBuild's scheduling and incrementality models as build times elongate. This project cache plugin lets MSBuild natively communicate with existing tools that enable build caching and/or distribution, enabling true scalability.
+
+Visual Studio is one beneficiary. This plugin inverts dependencies among build systems: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild calls into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.
+
+This change also simplifies and unifies user experiences. MSBuild works the same from Visual Studio or the command line without dramatically changing how it works.
+
+# Plugin requirements
+
+- The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:
+  - it makes the filesystem look as if the project built
+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.
+
+# High-level design
+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.
+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.
+- If the plugin decides to build, then MSBuild proceeds building the project as usual.
+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.
+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.
+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).
+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.
+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.
+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.
+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.
+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the "graph" when static graph is not available).
+- A single plugin is supported (for now).
+
+# APIs and calling patterns
+- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).
+
+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.
+- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.
+  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.
+- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.
+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.
+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.
+- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.
+
+## From command line
+- Requires /graph. It is the easiest way to implement the plugin:
+  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.
+  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.
+- User calls msbuild /graph.
+- MSBuild constructs the static graph.
+- The graph builder finds and loads the plugin into the `BuildManager`.
+  - Each graph node has a ProjectInstance, which is used to search for the plugin.
+  - If a project defines a plugin, then all projects in the graph must define that same plugin.
+  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).
+- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.
+  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.
+
+## From Visual Studio, a temporary workaround
+- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:
+  - The workaround logic activates only when MSBuild detects that it's running under VS.
+  - Plugin discovery
+    - When VS evaluates projects via "new Project(..)" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.
+  - Plugin usage:
+    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.
+
+# Details
+- Plugin discovery
+  - Each project defines an item containing the path to the plugin DLL:
+```xml
+<ProjectCachePlugin Include="..\..\QuickbuildProjectCachePlugin.dll">
+```
+- Plugin acquisition
+  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.
+- Defining the "graph" when static graph is not available
+  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.
+  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.
+    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.
+- Returning a valid BuildResult object on cache hits.
+  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).
+  - Plugins have three options:
+    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.
+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/ProjectReference-Protocol.md) for more details.
+      - Proxy target assumptions:
+        - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).
+        - They do not mutate state (file system, environment variables, etc).
+        - They do not MSBuild task call into other projects.
+      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.
+    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.
+      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.
+      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.
+- Configuring plugins
+  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.
+```xml
+<ProjectCachePlugin Update="@(ProjectCachePlugin)" setting1="val1" setting2="val2" />
+```
+- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):
+  - From command line: `msbuild /graph:NoBuild`
+  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`
+- Logging
+  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.
+  - Log messages from querying a project get parented under that project's logging context.
+    - This is not yet implemented. For now, all plugin log messages do not have a parent event context.
+
+# Caveats
+- Absolute paths circulating through the saved build results
+  - Absolute paths will likely break the build, since they'd be captured on the machine that writes to the cache.
+- Slow connections. In a coffee shop it might be faster to build everything instead of downloading from the cache. Consider racing plugin checks and building: if the bottom up build traversal reaches a node that's still querying the cache, cancel the cache query and build the node instead.
+- Inferring what targets to run on each node when using /graph
+  - Msbuild /graph requires that the [target inference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#inferring-which-targets-to-run-for-a-project-within-the-graph) is good enough.
+- Small repos will probably be slower with plugin implementations that access the network. Remote distribution and caching will only be worth it for repos that are large enough.
+
+# Future work
+- On cache misses plugins can build the project with IO monitoring and write to the local cache. As far as we can tell there are two main possibilities:
+  - plugins build the projects themselves in isolation (without projects building their reference, probably by setting `BuildProjectReferences` to false) by calling msbuild.exe.
+  - plugins request msbuild to build the projects on special out of proc nodes whose IO system calls can be monitored.
+
+# Potential work of dubious value
+- Allow multiple plugin instances and query them based on some priority, similar to sdk resolvers.
+- Enable plugins to work with the just-in-time top down msbuild traversal that msbuild natively does when it's not using `/graph`.
+- Extend the project cache API to allow skipping individual targets or tasks instead of entire projects. This would allow for smaller specialized plugins, like plugins that only know to distribute, cache, and skip CSC.exe calls.
diff --git a/documentation/specs/static-graph-implementation-details.md b/documentation/specs/static-graph-implementation-details.md
new file mode 100644
index 00000000000..4845fff794d
--- /dev/null
+++ b/documentation/specs/static-graph-implementation-details.md
@@ -0,0 +1,59 @@
+- [Single project isolated builds: implementation details](#single-project-isolated-builds-implementation-details)
+  - [Input / Output cache implementation](#input--output-cache-implementation)
+  - [Isolation implementation](#isolation-implementation)
+    - [How isolation exemption complicates everything](#how-isolation-exemption-complicates-everything)
+
+# Single project isolated builds: implementation details
+
+<!-- workflow -->
+Single project isolated builds can be achieved by providing MSBuild with input and output cache files.
+
+The input cache files contain the cached results of all the targets that a project calls on its references. When a project builds without isolation, it builds its references via [MSBuild task](aka.ms/msbuild_tasks) calls. In isolated builds, the engine, instead of executing these tasks, serves their results from the provided input caches. In an isolated project build, only the top level project (built via the BuildManager APIs) should build targets. Any referenced projects by the top level project should be provided from the input caches.
+
+The output cache file tells MSBuild where to serialize the results of building the current project. This output cache becomes an input cache for all other projects that depend on the current project.
+The output cache file can be omitted in which case the build reuses prior results but does not write out any new results. This is useful when one wants to re-execute the build for a project without building its references.
+
+The presence of either input or output caches turns on [isolated build constraints](static-graph.md##single-project-isolated-builds).
+
+## Input / Output cache implementation
+<!-- cache structure -->
+The cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results. For example, it is these caches which ensure that a target is only built once per build submission. The `ConfigCache` entries are instances of [BuildRequestConfiguration](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25). The `ResultsCache` entries are instances of [BuildResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34), which contain or more instances of [TargetResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22). 
+
+One can view the two caches as the following mapping: `(project path, global properties) -> results`. `(project path, global properties)` is represented by a `BuildRequestConfiguration`, and the results are represented by `BuildResult` and `TargetResult`.
+
+<!-- cache lifetime -->
+The input and output cache files have the same lifetime as the `ConfigCache` and the `ResultsCache`. The `ConfigCache` and the `ResultsCache` are owned by the [BuildManager](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/BuildManager/BuildManager.cs), and their lifetimes are one `BuildManager.BeginBuild` / `BuildManager.EndBuild` session. On commandline builds, since MSBuild.exe uses one BuildManager with one BeginBuild / EndBuild session, the cache lifetime is the same as the entire process lifetime. When other processes (e.g. Visual Studio's devenv.exe) perform msbuild builds via the `BuildManager` APIs, there can be multiple build sessions in the same process.
+
+<!-- constraints -->
+
+When MSBuild is loading input cache files, it has to merge multiple incoming instances of `ConfigCache` and `ResultsCache` into one instance of each. The [CacheAggregator](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/BuildManager/CacheAggregator.cs#L13) is responsible for stitching together the pairs of deserialized `ConfigCache`/`ResultsCache` entries from each input cache file.
+The following constraints are enforced during cache aggregation:
+- For each input cache, `ConfigCache.Entries.Size == ResultsCache.Entries.Size`
+- For each input cache, there is exactly one mapping from ConfigCache to ResultsCache (on `BuildResult.ConfigurationId` == `BuildRequestConfiguration.ConfigurationId`)
+- Colliding configurations (defined as tuples of `(project path, global properties)`) get their corresponding BuildResult entries merged at the level of TargetResult entries. TargetResult conflicts are handled via the "first one wins" strategy. This is in line with vanilla msbuild's behaviour where a target tuple of `(project path, global properties, target)` gets executed only once.
+
+The output cache file **only contains results for additional work performed in the current BeginBuild / EndBuild session**. Entries from input caches are not transferred to the output cache.
+
+<!-- How input / output cache entries are separated with the override caches -->
+Entries that make it into the output cache file are separated from entries serialized from input cache files via the use of [ConfigCacheWithOverride](https://github.com/microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [ResultsCacheWithOverride](https://github.com/microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). These are composite caches. Each contains two underlying caches: a cache where input caches files are loaded into (called the override cache), and a cache where new results are written into (called the current cache). Cache reads are satisified from both underlying caches (override cache is queried first, current cache is queried second). Writes are only written to the current cache, never into the override cache. The output cache file only contains the serialized current cache, and not the override cache, thus ensuring that only newly built results are serialized in the output cache file. It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache read.
+
+## Isolation implementation
+
+[Isolation constraints](static-graph.md##single-project-isolated-builds) are implemented in the Scheduler and the TaskBuilder. [TaskBuilder.ExecuteInstantiatedTask](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs#L743) ensures that the `MSBuild` task is only called on projects declared in `ProjectReference`. [Scheduler.CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L1818) ensures that all `MSBuild` tasks are cache hits.
+
+### How isolation exemption complicates everything
+<!-- Potential cache scenarios caused by exemption -->
+Project references [can be exempt](static-graph.md#exempting-references-from-isolation-constraints) from isolation constraints via the `GraphIsolationExemptReference` item.
+
+The `Scheduler` knows to skip isolation constraints on an exempt `BuildRequest` because the [ProjectBuilder compares](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs#L349) each new `BuildRequest` against the `GraphIsolationExemptReference` items defined in the calling project, and if exempt, sets `BuildRequest.SkipStaticGraphIsolationConstraints`. When a `BuildRequest` is marked as exempt, the `Scheduler` also marks its corresponding `BuildRequestConfiguration` as exempt as well, which aids in further identification of exempt projects outside the `Scheduler`.
+
+The build results for the exempt project are also included in the current cache (according to the above mentioned rule that newly built results are serialized in the output cache file). This complicates the way caches interact in several scenarios:
+1. the same project can be exempt via multiple references, thus potentially colliding when multiple output cache files containing the same exempt project get aggregated. For example, given the graph `{A->B, A->C}`, where both `B` and `C` build the exempt project `D`, `D` will appear in the output caches of both `B` and `C`. When `A` aggregates these two caches, it will encounter duplicate entries for `D`, and will need to merge the results.
+2. a project can be both exempt and present in the graph at the same time. For example, given the graph `{A->B}`, both `A` and `B` are in the graph, but `A` can also mark `B` as exempt (meaning that `A` contains both a `ProjectReference` item to `B`, and a `GraphIsolationExemptReference` item to `B`). The fact that `B` is in the graph means that `A` will receive an input cache containing B's build results. There are two subcases here:
+   1.  `A` builds targets from `B` that already exist in the input cache file from `B`. In this case, all the builds of `B` will be cache hits, and no target results from `B` will make it into `A`'s output cache, since nothing new was built.
+   2.  `A` builds targets from `B` that do not exist in the input cache file from `B`. If `B` weren't exempt from isolation constraints, this scenario would lead to a build break, as cache misses are illegal under isolation. With `B` being exempt, the new builds of `B` will get included in `A`'s output cache. The results from `B`'s cache file won't get included in `A`'s output cache file, as they weren't built by `A`.
+3. A project, which is not in the graph, can be exempt by two parent/child projects from the graph. For example, given the graph `{A->B}`, both `A` and `B` can exempt project `D` (meaning that neither `A` nor `B` have a `ProjectReference` to `D`, but both `A` and `B` have a `GraphIsolationExemptReference` to `D`). The fact that `B` is in the graph means that `A` will receive an input cache containing `B`'s build results. Since `B` builds targets from `D`, it means that `B`'s output cache file also contains target results from `D`. There are two subcases here:
+   1. `A` builds targets from `D` that already exist in the input cache file from `B`. This is handled in the same way as the above case `2.1.`
+   2. `A` builds targets from `D` that do not exist in the input cache file from `B`, meaning that `A` builds additional targets from `D` which `B` didn't build. This is handled in the same way as teh above case `2.2.`
+
+**Current issue:** if multiple nodes in the graph exempt the same project file, the build results of the exempt project will trickle up and conflict in the first parent that tries to merge them. Documented in issue [#4386](https://github.com/dotnet/msbuild/issues/4386).
diff --git a/documentation/specs/static-graph.md b/documentation/specs/static-graph.md
index 240db807df2..6e4527a7470 100644
--- a/documentation/specs/static-graph.md
+++ b/documentation/specs/static-graph.md
@@ -9,9 +9,12 @@
   - [Design documentation](#design-documentation)
     - [Design goals](#design-goals)
   - [Project Graph](#project-graph)
+    - [Constructing the project graph](#constructing-the-project-graph)
     - [Build dimensions](#build-dimensions)
       - [Multitargeting](#multitargeting)
-    - [Building a project graph](#building-a-project-graph)
+    - [Executing targets on a graph](#executing-targets-on-a-graph)
+      - [Command line](#command-line)
+      - [APIs](#apis)
     - [Inferring which targets to run for a project within the graph](#inferring-which-targets-to-run-for-a-project-within-the-graph)
       - [Multitargeting details](#multitargeting-details)
     - [Underspecified graphs](#underspecified-graphs)
@@ -19,9 +22,9 @@
   - [Isolated builds](#isolated-builds)
     - [Isolated graph builds](#isolated-graph-builds)
     - [Single project isolated builds](#single-project-isolated-builds)
-    - [Single project isolated builds: implementation details](#single-project-isolated-builds-implementation-details)
-      - [APIs](#apis)
-      - [Command line](#command-line)
+      - [APIs](#apis-1)
+      - [Command line](#command-line-1)
+      - [Exempting references from isolation constraints](#exempting-references-from-isolation-constraints)
   - [I/O Tracking](#io-tracking)
     - [Detours](#detours)
     - [Isolation requirement](#isolation-requirement)
@@ -112,11 +115,15 @@ Static graph functionality can be used in three ways:
 
 ## Project Graph
 
+### Constructing the project graph
 Calculating the project graph will be very similar to the MS internal build engine's existing Traversal logic. For a given evaluated project, all project references will be identified and recursively evaluated (with deduping).
 Project references are identified via the `ProjectReference` item.
 
 A node in the graph is a tuple of the project file and global properties. Each (project, global properties) combo can be evaluated in parallel.
 
+Transitive project references are opt-in per project. Once a project opts-in, transitivity is applied for all ProjectReference items.
+A project opt-ins by setting the property `AddTransitiveProjectReferencesInStaticGraph` to true.
+
 ### Build dimensions
 
 Build dimensions can be thought of as different ways to build a particular project. For example, a project can be built Debug or Retail, x86 or x64, for .NET Framework 4.7.1 or .NET Core 2.0.
@@ -179,7 +186,7 @@ To summarize, there are two main patterns for build dimensions which are handled
 1. The project multitargets, in which case the SDK needs to specify the multitargeting build dimensions.
 2. A different set of global properties are used to choose the dimension like with Configuration or Platform. The project graph supports this via multiple entry points.
 
-### Building a project graph
+### Executing targets on a graph
 When building a graph, project references should be built before the projects that reference them, as opposed to the existing msbuild scheduler which builds projects just in time.
 
 For example if project A depends on project B, then project B should build first, then project A. Existing msbuild scheduling would start building project A, reach an MSBuild task for project B, yield project A, build project B, then resume project A once unblocked.
@@ -188,6 +195,13 @@ Building in this way should make better use of parallelism as all CPU cores can
 
 Note that graph cycles are disallowed, even if they're using disconnected targets. This is a breaking change, as today you can have two projects where each project depends on a target from the other project, but that target doesn't depend on the default target or anything in its target graph.
 
+#### Command line
+`msbuild /graph` - msbuild will create a static graph from the entry point project and build it in topological order with the specified targets. Targets to call on each node are inferred via the rules in [this section](#inferring-which-targets-to-run-for-a-project-within-the-graph).
+
+#### APIs
+
+[BuildManager.PendBuildRequest(GraphBuildRequestData requestData)](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/BuildManager/BuildManager.cs#L676)
+
 ### Inferring which targets to run for a project within the graph
 In the classic traversal, the referencing project chooses which targets to call on the referenced projects and may call into a project multiple times with different target lists and global properties (examples in [project reference protocol](../ProjectReference-Protocol.md)). When building a graph, where projects are built before the projects that reference them, we have to determine the target list to execute on each project statically.
 
@@ -375,56 +389,50 @@ Because referenced projects and their entry targets are guaranteed to be in the
 ### Isolated graph builds
 When building a graph in isolated mode, the graph is used to traverse and build the projects in the right order, but each individual project is built in isolation. The build result cache will just be in memory exactly as it is today, but on cache miss it will error. This enforces that both the graph and target mappings are complete and correct.
 
-Furthermore, running in this mode enforces that each (project, global properties) pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.
+Furthermore, running in this mode enforces that each (project, global properties) pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some potential perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.
 
 This discrete start and end time also allows for easy integration with [I/O Tracking](#io-tracking) to observe all inputs and outputs for a project. Note however that I/O during target execution, particular target execution which may not normally happen as part of a project's individual build execution, would be attributed to the project reference project rather the project with the project reference. This differs from today's behavior, but seems like a desirable difference anyway.
 
 ### Single project isolated builds
 When building a single project in isolation, all project references' build results must be provided to the project externally. Specifically, the results will need to be [deserialized](#deserialization) from files and loaded into the build result cache in memory.
 
-Because of this, single project isolated builds is quite restrictive and is not intended to be used directly by end-users. Instead the scenario is intended for higher-order build engines which support caching and [distribution](#distribution).
-
-There is also the possibility for these higher-order build engines and even Visual Studio to enable extremely fast incremental builds for a project. For example, when all project references' build results are provided (and validated as up to date by that higher-order build engine), there is no need to evaluate or execute any targets on any other project.
-
-These incremental builds can even be extended to multiple projects by keeping a project graph in memory as well as the last build result for each node and whether that build result is valid. The higher-order build engine can then itself traverse the graph and do single project isolated builds for projects which are not currently up to date.
+When MSBuild runs in isolation mode, it fails the build when it detects:
+1. `MSBuild` task calls which cannot be served from the cache. Cache misses are illegal.
+2. `MSBuild` task calls to project files which were not defined in the `ProjectReference` item.
 
-### Single project isolated builds: implementation details
-
-<!-- workflow -->
-Single project builds can be achieved by providing MSBuild with input and output cache files.
+Because of this, single project isolated builds is quite restrictive and is not intended to be used directly by end-users. Instead the scenario is intended for higher-order build engines which support caching and [distribution](#distribution).
 
-The input cache files contain the cached results of all of the current project's references. This way, when the current project executes, it will naturally build its references via [MSBuild task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) calls. The engine, instead of executing these tasks, will serve them from the provided input caches.
+There is also the possibility for these higher-order build engines and even Visual Studio to enable faster incremental builds for a project. For example, when a project's references' build results are provided via file caches (and validated as up to date by that higher-order build engine), there is no need to evaluate or execute any targets for any reference.
 
-The output cache file tells MSBuild where it should serialize the results of the current project. This output cache would become an input cache for all other projects that depend on the current project.
-The output cache file can be ommited in which case the build would just reuse prior results but not write out any new results. This could be useful when one wants to replay a build from previous caches.
+These incremental builds could be extended to the entire graph by keeping a project graph in memory as well as the last build result cache files for each node and whether a node's results are up to date. The higher-order build engine can then itself traverse the graph and do single project isolated builds only for projects which are not currently up to date.
 
-The presence of either input or output caches turns on the isolated build constraints. The engine will fail the build on:
-- `MSBuild` task calls to project files which were not defined in the `ProjectReference` item at evaluation time.
-- `MSBuild` task calls which cannot be served from the cache
+Details on how isolation and cache files are implemented in MSBuild can be found [here](./static-graph-implementation-details.md).
 
-<!-- cache structure -->
-These cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results.
+#### APIs
+Cache file information is provided via [BuildParameters](https://github.com/Microsoft/msbuild/blob/2d4dc592a638b809944af10ad1e48e7169e40808/src/Build/BackEnd/BuildManager/BuildParameters.cs#L746-L764). Input caches are applied in `BuildManager.BeginBuild`. Output cache files are written in `BuildManager.EndBuild`. Thus, the scope of the caches are one BuildManager BeginBuild/EndBuild session.
 
-Cache structure: `(project path, global properties) -> results`
+Isolation constraints are turned on via [BuildParameters.IsolateProjects](https://github.com/microsoft/msbuild/blob/b111470ae61eba02c6102374c2b7d62aebe45f5b/src/Build/BackEnd/BuildManager/BuildParameters.cs#L742). Isolation constraints are also automatically turned on if either input or output cache files are used.
 
-<!-- cache lifetime -->
-The caches are applicable for the entire duration of the MSBuild.exe process. The input and output caches have the same lifetime as the `ConfigCache` and the `ResultsCache`. The `ConfigCache` and the `ResultsCache` are owned by the [BuildManager](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/BuildManager/BuildManager.cs), and their lifetimes are one `BuildManager.BeginBuild` / `BuildManager.EndBuild` session. Since MSBuild.exe uses one BuildManager with one BeginBuild / EndBuild session, the cache lifetime is the same as the entire process lifetime.
+#### Command line
+Caches are provided to MSBuild.exe via the multi value `/inputResultsCaches` and the single value `/outputResultsCache`.
+Isolation constraints are turned on via `/isolate` (they are also implicitly activated when either input or output caches are used).
 
-<!-- constraints -->
-The following are cache file constraints enforced by the engine.
+#### Exempting references from isolation constraints
+In certain situations one may want to exempt a reference from isolation constraints. A few potential cases:
+- debugging / onboarding to isolation constraints
+- exempting references whose project files are generated at build times with random names (for example, each WPF project, before the Build target, generates and builds a helper .csproj with a random file name)
+- relaxing constraints for MSBuild task calling patterns that static graph cannot express (for exemple, if a project is calculating references, or the targets to call on references, at runtime via an arbitrary algorithm)
 
-Input cache files constraints:
-- A ConfigCache / ResultsCache mapping must be unique between all input caches (multiple input caches cannot provide information for the same cache entry)
-- For each input cache, `ConfigCache.Entries.Size == ResultsCache.Entries.Size`
-- For each input cache, there is exactly one mapping from ConfigCache to ResultsCache
+A project is exempt from isolation constraints by adding its full path to the `GraphIsolationExemptReference` item. For example, if project A.csproj references project B.csproj, the following snippet exempts B.csproj from isolation constraints while A.csproj is built:
+```xml
+<ItemGroup>
+  <GraphIsolationExemptReference Include="/Full/Path/To/B.csproj" />
+</ItemGroup>
+```
 
-Output cache file constraints:
-- the output cache file contains results only for additional work performed in the current BeginBuild / EndBuild session. Entries from input caches are not transferred to the output cache.
+A reference is exempt only in projects that add the reference in `GraphIsolationExemptReference`. If multiple projects need to exempt the same reference, all of them need to add the reference to `GraphIsolationExemptReference`.
 
-#### APIs
-Caches are provided via [BuildParameters](https://github.com/Microsoft/msbuild/blob/2d4dc592a638b809944af10ad1e48e7169e40808/src/Build/BackEnd/BuildManager/BuildParameters.cs#L746-L764). They are applied in `BuildManager.BeginBuild`
-#### Command line
-Caches are provided to MSBuild.exe via the multi value `/inputResultsCaches` and the single value `/outputResultsCache`.
+For now, self-builds (a project building itself with different global properties) are also exempt from isolation constraints, but this behaviour is of dubious value and might be changed in the future.
 
 ## I/O Tracking
 To help facilitate caching of build outputs by a higher-order build engine, MSBuild needs to track all I/O that happens as part of a build.
diff --git a/documentation/specs/threading.md b/documentation/specs/threading.md
new file mode 100644
index 00000000000..935e96cf141
--- /dev/null
+++ b/documentation/specs/threading.md
@@ -0,0 +1,17 @@
+# Threading in MSBuild Worker Nodes
+
+MSBuild can build multiple projects in parallel with the `-m` switch. This launches many worker processes (**nodes**) and assigns work to them. Each is generally dedicated to building a single project at a time.
+
+Projects can have dependencies on other projects. This is often represented with `@(ProjectReference)` items, but can be more complex--a dependency is created when a task calls the `IBuildEngine.BuildProjectFile` method or an equivalent. When this happens, the project is _blocked_: it cannot progress until the request it generated is built.
+
+While a project is blocked, the node that was building it can do work on other projects. The build engine will save project-specific state like environment variables and current working directory and then do something else (if the scheduler has work to assign to it).
+
+This is logically single-threaded, via a continuation model: a node is building a single chain of things, which may be suspended and continued after building another project in the same thread. The thread used to do this work is named `RequestBuilder thread`. It is not the main thread of the process because some other work goes on in parallel, like inter-process communication.
+
+It is sometimes useful to be able to do computational work within one project while *also* freeing up the node to do work on another project. When this is desired, a task can call `IBuildEngine3.Yield()` to indicate that the node can do other work until it calls `IBuildEngine3.Reacquire()`.
+
+When a project is _yielded_, the node is also yielded. The scheduler may then decide to assign additional work to the node. If it does so, the node will start a new RequestBuilder thread to do the new work, because the original thread will still be running the task code between `Yield()` and `Reacquire()`.
+
+The scheduler limits the amount of total work being done, including both executing and yielded nodes, to attempt to avoid starting too much parallel work and bogging down the operating system. As a result, it's rare for a single node to have more than two or three RequestBuilder threads, though there is no hard bound on the number of threads in a single node.
+
+If multiple RequestBuilder threads have been started and are idle in a single worker node, any of them may be used when a request is assigned to that node (or unblocked).
diff --git a/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md b/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
index 40caef7e8f9..d7d81600bef 100644
--- a/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
+++ b/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
@@ -13,13 +13,13 @@ All command lines should be executed from a Visual Studio developer command prom
 1. Clone the repo: `git clone https://github.com/Microsoft/msbuild.git`
 2. Build on the command line: `.\build.cmd`
    1. If you encounter errors, see [Something's wrong in my build](Something's-wrong-in-my-build.md).
-3. Open the solution file in Visual Studio (`MSBuild.Dev.sln`).
+3. Open the solution file in Visual Studio (`MSBuild.Dev.slnf`).
 
 ## Running Unit Tests
 
 To run the unit tests from Visual Studio:
 
-1. Open the MSBuild solution file (`MSBuild.Dev.sln`) in Visual Studio.
+1. Open the MSBuild solution file (`MSBuild.Dev.slnf`) in Visual Studio.
 2. Open the Test menu -> Windows -> Test Explorer.
 3. Click Run All.
 
diff --git a/documentation/wiki/ChangeWaves-Dev.md b/documentation/wiki/ChangeWaves-Dev.md
index 66d80097213..a3cfdbcd93f 100644
--- a/documentation/wiki/ChangeWaves-Dev.md
+++ b/documentation/wiki/ChangeWaves-Dev.md
@@ -24,22 +24,22 @@ The Process:
 6. [Delete the wave as it cycles out](#change-wave-'end-of-lifespan'-procedure)
 
 ## Creating a Change Wave
-1. In the `Microsoft.Build` project, open `SharedUtilities\ChangeWaves.cs`.
-2. Add a const string to identify the new wave, following the format:
+1. In the `Microsoft.Build.Framework` project, open `ChangeWaves.cs`.
+2. Add a static readonly Version to identify the new wave, following the format:
 ```c#
-public const string Wave17_4 = "17.4";
+public static readonly Version Wave17_4 = new Version(17, 4);
 ```
 3. You may need to delete the lowest wave as new waves get added.
 4. Update the AllWaves array appropriately.
 ```c#
-public static readonly string[] AllWaves = { Wave16_10, Wave17_0, Wave17_4 };
+public static readonly Version[] AllWaves = { Wave16_10, Wave17_0, Wave17_4 };
 ```
 
 ## Condition Your Feature On A Change Wave
 Surround your feature with the following:
 ```c#
     // If you pass an incorrectly formatted change wave, this will throw.
-    // Use the const Version that was created in the previous step.
+    // Use the readonly Version that was created in the previous step.
     if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
     {
         <your feature>
@@ -55,11 +55,13 @@ If you need to condition a Task or Target, use the built in `AreFeaturesEnabled`
 ## Test Your Feature
 Create tests as you normally would. Include one test with environment variable `MSBuildDisableFeaturesFromVersion` set to `ChangeWaves.Wave17_4`. Set this like so:
 ```c#
-TestEnvironment env = TestEnvironment.Create()
+using TestEnvironment env = TestEnvironment.Create();
 
-env.SetChangeWave(ChangeWaves.Wave17_4);
+ChangeWaves.ResetStateForTests();
+// Important: use the version here
+env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_4.ToString());
+BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
 ```
-When the TestEnvironment is disposed, it handles special logic to properly reset Change Waves for future tests.
 
 **Important!** If you need to build a project to test your feature (say, for tasks or targets), build via `ProjectCollection` in your test.
 
@@ -67,8 +69,9 @@ Example:
 ```c#
 using (TestEnvironment env = TestEnvironment.Create())
 {
-    // Important: use the constant here
-    env.SetChangeWave(ChangeWaves.Wave17_4);
+    ChangeWaves.ResetStateForTests();
+    env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_4.ToString());
+    BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
 
     string projectFile = @"
         <Project>
@@ -90,7 +93,7 @@ using (TestEnvironment env = TestEnvironment.Create())
 
 ## Change Wave 'End-of-Lifespan' Procedure
 These features will eventually become standard functionality. When a change wave rotates out, do the following:
-1. Start by deleting the constant `Wave17_4` that was created in [Creating a Change Wave](#creating-a-change-wave).
+1. Start by deleting the readonly `Wave17_4` that was created in [Creating a Change Wave](#creating-a-change-wave).
 2. Remove `ChangeWave.AreFeaturesEnabled` or `[MSBuild]::AreFeaturesEnabled` conditions surrounding features that were assigned that change wave.
 3. Remove tests associated with ensuring features would not run if this wave were set.
-4. Clear all other issues that arose from deleting the constant.
+4. Clear all other issues that arose from deleting the version.
diff --git a/eng/Packages.props b/eng/Packages.props
index ebd0d0e551f..c4ae1af44ed 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -1,10 +1,11 @@
 <Project>
   <ItemGroup>
+    <PackageReference Update="BenchmarkDotNet" Version="0.12.1" />
     <PackageReference Update="jnm2.ReferenceAssemblies.net35" Version="1.0.1" />
     <PackageReference Update="LargeAddressAware" Version="1.0.3" />
     <PackageReference Update="Microsoft.Build.NuGetSdkResolver" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="Microsoft.CodeAnalysis.Build.Tasks" Version="$(MicrosoftNetCompilersToolsetVersion)" />
-    <PackageReference Update="Microsoft.DotNet.BuildTools.GenAPI" Version="2.1.0-prerelease-02404-02" />
+    <PackageReference Update="Microsoft.DotNet.GenAPI" Version="2.1.0-prerelease-02404-02" />
     <PackageReference Update="Microsoft.Extensions.DependencyModel" Version="2.1.0" />
     <PackageReference Update="Microsoft.Net.Compilers.Toolset" Version="$(MicrosoftNetCompilersToolsetVersion)" />
     <PackageReference Update="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.15" />
@@ -16,22 +17,11 @@
     <PackageReference Update="Shouldly" Version="3.0.0" />
     <PackageReference Update="SourceLink.Create.CommandLine" Version="2.1.2" />
     <PackageReference Update="System.CodeDom" Version="4.4.0" />
-    <PackageReference Update="System.Collections.Concurrent" Version="4.3.0" />
     <PackageReference Update="System.Collections.Immutable" Version="5.0.0" />
-    <PackageReference Update="System.Diagnostics.TraceSource" Version="4.0.0" />
-    <PackageReference Update="System.IO.Compression" Version="4.3.0" />
-    <PackageReference Update="System.IO.FileSystem.Primitives" Version="4.3.0" />
-    <PackageReference Update="System.Linq.Parallel" Version="4.0.1" />
     <PackageReference Update="System.Memory" Version="4.5.4" />
-    <PackageReference Update="System.Net.Http" Version="4.3.4" />
     <PackageReference Update="System.Reflection.Metadata" Version="1.6.0" />
-    <PackageReference Update="System.Reflection.TypeExtensions" Version="4.1.0" />
     <PackageReference Update="System.Resources.Extensions" Version="4.6.0" />
-    <PackageReference Update="System.Resources.Writer" Version="4.0.0" />
-    <PackageReference Update="System.Runtime.InteropServices" Version="4.3.0" />
-    <PackageReference Update="System.Runtime.InteropServices.RuntimeInformation" Version="4.3.0" />
-    <PackageReference Update="System.Runtime.Loader" Version="4.0.0" />
-    <PackageReference Update="System.Runtime.Serialization.Primitives" Version="4.1.1" />
+    <PackageReference Update="System.Runtime.CompilerServices.Unsafe" Version="5.0.0"/>
     <PackageReference Update="System.Security.Cryptography.Pkcs" Version="4.7.0" />
     <PackageReference Update="System.Security.Cryptography.Xml" Version="4.7.0" />
     <PackageReference Update="System.Security.Permissions" Version="4.7.0" />
@@ -39,13 +29,15 @@
     <PackageReference Update="System.Text.Encoding.CodePages" Version="4.0.1" />
     <PackageReference Update="System.Text.Json" Version="4.7.0" />
     <PackageReference Update="System.Threading.Tasks.Dataflow" Version="4.9.0" />
-    <PackageReference Update="System.Threading.Thread" Version="4.0.0" />
-    <PackageReference Update="System.Xml.XPath" Version="4.3.0" />
     <PackageReference Update="xunit.assert" Version="$(XUnitVersion)" />
     <PackageReference Update="xunit.console" Version="$(XUnitVersion)" />
     <PackageReference Update="xunit.core" Version="$(XUnitVersion)" />
   </ItemGroup>
 
+  <ItemGroup Condition="'$(MonoBuild)' == 'true' or $([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'netcoreapp2.1'))">
+    <PackageReference Update="Microsoft.Extensions.DependencyModel" Version="5.0.0"/>
+  </ItemGroup>
+
   <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true'">
     <GlobalPackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="1.0.0" PrivateAssets="All"/>
   </ItemGroup>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 32ddd405d96..caf93915568 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,17 +1,17 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="1.0.0-beta.20580.3">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="5.0.0-beta.21112.3">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>7ee8c2b620e66b3762d7a5a688dee8238770c86a</Sha>
+      <Sha>d8c68c834bcca3f721ad1550404807e301ba7afe</Sha>
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="5.9.0-preview.2.6967">
-      <Uri>https://github.com/NuGet/NuGet.Client</Uri>
-      <Sha>a4c9d63bf942f1df1ba9486a87bad2e4b6888488</Sha>
+    <Dependency Name="NuGet.Build.Tasks" Version="5.9.0-rc.7097">
+      <Uri>https://dev.azure.com/devdiv/DevDiv/_git/NuGet-NuGet.Client-Trusted</Uri>
+      <Sha>ed9af679b4425c1ff4d41d2302d73f6e580a2839</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="3.9.0-2.20574.26">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha />
+      <Sha>e9fd4dc7d74932c0d4b042251bc5a88bb5b3c437</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index a3a255f0129..3916d33cc6a 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -1,21 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
-  <Import Project="$(DotNetRestoreSourcePropsPath)" Condition="'$(DotNetRestoreSourcePropsPath)' != ''" />
   <PropertyGroup>
-    <RestoreSources>$(DotNetRestoreSources)</RestoreSources>
-    <RestoreSources Condition="'$(DotNetBuildOffline)' != 'true'">
-        $(RestoreSources);
-        https://dotnetfeed.blob.core.windows.net/dotnet-core/index.json;
-        https://dotnet.myget.org/F/roslyn/api/v3/index.json;
-        https://dotnet.myget.org/F/nuget-build/api/v3/index.json;
-        https://dotnet.myget.org/F/roslyn-tools/api/v3/index.json;
-        https://dotnet.myget.org/F/dotnet-buildtools/api/v3/index.json
-    </RestoreSources>
-    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
-  </PropertyGroup>
-  <PropertyGroup>
-    <VersionPrefix>16.9.0</VersionPrefix>
+    <VersionPrefix>16.10.0</VersionPrefix>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
@@ -36,9 +23,11 @@
   </PropertyGroup>
   <!-- Toolset Dependencies -->
   <PropertyGroup>
-    <DotNetCliVersion>3.1.100</DotNetCliVersion>
-    <MicrosoftNetCompilersToolsetVersion>3.3.1-beta3-final</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>5.9.0-preview.2.6967</NuGetBuildTasksVersion>
+    <!-- DotNetCliVersion MUST match the dotnet version in global.json.
+         Otherwise, this version of dotnet will not be installed and the build will error out. -->
+    <DotNetCliVersion>5.0.102</DotNetCliVersion>
+    <MicrosoftNetCompilersToolsetVersion>3.9.0-2.20574.26</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>5.9.0-rc.7097</NuGetBuildTasksVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/eng/cibuild_bootstrapped_msbuild.ps1 b/eng/cibuild_bootstrapped_msbuild.ps1
index ca978944bd6..8fb7f590527 100644
--- a/eng/cibuild_bootstrapped_msbuild.ps1
+++ b/eng/cibuild_bootstrapped_msbuild.ps1
@@ -95,7 +95,7 @@ try {
   else
   {
     $buildToolPath = $dotnetExePath
-    $buildToolCommand = Join-Path $bootstrapRoot "netcoreapp2.1\MSBuild\MSBuild.dll"
+    $buildToolCommand = Join-Path $bootstrapRoot "net5.0\MSBuild\MSBuild.dll"
     $buildToolFramework = "netcoreapp2.1"
   }
 
diff --git a/eng/cibuild_bootstrapped_msbuild.sh b/eng/cibuild_bootstrapped_msbuild.sh
index 6688317ada3..23987f994d9 100755
--- a/eng/cibuild_bootstrapped_msbuild.sh
+++ b/eng/cibuild_bootstrapped_msbuild.sh
@@ -62,7 +62,7 @@ bootstrapRoot="$Stage1Dir/bin/bootstrap"
 if [ $host_type = "core" ]
 then
   _InitializeBuildTool="$_InitializeDotNetCli/dotnet"
-  _InitializeBuildToolCommand="$bootstrapRoot/netcoreapp2.1/MSBuild/MSBuild.dll"
+  _InitializeBuildToolCommand="$bootstrapRoot/net5.0/MSBuild/MSBuild.dll"
   _InitializeBuildToolFramework="netcoreapp2.1"
 elif [ $host_type = "mono" ]
 then
diff --git a/eng/common/CheckSymbols.ps1 b/eng/common/CheckSymbols.ps1
deleted file mode 100644
index b8d84607b89..00000000000
--- a/eng/common/CheckSymbols.ps1
+++ /dev/null
@@ -1,158 +0,0 @@
-param(
-  [Parameter(Mandatory=$true)][string] $InputPath,       # Full path to directory where NuGet packages to be checked are stored
-  [Parameter(Mandatory=$true)][string] $ExtractPath,     # Full path to directory where the packages will be extracted during validation
-  [Parameter(Mandatory=$true)][string] $SymbolToolPath   # Full path to directory where dotnet symbol-tool was installed
-)
-
-Add-Type -AssemblyName System.IO.Compression.FileSystem
-
-function FirstMatchingSymbolDescriptionOrDefault {
-  param( 
-    [string] $FullPath,                  # Full path to the module that has to be checked
-    [string] $TargetServerParam,         # Parameter to pass to `Symbol Tool` indicating the server to lookup for symbols
-    [string] $SymbolsPath
-  )
-
-  $FileName = [System.IO.Path]::GetFileName($FullPath)
-  $Extension = [System.IO.Path]::GetExtension($FullPath)
-
-  # Those below are potential symbol files that the `dotnet symbol` might
-  # return. Which one will be returned depend on the type of file we are
-  # checking and which type of file was uploaded.
-
-  # The file itself is returned
-  $SymbolPath = $SymbolsPath + "\" + $FileName
-
-  # PDB file for the module
-  $PdbPath = $SymbolPath.Replace($Extension, ".pdb")
-
-  # PDB file for R2R module (created by crossgen)
-  $NGenPdb = $SymbolPath.Replace($Extension, ".ni.pdb")
-
-  # DBG file for a .so library
-  $SODbg = $SymbolPath.Replace($Extension, ".so.dbg")
-
-  # DWARF file for a .dylib
-  $DylibDwarf = $SymbolPath.Replace($Extension, ".dylib.dwarf")
- 
-  .\dotnet-symbol.exe --symbols --modules --windows-pdbs $TargetServerParam $FullPath -o $SymbolsPath | Out-Null
-
-  if (Test-Path $PdbPath) {
-    return "PDB"
-  }
-  elseif (Test-Path $NGenPdb) {
-    return "NGen PDB"
-  }
-  elseif (Test-Path $SODbg) {
-    return "DBG for SO"
-  }  
-  elseif (Test-Path $DylibDwarf) {
-    return "Dwarf for Dylib"
-  }  
-  elseif (Test-Path $SymbolPath) {
-    return "Module"
-  }
-  else {
-    return $null
-  }
-}
-
-function CountMissingSymbols {
-  param( 
-    [string] $PackagePath          # Path to a NuGet package
-  )
-
-  # Ensure input file exist
-  if (!(Test-Path $PackagePath)) {
-    throw "Input file does not exist: $PackagePath"
-  }
-  
-  # Extensions for which we'll look for symbols
-  $RelevantExtensions = @(".dll", ".exe", ".so", ".dylib")
-
-  # How many files are missing symbol information
-  $MissingSymbols = 0
-
-  $PackageId = [System.IO.Path]::GetFileNameWithoutExtension($PackagePath)
-  $PackageGuid = New-Guid
-  $ExtractPath = Join-Path -Path $ExtractPath -ChildPath $PackageGuid
-  $SymbolsPath = Join-Path -Path $ExtractPath -ChildPath "Symbols"
-  
-  [System.IO.Compression.ZipFile]::ExtractToDirectory($PackagePath, $ExtractPath)
-
-  # Makes easier to reference `symbol tool`
-  Push-Location $SymbolToolPath
-
-  Get-ChildItem -Recurse $ExtractPath |
-    Where-Object {$RelevantExtensions -contains $_.Extension} |
-    ForEach-Object {
-      if ($_.FullName -Match "\\ref\\") {
-        Write-Host "`t Ignoring reference assembly file" $_.FullName
-        return
-      }
-
-      $SymbolsOnMSDL = FirstMatchingSymbolDescriptionOrDefault $_.FullName "--microsoft-symbol-server" $SymbolsPath
-      $SymbolsOnSymWeb = FirstMatchingSymbolDescriptionOrDefault $_.FullName "--internal-server" $SymbolsPath
-
-      Write-Host -NoNewLine "`t Checking file" $_.FullName "... "
-  
-      if ($SymbolsOnMSDL -ne $null -and $SymbolsOnSymWeb -ne $null) {
-        Write-Host "Symbols found on MSDL (" $SymbolsOnMSDL ") and SymWeb (" $SymbolsOnSymWeb ")"
-      }
-      else {
-        $MissingSymbols++
-
-        if ($SymbolsOnMSDL -eq $null -and $SymbolsOnSymWeb -eq $null) {
-          Write-Host "No symbols found on MSDL or SymWeb!"
-        }
-        else {
-          if ($SymbolsOnMSDL -eq $null) {
-            Write-Host "No symbols found on MSDL!"
-          }
-          else {
-            Write-Host "No symbols found on SymWeb!"
-          }
-        }
-      }
-    }
-  
-  Pop-Location
-
-  return $MissingSymbols
-}
-
-function CheckSymbolsAvailable {
-  if (Test-Path $ExtractPath) {
-    Remove-Item $ExtractPath -Force  -Recurse -ErrorAction SilentlyContinue
-  }
-
-  Get-ChildItem "$InputPath\*.nupkg" |
-    ForEach-Object {
-      $FileName = $_.Name
-	  
-      # These packages from Arcade-Services include some native libraries that
-      # our current symbol uploader can't handle. Below is a workaround until
-      # we get issue: https://github.com/dotnet/arcade/issues/2457 sorted.
-      if ($FileName -Match "Microsoft\.DotNet\.Darc\.") {
-        Write-Host "Ignoring Arcade-services file: $FileName"
-        Write-Host
-        return
-      }
-      elseif ($FileName -Match "Microsoft\.DotNet\.Maestro\.Tasks\.") {
-        Write-Host "Ignoring Arcade-services file: $FileName"
-        Write-Host
-        return
-      }
-	  
-      Write-Host "Validating $FileName "
-      $Status = CountMissingSymbols "$InputPath\$FileName"
-  
-      if ($Status -ne 0) {
-        Write-Error "Missing symbols for $Status modules in the package $FileName"
-      }
-
-      Write-Host
-    }
-}
-
-CheckSymbolsAvailable
diff --git a/eng/common/PublishToPackageFeed.proj b/eng/common/PublishToPackageFeed.proj
deleted file mode 100644
index a1b1333723e..00000000000
--- a/eng/common/PublishToPackageFeed.proj
+++ /dev/null
@@ -1,83 +0,0 @@
-<!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the LICENSE file in the project root for more information. -->
-<Project Sdk="Microsoft.NET.Sdk">
-  <!--
-    This MSBuild file is intended to be used as the body of the default 
-    publishing release pipeline. The release pipeline will use this file
-    to invoke the PushToStaticFeed task that will read the build asset
-    manifest and publish the assets described in the manifest to
-    informed target feeds.
-  -->
-
-  <PropertyGroup>
-    <TargetFramework>netcoreapp2.1</TargetFramework>
-  </PropertyGroup>
-
-  <Import Project="$(MSBuildThisFileDirectory)DefaultVersions.props" Condition="Exists('$(MSBuildThisFileDirectory)DefaultVersions.props')" />
-
-  <!--
-    This won't be necessary once we solve this issue:
-    https://github.com/dotnet/arcade/issues/2266
-  -->
-  <Import Project="$(MSBuildThisFileDirectory)ArtifactsCategory.props" Condition="Exists('$(MSBuildThisFileDirectory)ArtifactsCategory.props')" />
-  
-  <Import Project="$(NuGetPackageRoot)microsoft.dotnet.build.tasks.feed\$(MicrosoftDotNetBuildTasksFeedVersion)\build\Microsoft.DotNet.Build.Tasks.Feed.targets" />
-
-  <Target Name="PublishToFeed">
-    <Error Condition="'$(ArtifactsCategory)' == ''" Text="ArtifactsCategory: The artifacts' category produced by the build wasn't provided." />
-    <Error Condition="'$(AccountKeyToStaticFeed)' == ''" Text="AccountKeyToStaticFeed: Account key for target feed wasn't provided." />
-    <Error Condition="'$(ManifestsBasePath)' == ''" Text="Full path to asset manifests directory wasn't provided." />
-    <Error Condition="'$(BlobBasePath)' == '' AND '$(PackageBasePath)' == ''" Text="A valid full path to BlobBasePath of PackageBasePath is required." />
-
-    <ItemGroup>
-      <!-- Include all manifests found in the manifest folder. -->
-      <ManifestFiles Include="$(ManifestsBasePath)*.xml" />
-    </ItemGroup>
-
-    <Error Condition="'@(ManifestFiles)' == ''" Text="No manifest file was found in the provided path: $(ManifestsBasePath)" />
-
-    <!--
-      For now the type of packages being published will be informed for the whole build.
-      Eventually this will be specified on a per package basis:
-      TODO: https://github.com/dotnet/arcade/issues/2266
-    -->
-    <PropertyGroup>
-      <TargetStaticFeed Condition="'$(ArtifactsCategory.ToUpper())' == '.NETCORE'">https://dotnetfeed.blob.core.windows.net/dotnet-core/index.json</TargetStaticFeed>
-      <TargetStaticFeed Condition="'$(ArtifactsCategory.ToUpper())' == '.NETCOREVALIDATION'">https://dotnetfeed.blob.core.windows.net/arcade-validation/index.json</TargetStaticFeed>
-      <TargetStaticFeed Condition="'$(ArtifactsCategory.ToUpper())' == 'ASPNETCORE'">https://dotnetfeed.blob.core.windows.net/aspnet-aspnetcore/index.json</TargetStaticFeed>
-      <TargetStaticFeed Condition="'$(ArtifactsCategory.ToUpper())' == 'ASPNETCORETOOLING'">https://dotnetfeed.blob.core.windows.net/aspnet-aspnetcore-tooling/index.json</TargetStaticFeed>
-      <TargetStaticFeed Condition="'$(ArtifactsCategory.ToUpper())' == 'ENTITYFRAMEWORKCORE'">https://dotnetfeed.blob.core.windows.net/aspnet-entityframeworkcore/index.json</TargetStaticFeed>
-      <TargetStaticFeed Condition="'$(ArtifactsCategory.ToUpper())' == 'ASPNETEXTENSIONS'">https://dotnetfeed.blob.core.windows.net/aspnet-extensions/index.json</TargetStaticFeed>
-      <TargetStaticFeed Condition="'$(ArtifactsCategory.ToUpper())' == 'CORECLR'">https://dotnetfeed.blob.core.windows.net/dotnet-coreclr/index.json</TargetStaticFeed>
-      <TargetStaticFeed Condition="'$(ArtifactsCategory.ToUpper())' == 'CORESDK'">https://dotnetfeed.blob.core.windows.net/dotnet-sdk/index.json</TargetStaticFeed>
-      <TargetStaticFeed Condition="'$(ArtifactsCategory.ToUpper())' == 'TOOLSINTERNAL'">https://dotnetfeed.blob.core.windows.net/dotnet-tools-internal/index.json</TargetStaticFeed>
-      <TargetStaticFeed Condition="'$(ArtifactsCategory.ToUpper())' == 'TOOLSET'">https://dotnetfeed.blob.core.windows.net/dotnet-toolset/index.json</TargetStaticFeed>
-      <TargetStaticFeed Condition="'$(ArtifactsCategory.ToUpper())' == 'WINDOWSDESKTOP'">https://dotnetfeed.blob.core.windows.net/dotnet-windowsdesktop/index.json</TargetStaticFeed>
-      <TargetStaticFeed Condition="'$(ArtifactsCategory.ToUpper())' == 'NUGETCLIENT'">https://dotnetfeed.blob.core.windows.net/nuget-nugetclient/index.json</TargetStaticFeed>
-      <TargetStaticFeed Condition="'$(ArtifactsCategory.ToUpper())' == 'ASPNETENTITYFRAMEWORK6'">https://dotnetfeed.blob.core.windows.net/aspnet-entityframework6/index.json</TargetStaticFeed>
-      <TargetStaticFeed Condition="'$(ArtifactsCategory.ToUpper())' == 'ASPNETBLAZOR'">https://dotnetfeed.blob.core.windows.net/aspnet-blazor/index.json</TargetStaticFeed>
-    </PropertyGroup>
-
-    <Error 
-      Condition="'$(TargetStaticFeed)' == ''" 
-      Text="'$(ArtifactsCategory)' wasn't recognized as a valid artifact category. Valid categories are: '.NetCore' and '.NetCoreValidation'" />
-
-    <!-- Iterate publishing assets from each manifest file. -->
-    <PushArtifactsInManifestToFeed
-      ExpectedFeedUrl="$(TargetStaticFeed)"
-      AccountKey="$(AccountKeyToStaticFeed)"
-      BARBuildId="$(BARBuildId)"
-      MaestroApiEndpoint="$(MaestroApiEndpoint)"
-      BuildAssetRegistryToken="$(BuildAssetRegistryToken)"
-      Overwrite="$(OverrideAssetsWithSameName)"
-      PassIfExistingItemIdentical="$(PassIfExistingItemIdentical)"
-      MaxClients="$(MaxParallelUploads)"
-      UploadTimeoutInMinutes="$(MaxUploadTimeoutInMinutes)"
-      AssetManifestPath="%(ManifestFiles.Identity)"
-      BlobAssetsBasePath="$(BlobBasePath)"
-      PackageAssetsBasePath="$(PackageBasePath)"/>
-  </Target>
-
-  <ItemGroup>
-    <PackageReference Include="Microsoft.DotNet.Build.Tasks.Feed" Version="$(MicrosoftDotNetBuildTasksFeedVersion)" />
-  </ItemGroup>
-</Project>
diff --git a/eng/common/PublishToSymbolServers.proj b/eng/common/PublishToSymbolServers.proj
deleted file mode 100644
index 5d55e312b01..00000000000
--- a/eng/common/PublishToSymbolServers.proj
+++ /dev/null
@@ -1,82 +0,0 @@
-<!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the LICENSE file in the project root for more information. -->
-<Project Sdk="Microsoft.NET.Sdk">
-  <!--
-    This MSBuild file is intended to be used as the body of the default 
-    publishing release pipeline. The release pipeline will use this file
-    to invoke the PublishSymbols tasks to publish symbols to MSDL and SymWeb.
-  
-    Parameters:
-  
-      - PDBArtifactsDirectory   : Full path to directory containing PDB files to be published.
-      - BlobBasePath            : Full path containing *.symbols.nupkg packages to be published.
-      - DotNetSymbolServerTokenMsdl   : PAT to access MSDL.
-      - DotNetSymbolServerTokenSymWeb : PAT to access SymWeb.
-      - DotNetSymbolExpirationInDays  : Expiration days for published packages. Default is 3650.
-  -->
-
-  <PropertyGroup>
-    <TargetFramework>netcoreapp2.1</TargetFramework>
-  </PropertyGroup>
-
-  <Import Project="$(NuGetPackageRoot)microsoft.symboluploader.build.task\$(SymbolUploaderVersion)\build\PublishSymbols.targets" />
-    
-  <Target Name="PublishSymbols">
-    <ItemGroup>
-      <FilesToPublishToSymbolServer Include="$(PDBArtifactsDirectory)\*.pdb"/>
-      <PackagesToPublishToSymbolServer Include="$(BlobBasePath)\*.symbols.nupkg"/>
-
-      <!--
-        These packages from Arcade-Services include some native libraries that
-        our current symbol uploader can't handle. Below is a workaround until
-        we get issue: https://github.com/dotnet/arcade/issues/2457 sorted.
-      -->
-      <PackagesToPublishToSymbolServer Remove="$(BlobBasePath)\Microsoft.DotNet.Darc.*" />
-      <PackagesToPublishToSymbolServer Remove="$(BlobBasePath)\Microsoft.DotNet.Maestro.Tasks.*" />
-    </ItemGroup>
-
-    <PropertyGroup>
-      <DotNetSymbolExpirationInDays Condition="'$(DotNetSymbolExpirationInDays)' == ''">3650</DotNetSymbolExpirationInDays>
-      <PublishToSymbolServer>true</PublishToSymbolServer>
-      <PublishToSymbolServer Condition="'@(FilesToPublishToSymbolServer)' == '' and '@(PackagesToPublishToSymbolServer)' == ''">false</PublishToSymbolServer>
-    </PropertyGroup>
-
-    <Message
-      Importance="High"
-      Text="No symbol package(s) were found to publish." 
-      Condition="$(PublishToSymbolServer) == false" />
-    
-    <!-- Symbol Uploader: MSDL -->
-    <Message Importance="High" Text="Publishing symbol packages to MSDL ..." Condition="$(PublishToSymbolServer)" />
-    <PublishSymbols PackagesToPublish="@(PackagesToPublishToSymbolServer)"
-                    FilesToPublish="@(FilesToPublishToSymbolServer)"
-                    PersonalAccessToken="$(DotNetSymbolServerTokenMsdl)"
-                    SymbolServerPath="https://microsoftpublicsymbols.artifacts.visualstudio.com/DefaultCollection"
-                    ExpirationInDays="$(DotNetSymbolExpirationInDays)"
-                    VerboseLogging="true"
-                    DryRun="false"
-                    ConvertPortablePdbsToWindowsPdbs="false"
-                    PdbConversionTreatAsWarning=""
-                    Condition="$(PublishToSymbolServer)"/>
-
-    <!-- 
-      Symbol Uploader: SymWeb 
-      Watson, VS insertion testings and the typical internal dev usage require SymWeb.
-      Currently we need to call the task twice (https://github.com/dotnet/core-eng/issues/3489).
-    -->
-    <Message Importance="High" Text="Publishing symbol packages to SymWeb ..." Condition="$(PublishToSymbolServer)" />
-    <PublishSymbols PackagesToPublish="@(PackagesToPublishToSymbolServer)"
-                    FilesToPublish="@(FilesToPublishToSymbolServer)"
-                    PersonalAccessToken="$(DotNetSymbolServerTokenSymWeb)"
-                    SymbolServerPath="https://microsoft.artifacts.visualstudio.com/DefaultCollection"
-                    ExpirationInDays="$(DotNetSymbolExpirationInDays)"
-                    VerboseLogging="true"
-                    DryRun="false"
-                    ConvertPortablePdbsToWindowsPdbs="false"
-                    PdbConversionTreatAsWarning=""
-                    Condition="$(PublishToSymbolServer)"/>
-  </Target>
-
-  <ItemGroup>
-    <PackageReference Include="Microsoft.SymbolUploader.Build.Task" Version="$(SymbolUploaderVersion)" />
-  </ItemGroup>
-</Project>
diff --git a/eng/common/SetupNugetSources.ps1 b/eng/common/SetupNugetSources.ps1
index 83218ad7e72..a0b5fc37f43 100644
--- a/eng/common/SetupNugetSources.ps1
+++ b/eng/common/SetupNugetSources.ps1
@@ -146,16 +146,16 @@ $userName = "dn-bot"
 # Insert credential nodes for Maestro's private feeds
 InsertMaestroPrivateFeedCredentials -Sources $sources -Creds $creds -Username $userName -Password $Password
 
-$dotnet3Source = $sources.SelectSingleNode("add[@key='dotnet3']")
-if ($dotnet3Source -ne $null) {
-    AddPackageSource -Sources $sources -SourceName "dotnet3-internal" -SourceEndPoint "https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3-internal/nuget/v2" -Creds $creds -Username $userName -Password $Password
-    AddPackageSource -Sources $sources -SourceName "dotnet3-internal-transport" -SourceEndPoint "https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3-internal-transport/nuget/v2" -Creds $creds -Username $userName -Password $Password
-}
-
 $dotnet31Source = $sources.SelectSingleNode("add[@key='dotnet3.1']")
 if ($dotnet31Source -ne $null) {
     AddPackageSource -Sources $sources -SourceName "dotnet3.1-internal" -SourceEndPoint "https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal/nuget/v2" -Creds $creds -Username $userName -Password $Password
     AddPackageSource -Sources $sources -SourceName "dotnet3.1-internal-transport" -SourceEndPoint "https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-transport/nuget/v2" -Creds $creds -Username $userName -Password $Password
 }
 
-$doc.Save($filename)
\ No newline at end of file
+$dotnet5Source = $sources.SelectSingleNode("add[@key='dotnet5']")
+if ($dotnet5Source -ne $null) {
+    AddPackageSource -Sources $sources -SourceName "dotnet5-internal" -SourceEndPoint "https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet5-internal/nuget/v2" -Creds $creds -Username $userName -Password $Password
+    AddPackageSource -Sources $sources -SourceName "dotnet5-internal-transport" -SourceEndPoint "https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet5-internal-transport/nuget/v2" -Creds $creds -Username $userName -Password $Password
+}
+
+$doc.Save($filename)
diff --git a/eng/common/SetupNugetSources.sh b/eng/common/SetupNugetSources.sh
index 751863d5006..2734601c13c 100644
--- a/eng/common/SetupNugetSources.sh
+++ b/eng/common/SetupNugetSources.sh
@@ -81,53 +81,52 @@ fi
 
 PackageSources=()
 
-# Ensure dotnet3-internal and dotnet3-internal-transport are in the packageSources if the public dotnet3 feeds are present
-grep -i "<add key=\"dotnet3\"" $ConfigFile
-
+# Ensure dotnet3.1-internal and dotnet3.1-internal-transport are in the packageSources if the public dotnet3.1 feeds are present
+grep -i "<add key=\"dotnet3.1\"" $ConfigFile
 if [ "$?" == "0" ]; then
-    grep -i "<add key=\"dotnet3-internal\">" $ConfigFile
+    grep -i "<add key=\"dotnet3.1-internal\"" $ConfigFile
     if [ "$?" != "0" ]; then
-        echo "Adding dotnet3-internal to the packageSources."
+        echo "Adding dotnet3.1-internal to the packageSources."
         PackageSourcesNodeFooter="</packageSources>"
-        PackageSourceTemplate="${TB}<add key=\"dotnet3-internal\" value=\"https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3-internal/nuget/v2\" />"
+        PackageSourceTemplate="${TB}<add key=\"dotnet3.1-internal\" value=\"https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal/nuget/v2\" />"
 
         sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
     fi
-    PackageSources+=('dotnet3-internal')
+    PackageSources+=('dotnet3.1-internal')
 
-    grep -i "<add key=\"dotnet3-internal-transport\"" $ConfigFile
+    grep -i "<add key=\"dotnet3.1-internal-transport\">" $ConfigFile
     if [ "$?" != "0" ]; then
-        echo "Adding dotnet3-internal-transport to the packageSources."
+        echo "Adding dotnet3.1-internal-transport to the packageSources."
         PackageSourcesNodeFooter="</packageSources>"
-        PackageSourceTemplate="${TB}<add key=\"dotnet3-internal-transport\" value=\"https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3-internal-transport/nuget/v2\" />"
+        PackageSourceTemplate="${TB}<add key=\"dotnet3.1-internal-transport\" value=\"https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-transport/nuget/v2\" />"
 
         sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
     fi
-    PackageSources+=('dotnet3-internal-transport')
+    PackageSources+=('dotnet3.1-internal-transport')
 fi
 
-# Ensure dotnet3.1-internal and dotnet3.1-internal-transport are in the packageSources if the public dotnet3.1 feeds are present
-grep -i "<add key=\"dotnet3.1\"" $ConfigFile
+# Ensure dotnet5-internal and dotnet5-internal-transport are in the packageSources if the public dotnet5 feeds are present
+grep -i "<add key=\"dotnet5\"" $ConfigFile
 if [ "$?" == "0" ]; then
-    grep -i "<add key=\"dotnet3.1-internal\"" $ConfigFile
+    grep -i "<add key=\"dotnet5-internal\"" $ConfigFile
     if [ "$?" != "0" ]; then
-        echo "Adding dotnet3.1-internal to the packageSources."
+        echo "Adding dotnet5-internal to the packageSources."
         PackageSourcesNodeFooter="</packageSources>"
-        PackageSourceTemplate="${TB}<add key=\"dotnet3.1-internal\" value=\"https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal/nuget/v2\" />"
+        PackageSourceTemplate="${TB}<add key=\"dotnet5-internal\" value=\"https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet5-internal/nuget/v2\" />"
 
         sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
     fi
-    PackageSources+=('dotnet3.1-internal')
+    PackageSources+=('dotnet5-internal')
 
-    grep -i "<add key=\"dotnet3.1-internal-transport\">" $ConfigFile
+    grep -i "<add key=\"dotnet5-internal-transport\">" $ConfigFile
     if [ "$?" != "0" ]; then
-        echo "Adding dotnet3.1-internal-transport to the packageSources."
+        echo "Adding dotnet5-internal-transport to the packageSources."
         PackageSourcesNodeFooter="</packageSources>"
-        PackageSourceTemplate="${TB}<add key=\"dotnet3.1-internal-transport\" value=\"https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-transport/nuget/v2\" />"
+        PackageSourceTemplate="${TB}<add key=\"dotnet5-internal-transport\" value=\"https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet5-internal-transport/nuget/v2\" />"
 
         sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
     fi
-    PackageSources+=('dotnet3.1-internal-transport')
+    PackageSources+=('dotnet5-internal-transport')
 fi
 
 # I want things split line by line
@@ -165,4 +164,4 @@ if [ "$?" == "0" ]; then
                 echo "Neutralized disablePackageSources entry for '$DisabledSourceName'"
         fi
     done
-fi
\ No newline at end of file
+fi
diff --git a/eng/common/SigningValidation.proj b/eng/common/SigningValidation.proj
deleted file mode 100644
index 3d0ac80af3f..00000000000
--- a/eng/common/SigningValidation.proj
+++ /dev/null
@@ -1,83 +0,0 @@
-<!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the LICENSE file in the project root for more information. -->
-<Project Sdk="Microsoft.NET.Sdk">
-  <!--
-    This MSBuild file is intended to be used as the body of the default 
-    publishing release pipeline. The release pipeline will use this file
-    to invoke the SignCheck tool to validate that packages about to
-    be published are correctly signed.
-  
-    Parameters:
-  
-      - PackageBasePath   : Directory containing all files that need to be validated.
-      - SignCheckVersion  : Version of SignCheck package to be used.
-      - SignValidationExclusionList   : ItemGroup containing exclusion list to be forwarded to SignCheck.
-      - EnableJarSigningCheck    : Whether .jar files should be validated.
-      - EnableStrongNameCheck    : Whether strong name check should be performed.
-  -->
-
-  <PropertyGroup>
-    <TargetFramework>netcoreapp2.1</TargetFramework>
-  </PropertyGroup>
-
-  <!--
-    From 'Signing.props' we import $(SignValidationExclusionList)
-  -->
-  <Import Project="$(MSBuildThisFileDirectory)Signing.props" Condition="Exists('$(MSBuildThisFileDirectory)Signing.props')" />
-
-  <Target Name="ValidateSigning">
-    <PropertyGroup>
-      <SignCheckToolPath>$(NuGetPackageRoot)Microsoft.DotNet.SignCheck\$(SignCheckVersion)\tools\Microsoft.DotNet.SignCheck.exe</SignCheckToolPath>
-
-      <SignCheckInputDir>$(PackageBasePath)</SignCheckInputDir>
-      <SignCheckLog>signcheck.log</SignCheckLog>
-      <SignCheckErrorLog>signcheck.errors.log</SignCheckErrorLog>
-      <SignCheckExclusionsFile>signcheck.exclusions.txt</SignCheckExclusionsFile>
-    </PropertyGroup>
-    
-    <ItemGroup>
-      <!--
-        Documentation for these arguments is available here:
-        https://github.com/dotnet/arcade/tree/master/src/SignCheck
-      -->
-      <SignCheckArgs Include="--recursive" />
-      <SignCheckArgs Include="--traverse-subfolders" />
-      <SignCheckArgs Include="--file-status AllFiles" />
-      <SignCheckArgs Include="--log-file $(SignCheckLog)" />
-      <SignCheckArgs Include="--error-log-file $(SignCheckErrorLog)" />
-      <SignCheckArgs Include="--input-files $(SignCheckInputDir)" />
-      
-      <SignCheckArgs Include="--exclusions-file $(SignCheckExclusionsFile)" Condition="'@(SignValidationExclusionList)' != ''" />
-      <SignCheckArgs Include="--verify-jar" Condition="'$(EnableJarSigningCheck)' == 'true'" />
-      <SignCheckArgs Include="--verify-strongname" Condition="'$(EnableStrongNameCheck)' == 'true'" />
-    </ItemGroup>
-   
-    <WriteLinesToFile 
-      File="$(SignCheckExclusionsFile)"
-      Lines="@(SignValidationExclusionList)"
-      Condition="'@(SignValidationExclusionList)' != ''"
-      Overwrite="true"
-      Encoding="Unicode"/>
-    
-    <!--
-      IgnoreExitCode='true' because the tool doesn't return '0' on success.
-    -->
-    <Exec 
-      Command="&quot;$(SignCheckToolPath)&quot; @(SignCheckArgs, ' ')"
-      IgnoreExitCode='true' 
-      ConsoleToMsBuild="false" 
-      StandardErrorImportance="high" />
-
-    <Error 
-      Text="Signing validation failed. Check $(SignCheckErrorLog) for more information." 
-      Condition="Exists($(SignCheckErrorLog)) and '$([System.IO.File]::ReadAllText($(SignCheckErrorLog)))' != ''" />
-
-    <Message
-      Text="##vso[artifact.upload containerfolder=LogFiles;artifactname=LogFiles]{SignCheckErrorLog}"
-      Condition="Exists($(SignCheckErrorLog)) and '$([System.IO.File]::ReadAllText($(SignCheckErrorLog)))' != ''" />
-    
-  </Target>
-
-  <ItemGroup>
-    <PackageReference Include="Microsoft.DotNet.SignCheck" Version="$(SignCheckVersion)" />
-  </ItemGroup>
-</Project>
diff --git a/eng/common/SourceLinkValidation.ps1 b/eng/common/SourceLinkValidation.ps1
deleted file mode 100644
index cb2d28cb99e..00000000000
--- a/eng/common/SourceLinkValidation.ps1
+++ /dev/null
@@ -1,184 +0,0 @@
-param(
-  [Parameter(Mandatory=$true)][string] $InputPath,           # Full path to directory where Symbols.NuGet packages to be checked are stored
-  [Parameter(Mandatory=$true)][string] $ExtractPath,         # Full path to directory where the packages will be extracted during validation
-  [Parameter(Mandatory=$true)][string] $SourceLinkToolPath,  # Full path to directory where dotnet SourceLink CLI was installed
-  [Parameter(Mandatory=$true)][string] $GHRepoName,          # GitHub name of the repo including the Org. E.g., dotnet/arcade
-  [Parameter(Mandatory=$true)][string] $GHCommit             # GitHub commit SHA used to build the packages
-)
-
-# Cache/HashMap (File -> Exist flag) used to consult whether a file exist 
-# in the repository at a specific commit point. This is populated by inserting
-# all files present in the repo at a specific commit point.
-$global:RepoFiles = @{}
-
-$ValidatePackage = {
-  param( 
-    [string] $PackagePath                                 # Full path to a Symbols.NuGet package
-  )
-
-  # Ensure input file exist
-  if (!(Test-Path $PackagePath)) {
-    throw "Input file does not exist: $PackagePath"
-  }
-
-  # Extensions for which we'll look for SourceLink information
-  # For now we'll only care about Portable & Embedded PDBs
-  $RelevantExtensions = @(".dll", ".exe", ".pdb")
- 
-  Write-Host -NoNewLine "Validating" ([System.IO.Path]::GetFileName($PackagePath)) "... "
-
-  $PackageId = [System.IO.Path]::GetFileNameWithoutExtension($PackagePath)
-  $ExtractPath = Join-Path -Path $using:ExtractPath -ChildPath $PackageId
-  $FailedFiles = 0
-
-  Add-Type -AssemblyName System.IO.Compression.FileSystem
-
-  [System.IO.Directory]::CreateDirectory($ExtractPath);
-
-  $zip = [System.IO.Compression.ZipFile]::OpenRead($PackagePath)
-
-  $zip.Entries | 
-    Where-Object {$RelevantExtensions -contains [System.IO.Path]::GetExtension($_.Name)} |
-      ForEach-Object {
-        $FileName = $_.FullName
-        $Extension = [System.IO.Path]::GetExtension($_.Name)
-        $FakeName = -Join((New-Guid), $Extension)
-        $TargetFile = Join-Path -Path $ExtractPath -ChildPath $FakeName 
-
-        # We ignore resource DLLs
-        if ($FileName.EndsWith(".resources.dll")) {
-          return
-        }
-
-        [System.IO.Compression.ZipFileExtensions]::ExtractToFile($_, $TargetFile, $true)
-
-        $ValidateFile = {
-          param( 
-            [string] $FullPath,                                # Full path to the module that has to be checked
-            [string] $RealPath,
-            [ref] $FailedFiles
-          )
-
-          # Makes easier to reference `sourcelink cli`
-          Push-Location $using:SourceLinkToolPath
-
-          $SourceLinkInfos = .\sourcelink.exe print-urls $FullPath | Out-String
-
-          if ($LASTEXITCODE -eq 0 -and -not ([string]::IsNullOrEmpty($SourceLinkInfos))) {
-            $NumFailedLinks = 0
-
-            # We only care about Http addresses
-            $Matches = (Select-String '(http[s]?)(:\/\/)([^\s,]+)' -Input $SourceLinkInfos -AllMatches).Matches
-
-            if ($Matches.Count -ne 0) {
-              $Matches.Value |
-                ForEach-Object {
-                  $Link = $_
-                  $CommitUrl = -Join("https://raw.githubusercontent.com/", $using:GHRepoName, "/", $using:GHCommit, "/")
-                  $FilePath = $Link.Replace($CommitUrl, "")
-                  $Status = 200
-                  $Cache = $using:RepoFiles
-
-                  if ( !($Cache.ContainsKey($FilePath)) ) {
-                    try {
-                      $Uri = $Link -as [System.URI]
-                    
-                      # Only GitHub links are valid
-                      if ($Uri.AbsoluteURI -ne $null -and $Uri.Host -match "github") {
-                        $Status = (Invoke-WebRequest -Uri $Link -UseBasicParsing -Method HEAD -TimeoutSec 5).StatusCode
-                      }
-                      else {
-                        $Status = 0
-                      }
-                    }
-                    catch {
-                      $Status = 0
-                    }
-                  }
-
-                  if ($Status -ne 200) {
-                    if ($NumFailedLinks -eq 0) {
-                      if ($FailedFiles.Value -eq 0) {
-                        Write-Host
-                      }
-
-                      Write-Host "`tFile $RealPath has broken links:"
-                    }
-
-                    Write-Host "`t`tFailed to retrieve $Link"
-
-                    $NumFailedLinks++
-                  }
-                }
-            }
-
-            if ($NumFailedLinks -ne 0) {
-              $FailedFiles.value++
-              $global:LASTEXITCODE = 1
-            }
-          }
-
-          Pop-Location
-        }
-      
-        &$ValidateFile $TargetFile $FileName ([ref]$FailedFiles)
-      }
-
-  $zip.Dispose()
-
-  if ($FailedFiles -eq 0) {
-    Write-Host "Passed."
-  }
-}
-
-function ValidateSourceLinkLinks {
-  if (!($GHRepoName -Match "^[^\s\/]+/[^\s\/]+$")) {
-    Write-Host "GHRepoName should be in the format <org>/<repo>"
-    $global:LASTEXITCODE = 1
-    return
-  }
-
-  if (!($GHCommit -Match "^[0-9a-fA-F]{40}$")) {
-    Write-Host "GHCommit should be a 40 chars hexadecimal string"
-    $global:LASTEXITCODE = 1
-    return
-  }
-
-  $RepoTreeURL = -Join("https://api.github.com/repos/", $GHRepoName, "/git/trees/", $GHCommit, "?recursive=1")
-  $CodeExtensions = @(".cs", ".vb", ".fs", ".fsi", ".fsx", ".fsscript")
-
-  try {
-    # Retrieve the list of files in the repo at that particular commit point and store them in the RepoFiles hash
-    $Data = Invoke-WebRequest $RepoTreeURL | ConvertFrom-Json | Select-Object -ExpandProperty tree
-  
-    foreach ($file in $Data) {
-      $Extension = [System.IO.Path]::GetExtension($file.path)
-
-      if ($CodeExtensions.Contains($Extension)) {
-        $RepoFiles[$file.path] = 1
-      }
-    }
-  }
-  catch {
-    Write-Host "Problems downloading the list of files from the repo. Url used: $RepoTreeURL"
-    $global:LASTEXITCODE = 1
-    return
-  }
-  
-  if (Test-Path $ExtractPath) {
-    Remove-Item $ExtractPath -Force -Recurse -ErrorAction SilentlyContinue
-  }
-
-  # Process each NuGet package in parallel
-  $Jobs = @()
-  Get-ChildItem "$InputPath\*.symbols.nupkg" |
-    ForEach-Object {
-      $Jobs += Start-Job -ScriptBlock $ValidatePackage -ArgumentList $_.FullName
-    }
-
-  foreach ($Job in $Jobs) {
-    Wait-Job -Id $Job.Id | Receive-Job
-  }
-}
-
-Measure-Command { ValidateSourceLinkLinks }
diff --git a/eng/common/build.ps1 b/eng/common/build.ps1
index e001ccb481c..94a91c0817e 100644
--- a/eng/common/build.ps1
+++ b/eng/common/build.ps1
@@ -18,56 +18,67 @@ Param(
   [switch] $sign,
   [switch] $pack,
   [switch] $publish,
+  [switch] $clean,
   [switch][Alias('bl')]$binaryLog,
+  [switch][Alias('nobl')]$excludeCIBinarylog,
   [switch] $ci,
   [switch] $prepareMachine,
+  [string] $runtimeSourceFeed = '',
+  [string] $runtimeSourceFeedKey = '',
   [switch] $help,
   [Parameter(ValueFromRemainingArguments=$true)][String[]]$properties
 )
 
-. $PSScriptRoot\tools.ps1
-
+# Unset 'Platform' environment variable to avoid unwanted collision in InstallDotNetCore.targets file
+# some computer has this env var defined (e.g. Some HP)
+if($env:Platform) {
+  $env:Platform=""  
+}
 function Print-Usage() {
-    Write-Host "Common settings:"
-    Write-Host "  -configuration <value>  Build configuration: 'Debug' or 'Release' (short: -c)"
-    Write-Host "  -platform <value>       Platform configuration: 'x86', 'x64' or any valid Platform value to pass to msbuild"
-    Write-Host "  -verbosity <value>      Msbuild verbosity: q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic] (short: -v)"
-    Write-Host "  -binaryLog              Output binary log (short: -bl)"
-    Write-Host "  -help                   Print help and exit"
-    Write-Host ""
-
-    Write-Host "Actions:"
-    Write-Host "  -restore                Restore dependencies (short: -r)"
-    Write-Host "  -build                  Build solution (short: -b)"
-    Write-Host "  -rebuild                Rebuild solution"
-    Write-Host "  -deploy                 Deploy built VSIXes"
-    Write-Host "  -deployDeps             Deploy dependencies (e.g. VSIXes for integration tests)"
-    Write-Host "  -test                   Run all unit tests in the solution (short: -t)"
-    Write-Host "  -integrationTest        Run all integration tests in the solution"
-    Write-Host "  -performanceTest        Run all performance tests in the solution"
-    Write-Host "  -pack                   Package build outputs into NuGet packages and Willow components"
-    Write-Host "  -sign                   Sign build outputs"
-    Write-Host "  -publish                Publish artifacts (e.g. symbols)"
-    Write-Host ""
-
-    Write-Host "Advanced settings:"
-    Write-Host "  -projects <value>       Semi-colon delimited list of sln/proj's to build. Globbing is supported (*.sln)"
-    Write-Host "  -ci                     Set when running on CI server"
-    Write-Host "  -prepareMachine         Prepare machine for CI run, clean up processes after build"
-    Write-Host "  -warnAsError <value>    Sets warnaserror msbuild parameter ('true' or 'false')"
-    Write-Host "  -msbuildEngine <value>  Msbuild engine to use to run build ('dotnet', 'vs', or unspecified)."
-    Write-Host ""
-
-    Write-Host "Command line arguments not listed above are passed thru to msbuild."
-    Write-Host "The above arguments can be shortened as much as to be unambiguous (e.g. -co for configuration, -t for test, etc.)."
+  Write-Host "Common settings:"
+  Write-Host "  -configuration <value>  Build configuration: 'Debug' or 'Release' (short: -c)"
+  Write-Host "  -platform <value>       Platform configuration: 'x86', 'x64' or any valid Platform value to pass to msbuild"
+  Write-Host "  -verbosity <value>      Msbuild verbosity: q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic] (short: -v)"
+  Write-Host "  -binaryLog              Output binary log (short: -bl)"
+  Write-Host "  -help                   Print help and exit"
+  Write-Host ""
+
+  Write-Host "Actions:"
+  Write-Host "  -restore                Restore dependencies (short: -r)"
+  Write-Host "  -build                  Build solution (short: -b)"
+  Write-Host "  -rebuild                Rebuild solution"
+  Write-Host "  -deploy                 Deploy built VSIXes"
+  Write-Host "  -deployDeps             Deploy dependencies (e.g. VSIXes for integration tests)"
+  Write-Host "  -test                   Run all unit tests in the solution (short: -t)"
+  Write-Host "  -integrationTest        Run all integration tests in the solution"
+  Write-Host "  -performanceTest        Run all performance tests in the solution"
+  Write-Host "  -pack                   Package build outputs into NuGet packages and Willow components"
+  Write-Host "  -sign                   Sign build outputs"
+  Write-Host "  -publish                Publish artifacts (e.g. symbols)"
+  Write-Host "  -clean                  Clean the solution"
+  Write-Host ""
+
+  Write-Host "Advanced settings:"
+  Write-Host "  -projects <value>       Semi-colon delimited list of sln/proj's to build. Globbing is supported (*.sln)"
+  Write-Host "  -ci                     Set when running on CI server"
+  Write-Host "  -excludeCIBinarylog     Don't output binary log (short: -nobl)"
+  Write-Host "  -prepareMachine         Prepare machine for CI run, clean up processes after build"
+  Write-Host "  -warnAsError <value>    Sets warnaserror msbuild parameter ('true' or 'false')"
+  Write-Host "  -msbuildEngine <value>  Msbuild engine to use to run build ('dotnet', 'vs', or unspecified)."
+  Write-Host ""
+
+  Write-Host "Command line arguments not listed above are passed thru to msbuild."
+  Write-Host "The above arguments can be shortened as much as to be unambiguous (e.g. -co for configuration, -t for test, etc.)."
 }
 
+. $PSScriptRoot\tools.ps1
+
 function InitializeCustomToolset {
   if (-not $restore) {
     return
   }
 
-  $script = Join-Path $EngRoot "restore-toolset.ps1"
+  $script = Join-Path $EngRoot 'restore-toolset.ps1'
 
   if (Test-Path $script) {
     . $script
@@ -78,8 +89,8 @@ function Build {
   $toolsetBuildProj = InitializeToolset
   InitializeCustomToolset
 
-  $bl = if ($binaryLog) { "/bl:" + (Join-Path $LogDir "Build.binlog") } else { "" }
-  $platformArg = if ($platform) { "/p:Platform=$platform" } else { "" }
+  $bl = if ($binaryLog) { '/bl:' + (Join-Path $LogDir 'Build.binlog') } else { '' }
+  $platformArg = if ($platform) { "/p:Platform=$platform" } else { '' }
 
   if ($projects) {
     # Re-assign properties to a new variable because PowerShell doesn't let us append properties directly for unclear reasons.
@@ -113,24 +124,27 @@ function Build {
 }
 
 try {
-  if ($help -or (($null -ne $properties) -and ($properties.Contains("/help") -or $properties.Contains("/?")))) {
+  if ($clean) {
+    if (Test-Path $ArtifactsDir) {
+      Remove-Item -Recurse -Force $ArtifactsDir
+      Write-Host 'Artifacts directory deleted.'
+    }
+    exit 0
+  }
+
+  if ($help -or (($null -ne $properties) -and ($properties.Contains('/help') -or $properties.Contains('/?')))) {
     Print-Usage
     exit 0
   }
 
   if ($ci) {
-    $binaryLog = $true
+    if (-not $excludeCIBinarylog) {
+      $binaryLog = $true
+    }
     $nodeReuse = $false
   }
 
-  # Import custom tools configuration, if present in the repo.
-  # Note: Import in global scope so that the script set top-level variables without qualification.
-  $configureToolsetScript = Join-Path $EngRoot "configure-toolset.ps1"
-  if (Test-Path $configureToolsetScript) {
-    . $configureToolsetScript
-  }
-
-  if (($restore) -and ($null -eq $env:DisableNativeToolsetInstalls)) {
+  if ($restore) {
     InitializeNativeTools
   }
 
@@ -138,7 +152,7 @@ try {
 }
 catch {
   Write-Host $_.ScriptStackTrace
-  Write-PipelineTelemetryError -Category "InitializeToolset" -Message $_
+  Write-PipelineTelemetryError -Category 'InitializeToolset' -Message $_
   ExitWithExitCode 1
 }
 
diff --git a/eng/common/build.sh b/eng/common/build.sh
index 6236fc4d38c..252b63604e6 100755
--- a/eng/common/build.sh
+++ b/eng/common/build.sh
@@ -26,11 +26,13 @@ usage()
   echo "  --pack                     Package build outputs into NuGet packages and Willow components"
   echo "  --sign                     Sign build outputs"
   echo "  --publish                  Publish artifacts (e.g. symbols)"
+  echo "  --clean                    Clean the solution"
   echo ""
 
   echo "Advanced settings:"
   echo "  --projects <value>       Project or solution file(s) to build"
   echo "  --ci                     Set when running on CI server"
+  echo "  --excludeCIBinarylog     Don't output binary log (short: -nobl)"
   echo "  --prepareMachine         Prepare machine for CI run, clean up processes after build"
   echo "  --nodeReuse <value>      Sets nodereuse msbuild parameter ('true' or 'false')"
   echo "  --warnAsError <value>    Sets warnaserror msbuild parameter ('true' or 'false')"
@@ -62,19 +64,22 @@ publish=false
 sign=false
 public=false
 ci=false
+clean=false
 
 warn_as_error=true
 node_reuse=true
 binary_log=false
+exclude_ci_binary_log=false
 pipelines_log=false
 
 projects=''
 configuration='Debug'
 prepare_machine=false
 verbosity='minimal'
+runtime_source_feed=''
+runtime_source_feed_key=''
 
 properties=''
-
 while [[ $# > 0 ]]; do
   opt="$(echo "${1/#--/-}" | awk '{print tolower($0)}')"
   case "$opt" in
@@ -82,6 +87,9 @@ while [[ $# > 0 ]]; do
       usage
       exit 0
       ;;
+    -clean)
+      clean=true
+      ;;
     -configuration|-c)
       configuration=$2
       shift
@@ -93,6 +101,9 @@ while [[ $# > 0 ]]; do
     -binarylog|-bl)
       binary_log=true
       ;;
+    -excludeCIBinarylog|-nobl)
+      exclude_ci_binary_log=true
+      ;;
     -pipelineslog|-pl)
       pipelines_log=true
       ;;
@@ -141,6 +152,14 @@ while [[ $# > 0 ]]; do
       node_reuse=$2
       shift
       ;;
+    -runtimesourcefeed)
+      runtime_source_feed=$2
+      shift
+      ;;
+     -runtimesourcefeedkey)
+      runtime_source_feed_key=$2
+      shift
+      ;;
     *)
       properties="$properties $1"
       ;;
@@ -151,8 +170,10 @@ done
 
 if [[ "$ci" == true ]]; then
   pipelines_log=true
-  binary_log=true
   node_reuse=false
+  if [[ "$exclude_ci_binary_log" == false ]]; then
+    binary_log=true
+  fi
 fi
 
 . "$scriptroot/tools.sh"
@@ -196,20 +217,15 @@ function Build {
   ExitWithExitCode 0
 }
 
-# Import custom tools configuration, if present in the repo.
-configure_toolset_script="$eng_root/configure-toolset.sh"
-if [[ -a "$configure_toolset_script" ]]; then
-  . "$configure_toolset_script"
-fi
-
-# TODO: https://github.com/dotnet/arcade/issues/1468
-# Temporary workaround to avoid breaking change.
-# Remove once repos are updated.
-if [[ -n "${useInstalledDotNetCli:-}" ]]; then
-  use_installed_dotnet_cli="$useInstalledDotNetCli"
+if [[ "$clean" == true ]]; then
+  if [ -d "$artifacts_dir" ]; then
+    rm -rf $artifacts_dir
+    echo "Artifacts directory deleted."
+  fi
+  exit 0
 fi
 
-if [[ "$restore" == true && -z ${DisableNativeToolsetInstalls:-} ]]; then
+if [[ "$restore" == true ]]; then
   InitializeNativeTools
 fi
 
diff --git a/eng/common/cross/android/arm/toolchain.cmake b/eng/common/cross/android/arm/toolchain.cmake
deleted file mode 100644
index a7e1c73501b..00000000000
--- a/eng/common/cross/android/arm/toolchain.cmake
+++ /dev/null
@@ -1,41 +0,0 @@
-set(CROSS_NDK_TOOLCHAIN $ENV{ROOTFS_DIR}/../)
-set(CROSS_ROOTFS ${CROSS_NDK_TOOLCHAIN}/sysroot)
-set(CLR_CMAKE_PLATFORM_ANDROID "Android")
-
-set(CMAKE_SYSTEM_NAME Linux)
-set(CMAKE_SYSTEM_VERSION 1)
-set(CMAKE_SYSTEM_PROCESSOR arm)
-
-## Specify the toolchain
-set(TOOLCHAIN "arm-linux-androideabi")
-set(CMAKE_PREFIX_PATH ${CROSS_NDK_TOOLCHAIN})
-set(TOOLCHAIN_PREFIX ${TOOLCHAIN}-)
-
-find_program(CMAKE_C_COMPILER ${TOOLCHAIN_PREFIX}clang)
-find_program(CMAKE_CXX_COMPILER ${TOOLCHAIN_PREFIX}clang++)
-find_program(CMAKE_ASM_COMPILER ${TOOLCHAIN_PREFIX}clang)
-find_program(CMAKE_AR ${TOOLCHAIN_PREFIX}ar)
-find_program(CMAKE_LD ${TOOLCHAIN_PREFIX}ar)
-find_program(CMAKE_OBJCOPY ${TOOLCHAIN_PREFIX}objcopy)
-find_program(CMAKE_OBJDUMP ${TOOLCHAIN_PREFIX}objdump)
-
-add_compile_options(--sysroot=${CROSS_ROOTFS})
-add_compile_options(-fPIE)
-add_compile_options(-mfloat-abi=soft)
-include_directories(SYSTEM ${CROSS_NDK_TOOLCHAIN}/include/c++/4.9.x/)
-include_directories(SYSTEM ${CROSS_NDK_TOOLCHAIN}/include/c++/4.9.x/arm-linux-androideabi/)
-
-set(CROSS_LINK_FLAGS "${CROSS_LINK_FLAGS} -B ${CROSS_ROOTFS}/usr/lib/gcc/${TOOLCHAIN}")
-set(CROSS_LINK_FLAGS "${CROSS_LINK_FLAGS} -L${CROSS_ROOTFS}/lib/${TOOLCHAIN}")
-set(CROSS_LINK_FLAGS "${CROSS_LINK_FLAGS} --sysroot=${CROSS_ROOTFS}")
-set(CROSS_LINK_FLAGS "${CROSS_LINK_FLAGS} -fPIE -pie")
-
-set(CMAKE_EXE_LINKER_FLAGS    "${CMAKE_EXE_LINKER_FLAGS}    ${CROSS_LINK_FLAGS}" CACHE STRING "" FORCE)
-set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} ${CROSS_LINK_FLAGS}" CACHE STRING "" FORCE)
-set(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} ${CROSS_LINK_FLAGS}" CACHE STRING "" FORCE)
-
-set(CMAKE_FIND_ROOT_PATH "${CROSS_ROOTFS}")
-set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
-set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
-set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
-set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
diff --git a/eng/common/cross/android/arm64/toolchain.cmake b/eng/common/cross/android/arm64/toolchain.cmake
deleted file mode 100644
index 29415899c1c..00000000000
--- a/eng/common/cross/android/arm64/toolchain.cmake
+++ /dev/null
@@ -1,42 +0,0 @@
-set(CROSS_NDK_TOOLCHAIN $ENV{ROOTFS_DIR}/../)
-set(CROSS_ROOTFS ${CROSS_NDK_TOOLCHAIN}/sysroot)
-set(CLR_CMAKE_PLATFORM_ANDROID "Android")
-
-set(CMAKE_SYSTEM_NAME Linux)
-set(CMAKE_SYSTEM_VERSION 1)
-set(CMAKE_SYSTEM_PROCESSOR aarch64)
-
-## Specify the toolchain
-set(TOOLCHAIN "aarch64-linux-android")
-set(CMAKE_PREFIX_PATH ${CROSS_NDK_TOOLCHAIN})
-set(TOOLCHAIN_PREFIX ${TOOLCHAIN}-)
-
-find_program(CMAKE_C_COMPILER ${TOOLCHAIN_PREFIX}clang)
-find_program(CMAKE_CXX_COMPILER ${TOOLCHAIN_PREFIX}clang++)
-find_program(CMAKE_ASM_COMPILER ${TOOLCHAIN_PREFIX}clang)
-find_program(CMAKE_AR ${TOOLCHAIN_PREFIX}ar)
-find_program(CMAKE_LD ${TOOLCHAIN_PREFIX}ar)
-find_program(CMAKE_OBJCOPY ${TOOLCHAIN_PREFIX}objcopy)
-find_program(CMAKE_OBJDUMP ${TOOLCHAIN_PREFIX}objdump)
-
-add_compile_options(--sysroot=${CROSS_ROOTFS})
-add_compile_options(-fPIE)
-
-## Needed for Android or bionic specific conditionals
-add_compile_options(-D__ANDROID__)
-add_compile_options(-D__BIONIC__)
-
-set(CROSS_LINK_FLAGS "${CROSS_LINK_FLAGS} -B ${CROSS_ROOTFS}/usr/lib/gcc/${TOOLCHAIN}")
-set(CROSS_LINK_FLAGS "${CROSS_LINK_FLAGS} -L${CROSS_ROOTFS}/lib/${TOOLCHAIN}")
-set(CROSS_LINK_FLAGS "${CROSS_LINK_FLAGS} --sysroot=${CROSS_ROOTFS}")
-set(CROSS_LINK_FLAGS "${CROSS_LINK_FLAGS} -fPIE -pie")
-
-set(CMAKE_EXE_LINKER_FLAGS    "${CMAKE_EXE_LINKER_FLAGS}    ${CROSS_LINK_FLAGS}" CACHE STRING "" FORCE)
-set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} ${CROSS_LINK_FLAGS}" CACHE STRING "" FORCE)
-set(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} ${CROSS_LINK_FLAGS}" CACHE STRING "" FORCE)
-
-set(CMAKE_FIND_ROOT_PATH "${CROSS_ROOTFS}")
-set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
-set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
-set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
-set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
diff --git a/eng/common/cross/arm64/tizen-build-rootfs.sh b/eng/common/cross/arm64/tizen-build-rootfs.sh
new file mode 100644
index 00000000000..13bfddb5e2a
--- /dev/null
+++ b/eng/common/cross/arm64/tizen-build-rootfs.sh
@@ -0,0 +1,35 @@
+#!/usr/bin/env bash
+set -e
+
+__CrossDir=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
+__TIZEN_CROSSDIR="$__CrossDir/tizen"
+
+if [[ -z "$ROOTFS_DIR" ]]; then
+    echo "ROOTFS_DIR is not defined."
+    exit 1;
+fi
+
+TIZEN_TMP_DIR=$ROOTFS_DIR/tizen_tmp
+mkdir -p $TIZEN_TMP_DIR
+
+# Download files
+echo ">>Start downloading files"
+VERBOSE=1 $__CrossDir/tizen-fetch.sh $TIZEN_TMP_DIR
+echo "<<Finish downloading files"
+
+echo ">>Start constructing Tizen rootfs"
+TIZEN_RPM_FILES=`ls $TIZEN_TMP_DIR/*.rpm`
+cd $ROOTFS_DIR
+for f in $TIZEN_RPM_FILES; do
+    rpm2cpio $f  | cpio -idm --quiet
+done
+echo "<<Finish constructing Tizen rootfs"
+
+# Cleanup tmp
+rm -rf $TIZEN_TMP_DIR
+
+# Configure Tizen rootfs
+echo ">>Start configuring Tizen rootfs"
+ln -sfn asm-arm64 ./usr/include/asm
+patch -p1 < $__TIZEN_CROSSDIR/tizen.patch
+echo "<<Finish configuring Tizen rootfs"
diff --git a/eng/common/cross/arm64/tizen-fetch.sh b/eng/common/cross/arm64/tizen-fetch.sh
new file mode 100644
index 00000000000..a48a6f51c49
--- /dev/null
+++ b/eng/common/cross/arm64/tizen-fetch.sh
@@ -0,0 +1,170 @@
+#!/usr/bin/env bash
+set -e
+
+if [[ -z "${VERBOSE// }" ]] || [ "$VERBOSE" -ne "$VERBOSE" ] 2>/dev/null; then
+	VERBOSE=0
+fi
+
+Log()
+{
+	if [ $VERBOSE -ge $1 ]; then
+		echo ${@:2}
+	fi
+}
+
+Inform()
+{
+	Log 1 -e "\x1B[0;34m$@\x1B[m"
+}
+
+Debug()
+{
+	Log 2 -e "\x1B[0;32m$@\x1B[m"
+}
+
+Error()
+{
+	>&2 Log 0 -e "\x1B[0;31m$@\x1B[m"
+}
+
+Fetch()
+{
+	URL=$1
+	FILE=$2
+	PROGRESS=$3
+	if [ $VERBOSE -ge 1 ] && [ $PROGRESS ]; then
+		CURL_OPT="--progress-bar"
+	else
+		CURL_OPT="--silent"
+	fi
+	curl $CURL_OPT $URL > $FILE
+}
+
+hash curl 2> /dev/null || { Error "Require 'curl' Aborting."; exit 1; }
+hash xmllint 2> /dev/null || { Error "Require 'xmllint' Aborting."; exit 1; }
+hash sha256sum 2> /dev/null || { Error "Require 'sha256sum' Aborting."; exit 1; }
+
+TMPDIR=$1
+if [ ! -d $TMPDIR ]; then
+	TMPDIR=./tizen_tmp
+	Debug "Create temporary directory : $TMPDIR"
+	mkdir -p $TMPDIR
+fi
+
+TIZEN_URL=http://download.tizen.org/snapshots/tizen/
+BUILD_XML=build.xml
+REPOMD_XML=repomd.xml
+PRIMARY_XML=primary.xml
+TARGET_URL="http://__not_initialized"
+
+Xpath_get()
+{
+	XPATH_RESULT=''
+	XPATH=$1
+	XML_FILE=$2
+	RESULT=$(xmllint --xpath $XPATH $XML_FILE)
+	if [[ -z ${RESULT// } ]]; then
+		Error "Can not find target from $XML_FILE"
+		Debug "Xpath = $XPATH"
+		exit 1
+	fi
+	XPATH_RESULT=$RESULT
+}
+
+fetch_tizen_pkgs_init()
+{
+	TARGET=$1
+	PROFILE=$2
+	Debug "Initialize TARGET=$TARGET, PROFILE=$PROFILE"
+
+	TMP_PKG_DIR=$TMPDIR/tizen_${PROFILE}_pkgs
+	if [ -d $TMP_PKG_DIR ]; then rm -rf $TMP_PKG_DIR; fi
+	mkdir -p $TMP_PKG_DIR
+
+	PKG_URL=$TIZEN_URL/$PROFILE/latest
+
+	BUILD_XML_URL=$PKG_URL/$BUILD_XML
+	TMP_BUILD=$TMP_PKG_DIR/$BUILD_XML
+	TMP_REPOMD=$TMP_PKG_DIR/$REPOMD_XML
+	TMP_PRIMARY=$TMP_PKG_DIR/$PRIMARY_XML
+	TMP_PRIMARYGZ=${TMP_PRIMARY}.gz
+
+	Fetch $BUILD_XML_URL $TMP_BUILD
+
+	Debug "fetch $BUILD_XML_URL to $TMP_BUILD"
+
+	TARGET_XPATH="//build/buildtargets/buildtarget[@name=\"$TARGET\"]/repo[@type=\"binary\"]/text()"
+	Xpath_get $TARGET_XPATH $TMP_BUILD
+	TARGET_PATH=$XPATH_RESULT
+	TARGET_URL=$PKG_URL/$TARGET_PATH
+
+	REPOMD_URL=$TARGET_URL/repodata/repomd.xml
+	PRIMARY_XPATH='string(//*[local-name()="data"][@type="primary"]/*[local-name()="location"]/@href)'
+
+	Fetch $REPOMD_URL $TMP_REPOMD
+
+	Debug "fetch $REPOMD_URL to $TMP_REPOMD"
+
+	Xpath_get $PRIMARY_XPATH $TMP_REPOMD
+	PRIMARY_XML_PATH=$XPATH_RESULT
+	PRIMARY_URL=$TARGET_URL/$PRIMARY_XML_PATH
+
+	Fetch $PRIMARY_URL $TMP_PRIMARYGZ
+
+	Debug "fetch $PRIMARY_URL to $TMP_PRIMARYGZ"
+
+	gunzip $TMP_PRIMARYGZ
+
+	Debug "unzip $TMP_PRIMARYGZ to $TMP_PRIMARY"
+}
+
+fetch_tizen_pkgs()
+{
+	ARCH=$1
+	PACKAGE_XPATH_TPL='string(//*[local-name()="metadata"]/*[local-name()="package"][*[local-name()="name"][text()="_PKG_"]][*[local-name()="arch"][text()="_ARCH_"]]/*[local-name()="location"]/@href)'
+
+	PACKAGE_CHECKSUM_XPATH_TPL='string(//*[local-name()="metadata"]/*[local-name()="package"][*[local-name()="name"][text()="_PKG_"]][*[local-name()="arch"][text()="_ARCH_"]]/*[local-name()="checksum"]/text())'
+
+	for pkg in ${@:2}
+	do
+		Inform "Fetching... $pkg"
+		XPATH=${PACKAGE_XPATH_TPL/_PKG_/$pkg}
+		XPATH=${XPATH/_ARCH_/$ARCH}
+		Xpath_get $XPATH $TMP_PRIMARY
+		PKG_PATH=$XPATH_RESULT
+
+		XPATH=${PACKAGE_CHECKSUM_XPATH_TPL/_PKG_/$pkg}
+		XPATH=${XPATH/_ARCH_/$ARCH}
+		Xpath_get $XPATH $TMP_PRIMARY
+		CHECKSUM=$XPATH_RESULT
+
+		PKG_URL=$TARGET_URL/$PKG_PATH
+		PKG_FILE=$(basename $PKG_PATH)
+		PKG_PATH=$TMPDIR/$PKG_FILE
+
+		Debug "Download $PKG_URL to $PKG_PATH"
+		Fetch $PKG_URL $PKG_PATH true
+
+		echo "$CHECKSUM $PKG_PATH" | sha256sum -c - > /dev/null
+		if [ $? -ne 0 ]; then
+			Error "Fail to fetch $PKG_URL to $PKG_PATH"
+			Debug "Checksum = $CHECKSUM"
+			exit 1
+		fi
+	done
+}
+
+Inform "Initialize arm base"
+fetch_tizen_pkgs_init standard base
+Inform "fetch common packages"
+fetch_tizen_pkgs aarch64 gcc glibc glibc-devel libicu libicu-devel libatomic linux-glibc-devel
+Inform "fetch coreclr packages"
+fetch_tizen_pkgs aarch64 lldb lldb-devel libgcc libstdc++ libstdc++-devel libunwind libunwind-devel lttng-ust-devel lttng-ust userspace-rcu-devel userspace-rcu
+Inform "fetch corefx packages"
+fetch_tizen_pkgs aarch64 libcom_err libcom_err-devel zlib zlib-devel libopenssl11 libopenssl1.1-devel krb5 krb5-devel
+
+Inform "Initialize standard unified"
+fetch_tizen_pkgs_init standard unified
+Inform "fetch corefx packages"
+fetch_tizen_pkgs aarch64 gssdp gssdp-devel tizen-release
+
diff --git a/eng/common/cross/arm64/tizen/tizen.patch b/eng/common/cross/arm64/tizen/tizen.patch
new file mode 100644
index 00000000000..af7c8be0590
--- /dev/null
+++ b/eng/common/cross/arm64/tizen/tizen.patch
@@ -0,0 +1,9 @@
+diff -u -r a/usr/lib/libc.so b/usr/lib/libc.so
+--- a/usr/lib64/libc.so	2016-12-30 23:00:08.284951863 +0900
++++ b/usr/lib64/libc.so	2016-12-30 23:00:32.140951815 +0900
+@@ -2,4 +2,4 @@
+    Use the shared library, but some functions are only in
+    the static library, so try that secondarily.  */
+ OUTPUT_FORMAT(elf64-littleaarch64)
+-GROUP ( /lib64/libc.so.6 /usr/lib64/libc_nonshared.a  AS_NEEDED ( /lib/ld-linux-aarch64.so.1 ) )
++GROUP ( libc.so.6 libc_nonshared.a  AS_NEEDED ( ld-linux-aarch64.so.1 ) )
diff --git a/eng/common/cross/armel/tizen-build-rootfs.sh b/eng/common/cross/armel/tizen-build-rootfs.sh
index 87c48e78fbb..9a4438af61c 100755
--- a/eng/common/cross/armel/tizen-build-rootfs.sh
+++ b/eng/common/cross/armel/tizen-build-rootfs.sh
@@ -9,13 +9,6 @@ if [[ -z "$ROOTFS_DIR" ]]; then
     exit 1;
 fi
 
-# Clean-up (TODO-Cleanup: We may already delete  $ROOTFS_DIR at ./cross/build-rootfs.sh.)
-# hk0110
-if [ -d "$ROOTFS_DIR" ]; then
-    umount $ROOTFS_DIR/*
-    rm -rf $ROOTFS_DIR
-fi
-
 TIZEN_TMP_DIR=$ROOTFS_DIR/tizen_tmp
 mkdir -p $TIZEN_TMP_DIR
 
@@ -37,8 +30,6 @@ rm -rf $TIZEN_TMP_DIR
 
 # Configure Tizen rootfs
 echo ">>Start configuring Tizen rootfs"
-rm ./usr/lib/libunwind.so
-ln -s libunwind.so.8 ./usr/lib/libunwind.so
 ln -sfn asm-arm ./usr/include/asm
 patch -p1 < $__TIZEN_CROSSDIR/tizen.patch
 echo "<<Finish configuring Tizen rootfs"
diff --git a/eng/common/cross/armel/tizen-fetch.sh b/eng/common/cross/armel/tizen-fetch.sh
index ed70e0a86eb..2776cbba4e4 100755
--- a/eng/common/cross/armel/tizen-fetch.sh
+++ b/eng/common/cross/armel/tizen-fetch.sh
@@ -51,7 +51,7 @@ if [ ! -d $TMPDIR ]; then
 	mkdir -p $TMPDIR 
 fi
 
-TIZEN_URL=http://download.tizen.org/releases/milestone/tizen
+TIZEN_URL=http://download.tizen.org/snapshots/tizen
 BUILD_XML=build.xml
 REPOMD_XML=repomd.xml
 PRIMARY_XML=primary.xml
@@ -157,12 +157,11 @@ fetch_tizen_pkgs()
 Inform "Initialize arm base"
 fetch_tizen_pkgs_init standard base
 Inform "fetch common packages"
-fetch_tizen_pkgs armv7l gcc glibc glibc-devel libicu libicu-devel libatomic
-fetch_tizen_pkgs noarch linux-glibc-devel
+fetch_tizen_pkgs armv7l gcc glibc glibc-devel libicu libicu-devel libatomic linux-glibc-devel
 Inform "fetch coreclr packages"
 fetch_tizen_pkgs armv7l lldb lldb-devel libgcc libstdc++ libstdc++-devel libunwind libunwind-devel lttng-ust-devel lttng-ust userspace-rcu-devel userspace-rcu
 Inform "fetch corefx packages"
-fetch_tizen_pkgs armv7l libcom_err libcom_err-devel zlib zlib-devel libopenssl libopenssl-devel krb5 krb5-devel libcurl libcurl-devel
+fetch_tizen_pkgs armv7l libcom_err libcom_err-devel zlib zlib-devel libopenssl11 libopenssl1.1-devel krb5 krb5-devel
 
 Inform "Initialize standard unified"
 fetch_tizen_pkgs_init standard unified
diff --git a/eng/common/cross/armel/tizen/tizen.patch b/eng/common/cross/armel/tizen/tizen.patch
index d223427c978..ca7c7c1ff75 100644
--- a/eng/common/cross/armel/tizen/tizen.patch
+++ b/eng/common/cross/armel/tizen/tizen.patch
@@ -7,12 +7,3 @@ diff -u -r a/usr/lib/libc.so b/usr/lib/libc.so
  OUTPUT_FORMAT(elf32-littlearm)
 -GROUP ( /lib/libc.so.6 /usr/lib/libc_nonshared.a  AS_NEEDED ( /lib/ld-linux.so.3 ) )
 +GROUP ( libc.so.6 libc_nonshared.a  AS_NEEDED ( ld-linux.so.3 ) )
-diff -u -r a/usr/lib/libpthread.so b/usr/lib/libpthread.so
---- a/usr/lib/libpthread.so	2016-12-30 23:00:19.408951841 +0900
-+++ b/usr/lib/libpthread.so	2016-12-30 23:00:39.068951801 +0900
-@@ -2,4 +2,4 @@
-    Use the shared library, but some functions are only in
-    the static library, so try that secondarily.  */
- OUTPUT_FORMAT(elf32-littlearm)
--GROUP ( /lib/libpthread.so.0 /usr/lib/libpthread_nonshared.a )
-+GROUP ( libpthread.so.0 libpthread_nonshared.a )
diff --git a/eng/common/cross/build-android-rootfs.sh b/eng/common/cross/build-android-rootfs.sh
index adceda877ad..e7f12edb565 100755
--- a/eng/common/cross/build-android-rootfs.sh
+++ b/eng/common/cross/build-android-rootfs.sh
@@ -1,6 +1,6 @@
 #!/usr/bin/env bash
 set -e
-__NDK_Version=r14
+__NDK_Version=r21
 
 usage()
 {
@@ -16,11 +16,11 @@ usage()
     echo.
     echo "By default, the NDK will be downloaded into the cross/android-rootfs/android-ndk-$__NDK_Version directory. If you already have an NDK installation,"
     echo "you can set the NDK_DIR environment variable to have this script use that installation of the NDK."
-    echo "By default, this script will generate a file, android_platform, in the root of the ROOTFS_DIR directory that contains the RID for the supported and tested Android build: android.21-arm64. This file is to replace '/etc/os-release', which is not available for Android."
+    echo "By default, this script will generate a file, android_platform, in the root of the ROOTFS_DIR directory that contains the RID for the supported and tested Android build: android.28-arm64. This file is to replace '/etc/os-release', which is not available for Android."
     exit 1
 }
 
-__ApiLevel=21 # The minimum platform for arm64 is API level 21
+__ApiLevel=28 # The minimum platform for arm64 is API level 21 but the minimum version that support glob(3) is 28. See $ANDROID_NDK/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/glob.h
 __BuildArch=arm64
 __AndroidArch=aarch64
 __AndroidToolchain=aarch64-linux-android
@@ -53,13 +53,20 @@ for i in "$@"
 done
 
 # Obtain the location of the bash script to figure out where the root of the repo is.
-__CrossDir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
+__ScriptBaseDir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
 
-__Android_Cross_Dir="$__CrossDir/android-rootfs"
-__NDK_Dir="$__Android_Cross_Dir/android-ndk-$__NDK_Version"
-__libunwind_Dir="$__Android_Cross_Dir/libunwind"
-__lldb_Dir="$__Android_Cross_Dir/lldb"
-__ToolchainDir="$__Android_Cross_Dir/toolchain/$__BuildArch"
+__CrossDir="$__ScriptBaseDir/../../../.tools/android-rootfs"
+
+if [[ ! -f "$__CrossDir" ]]; then
+    mkdir -p "$__CrossDir"
+fi
+
+# Resolve absolute path to avoid `../` in build logs
+__CrossDir="$( cd "$__CrossDir" && pwd )"
+
+__NDK_Dir="$__CrossDir/android-ndk-$__NDK_Version"
+__lldb_Dir="$__CrossDir/lldb"
+__ToolchainDir="$__CrossDir/android-ndk-$__NDK_Version"
 
 if [[ -n "$TOOLCHAIN_DIR" ]]; then
     __ToolchainDir=$TOOLCHAIN_DIR
@@ -78,60 +85,47 @@ echo "Target Toolchain location: $__ToolchainDir"
 if [ ! -d $__NDK_Dir ]; then
     echo Downloading the NDK into $__NDK_Dir
     mkdir -p $__NDK_Dir
-    wget -nv -nc --show-progress https://dl.google.com/android/repository/android-ndk-$__NDK_Version-linux-x86_64.zip -O $__Android_Cross_Dir/android-ndk-$__NDK_Version-linux-x86_64.zip
-    unzip -q $__Android_Cross_Dir/android-ndk-$__NDK_Version-linux-x86_64.zip -d $__Android_Cross_Dir
+    wget -q --progress=bar:force:noscroll --show-progress https://dl.google.com/android/repository/android-ndk-$__NDK_Version-linux-x86_64.zip -O $__CrossDir/android-ndk-$__NDK_Version-linux-x86_64.zip
+    unzip -q $__CrossDir/android-ndk-$__NDK_Version-linux-x86_64.zip -d $__CrossDir
 fi
 
 if [ ! -d $__lldb_Dir ]; then
     mkdir -p $__lldb_Dir
     echo Downloading LLDB into $__lldb_Dir
-    wget -nv -nc --show-progress https://dl.google.com/android/repository/lldb-2.3.3614996-linux-x86_64.zip -O $__Android_Cross_Dir/lldb-2.3.3614996-linux-x86_64.zip
-    unzip -q $__Android_Cross_Dir/lldb-2.3.3614996-linux-x86_64.zip -d $__lldb_Dir
+    wget -q --progress=bar:force:noscroll --show-progress https://dl.google.com/android/repository/lldb-2.3.3614996-linux-x86_64.zip -O $__CrossDir/lldb-2.3.3614996-linux-x86_64.zip
+    unzip -q $__CrossDir/lldb-2.3.3614996-linux-x86_64.zip -d $__lldb_Dir
 fi
 
-# Create the RootFS for both arm64 as well as aarch
-rm -rf $__Android_Cross_Dir/toolchain
-
-echo Generating the $__BuildArch toolchain
-$__NDK_Dir/build/tools/make_standalone_toolchain.py --arch $__BuildArch --api $__ApiLevel --install-dir $__ToolchainDir
-
-# Install the required packages into the toolchain
-# TODO: Add logic to get latest pkg version instead of specific version number
-rm -rf $__Android_Cross_Dir/deb/
-rm -rf $__Android_Cross_Dir/tmp
-
-mkdir -p $__Android_Cross_Dir/deb/
-mkdir -p $__Android_Cross_Dir/tmp/$arch/
-wget -nv -nc http://termux.net/dists/stable/main/binary-$__AndroidArch/libicu_60.2_$__AndroidArch.deb -O $__Android_Cross_Dir/deb/libicu_60.2_$__AndroidArch.deb
-wget -nv -nc http://termux.net/dists/stable/main/binary-$__AndroidArch/libicu-dev_60.2_$__AndroidArch.deb -O $__Android_Cross_Dir/deb/libicu-dev_60.2_$__AndroidArch.deb
-
-wget -nv -nc http://termux.net/dists/stable/main/binary-$__AndroidArch/libandroid-glob-dev_0.4_$__AndroidArch.deb -O $__Android_Cross_Dir/deb/libandroid-glob-dev_0.4_$__AndroidArch.deb
-wget -nv -nc http://termux.net/dists/stable/main/binary-$__AndroidArch/libandroid-glob_0.4_$__AndroidArch.deb -O $__Android_Cross_Dir/deb/libandroid-glob_0.4_$__AndroidArch.deb
-wget -nv -nc http://termux.net/dists/stable/main/binary-$__AndroidArch/libandroid-support-dev_22_$__AndroidArch.deb -O $__Android_Cross_Dir/deb/libandroid-support-dev_22_$__AndroidArch.deb
-wget -nv -nc http://termux.net/dists/stable/main/binary-$__AndroidArch/libandroid-support_22_$__AndroidArch.deb -O $__Android_Cross_Dir/deb/libandroid-support_22_$__AndroidArch.deb
-wget -nv -nc http://termux.net/dists/stable/main/binary-$__AndroidArch/liblzma-dev_5.2.3_$__AndroidArch.deb  -O $__Android_Cross_Dir/deb/liblzma-dev_5.2.3_$__AndroidArch.deb
-wget -nv -nc http://termux.net/dists/stable/main/binary-$__AndroidArch/liblzma_5.2.3_$__AndroidArch.deb -O $__Android_Cross_Dir/deb/liblzma_5.2.3_$__AndroidArch.deb
-wget -nv -nc http://termux.net/dists/stable/main/binary-$__AndroidArch/libunwind-dev_1.2.20170304_$__AndroidArch.deb  -O $__Android_Cross_Dir/deb/libunwind-dev_1.2.20170304_$__AndroidArch.deb
-wget -nv -nc http://termux.net/dists/stable/main/binary-$__AndroidArch/libunwind_1.2.20170304_$__AndroidArch.deb -O $__Android_Cross_Dir/deb/libunwind_1.2.20170304_$__AndroidArch.deb
-
-echo Unpacking Termux packages
-dpkg -x $__Android_Cross_Dir/deb/libicu_60.2_$__AndroidArch.deb $__Android_Cross_Dir/tmp/$__AndroidArch/
-dpkg -x $__Android_Cross_Dir/deb/libicu-dev_60.2_$__AndroidArch.deb $__Android_Cross_Dir/tmp/$__AndroidArch/
-dpkg -x $__Android_Cross_Dir/deb/libandroid-glob-dev_0.4_$__AndroidArch.deb $__Android_Cross_Dir/tmp/$__AndroidArch/
-dpkg -x $__Android_Cross_Dir/deb/libandroid-glob_0.4_$__AndroidArch.deb $__Android_Cross_Dir/tmp/$__AndroidArch/
-dpkg -x $__Android_Cross_Dir/deb/libandroid-support-dev_22_$__AndroidArch.deb $__Android_Cross_Dir/tmp/$__AndroidArch/
-dpkg -x $__Android_Cross_Dir/deb/libandroid-support_22_$__AndroidArch.deb $__Android_Cross_Dir/tmp/$__AndroidArch/
-dpkg -x $__Android_Cross_Dir/deb/liblzma-dev_5.2.3_$__AndroidArch.deb $__Android_Cross_Dir/tmp/$__AndroidArch/
-dpkg -x $__Android_Cross_Dir/deb/liblzma_5.2.3_$__AndroidArch.deb $__Android_Cross_Dir/tmp/$__AndroidArch/
-dpkg -x $__Android_Cross_Dir/deb/libunwind-dev_1.2.20170304_$__AndroidArch.deb $__Android_Cross_Dir/tmp/$__AndroidArch/
-dpkg -x $__Android_Cross_Dir/deb/libunwind_1.2.20170304_$__AndroidArch.deb $__Android_Cross_Dir/tmp/$__AndroidArch/
-
-cp -R $__Android_Cross_Dir/tmp/$__AndroidArch/data/data/com.termux/files/usr/* $__ToolchainDir/sysroot/usr/
+echo "Download dependencies..."
+__TmpDir=$__CrossDir/tmp/$__BuildArch/
+mkdir -p "$__TmpDir"
 
-# Generate platform file for build.sh script to assign to __DistroRid
-echo "Generating platform file..."
+# combined dependencies for coreclr, installer and libraries
+__AndroidPackages="libicu"
+__AndroidPackages+=" libandroid-glob"
+__AndroidPackages+=" liblzma"
+__AndroidPackages+=" krb5"
+__AndroidPackages+=" openssl"
 
-echo "RID=android.21-arm64" > $__ToolchainDir/sysroot/android_platform
-echo Now run:
-echo CONFIG_DIR=\`realpath cross/android/$__BuildArch\` ROOTFS_DIR=\`realpath $__ToolchainDir/sysroot\` ./build.sh cross $__BuildArch skipgenerateversion skipnuget cmakeargs -DENABLE_LLDBPLUGIN=0
+for path in $(wget -qO- http://termux.net/dists/stable/main/binary-$__AndroidArch/Packages |\
+    grep -A15 "Package: \(${__AndroidPackages// /\\|}\)" | grep -v "static\|tool" | grep Filename); do
 
+    if [[ "$path" != "Filename:" ]]; then
+        echo "Working on: $path"
+        wget -qO- http://termux.net/$path | dpkg -x - "$__TmpDir"
+    fi
+done
+
+cp -R "$__TmpDir/data/data/com.termux/files/usr/"* "$__ToolchainDir/sysroot/usr/"
+
+# Generate platform file for build.sh script to assign to __DistroRid
+echo "Generating platform file..."
+echo "RID=android.${__ApiLevel}-${__BuildArch}" > $__ToolchainDir/sysroot/android_platform
+
+echo "Now to build coreclr, libraries and installers; run:"
+echo ROOTFS_DIR=\$\(realpath $__ToolchainDir/sysroot\) ./build.sh --cross --arch $__BuildArch \
+    --subsetCategory coreclr
+echo ROOTFS_DIR=\$\(realpath $__ToolchainDir/sysroot\) ./build.sh --cross --arch $__BuildArch \
+    --subsetCategory libraries
+echo ROOTFS_DIR=\$\(realpath $__ToolchainDir/sysroot\) ./build.sh --cross --arch $__BuildArch \
+    --subsetCategory installer
diff --git a/eng/common/cross/build-rootfs.sh b/eng/common/cross/build-rootfs.sh
index d7d5d7d5f44..ffdff38542e 100755
--- a/eng/common/cross/build-rootfs.sh
+++ b/eng/common/cross/build-rootfs.sh
@@ -1,19 +1,26 @@
 #!/usr/bin/env bash
 
+set -e
+
 usage()
 {
-    echo "Usage: $0 [BuildArch] [LinuxCodeName] [lldbx.y] [--skipunmount] --rootfsdir <directory>]"
+    echo "Usage: $0 [BuildArch] [CodeName] [lldbx.y] [--skipunmount] --rootfsdir <directory>]"
     echo "BuildArch can be: arm(default), armel, arm64, x86"
-    echo "LinuxCodeName - optional, Code name for Linux, can be: trusty, xenial(default), zesty, bionic, alpine. If BuildArch is armel, LinuxCodeName is jessie(default) or tizen."
-    echo "lldbx.y - optional, LLDB version, can be: lldb3.9(default), lldb4.0, lldb5.0, lldb6.0 no-lldb. Ignored for alpine"
+    echo "CodeName - optional, Code name for Linux, can be: trusty, xenial(default), zesty, bionic, alpine. If BuildArch is armel, LinuxCodeName is jessie(default) or tizen."
+    echo "                              for FreeBSD can be: freebsd11 or freebsd12."
+    echo "                              for illumos can be: illumos."
+    echo "lldbx.y - optional, LLDB version, can be: lldb3.9(default), lldb4.0, lldb5.0, lldb6.0 no-lldb. Ignored for alpine and FReeBSD"
     echo "--skipunmount - optional, will skip the unmount of rootfs folder."
+    echo "--use-mirror - optional, use mirror URL to fetch resources, when available."
     exit 1
 }
 
-__LinuxCodeName=xenial
+__CodeName=xenial
 __CrossDir=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
 __InitialDir=$PWD
 __BuildArch=arm
+__AlpineArch=armv7
+__QEMUArch=arm
 __UbuntuArch=armhf
 __UbuntuRepo="http://ports.ubuntu.com/"
 __LLDB_Package="liblldb-3.9-dev"
@@ -25,8 +32,10 @@ __UbuntuPackages="build-essential"
 __AlpinePackages="alpine-base"
 __AlpinePackages+=" build-base"
 __AlpinePackages+=" linux-headers"
-__AlpinePackages+=" lldb-dev"
-__AlpinePackages+=" llvm-dev"
+__AlpinePackagesEdgeCommunity=" lldb-dev"
+__AlpinePackagesEdgeMain=" llvm10-libs"
+__AlpinePackagesEdgeMain+=" python3"
+__AlpinePackagesEdgeMain+=" libedit"
 
 # symlinks fixer
 __UbuntuPackages+=" symlinks"
@@ -52,6 +61,21 @@ __AlpinePackages+=" krb5-dev"
 __AlpinePackages+=" openssl-dev"
 __AlpinePackages+=" zlib-dev"
 
+__FreeBSDBase="12.1-RELEASE"
+__FreeBSDPkg="1.12.0"
+__FreeBSDPackages="libunwind"
+__FreeBSDPackages+=" icu"
+__FreeBSDPackages+=" libinotify"
+__FreeBSDPackages+=" lttng-ust"
+__FreeBSDPackages+=" krb5"
+
+__IllumosPackages="icu-64.2nb2"
+__IllumosPackages+=" mit-krb5-1.16.2nb4"
+__IllumosPackages+=" openssl-1.1.1e"
+__IllumosPackages+=" zlib-1.2.11"
+
+__UseMirror=0
+
 __UnprocessedBuildArgs=
 while :; do
     if [ $# -le 0 ]; then
@@ -67,7 +91,7 @@ while :; do
         arm)
             __BuildArch=arm
             __UbuntuArch=armhf
-            __AlpineArch=armhf
+            __AlpineArch=armv7
             __QEMUArch=arm
             ;;
         arm64)
@@ -80,7 +104,7 @@ while :; do
             __BuildArch=armel
             __UbuntuArch=armel
             __UbuntuRepo="http://ftp.debian.org/debian/"
-            __LinuxCodeName=jessie
+            __CodeName=jessie
             ;;
         x86)
             __BuildArch=x86
@@ -109,53 +133,66 @@ while :; do
             unset __LLDB_Package
             ;;
         trusty) # Ubuntu 14.04
-            if [ "$__LinuxCodeName" != "jessie" ]; then
-                __LinuxCodeName=trusty
+            if [ "$__CodeName" != "jessie" ]; then
+                __CodeName=trusty
             fi
             ;;
         xenial) # Ubuntu 16.04
-            if [ "$__LinuxCodeName" != "jessie" ]; then
-                __LinuxCodeName=xenial
+            if [ "$__CodeName" != "jessie" ]; then
+                __CodeName=xenial
             fi
             ;;
         zesty) # Ubuntu 17.04
-            if [ "$__LinuxCodeName" != "jessie" ]; then
-                __LinuxCodeName=zesty
+            if [ "$__CodeName" != "jessie" ]; then
+                __CodeName=zesty
             fi
             ;;
         bionic) # Ubuntu 18.04
-            if [ "$__LinuxCodeName" != "jessie" ]; then
-                __LinuxCodeName=bionic
+            if [ "$__CodeName" != "jessie" ]; then
+                __CodeName=bionic
             fi
             ;;
         jessie) # Debian 8
-            __LinuxCodeName=jessie
+            __CodeName=jessie
             __UbuntuRepo="http://ftp.debian.org/debian/"
             ;;
         stretch) # Debian 9
-            __LinuxCodeName=stretch
+            __CodeName=stretch
             __UbuntuRepo="http://ftp.debian.org/debian/"
             __LLDB_Package="liblldb-6.0-dev"
             ;;
         buster) # Debian 10
-            __LinuxCodeName=buster
+            __CodeName=buster
             __UbuntuRepo="http://ftp.debian.org/debian/"
             __LLDB_Package="liblldb-6.0-dev"
             ;;
         tizen)
-            if [ "$__BuildArch" != "armel" ]; then
-                echo "Tizen is available only for armel."
+            if [ "$__BuildArch" != "armel" ] && [ "$__BuildArch" != "arm64" ]; then
+                echo "Tizen is available only for armel and arm64."
                 usage;
                 exit 1;
             fi
-            __LinuxCodeName=
+            __CodeName=
             __UbuntuRepo=
             __Tizen=tizen
             ;;
         alpine)
-            __LinuxCodeName=alpine
+            __CodeName=alpine
             __UbuntuRepo=
             ;;
+        freebsd11)
+            __FreeBSDBase="11.3-RELEASE"
+            ;&
+        freebsd12)
+            __CodeName=freebsd
+            __BuildArch=x64
+            __SkipUnmount=1
+            ;;
+        illumos)
+            __CodeName=illumos
+            __BuildArch=x64
+            __SkipUnmount=1
+            ;;
         --skipunmount)
             __SkipUnmount=1
             ;;
@@ -163,6 +200,9 @@ while :; do
             shift
             __RootfsDir=$1
             ;;
+        --use-mirror)
+            __UseMirror=1
+            ;;
         *)
             __UnprocessedBuildArgs="$__UnprocessedBuildArgs $1"
             ;;
@@ -186,46 +226,121 @@ fi
 
 if [ -d "$__RootfsDir" ]; then
     if [ $__SkipUnmount == 0 ]; then
-        umount $__RootfsDir/*
+        umount $__RootfsDir/* || true
     fi
     rm -rf $__RootfsDir
 fi
 
-if [[ "$__LinuxCodeName" == "alpine" ]]; then
+mkdir -p $__RootfsDir
+__RootfsDir="$( cd "$__RootfsDir" && pwd )"
+
+if [[ "$__CodeName" == "alpine" ]]; then
     __ApkToolsVersion=2.9.1
-    __AlpineVersion=3.7
+    __AlpineVersion=3.9
     __ApkToolsDir=$(mktemp -d)
     wget https://github.com/alpinelinux/apk-tools/releases/download/v$__ApkToolsVersion/apk-tools-$__ApkToolsVersion-x86_64-linux.tar.gz -P $__ApkToolsDir
     tar -xf $__ApkToolsDir/apk-tools-$__ApkToolsVersion-x86_64-linux.tar.gz -C $__ApkToolsDir
     mkdir -p $__RootfsDir/usr/bin
     cp -v /usr/bin/qemu-$__QEMUArch-static $__RootfsDir/usr/bin
+
     $__ApkToolsDir/apk-tools-$__ApkToolsVersion/apk \
       -X http://dl-cdn.alpinelinux.org/alpine/v$__AlpineVersion/main \
       -X http://dl-cdn.alpinelinux.org/alpine/v$__AlpineVersion/community \
-      -X http://dl-cdn.alpinelinux.org/alpine/edge/testing \
-      -X http://dl-cdn.alpinelinux.org/alpine/edge/main \
       -U --allow-untrusted --root $__RootfsDir --arch $__AlpineArch --initdb \
       add $__AlpinePackages
+
+    $__ApkToolsDir/apk-tools-$__ApkToolsVersion/apk \
+      -X http://dl-cdn.alpinelinux.org/alpine/edge/main \
+      -U --allow-untrusted --root $__RootfsDir --arch $__AlpineArch --initdb \
+      add $__AlpinePackagesEdgeMain
+
+    $__ApkToolsDir/apk-tools-$__ApkToolsVersion/apk \
+      -X http://dl-cdn.alpinelinux.org/alpine/edge/community \
+      -U --allow-untrusted --root $__RootfsDir --arch $__AlpineArch --initdb \
+      add $__AlpinePackagesEdgeCommunity
+
     rm -r $__ApkToolsDir
-elif [[ -n $__LinuxCodeName ]]; then
-    qemu-debootstrap --arch $__UbuntuArch $__LinuxCodeName $__RootfsDir $__UbuntuRepo
-    cp $__CrossDir/$__BuildArch/sources.list.$__LinuxCodeName $__RootfsDir/etc/apt/sources.list
+elif [[ "$__CodeName" == "freebsd" ]]; then
+    mkdir -p $__RootfsDir/usr/local/etc
+    wget -O - https://download.freebsd.org/ftp/releases/amd64/${__FreeBSDBase}/base.txz | tar -C $__RootfsDir -Jxf - ./lib ./usr/lib ./usr/libdata ./usr/include ./usr/share/keys ./etc ./bin/freebsd-version
+    # For now, ask for 11 ABI even on 12. This can be revisited later.
+    echo "ABI = \"FreeBSD:11:amd64\"; FINGERPRINTS = \"${__RootfsDir}/usr/share/keys\"; REPOS_DIR = [\"${__RootfsDir}/etc/pkg\"]; REPO_AUTOUPDATE = NO; RUN_SCRIPTS = NO;" > ${__RootfsDir}/usr/local/etc/pkg.conf
+    echo "FreeBSD: { url: "pkg+http://pkg.FreeBSD.org/\${ABI}/quarterly", mirror_type: \"srv\", signature_type: \"fingerprints\", fingerprints: \"${__RootfsDir}/usr/share/keys/pkg\", enabled: yes }" > ${__RootfsDir}/etc/pkg/FreeBSD.conf
+    mkdir -p $__RootfsDir/tmp
+    # get and build package manager
+    wget -O -  https://github.com/freebsd/pkg/archive/${__FreeBSDPkg}.tar.gz  |  tar -C $__RootfsDir/tmp -zxf -
+    cd $__RootfsDir/tmp/pkg-${__FreeBSDPkg}
+    # needed for install to succeed
+    mkdir -p $__RootfsDir/host/etc
+    ./autogen.sh && ./configure --prefix=$__RootfsDir/host && make && make install
+    rm -rf $__RootfsDir/tmp/pkg-${__FreeBSDPkg}
+    # install packages we need.
+    INSTALL_AS_USER=$(whoami) $__RootfsDir/host/sbin/pkg -r $__RootfsDir -C $__RootfsDir/usr/local/etc/pkg.conf update
+    INSTALL_AS_USER=$(whoami) $__RootfsDir/host/sbin/pkg -r $__RootfsDir -C $__RootfsDir/usr/local/etc/pkg.conf install --yes $__FreeBSDPackages
+elif [[ "$__CodeName" == "illumos" ]]; then
+    mkdir "$__RootfsDir/tmp"
+    pushd "$__RootfsDir/tmp"
+    JOBS="$(getconf _NPROCESSORS_ONLN)"
+    echo "Downloading sysroot."
+    wget -O - https://github.com/illumos/sysroot/releases/download/20181213-de6af22ae73b-v1/illumos-sysroot-i386-20181213-de6af22ae73b-v1.tar.gz | tar -C "$__RootfsDir" -xzf -
+    echo "Building binutils. Please wait.."
+    wget -O - https://ftp.gnu.org/gnu/binutils/binutils-2.33.1.tar.bz2 | tar -xjf -
+    mkdir build-binutils && cd build-binutils
+    ../binutils-2.33.1/configure --prefix="$__RootfsDir" --target="x86_64-sun-solaris2.10" --program-prefix="x86_64-illumos-" --with-sysroot="$__RootfsDir"
+    make -j "$JOBS" && make install && cd ..
+    echo "Building gcc. Please wait.."
+    wget -O - https://ftp.gnu.org/gnu/gcc/gcc-8.4.0/gcc-8.4.0.tar.xz | tar -xJf -
+    CFLAGS="-fPIC"
+    CXXFLAGS="-fPIC"
+    CXXFLAGS_FOR_TARGET="-fPIC"
+    CFLAGS_FOR_TARGET="-fPIC"
+    export CFLAGS CXXFLAGS CXXFLAGS_FOR_TARGET CFLAGS_FOR_TARGET
+    mkdir build-gcc && cd build-gcc
+    ../gcc-8.4.0/configure --prefix="$__RootfsDir" --target="x86_64-sun-solaris2.10" --program-prefix="x86_64-illumos-" --with-sysroot="$__RootfsDir" --with-gnu-as       \
+        --with-gnu-ld --disable-nls --disable-libgomp --disable-libquadmath --disable-libssp --disable-libvtv --disable-libcilkrts --disable-libada --disable-libsanitizer \
+        --disable-libquadmath-support --disable-shared --enable-tls
+    make -j "$JOBS" && make install && cd ..
+    BaseUrl=https://pkgsrc.joyent.com
+    if [[ "$__UseMirror" == 1 ]]; then
+        BaseUrl=http://pkgsrc.smartos.skylime.net
+    fi
+    BaseUrl="$BaseUrl"/packages/SmartOS/2020Q1/x86_64/All
+    echo "Downloading dependencies."
+    read -ra array <<<"$__IllumosPackages"
+    for package in "${array[@]}"; do
+       echo "Installing $package..."
+        wget "$BaseUrl"/"$package".tgz
+        ar -x "$package".tgz
+        tar --skip-old-files -xzf "$package".tmp.tgz -C "$__RootfsDir" 2>/dev/null
+    done
+    echo "Cleaning up temporary files."
+    popd
+    rm -rf "$__RootfsDir"/{tmp,+*}
+    mkdir -p "$__RootfsDir"/usr/include/net
+    mkdir -p "$__RootfsDir"/usr/include/netpacket
+    wget -P "$__RootfsDir"/usr/include/net https://raw.githubusercontent.com/illumos/illumos-gate/master/usr/src/uts/common/io/bpf/net/bpf.h
+    wget -P "$__RootfsDir"/usr/include/net https://raw.githubusercontent.com/illumos/illumos-gate/master/usr/src/uts/common/io/bpf/net/dlt.h
+    wget -P "$__RootfsDir"/usr/include/netpacket https://raw.githubusercontent.com/illumos/illumos-gate/master/usr/src/uts/common/inet/sockmods/netpacket/packet.h
+    wget -P "$__RootfsDir"/usr/include/sys https://raw.githubusercontent.com/illumos/illumos-gate/master/usr/src/uts/common/sys/sdt.h
+elif [[ -n $__CodeName ]]; then
+    qemu-debootstrap --arch $__UbuntuArch $__CodeName $__RootfsDir $__UbuntuRepo
+    cp $__CrossDir/$__BuildArch/sources.list.$__CodeName $__RootfsDir/etc/apt/sources.list
     chroot $__RootfsDir apt-get update
     chroot $__RootfsDir apt-get -f -y install
     chroot $__RootfsDir apt-get -y install $__UbuntuPackages
     chroot $__RootfsDir symlinks -cr /usr
 
     if [ $__SkipUnmount == 0 ]; then
-        umount $__RootfsDir/*
+        umount $__RootfsDir/* || true
     fi
 
-    if [[ "$__BuildArch" == "arm" && "$__LinuxCodeName" == "trusty" ]]; then
+    if [[ "$__BuildArch" == "arm" && "$__CodeName" == "trusty" ]]; then
         pushd $__RootfsDir
         patch -p1 < $__CrossDir/$__BuildArch/trusty.patch
         patch -p1 < $__CrossDir/$__BuildArch/trusty-lttng-2.4.patch
         popd
     fi
-elif [ "$__Tizen" == "tizen" ]; then
+elif [[ "$__Tizen" == "tizen" ]]; then
     ROOTFS_DIR=$__RootfsDir $__CrossDir/$__BuildArch/tizen-build-rootfs.sh
 else
     echo "Unsupported target platform."
diff --git a/eng/common/cross/toolchain.cmake b/eng/common/cross/toolchain.cmake
index 071d4112419..137736c0a27 100644
--- a/eng/common/cross/toolchain.cmake
+++ b/eng/common/cross/toolchain.cmake
@@ -1,18 +1,27 @@
 set(CROSS_ROOTFS $ENV{ROOTFS_DIR})
 
 set(TARGET_ARCH_NAME $ENV{TARGET_BUILD_ARCH})
-set(CMAKE_SYSTEM_NAME Linux)
+if(EXISTS ${CROSS_ROOTFS}/bin/freebsd-version)
+  set(CMAKE_SYSTEM_NAME FreeBSD)
+elseif(EXISTS ${CROSS_ROOTFS}/usr/platform/i86pc)
+  set(CMAKE_SYSTEM_NAME SunOS)
+  set(ILLUMOS 1)
+else()
+  set(CMAKE_SYSTEM_NAME Linux)
+endif()
 set(CMAKE_SYSTEM_VERSION 1)
 
 if(TARGET_ARCH_NAME STREQUAL "armel")
   set(CMAKE_SYSTEM_PROCESSOR armv7l)
   set(TOOLCHAIN "arm-linux-gnueabi")
   if("$ENV{__DistroRid}" MATCHES "tizen.*")
-    set(TIZEN_TOOLCHAIN "armv7l-tizen-linux-gnueabi/6.2.1")
+    set(TIZEN_TOOLCHAIN "armv7l-tizen-linux-gnueabi/9.2.0")
   endif()
 elseif(TARGET_ARCH_NAME STREQUAL "arm")
   set(CMAKE_SYSTEM_PROCESSOR armv7l)
-  if(EXISTS ${CROSS_ROOTFS}/usr/lib/gcc/armv6-alpine-linux-musleabihf)
+  if(EXISTS ${CROSS_ROOTFS}/usr/lib/gcc/armv7-alpine-linux-musleabihf)
+    set(TOOLCHAIN "armv7-alpine-linux-musleabihf")
+  elseif(EXISTS ${CROSS_ROOTFS}/usr/lib/gcc/armv6-alpine-linux-musleabihf)
     set(TOOLCHAIN "armv6-alpine-linux-musleabihf")
   else()
     set(TOOLCHAIN "arm-linux-gnueabihf")
@@ -24,65 +33,141 @@ elseif(TARGET_ARCH_NAME STREQUAL "arm64")
   else()
     set(TOOLCHAIN "aarch64-linux-gnu")
   endif()
+  if("$ENV{__DistroRid}" MATCHES "tizen.*")
+    set(TIZEN_TOOLCHAIN "aarch64-tizen-linux-gnu/9.2.0")
+  endif()
 elseif(TARGET_ARCH_NAME STREQUAL "x86")
   set(CMAKE_SYSTEM_PROCESSOR i686)
   set(TOOLCHAIN "i686-linux-gnu")
+elseif (CMAKE_SYSTEM_NAME STREQUAL "FreeBSD")
+  set(CMAKE_SYSTEM_PROCESSOR "x86_64")
+  set(triple "x86_64-unknown-freebsd11")
+elseif (ILLUMOS)
+  set(CMAKE_SYSTEM_PROCESSOR "x86_64")
+  set(TOOLCHAIN "x86_64-illumos")
 else()
   message(FATAL_ERROR "Arch is ${TARGET_ARCH_NAME}. Only armel, arm, arm64 and x86 are supported!")
 endif()
 
+if(DEFINED ENV{TOOLCHAIN})
+  set(TOOLCHAIN $ENV{TOOLCHAIN})
+endif()
+
 # Specify include paths
-if(TARGET_ARCH_NAME STREQUAL "armel")
-  if(DEFINED TIZEN_TOOLCHAIN)
+if(DEFINED TIZEN_TOOLCHAIN)
+  if(TARGET_ARCH_NAME STREQUAL "armel")
     include_directories(SYSTEM ${CROSS_ROOTFS}/usr/lib/gcc/${TIZEN_TOOLCHAIN}/include/c++/)
     include_directories(SYSTEM ${CROSS_ROOTFS}/usr/lib/gcc/${TIZEN_TOOLCHAIN}/include/c++/armv7l-tizen-linux-gnueabi)
   endif()
+  if(TARGET_ARCH_NAME STREQUAL "arm64")
+    include_directories(SYSTEM ${CROSS_ROOTFS}/usr/lib64/gcc/${TIZEN_TOOLCHAIN}/include/c++/)
+    include_directories(SYSTEM ${CROSS_ROOTFS}/usr/lib64/gcc/${TIZEN_TOOLCHAIN}/include/c++/aarch64-tizen-linux-gnu)
+  endif()
 endif()
 
-# add_compile_param - adds only new options without duplicates.
-# arg0 - list with result options, arg1 - list with new options.
-# arg2 - optional argument, quick summary string for optional using CACHE FORCE mode.
-macro(add_compile_param)
-  if(NOT ${ARGC} MATCHES "^(2|3)$")
-    message(FATAL_ERROR "Wrong using add_compile_param! Two or three parameters must be given! See add_compile_param description.")
-  endif()
-  foreach(OPTION ${ARGV1})
-    if(NOT ${ARGV0} MATCHES "${OPTION}($| )")
-      set(${ARGV0} "${${ARGV0}} ${OPTION}")
-      if(${ARGC} EQUAL "3") # CACHE FORCE mode
-        set(${ARGV0} "${${ARGV0}}" CACHE STRING "${ARGV2}" FORCE)
-      endif()
+if("$ENV{__DistroRid}" MATCHES "android.*")
+    if(TARGET_ARCH_NAME STREQUAL "arm")
+        set(ANDROID_ABI armeabi-v7a)
+    elseif(TARGET_ARCH_NAME STREQUAL "arm64")
+        set(ANDROID_ABI arm64-v8a)
     endif()
-  endforeach()
-endmacro()
+
+    # extract platform number required by the NDK's toolchain
+    string(REGEX REPLACE ".*\\.([0-9]+)-.*" "\\1" ANDROID_PLATFORM "$ENV{__DistroRid}")
+
+    set(ANDROID_TOOLCHAIN clang)
+    set(FEATURE_EVENT_TRACE 0) # disable event trace as there is no lttng-ust package in termux repository
+    set(CMAKE_SYSTEM_LIBRARY_PATH "${CROSS_ROOTFS}/usr/lib")
+    set(CMAKE_SYSTEM_INCLUDE_PATH "${CROSS_ROOTFS}/usr/include")
+
+    # include official NDK toolchain script
+    include(${CROSS_ROOTFS}/../build/cmake/android.toolchain.cmake)
+elseif(CMAKE_SYSTEM_NAME STREQUAL "FreeBSD")
+    # we cross-compile by instructing clang
+    set(CMAKE_C_COMPILER_TARGET ${triple})
+    set(CMAKE_CXX_COMPILER_TARGET ${triple})
+    set(CMAKE_ASM_COMPILER_TARGET ${triple})
+    set(CMAKE_SYSROOT "${CROSS_ROOTFS}")
+elseif(ILLUMOS)
+    set(CMAKE_SYSROOT "${CROSS_ROOTFS}")
+
+    include_directories(SYSTEM ${CROSS_ROOTFS}/include)
+
+    set(TOOLSET_PREFIX ${TOOLCHAIN}-)
+    function(locate_toolchain_exec exec var)
+        string(TOUPPER ${exec} EXEC_UPPERCASE)
+        if(NOT "$ENV{CLR_${EXEC_UPPERCASE}}" STREQUAL "")
+            set(${var} "$ENV{CLR_${EXEC_UPPERCASE}}" PARENT_SCOPE)
+            return()
+        endif()
+
+        find_program(EXEC_LOCATION_${exec}
+            NAMES
+            "${TOOLSET_PREFIX}${exec}${CLR_CMAKE_COMPILER_FILE_NAME_VERSION}"
+            "${TOOLSET_PREFIX}${exec}")
+
+        if (EXEC_LOCATION_${exec} STREQUAL "EXEC_LOCATION_${exec}-NOTFOUND")
+            message(FATAL_ERROR "Unable to find toolchain executable. Name: ${exec}, Prefix: ${TOOLSET_PREFIX}.")
+        endif()
+        set(${var} ${EXEC_LOCATION_${exec}} PARENT_SCOPE)
+    endfunction()
+
+    set(CMAKE_SYSTEM_PREFIX_PATH "${CROSS_ROOTFS}")
+
+    locate_toolchain_exec(gcc CMAKE_C_COMPILER)
+    locate_toolchain_exec(g++ CMAKE_CXX_COMPILER)
+
+    set(CMAKE_C_STANDARD_LIBRARIES "${CMAKE_C_STANDARD_LIBRARIES} -lssp")
+    set(CMAKE_CXX_STANDARD_LIBRARIES "${CMAKE_CXX_STANDARD_LIBRARIES} -lssp")
+else()
+    set(CMAKE_SYSROOT "${CROSS_ROOTFS}")
+
+    set(CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN "${CROSS_ROOTFS}/usr")
+    set(CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN "${CROSS_ROOTFS}/usr")
+    set(CMAKE_ASM_COMPILER_EXTERNAL_TOOLCHAIN "${CROSS_ROOTFS}/usr")
+endif()
 
 # Specify link flags
-add_compile_param(CROSS_LINK_FLAGS "--sysroot=${CROSS_ROOTFS}")
-add_compile_param(CROSS_LINK_FLAGS "--gcc-toolchain=${CROSS_ROOTFS}/usr")
-add_compile_param(CROSS_LINK_FLAGS "--target=${TOOLCHAIN}")
-add_compile_param(CROSS_LINK_FLAGS "-fuse-ld=gold")
+
+function(add_toolchain_linker_flag Flag)
+  set(Config "${ARGV1}")
+  set(CONFIG_SUFFIX "")
+  if (NOT Config STREQUAL "")
+    set(CONFIG_SUFFIX "_${Config}")
+  endif()
+  set("CMAKE_EXE_LINKER_FLAGS${CONFIG_SUFFIX}" "${CMAKE_EXE_LINKER_FLAGS${CONFIG_SUFFIX}} ${Flag}" PARENT_SCOPE)
+  set("CMAKE_SHARED_LINKER_FLAGS${CONFIG_SUFFIX}" "${CMAKE_SHARED_LINKER_FLAGS${CONFIG_SUFFIX}} ${Flag}" PARENT_SCOPE)
+endfunction()
+
 
 if(TARGET_ARCH_NAME STREQUAL "armel")
   if(DEFINED TIZEN_TOOLCHAIN) # For Tizen only
-    add_compile_param(CROSS_LINK_FLAGS "-B${CROSS_ROOTFS}/usr/lib/gcc/${TIZEN_TOOLCHAIN}")
-    add_compile_param(CROSS_LINK_FLAGS "-L${CROSS_ROOTFS}/lib")
-    add_compile_param(CROSS_LINK_FLAGS "-L${CROSS_ROOTFS}/usr/lib")
-    add_compile_param(CROSS_LINK_FLAGS "-L${CROSS_ROOTFS}/usr/lib/gcc/${TIZEN_TOOLCHAIN}")
+    add_toolchain_linker_flag("-B${CROSS_ROOTFS}/usr/lib/gcc/${TIZEN_TOOLCHAIN}")
+    add_toolchain_linker_flag("-L${CROSS_ROOTFS}/lib")
+    add_toolchain_linker_flag("-L${CROSS_ROOTFS}/usr/lib")
+    add_toolchain_linker_flag("-L${CROSS_ROOTFS}/usr/lib/gcc/${TIZEN_TOOLCHAIN}")
+  endif()
+elseif(TARGET_ARCH_NAME STREQUAL "arm64")
+  if(DEFINED TIZEN_TOOLCHAIN) # For Tizen only
+    add_toolchain_linker_flag("-B${CROSS_ROOTFS}/usr/lib64/gcc/${TIZEN_TOOLCHAIN}")
+    add_toolchain_linker_flag("-L${CROSS_ROOTFS}/lib64")
+    add_toolchain_linker_flag("-L${CROSS_ROOTFS}/usr/lib64")
+    add_toolchain_linker_flag("-L${CROSS_ROOTFS}/usr/lib64/gcc/${TIZEN_TOOLCHAIN}")
+
+    add_toolchain_linker_flag("-Wl,--rpath-link=${CROSS_ROOTFS}/lib64")
+    add_toolchain_linker_flag("-Wl,--rpath-link=${CROSS_ROOTFS}/usr/lib64")
+    add_toolchain_linker_flag("-Wl,--rpath-link=${CROSS_ROOTFS}/usr/lib64/gcc/${TIZEN_TOOLCHAIN}")
   endif()
 elseif(TARGET_ARCH_NAME STREQUAL "x86")
-  add_compile_param(CROSS_LINK_FLAGS "-m32")
+  add_toolchain_linker_flag(-m32)
+elseif(ILLUMOS)
+  add_toolchain_linker_flag("-L${CROSS_ROOTFS}/lib/amd64")
+  add_toolchain_linker_flag("-L${CROSS_ROOTFS}/usr/amd64/lib")
 endif()
 
-add_compile_param(CMAKE_EXE_LINKER_FLAGS "${CROSS_LINK_FLAGS}" "TOOLCHAIN_EXE_LINKER_FLAGS")
-add_compile_param(CMAKE_SHARED_LINKER_FLAGS "${CROSS_LINK_FLAGS}" "TOOLCHAIN_EXE_LINKER_FLAGS")
-add_compile_param(CMAKE_MODULE_LINKER_FLAGS "${CROSS_LINK_FLAGS}" "TOOLCHAIN_EXE_LINKER_FLAGS")
-
 # Specify compile options
-add_compile_options("--sysroot=${CROSS_ROOTFS}")
-add_compile_options("--target=${TOOLCHAIN}")
-add_compile_options("--gcc-toolchain=${CROSS_ROOTFS}/usr")
 
-if(TARGET_ARCH_NAME MATCHES "^(arm|armel|arm64)$")
+if((TARGET_ARCH_NAME MATCHES "^(arm|armel|arm64)$" AND NOT "$ENV{__DistroRid}" MATCHES "android.*") OR ILLUMOS)
   set(CMAKE_C_COMPILER_TARGET ${TOOLCHAIN})
   set(CMAKE_CXX_COMPILER_TARGET ${TOOLCHAIN})
   set(CMAKE_ASM_COMPILER_TARGET ${TOOLCHAIN})
@@ -90,20 +175,33 @@ endif()
 
 if(TARGET_ARCH_NAME MATCHES "^(arm|armel)$")
   add_compile_options(-mthumb)
-  add_compile_options(-mfpu=vfpv3)
+  if (NOT DEFINED CLR_ARM_FPU_TYPE)
+    set (CLR_ARM_FPU_TYPE vfpv3)
+  endif (NOT DEFINED CLR_ARM_FPU_TYPE)
+
+  add_compile_options (-mfpu=${CLR_ARM_FPU_TYPE})
+  if (NOT DEFINED CLR_ARM_FPU_CAPABILITY)
+    set (CLR_ARM_FPU_CAPABILITY 0x7)
+  endif (NOT DEFINED CLR_ARM_FPU_CAPABILITY)
+
+  add_definitions (-DCLR_ARM_FPU_CAPABILITY=${CLR_ARM_FPU_CAPABILITY})
+
   if(TARGET_ARCH_NAME STREQUAL "armel")
     add_compile_options(-mfloat-abi=softfp)
-    if(DEFINED TIZEN_TOOLCHAIN)
-      add_compile_options(-Wno-deprecated-declarations) # compile-time option
-      add_compile_options(-D__extern_always_inline=inline) # compile-time option
-    endif()
   endif()
 elseif(TARGET_ARCH_NAME STREQUAL "x86")
   add_compile_options(-m32)
   add_compile_options(-Wno-error=unused-command-line-argument)
 endif()
 
-# Set LLDB include and library paths
+if(DEFINED TIZEN_TOOLCHAIN)
+  if(TARGET_ARCH_NAME MATCHES "^(armel|arm64)$")
+    add_compile_options(-Wno-deprecated-declarations) # compile-time option
+    add_compile_options(-D__extern_always_inline=inline) # compile-time option
+  endif()
+endif()
+
+# Set LLDB include and library paths for builds that need lldb.
 if(TARGET_ARCH_NAME MATCHES "^(arm|armel|x86)$")
   if(TARGET_ARCH_NAME STREQUAL "x86")
     set(LLVM_CROSS_DIR "$ENV{LLVM_CROSS_HOME}")
@@ -131,7 +229,6 @@ if(TARGET_ARCH_NAME MATCHES "^(arm|armel|x86)$")
   endif()
 endif()
 
-set(CMAKE_FIND_ROOT_PATH "${CROSS_ROOTFS}")
 set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
 set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
 set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
diff --git a/eng/common/darc-init.sh b/eng/common/darc-init.sh
index 06b65342528..d981d7bbf38 100755
--- a/eng/common/darc-init.sh
+++ b/eng/common/darc-init.sh
@@ -68,7 +68,7 @@ function InstallDarcCli {
     fi
   fi
 
-  local arcadeServicesSource="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json"
+  local arcadeServicesSource="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json"
 
   echo "Installing Darc CLI version $darcVersion..."
   echo "You may need to restart your command shell if this is the first dotnet tool you have installed."
diff --git a/eng/common/dotnet-install.ps1 b/eng/common/dotnet-install.ps1
index ec3e739fe83..811f0f717f7 100644
--- a/eng/common/dotnet-install.ps1
+++ b/eng/common/dotnet-install.ps1
@@ -1,28 +1,27 @@
 [CmdletBinding(PositionalBinding=$false)]
 Param(
-  [string] $verbosity = "minimal",
-  [string] $architecture = "",
-  [string] $version = "Latest",
-  [string] $runtime = "dotnet",
-  [string] $RuntimeSourceFeed = "",
-  [string] $RuntimeSourceFeedKey = ""
+  [string] $verbosity = 'minimal',
+  [string] $architecture = '',
+  [string] $version = 'Latest',
+  [string] $runtime = 'dotnet',
+  [string] $RuntimeSourceFeed = '',
+  [string] $RuntimeSourceFeedKey = ''
 )
 
 . $PSScriptRoot\tools.ps1
 
-$dotnetRoot = Join-Path $RepoRoot ".dotnet"
+$dotnetRoot = Join-Path $RepoRoot '.dotnet'
 
 $installdir = $dotnetRoot
 try {
-    if ($architecture -and $architecture.Trim() -eq "x86") {
-        $installdir = Join-Path $installdir "x86"
+    if ($architecture -and $architecture.Trim() -eq 'x86') {
+        $installdir = Join-Path $installdir 'x86'
     }
-   InstallDotNet $installdir $version $architecture $runtime $true -RuntimeSourceFeed $RuntimeSourceFeed -RuntimeSourceFeedKey $RuntimeSourceFeedKey
-} 
+    InstallDotNet $installdir $version $architecture $runtime $true -RuntimeSourceFeed $RuntimeSourceFeed -RuntimeSourceFeedKey $RuntimeSourceFeedKey
+}
 catch {
-  Write-Host $_
-  Write-Host $_.Exception
   Write-Host $_.ScriptStackTrace
+  Write-PipelineTelemetryError -Category 'InitializeToolset' -Message $_
   ExitWithExitCode 1
 }
 
diff --git a/eng/common/dotnet-install.sh b/eng/common/dotnet-install.sh
index d259a274c78..ead6a1d9a24 100755
--- a/eng/common/dotnet-install.sh
+++ b/eng/common/dotnet-install.sh
@@ -11,6 +11,8 @@ while [[ -h "$source" ]]; do
 done
 scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
 
+. "$scriptroot/tools.sh"
+
 version='Latest'
 architecture=''
 runtime='dotnet'
@@ -40,18 +42,47 @@ while [[ $# > 0 ]]; do
       runtimeSourceFeedKey="$1"
       ;;
     *)
-      echo "Invalid argument: $1"
+      Write-PipelineTelemetryError -Category 'Build' -Message "Invalid argument: $1"
       exit 1
       ;;
   esac
   shift
 done
 
-. "$scriptroot/tools.sh"
+# Use uname to determine what the CPU is.
+cpuname=$(uname -p)
+# Some Linux platforms report unknown for platform, but the arch for machine.
+if [[ "$cpuname" == "unknown" ]]; then
+  cpuname=$(uname -m)
+fi
+
+case $cpuname in
+  aarch64)
+    buildarch=arm64
+    ;;
+  amd64|x86_64)
+    buildarch=x64
+    ;;
+  armv*l)
+    buildarch=arm
+    ;;
+  i686)
+    buildarch=x86
+    ;;
+  *)
+    echo "Unknown CPU $cpuname detected, treating it as x64"
+    buildarch=x64
+    ;;
+esac
+
 dotnetRoot="$repo_root/.dotnet"
+if [[ $architecture != "" ]] && [[ $architecture != $buildarch ]]; then
+  dotnetRoot="$dotnetRoot/$architecture"
+fi
+
 InstallDotNet $dotnetRoot $version "$architecture" $runtime true $runtimeSourceFeed $runtimeSourceFeedKey || {
   local exit_code=$?
-  echo "dotnet-install.sh failed (exit code '$exit_code')." >&2
+  Write-PipelineTelemetryError -Category 'InitializeToolset' -Message "dotnet-install.sh failed (exit code '$exit_code')." >&2
   ExitWithExitCode $exit_code
 }
 
diff --git a/eng/common/enable-cross-org-publishing.ps1 b/eng/common/enable-cross-org-publishing.ps1
index eccbf9f1b16..da09da4f1fc 100644
--- a/eng/common/enable-cross-org-publishing.ps1
+++ b/eng/common/enable-cross-org-publishing.ps1
@@ -2,5 +2,12 @@ param(
   [string] $token
 )
 
-Write-Host "##vso[task.setvariable variable=VSS_NUGET_ACCESSTOKEN]$token"
-Write-Host "##vso[task.setvariable variable=VSS_NUGET_URI_PREFIXES]https://dnceng.pkgs.visualstudio.com/;https://pkgs.dev.azure.com/dnceng/;https://devdiv.pkgs.visualstudio.com/;https://pkgs.dev.azure.com/devdiv/"
+
+. $PSScriptRoot\pipeline-logging-functions.ps1
+
+# Write-PipelineSetVariable will no-op if a variable named $ci is not defined
+# Since this script is only ever called in AzDO builds, just universally set it
+$ci = $true
+
+Write-PipelineSetVariable -Name 'VSS_NUGET_ACCESSTOKEN' -Value $token -IsMultiJobVariable $false
+Write-PipelineSetVariable -Name 'VSS_NUGET_URI_PREFIXES' -Value 'https://dnceng.pkgs.visualstudio.com/;https://pkgs.dev.azure.com/dnceng/;https://devdiv.pkgs.visualstudio.com/;https://pkgs.dev.azure.com/devdiv/' -IsMultiJobVariable $false
diff --git a/eng/common/generate-graph-files.ps1 b/eng/common/generate-graph-files.ps1
index b056e4c1ac2..0728b1a8b57 100644
--- a/eng/common/generate-graph-files.ps1
+++ b/eng/common/generate-graph-files.ps1
@@ -3,39 +3,39 @@ Param(
   [Parameter(Mandatory=$true)][string] $gitHubPat,      # GitHub personal access token from https://github.com/settings/tokens (no auth scopes needed)
   [Parameter(Mandatory=$true)][string] $azdoPat,        # Azure Dev Ops tokens from https://dev.azure.com/dnceng/_details/security/tokens (code read scope needed)
   [Parameter(Mandatory=$true)][string] $outputFolder,   # Where the graphviz.txt file will be created
-  [string] $darcVersion = '1.1.0-beta.19175.6',         # darc's version
+  [string] $darcVersion,                                # darc's version
   [string] $graphvizVersion = '2.38',                   # GraphViz version
   [switch] $includeToolset                              # Whether the graph should include toolset dependencies or not. i.e. arcade, optimization. For more about
                                                         # toolset dependencies see https://github.com/dotnet/arcade/blob/master/Documentation/Darc.md#toolset-vs-product-dependencies
 )
 
-$ErrorActionPreference = "Stop"
-. $PSScriptRoot\tools.ps1
-
-Import-Module -Name (Join-Path $PSScriptRoot "native\CommonLibrary.psm1")
-
 function CheckExitCode ([string]$stage)
 {
   $exitCode = $LASTEXITCODE
   if ($exitCode  -ne 0) {
-    Write-Host "Something failed in stage: '$stage'. Check for errors above. Exiting now..."
+    Write-PipelineTelemetryError -Category 'Arcade' -Message "Something failed in stage: '$stage'. Check for errors above. Exiting now..."
     ExitWithExitCode $exitCode
   }
 }
 
 try {
+  $ErrorActionPreference = 'Stop'
+  . $PSScriptRoot\tools.ps1
+  
+  Import-Module -Name (Join-Path $PSScriptRoot 'native\CommonLibrary.psm1')
+
   Push-Location $PSScriptRoot
 
-  Write-Host "Installing darc..."
+  Write-Host 'Installing darc...'
   . .\darc-init.ps1 -darcVersion $darcVersion
-  CheckExitCode "Running darc-init"
+  CheckExitCode 'Running darc-init'
 
-  $engCommonBaseDir = Join-Path $PSScriptRoot "native\"
+  $engCommonBaseDir = Join-Path $PSScriptRoot 'native\'
   $graphvizInstallDir = CommonLibrary\Get-NativeInstallDirectory
-  $nativeToolBaseUri = "https://netcorenativeassets.blob.core.windows.net/resource-packages/external"
-  $installBin = Join-Path $graphvizInstallDir "bin"
+  $nativeToolBaseUri = 'https://netcorenativeassets.blob.core.windows.net/resource-packages/external'
+  $installBin = Join-Path $graphvizInstallDir 'bin'
 
-  Write-Host "Installing dot..."
+  Write-Host 'Installing dot...'
   .\native\install-tool.ps1 -ToolName graphviz -InstallPath $installBin -BaseUri $nativeToolBaseUri -CommonLibraryDirectory $engCommonBaseDir -Version $graphvizVersion -Verbose
 
   $darcExe = "$env:USERPROFILE\.dotnet\tools"
@@ -51,37 +51,36 @@ try {
   $graphVizImageFilePath = "$outputFolder\graph.png"
   $normalGraphFilePath = "$outputFolder\graph-full.txt"
   $flatGraphFilePath = "$outputFolder\graph-flat.txt"
-  $baseOptions = @( "--github-pat", "$gitHubPat", "--azdev-pat", "$azdoPat", "--password", "$barToken" )
+  $baseOptions = @( '--github-pat', "$gitHubPat", '--azdev-pat', "$azdoPat", '--password', "$barToken" )
 
   if ($includeToolset) {
-    Write-Host "Toolsets will be included in the graph..."
-    $baseOptions += @( "--include-toolset" )
+    Write-Host 'Toolsets will be included in the graph...'
+    $baseOptions += @( '--include-toolset' )
   }
 
-  Write-Host "Generating standard dependency graph..."
+  Write-Host 'Generating standard dependency graph...'
   & "$darcExe" get-dependency-graph @baseOptions --output-file $normalGraphFilePath
-  CheckExitCode "Generating normal dependency graph"
+  CheckExitCode 'Generating normal dependency graph'
 
-  Write-Host "Generating flat dependency graph and graphviz file..."
+  Write-Host 'Generating flat dependency graph and graphviz file...'
   & "$darcExe" get-dependency-graph @baseOptions --flat --coherency --graphviz $graphVizFilePath --output-file $flatGraphFilePath
-  CheckExitCode "Generating flat and graphviz dependency graph"
+  CheckExitCode 'Generating flat and graphviz dependency graph'
 
   Write-Host "Generating graph image $graphVizFilePath"
   $dotFilePath = Join-Path $installBin "graphviz\$graphvizVersion\release\bin\dot.exe"
   & "$dotFilePath" -Tpng -o"$graphVizImageFilePath" "$graphVizFilePath"
-  CheckExitCode "Generating graphviz image"
+  CheckExitCode 'Generating graphviz image'
 
   Write-Host "'$graphVizFilePath', '$flatGraphFilePath', '$normalGraphFilePath' and '$graphVizImageFilePath' created!"
 }
 catch {
   if (!$includeToolset) {
-    Write-Host "This might be a toolset repo which includes only toolset dependencies. " -NoNewline -ForegroundColor Yellow
-    Write-Host "Since -includeToolset is not set there is no graph to create. Include -includeToolset and try again..." -ForegroundColor Yellow
+    Write-Host 'This might be a toolset repo which includes only toolset dependencies. ' -NoNewline -ForegroundColor Yellow
+    Write-Host 'Since -includeToolset is not set there is no graph to create. Include -includeToolset and try again...' -ForegroundColor Yellow
   }
-  Write-Host $_
-  Write-Host $_.Exception
   Write-Host $_.ScriptStackTrace
+  Write-PipelineTelemetryError -Category 'Arcade' -Message $_
   ExitWithExitCode 1
 } finally {
-    Pop-Location
+  Pop-Location
 }
\ No newline at end of file
diff --git a/eng/common/init-tools-native.ps1 b/eng/common/init-tools-native.ps1
index 8cf18bcfeba..db830c00a6f 100644
--- a/eng/common/init-tools-native.ps1
+++ b/eng/common/init-tools-native.ps1
@@ -35,7 +35,7 @@ File path to global.json file
 #>
 [CmdletBinding(PositionalBinding=$false)]
 Param (
-  [string] $BaseUri = "https://netcorenativeassets.blob.core.windows.net/resource-packages/external",
+  [string] $BaseUri = 'https://netcorenativeassets.blob.core.windows.net/resource-packages/external',
   [string] $InstallDirectory,
   [switch] $Clean = $False,
   [switch] $Force = $False,
@@ -45,26 +45,27 @@ Param (
 )
 
 if (!$GlobalJsonFile) {
-  $GlobalJsonFile = Join-Path (Get-Item $PSScriptRoot).Parent.Parent.FullName "global.json"
+  $GlobalJsonFile = Join-Path (Get-Item $PSScriptRoot).Parent.Parent.FullName 'global.json'
 }
 
 Set-StrictMode -version 2.0
-$ErrorActionPreference="Stop"
+$ErrorActionPreference='Stop'
 
-Import-Module -Name (Join-Path $PSScriptRoot "native\CommonLibrary.psm1")
+. $PSScriptRoot\pipeline-logging-functions.ps1
+Import-Module -Name (Join-Path $PSScriptRoot 'native\CommonLibrary.psm1')
 
 try {
   # Define verbose switch if undefined
-  $Verbose = $VerbosePreference -Eq "Continue"
+  $Verbose = $VerbosePreference -Eq 'Continue'
 
-  $EngCommonBaseDir = Join-Path $PSScriptRoot "native\"
+  $EngCommonBaseDir = Join-Path $PSScriptRoot 'native\'
   $NativeBaseDir = $InstallDirectory
   if (!$NativeBaseDir) {
     $NativeBaseDir = CommonLibrary\Get-NativeInstallDirectory
   }
   $Env:CommonLibrary_NativeInstallDir = $NativeBaseDir
-  $InstallBin = Join-Path $NativeBaseDir "bin"
-  $InstallerPath = Join-Path $EngCommonBaseDir "install-tool.ps1"
+  $InstallBin = Join-Path $NativeBaseDir 'bin'
+  $InstallerPath = Join-Path $EngCommonBaseDir 'install-tool.ps1'
 
   # Process tools list
   Write-Host "Processing $GlobalJsonFile"
@@ -74,7 +75,7 @@ try {
   }
   $NativeTools = Get-Content($GlobalJsonFile) -Raw |
                     ConvertFrom-Json |
-                    Select-Object -Expand "native-tools" -ErrorAction SilentlyContinue
+                    Select-Object -Expand 'native-tools' -ErrorAction SilentlyContinue
   if ($NativeTools) {
     $NativeTools.PSObject.Properties | ForEach-Object {
       $ToolName = $_.Name
@@ -112,18 +113,21 @@ try {
             }
             $toolInstallationFailure = $true
         } else {
-            Write-Error $errMsg
+            # We cannot change this to Write-PipelineTelemetryError because of https://github.com/dotnet/arcade/issues/4482
+            Write-Host $errMsg
             exit 1
         }
       }
     }
 
     if ((Get-Variable 'toolInstallationFailure' -ErrorAction 'SilentlyContinue') -and $toolInstallationFailure) {
+        # We cannot change this to Write-PipelineTelemetryError because of https://github.com/dotnet/arcade/issues/4482
+        Write-Host 'Native tools bootstrap failed'
         exit 1
     }
   }
   else {
-    Write-Host "No native tools defined in global.json"
+    Write-Host 'No native tools defined in global.json'
     exit 0
   }
 
@@ -131,17 +135,18 @@ try {
     exit 0
   }
   if (Test-Path $InstallBin) {
-    Write-Host "Native tools are available from" (Convert-Path -Path $InstallBin)
+    Write-Host 'Native tools are available from ' (Convert-Path -Path $InstallBin)
     Write-Host "##vso[task.prependpath]$(Convert-Path -Path $InstallBin)"
+    return $InstallBin
   }
   else {
-    Write-Error "Native tools install directory does not exist, installation failed"
+    Write-PipelineTelemetryError -Category 'NativeToolsBootstrap' -Message 'Native tools install directory does not exist, installation failed'
     exit 1
   }
   exit 0
 }
 catch {
-  Write-Host $_
-  Write-Host $_.Exception
-  exit 1
+  Write-Host $_.ScriptStackTrace
+  Write-PipelineTelemetryError -Category 'NativeToolsBootstrap' -Message $_
+  ExitWithExitCode 1
 }
diff --git a/eng/common/init-tools-native.sh b/eng/common/init-tools-native.sh
index 4dafaaca130..29fc5db8ae0 100755
--- a/eng/common/init-tools-native.sh
+++ b/eng/common/init-tools-native.sh
@@ -12,6 +12,7 @@ retry_wait_time_seconds=30
 global_json_file="$(dirname "$(dirname "${scriptroot}")")/global.json"
 declare -A native_assets
 
+. $scriptroot/pipeline-logging-functions.sh
 . $scriptroot/native/common-library.sh
 
 while (($# > 0)); do
@@ -33,6 +34,14 @@ while (($# > 0)); do
       force=true
       shift 1
       ;;
+    --donotabortonfailure)
+      donotabortonfailure=true
+      shift 1
+      ;;
+    --donotdisplaywarnings)
+      donotdisplaywarnings=true
+      shift 1
+      ;;
     --downloadretries)
       download_retries=$2
       shift 2
@@ -51,6 +60,8 @@ while (($# > 0)); do
       echo "                                          - (default) %USERPROFILE%/.netcoreeng/native"
       echo ""
       echo "  --clean                             Switch specifying not to install anything, but cleanup native asset folders"
+      echo "  --donotabortonfailure               Switch specifiying whether to abort native tools installation on failure"
+      echo "  --donotdisplaywarnings              Switch specifiying whether to display warnings during native tools installation on failure"
       echo "  --force                             Clean and then install tools"
       echo "  --help                              Print help and exit"
       echo ""
@@ -91,6 +102,7 @@ if [[ -z $install_directory ]]; then
 fi
 
 install_bin="${native_base_dir}/bin"
+installed_any=false
 
 ReadGlobalJsonNativeTools
 
@@ -102,8 +114,8 @@ else
   for tool in "${!native_assets[@]}"
   do
     tool_version=${native_assets[$tool]}
-    installer_name="install-$tool.sh"
-    installer_command="$native_installer_dir/$installer_name"
+    installer_path="$native_installer_dir/install-$tool.sh"
+    installer_command="$installer_path"
     installer_command+=" --baseuri $base_uri"
     installer_command+=" --installpath $install_bin"
     installer_command+=" --version $tool_version"
@@ -117,11 +129,29 @@ else
       installer_command+=" --clean"
     fi
 
-    $installer_command
-
-    if [[ $? != 0 ]]; then
-      echo "Execution Failed" >&2
-      exit 1
+    if [[ -a $installer_path ]]; then
+      $installer_command
+      if [[ $? != 0 ]]; then
+        if [[ $donotabortonfailure = true ]]; then
+          if [[ $donotdisplaywarnings != true ]]; then
+            Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Execution Failed"
+          fi
+        else
+          Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Execution Failed"
+          exit 1
+        fi
+      else
+        $installed_any = true
+      fi
+    else
+      if [[ $donotabortonfailure == true ]]; then
+        if [[ $donotdisplaywarnings != true ]]; then
+          Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Execution Failed: no install script"
+        fi
+      else
+        Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Execution Failed: no install script"
+        exit 1
+      fi
     fi
   done
 fi
@@ -134,8 +164,10 @@ if [[ -d $install_bin ]]; then
   echo "Native tools are available from $install_bin"
   echo "##vso[task.prependpath]$install_bin"
 else
-  echo "Native tools install directory does not exist, installation failed" >&2
-  exit 1
+  if [[ $installed_any = true ]]; then
+    Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Native tools install directory does not exist, installation failed"
+    exit 1
+  fi
 fi
 
 exit 0
diff --git a/eng/common/internal-feed-operations.ps1 b/eng/common/internal-feed-operations.ps1
index 8b8bafd6a89..418c09930cf 100644
--- a/eng/common/internal-feed-operations.ps1
+++ b/eng/common/internal-feed-operations.ps1
@@ -6,9 +6,8 @@ param(
   [switch] $IsFeedPrivate
 )
 
-$ErrorActionPreference = "Stop"
+$ErrorActionPreference = 'Stop'
 Set-StrictMode -Version 2.0
-
 . $PSScriptRoot\tools.ps1
 
 # Sets VSS_NUGET_EXTERNAL_FEED_ENDPOINTS based on the "darc-int-*" feeds defined in NuGet.config. This is needed
@@ -21,7 +20,7 @@ function SetupCredProvider {
   )    
 
   # Install the Cred Provider NuGet plugin
-  Write-Host "Setting up Cred Provider NuGet plugin in the agent..."
+  Write-Host 'Setting up Cred Provider NuGet plugin in the agent...'
   Write-Host "Getting 'installcredprovider.ps1' from 'https://github.com/microsoft/artifacts-credprovider'..."
 
   $url = 'https://raw.githubusercontent.com/microsoft/artifacts-credprovider/master/helpers/installcredprovider.ps1'
@@ -29,18 +28,18 @@ function SetupCredProvider {
   Write-Host "Writing the contents of 'installcredprovider.ps1' locally..."
   Invoke-WebRequest $url -OutFile installcredprovider.ps1
   
-  Write-Host "Installing plugin..."
+  Write-Host 'Installing plugin...'
   .\installcredprovider.ps1 -Force
   
   Write-Host "Deleting local copy of 'installcredprovider.ps1'..."
   Remove-Item .\installcredprovider.ps1
 
   if (-Not("$env:USERPROFILE\.nuget\plugins\netcore")) {
-    Write-Host "CredProvider plugin was not installed correctly!"
+    Write-PipelineTelemetryError -Category 'Arcade' -Message 'CredProvider plugin was not installed correctly!'
     ExitWithExitCode 1  
   } 
   else {
-    Write-Host "CredProvider plugin was installed correctly!"
+    Write-Host 'CredProvider plugin was installed correctly!'
   }
 
   # Then, we set the 'VSS_NUGET_EXTERNAL_FEED_ENDPOINTS' environment variable to restore from the stable 
@@ -49,7 +48,7 @@ function SetupCredProvider {
   $nugetConfigPath = "$RepoRoot\NuGet.config"
 
   if (-Not (Test-Path -Path $nugetConfigPath)) {
-    Write-Host "NuGet.config file not found in repo's root!"
+    Write-PipelineTelemetryError -Category 'Build' -Message 'NuGet.config file not found in repo root!'
     ExitWithExitCode 1  
   }
   
@@ -64,7 +63,6 @@ function SetupCredProvider {
   }
 
   if (($endpoints | Measure-Object).Count -gt 0) {
-      # Create the JSON object. It should look like '{"endpointCredentials": [{"endpoint":"http://example.index.json", "username":"optional", "password":"accesstoken"}]}'
       $endpointCredentials = @{endpointCredentials=$endpoints} | ConvertTo-Json -Compress
 
      # Create the environment variables the AzDo way
@@ -81,7 +79,7 @@ function SetupCredProvider {
   }
   else
   {
-    Write-Host "No internal endpoints found in NuGet.config"
+    Write-Host 'No internal endpoints found in NuGet.config'
   }
 }
 
@@ -99,7 +97,7 @@ function InstallDotNetSdkAndRestoreArcade {
 
   & $dotnet restore $restoreProjPath
 
-  Write-Host "Arcade SDK restored!"
+  Write-Host 'Arcade SDK restored!'
 
   if (Test-Path -Path $restoreProjPath) {
     Remove-Item $restoreProjPath
@@ -113,23 +111,22 @@ function InstallDotNetSdkAndRestoreArcade {
 try {
   Push-Location $PSScriptRoot
 
-  if ($Operation -like "setup") {
+  if ($Operation -like 'setup') {
     SetupCredProvider $AuthToken
   } 
-  elseif ($Operation -like "install-restore") {
+  elseif ($Operation -like 'install-restore') {
     InstallDotNetSdkAndRestoreArcade
   }
   else {
-    Write-Host "Unknown operation '$Operation'!"
+    Write-PipelineTelemetryError -Category 'Arcade' -Message "Unknown operation '$Operation'!"
     ExitWithExitCode 1  
   }
 } 
 catch {
-  Write-Host $_
-  Write-Host $_.Exception
   Write-Host $_.ScriptStackTrace
+  Write-PipelineTelemetryError -Category 'Arcade' -Message $_
   ExitWithExitCode 1
 } 
 finally {
-    Pop-Location
+  Pop-Location
 }
diff --git a/eng/common/internal-feed-operations.sh b/eng/common/internal-feed-operations.sh
index 1ff654d2ffc..343054b3ae9 100755
--- a/eng/common/internal-feed-operations.sh
+++ b/eng/common/internal-feed-operations.sh
@@ -30,7 +30,7 @@ function SetupCredProvider {
   rm installcredprovider.sh
 
   if [ ! -d "$HOME/.nuget/plugins" ]; then
-    echo "CredProvider plugin was not installed correctly!"
+    Write-PipelineTelemetryError -category 'Build' 'CredProvider plugin was not installed correctly!'
     ExitWithExitCode 1  
   else 
     echo "CredProvider plugin was installed correctly!"
@@ -42,7 +42,7 @@ function SetupCredProvider {
   local nugetConfigPath="$repo_root/NuGet.config"
 
   if [ ! "$nugetConfigPath" ]; then
-    echo "NuGet.config file not found in repo's root!"
+    Write-PipelineTelemetryError -category 'Build' "NuGet.config file not found in repo's root!"
     ExitWithExitCode 1  
   fi
   
@@ -62,7 +62,6 @@ function SetupCredProvider {
   endpoints+=']'
 
   if [ ${#endpoints} -gt 2 ]; then 
-      # Create the JSON object. It should look like '{"endpointCredentials": [{"endpoint":"http://example.index.json", "username":"optional", "password":"accesstoken"}]}'
       local endpointCredentials="{\"endpointCredentials\": "$endpoints"}"
 
       echo "##vso[task.setvariable variable=VSS_NUGET_EXTERNAL_FEED_ENDPOINTS]$endpointCredentials"
diff --git a/eng/common/internal/Directory.Build.props b/eng/common/internal/Directory.Build.props
index e33179ef373..dbf99d82a5c 100644
--- a/eng/common/internal/Directory.Build.props
+++ b/eng/common/internal/Directory.Build.props
@@ -1,4 +1,4 @@
-<!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the LICENSE file in the project root for more information. -->
+<!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
 <Project>
   <Import Project="Sdk.props" Sdk="Microsoft.DotNet.Arcade.Sdk" />
 </Project>
diff --git a/eng/common/internal/Tools.csproj b/eng/common/internal/Tools.csproj
index 1a39a7ef3f6..f46d5efe2e3 100644
--- a/eng/common/internal/Tools.csproj
+++ b/eng/common/internal/Tools.csproj
@@ -4,6 +4,7 @@
   <PropertyGroup>
     <TargetFramework>net472</TargetFramework>
     <ImportDirectoryBuildTargets>false</ImportDirectoryBuildTargets>
+    <AutomaticallyUseReferenceAssemblyPackages>false</AutomaticallyUseReferenceAssemblyPackages>
   </PropertyGroup>
   <ItemGroup>
     <!-- Clear references, the SDK may add some depending on UsuingToolXxx settings, but we only want to restore the following -->
diff --git a/eng/common/msbuild.ps1 b/eng/common/msbuild.ps1
index b37fd3d5e97..c6401230002 100644
--- a/eng/common/msbuild.ps1
+++ b/eng/common/msbuild.ps1
@@ -1,6 +1,6 @@
 [CmdletBinding(PositionalBinding=$false)]
 Param(
-  [string] $verbosity = "minimal",
+  [string] $verbosity = 'minimal',
   [bool] $warnAsError = $true,
   [bool] $nodeReuse = $true,
   [switch] $ci,
@@ -18,9 +18,8 @@ try {
   MSBuild @extraArgs
 } 
 catch {
-  Write-Host $_
-  Write-Host $_.Exception
   Write-Host $_.ScriptStackTrace
+  Write-PipelineTelemetryError -Category 'Build' -Message $_
   ExitWithExitCode 1
 }
 
diff --git a/eng/common/native/CommonLibrary.psm1 b/eng/common/native/CommonLibrary.psm1
index 41416862d91..d7d1a651094 100644
--- a/eng/common/native/CommonLibrary.psm1
+++ b/eng/common/native/CommonLibrary.psm1
@@ -145,9 +145,12 @@ function Get-File {
     New-Item -path $DownloadDirectory -force -itemType "Directory" | Out-Null
   }
 
+  $TempPath = "$Path.tmp"
   if (Test-Path -IsValid -Path $Uri) {
-    Write-Verbose "'$Uri' is a file path, copying file to '$Path'"
-    Copy-Item -Path $Uri -Destination $Path
+    Write-Verbose "'$Uri' is a file path, copying temporarily to '$TempPath'"
+    Copy-Item -Path $Uri -Destination $TempPath
+    Write-Verbose "Moving temporary file to '$Path'"
+    Move-Item -Path $TempPath -Destination $Path
     return $?
   }
   else {
@@ -157,8 +160,10 @@ function Get-File {
     while($Attempt -Lt $DownloadRetries)
     {
       try {
-        Invoke-WebRequest -UseBasicParsing -Uri $Uri -OutFile $Path
-        Write-Verbose "Downloaded to '$Path'"
+        Invoke-WebRequest -UseBasicParsing -Uri $Uri -OutFile $TempPath
+        Write-Verbose "Downloaded to temporary location '$TempPath'"
+        Move-Item -Path $TempPath -Destination $Path
+        Write-Verbose "Moved temporary file to '$Path'"
         return $True
       }
       catch {
@@ -359,16 +364,21 @@ function Expand-Zip {
         return $False
       }
     }
-    if (-Not (Test-Path $OutputDirectory)) {
-      New-Item -path $OutputDirectory -Force -itemType "Directory" | Out-Null
+
+    $TempOutputDirectory = Join-Path "$(Split-Path -Parent $OutputDirectory)" "$(Split-Path -Leaf $OutputDirectory).tmp"
+    if (Test-Path $TempOutputDirectory) {
+      Remove-Item $TempOutputDirectory -Force -Recurse
     }
+    New-Item -Path $TempOutputDirectory -Force -ItemType "Directory" | Out-Null
 
     Add-Type -assembly "system.io.compression.filesystem"
-    [io.compression.zipfile]::ExtractToDirectory("$ZipPath", "$OutputDirectory")
+    [io.compression.zipfile]::ExtractToDirectory("$ZipPath", "$TempOutputDirectory")
     if ($? -Eq $False) {
       Write-Error "Unable to extract '$ZipPath'"
       return $False
     }
+
+    Move-Item -Path $TempOutputDirectory -Destination $OutputDirectory
   }
   catch {
     Write-Host $_
diff --git a/eng/common/native/common-library.sh b/eng/common/native/common-library.sh
index 271bddfac5a..bf272dcf55a 100755
--- a/eng/common/native/common-library.sh
+++ b/eng/common/native/common-library.sh
@@ -34,7 +34,7 @@ function ExpandZip {
     echo "'Force flag enabled, but '$output_directory' exists. Removing directory"
     rm -rf $output_directory
     if [[ $? != 0 ]]; then
-      echo Unable to remove '$output_directory'>&2
+      Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Unable to remove '$output_directory'"
       return 1
     fi
   fi
@@ -45,7 +45,7 @@ function ExpandZip {
   echo "Extracting archive"
   tar -xf $zip_path -C $output_directory
   if [[ $? != 0 ]]; then
-    echo "Unable to extract '$zip_path'" >&2
+    Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Unable to extract '$zip_path'"
     return 1
   fi
 
@@ -117,7 +117,7 @@ function DownloadAndExtract {
   # Download file
   GetFile "$uri" "$temp_tool_path" $force $download_retries $retry_wait_time_seconds
   if [[ $? != 0 ]]; then
-    echo "Failed to download '$uri' to '$temp_tool_path'." >&2
+    Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Failed to download '$uri' to '$temp_tool_path'."
     return 1
   fi
 
@@ -125,7 +125,7 @@ function DownloadAndExtract {
   echo "extracting from  $temp_tool_path to $installDir"
   ExpandZip "$temp_tool_path" "$installDir" $force $download_retries $retry_wait_time_seconds
   if [[ $? != 0 ]]; then
-    echo "Failed to extract '$temp_tool_path' to '$installDir'." >&2
+    Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Failed to extract '$temp_tool_path' to '$installDir'."
     return 1
   fi
 
@@ -148,7 +148,7 @@ function NewScriptShim {
   fi
   
   if [[ ! -f $tool_file_path ]]; then
-    echo "Specified tool file path:'$tool_file_path' does not exist" >&2
+    Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Specified tool file path:'$tool_file_path' does not exist"
     return 1
   fi
 
diff --git a/eng/common/native/find-native-compiler.sh b/eng/common/native/find-native-compiler.sh
new file mode 100644
index 00000000000..aed19d07d50
--- /dev/null
+++ b/eng/common/native/find-native-compiler.sh
@@ -0,0 +1,121 @@
+#!/usr/bin/env bash
+#
+# This file locates the native compiler with the given name and version and sets the environment variables to locate it.
+#
+
+source="${BASH_SOURCE[0]}"
+
+# resolve $SOURCE until the file is no longer a symlink
+while [[ -h $source ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+
+  # if $source was a relative symlink, we need to resolve it relative to the path where the
+  # symlink file was located
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+
+if [ $# -lt 0 ]
+then
+  echo "Usage..."
+  echo "find-native-compiler.sh <compiler> <compiler major version> <compiler minor version>"
+  echo "Specify the name of compiler (clang or gcc)."
+  echo "Specify the major version of compiler."
+  echo "Specify the minor version of compiler."
+  exit 1
+fi
+
+. $scriptroot/../pipeline-logging-functions.sh
+
+compiler="$1"
+cxxCompiler="$compiler++"
+majorVersion="$2"
+minorVersion="$3"
+
+if [ "$compiler" = "gcc" ]; then cxxCompiler="g++"; fi
+
+check_version_exists() {
+    desired_version=-1
+
+    # Set up the environment to be used for building with the desired compiler.
+    if command -v "$compiler-$1.$2" > /dev/null; then
+        desired_version="-$1.$2"
+    elif command -v "$compiler$1$2" > /dev/null; then
+        desired_version="$1$2"
+    elif command -v "$compiler-$1$2" > /dev/null; then
+        desired_version="-$1$2"
+    fi
+
+    echo "$desired_version"
+}
+
+if [ -z "$CLR_CC" ]; then
+
+    # Set default versions
+    if [ -z "$majorVersion" ]; then
+        # note: gcc (all versions) and clang versions higher than 6 do not have minor version in file name, if it is zero.
+        if [ "$compiler" = "clang" ]; then versions=( 9 8 7 6.0 5.0 4.0 3.9 3.8 3.7 3.6 3.5 )
+        elif [ "$compiler" = "gcc" ]; then versions=( 9 8 7 6 5 4.9 ); fi
+
+        for version in "${versions[@]}"; do
+            parts=(${version//./ })
+            desired_version="$(check_version_exists "${parts[0]}" "${parts[1]}")"
+            if [ "$desired_version" != "-1" ]; then majorVersion="${parts[0]}"; break; fi
+        done
+
+        if [ -z "$majorVersion" ]; then
+            if command -v "$compiler" > /dev/null; then
+                if [ "$(uname)" != "Darwin" ]; then
+                    Write-PipelineTelemetryError -category "Build" -type "warning" "Specific version of $compiler not found, falling back to use the one in PATH."
+                fi
+                export CC="$(command -v "$compiler")"
+                export CXX="$(command -v "$cxxCompiler")"
+            else
+                Write-PipelineTelemetryError -category "Build" "No usable version of $compiler found."
+                exit 1
+            fi
+        else
+            if [ "$compiler" = "clang" ] && [ "$majorVersion" -lt 5 ]; then
+                if [ "$build_arch" = "arm" ] || [ "$build_arch" = "armel" ]; then
+                    if command -v "$compiler" > /dev/null; then
+                        Write-PipelineTelemetryError -category "Build" -type "warning" "Found clang version $majorVersion which is not supported on arm/armel architectures, falling back to use clang from PATH."
+                        export CC="$(command -v "$compiler")"
+                        export CXX="$(command -v "$cxxCompiler")"
+                    else
+                        Write-PipelineTelemetryError -category "Build" "Found clang version $majorVersion which is not supported on arm/armel architectures, and there is no clang in PATH."
+                        exit 1
+                    fi
+                fi
+            fi
+        fi
+    else
+        desired_version="$(check_version_exists "$majorVersion" "$minorVersion")"
+        if [ "$desired_version" = "-1" ]; then
+            Write-PipelineTelemetryError -category "Build" "Could not find specific version of $compiler: $majorVersion $minorVersion."
+            exit 1
+        fi
+    fi
+
+    if [ -z "$CC" ]; then
+        export CC="$(command -v "$compiler$desired_version")"
+        export CXX="$(command -v "$cxxCompiler$desired_version")"
+        if [ -z "$CXX" ]; then export CXX="$(command -v "$cxxCompiler")"; fi
+    fi
+else
+    if [ ! -f "$CLR_CC" ]; then
+        Write-PipelineTelemetryError -category "Build" "CLR_CC is set but path '$CLR_CC' does not exist"
+        exit 1
+    fi
+    export CC="$CLR_CC"
+    export CXX="$CLR_CXX"
+fi
+
+if [ -z "$CC" ]; then
+   Write-PipelineTelemetryError -category "Build" "Unable to find $compiler."
+    exit 1
+fi
+
+export CCC_CC="$CC"
+export CCC_CXX="$CXX"
+export SCAN_BUILD_COMMAND="$(command -v "scan-build$desired_version")"
diff --git a/eng/common/native/install-cmake-test.sh b/eng/common/native/install-cmake-test.sh
index 53ddf4e6860..12339a40761 100755
--- a/eng/common/native/install-cmake-test.sh
+++ b/eng/common/native/install-cmake-test.sh
@@ -101,7 +101,7 @@ fi
 DownloadAndExtract $uri $tool_install_directory $force $download_retries $retry_wait_time_seconds
 
 if [[ $? != 0 ]]; then
-  echo "Installation failed" >&2
+  Write-PipelineTelemetryError -category 'NativeToolsBootstrap' 'Installation failed'
   exit 1
 fi
 
@@ -110,7 +110,7 @@ fi
 NewScriptShim $shim_path $tool_file_path true
 
 if [[ $? != 0 ]]; then
-  echo "Shim generation failed" >&2
+  Write-PipelineTelemetryError -category 'NativeToolsBootstrap' 'Shim generation failed'
   exit 1
 fi
 
diff --git a/eng/common/native/install-cmake.sh b/eng/common/native/install-cmake.sh
index 5f1a182fa9f..18041be8763 100755
--- a/eng/common/native/install-cmake.sh
+++ b/eng/common/native/install-cmake.sh
@@ -101,7 +101,7 @@ fi
 DownloadAndExtract $uri $tool_install_directory $force $download_retries $retry_wait_time_seconds
 
 if [[ $? != 0 ]]; then
-  echo "Installation failed" >&2
+  Write-PipelineTelemetryError -category 'NativeToolsBootstrap' 'Installation failed'
   exit 1
 fi
 
@@ -110,7 +110,7 @@ fi
 NewScriptShim $shim_path $tool_file_path true
 
 if [[ $? != 0 ]]; then
-  echo "Shim generation failed" >&2
+  Write-PipelineTelemetryError -category 'NativeToolsBootstrap' 'Shim generation failed'
   exit 1
 fi
 
diff --git a/eng/common/native/install-tool.ps1 b/eng/common/native/install-tool.ps1
index 635ab3fd414..f397e1c75d4 100644
--- a/eng/common/native/install-tool.ps1
+++ b/eng/common/native/install-tool.ps1
@@ -46,6 +46,8 @@ Param (
   [int] $RetryWaitTimeInSeconds = 30
 )
 
+. $PSScriptRoot\..\pipeline-logging-functions.ps1
+
 # Import common library modules
 Import-Module -Name (Join-Path $CommonLibraryDirectory "CommonLibrary.psm1")
 
@@ -93,7 +95,7 @@ try {
                                                       -Verbose:$Verbose
 
     if ($InstallStatus -Eq $False) {
-      Write-Error "Installation failed"
+      Write-PipelineTelemetryError "Installation failed" -Category "NativeToolsetBootstrapping"
       exit 1
     }
   }
@@ -103,7 +105,7 @@ try {
     Write-Error "There are multiple copies of $ToolName in $($ToolInstallDirectory): `n$(@($ToolFilePath | out-string))"
     exit 1
   } elseif (@($ToolFilePath).Length -Lt 1) {
-    Write-Error "$ToolName was not found in $ToolFilePath."
+    Write-Host "$ToolName was not found in $ToolFilePath."
     exit 1
   }
 
@@ -117,14 +119,14 @@ try {
                                                      -Verbose:$Verbose
 
   if ($GenerateShimStatus -Eq $False) {
-    Write-Error "Generate shim failed"
+    Write-PipelineTelemetryError "Generate shim failed" -Category "NativeToolsetBootstrapping"
     return 1
   }
 
   exit 0
 }
 catch {
-  Write-Host $_
-  Write-Host $_.Exception
+  Write-Host $_.ScriptStackTrace
+  Write-PipelineTelemetryError -Category "NativeToolsetBootstrapping" -Message $_
   exit 1
 }
diff --git a/eng/common/performance/blazor_perf.proj b/eng/common/performance/blazor_perf.proj
new file mode 100644
index 00000000000..3b25359c438
--- /dev/null
+++ b/eng/common/performance/blazor_perf.proj
@@ -0,0 +1,30 @@
+<Project Sdk="Microsoft.DotNet.Helix.Sdk" DefaultTargets="Test">
+  <PropertyGroup Condition="'$(AGENT_OS)' != 'Windows_NT'">
+    <Python>python3</Python>
+    <HelixPreCommands>$(HelixPreCommands);chmod +x $HELIX_WORKITEM_PAYLOAD/SOD/SizeOnDisk</HelixPreCommands>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <HelixCorrelationPayload Include="$(CorrelationPayloadDirectory)">
+      <PayloadDirectory>%(Identity)</PayloadDirectory>
+    </HelixCorrelationPayload>
+  </ItemGroup>
+
+  <PropertyGroup Condition="'$(AGENT_OS)' == 'Windows_NT'">
+    <ScenarioDirectory>%HELIX_CORRELATION_PAYLOAD%\performance\src\scenarios\</ScenarioDirectory>
+    <BlazorDirectory>$(ScenarioDirectory)blazor\</BlazorDirectory>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(AGENT_OS)' != 'Windows_NT'">
+    <ScenarioDirectory>$HELIX_CORRELATION_PAYLOAD/performance/src/scenarios/</ScenarioDirectory>
+    <BlazorDirectory>$(ScenarioDirectory)blazor/</BlazorDirectory>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <HelixWorkItem Include="SOD - New Blazor Template - Publish">
+        <PayloadDirectory>$(WorkItemDirectory)</PayloadDirectory>
+        <PreCommands>cd $(BlazorDirectory);$(Python) pre.py publish --msbuild %27/p:_TrimmerDumpDependencies=true%27 --msbuild-static AdditionalMonoLinkerOptions=%27&quot;%24(AdditionalMonoLinkerOptions) --dump-dependencies&quot;%27 --binlog %27./traces/blazor_publish.binlog%27</PreCommands>
+        <Command>$(Python) test.py sod --scenario-name &quot;%(Identity)&quot;</Command>
+        <PostCommands>$(Python) post.py</PostCommands>
+    </HelixWorkItem>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/eng/common/performance/crossgen_perf.proj b/eng/common/performance/crossgen_perf.proj
new file mode 100644
index 00000000000..4264920382e
--- /dev/null
+++ b/eng/common/performance/crossgen_perf.proj
@@ -0,0 +1,69 @@
+<Project Sdk="Microsoft.DotNet.Helix.Sdk" DefaultTargets="Test">
+
+  <ItemGroup>
+    <HelixCorrelationPayload Include="$(CorrelationPayloadDirectory)">
+      <PayloadDirectory>%(Identity)</PayloadDirectory>
+    </HelixCorrelationPayload>
+  </ItemGroup>
+
+  <!-- 
+    Crossgen and Crossgen2 Scenario WorkItems 
+  -->
+  <PropertyGroup Condition="'$(AGENT_OS)' == 'Windows_NT'">
+    <Python>py -3</Python>
+    <HelixPreCommands>$(HelixPreCommands)</HelixPreCommands>
+    <CoreRoot>%HELIX_CORRELATION_PAYLOAD%\Core_Root</CoreRoot>
+    <ScenarioDirectory>%HELIX_CORRELATION_PAYLOAD%\performance\src\scenarios\</ScenarioDirectory>
+    <CrossgenDirectory>$(ScenarioDirectory)crossgen\</CrossgenDirectory>
+    <Crossgen2Directory>$(ScenarioDirectory)crossgen2\</Crossgen2Directory>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(AGENT_OS)' != 'Windows_NT'">
+    <Python>python3</Python>
+    <HelixPreCommands>$(HelixPreCommands);chmod +x $HELIX_WORKITEM_PAYLOAD/startup/Startup;chmod +x $HELIX_WORKITEM_PAYLOAD/startup/perfcollect;sudo apt update</HelixPreCommands>
+    <CoreRoot>$HELIX_CORRELATION_PAYLOAD/Core_Root</CoreRoot>
+    <ScenarioDirectory>$HELIX_CORRELATION_PAYLOAD/performance/src/scenarios/</ScenarioDirectory>
+    <CrossgenDirectory>$(ScenarioDirectory)crossgen/</CrossgenDirectory>
+    <Crossgen2Directory>$(ScenarioDirectory)crossgen2/</Crossgen2Directory>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <SingleAssembly Include="System.Private.Xml.dll"/>
+    <SingleAssembly Include="System.Linq.Expressions.dll"/>
+    <SingleAssembly Include="Microsoft.CodeAnalysis.VisualBasic.dll"/>
+    <SingleAssembly Include="Microsoft.CodeAnalysis.CSharp.dll"/>
+    <SingleAssembly Include="System.Private.CoreLib.dll"/>
+  </ItemGroup>
+  <ItemGroup>
+    <Composite Include="framework-r2r.dll.rsp"/>
+  </ItemGroup>
+
+  <ItemGroup>
+    <CrossgenWorkItem Include="@(SingleAssembly)">
+      <PayloadDirectory>$(WorkItemDirectory)</PayloadDirectory>
+      <Command>$(Python) $(CrossgenDirectory)test.py crossgen --core-root $(CoreRoot) --test-name %(Identity)</Command>
+    </CrossgenWorkItem>
+  </ItemGroup>
+
+  <ItemGroup> 
+    <Crossgen2WorkItem Include="@(SingleAssembly)">
+      <PayloadDirectory>$(WorkItemDirectory)</PayloadDirectory>
+      <Command>$(Python) $(Crossgen2Directory)test.py crossgen2 --core-root $(CoreRoot) --single %(Identity)</Command>
+    </Crossgen2WorkItem>
+  </ItemGroup>
+
+  <ItemGroup>
+    <!-- Enable crossgen tests on Windows x64 and Windows x86 -->
+    <HelixWorkItem Include="@(CrossgenWorkItem -> 'Crossgen %(Identity)')" Condition="'$(AGENT_OS)' == 'Windows_NT'">
+      <Timeout>4:00</Timeout>
+    </HelixWorkItem>
+    <!-- Enable crossgen2 tests on Windows x64 and Linux x64 -->
+    <HelixWorkItem Include="@(Crossgen2WorkItem -> 'Crossgen2 %(Identity)')" Condition="'$(Architecture)' == 'x64'">
+      <Timeout>4:00</Timeout>
+    </HelixWorkItem>
+    <HelixWorkItem Include="Crossgen2 Composite Framework R2R" Condition="'$(Architecture)' == 'x64'">
+      <PayloadDirectory>$(WorkItemDirectory)</PayloadDirectory>	
+      <Command>$(Python) $(Crossgen2Directory)test.py crossgen2 --core-root $(CoreRoot) --composite $(Crossgen2Directory)framework-r2r.dll.rsp</Command>
+      <Timeout>1:00</Timeout>  
+    </HelixWorkItem>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/eng/common/performance/perfhelixpublish.proj b/eng/common/performance/microbenchmarks.proj
similarity index 71%
rename from eng/common/performance/perfhelixpublish.proj
rename to eng/common/performance/microbenchmarks.proj
index e5826b53237..94b6efbc929 100644
--- a/eng/common/performance/perfhelixpublish.proj
+++ b/eng/common/performance/microbenchmarks.proj
@@ -6,7 +6,8 @@
     <Python>py -3</Python>
     <CoreRun>%HELIX_CORRELATION_PAYLOAD%\Core_Root\CoreRun.exe</CoreRun>
     <BaselineCoreRun>%HELIX_CORRELATION_PAYLOAD%\Baseline_Core_Root\CoreRun.exe</BaselineCoreRun>
-    <HelixPreCommands>$(HelixPreCommands);call %HELIX_CORRELATION_PAYLOAD%\performance\tools\machine-setup.cmd</HelixPreCommands>
+    
+    <HelixPreCommands>$(HelixPreCommands);call %HELIX_CORRELATION_PAYLOAD%\performance\tools\machine-setup.cmd;set PYTHONPATH=%HELIX_WORKITEM_PAYLOAD%\scripts%3B%HELIX_WORKITEM_PAYLOAD%</HelixPreCommands>
     <ArtifactsDirectory>%HELIX_CORRELATION_PAYLOAD%\artifacts\BenchmarkDotNet.Artifacts</ArtifactsDirectory>
     <BaselineArtifactsDirectory>%HELIX_CORRELATION_PAYLOAD%\artifacts\BenchmarkDotNet.Artifacts_Baseline</BaselineArtifactsDirectory>
     <ResultsComparer>%HELIX_CORRELATION_PAYLOAD%\performance\src\tools\ResultsComparer\ResultsComparer.csproj</ResultsComparer>
@@ -40,6 +41,17 @@
     <XMLResults>$HELIX_WORKITEM_ROOT/testResults.xml</XMLResults>
   </PropertyGroup>
 
+  <PropertyGroup Condition="'$(WasmDotnet)' == 'true'">
+    <CliArguments>$(CliArguments) --wasm</CliArguments>
+  </PropertyGroup>
+
+  <PropertyGroup Condition="'$(MonoDotnet)' == 'true' and '$(AGENT_OS)' == 'Windows_NT'">
+    <CoreRunArgument>--corerun %HELIX_CORRELATION_PAYLOAD%\dotnet-mono\shared\Microsoft.NETCore.App\6.0.0\corerun.exe</CoreRunArgument>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(MonoDotnet)' == 'true' and '$(AGENT_OS)' != 'Windows_NT'">
+    <CoreRunArgument>--corerun $(BaseDirectory)/dotnet-mono/shared/Microsoft.NETCore.App/6.0.0/corerun</CoreRunArgument>
+  </PropertyGroup>
+
   <PropertyGroup Condition="'$(UseCoreRun)' == 'true'">
     <CoreRunArgument>--corerun $(CoreRun)</CoreRunArgument>
   </PropertyGroup>
@@ -55,6 +67,11 @@
   <PropertyGroup Condition="'$(_Framework)' != 'net461'">
     <WorkItemCommand>$(WorkItemCommand) $(CliArguments)</WorkItemCommand>
   </PropertyGroup>
+  
+  <PropertyGroup>
+    <WorkItemTimeout>2:30</WorkItemTimeout>
+    <WorkItemTimeout Condition="'$(HelixSourcePrefix)' != 'official'">0:15</WorkItemTimeout>
+  </PropertyGroup>
 
   <ItemGroup>
     <HelixCorrelationPayload Include="$(CorrelationPayloadDirectory)">
@@ -63,7 +80,7 @@
   </ItemGroup>
 
   <PropertyGroup>
-    <PartitionCount>5</PartitionCount>
+    <PartitionCount>30</PartitionCount>
   </PropertyGroup>
   <ItemGroup>
     <Partition Include="$(BuildConfig).Partition0" Index="0" />
@@ -71,6 +88,31 @@
     <Partition Include="$(BuildConfig).Partition2" Index="2" />
     <Partition Include="$(BuildConfig).Partition3" Index="3" />
     <Partition Include="$(BuildConfig).Partition4" Index="4" />
+    <Partition Include="$(BuildConfig).Partition5" Index="5" />
+    <Partition Include="$(BuildConfig).Partition6" Index="6" />
+    <Partition Include="$(BuildConfig).Partition7" Index="7" />
+    <Partition Include="$(BuildConfig).Partition8" Index="8" />
+    <Partition Include="$(BuildConfig).Partition9" Index="9" />
+    <Partition Include="$(BuildConfig).Partition10" Index="10" />
+    <Partition Include="$(BuildConfig).Partition11" Index="11" />
+    <Partition Include="$(BuildConfig).Partition12" Index="12" />
+    <Partition Include="$(BuildConfig).Partition13" Index="13" />
+    <Partition Include="$(BuildConfig).Partition14" Index="14" />
+    <Partition Include="$(BuildConfig).Partition15" Index="15" />
+    <Partition Include="$(BuildConfig).Partition16" Index="16" />
+    <Partition Include="$(BuildConfig).Partition17" Index="17" />
+    <Partition Include="$(BuildConfig).Partition18" Index="18" />
+    <Partition Include="$(BuildConfig).Partition19" Index="19" />
+    <Partition Include="$(BuildConfig).Partition20" Index="20" />
+    <Partition Include="$(BuildConfig).Partition21" Index="21" />
+    <Partition Include="$(BuildConfig).Partition22" Index="22" />
+    <Partition Include="$(BuildConfig).Partition23" Index="23" />
+    <Partition Include="$(BuildConfig).Partition24" Index="24" />
+    <Partition Include="$(BuildConfig).Partition25" Index="25" />
+    <Partition Include="$(BuildConfig).Partition26" Index="26" />
+    <Partition Include="$(BuildConfig).Partition27" Index="27" />
+    <Partition Include="$(BuildConfig).Partition28" Index="28" />
+    <Partition Include="$(BuildConfig).Partition29" Index="29" />
   </ItemGroup>
 
   <PropertyGroup Condition="'$(Compare)' == 'true'">
@@ -86,7 +128,7 @@
       <PreCommands Condition="'$(Compare)' == 'true'">$(WorkItemCommand) --bdn-artifacts $(BaselineArtifactsDirectory) --bdn-arguments="--anyCategories $(BDNCategories) $(ExtraBenchmarkDotNetArguments) $(BaselineCoreRunArgument) --partition-count $(PartitionCount) --partition-index %(HelixWorkItem.Index)"</PreCommands>
       <Command>$(WorkItemCommand) --bdn-artifacts $(ArtifactsDirectory) --bdn-arguments="--anyCategories $(BDNCategories) $(ExtraBenchmarkDotNetArguments) $(CoreRunArgument) --partition-count $(PartitionCount) --partition-index %(HelixWorkItem.Index)"</Command>
       <PostCommands Condition="'$(Compare)' == 'true'">$(DotnetExe) run -f $(_Framework) -p $(ResultsComparer) --base $(BaselineArtifactsDirectory) --diff $(ArtifactsDirectory) --threshold 2$(Percent) --xml $(XMLResults);$(FinalCommand)</PostCommands>
-      <Timeout>4:00</Timeout>
+      <Timeout>$(WorkItemTimeout)</Timeout>
     </HelixWorkItem>
   </ItemGroup>
 
diff --git a/eng/common/performance/performance-setup.ps1 b/eng/common/performance/performance-setup.ps1
index ec41965fc89..656c0bd9022 100644
--- a/eng/common/performance/performance-setup.ps1
+++ b/eng/common/performance/performance-setup.ps1
@@ -3,18 +3,22 @@ Param(
     [string] $CoreRootDirectory,
     [string] $BaselineCoreRootDirectory,
     [string] $Architecture="x64",
-    [string] $Framework="netcoreapp5.0",
+    [string] $Framework="net5.0",
     [string] $CompilationMode="Tiered",
     [string] $Repository=$env:BUILD_REPOSITORY_NAME,
     [string] $Branch=$env:BUILD_SOURCEBRANCH,
     [string] $CommitSha=$env:BUILD_SOURCEVERSION,
     [string] $BuildNumber=$env:BUILD_BUILDNUMBER,
-    [string] $RunCategories="coreclr corefx",
+    [string] $RunCategories="Libraries Runtime",
     [string] $Csproj="src\benchmarks\micro\MicroBenchmarks.csproj",
     [string] $Kind="micro",
+    [switch] $LLVM,
+    [switch] $MonoInterpreter,
+    [switch] $MonoAOT, 
     [switch] $Internal,
     [switch] $Compare,
-    [string] $Configurations="CompilationMode=$CompilationMode"
+    [string] $MonoDotnet="",
+    [string] $Configurations="CompilationMode=$CompilationMode RunKind=$Kind"
 )
 
 $RunFromPerformanceRepo = ($Repository -eq "dotnet/performance") -or ($Repository -eq "dotnet-performance")
@@ -31,7 +35,8 @@ $HelixSourcePrefix = "pr"
 
 $Queue = "Windows.10.Amd64.ClientRS4.DevEx.15.8.Open"
 
-if ($Framework.StartsWith("netcoreapp")) {
+# TODO: Implement a better logic to determine if Framework is .NET Core or >= .NET 5.
+if ($Framework.StartsWith("netcoreapp") -or ($Framework -eq "net5.0")) {
     $Queue = "Windows.10.Amd64.ClientRS5.Open"
 }
 
@@ -49,9 +54,37 @@ if ($Internal) {
     $HelixSourcePrefix = "official"
 }
 
-$CommonSetupArguments="--frameworks $Framework --queue $Queue --build-number $BuildNumber --build-configs $Configurations"
+if($MonoInterpreter)
+{
+    $ExtraBenchmarkDotNetArguments = "--category-exclusion-filter NoInterpreter"
+}
+
+if($MonoDotnet -ne "")
+{
+    $Configurations += " LLVM=$LLVM MonoInterpreter=$MonoInterpreter MonoAOT=$MonoAOT"
+    if($ExtraBenchmarkDotNetArguments -eq "")
+    {
+        #FIX ME: We need to block these tests as they don't run on mono for now
+        $ExtraBenchmarkDotNetArguments = "--exclusion-filter *Perf_Image* *Perf_NamedPipeStream*"
+    }
+    else
+    {
+        #FIX ME: We need to block these tests as they don't run on mono for now
+        $ExtraBenchmarkDotNetArguments += " --exclusion-filter *Perf_Image* *Perf_NamedPipeStream*"
+    }
+}
+
+# FIX ME: This is a workaround until we get this from the actual pipeline
+$CommonSetupArguments="--channel master --queue $Queue --build-number $BuildNumber --build-configs $Configurations --architecture $Architecture"
 $SetupArguments = "--repository https://github.com/$Repository --branch $Branch --get-perf-hash --commit-sha $CommitSha $CommonSetupArguments"
 
+
+#This grabs the LKG version number of dotnet and passes it to our scripts
+$VersionJSON = Get-Content global.json | ConvertFrom-Json
+$DotNetVersion = $VersionJSON.tools.dotnet
+$SetupArguments = "--dotnet-versions $DotNetVersion $SetupArguments"
+
+
 if ($RunFromPerformanceRepo) {
     $SetupArguments = "--perf-hash $CommitSha $CommonSetupArguments"
     
@@ -61,6 +94,13 @@ else {
     git clone --branch master --depth 1 --quiet https://github.com/dotnet/performance $PerformanceDirectory
 }
 
+if($MonoDotnet -ne "")
+{
+    $UsingMono = "true"
+    $MonoDotnetPath = (Join-Path $PayloadDirectory "dotnet-mono")
+    Move-Item -Path $MonoDotnet -Destination $MonoDotnetPath
+}
+
 if ($UseCoreRun) {
     $NewCoreRoot = (Join-Path $PayloadDirectory "Core_Root")
     Move-Item -Path $CoreRootDirectory -Destination $NewCoreRoot
@@ -96,6 +136,7 @@ Write-PipelineSetVariable -Name 'UseCoreRun' -Value "$UseCoreRun" -IsMultiJobVar
 Write-PipelineSetVariable -Name 'UseBaselineCoreRun' -Value "$UseBaselineCoreRun" -IsMultiJobVariable $false
 Write-PipelineSetVariable -Name 'RunFromPerfRepo' -Value "$RunFromPerformanceRepo" -IsMultiJobVariable $false
 Write-PipelineSetVariable -Name 'Compare' -Value "$Compare" -IsMultiJobVariable $false
+Write-PipelineSetVariable -Name 'MonoDotnet' -Value "$UsingMono" -IsMultiJobVariable $false
 
 # Helix Arguments
 Write-PipelineSetVariable -Name 'Creator' -Value "$Creator" -IsMultiJobVariable $false
diff --git a/eng/common/performance/performance-setup.sh b/eng/common/performance/performance-setup.sh
index 2f2092166e4..99d1b7bc1fc 100755
--- a/eng/common/performance/performance-setup.sh
+++ b/eng/common/performance/performance-setup.sh
@@ -4,7 +4,7 @@ source_directory=$BUILD_SOURCESDIRECTORY
 core_root_directory=
 baseline_core_root_directory=
 architecture=x64
-framework=netcoreapp5.0
+framework=net5.0
 compilation_mode=tiered
 repository=$BUILD_REPOSITORY_NAME
 branch=$BUILD_SOURCEBRANCH
@@ -12,13 +12,21 @@ commit_sha=$BUILD_SOURCEVERSION
 build_number=$BUILD_BUILDNUMBER
 internal=false
 compare=false
+mono_dotnet=
 kind="micro"
-run_categories="coreclr corefx"
+llvm=false
+monointerpreter=false
+monoaot=false
+run_categories="Libraries Runtime"
 csproj="src\benchmarks\micro\MicroBenchmarks.csproj"
-configurations=
+configurations="CompliationMode=$compilation_mode RunKind=$kind"
 run_from_perf_repo=false
 use_core_run=true
 use_baseline_core_run=true
+using_mono=false
+wasm_runtime_loc=
+using_wasm=false
+use_latest_dotnet=false
 
 while (($# > 0)); do
   lowerI="$(echo $1 | awk '{print tolower($0)}')"
@@ -65,6 +73,7 @@ while (($# > 0)); do
       ;;
     --kind)
       kind=$2
+      configurations="CompilationMode=$compilation_mode RunKind=$kind"
       shift 2
       ;;
     --runcategories)
@@ -79,6 +88,26 @@ while (($# > 0)); do
       internal=true
       shift 1
       ;;
+    --llvm)
+      llvm=true
+      shift 1
+      ;;
+    --monointerpreter)
+      monointerpreter=true
+      shift 1
+      ;;
+    --monoaot)
+      monoaot=true
+      shift 1
+      ;;
+    --monodotnet)
+      mono_dotnet=$2
+      shift 2
+      ;;
+    --wasm)
+      wasm_runtime_loc=$2
+      shift 2
+      ;;
     --compare)
       compare=true
       shift 1
@@ -87,7 +116,11 @@ while (($# > 0)); do
       configurations=$2
       shift 2
       ;;
-    --help)
+    --latestdotnet)
+      use_latest_dotnet=true
+      shift 1
+      ;;
+    *)
       echo "Common settings:"
       echo "  --corerootdirectory <value>    Directory where Core_Root exists, if running perf testing with --corerun"
       echo "  --architecture <value>         Architecture of the testing being run"
@@ -107,6 +140,9 @@ while (($# > 0)); do
       echo "  --kind <value>                 Related to csproj. The kind of benchmarks that should be run. Defaults to micro"
       echo "  --runcategories <value>        Related to csproj. Categories of benchmarks to run. Defaults to \"coreclr corefx\""
       echo "  --internal                     If the benchmarks are running as an official job."
+      echo "  --monodotnet                   Pass the path to the mono dotnet for mono performance testing."
+      echo "  --wasm                         Path to the unpacked wasm runtime pack."
+      echo "  --latestdotnet                 --dotnet-versions will not be specified. --dotnet-versions defaults to LKG version in global.json "
       echo ""
       exit 0
       ;;
@@ -118,7 +154,7 @@ if [ "$repository" == "dotnet/performance" ] || [ "$repository" == "dotnet-perfo
 fi
 
 if [ -z "$configurations" ]; then
-    configurations="CompliationMode=$compilation_mode"
+    configurations="CompilationMode=$compilation_mode"
 fi
 
 if [ -z "$core_root_directory" ]; then
@@ -164,9 +200,31 @@ if [[ "$internal" == true ]]; then
     fi
 fi
 
-common_setup_arguments="--frameworks $framework --queue $queue --build-number $build_number --build-configs $configurations"
+if [[ "$mono_dotnet" != "" ]] && [[ "$monointerpreter" == "false" ]]; then
+    extra_benchmark_dotnet_arguments="$extra_benchmark_dotnet_arguments --category-exclusion-filter NoMono"
+fi
+
+if [[ "$wasm_runtime_loc" != "" ]]; then
+    configurations="CompilationMode=wasm RunKind=$kind"
+    extra_benchmark_dotnet_arguments="$extra_benchmark_dotnet_arguments --category-exclusion-filter NoInterpreter NoWASM NoMono"
+fi
+
+if [[ "$mono_dotnet" != "" ]] && [[ "$monointerpreter" == "true" ]]; then
+    configurations="$configurations LLVM=$llvm MonoInterpreter=$monointerpreter MonoAOT=$monoaot"
+    extra_benchmark_dotnet_arguments="$extra_benchmark_dotnet_arguments --category-exclusion-filter NoInterpreter NoMono"
+fi
+
+common_setup_arguments="--channel master --queue $queue --build-number $build_number --build-configs $configurations --architecture $architecture"
 setup_arguments="--repository https://github.com/$repository --branch $branch --get-perf-hash --commit-sha $commit_sha $common_setup_arguments"
 
+
+if [[ "$use_latest_dotnet" = false ]]; then
+    # Get the tools section from the global.json.
+    # This grabs the LKG version number of dotnet and passes it to our scripts
+    dotnet_version=`cat global.json | python3 -c 'import json,sys;obj=json.load(sys.stdin);print(obj["tools"]["dotnet"])'`
+    setup_arguments="--dotnet-versions $dotnet_version $setup_arguments"
+fi
+
 if [[ "$run_from_perf_repo" = true ]]; then
     payload_directory=
     workitem_directory=$source_directory
@@ -179,6 +237,19 @@ else
     mv $docs_directory $workitem_directory
 fi
 
+if [[ "$wasm_runtime_loc" != "" ]]; then
+    using_wasm=true
+    wasm_dotnet_path=$payload_directory/dotnet-wasm
+    mv $wasm_runtime_loc $wasm_dotnet_path
+    extra_benchmark_dotnet_arguments="$extra_benchmark_dotnet_arguments --wasmMainJS \$HELIX_CORRELATION_PAYLOAD/dotnet-wasm/runtime-test.js --wasmEngine /home/helixbot/.jsvu/v8 --customRuntimePack \$HELIX_CORRELATION_PAYLOAD/dotnet-wasm"
+fi
+
+if [[ "$mono_dotnet" != "" ]]; then
+    using_mono=true
+    mono_dotnet_path=$payload_directory/dotnet-mono
+    mv $mono_dotnet $mono_dotnet_path
+fi
+
 if [[ "$use_core_run" = true ]]; then
     new_core_root=$payload_directory/Core_Root
     mv $core_root_directory $new_core_root
@@ -203,7 +274,7 @@ Write-PipelineSetVariable -name "PerformanceDirectory" -value "$performance_dire
 Write-PipelineSetVariable -name "WorkItemDirectory" -value "$workitem_directory" -is_multi_job_variable false
 Write-PipelineSetVariable -name "Queue" -value "$queue" -is_multi_job_variable false
 Write-PipelineSetVariable -name "SetupArguments" -value "$setup_arguments" -is_multi_job_variable false
-Write-PipelineSetVariable -name "Python" -value "$python3" -is_multi_job_variable false
+Write-PipelineSetVariable -name "Python" -value "python3" -is_multi_job_variable false
 Write-PipelineSetVariable -name "PerfLabArguments" -value "$perflab_arguments" -is_multi_job_variable false
 Write-PipelineSetVariable -name "ExtraBenchmarkDotNetArguments" -value "$extra_benchmark_dotnet_arguments" -is_multi_job_variable false
 Write-PipelineSetVariable -name "BDNCategories" -value "$run_categories" -is_multi_job_variable false
@@ -214,3 +285,5 @@ Write-PipelineSetVariable -name "HelixSourcePrefix" -value "$helix_source_prefix
 Write-PipelineSetVariable -name "Kind" -value "$kind" -is_multi_job_variable false
 Write-PipelineSetVariable -name "_BuildConfig" -value "$architecture.$kind.$framework" -is_multi_job_variable false
 Write-PipelineSetVariable -name "Compare" -value "$compare" -is_multi_job_variable false
+Write-PipelineSetVariable -name "MonoDotnet" -value "$using_mono" -is_multi_job_variable false
+Write-PipelineSetVariable -name "WasmDotnet" -value "$using_wasm" -is_multi_job_variable false
diff --git a/eng/common/pipeline-logging-functions.ps1 b/eng/common/pipeline-logging-functions.ps1
index af5f48aaceb..8484451f3a5 100644
--- a/eng/common/pipeline-logging-functions.ps1
+++ b/eng/common/pipeline-logging-functions.ps1
@@ -12,6 +12,7 @@ $script:loggingCommandEscapeMappings = @( # TODO: WHAT ABOUT "="? WHAT ABOUT "%"
 # TODO: BUG: Escape % ???
 # TODO: Add test to verify don't need to escape "=".
 
+# Specify "-Force" to force pipeline formatted output even if "$ci" is false or not set
 function Write-PipelineTelemetryError {
     [CmdletBinding()]
     param(
@@ -25,49 +26,55 @@ function Write-PipelineTelemetryError {
         [string]$SourcePath,
         [string]$LineNumber,
         [string]$ColumnNumber,
-        [switch]$AsOutput)
-
-        $PSBoundParameters.Remove("Category") | Out-Null
+        [switch]$AsOutput,
+        [switch]$Force)
 
-        $Message = "(NETCORE_ENGINEERING_TELEMETRY=$Category) $Message"
-        $PSBoundParameters.Remove("Message") | Out-Null
-        $PSBoundParameters.Add("Message", $Message)
+        $PSBoundParameters.Remove('Category') | Out-Null
 
+        if($Force -Or ((Test-Path variable:ci) -And $ci)) {
+            $Message = "(NETCORE_ENGINEERING_TELEMETRY=$Category) $Message"
+        }
+        $PSBoundParameters.Remove('Message') | Out-Null
+        $PSBoundParameters.Add('Message', $Message)
         Write-PipelineTaskError @PSBoundParameters
 }
 
+# Specify "-Force" to force pipeline formatted output even if "$ci" is false or not set
 function Write-PipelineTaskError {
     [CmdletBinding()]
     param(
-      [Parameter(Mandatory = $true)]
-      [string]$Message,
-      [Parameter(Mandatory = $false)]
-      [string]$Type = 'error',
-      [string]$ErrCode,
-      [string]$SourcePath,
-      [string]$LineNumber,
-      [string]$ColumnNumber,
-      [switch]$AsOutput)
-  
-      if(!$ci) {
+        [Parameter(Mandatory = $true)]
+        [string]$Message,
+        [Parameter(Mandatory = $false)]
+        [string]$Type = 'error',
+        [string]$ErrCode,
+        [string]$SourcePath,
+        [string]$LineNumber,
+        [string]$ColumnNumber,
+        [switch]$AsOutput,
+        [switch]$Force
+    )
+
+    if(!$Force -And (-Not (Test-Path variable:ci) -Or !$ci)) {
         if($Type -eq 'error') {
-          Write-Host $Message -ForegroundColor Red
-          return
+            Write-Host $Message -ForegroundColor Red
+            return
         }
         elseif ($Type -eq 'warning') {
-          Write-Host $Message -ForegroundColor Yellow
-          return
+            Write-Host $Message -ForegroundColor Yellow
+            return
         }
-      }
-  
-      if(($Type -ne 'error') -and ($Type -ne 'warning')) {
+    }
+
+    if(($Type -ne 'error') -and ($Type -ne 'warning')) {
         Write-Host $Message
         return
-      }
-      if(-not $PSBoundParameters.ContainsKey('Type')) {
+    }
+    $PSBoundParameters.Remove('Force') | Out-Null      
+    if(-not $PSBoundParameters.ContainsKey('Type')) {
         $PSBoundParameters.Add('Type', 'error')
-      }
-      Write-LogIssue @PSBoundParameters
+    }
+    Write-LogIssue @PSBoundParameters
   }
   
   function Write-PipelineSetVariable {
@@ -80,7 +87,7 @@ function Write-PipelineTaskError {
       [switch]$AsOutput,
       [bool]$IsMultiJobVariable=$true)
 
-      if($ci) {
+      if((Test-Path variable:ci) -And $ci) {
         Write-LoggingCommand -Area 'task' -Event 'setvariable' -Data $Value -Properties @{
           'variable' = $Name
           'isSecret' = $Secret
@@ -95,7 +102,8 @@ function Write-PipelineTaskError {
       [Parameter(Mandatory=$true)]
       [string]$Path,
       [switch]$AsOutput)
-      if($ci) {
+
+      if((Test-Path variable:ci) -And $ci) {
         Write-LoggingCommand -Area 'task' -Event 'prependpath' -Data $Path -AsOutput:$AsOutput
       }
   }
@@ -231,4 +239,4 @@ function Write-LogIssue {
     }
 
     Write-Host $command -ForegroundColor $foregroundColor -BackgroundColor $backgroundColor
-}
\ No newline at end of file
+}
diff --git a/eng/common/pipeline-logging-functions.sh b/eng/common/pipeline-logging-functions.sh
index 1c560a50613..6cd0a3400e6 100755
--- a/eng/common/pipeline-logging-functions.sh
+++ b/eng/common/pipeline-logging-functions.sh
@@ -2,6 +2,7 @@
 
 function Write-PipelineTelemetryError {
   local telemetry_category=''
+  local force=false
   local function_args=()
   local message=''
   while [[ $# -gt 0 ]]; do
@@ -11,6 +12,9 @@ function Write-PipelineTelemetryError {
         telemetry_category=$2
         shift
         ;;
+      -force|-f)
+        force=true
+        ;;
       -*)
         function_args+=("$1 $2")
         shift
@@ -22,28 +26,26 @@ function Write-PipelineTelemetryError {
     shift
   done
 
-  if [[ "$ci" != true ]]; then
+  if [[ $force != true ]] && [[ "$ci" != true ]]; then
     echo "$message" >&2
     return
   fi
 
+  if [[ $force == true ]]; then
+    function_args+=("-force")
+  fi
   message="(NETCORE_ENGINEERING_TELEMETRY=$telemetry_category) $message"
   function_args+=("$message")
-
-  Write-PipelineTaskError $function_args
+  Write-PipelineTaskError ${function_args[@]}
 }
 
 function Write-PipelineTaskError {
-  if [[ "$ci" != true ]]; then
-    echo "$@" >&2
-    return
-  fi
-
   local message_type="error"
   local sourcepath=''
   local linenumber=''
   local columnnumber=''
   local error_code=''
+  local force=false
 
   while [[ $# -gt 0 ]]; do
     opt="$(echo "${1/#--/-}" | awk '{print tolower($0)}')"
@@ -68,6 +70,9 @@ function Write-PipelineTaskError {
         error_code=$2
         shift
         ;;
+      -force|-f)
+        force=true
+        ;;
       *)
         break
         ;;
@@ -76,6 +81,11 @@ function Write-PipelineTaskError {
     shift
   done
 
+  if [[ $force != true ]] && [[ "$ci" != true ]]; then
+    echo "$@" >&2
+    return
+  fi
+
   local message="##vso[task.logissue"
 
   message="$message type=$message_type"
diff --git a/eng/common/post-build/promote-build.ps1 b/eng/common/post-build/add-build-to-channel.ps1
similarity index 55%
rename from eng/common/post-build/promote-build.ps1
rename to eng/common/post-build/add-build-to-channel.ps1
index e5ae85f2517..de2d957922a 100644
--- a/eng/common/post-build/promote-build.ps1
+++ b/eng/common/post-build/add-build-to-channel.ps1
@@ -2,26 +2,26 @@ param(
   [Parameter(Mandatory=$true)][int] $BuildId,
   [Parameter(Mandatory=$true)][int] $ChannelId,
   [Parameter(Mandatory=$true)][string] $MaestroApiAccessToken,
-  [Parameter(Mandatory=$false)][string] $MaestroApiEndPoint = "https://maestro-prod.westus2.cloudapp.azure.com",
-  [Parameter(Mandatory=$false)][string] $MaestroApiVersion = "2019-01-16"
+  [Parameter(Mandatory=$false)][string] $MaestroApiEndPoint = 'https://maestro-prod.westus2.cloudapp.azure.com',
+  [Parameter(Mandatory=$false)][string] $MaestroApiVersion = '2019-01-16'
 )
 
-. $PSScriptRoot\post-build-utils.ps1
-
 try {
+  . $PSScriptRoot\post-build-utils.ps1
+
   # Check that the channel we are going to promote the build to exist
   $channelInfo = Get-MaestroChannel -ChannelId $ChannelId
 
   if (!$channelInfo) {
-    Write-Host "Channel with BAR ID $ChannelId was not found in BAR!"
+    Write-PipelineTelemetryCategory -Category 'PromoteBuild' -Message "Channel with BAR ID $ChannelId was not found in BAR!"
     ExitWithExitCode 1
   }
 
-  # Get info about which channels the build has already been promoted to
+  # Get info about which channel(s) the build has already been promoted to
   $buildInfo = Get-MaestroBuild -BuildId $BuildId
   
   if (!$buildInfo) {
-    Write-Host "Build with BAR ID $BuildId was not found in BAR!"
+    Write-PipelineTelemetryError -Category 'PromoteBuild' -Message "Build with BAR ID $BuildId was not found in BAR!"
     ExitWithExitCode 1
   }
 
@@ -39,10 +39,10 @@ try {
 
   Assign-BuildToChannel -BuildId $BuildId -ChannelId $ChannelId
 
-  Write-Host "done."
+  Write-Host 'done.'
 } 
 catch {
-  Write-Host "There was an error while trying to promote build '$BuildId' to channel '$ChannelId'"
   Write-Host $_
-  Write-Host $_.ScriptStackTrace
+  Write-PipelineTelemetryError -Category 'PromoteBuild' -Message "There was an error while trying to promote build '$BuildId' to channel '$ChannelId'"
+  ExitWithExitCode 1
 }
diff --git a/eng/common/post-build/check-channel-consistency.ps1 b/eng/common/post-build/check-channel-consistency.ps1
new file mode 100644
index 00000000000..63f3464c986
--- /dev/null
+++ b/eng/common/post-build/check-channel-consistency.ps1
@@ -0,0 +1,40 @@
+param(
+  [Parameter(Mandatory=$true)][string] $PromoteToChannels,            # List of channels that the build should be promoted to
+  [Parameter(Mandatory=$true)][array] $AvailableChannelIds            # List of channel IDs available in the YAML implementation
+)
+
+try {
+  . $PSScriptRoot\post-build-utils.ps1
+
+  if ($PromoteToChannels -eq "") {
+    Write-PipelineTaskError -Type 'warning' -Message "This build won't publish assets as it's not configured to any Maestro channel. If that wasn't intended use Darc to configure a default channel using add-default-channel for this branch or to promote it to a channel using add-build-to-channel. See https://github.com/dotnet/arcade/blob/master/Documentation/Darc.md#assigning-an-individual-build-to-a-channel for more info."
+    ExitWithExitCode 0
+  }
+
+  # Check that every channel that Maestro told to promote the build to 
+  # is available in YAML
+  $PromoteToChannelsIds = $PromoteToChannels -split "\D" | Where-Object { $_ }
+
+  $hasErrors = $false
+
+  foreach ($id in $PromoteToChannelsIds) {
+    if (($id -ne 0) -and ($id -notin $AvailableChannelIds)) {
+      Write-PipelineTaskError -Message "Channel $id is not present in the post-build YAML configuration! This is an error scenario. Please contact @dnceng."
+      $hasErrors = $true
+    }
+  }
+
+  # The `Write-PipelineTaskError` doesn't error the script and we might report several errors
+  # in the previous lines. The check below makes sure that we return an error state from the
+  # script if we reported any validation error
+  if ($hasErrors) {
+    ExitWithExitCode 1 
+  }
+
+  Write-Host 'done.'
+} 
+catch {
+  Write-Host $_
+  Write-PipelineTelemetryError -Category 'CheckChannelConsistency' -Message "There was an error while trying to check consistency of Maestro default channels for the build and post-build YAML configuration."
+  ExitWithExitCode 1
+}
diff --git a/eng/common/post-build/darc-gather-drop.ps1 b/eng/common/post-build/darc-gather-drop.ps1
deleted file mode 100644
index 89854d3c1c2..00000000000
--- a/eng/common/post-build/darc-gather-drop.ps1
+++ /dev/null
@@ -1,45 +0,0 @@
-param(
-  [Parameter(Mandatory=$true)][int] $BarBuildId,                # ID of the build which assets should be downloaded
-  [Parameter(Mandatory=$true)][string] $DropLocation,           # Where the assets should be downloaded to
-  [Parameter(Mandatory=$true)][string] $MaestroApiAccessToken,  # Token used to access Maestro API
-  [Parameter(Mandatory=$false)][string] $MaestroApiEndPoint = "https://maestro-prod.westus2.cloudapp.azure.com",     # Maestro API URL
-  [Parameter(Mandatory=$false)][string] $MaestroApiVersion = "2019-01-16"                                            # Version of Maestro API to use
-)
-
-. $PSScriptRoot\post-build-utils.ps1
-
-try {
-  Write-Host "Installing DARC ..."
-
-  . $PSScriptRoot\..\darc-init.ps1
-  $exitCode = $LASTEXITCODE
-
-  if ($exitCode -ne 0) {
-    Write-PipelineTaskError "Something failed while running 'darc-init.ps1'. Check for errors above. Exiting now..."
-    ExitWithExitCode $exitCode
-  }
-
-  # For now, only use a dry run.
-  # Ideally we would change darc to enable a quick request that
-  # would check whether the file exists that you can download it,
-  # and that it won't conflict with other files.
-  # https://github.com/dotnet/arcade/issues/3674
-  # Right now we can't remove continue-on-error because we ocassionally will have
-  # dependencies that have no associated builds (e.g. an old dependency).
-  # We need to add an option to baseline specific dependencies away, or add them manually
-  # to the BAR.
-  darc gather-drop --non-shipping `
-    --dry-run `
-    --continue-on-error `
-    --id $BarBuildId `
-    --output-dir $DropLocation `
-    --bar-uri $MaestroApiEndpoint `
-    --password $MaestroApiAccessToken `
-    --latest-location
-}
-catch {
-  Write-Host $_
-  Write-Host $_.Exception
-  Write-Host $_.ScriptStackTrace
-  ExitWithExitCode 1
-}
diff --git a/eng/common/post-build/nuget-validation.ps1 b/eng/common/post-build/nuget-validation.ps1
index 78ed0d540f5..dab3534ab53 100644
--- a/eng/common/post-build/nuget-validation.ps1
+++ b/eng/common/post-build/nuget-validation.ps1
@@ -6,20 +6,19 @@ param(
   [Parameter(Mandatory=$true)][string] $ToolDestinationPath     # Where the validation tool should be downloaded to
 )
 
-. $PSScriptRoot\post-build-utils.ps1
-
 try {
-  $url = "https://raw.githubusercontent.com/NuGet/NuGetGallery/jver-verify/src/VerifyMicrosoftPackage/verify.ps1" 
+  . $PSScriptRoot\post-build-utils.ps1
+
+  $url = 'https://raw.githubusercontent.com/NuGet/NuGetGallery/3e25ad135146676bcab0050a516939d9958bfa5d/src/VerifyMicrosoftPackage/verify.ps1'
 
-  New-Item -ItemType "directory" -Path ${ToolDestinationPath} -Force
+  New-Item -ItemType 'directory' -Path ${ToolDestinationPath} -Force
 
   Invoke-WebRequest $url -OutFile ${ToolDestinationPath}\verify.ps1 
 
   & ${ToolDestinationPath}\verify.ps1 ${PackagesPath}\*.nupkg
 } 
 catch {
-  Write-PipelineTaskError "NuGet package validation failed. Please check error logs."
-  Write-Host $_
   Write-Host $_.ScriptStackTrace
+  Write-PipelineTelemetryError -Category 'NuGetValidation' -Message $_
   ExitWithExitCode 1
 }
diff --git a/eng/common/post-build/post-build-utils.ps1 b/eng/common/post-build/post-build-utils.ps1
index 551ae113f89..7d49744795f 100644
--- a/eng/common/post-build/post-build-utils.ps1
+++ b/eng/common/post-build/post-build-utils.ps1
@@ -1,16 +1,17 @@
 # Most of the functions in this file require the variables `MaestroApiEndPoint`, 
 # `MaestroApiVersion` and `MaestroApiAccessToken` to be globally available.
 
-$ErrorActionPreference = "Stop"
+$ErrorActionPreference = 'Stop'
 Set-StrictMode -Version 2.0
 
 # `tools.ps1` checks $ci to perform some actions. Since the post-build
 # scripts don't necessarily execute in the same agent that run the
 # build.ps1/sh script this variable isn't automatically set.
 $ci = $true
+$disableConfigureToolsetImport = $true
 . $PSScriptRoot\..\tools.ps1
 
-function Create-MaestroApiRequestHeaders([string]$ContentType = "application/json") {
+function Create-MaestroApiRequestHeaders([string]$ContentType = 'application/json') {
   Validate-MaestroVars
 
   $headers = New-Object 'System.Collections.Generic.Dictionary[[String],[String]]'
@@ -50,20 +51,20 @@ function Get-MaestroSubscriptions([string]$SourceRepository, [int]$ChannelId) {
   return $result
 }
 
-function Trigger-Subscription([string]$SubscriptionId) {
+function Assign-BuildToChannel([int]$BuildId, [int]$ChannelId) {
   Validate-MaestroVars
 
   $apiHeaders = Create-MaestroApiRequestHeaders -AuthToken $MaestroApiAccessToken
-  $apiEndpoint = "$MaestroApiEndPoint/api/subscriptions/$SubscriptionId/trigger?api-version=$MaestroApiVersion"
-  Invoke-WebRequest -Uri $apiEndpoint -Headers $apiHeaders -Method Post | Out-Null
+  $apiEndpoint = "$MaestroApiEndPoint/api/channels/${ChannelId}/builds/${BuildId}?api-version=$MaestroApiVersion"
+  Invoke-WebRequest -Method Post -Uri $apiEndpoint -Headers $apiHeaders | Out-Null
 }
 
-function Assign-BuildToChannel([int]$BuildId, [int]$ChannelId) {
+function Trigger-Subscription([string]$SubscriptionId) {
   Validate-MaestroVars
 
   $apiHeaders = Create-MaestroApiRequestHeaders -AuthToken $MaestroApiAccessToken
-  $apiEndpoint = "$MaestroApiEndPoint/api/channels/${ChannelId}/builds/${BuildId}?api-version=$MaestroApiVersion"
-  Invoke-WebRequest -Method Post -Uri $apiEndpoint -Headers $apiHeaders | Out-Null
+  $apiEndpoint = "$MaestroApiEndPoint/api/subscriptions/$SubscriptionId/trigger?api-version=$MaestroApiVersion"
+  Invoke-WebRequest -Uri $apiEndpoint -Headers $apiHeaders -Method Post | Out-Null
 }
 
 function Validate-MaestroVars {
@@ -72,18 +73,18 @@ function Validate-MaestroVars {
     Get-Variable MaestroApiVersion -Scope Global | Out-Null
     Get-Variable MaestroApiAccessToken -Scope Global | Out-Null
 
-    if (!($MaestroApiEndPoint -Match "^http[s]?://maestro-(int|prod).westus2.cloudapp.azure.com$")) {
-      Write-PipelineTaskError "MaestroApiEndPoint is not a valid Maestro URL. '$MaestroApiEndPoint'"
+    if (!($MaestroApiEndPoint -Match '^http[s]?://maestro-(int|prod).westus2.cloudapp.azure.com$')) {
+      Write-PipelineTelemetryError -Category 'MaestroVars' -Message "MaestroApiEndPoint is not a valid Maestro URL. '$MaestroApiEndPoint'"
       ExitWithExitCode 1  
     }
 
-    if (!($MaestroApiVersion -Match "^[0-9]{4}-[0-9]{2}-[0-9]{2}$")) {
-      Write-PipelineTaskError "MaestroApiVersion does not match a version string in the format yyyy-MM-DD. '$MaestroApiVersion'"
+    if (!($MaestroApiVersion -Match '^[0-9]{4}-[0-9]{2}-[0-9]{2}$')) {
+      Write-PipelineTelemetryError -Category 'MaestroVars' -Message "MaestroApiVersion does not match a version string in the format yyyy-MM-DD. '$MaestroApiVersion'"
       ExitWithExitCode 1
     }
   }
   catch {
-    Write-PipelineTaskError "Error: Variables `MaestroApiEndPoint`, `MaestroApiVersion` and `MaestroApiAccessToken` are required while using this script."
+    Write-PipelineTelemetryError -Category 'MaestroVars' -Message 'Error: Variables `MaestroApiEndPoint`, `MaestroApiVersion` and `MaestroApiAccessToken` are required while using this script.'
     Write-Host $_
     ExitWithExitCode 1
   }
diff --git a/eng/common/post-build/publish-using-darc.ps1 b/eng/common/post-build/publish-using-darc.ps1
new file mode 100644
index 00000000000..650b13b089b
--- /dev/null
+++ b/eng/common/post-build/publish-using-darc.ps1
@@ -0,0 +1,74 @@
+param(
+  [Parameter(Mandatory=$true)][int] $BuildId,
+  [Parameter(Mandatory=$true)][int] $PublishingInfraVersion,
+  [Parameter(Mandatory=$true)][string] $AzdoToken,
+  [Parameter(Mandatory=$true)][string] $MaestroToken,
+  [Parameter(Mandatory=$false)][string] $MaestroApiEndPoint = 'https://maestro-prod.westus2.cloudapp.azure.com',
+  [Parameter(Mandatory=$true)][string] $WaitPublishingFinish,
+  [Parameter(Mandatory=$false)][string] $EnableSourceLinkValidation,
+  [Parameter(Mandatory=$false)][string] $EnableSigningValidation,
+  [Parameter(Mandatory=$false)][string] $EnableNugetValidation,
+  [Parameter(Mandatory=$false)][string] $PublishInstallersAndChecksums,
+  [Parameter(Mandatory=$false)][string] $ArtifactsPublishingAdditionalParameters,
+  [Parameter(Mandatory=$false)][string] $SigningValidationAdditionalParameters
+)
+
+try {
+  . $PSScriptRoot\post-build-utils.ps1
+  # Hard coding darc version till the next arcade-services roll out, cos this version has required API changes for darc add-build-to-channel
+  $darc = Get-Darc "1.1.0-beta.20418.1"
+
+  $optionalParams = [System.Collections.ArrayList]::new()
+
+  if ("" -ne $ArtifactsPublishingAdditionalParameters) {
+    $optionalParams.Add("artifact-publishing-parameters") | Out-Null
+    $optionalParams.Add($ArtifactsPublishingAdditionalParameters) | Out-Null
+  }
+
+  if ("false" -eq $WaitPublishingFinish) {
+    $optionalParams.Add("--no-wait") | Out-Null
+  }
+
+  if ("false" -ne $PublishInstallersAndChecksums) {
+    $optionalParams.Add("--publish-installers-and-checksums") | Out-Null
+  }
+
+  if ("true" -eq $EnableNugetValidation) {
+    $optionalParams.Add("--validate-nuget") | Out-Null
+  }
+
+  if ("true" -eq $EnableSourceLinkValidation) {
+    $optionalParams.Add("--validate-sourcelinkchecksums") | Out-Null
+  }
+
+  if ("true" -eq $EnableSigningValidation) {
+    $optionalParams.Add("--validate-signingchecksums") | Out-Null
+
+    if ("" -ne $SigningValidationAdditionalParameters) {
+      $optionalParams.Add("--signing-validation-parameters") | Out-Null
+      $optionalParams.Add($SigningValidationAdditionalParameters) | Out-Null
+    }
+  }
+
+  & $darc add-build-to-channel `
+  --id $buildId `
+  --publishing-infra-version $PublishingInfraVersion `
+  --default-channels `
+  --source-branch master `
+  --azdev-pat $AzdoToken `
+  --bar-uri $MaestroApiEndPoint `
+  --password $MaestroToken `
+	@optionalParams
+
+  if ($LastExitCode -ne 0) {
+    Write-Host "Problems using Darc to promote build ${buildId} to default channels. Stopping execution..."
+    exit 1
+  }
+
+  Write-Host 'done.'
+} 
+catch {
+  Write-Host $_
+  Write-PipelineTelemetryError -Category 'PromoteBuild' -Message "There was an error while trying to publish build '$BuildId' to default channels."
+  ExitWithExitCode 1
+}
diff --git a/eng/common/post-build/setup-maestro-vars.ps1 b/eng/common/post-build/setup-maestro-vars.ps1
deleted file mode 100644
index d7f64dc63cb..00000000000
--- a/eng/common/post-build/setup-maestro-vars.ps1
+++ /dev/null
@@ -1,26 +0,0 @@
-param(
-  [Parameter(Mandatory=$true)][string] $ReleaseConfigsPath            # Full path to ReleaseConfigs.txt asset
-)
-
-. $PSScriptRoot\post-build-utils.ps1
-
-try {
-  $Content = Get-Content $ReleaseConfigsPath
-  
-  $BarId = $Content | Select -Index 0
-  
-  $Channels = ""            
-  $Content | Select -Index 1 | ForEach-Object { $Channels += "$_ ," }
-  
-  $IsStableBuild = $Content | Select -Index 2
-
-  Write-PipelineSetVariable -Name 'BARBuildId' -Value $BarId
-  Write-PipelineSetVariable -Name 'InitialChannels' -Value "$Channels"
-  Write-PipelineSetVariable -Name 'IsStableBuild' -Value $IsStableBuild
-}
-catch {
-  Write-Host $_
-  Write-Host $_.Exception
-  Write-Host $_.ScriptStackTrace
-  ExitWithExitCode 1
-}
diff --git a/eng/common/post-build/sourcelink-validation.ps1 b/eng/common/post-build/sourcelink-validation.ps1
index bbfdacca130..c7e7ae67d81 100644
--- a/eng/common/post-build/sourcelink-validation.ps1
+++ b/eng/common/post-build/sourcelink-validation.ps1
@@ -34,9 +34,9 @@ $ValidatePackage = {
 
   # Extensions for which we'll look for SourceLink information
   # For now we'll only care about Portable & Embedded PDBs
-  $RelevantExtensions = @(".dll", ".exe", ".pdb")
+  $RelevantExtensions = @('.dll', '.exe', '.pdb')
  
-  Write-Host -NoNewLine "Validating" ([System.IO.Path]::GetFileName($PackagePath)) "... "
+  Write-Host -NoNewLine 'Validating ' ([System.IO.Path]::GetFileName($PackagePath)) '...'
 
   $PackageId = [System.IO.Path]::GetFileNameWithoutExtension($PackagePath)
   $ExtractPath = Join-Path -Path $using:ExtractPath -ChildPath $PackageId
@@ -58,7 +58,7 @@ $ValidatePackage = {
           $TargetFile = Join-Path -Path $ExtractPath -ChildPath $FakeName 
 
           # We ignore resource DLLs
-          if ($FileName.EndsWith(".resources.dll")) {
+          if ($FileName.EndsWith('.resources.dll')) {
             return
           }
 
@@ -96,7 +96,7 @@ $ValidatePackage = {
                         $Uri = $Link -as [System.URI]
                       
                         # Only GitHub links are valid
-                        if ($Uri.AbsoluteURI -ne $null -and ($Uri.Host -match "github" -or $Uri.Host -match "githubusercontent")) {
+                        if ($Uri.AbsoluteURI -ne $null -and ($Uri.Host -match 'github' -or $Uri.Host -match 'githubusercontent')) {
                           $Status = (Invoke-WebRequest -Uri $Link -UseBasicParsing -Method HEAD -TimeoutSec 5).StatusCode
                         }
                         else {
@@ -143,19 +143,35 @@ $ValidatePackage = {
   }
 
   if ($FailedFiles -eq 0) {
-    Write-Host "Passed."
-    return 0
+    Write-Host 'Passed.'
+    return [pscustomobject]@{
+      result = 0
+      packagePath = $PackagePath
+    }
   }
   else {
-    Write-Host "$PackagePath has broken SourceLink links."
-    return 1
+    Write-PipelineTelemetryError -Category 'SourceLink' -Message "$PackagePath has broken SourceLink links."
+    return [pscustomobject]@{
+      result = 1
+      packagePath = $PackagePath
+    }
+  }
+}
+
+function CheckJobResult(
+    $result, 
+    $packagePath,
+    [ref]$ValidationFailures) {
+  if ($jobResult.result -ne '0') {
+    Write-PipelineTelemetryError -Category 'SourceLink' -Message "$packagePath has broken SourceLink links."
+    $ValidationFailures.Value++
   }
 }
 
 function ValidateSourceLinkLinks {
-  if ($GHRepoName -ne "" -and !($GHRepoName -Match "^[^\s\/]+/[^\s\/]+$")) {
-    if (!($GHRepoName -Match "^[^\s-]+-[^\s]+$")) {
-      Write-PipelineTaskError "GHRepoName should be in the format <org>/<repo> or <org>-<repo>. '$GHRepoName'"
+  if ($GHRepoName -ne '' -and !($GHRepoName -Match '^[^\s\/]+/[^\s\/]+$')) {
+    if (!($GHRepoName -Match '^[^\s-]+-[^\s]+$')) {
+      Write-PipelineTelemetryError -Category 'SourceLink' -Message "GHRepoName should be in the format <org>/<repo> or <org>-<repo>. '$GHRepoName'"
       ExitWithExitCode 1
     }
     else {
@@ -163,14 +179,14 @@ function ValidateSourceLinkLinks {
     }
   }
 
-  if ($GHCommit -ne "" -and !($GHCommit -Match "^[0-9a-fA-F]{40}$")) {
-    Write-PipelineTaskError "GHCommit should be a 40 chars hexadecimal string. '$GHCommit'"
+  if ($GHCommit -ne '' -and !($GHCommit -Match '^[0-9a-fA-F]{40}$')) {
+    Write-PipelineTelemetryError -Category 'SourceLink' -Message "GHCommit should be a 40 chars hexadecimal string. '$GHCommit'"
     ExitWithExitCode 1
   }
 
-  if ($GHRepoName -ne "" -and $GHCommit -ne "") {
-    $RepoTreeURL = -Join("http://api.github.com/repos/", $GHRepoName, "/git/trees/", $GHCommit, "?recursive=1")
-    $CodeExtensions = @(".cs", ".vb", ".fs", ".fsi", ".fsx", ".fsscript")
+  if ($GHRepoName -ne '' -and $GHCommit -ne '') {
+    $RepoTreeURL = -Join('http://api.github.com/repos/', $GHRepoName, '/git/trees/', $GHCommit, '?recursive=1')
+    $CodeExtensions = @('.cs', '.vb', '.fs', '.fsi', '.fsx', '.fsscript')
 
     try {
       # Retrieve the list of files in the repo at that particular commit point and store them in the RepoFiles hash
@@ -188,14 +204,16 @@ function ValidateSourceLinkLinks {
       Write-Host "Problems downloading the list of files from the repo. Url used: $RepoTreeURL . Execution will proceed without caching."
     }
   }
-  elseif ($GHRepoName -ne "" -or $GHCommit -ne "") {
-    Write-Host "For using the http caching mechanism both GHRepoName and GHCommit should be informed."
+  elseif ($GHRepoName -ne '' -or $GHCommit -ne '') {
+    Write-Host 'For using the http caching mechanism both GHRepoName and GHCommit should be informed.'
   }
   
   if (Test-Path $ExtractPath) {
     Remove-Item $ExtractPath -Force -Recurse -ErrorAction SilentlyContinue
   }
 
+  $ValidationFailures = 0
+
   # Process each NuGet package in parallel
   Get-ChildItem "$InputPath\*.symbols.nupkg" |
     ForEach-Object {
@@ -209,26 +227,27 @@ function ValidateSourceLinkLinks {
       }
 
       foreach ($Job in @(Get-Job -State 'Completed')) {
-        Receive-Job -Id $Job.Id
+        $jobResult = Wait-Job -Id $Job.Id | Receive-Job
+        CheckJobResult $jobResult.result $jobResult.packagePath ([ref]$ValidationFailures)
         Remove-Job -Id $Job.Id
       }
     }
 
-  $ValidationFailures = 0
   foreach ($Job in @(Get-Job)) {
     $jobResult = Wait-Job -Id $Job.Id | Receive-Job
-    if ($jobResult -ne "0") {
+    if ($jobResult -ne '0') {
       $ValidationFailures++
     }
+    Remove-Job -Id $Job.Id
   }
   if ($ValidationFailures -gt 0) {
-    Write-PipelineTaskError " $ValidationFailures package(s) failed validation."
+    Write-PipelineTelemetryError -Category 'SourceLink' -Message "$ValidationFailures package(s) failed validation."
     ExitWithExitCode 1
   }
 }
 
 function InstallSourcelinkCli {
-  $sourcelinkCliPackageName = "sourcelink"
+  $sourcelinkCliPackageName = 'sourcelink'
 
   $dotnetRoot = InitializeDotNetCli -install:$true
   $dotnet = "$dotnetRoot\dotnet.exe"
@@ -239,7 +258,7 @@ function InstallSourcelinkCli {
   }
   else {
     Write-Host "Installing SourceLink CLI version $sourcelinkCliVersion..."
-    Write-Host "You may need to restart your command window if this is the first dotnet tool you have installed."
+    Write-Host 'You may need to restart your command window if this is the first dotnet tool you have installed.'
     & "$dotnet" tool install $sourcelinkCliPackageName --version $sourcelinkCliVersion --verbosity "minimal" --global 
   }
 }
@@ -250,8 +269,8 @@ try {
   ValidateSourceLinkLinks 
 }
 catch {
-  Write-Host $_
   Write-Host $_.Exception
   Write-Host $_.ScriptStackTrace
+  Write-PipelineTelemetryError -Category 'SourceLink' -Message $_
   ExitWithExitCode 1
 }
diff --git a/eng/common/post-build/symbols-validation.ps1 b/eng/common/post-build/symbols-validation.ps1
index 096ac321d12..fcc6019b495 100644
--- a/eng/common/post-build/symbols-validation.ps1
+++ b/eng/common/post-build/symbols-validation.ps1
@@ -1,127 +1,168 @@
 param(
   [Parameter(Mandatory=$true)][string] $InputPath,              # Full path to directory where NuGet packages to be checked are stored
   [Parameter(Mandatory=$true)][string] $ExtractPath,            # Full path to directory where the packages will be extracted during validation
-  [Parameter(Mandatory=$true)][string] $DotnetSymbolVersion     # Version of dotnet symbol to use
+  [Parameter(Mandatory=$true)][string] $DotnetSymbolVersion,    # Version of dotnet symbol to use
+  [Parameter(Mandatory=$false)][switch] $ContinueOnError,       # If we should keep checking symbols after an error
+  [Parameter(Mandatory=$false)][switch] $Clean                  # Clean extracted symbols directory after checking symbols
 )
 
-. $PSScriptRoot\post-build-utils.ps1
+# Maximum number of jobs to run in parallel
+$MaxParallelJobs = 6
 
-Add-Type -AssemblyName System.IO.Compression.FileSystem
+# Wait time between check for system load
+$SecondsBetweenLoadChecks = 10
 
-function FirstMatchingSymbolDescriptionOrDefault {
+$CountMissingSymbols = {
   param( 
-    [string] $FullPath,                  # Full path to the module that has to be checked
-    [string] $TargetServerParam,         # Parameter to pass to `Symbol Tool` indicating the server to lookup for symbols
-    [string] $SymbolsPath
+    [string] $PackagePath          # Path to a NuGet package
   )
 
-  $FileName = [System.IO.Path]::GetFileName($FullPath)
-  $Extension = [System.IO.Path]::GetExtension($FullPath)
-
-  # Those below are potential symbol files that the `dotnet symbol` might
-  # return. Which one will be returned depend on the type of file we are
-  # checking and which type of file was uploaded.
-
-  # The file itself is returned
-  $SymbolPath = $SymbolsPath + "\" + $FileName
-
-  # PDB file for the module
-  $PdbPath = $SymbolPath.Replace($Extension, ".pdb")
-
-  # PDB file for R2R module (created by crossgen)
-  $NGenPdb = $SymbolPath.Replace($Extension, ".ni.pdb")
+  . $using:PSScriptRoot\..\tools.ps1
 
-  # DBG file for a .so library
-  $SODbg = $SymbolPath.Replace($Extension, ".so.dbg")
-
-  # DWARF file for a .dylib
-  $DylibDwarf = $SymbolPath.Replace($Extension, ".dylib.dwarf")
- 
-  $dotnetSymbolExe = "$env:USERPROFILE\.dotnet\tools"
-  $dotnetSymbolExe = Resolve-Path "$dotnetSymbolExe\dotnet-symbol.exe"
-
-  & $dotnetSymbolExe --symbols --modules --windows-pdbs $TargetServerParam $FullPath -o $SymbolsPath | Out-Null
-
-  if (Test-Path $PdbPath) {
-    return "PDB"
-  }
-  elseif (Test-Path $NGenPdb) {
-    return "NGen PDB"
-  }
-  elseif (Test-Path $SODbg) {
-    return "DBG for SO"
-  }  
-  elseif (Test-Path $DylibDwarf) {
-    return "Dwarf for Dylib"
-  }  
-  elseif (Test-Path $SymbolPath) {
-    return "Module"
-  }
-  else {
-    return $null
-  }
-}
-
-function CountMissingSymbols {
-  param( 
-    [string] $PackagePath          # Path to a NuGet package
-  )
+  Add-Type -AssemblyName System.IO.Compression.FileSystem
 
   # Ensure input file exist
   if (!(Test-Path $PackagePath)) {
     Write-PipelineTaskError "Input file does not exist: $PackagePath"
-    ExitWithExitCode 1
+    return -2
   }
   
   # Extensions for which we'll look for symbols
-  $RelevantExtensions = @(".dll", ".exe", ".so", ".dylib")
+  $RelevantExtensions = @('.dll', '.exe', '.so', '.dylib')
 
   # How many files are missing symbol information
   $MissingSymbols = 0
 
   $PackageId = [System.IO.Path]::GetFileNameWithoutExtension($PackagePath)
   $PackageGuid = New-Guid
-  $ExtractPath = Join-Path -Path $ExtractPath -ChildPath $PackageGuid
-  $SymbolsPath = Join-Path -Path $ExtractPath -ChildPath "Symbols"
+  $ExtractPath = Join-Path -Path $using:ExtractPath -ChildPath $PackageGuid
+  $SymbolsPath = Join-Path -Path $ExtractPath -ChildPath 'Symbols'
   
-  [System.IO.Compression.ZipFile]::ExtractToDirectory($PackagePath, $ExtractPath)
+  try {
+    [System.IO.Compression.ZipFile]::ExtractToDirectory($PackagePath, $ExtractPath)
+  }
+  catch {
+    Write-Host "Something went wrong extracting $PackagePath"
+    Write-Host $_
+    return [pscustomobject]@{
+      result = -1
+      packagePath = $PackagePath
+    }
+  }
 
   Get-ChildItem -Recurse $ExtractPath |
     Where-Object {$RelevantExtensions -contains $_.Extension} |
     ForEach-Object {
-      if ($_.FullName -Match "\\ref\\") {
-        Write-Host "`t Ignoring reference assembly file" $_.FullName
+      $FileName = $_.FullName
+      if ($FileName -Match '\\ref\\') {
+        Write-Host "`t Ignoring reference assembly file " $FileName
         return
       }
 
-      $SymbolsOnMSDL = FirstMatchingSymbolDescriptionOrDefault $_.FullName "--microsoft-symbol-server" $SymbolsPath
-      $SymbolsOnSymWeb = FirstMatchingSymbolDescriptionOrDefault $_.FullName "--internal-server" $SymbolsPath
+      $FirstMatchingSymbolDescriptionOrDefault = {
+      param( 
+        [string] $FullPath,                  # Full path to the module that has to be checked
+        [string] $TargetServerParam,         # Parameter to pass to `Symbol Tool` indicating the server to lookup for symbols
+        [string] $SymbolsPath
+      )
+
+      $FileName = [System.IO.Path]::GetFileName($FullPath)
+      $Extension = [System.IO.Path]::GetExtension($FullPath)
+
+      # Those below are potential symbol files that the `dotnet symbol` might
+      # return. Which one will be returned depend on the type of file we are
+      # checking and which type of file was uploaded.
+
+      # The file itself is returned
+      $SymbolPath = $SymbolsPath + '\' + $FileName
 
-      Write-Host -NoNewLine "`t Checking file" $_.FullName "... "
+      # PDB file for the module
+      $PdbPath = $SymbolPath.Replace($Extension, '.pdb')
+
+      # PDB file for R2R module (created by crossgen)
+      $NGenPdb = $SymbolPath.Replace($Extension, '.ni.pdb')
+
+      # DBG file for a .so library
+      $SODbg = $SymbolPath.Replace($Extension, '.so.dbg')
+
+      # DWARF file for a .dylib
+      $DylibDwarf = $SymbolPath.Replace($Extension, '.dylib.dwarf')
+    
+      $dotnetSymbolExe = "$env:USERPROFILE\.dotnet\tools"
+      $dotnetSymbolExe = Resolve-Path "$dotnetSymbolExe\dotnet-symbol.exe"
+
+      & $dotnetSymbolExe --symbols --modules --windows-pdbs $TargetServerParam $FullPath -o $SymbolsPath | Out-Null
+
+      if (Test-Path $PdbPath) {
+        return 'PDB'
+      }
+      elseif (Test-Path $NGenPdb) {
+        return 'NGen PDB'
+      }
+      elseif (Test-Path $SODbg) {
+        return 'DBG for SO'
+      }  
+      elseif (Test-Path $DylibDwarf) {
+        return 'Dwarf for Dylib'
+      }  
+      elseif (Test-Path $SymbolPath) {
+        return 'Module'
+      }
+      else {
+        return $null
+      }
+    }
+
+      $SymbolsOnMSDL = & $FirstMatchingSymbolDescriptionOrDefault $FileName '--microsoft-symbol-server' $SymbolsPath
+      $SymbolsOnSymWeb = & $FirstMatchingSymbolDescriptionOrDefault $FileName '--internal-server' $SymbolsPath
+
+      Write-Host -NoNewLine "`t Checking file " $FileName "... "
   
       if ($SymbolsOnMSDL -ne $null -and $SymbolsOnSymWeb -ne $null) {
-        Write-Host "Symbols found on MSDL (" $SymbolsOnMSDL ") and SymWeb (" $SymbolsOnSymWeb ")"
+        Write-Host "Symbols found on MSDL ($SymbolsOnMSDL) and SymWeb ($SymbolsOnSymWeb)"
       }
       else {
         $MissingSymbols++
 
         if ($SymbolsOnMSDL -eq $null -and $SymbolsOnSymWeb -eq $null) {
-          Write-Host "No symbols found on MSDL or SymWeb!"
+          Write-Host 'No symbols found on MSDL or SymWeb!'
         }
         else {
           if ($SymbolsOnMSDL -eq $null) {
-            Write-Host "No symbols found on MSDL!"
+            Write-Host 'No symbols found on MSDL!'
           }
           else {
-            Write-Host "No symbols found on SymWeb!"
+            Write-Host 'No symbols found on SymWeb!'
           }
         }
       }
     }
   
+  if ($using:Clean) {
+    Remove-Item $ExtractPath -Recurse -Force
+  }
+  
   Pop-Location
 
-  return $MissingSymbols
+  return [pscustomobject]@{
+      result = $MissingSymbols
+      packagePath = $PackagePath
+    }
+}
+
+function CheckJobResult(
+    $result, 
+    $packagePath,
+    [ref]$DupedSymbols,
+    [ref]$TotalFailures) {
+  if ($result -eq '-1') {
+    Write-PipelineTelemetryError -Category 'CheckSymbols' -Message "$packagePath has duplicated symbol files"
+    $DupedSymbols.Value++
+  } 
+  elseif ($jobResult.result -ne '0') {
+    Write-PipelineTelemetryError -Category 'CheckSymbols' -Message "Missing symbols for $result modules in the package $packagePath"
+    $TotalFailures.Value++
+  }
 }
 
 function CheckSymbolsAvailable {
@@ -129,38 +170,71 @@ function CheckSymbolsAvailable {
     Remove-Item $ExtractPath -Force  -Recurse -ErrorAction SilentlyContinue
   }
 
+  $TotalFailures = 0
+  $DupedSymbols = 0
+
   Get-ChildItem "$InputPath\*.nupkg" |
     ForEach-Object {
       $FileName = $_.Name
-	  
+      $FullName = $_.FullName
+
       # These packages from Arcade-Services include some native libraries that
       # our current symbol uploader can't handle. Below is a workaround until
       # we get issue: https://github.com/dotnet/arcade/issues/2457 sorted.
-      if ($FileName -Match "Microsoft\.DotNet\.Darc\.") {
+      if ($FileName -Match 'Microsoft\.DotNet\.Darc\.') {
         Write-Host "Ignoring Arcade-services file: $FileName"
         Write-Host
         return
       }
-      elseif ($FileName -Match "Microsoft\.DotNet\.Maestro\.Tasks\.") {
+      elseif ($FileName -Match 'Microsoft\.DotNet\.Maestro\.Tasks\.') {
         Write-Host "Ignoring Arcade-services file: $FileName"
         Write-Host
         return
       }
-	  
+
       Write-Host "Validating $FileName "
-      $Status = CountMissingSymbols "$InputPath\$FileName"
-  
-      if ($Status -ne 0) {
-	    Write-PipelineTaskError "Missing symbols for $Status modules in the package $FileName"
-		ExitWithExitCode $exitCode
+
+      Start-Job -ScriptBlock $CountMissingSymbols -ArgumentList $FullName | Out-Null
+
+      $NumJobs = @(Get-Job -State 'Running').Count
+
+      while ($NumJobs -ge $MaxParallelJobs) {
+        Write-Host "There are $NumJobs validation jobs running right now. Waiting $SecondsBetweenLoadChecks seconds to check again."
+        sleep $SecondsBetweenLoadChecks
+        $NumJobs = @(Get-Job -State 'Running').Count
       }
 
+      foreach ($Job in @(Get-Job -State 'Completed')) {
+        $jobResult = Wait-Job -Id $Job.Id | Receive-Job
+        CheckJobResult $jobResult.result $jobResult.packagePath ([ref]$DupedSymbols) ([ref]$TotalFailures)
+        Remove-Job -Id $Job.Id
+      }
       Write-Host
     }
+
+  foreach ($Job in @(Get-Job)) {
+    $jobResult = Wait-Job -Id $Job.Id | Receive-Job
+    CheckJobResult $jobResult.result $jobResult.packagePath ([ref]$DupedSymbols) ([ref]$TotalFailures)
+  }
+
+  if ($TotalFailures -gt 0 -or $DupedSymbols -gt 0) {
+    if ($TotalFailures -gt 0) {
+      Write-PipelineTelemetryError -Category 'CheckSymbols' -Message "Symbols missing for $TotalFailures packages"
+    }
+
+    if ($DupedSymbols -gt 0) {
+      Write-PipelineTelemetryError -Category 'CheckSymbols' -Message "$DupedSymbols packages had duplicated symbol files"
+    }
+    
+    ExitWithExitCode 1
+  }
+  else {
+    Write-Host "All symbols validated!"
+  }
 }
 
 function InstallDotnetSymbol {
-  $dotnetSymbolPackageName = "dotnet-symbol"
+  $dotnetSymbolPackageName = 'dotnet-symbol'
 
   $dotnetRoot = InitializeDotNetCli -install:$true
   $dotnet = "$dotnetRoot\dotnet.exe"
@@ -171,19 +245,24 @@ function InstallDotnetSymbol {
   }
   else {
     Write-Host "Installing dotnet-symbol version $dotnetSymbolVersion..."
-    Write-Host "You may need to restart your command window if this is the first dotnet tool you have installed."
+    Write-Host 'You may need to restart your command window if this is the first dotnet tool you have installed.'
     & "$dotnet" tool install $dotnetSymbolPackageName --version $dotnetSymbolVersion --verbosity "minimal" --global
   }
 }
 
 try {
+  . $PSScriptRoot\post-build-utils.ps1
+  
   InstallDotnetSymbol
 
+  foreach ($Job in @(Get-Job)) {
+    Remove-Job -Id $Job.Id
+  }
+
   CheckSymbolsAvailable
 }
 catch {
-  Write-Host $_
-  Write-Host $_.Exception
   Write-Host $_.ScriptStackTrace
+  Write-PipelineTelemetryError -Category 'CheckSymbols' -Message $_
   ExitWithExitCode 1
 }
diff --git a/eng/common/post-build/trigger-subscriptions.ps1 b/eng/common/post-build/trigger-subscriptions.ps1
index 926d5b45513..55dea518ac5 100644
--- a/eng/common/post-build/trigger-subscriptions.ps1
+++ b/eng/common/post-build/trigger-subscriptions.ps1
@@ -2,56 +2,63 @@ param(
   [Parameter(Mandatory=$true)][string] $SourceRepo,
   [Parameter(Mandatory=$true)][int] $ChannelId,
   [Parameter(Mandatory=$true)][string] $MaestroApiAccessToken,
-  [Parameter(Mandatory=$false)][string] $MaestroApiEndPoint = "https://maestro-prod.westus2.cloudapp.azure.com",
-  [Parameter(Mandatory=$false)][string] $MaestroApiVersion = "2019-01-16"
+  [Parameter(Mandatory=$false)][string] $MaestroApiEndPoint = 'https://maestro-prod.westus2.cloudapp.azure.com',
+  [Parameter(Mandatory=$false)][string] $MaestroApiVersion = '2019-01-16'
 )
 
-. $PSScriptRoot\post-build-utils.ps1
+try {
+  . $PSScriptRoot\post-build-utils.ps1
 
-# Get all the $SourceRepo subscriptions
-$normalizedSourceRepo = $SourceRepo.Replace('dnceng@', '')
-$subscriptions = Get-MaestroSubscriptions -SourceRepository $normalizedSourceRepo -ChannelId $ChannelId
+  # Get all the $SourceRepo subscriptions
+  $normalizedSourceRepo = $SourceRepo.Replace('dnceng@', '')
+  $subscriptions = Get-MaestroSubscriptions -SourceRepository $normalizedSourceRepo -ChannelId $ChannelId
 
-if (!$subscriptions) {
-  Write-Host "No subscriptions found for source repo '$normalizedSourceRepo' in channel '$ChannelId'"
-  ExitWithExitCode 0
-}
+  if (!$subscriptions) {
+    Write-PipelineTelemetryError -Category 'TriggerSubscriptions' -Message "No subscriptions found for source repo '$normalizedSourceRepo' in channel '$ChannelId'"
+    ExitWithExitCode 0
+  }
 
-$subscriptionsToTrigger = New-Object System.Collections.Generic.List[string]
-$failedTriggeredSubscription = $false
+  $subscriptionsToTrigger = New-Object System.Collections.Generic.List[string]
+  $failedTriggeredSubscription = $false
 
-# Get all enabled subscriptions that need dependency flow on 'everyBuild'
-foreach ($subscription in $subscriptions) {
-  if ($subscription.enabled -and $subscription.policy.updateFrequency -like 'everyBuild' -and $subscription.channel.id -eq $ChannelId) {
-    Write-Host "Should trigger this subscription: $subscription.id"
-    [void]$subscriptionsToTrigger.Add($subscription.id)
+  # Get all enabled subscriptions that need dependency flow on 'everyBuild'
+  foreach ($subscription in $subscriptions) {
+    if ($subscription.enabled -and $subscription.policy.updateFrequency -like 'everyBuild' -and $subscription.channel.id -eq $ChannelId) {
+      Write-Host "Should trigger this subscription: ${$subscription.id}"
+      [void]$subscriptionsToTrigger.Add($subscription.id)
+    }
   }
-}
 
-foreach ($subscriptionToTrigger in $subscriptionsToTrigger) {
-  try {
-    Write-Host "Triggering subscription '$subscriptionToTrigger'."
-
-    Trigger-Subscription -SubscriptionId $subscriptionToTrigger
-  
-    Write-Host "done."
-  } 
-  catch
-  {
-    Write-Host "There was an error while triggering subscription '$subscriptionToTrigger'"
-    Write-Host $_
-    Write-Host $_.ScriptStackTrace
-    $failedTriggeredSubscription = $true
+  foreach ($subscriptionToTrigger in $subscriptionsToTrigger) {
+    try {
+      Write-Host "Triggering subscription '$subscriptionToTrigger'."
+
+      Trigger-Subscription -SubscriptionId $subscriptionToTrigger
+    
+      Write-Host 'done.'
+    } 
+    catch
+    {
+      Write-Host "There was an error while triggering subscription '$subscriptionToTrigger'"
+      Write-Host $_
+      Write-Host $_.ScriptStackTrace
+      $failedTriggeredSubscription = $true
+    }
   }
-}
 
-if ($subscriptionsToTrigger.Count -eq 0) {
-  Write-Host "No subscription matched source repo '$normalizedSourceRepo' and channel ID '$ChannelId'."
+  if ($subscriptionsToTrigger.Count -eq 0) {
+    Write-Host "No subscription matched source repo '$normalizedSourceRepo' and channel ID '$ChannelId'."
+  }
+  elseif ($failedTriggeredSubscription) {
+    Write-PipelineTelemetryError -Category 'TriggerSubscriptions' -Message 'At least one subscription failed to be triggered...'
+    ExitWithExitCode 1
+  }
+  else {
+    Write-Host 'All subscriptions were triggered successfully!'
+  }
 }
-elseif ($failedTriggeredSubscription) {
-  Write-Host "At least one subscription failed to be triggered..."
+catch {
+  Write-Host $_.ScriptStackTrace
+  Write-PipelineTelemetryError -Category 'TriggerSubscriptions' -Message $_
   ExitWithExitCode 1
 }
-else {
-  Write-Host "All subscriptions were triggered successfully!"
-}
diff --git a/eng/common/sdk-task.ps1 b/eng/common/sdk-task.ps1
index d0eec5163ef..f55c43c6f47 100644
--- a/eng/common/sdk-task.ps1
+++ b/eng/common/sdk-task.ps1
@@ -1,8 +1,8 @@
 [CmdletBinding(PositionalBinding=$false)]
 Param(
-  [string] $configuration = "Debug",
+  [string] $configuration = 'Debug',
   [string] $task,
-  [string] $verbosity = "minimal",
+  [string] $verbosity = 'minimal',
   [string] $msbuildEngine = $null,
   [switch] $restore,
   [switch] $prepareMachine,
@@ -32,7 +32,7 @@ function Print-Usage() {
 }
 
 function Build([string]$target) {
-  $logSuffix = if ($target -eq "Execute") { "" } else { ".$target" }
+  $logSuffix = if ($target -eq 'Execute') { '' } else { ".$target" }
   $log = Join-Path $LogDir "$task$logSuffix.binlog"
   $outputPath = Join-Path $ToolsetDir "$task\\"
 
@@ -42,37 +42,55 @@ function Build([string]$target) {
     /p:Configuration=$configuration `
     /p:RepoRoot=$RepoRoot `
     /p:BaseIntermediateOutputPath=$outputPath `
+    /v:$verbosity `
     @properties
 }
 
 try {
-  if ($help -or (($null -ne $properties) -and ($properties.Contains("/help") -or $properties.Contains("/?")))) {
+  if ($help -or (($null -ne $properties) -and ($properties.Contains('/help') -or $properties.Contains('/?')))) {
     Print-Usage
     exit 0
   }
 
   if ($task -eq "") {
-    Write-Host "Missing required parameter '-task <value>'" -ForegroundColor Red
+    Write-PipelineTelemetryError -Category 'Build' -Message "Missing required parameter '-task <value>'" -ForegroundColor Red
     Print-Usage
     ExitWithExitCode 1
   }
 
+  if( $msbuildEngine -eq "vs") {
+    # Ensure desktop MSBuild is available for sdk tasks.
+    if( -not ($GlobalJson.tools.PSObject.Properties.Name -contains "vs" )) {
+      $GlobalJson.tools | Add-Member -Name "vs" -Value (ConvertFrom-Json "{ `"version`": `"16.5`" }") -MemberType NoteProperty
+    }
+    if( -not ($GlobalJson.tools.PSObject.Properties.Name -match "xcopy-msbuild" )) {
+      $GlobalJson.tools | Add-Member -Name "xcopy-msbuild" -Value "16.8.0-preview3" -MemberType NoteProperty
+    }
+    if ($GlobalJson.tools."xcopy-msbuild".Trim() -ine "none") {
+        $xcopyMSBuildToolsFolder = InitializeXCopyMSBuild $GlobalJson.tools."xcopy-msbuild" -install $true
+    }
+    if ($xcopyMSBuildToolsFolder -eq $null) {
+      throw 'Unable to get xcopy downloadable version of msbuild'
+    }
+
+    $global:_MSBuildExe = "$($xcopyMSBuildToolsFolder)\MSBuild\Current\Bin\MSBuild.exe"
+  }
+
   $taskProject = GetSdkTaskProject $task
   if (!(Test-Path $taskProject)) {
-    Write-Host "Unknown task: $task" -ForegroundColor Red
+    Write-PipelineTelemetryError -Category 'Build' -Message "Unknown task: $task" -ForegroundColor Red
     ExitWithExitCode 1
   }
 
   if ($restore) {
-    Build "Restore"
+    Build 'Restore'
   }
 
-  Build "Execute"
+  Build 'Execute'
 }
 catch {
-  Write-Host $_
-  Write-Host $_.Exception
   Write-Host $_.ScriptStackTrace
+  Write-PipelineTelemetryError -Category 'Build' -Message $_
   ExitWithExitCode 1
 }
 
diff --git a/eng/common/sdl/execute-all-sdl-tools.ps1 b/eng/common/sdl/execute-all-sdl-tools.ps1
index 01799d63ff3..b681d797cda 100644
--- a/eng/common/sdl/execute-all-sdl-tools.ps1
+++ b/eng/common/sdl/execute-all-sdl-tools.ps1
@@ -1,100 +1,120 @@
 Param(
-  [string] $GuardianPackageName,                                                           # Required: the name of guardian CLI package (not needed if GuardianCliLocation is specified)
-  [string] $NugetPackageDirectory,                                                         # Required: directory where NuGet packages are installed (not needed if GuardianCliLocation is specified)
-  [string] $GuardianCliLocation,                                                           # Optional: Direct location of Guardian CLI executable if GuardianPackageName & NugetPackageDirectory are not specified
-  [string] $Repository=$env:BUILD_REPOSITORY_NAME,                                         # Required: the name of the repository (e.g. dotnet/arcade)
-  [string] $BranchName=$env:BUILD_SOURCEBRANCH,                                            # Optional: name of branch or version of gdn settings; defaults to master
-  [string] $SourceDirectory=$env:BUILD_SOURCESDIRECTORY,                                   # Required: the directory where source files are located
-  [string] $ArtifactsDirectory = (Join-Path $env:BUILD_SOURCESDIRECTORY ("artifacts")),    # Required: the directory where build artifacts are located
-  [string] $AzureDevOpsAccessToken,                                                        # Required: access token for dnceng; should be provided via KeyVault
-  [string[]] $SourceToolsList,                                                             # Optional: list of SDL tools to run on source code
-  [string[]] $ArtifactToolsList,                                                           # Optional: list of SDL tools to run on built artifacts
-  [bool] $TsaPublish=$False,                                                               # Optional: true will publish results to TSA; only set to true after onboarding to TSA; TSA is the automated framework used to upload test results as bugs.
-  [string] $TsaBranchName=$env:BUILD_SOURCEBRANCH,                                         # Optional: required for TSA publish; defaults to $(Build.SourceBranchName); TSA is the automated framework used to upload test results as bugs.
-  [string] $TsaRepositoryName=$env:BUILD_REPOSITORY_NAME,                                  # Optional: TSA repository name; will be generated automatically if not submitted; TSA is the automated framework used to upload test results as bugs.
-  [string] $BuildNumber=$env:BUILD_BUILDNUMBER,                                            # Optional: required for TSA publish; defaults to $(Build.BuildNumber)
-  [bool] $UpdateBaseline=$False,                                                           # Optional: if true, will update the baseline in the repository; should only be run after fixing any issues which need to be fixed
-  [bool] $TsaOnboard=$False,                                                               # Optional: if true, will onboard the repository to TSA; should only be run once; TSA is the automated framework used to upload test results as bugs.
-  [string] $TsaInstanceUrl,                                                                # Optional: only needed if TsaOnboard or TsaPublish is true; the instance-url registered with TSA; TSA is the automated framework used to upload test results as bugs.
-  [string] $TsaCodebaseName,                                                               # Optional: only needed if TsaOnboard or TsaPublish is true; the name of the codebase registered with TSA; TSA is the automated framework used to upload test results as bugs.
-  [string] $TsaProjectName,                                                                # Optional: only needed if TsaOnboard or TsaPublish is true; the name of the project registered with TSA; TSA is the automated framework used to upload test results as bugs.
-  [string] $TsaNotificationEmail,                                                          # Optional: only needed if TsaOnboard is true; the email(s) which will receive notifications of TSA bug filings (e.g. alias@microsoft.com); TSA is the automated framework used to upload test results as bugs.
-  [string] $TsaCodebaseAdmin,                                                              # Optional: only needed if TsaOnboard is true; the aliases which are admins of the TSA codebase (e.g. DOMAIN\alias); TSA is the automated framework used to upload test results as bugs.
-  [string] $TsaBugAreaPath,                                                                # Optional: only needed if TsaOnboard is true; the area path where TSA will file bugs in AzDO; TSA is the automated framework used to upload test results as bugs.
-  [string] $TsaIterationPath,                                                              # Optional: only needed if TsaOnboard is true; the iteration path where TSA will file bugs in AzDO; TSA is the automated framework used to upload test results as bugs.
-  [string] $GuardianLoggerLevel="Standard",                                                # Optional: the logger level for the Guardian CLI; options are Trace, Verbose, Standard, Warning, and Error
-  [string[]] $CrScanAdditionalRunConfigParams,                                             # Optional: Additional Params to custom build a CredScan run config in the format @("xyz:abc","sdf:1")
-  [string[]] $PoliCheckAdditionalRunConfigParams                                           # Optional: Additional Params to custom build a Policheck run config in the format @("xyz:abc","sdf:1")
+  [string] $GuardianPackageName,                                                                 # Required: the name of guardian CLI package (not needed if GuardianCliLocation is specified)
+  [string] $NugetPackageDirectory,                                                               # Required: directory where NuGet packages are installed (not needed if GuardianCliLocation is specified)
+  [string] $GuardianCliLocation,                                                                 # Optional: Direct location of Guardian CLI executable if GuardianPackageName & NugetPackageDirectory are not specified
+  [string] $Repository=$env:BUILD_REPOSITORY_NAME,                                               # Required: the name of the repository (e.g. dotnet/arcade)
+  [string] $BranchName=$env:BUILD_SOURCEBRANCH,                                                  # Optional: name of branch or version of gdn settings; defaults to master
+  [string] $SourceDirectory=$env:BUILD_SOURCESDIRECTORY,                                         # Required: the directory where source files are located
+  [string] $ArtifactsDirectory = (Join-Path $env:BUILD_ARTIFACTSTAGINGDIRECTORY ('artifacts')),  # Required: the directory where build artifacts are located
+  [string] $AzureDevOpsAccessToken,                                                              # Required: access token for dnceng; should be provided via KeyVault
+  [string[]] $SourceToolsList,                                                                   # Optional: list of SDL tools to run on source code
+  [string[]] $ArtifactToolsList,                                                                 # Optional: list of SDL tools to run on built artifacts
+  [bool] $TsaPublish=$False,                                                                     # Optional: true will publish results to TSA; only set to true after onboarding to TSA; TSA is the automated framework used to upload test results as bugs.
+  [string] $TsaBranchName=$env:BUILD_SOURCEBRANCH,                                               # Optional: required for TSA publish; defaults to $(Build.SourceBranchName); TSA is the automated framework used to upload test results as bugs.
+  [string] $TsaRepositoryName=$env:BUILD_REPOSITORY_NAME,                                        # Optional: TSA repository name; will be generated automatically if not submitted; TSA is the automated framework used to upload test results as bugs.
+  [string] $BuildNumber=$env:BUILD_BUILDNUMBER,                                                  # Optional: required for TSA publish; defaults to $(Build.BuildNumber)
+  [bool] $UpdateBaseline=$False,                                                                 # Optional: if true, will update the baseline in the repository; should only be run after fixing any issues which need to be fixed
+  [bool] $TsaOnboard=$False,                                                                     # Optional: if true, will onboard the repository to TSA; should only be run once; TSA is the automated framework used to upload test results as bugs.
+  [string] $TsaInstanceUrl,                                                                      # Optional: only needed if TsaOnboard or TsaPublish is true; the instance-url registered with TSA; TSA is the automated framework used to upload test results as bugs.
+  [string] $TsaCodebaseName,                                                                     # Optional: only needed if TsaOnboard or TsaPublish is true; the name of the codebase registered with TSA; TSA is the automated framework used to upload test results as bugs.
+  [string] $TsaProjectName,                                                                      # Optional: only needed if TsaOnboard or TsaPublish is true; the name of the project registered with TSA; TSA is the automated framework used to upload test results as bugs.
+  [string] $TsaNotificationEmail,                                                                # Optional: only needed if TsaOnboard is true; the email(s) which will receive notifications of TSA bug filings (e.g. alias@microsoft.com); TSA is the automated framework used to upload test results as bugs.
+  [string] $TsaCodebaseAdmin,                                                                    # Optional: only needed if TsaOnboard is true; the aliases which are admins of the TSA codebase (e.g. DOMAIN\alias); TSA is the automated framework used to upload test results as bugs.
+  [string] $TsaBugAreaPath,                                                                      # Optional: only needed if TsaOnboard is true; the area path where TSA will file bugs in AzDO; TSA is the automated framework used to upload test results as bugs.
+  [string] $TsaIterationPath,                                                                    # Optional: only needed if TsaOnboard is true; the iteration path where TSA will file bugs in AzDO; TSA is the automated framework used to upload test results as bugs.
+  [string] $GuardianLoggerLevel='Standard',                                                      # Optional: the logger level for the Guardian CLI; options are Trace, Verbose, Standard, Warning, and Error
+  [string[]] $CrScanAdditionalRunConfigParams,                                                   # Optional: Additional Params to custom build a CredScan run config in the format @("xyz:abc","sdf:1")
+  [string[]] $PoliCheckAdditionalRunConfigParams,                                                # Optional: Additional Params to custom build a Policheck run config in the format @("xyz:abc","sdf:1")
+  [bool] $BreakOnFailure=$False                                                                  # Optional: Fail the build if there were errors during the run
 )
 
-$ErrorActionPreference = "Stop"
-Set-StrictMode -Version 2.0
-$LASTEXITCODE = 0
+try {
+  $ErrorActionPreference = 'Stop'
+  Set-StrictMode -Version 2.0
+  $disableConfigureToolsetImport = $true
+  $LASTEXITCODE = 0
 
-#Replace repo names to the format of org/repo
-if (!($Repository.contains('/'))) {
-  $RepoName = $Repository -replace '(.*?)-(.*)', '$1/$2';
-}
-else{
-  $RepoName = $Repository;
-}
+  # `tools.ps1` checks $ci to perform some actions. Since the SDL
+  # scripts don't necessarily execute in the same agent that run the
+  # build.ps1/sh script this variable isn't automatically set.
+  $ci = $true
+  . $PSScriptRoot\..\tools.ps1
 
-if ($GuardianPackageName) {
-  $guardianCliLocation = Join-Path $NugetPackageDirectory (Join-Path $GuardianPackageName (Join-Path "tools" "guardian.cmd"))
-} else {
-  $guardianCliLocation = $GuardianCliLocation
-}
+  #Replace repo names to the format of org/repo
+  if (!($Repository.contains('/'))) {
+    $RepoName = $Repository -replace '(.*?)-(.*)', '$1/$2';
+  }
+  else{
+    $RepoName = $Repository;
+  }
 
-$workingDirectory = (Split-Path $SourceDirectory -Parent)
-$ValidPath = Test-Path $guardianCliLocation
+  if ($GuardianPackageName) {
+    $guardianCliLocation = Join-Path $NugetPackageDirectory (Join-Path $GuardianPackageName (Join-Path 'tools' 'guardian.cmd'))
+  } else {
+    $guardianCliLocation = $GuardianCliLocation
+  }
 
-if ($ValidPath -eq $False)
-{
-  Write-Host "Invalid Guardian CLI Location."
-  exit 1
-}
+  $workingDirectory = (Split-Path $SourceDirectory -Parent)
+  $ValidPath = Test-Path $guardianCliLocation
+
+  if ($ValidPath -eq $False)
+  {
+    Write-PipelineTelemetryError -Force -Category 'Sdl' -Message 'Invalid Guardian CLI Location.'
+    ExitWithExitCode 1
+  }
 
-& $(Join-Path $PSScriptRoot "init-sdl.ps1") -GuardianCliLocation $guardianCliLocation -Repository $RepoName -BranchName $BranchName -WorkingDirectory $workingDirectory -AzureDevOpsAccessToken $AzureDevOpsAccessToken -GuardianLoggerLevel $GuardianLoggerLevel
-$gdnFolder = Join-Path $workingDirectory ".gdn"
+  & $(Join-Path $PSScriptRoot 'init-sdl.ps1') -GuardianCliLocation $guardianCliLocation -Repository $RepoName -BranchName $BranchName -WorkingDirectory $workingDirectory -AzureDevOpsAccessToken $AzureDevOpsAccessToken -GuardianLoggerLevel $GuardianLoggerLevel
+  $gdnFolder = Join-Path $workingDirectory '.gdn'
 
-if ($TsaOnboard) {
-  if ($TsaCodebaseName -and $TsaNotificationEmail -and $TsaCodebaseAdmin -and $TsaBugAreaPath) {
-    Write-Host "$guardianCliLocation tsa-onboard --codebase-name `"$TsaCodebaseName`" --notification-alias `"$TsaNotificationEmail`" --codebase-admin `"$TsaCodebaseAdmin`" --instance-url `"$TsaInstanceUrl`" --project-name `"$TsaProjectName`" --area-path `"$TsaBugAreaPath`" --iteration-path `"$TsaIterationPath`" --working-directory $workingDirectory --logger-level $GuardianLoggerLevel"
-    & $guardianCliLocation tsa-onboard --codebase-name "$TsaCodebaseName" --notification-alias "$TsaNotificationEmail" --codebase-admin "$TsaCodebaseAdmin" --instance-url "$TsaInstanceUrl" --project-name "$TsaProjectName" --area-path "$TsaBugAreaPath" --iteration-path "$TsaIterationPath" --working-directory $workingDirectory --logger-level $GuardianLoggerLevel
-    if ($LASTEXITCODE -ne 0) {
-      Write-Host "Guardian tsa-onboard failed with exit code $LASTEXITCODE."
-      exit $LASTEXITCODE
+  if ($TsaOnboard) {
+    if ($TsaCodebaseName -and $TsaNotificationEmail -and $TsaCodebaseAdmin -and $TsaBugAreaPath) {
+      Write-Host "$guardianCliLocation tsa-onboard --codebase-name `"$TsaCodebaseName`" --notification-alias `"$TsaNotificationEmail`" --codebase-admin `"$TsaCodebaseAdmin`" --instance-url `"$TsaInstanceUrl`" --project-name `"$TsaProjectName`" --area-path `"$TsaBugAreaPath`" --iteration-path `"$TsaIterationPath`" --working-directory $workingDirectory --logger-level $GuardianLoggerLevel"
+      & $guardianCliLocation tsa-onboard --codebase-name "$TsaCodebaseName" --notification-alias "$TsaNotificationEmail" --codebase-admin "$TsaCodebaseAdmin" --instance-url "$TsaInstanceUrl" --project-name "$TsaProjectName" --area-path "$TsaBugAreaPath" --iteration-path "$TsaIterationPath" --working-directory $workingDirectory --logger-level $GuardianLoggerLevel
+      if ($LASTEXITCODE -ne 0) {
+        Write-PipelineTelemetryError -Force -Category 'Sdl' -Message "Guardian tsa-onboard failed with exit code $LASTEXITCODE."
+        ExitWithExitCode $LASTEXITCODE
+      }
+    } else {
+      Write-PipelineTelemetryError -Force -Category 'Sdl' -Message 'Could not onboard to TSA -- not all required values ($TsaCodebaseName, $TsaNotificationEmail, $TsaCodebaseAdmin, $TsaBugAreaPath) were specified.'
+      ExitWithExitCode 1
     }
-  } else {
-    Write-Host "Could not onboard to TSA -- not all required values ($$TsaCodebaseName, $$TsaNotificationEmail, $$TsaCodebaseAdmin, $$TsaBugAreaPath) were specified."
-    exit 1
   }
-}
 
-if ($ArtifactToolsList -and $ArtifactToolsList.Count -gt 0) {
-  & $(Join-Path $PSScriptRoot "run-sdl.ps1") -GuardianCliLocation $guardianCliLocation -WorkingDirectory $workingDirectory -TargetDirectory $ArtifactsDirectory -GdnFolder $gdnFolder -ToolsList $ArtifactToolsList -AzureDevOpsAccessToken $AzureDevOpsAccessToken -UpdateBaseline $UpdateBaseline -GuardianLoggerLevel $GuardianLoggerLevel -CrScanAdditionalRunConfigParams $CrScanAdditionalRunConfigParams -PoliCheckAdditionalRunConfigParams $PoliCheckAdditionalRunConfigParams
-}
-if ($SourceToolsList -and $SourceToolsList.Count -gt 0) {
-  & $(Join-Path $PSScriptRoot "run-sdl.ps1") -GuardianCliLocation $guardianCliLocation -WorkingDirectory $workingDirectory -TargetDirectory $SourceDirectory -GdnFolder $gdnFolder -ToolsList $SourceToolsList -AzureDevOpsAccessToken $AzureDevOpsAccessToken -UpdateBaseline $UpdateBaseline -GuardianLoggerLevel $GuardianLoggerLevel -CrScanAdditionalRunConfigParams $CrScanAdditionalRunConfigParams -PoliCheckAdditionalRunConfigParams $PoliCheckAdditionalRunConfigParams
-}
+  if ($ArtifactToolsList -and $ArtifactToolsList.Count -gt 0) {
+    & $(Join-Path $PSScriptRoot 'run-sdl.ps1') -GuardianCliLocation $guardianCliLocation -WorkingDirectory $workingDirectory -TargetDirectory $ArtifactsDirectory -GdnFolder $gdnFolder -ToolsList $ArtifactToolsList -AzureDevOpsAccessToken $AzureDevOpsAccessToken -UpdateBaseline $UpdateBaseline -GuardianLoggerLevel $GuardianLoggerLevel -CrScanAdditionalRunConfigParams $CrScanAdditionalRunConfigParams -PoliCheckAdditionalRunConfigParams $PoliCheckAdditionalRunConfigParams
+  }
+  if ($SourceToolsList -and $SourceToolsList.Count -gt 0) {
+    & $(Join-Path $PSScriptRoot 'run-sdl.ps1') -GuardianCliLocation $guardianCliLocation -WorkingDirectory $workingDirectory -TargetDirectory $SourceDirectory -GdnFolder $gdnFolder -ToolsList $SourceToolsList -AzureDevOpsAccessToken $AzureDevOpsAccessToken -UpdateBaseline $UpdateBaseline -GuardianLoggerLevel $GuardianLoggerLevel -CrScanAdditionalRunConfigParams $CrScanAdditionalRunConfigParams -PoliCheckAdditionalRunConfigParams $PoliCheckAdditionalRunConfigParams
+  }
 
-if ($UpdateBaseline) {
-  & (Join-Path $PSScriptRoot "push-gdn.ps1") -Repository $RepoName -BranchName $BranchName -GdnFolder $GdnFolder -AzureDevOpsAccessToken $AzureDevOpsAccessToken -PushReason "Update baseline"
-}
+  if ($UpdateBaseline) {
+    & (Join-Path $PSScriptRoot 'push-gdn.ps1') -Repository $RepoName -BranchName $BranchName -GdnFolder $GdnFolder -AzureDevOpsAccessToken $AzureDevOpsAccessToken -PushReason 'Update baseline'
+  }
 
-if ($TsaPublish) {
-  if ($TsaBranchName -and $BuildNumber) {
-    if (-not $TsaRepositoryName) {
-      $TsaRepositoryName = "$($Repository)-$($BranchName)"
+  if ($TsaPublish) {
+    if ($TsaBranchName -and $BuildNumber) {
+      if (-not $TsaRepositoryName) {
+        $TsaRepositoryName = "$($Repository)-$($BranchName)"
+      }
+      Write-Host "$guardianCliLocation tsa-publish --all-tools --repository-name `"$TsaRepositoryName`" --branch-name `"$TsaBranchName`" --build-number `"$BuildNumber`" --codebase-name `"$TsaCodebaseName`" --notification-alias `"$TsaNotificationEmail`" --codebase-admin `"$TsaCodebaseAdmin`" --instance-url `"$TsaInstanceUrl`" --project-name `"$TsaProjectName`" --area-path `"$TsaBugAreaPath`" --iteration-path `"$TsaIterationPath`" --working-directory $workingDirectory --logger-level $GuardianLoggerLevel"
+      & $guardianCliLocation tsa-publish --all-tools --repository-name "$TsaRepositoryName" --branch-name "$TsaBranchName" --build-number "$BuildNumber" --onboard $True --codebase-name "$TsaCodebaseName" --notification-alias "$TsaNotificationEmail" --codebase-admin "$TsaCodebaseAdmin" --instance-url "$TsaInstanceUrl" --project-name "$TsaProjectName" --area-path "$TsaBugAreaPath" --iteration-path "$TsaIterationPath" --working-directory $workingDirectory  --logger-level $GuardianLoggerLevel
+      if ($LASTEXITCODE -ne 0) {
+        Write-PipelineTelemetryError -Force -Category 'Sdl' -Message "Guardian tsa-publish failed with exit code $LASTEXITCODE."
+        ExitWithExitCode $LASTEXITCODE
+      }
+    } else {
+      Write-PipelineTelemetryError -Force -Category 'Sdl' -Message 'Could not publish to TSA -- not all required values ($TsaBranchName, $BuildNumber) were specified.'
+      ExitWithExitCode 1
     }
-    Write-Host "$guardianCliLocation tsa-publish --all-tools --repository-name `"$TsaRepositoryName`" --branch-name `"$TsaBranchName`" --build-number `"$BuildNumber`" --codebase-name `"$TsaCodebaseName`" --notification-alias `"$TsaNotificationEmail`" --codebase-admin `"$TsaCodebaseAdmin`" --instance-url `"$TsaInstanceUrl`" --project-name `"$TsaProjectName`" --area-path `"$TsaBugAreaPath`" --iteration-path `"$TsaIterationPath`" --working-directory $workingDirectory --logger-level $GuardianLoggerLevel"
-    & $guardianCliLocation tsa-publish --all-tools --repository-name "$TsaRepositoryName" --branch-name "$TsaBranchName" --build-number "$BuildNumber" --onboard $True --codebase-name "$TsaCodebaseName" --notification-alias "$TsaNotificationEmail" --codebase-admin "$TsaCodebaseAdmin" --instance-url "$TsaInstanceUrl" --project-name "$TsaProjectName" --area-path "$TsaBugAreaPath" --iteration-path "$TsaIterationPath" --working-directory $workingDirectory  --logger-level $GuardianLoggerLevel
-    if ($LASTEXITCODE -ne 0) {
-      Write-Host "Guardian tsa-publish failed with exit code $LASTEXITCODE."
-      exit $LASTEXITCODE
-    }
-  } else {
-    Write-Host "Could not publish to TSA -- not all required values ($$TsaBranchName, $$BuildNumber) were specified."
-    exit 1
   }
+
+  if ($BreakOnFailure) {
+    Write-Host "Failing the build in case of breaking results..."
+    & $guardianCliLocation break
+  }
+}
+catch {
+  Write-Host $_.ScriptStackTrace
+  Write-PipelineTelemetryError -Force -Category 'Sdl' -Message $_
+  exit 1
 }
diff --git a/eng/common/sdl/extract-artifact-packages.ps1 b/eng/common/sdl/extract-artifact-packages.ps1
index 6e6825013bf..7f28d9c59ec 100644
--- a/eng/common/sdl/extract-artifact-packages.ps1
+++ b/eng/common/sdl/extract-artifact-packages.ps1
@@ -3,54 +3,12 @@ param(
   [Parameter(Mandatory=$true)][string] $ExtractPath            # Full path to directory where the packages will be extracted
 )
 
-$ErrorActionPreference = "Stop"
+$ErrorActionPreference = 'Stop'
 Set-StrictMode -Version 2.0
 
-# `tools.ps1` checks $ci to perform some actions. Since the post-build
-# scripts don't necessarily execute in the same agent that run the
-# build.ps1/sh script this variable isn't automatically set.
-$ci = $true
-. $PSScriptRoot\..\tools.ps1
+$disableConfigureToolsetImport = $true
 
-$ExtractPackage = {
-  param( 
-    [string] $PackagePath                                 # Full path to a NuGet package
-  )
-  
-  if (!(Test-Path $PackagePath)) {
-    Write-PipelineTaskError "Input file does not exist: $PackagePath"
-    ExitWithExitCode 1
-  }
-  
-  $RelevantExtensions = @(".dll", ".exe", ".pdb")
-  Write-Host -NoNewLine "Extracting" ([System.IO.Path]::GetFileName($PackagePath)) "... "
-
-  $PackageId = [System.IO.Path]::GetFileNameWithoutExtension($PackagePath)
-  $ExtractPath = Join-Path -Path $using:ExtractPath -ChildPath $PackageId
-
-  Add-Type -AssemblyName System.IO.Compression.FileSystem
-
-  [System.IO.Directory]::CreateDirectory($ExtractPath);
-
-  try {
-    $zip = [System.IO.Compression.ZipFile]::OpenRead($PackagePath)
-
-    $zip.Entries | 
-    Where-Object {$RelevantExtensions -contains [System.IO.Path]::GetExtension($_.Name)} |
-      ForEach-Object {
-          $TargetFile = Join-Path -Path $ExtractPath -ChildPath $_.Name
-
-          [System.IO.Compression.ZipFileExtensions]::ExtractToFile($_, $TargetFile, $true)
-        }
-  }
-  catch {
-  
-  }
-  finally {
-    $zip.Dispose() 
-  }
- }
- function ExtractArtifacts {
+function ExtractArtifacts {
   if (!(Test-Path $InputPath)) {
     Write-Host "Input Path does not exist: $InputPath"
     ExitWithExitCode 0
@@ -67,11 +25,56 @@ $ExtractPackage = {
 }
 
 try {
+  # `tools.ps1` checks $ci to perform some actions. Since the SDL
+  # scripts don't necessarily execute in the same agent that run the
+  # build.ps1/sh script this variable isn't automatically set.
+  $ci = $true
+  . $PSScriptRoot\..\tools.ps1
+
+  $ExtractPackage = {
+    param( 
+      [string] $PackagePath                                 # Full path to a NuGet package
+    )
+    
+    if (!(Test-Path $PackagePath)) {
+      Write-PipelineTelemetryError -Category 'Build' -Message "Input file does not exist: $PackagePath"
+      ExitWithExitCode 1
+    }
+    
+    $RelevantExtensions = @('.dll', '.exe', '.pdb')
+    Write-Host -NoNewLine 'Extracting ' ([System.IO.Path]::GetFileName($PackagePath)) '...'
+  
+    $PackageId = [System.IO.Path]::GetFileNameWithoutExtension($PackagePath)
+    $ExtractPath = Join-Path -Path $using:ExtractPath -ChildPath $PackageId
+  
+    Add-Type -AssemblyName System.IO.Compression.FileSystem
+  
+    [System.IO.Directory]::CreateDirectory($ExtractPath);
+  
+    try {
+      $zip = [System.IO.Compression.ZipFile]::OpenRead($PackagePath)
+  
+      $zip.Entries | 
+      Where-Object {$RelevantExtensions -contains [System.IO.Path]::GetExtension($_.Name)} |
+        ForEach-Object {
+            $TargetFile = Join-Path -Path $ExtractPath -ChildPath $_.Name
+  
+            [System.IO.Compression.ZipFileExtensions]::ExtractToFile($_, $TargetFile, $true)
+          }
+    }
+    catch {
+      Write-Host $_
+      Write-PipelineTelemetryError -Force -Category 'Sdl' -Message $_
+      ExitWithExitCode 1
+    }
+    finally {
+      $zip.Dispose() 
+    }
+  }
   Measure-Command { ExtractArtifacts }
 }
 catch {
   Write-Host $_
-  Write-Host $_.Exception
-  Write-Host $_.ScriptStackTrace
+  Write-PipelineTelemetryError -Force -Category 'Sdl' -Message $_
   ExitWithExitCode 1
 }
diff --git a/eng/common/sdl/init-sdl.ps1 b/eng/common/sdl/init-sdl.ps1
index c737eb0e71c..bb6a4297110 100644
--- a/eng/common/sdl/init-sdl.ps1
+++ b/eng/common/sdl/init-sdl.ps1
@@ -1,51 +1,56 @@
 Param(
   [string] $GuardianCliLocation,
   [string] $Repository,
-  [string] $BranchName="master",
+  [string] $BranchName='master',
   [string] $WorkingDirectory,
   [string] $AzureDevOpsAccessToken,
-  [string] $GuardianLoggerLevel="Standard"
+  [string] $GuardianLoggerLevel='Standard'
 )
 
-$ErrorActionPreference = "Stop"
+$ErrorActionPreference = 'Stop'
 Set-StrictMode -Version 2.0
+$disableConfigureToolsetImport = $true
 $LASTEXITCODE = 0
 
+# `tools.ps1` checks $ci to perform some actions. Since the SDL
+# scripts don't necessarily execute in the same agent that run the
+# build.ps1/sh script this variable isn't automatically set.
+$ci = $true
+. $PSScriptRoot\..\tools.ps1
+
 # Don't display the console progress UI - it's a huge perf hit
 $ProgressPreference = 'SilentlyContinue'
 
 # Construct basic auth from AzDO access token; construct URI to the repository's gdn folder stored in that repository; construct location of zip file
 $encodedPat = [Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes(":$AzureDevOpsAccessToken"))
 $escapedRepository = [Uri]::EscapeDataString("/$Repository/$BranchName/.gdn")
-$uri = "https://dev.azure.com/dnceng/internal/_apis/git/repositories/sdl-tool-cfg/Items?path=$escapedRepository&versionDescriptor[versionOptions]=0&`$format=zip&api-version=5.0-preview.1"
+$uri = "https://dev.azure.com/dnceng/internal/_apis/git/repositories/sdl-tool-cfg/Items?path=$escapedRepository&versionDescriptor[versionOptions]=0&`$format=zip&api-version=5.0"
 $zipFile = "$WorkingDirectory/gdn.zip"
 
 Add-Type -AssemblyName System.IO.Compression.FileSystem
-$gdnFolder = (Join-Path $WorkingDirectory ".gdn")
-Try
-{
-  # We try to download the zip; if the request fails (e.g. the file doesn't exist), we catch it and init guardian instead
-  Write-Host "Downloading gdn folder from internal config repostiory..."
-  Invoke-WebRequest -Headers @{ "Accept"="application/zip"; "Authorization"="Basic $encodedPat" } -Uri $uri -OutFile $zipFile
-  if (Test-Path $gdnFolder) {
-    # Remove the gdn folder if it exists (it shouldn't unless there's too much caching; this is just in case)
-    Remove-Item -Force -Recurse $gdnFolder
-  }
-  [System.IO.Compression.ZipFile]::ExtractToDirectory($zipFile, $WorkingDirectory)
-  Write-Host $gdnFolder
-} Catch [System.Net.WebException] {
+$gdnFolder = (Join-Path $WorkingDirectory '.gdn')
+
+try {
   # if the folder does not exist, we'll do a guardian init and push it to the remote repository
-  Write-Host "Initializing Guardian..."
+  Write-Host 'Initializing Guardian...'
   Write-Host "$GuardianCliLocation init --working-directory $WorkingDirectory --logger-level $GuardianLoggerLevel"
   & $GuardianCliLocation init --working-directory $WorkingDirectory --logger-level $GuardianLoggerLevel
   if ($LASTEXITCODE -ne 0) {
-    Write-Error "Guardian init failed with exit code $LASTEXITCODE."
+    Write-PipelineTelemetryError -Force -Category 'Build' -Message "Guardian init failed with exit code $LASTEXITCODE."
+    ExitWithExitCode $LASTEXITCODE
   }
   # We create the mainbaseline so it can be edited later
   Write-Host "$GuardianCliLocation baseline --working-directory $WorkingDirectory --name mainbaseline"
   & $GuardianCliLocation baseline --working-directory $WorkingDirectory --name mainbaseline
   if ($LASTEXITCODE -ne 0) {
-    Write-Error "Guardian baseline failed with exit code $LASTEXITCODE."
+    Write-PipelineTelemetryError -Force -Category 'Build' -Message "Guardian baseline failed with exit code $LASTEXITCODE."
+    ExitWithExitCode $LASTEXITCODE
   }
-  & $(Join-Path $PSScriptRoot "push-gdn.ps1") -Repository $Repository -BranchName $BranchName -GdnFolder $gdnFolder -AzureDevOpsAccessToken $AzureDevOpsAccessToken -PushReason "Initialize gdn folder"
-}
\ No newline at end of file
+  & $(Join-Path $PSScriptRoot 'push-gdn.ps1') -Repository $Repository -BranchName $BranchName -GdnFolder $gdnFolder -AzureDevOpsAccessToken $AzureDevOpsAccessToken -PushReason 'Initialize gdn folder'
+  ExitWithExitCode 0
+}
+catch {
+  Write-Host $_.ScriptStackTrace
+  Write-PipelineTelemetryError -Force -Category 'Sdl' -Message $_
+  ExitWithExitCode 1
+}
diff --git a/eng/common/sdl/packages.config b/eng/common/sdl/packages.config
index 968b39bef5f..3bd8b29ebd7 100644
--- a/eng/common/sdl/packages.config
+++ b/eng/common/sdl/packages.config
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="utf-8"?>
 <packages>
-  <package id="Microsoft.Guardian.Cli.win10-x64" version="0.20.1"/>
+  <package id="Microsoft.Guardian.Cli" version="0.53.3"/>
 </packages>
diff --git a/eng/common/sdl/push-gdn.ps1 b/eng/common/sdl/push-gdn.ps1
index 79c707d6d8a..d8fd2d82a68 100644
--- a/eng/common/sdl/push-gdn.ps1
+++ b/eng/common/sdl/push-gdn.ps1
@@ -1,51 +1,69 @@
 Param(
   [string] $Repository,
-  [string] $BranchName="master",
+  [string] $BranchName='master',
   [string] $GdnFolder,
   [string] $AzureDevOpsAccessToken,
   [string] $PushReason
 )
 
-$ErrorActionPreference = "Stop"
+$ErrorActionPreference = 'Stop'
 Set-StrictMode -Version 2.0
+$disableConfigureToolsetImport = $true
 $LASTEXITCODE = 0
 
-# We create the temp directory where we'll store the sdl-config repository
-$sdlDir = Join-Path $env:TEMP "sdl"
-if (Test-Path $sdlDir) {
-  Remove-Item -Force -Recurse $sdlDir
-}
+try {
+  # `tools.ps1` checks $ci to perform some actions. Since the SDL
+  # scripts don't necessarily execute in the same agent that run the
+  # build.ps1/sh script this variable isn't automatically set.
+  $ci = $true
+  . $PSScriptRoot\..\tools.ps1
 
-Write-Host "git clone https://dnceng:`$AzureDevOpsAccessToken@dev.azure.com/dnceng/internal/_git/sdl-tool-cfg $sdlDir"
-git clone https://dnceng:$AzureDevOpsAccessToken@dev.azure.com/dnceng/internal/_git/sdl-tool-cfg $sdlDir
-if ($LASTEXITCODE -ne 0) {
-  Write-Error "Git clone failed with exit code $LASTEXITCODE."
-}
-# We copy the .gdn folder from our local run into the git repository so it can be committed
-$sdlRepositoryFolder = Join-Path (Join-Path (Join-Path $sdlDir $Repository) $BranchName) ".gdn"
-if (Get-Command Robocopy) {
-  Robocopy /S $GdnFolder $sdlRepositoryFolder
-} else {
-  rsync -r $GdnFolder $sdlRepositoryFolder
-}
-# cd to the sdl-config directory so we can run git there
-Push-Location $sdlDir
-# git add . --> git commit --> git push
-Write-Host "git add ."
-git add .
-if ($LASTEXITCODE -ne 0) {
-  Write-Error "Git add failed with exit code $LASTEXITCODE."
-}
-Write-Host "git -c user.email=`"dn-bot@microsoft.com`" -c user.name=`"Dotnet Bot`" commit -m `"$PushReason for $Repository/$BranchName`""
-git -c user.email="dn-bot@microsoft.com" -c user.name="Dotnet Bot" commit -m "$PushReason for $Repository/$BranchName"
-if ($LASTEXITCODE -ne 0) {
-  Write-Error "Git commit failed with exit code $LASTEXITCODE."
+  # We create the temp directory where we'll store the sdl-config repository
+  $sdlDir = Join-Path $env:TEMP 'sdl'
+  if (Test-Path $sdlDir) {
+    Remove-Item -Force -Recurse $sdlDir
+  }
+
+  Write-Host "git clone https://dnceng:`$AzureDevOpsAccessToken@dev.azure.com/dnceng/internal/_git/sdl-tool-cfg $sdlDir"
+  git clone https://dnceng:$AzureDevOpsAccessToken@dev.azure.com/dnceng/internal/_git/sdl-tool-cfg $sdlDir
+  if ($LASTEXITCODE -ne 0) {
+    Write-PipelineTelemetryError -Force -Category 'Sdl' -Message "Git clone failed with exit code $LASTEXITCODE."
+    ExitWithExitCode $LASTEXITCODE
+  }
+  # We copy the .gdn folder from our local run into the git repository so it can be committed
+  $sdlRepositoryFolder = Join-Path (Join-Path (Join-Path $sdlDir $Repository) $BranchName) '.gdn'
+  if (Get-Command Robocopy) {
+    Robocopy /S $GdnFolder $sdlRepositoryFolder
+  } else {
+    rsync -r $GdnFolder $sdlRepositoryFolder
+  }
+  # cd to the sdl-config directory so we can run git there
+  Push-Location $sdlDir
+  # git add . --> git commit --> git push
+  Write-Host 'git add .'
+  git add .
+  if ($LASTEXITCODE -ne 0) {
+    Write-PipelineTelemetryError -Force -Category 'Sdl' -Message "Git add failed with exit code $LASTEXITCODE."
+    ExitWithExitCode $LASTEXITCODE
+  }
+  Write-Host "git -c user.email=`"dn-bot@microsoft.com`" -c user.name=`"Dotnet Bot`" commit -m `"$PushReason for $Repository/$BranchName`""
+  git -c user.email="dn-bot@microsoft.com" -c user.name="Dotnet Bot" commit -m "$PushReason for $Repository/$BranchName"
+  if ($LASTEXITCODE -ne 0) {
+    Write-PipelineTelemetryError -Force -Category 'Sdl' -Message "Git commit failed with exit code $LASTEXITCODE."
+    ExitWithExitCode $LASTEXITCODE
+  }
+  Write-Host 'git push'
+  git push
+  if ($LASTEXITCODE -ne 0) {
+    Write-PipelineTelemetryError -Force -Category 'Sdl' -Message "Git push failed with exit code $LASTEXITCODE."
+    ExitWithExitCode $LASTEXITCODE
+  }
+
+  # Return to the original directory
+  Pop-Location
 }
-Write-Host "git push"
-git push
-if ($LASTEXITCODE -ne 0) {
-  Write-Error "Git push failed with exit code $LASTEXITCODE."
+catch {
+  Write-Host $_.ScriptStackTrace
+  Write-PipelineTelemetryError -Category 'Sdl' -Message $_
+  ExitWithExitCode 1
 }
-
-# Return to the original directory
-Pop-Location
\ No newline at end of file
diff --git a/eng/common/sdl/run-sdl.ps1 b/eng/common/sdl/run-sdl.ps1
index 9bc25314ae2..fe95ab35aa5 100644
--- a/eng/common/sdl/run-sdl.ps1
+++ b/eng/common/sdl/run-sdl.ps1
@@ -5,55 +5,69 @@ Param(
   [string] $GdnFolder,
   [string[]] $ToolsList,
   [string] $UpdateBaseline,
-  [string] $GuardianLoggerLevel="Standard",
+  [string] $GuardianLoggerLevel='Standard',
   [string[]] $CrScanAdditionalRunConfigParams,
   [string[]] $PoliCheckAdditionalRunConfigParams
 )
 
-$ErrorActionPreference = "Stop"
+$ErrorActionPreference = 'Stop'
 Set-StrictMode -Version 2.0
+$disableConfigureToolsetImport = $true
 $LASTEXITCODE = 0
 
-# We store config files in the r directory of .gdn
-Write-Host $ToolsList
-$gdnConfigPath = Join-Path $GdnFolder "r"
-$ValidPath = Test-Path $GuardianCliLocation
+try {
+  # `tools.ps1` checks $ci to perform some actions. Since the SDL
+  # scripts don't necessarily execute in the same agent that run the
+  # build.ps1/sh script this variable isn't automatically set.
+  $ci = $true
+  . $PSScriptRoot\..\tools.ps1
 
-if ($ValidPath -eq $False)
-{
-  Write-Host "Invalid Guardian CLI Location."
-  exit 1
-}
+  # We store config files in the r directory of .gdn
+  Write-Host $ToolsList
+  $gdnConfigPath = Join-Path $GdnFolder 'r'
+  $ValidPath = Test-Path $GuardianCliLocation
 
-$configParam = @("--config")
-
-foreach ($tool in $ToolsList) {
-  $gdnConfigFile = Join-Path $gdnConfigPath "$tool-configure.gdnconfig"
-  Write-Host $tool
-  # We have to manually configure tools that run on source to look at the source directory only
-  if ($tool -eq "credscan") {
-    Write-Host "$GuardianCliLocation configure --working-directory $WorkingDirectory --tool $tool --output-path $gdnConfigFile --logger-level $GuardianLoggerLevel --noninteractive --force --args `" TargetDirectory < $TargetDirectory `" `" OutputType < pre `" $(If ($CrScanAdditionalRunConfigParams) {$CrScanAdditionalRunConfigParams})"
-    & $GuardianCliLocation configure --working-directory $WorkingDirectory --tool $tool --output-path $gdnConfigFile --logger-level $GuardianLoggerLevel --noninteractive --force --args " TargetDirectory < $TargetDirectory " "OutputType < pre" $(If ($CrScanAdditionalRunConfigParams) {$CrScanAdditionalRunConfigParams})
-    if ($LASTEXITCODE -ne 0) {
-      Write-Host "Guardian configure for $tool failed with exit code $LASTEXITCODE."
-      exit $LASTEXITCODE
-    }
+  if ($ValidPath -eq $False)
+  {
+    Write-PipelineTelemetryError -Force -Category 'Sdl' -Message "Invalid Guardian CLI Location."
+    ExitWithExitCode 1
   }
-  if ($tool -eq "policheck") {
-    Write-Host "$GuardianCliLocation configure --working-directory $WorkingDirectory --tool $tool --output-path $gdnConfigFile --logger-level $GuardianLoggerLevel --noninteractive --force --args `" Target < $TargetDirectory `" $(If ($PoliCheckAdditionalRunConfigParams) {$PoliCheckAdditionalRunConfigParams})"
-    & $GuardianCliLocation configure --working-directory $WorkingDirectory --tool $tool --output-path $gdnConfigFile --logger-level $GuardianLoggerLevel --noninteractive --force --args " Target < $TargetDirectory " $(If ($PoliCheckAdditionalRunConfigParams) {$PoliCheckAdditionalRunConfigParams})
-    if ($LASTEXITCODE -ne 0) {
-      Write-Host "Guardian configure for $tool failed with exit code $LASTEXITCODE."
-      exit $LASTEXITCODE
+
+  $configParam = @('--config')
+
+  foreach ($tool in $ToolsList) {
+    $gdnConfigFile = Join-Path $gdnConfigPath "$tool-configure.gdnconfig"
+    Write-Host $tool
+    # We have to manually configure tools that run on source to look at the source directory only
+    if ($tool -eq 'credscan') {
+      Write-Host "$GuardianCliLocation configure --working-directory $WorkingDirectory --tool $tool --output-path $gdnConfigFile --logger-level $GuardianLoggerLevel --noninteractive --force --args `" TargetDirectory < $TargetDirectory `" `" OutputType < pre `" $(If ($CrScanAdditionalRunConfigParams) {$CrScanAdditionalRunConfigParams})"
+      & $GuardianCliLocation configure --working-directory $WorkingDirectory --tool $tool --output-path $gdnConfigFile --logger-level $GuardianLoggerLevel --noninteractive --force --args " TargetDirectory < $TargetDirectory " "OutputType < pre" $(If ($CrScanAdditionalRunConfigParams) {$CrScanAdditionalRunConfigParams})
+      if ($LASTEXITCODE -ne 0) {
+        Write-PipelineTelemetryError -Force -Category 'Sdl' -Message "Guardian configure for $tool failed with exit code $LASTEXITCODE."
+        ExitWithExitCode $LASTEXITCODE
+      }
     }
+    if ($tool -eq 'policheck') {
+      Write-Host "$GuardianCliLocation configure --working-directory $WorkingDirectory --tool $tool --output-path $gdnConfigFile --logger-level $GuardianLoggerLevel --noninteractive --force --args `" Target < $TargetDirectory `" $(If ($PoliCheckAdditionalRunConfigParams) {$PoliCheckAdditionalRunConfigParams})"
+      & $GuardianCliLocation configure --working-directory $WorkingDirectory --tool $tool --output-path $gdnConfigFile --logger-level $GuardianLoggerLevel --noninteractive --force --args " Target < $TargetDirectory " $(If ($PoliCheckAdditionalRunConfigParams) {$PoliCheckAdditionalRunConfigParams})
+      if ($LASTEXITCODE -ne 0) {
+        Write-PipelineTelemetryError -Force -Category 'Sdl' -Message "Guardian configure for $tool failed with exit code $LASTEXITCODE."
+        ExitWithExitCode $LASTEXITCODE
+      }
+    }
+
+    $configParam+=$gdnConfigFile
   }
 
-  $configParam+=$gdnConfigFile
+  Write-Host "$GuardianCliLocation run --working-directory $WorkingDirectory --baseline mainbaseline --update-baseline $UpdateBaseline --logger-level $GuardianLoggerLevel $configParam"
+  & $GuardianCliLocation run --working-directory $WorkingDirectory --tool $tool --baseline mainbaseline --update-baseline $UpdateBaseline --logger-level $GuardianLoggerLevel $configParam
+  if ($LASTEXITCODE -ne 0) {
+    Write-PipelineTelemetryError -Force -Category 'Sdl' -Message "Guardian run for $ToolsList using $configParam failed with exit code $LASTEXITCODE."
+    ExitWithExitCode $LASTEXITCODE
+  }
 }
-
-Write-Host "$GuardianCliLocation run --working-directory $WorkingDirectory --baseline mainbaseline --update-baseline $UpdateBaseline --logger-level $GuardianLoggerLevel $configParam"
-& $GuardianCliLocation run --working-directory $WorkingDirectory --tool $tool --baseline mainbaseline --update-baseline $UpdateBaseline --logger-level $GuardianLoggerLevel $configParam
-if ($LASTEXITCODE -ne 0) {
-  Write-Host "Guardian run for $ToolsList using $configParam failed with exit code $LASTEXITCODE."
-  exit $LASTEXITCODE
+catch {
+  Write-Host $_.ScriptStackTrace
+  Write-PipelineTelemetryError -Force -Category 'Sdl' -Message $_
+  ExitWithExitCode 1
 }
diff --git a/eng/common/templates/job/execute-sdl.yml b/eng/common/templates/job/execute-sdl.yml
index bf09d2511c6..53c100222b2 100644
--- a/eng/common/templates/job/execute-sdl.yml
+++ b/eng/common/templates/job/execute-sdl.yml
@@ -1,10 +1,12 @@
 parameters:
+  enable: 'false'                                             # Whether the SDL validation job should execute or not
   overrideParameters: ''                                       # Optional: to override values for parameters.
   additionalParameters: ''                                     # Optional: parameters that need user specific values eg: '-SourceToolsList @("abc","def") -ArtifactToolsList @("ghi","jkl")'
   # There is some sort of bug (has been reported) in Azure DevOps where if this parameter is named
   # 'continueOnError', the parameter value is not correctly picked up.
   # This can also be remedied by the caller (post-build.yml) if it does not use a nested parameter
   sdlContinueOnError: false                                    # optional: determines whether to continue the build if the step errors;
+  downloadArtifacts: true                                      # optional: determines if the artifacts should be dowloaded
   dependsOn: ''                                                # Optional: dependencies of the job
   artifactNames: ''                                            # Optional: patterns supplied to DownloadBuildArtifacts
                                                                # Usage:
@@ -16,37 +18,53 @@ jobs:
 - job: Run_SDL
   dependsOn: ${{ parameters.dependsOn }}
   displayName: Run SDL tool
+  condition: eq( ${{ parameters.enable }}, 'true')
   variables:
     - group: DotNet-VSTS-Bot
+    - name: AzDOProjectName
+      value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOProjectName'] ]
+    - name: AzDOPipelineId
+      value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOPipelineId'] ]
+    - name: AzDOBuildId
+      value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOBuildId'] ]
   pool:
     name: Hosted VS2017
   steps:
   - checkout: self
     clean: true
-  - ${{ if ne(parameters.artifactNames, '') }}:
-    - ${{ each artifactName in parameters.artifactNames }}:
+  - ${{ if ne(parameters.downloadArtifacts, 'false')}}:
+    - ${{ if ne(parameters.artifactNames, '') }}:
+      - ${{ each artifactName in parameters.artifactNames }}:
+        - task: DownloadBuildArtifacts@0
+          displayName: Download Build Artifacts
+          inputs:
+            buildType: specific
+            buildVersionToDownload: specific
+            project: $(AzDOProjectName)
+            pipeline: $(AzDOPipelineId)
+            buildId: $(AzDOBuildId)
+            artifactName: ${{ artifactName }}
+            downloadPath: $(Build.ArtifactStagingDirectory)\artifacts
+    - ${{ if eq(parameters.artifactNames, '') }}:
       - task: DownloadBuildArtifacts@0
         displayName: Download Build Artifacts
         inputs:
-          buildType: current
-          artifactName: ${{ artifactName }}
+          buildType: specific
+          buildVersionToDownload: specific
+          project: $(AzDOProjectName)
+          pipeline: $(AzDOPipelineId)
+          buildId: $(AzDOBuildId)
+          downloadType: specific files
+          itemPattern: "**"
           downloadPath: $(Build.ArtifactStagingDirectory)\artifacts
-  - ${{ if eq(parameters.artifactNames, '') }}:
-    - task: DownloadBuildArtifacts@0
-      displayName: Download Build Artifacts
-      inputs:
-        buildType: current
-        downloadType: specific files
-        itemPattern: "**"
-        downloadPath: $(Build.ArtifactStagingDirectory)\artifacts
   - powershell: eng/common/sdl/extract-artifact-packages.ps1
-      -InputPath $(Build.SourcesDirectory)\artifacts\BlobArtifacts
-      -ExtractPath $(Build.SourcesDirectory)\artifacts\BlobArtifacts
+      -InputPath $(Build.ArtifactStagingDirectory)\artifacts\BlobArtifacts
+      -ExtractPath $(Build.ArtifactStagingDirectory)\artifacts\BlobArtifacts
     displayName: Extract Blob Artifacts
     continueOnError: ${{ parameters.sdlContinueOnError }}
   - powershell: eng/common/sdl/extract-artifact-packages.ps1
-      -InputPath $(Build.SourcesDirectory)\artifacts\PackageArtifacts
-      -ExtractPath $(Build.SourcesDirectory)\artifacts\PackageArtifacts
+      -InputPath $(Build.ArtifactStagingDirectory)\artifacts\PackageArtifacts
+      -ExtractPath $(Build.ArtifactStagingDirectory)\artifacts\PackageArtifacts
     displayName: Extract Package Artifacts
     continueOnError: ${{ parameters.sdlContinueOnError }}
   - task: NuGetToolInstaller@1
@@ -65,7 +83,7 @@ jobs:
       continueOnError: ${{ parameters.sdlContinueOnError }}
   - ${{ if eq(parameters.overrideParameters, '') }}:
     - powershell: eng/common/sdl/execute-all-sdl-tools.ps1
-        -GuardianPackageName Microsoft.Guardian.Cli.win10-x64.0.20.1
+        -GuardianPackageName Microsoft.Guardian.Cli.0.53.3
         -NugetPackageDirectory $(Build.SourcesDirectory)\.packages
         -AzureDevOpsAccessToken $(dn-bot-dotnet-build-rw-code-rw)
         ${{ parameters.additionalParameters }}
diff --git a/eng/common/templates/job/job.yml b/eng/common/templates/job/job.yml
index ffda80a197b..8b81a7e5143 100644
--- a/eng/common/templates/job/job.yml
+++ b/eng/common/templates/job/job.yml
@@ -1,67 +1,36 @@
+# Internal resources (telemetry, microbuild) can only be accessed from non-public projects,
+# and some (Microbuild) should only be applied to non-PR cases for internal builds.
+
 parameters:
 # Job schema parameters - https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=vsts&tabs=schema#job
   cancelTimeoutInMinutes: ''
-
   condition: ''
-
-  continueOnError: false
-
   container: ''
-
+  continueOnError: false
   dependsOn: ''
-
   displayName: ''
-
-  steps: []
-
   pool: ''
-
+  steps: []
   strategy: ''
-
   timeoutInMinutes: ''
-
   variables: []
-
   workspace: ''
 
-  # Job base template specific parameters
-  # Optional: Enable installing Microbuild plugin
-  #           if 'true', these "variables" must be specified in the variables object or as part of the queue matrix
-  #             _TeamName - the name of your team
-  #             _SignType - 'test' or 'real'
+# Job base template specific parameters
+  # See schema documentation - https://github.com/dotnet/arcade/blob/master/Documentation/AzureDevOps/TemplateSchema.md
+  artifacts: ''
   enableMicrobuild: false
-
-  # Optional: Include PublishBuildArtifacts task
   enablePublishBuildArtifacts: false
-
-  # Optional: Enable publishing to the build asset registry
   enablePublishBuildAssets: false
-
-  # Optional: Prevent gather/push manifest from executing when using publishing pipelines
-  enablePublishUsingPipelines: false
-
-  # Optional: Include PublishTestResults task
   enablePublishTestResults: false
-
-  # Optional: enable sending telemetry
-  enableTelemetry: false
-
-  # Optional: define the helix repo for telemetry (example: 'dotnet/arcade')
-  helixRepo: ''
-
-  # Optional: define the helix type for telemetry (example: 'build/product/')
-  helixType: ''
-
-  # Required: name of the job
+  enablePublishUsingPipelines: false
+  useBuildManifest: false
+  mergeTestResults: false
+  testRunTitle: ''
   name: ''
-
-  # Optional: should run as a public build even in the internal project
-  #           if 'true', the build won't run any of the internal only steps, even if it is running in non-public projects.
+  preSteps: []
   runAsPublic: false
 
-# Internal resources (telemetry, microbuild) can only be accessed from non-public projects,
-# and some (Microbuild) should only be applied to non-PR cases for internal builds.
-
 jobs:
 - job: ${{ parameters.name }}
 
@@ -93,9 +62,12 @@ jobs:
     timeoutInMinutes: ${{ parameters.timeoutInMinutes }}
 
   variables:
-  - ${{ if eq(parameters.enableTelemetry, 'true') }}:
+  - ${{ if ne(parameters.enableTelemetry, 'false') }}:
     - name: DOTNET_CLI_TELEMETRY_PROFILE
       value: '$(Build.Repository.Uri)'
+  - ${{ if eq(parameters.enableRichCodeNavigation, 'true') }}:
+    - name: EnableRichCodeNavigation
+      value: 'true'
   - ${{ each variable in parameters.variables }}:
     # handle name-value variable syntax
     # example:
@@ -125,21 +97,12 @@ jobs:
     workspace: ${{ parameters.workspace }}
 
   steps:
-  - ${{ if eq(parameters.enableTelemetry, 'true') }}:
-    # Telemetry tasks are built from https://github.com/dotnet/arcade-extensions
-    - task: sendStartTelemetry@0
-      displayName: 'Send Helix Start Telemetry'
-      inputs:
-        helixRepo: ${{ parameters.helixRepo }}
-        ${{ if ne(parameters.helixType, '') }}:
-          helixType: ${{ parameters.helixType }}
-        buildConfig: $(_BuildConfig)
-        runAsPublic: ${{ parameters.runAsPublic }}
-      continueOnError: ${{ parameters.continueOnError }}
-      condition: always()
+  - ${{ if ne(parameters.preSteps, '') }}:
+    - ${{ each preStep in parameters.preSteps }}:
+      - ${{ preStep }}
 
-  - ${{ if eq(parameters.enableMicrobuild, 'true') }}:
-    - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
+  - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
+    - ${{ if eq(parameters.enableMicrobuild, 'true') }}:
       - task: MicroBuildSigningPlugin@2
         displayName: Install MicroBuild plugin
         inputs:
@@ -151,12 +114,28 @@ jobs:
         continueOnError: ${{ parameters.continueOnError }}
         condition: and(succeeded(), in(variables['_SignType'], 'real', 'test'), eq(variables['Agent.Os'], 'Windows_NT'))
 
-  - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
     - task: NuGetAuthenticate@0
 
+  - ${{ if or(eq(parameters.artifacts.download, 'true'), ne(parameters.artifacts.download, '')) }}:
+    - task: DownloadPipelineArtifact@2
+      inputs:
+        buildType: current
+        artifactName: ${{ coalesce(parameters.artifacts.download.name, 'Artifacts_$(Agent.OS)_$(_BuildConfig)') }}
+        targetPath: ${{ coalesce(parameters.artifacts.download.path, 'artifacts') }}
+        itemPattern: ${{ coalesce(parameters.artifacts.download.pattern, '**') }}
+
   - ${{ each step in parameters.steps }}:
     - ${{ step }}
 
+  - ${{ if eq(parameters.enableRichCodeNavigation, true) }}:
+    - task: RichCodeNavIndexer@0
+      displayName: RichCodeNav Upload
+      inputs:
+        languages: 'csharp'
+        environment: ${{ coalesce(parameters.richCodeNavigationEnvironment, 'prod') }}
+        richNavLogOutputDirectory: $(Build.SourcesDirectory)/artifacts/bin
+      continueOnError: true
+
   - ${{ if eq(parameters.enableMicrobuild, 'true') }}:
     - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
       - task: MicroBuildCleanup@1
@@ -166,30 +145,82 @@ jobs:
         env:
           TeamName: $(_TeamName)
 
-  - ${{ if eq(parameters.enableTelemetry, 'true') }}:
-    # Telemetry tasks are built from https://github.com/dotnet/arcade-extensions
-    - task: sendEndTelemetry@0
-      displayName: 'Send Helix End Telemetry'
-      continueOnError: ${{ parameters.continueOnError }}
-      condition: always()
-
-  - ${{ if eq(parameters.enablePublishBuildArtifacts, 'true') }}:
+  - ${{ if ne(parameters.artifacts.publish, '') }}:
+    - ${{ if or(eq(parameters.artifacts.publish.artifacts, 'true'), ne(parameters.artifacts.publish.artifacts, '')) }}:
+      - task: CopyFiles@2
+        displayName: Gather binaries for publish to artifacts
+        inputs:
+          SourceFolder: 'artifacts/bin'
+          Contents: '**'
+          TargetFolder: '$(Build.ArtifactStagingDirectory)/artifacts/bin'
+      - task: CopyFiles@2
+        displayName: Gather packages for publish to artifacts
+        inputs:
+          SourceFolder: 'artifacts/packages'
+          Contents: '**'
+          TargetFolder: '$(Build.ArtifactStagingDirectory)/artifacts/packages'
+      - task: PublishBuildArtifacts@1
+        displayName: Publish pipeline artifacts
+        inputs:
+          PathtoPublish: '$(Build.ArtifactStagingDirectory)/artifacts'
+          PublishLocation: Container
+          ArtifactName: ${{ coalesce(parameters.artifacts.publish.artifacts.name , 'Artifacts_$(Agent.Os)_$(_BuildConfig)') }}
+        continueOnError: true
+        condition: always()
+    - ${{ if or(eq(parameters.artifacts.publish.logs, 'true'), ne(parameters.artifacts.publish.logs, '')) }}:
+      - publish: artifacts/log
+        artifact: ${{ coalesce(parameters.artifacts.publish.logs.name, 'Logs_Build_$(Agent.Os)_$(_BuildConfig)') }}
+        displayName: Publish logs
+        continueOnError: true
+        condition: always()
+    - ${{ if or(eq(parameters.artifacts.publish.manifests, 'true'), ne(parameters.artifacts.publish.manifests, '')) }}:
+      - ${{ if and(ne(parameters.enablePublishUsingPipelines, 'true'), eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:    
+        - task: CopyFiles@2
+          displayName: Gather Asset Manifests
+          inputs:
+            SourceFolder: '$(Build.SourcesDirectory)/artifacts/log/$(_BuildConfig)/AssetManifest'
+            TargetFolder: '$(Build.ArtifactStagingDirectory)/AssetManifests'
+          continueOnError: ${{ parameters.continueOnError }}
+          condition: and(succeeded(), eq(variables['_DotNetPublishToBlobFeed'], 'true'))
+
+        - task: PublishBuildArtifacts@1
+          displayName: Push Asset Manifests
+          inputs:
+            PathtoPublish: '$(Build.ArtifactStagingDirectory)/AssetManifests'
+            PublishLocation: Container
+            ArtifactName: AssetManifests
+          continueOnError: ${{ parameters.continueOnError }}
+          condition: and(succeeded(), eq(variables['_DotNetPublishToBlobFeed'], 'true'))
+
+  - ${{ if ne(parameters.enablePublishBuildArtifacts, 'false') }}:
     - task: PublishBuildArtifacts@1
       displayName: Publish Logs
       inputs:
         PathtoPublish: '$(Build.SourcesDirectory)/artifacts/log/$(_BuildConfig)'
         PublishLocation: Container
-        ArtifactName: $(Agent.Os)_$(Agent.JobName)
+        ArtifactName: ${{ coalesce(parameters.enablePublishBuildArtifacts.artifactName, '$(Agent.Os)_$(Agent.JobName)' ) }}
       continueOnError: true
       condition: always()
 
   - ${{ if eq(parameters.enablePublishTestResults, 'true') }}:
     - task: PublishTestResults@2
-      displayName: Publish Test Results
+      displayName: Publish XUnit Test Results
       inputs:
         testResultsFormat: 'xUnit'
         testResultsFiles: '*.xml' 
         searchFolder: '$(Build.SourcesDirectory)/artifacts/TestResults/$(_BuildConfig)'
+        testRunTitle: ${{ coalesce(parameters.testRunTitle, parameters.name, '$(System.JobName)') }}-xunit
+        mergeTestResults: ${{ parameters.mergeTestResults }}
+      continueOnError: true
+      condition: always()
+    - task: PublishTestResults@2
+      displayName: Publish TRX Test Results
+      inputs:
+        testResultsFormat: 'VSTest'
+        testResultsFiles: '*.trx' 
+        searchFolder: '$(Build.SourcesDirectory)/artifacts/TestResults/$(_BuildConfig)'
+        testRunTitle: ${{ coalesce(parameters.testRunTitle, parameters.name, '$(System.JobName)') }}-trx
+        mergeTestResults: ${{ parameters.mergeTestResults }}
       continueOnError: true
       condition: always()
     
@@ -210,3 +241,12 @@ jobs:
         ArtifactName: AssetManifests
       continueOnError: ${{ parameters.continueOnError }}
       condition: and(succeeded(), eq(variables['_DotNetPublishToBlobFeed'], 'true'))
+
+  - ${{ if eq(parameters.useBuildManifest, true) }}:
+    - task: PublishBuildArtifacts@1
+      displayName: Publish Build Manifest
+      inputs:
+        PathToPublish: '$(Build.SourcesDirectory)/artifacts/log/$(_BuildConfig)/manifest.props'
+        PublishLocation: Container
+        ArtifactName: BuildManifests
+      continueOnError: ${{ parameters.continueOnError }}
diff --git a/eng/common/templates/job/publish-build-assets.yml b/eng/common/templates/job/publish-build-assets.yml
index b722975f9c2..d0c3cc2b3ba 100644
--- a/eng/common/templates/job/publish-build-assets.yml
+++ b/eng/common/templates/job/publish-build-assets.yml
@@ -37,6 +37,12 @@ jobs:
     - name: _BuildConfig
       value: ${{ parameters.configuration }}
     - group: Publish-Build-Assets
+    # Skip component governance and codesign validation for SDL. These jobs
+    # create no content.
+    - name: skipComponentGovernanceDetection
+      value: true
+    - name: runCodesignValidationInjection
+      value: false
 
   steps:
   - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
@@ -61,6 +67,7 @@ jobs:
           /p:MaestroApiEndpoint=https://maestro-prod.westus2.cloudapp.azure.com
           /p:PublishUsingPipelines=${{ parameters.publishUsingPipelines }}
           /p:Configuration=$(_BuildConfig)
+          /p:OfficialBuildId=$(Build.BuildNumber)
       condition: ${{ parameters.condition }}
       continueOnError: ${{ parameters.continueOnError }}
     
@@ -81,11 +88,6 @@ jobs:
         ArtifactName: ReleaseConfigs
     
     - ${{ if eq(parameters.enablePublishBuildArtifacts, 'true') }}:
-      - task: PublishBuildArtifacts@1
-        displayName: Publish Logs to VSTS
-        inputs:
-          PathtoPublish: '$(Build.SourcesDirectory)/artifacts/log/$(_BuildConfig)'
-          PublishLocation: Container
-          ArtifactName: $(Agent.Os)_PublishBuildAssets
-        continueOnError: true
-        condition: always()      
+      - template: /eng/common/templates/steps/publish-logs.yml
+        parameters:
+          JobLabel: 'Publish_Artifacts_Logs'     
diff --git a/eng/common/templates/job/source-build.yml b/eng/common/templates/job/source-build.yml
new file mode 100644
index 00000000000..9332f5ecc38
--- /dev/null
+++ b/eng/common/templates/job/source-build.yml
@@ -0,0 +1,49 @@
+parameters:
+  # This template adds arcade-powered source-build to CI. The template produces a server job with a
+  # default ID 'Source_Build_Complete' to put in a dependency list if necessary.
+
+  # Specifies the prefix for source-build jobs added to pipeline. Use this if disambiguation needed.
+  jobNamePrefix: 'Source_Build'
+
+  # Defines the platform on which to run the job. By default, a linux-x64 machine, suitable for
+  # managed-only repositories. This is an object with these properties:
+  #
+  # name: ''
+  #   The name of the job. This is included in the job ID.
+  # targetRID: ''
+  #   The name of the target RID to use, instead of the one auto-detected by Arcade.
+  # nonPortable: false
+  #   Enables non-portable mode. This means a more specific RID (e.g. fedora.32-x64 rather than
+  #   linux-x64), and compiling against distro-provided packages rather than portable ones.
+  # container: ''
+  #   A container to use. Runs in docker.
+  # pool: {}
+  #   A pool to use. Runs directly on an agent.
+  # buildScript: ''
+  #   Specifies the build script to invoke to perform the build in the repo. The default
+  #   './build.sh' should work for typical Arcade repositories, but this is customizable for
+  #   difficult situations.
+  # jobProperties: {}
+  #   A list of job properties to inject at the top level, for potential extensibility beyond
+  #   container and pool.
+  platform: {}
+
+jobs:
+- job: ${{ parameters.jobNamePrefix }}_${{ parameters.platform.name }}
+  displayName: Source-Build (${{ parameters.platform.name }})
+
+  ${{ each property in parameters.platform.jobProperties }}:
+    ${{ property.key }}: ${{ property.value }}
+
+  ${{ if ne(parameters.platform.container, '') }}:
+    container: ${{ parameters.platform.container }}
+  ${{ if ne(parameters.platform.pool, '') }}:
+    pool: ${{ parameters.platform.pool }}
+
+  workspace:
+    clean: all
+
+  steps:
+  - template: /eng/common/templates/steps/source-build.yml
+    parameters:
+      platform: ${{ parameters.platform }}
diff --git a/eng/common/templates/jobs/jobs.yml b/eng/common/templates/jobs/jobs.yml
index 6a2f98c036f..08845950f44 100644
--- a/eng/common/templates/jobs/jobs.yml
+++ b/eng/common/templates/jobs/jobs.yml
@@ -1,19 +1,10 @@
 parameters:
-  # Optional: 'true' if failures in job.yml job should not fail the job
+  # See schema documentation in /Documentation/AzureDevOps/TemplateSchema.md
   continueOnError: false
 
-  # Optional: Enable installing Microbuild plugin
-  #           if 'true', these "variables" must be specified in the variables object or as part of the queue matrix
-  #             _TeamName - the name of your team
-  #             _SignType - 'test' or 'real'
-  enableMicrobuild: false
-
   # Optional: Include PublishBuildArtifacts task
   enablePublishBuildArtifacts: false
 
-  # Optional: Enable publishing to the build asset registry
-  enablePublishBuildAssets: false
-
   # Optional: Enable publishing using release pipelines
   enablePublishUsingPipelines: false
   
@@ -23,19 +14,9 @@ parameters:
     # Optional: Include toolset dependencies in the generated graph files
     includeToolset: false
     
-  # Optional: Include PublishTestResults task
-  enablePublishTestResults: false
-
-  # Optional: enable sending telemetry
-  # if enabled then the 'helixRepo' parameter should also be specified
-  enableTelemetry: false
-
   # Required: A collection of jobs to run - https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=vsts&tabs=schema#job
   jobs: []
 
-  # Optional: define the helix repo for telemetry (example: 'dotnet/arcade')
-  helixRepo: ''
-
   # Optional: Override automatically derived dependsOn value for "publish build assets" job
   publishBuildAssetsDependsOn: ''
 
@@ -43,6 +24,13 @@ parameters:
   #           if 'true', the build won't run any of the internal only steps, even if it is running in non-public projects.
   runAsPublic: false
 
+  # Optional: Enable running the source-build jobs to build repo from source
+  runSourceBuild: false
+
+  # Optional: Parameters for source-build template.
+  #           See /eng/common/templates/jobs/source-build.yml for options
+  sourceBuildParameters: []
+
 # Internal resources (telemetry, microbuild) can only be accessed from non-public projects,
 # and some (Microbuild) should only be applied to non-PR cases for internal builds.
 
@@ -62,29 +50,39 @@ jobs:
 
       name: ${{ job.job }}
 
-- ${{ if and(eq(parameters.enablePublishBuildAssets, true), eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
-  - template: ../job/publish-build-assets.yml
-    parameters:
-      continueOnError: ${{ parameters.continueOnError }}
-      dependsOn:
-      - ${{ if ne(parameters.publishBuildAssetsDependsOn, '') }}:
-        - ${{ each job in parameters.publishBuildAssetsDependsOn }}:
-          - ${{ job.job }}
-      - ${{ if eq(parameters.publishBuildAssetsDependsOn, '') }}:
-        - ${{ each job in parameters.jobs }}:
-          - ${{ job.job }}
-      pool:
-        vmImage: vs2017-win2016
-      runAsPublic: ${{ parameters.runAsPublic }}
-      publishUsingPipelines: ${{ parameters.enablePublishUsingPipelines }}
-      enablePublishBuildArtifacts: ${{ parameters.enablePublishBuildArtifacts }}
-      
-- ${{ if and(eq(parameters.graphFileGeneration.enabled, true), eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
-  - template: ../job/generate-graph-files.yml
+- ${{ if eq(parameters.runSourceBuild, true) }}:
+  - template: /eng/common/templates/jobs/source-build.yml
     parameters:
-      continueOnError: ${{ parameters.continueOnError }}
-      includeToolset: ${{ parameters.graphFileGeneration.includeToolset }}
-      dependsOn:
-        - Asset_Registry_Publish
-      pool:
-        vmImage: vs2017-win2016
+      allCompletedJobId: Source_Build_Complete
+      ${{ each parameter in parameters.sourceBuildParameters }}:
+        ${{ parameter.key }}: ${{ parameter.value }}
+
+- ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
+  - ${{ if or(eq(parameters.enablePublishBuildAssets, true), eq(parameters.artifacts.publish.manifests, 'true'), ne(parameters.artifacts.publish.manifests, '')) }}:
+    - template: ../job/publish-build-assets.yml
+      parameters:
+        continueOnError: ${{ parameters.continueOnError }}
+        dependsOn:
+        - ${{ if ne(parameters.publishBuildAssetsDependsOn, '') }}:
+          - ${{ each job in parameters.publishBuildAssetsDependsOn }}:
+            - ${{ job.job }}
+        - ${{ if eq(parameters.publishBuildAssetsDependsOn, '') }}:
+          - ${{ each job in parameters.jobs }}:
+            - ${{ job.job }}
+        - ${{ if eq(parameters.runSourceBuild, true) }}:
+          - Source_Build_Complete
+        pool:
+          vmImage: vs2017-win2016
+        runAsPublic: ${{ parameters.runAsPublic }}
+        publishUsingPipelines: ${{ parameters.enablePublishUsingPipelines }}
+        enablePublishBuildArtifacts: ${{ parameters.enablePublishBuildArtifacts }}
+
+  - ${{ if eq(parameters.graphFileGeneration.enabled, true) }}:
+    - template: ../job/generate-graph-files.yml
+      parameters:
+        continueOnError: ${{ parameters.continueOnError }}
+        includeToolset: ${{ parameters.graphFileGeneration.includeToolset }}
+        dependsOn:
+          - Asset_Registry_Publish
+        pool:
+          vmImage: vs2017-win2016
diff --git a/eng/common/templates/jobs/source-build.yml b/eng/common/templates/jobs/source-build.yml
new file mode 100644
index 00000000000..f463011e793
--- /dev/null
+++ b/eng/common/templates/jobs/source-build.yml
@@ -0,0 +1,48 @@
+parameters:
+  # This template adds arcade-powered source-build to CI. A job is created for each platform, as
+  # well as an optional server job that completes when all platform jobs complete.
+
+  # The name of the "join" job for all source-build platforms. If set to empty string, the job is
+  # not included. Existing repo pipelines can use this job depend on all source-build jobs
+  # completing without maintaining a separate list of every single job ID: just depend on this one
+  # server job. By default, not included. Recommended name if used: 'Source_Build_Complete'.
+  allCompletedJobId: ''
+
+  # See /eng/common/templates/job/source-build.yml
+  jobNamePrefix: 'Source_Build'
+
+  # If changed to true, causes this template to include the default platform for a managed-only
+  # repo. The exact Docker image used for this build will be provided by Arcade. This has some risk,
+  # but since the repo is supposed to be managed-only, the risk should be very low.
+  includeDefaultManagedPlatform: false
+  defaultManagedPlatform:
+    name: 'Managed'
+    container: 'mcr.microsoft.com/dotnet-buildtools/prereqs:centos-7-3e800f1-20190501005343'
+
+  # Defines the platforms on which to run build jobs. One job is created for each platform, and the
+  # object in this array is sent to the job template as 'platform'.
+  platforms: []
+
+jobs:
+
+- ${{ if ne(parameters.allCompletedJobId, '') }}:
+  - job: ${{ parameters.allCompletedJobId }}
+    displayName: Source-Build Complete
+    pool: server
+    dependsOn:
+    - ${{ each platform in parameters.platforms }}:
+      - ${{ parameters.jobNamePrefix }}_${{ platform.name }}
+    - ${{ if eq(parameters.includeDefaultManagedPlatform, true) }}:
+      - ${{ parameters.jobNamePrefix }}_${{ parameters.defaultManagedPlatform.name }}
+
+- ${{ each platform in parameters.platforms }}:
+  - template: /eng/common/templates/job/source-build.yml
+    parameters:
+      jobNamePrefix: ${{ parameters.jobNamePrefix }}
+      platform: ${{ platform }}
+
+- ${{ if eq(parameters.includeDefaultManagedPlatform, true) }}:
+  - template: /eng/common/templates/job/source-build.yml
+    parameters:
+      jobNamePrefix: ${{ parameters.jobNamePrefix }}
+      platform: ${{ parameters.defaultManagedPlatform }}
diff --git a/eng/common/templates/post-build/channels/generic-internal-channel.yml b/eng/common/templates/post-build/channels/generic-internal-channel.yml
index ad9375f5e5c..7ae5255921a 100644
--- a/eng/common/templates/post-build/channels/generic-internal-channel.yml
+++ b/eng/common/templates/post-build/channels/generic-internal-channel.yml
@@ -1,5 +1,10 @@
 parameters:
-  publishInstallersAndChecksums: false
+  BARBuildId: ''
+  PromoteToChannelIds: ''
+  artifactsPublishingAdditionalParameters: ''
+  dependsOn:
+  - Validate
+  publishInstallersAndChecksums: true
   symbolPublishingAdditionalParameters: ''
   stageName: ''
   channelName: ''
@@ -10,19 +15,28 @@ parameters:
 
 stages:
 - stage: ${{ parameters.stageName }}
-  dependsOn: validate
+  dependsOn: ${{ parameters.dependsOn }}
   variables:
     - template: ../common-variables.yml
   displayName: ${{ parameters.channelName }} Publishing
   jobs:
   - template: ../setup-maestro-vars.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}
 
-  - job:
+  - job: publish_symbols
     displayName: Symbol Publishing
     dependsOn: setupMaestroVars
-    condition: contains(dependencies.setupMaestroVars.outputs['setReleaseVars.InitialChannels'], format('[{0}]', ${{ parameters.channelId }} ))
+    condition: contains(dependencies.setupMaestroVars.outputs['setReleaseVars.TargetChannels'], format('[{0}]', ${{ parameters.channelId }} ))
     variables:
       - group: DotNet-Symbol-Server-Pats
+      - name: AzDOProjectName
+        value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOProjectName'] ]
+      - name: AzDOPipelineId
+        value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOPipelineId'] ]
+      - name: AzDOBuildId
+        value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOBuildId'] ]
     pool:
       vmImage: 'windows-2019'
     steps:
@@ -31,16 +45,31 @@ stages:
         displayName: 'Authenticate to AzDO Feeds'
 
       - task: DownloadBuildArtifacts@0
-        displayName: Download Blob Artifacts
-        inputs:
-          artifactName: 'BlobArtifacts'
+        displayName: Download Build Assets
         continueOnError: true
+        inputs:
+          buildType: specific
+          buildVersionToDownload: specific
+          project: $(AzDOProjectName)
+          pipeline: $(AzDOPipelineId)
+          buildId: $(AzDOBuildId)
+          downloadType: 'specific'
+          itemPattern: |
+            PdbArtifacts/**
+            BlobArtifacts/**
+          downloadPath: '$(Build.ArtifactStagingDirectory)'
 
-      - task: DownloadBuildArtifacts@0
-        displayName: Download PDB Artifacts
+      # This is necessary whenever we want to publish/restore to an AzDO private feed
+      # Since sdk-task.ps1 tries to restore packages we need to do this authentication here
+      # otherwise it'll complain about accessing a private feed.
+      - task: NuGetAuthenticate@0
+        displayName: 'Authenticate to AzDO Feeds'
+
+      - task: PowerShell@2
+        displayName: Enable cross-org publishing
         inputs:
-          artifactName: 'PDBArtifacts'
-        continueOnError: true
+          filePath: eng\common\enable-cross-org-publishing.ps1
+          arguments: -token $(dn-bot-dnceng-artifact-feeds-rw)
 
       - task: PowerShell@2
         displayName: Publish
@@ -53,39 +82,48 @@ stages:
             /p:BlobBasePath='$(Build.ArtifactStagingDirectory)/BlobArtifacts/'
             /p:SymbolPublishingExclusionsFile='$(Build.SourcesDirectory)/eng/SymbolPublishingExclusionsFile.txt'
             /p:Configuration=Release
+            /p:PublishToMSDL=false
             ${{ parameters.symbolPublishingAdditionalParameters }}
 
+      - template: ../../steps/publish-logs.yml
+        parameters:
+          StageLabel: '${{ parameters.stageName }}'
+          JobLabel: 'SymbolPublishing'
+
   - job: publish_assets
     displayName: Publish Assets
     dependsOn: setupMaestroVars
+    timeoutInMinutes: 120
     variables:
-      - group: DotNet-Blob-Feed
-      - group: AzureDevOps-Artifact-Feeds-Pats
       - name: BARBuildId
         value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.BARBuildId'] ]
       - name: IsStableBuild
         value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.IsStableBuild'] ]
-    condition: contains(dependencies.setupMaestroVars.outputs['setReleaseVars.InitialChannels'], format('[{0}]', ${{ parameters.channelId }}))
+      - name: AzDOProjectName
+        value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOProjectName'] ]
+      - name: AzDOPipelineId
+        value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOPipelineId'] ]
+      - name: AzDOBuildId
+        value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOBuildId'] ]
+    condition: contains(dependencies.setupMaestroVars.outputs['setReleaseVars.TargetChannels'], format('[{0}]', ${{ parameters.channelId }} ))
     pool:
       vmImage: 'windows-2019'
     steps:
       - task: DownloadBuildArtifacts@0
-        displayName: Download Package Artifacts
-        inputs:
-          buildType: current
-          artifactName: PackageArtifacts
-
-      - task: DownloadBuildArtifacts@0
-        displayName: Download Blob Artifacts
-        inputs:
-          buildType: current
-          artifactName: BlobArtifacts
-
-      - task: DownloadBuildArtifacts@0
-        displayName: Download Asset Manifests
+        displayName: Download Build Assets
+        continueOnError: true
         inputs:
-          buildType: current
-          artifactName: AssetManifests
+          buildType: specific
+          buildVersionToDownload: specific
+          project: $(AzDOProjectName)
+          pipeline: $(AzDOPipelineId)
+          buildId: $(AzDOBuildId)
+          downloadType: 'specific'
+          itemPattern: |
+            PackageArtifacts/**
+            BlobArtifacts/**
+            AssetManifests/**
+          downloadPath: '$(Build.ArtifactStagingDirectory)'
 
       - task: NuGetToolInstaller@1
         displayName: 'Install NuGet.exe'
@@ -105,6 +143,7 @@ stages:
         inputs:
           filePath: eng\common\sdk-task.ps1
           arguments: -task PublishArtifactsInManifest -restore -msbuildEngine dotnet
+            /p:PublishingInfraVersion=2
             /p:IsStableBuild=$(IsStableBuild)
             /p:IsInternalBuild=$(IsInternalBuild)
             /p:RepositoryName=$(Build.Repository.Name)
@@ -119,12 +158,11 @@ stages:
             /p:BlobBasePath='$(Build.ArtifactStagingDirectory)/BlobArtifacts/'
             /p:PackageBasePath='$(Build.ArtifactStagingDirectory)/PackageArtifacts/'
             /p:Configuration=Release
-            /p:PublishInstallersAndChecksums=true
+            /p:PublishInstallersAndChecksums=${{ parameters.publishInstallersAndChecksums }}
             /p:ChecksumsTargetStaticFeed=$(InternalChecksumsBlobFeedUrl)
             /p:ChecksumsAzureAccountKey=$(InternalChecksumsBlobFeedKey)
             /p:InstallersTargetStaticFeed=$(InternalInstallersBlobFeedUrl)
             /p:InstallersAzureAccountKey=$(InternalInstallersBlobFeedKey)
-            /p:PublishToAzureDevOpsNuGetFeeds=true
             /p:AzureDevOpsStaticShippingFeed='${{ parameters.shippingFeed }}'
             /p:AzureDevOpsStaticShippingFeedKey='$(dn-bot-dnceng-artifact-feeds-rw)'
             /p:AzureDevOpsStaticTransportFeed='${{ parameters.transportFeed }}'
@@ -134,6 +172,11 @@ stages:
             /p:PublishToMSDL=false
             ${{ parameters.artifactsPublishingAdditionalParameters }}
 
-      - template: ../../steps/promote-build.yml
+      - template: ../../steps/publish-logs.yml
+        parameters:
+          StageLabel: '${{ parameters.stageName }}'
+          JobLabel: 'AssetsPublishing'
+
+      - template: ../../steps/add-build-to-channel.yml
         parameters:
           ChannelId: ${{ parameters.channelId }}
diff --git a/eng/common/templates/post-build/channels/generic-public-channel.yml b/eng/common/templates/post-build/channels/generic-public-channel.yml
index c4bc1897d81..6cf39dbb290 100644
--- a/eng/common/templates/post-build/channels/generic-public-channel.yml
+++ b/eng/common/templates/post-build/channels/generic-public-channel.yml
@@ -1,6 +1,10 @@
 parameters:
+  BARBuildId: ''
+  PromoteToChannelIds: ''
   artifactsPublishingAdditionalParameters: ''
-  publishInstallersAndChecksums: false
+  dependsOn:
+  - Validate
+  publishInstallersAndChecksums: true
   symbolPublishingAdditionalParameters: ''
   stageName: ''
   channelName: ''
@@ -8,36 +12,50 @@ parameters:
   transportFeed: ''
   shippingFeed: ''
   symbolsFeed: ''
+  # If the channel name is empty, no links will be generated
+  akaMSChannelName: ''
 
 stages:
 - stage: ${{ parameters.stageName }}
-  dependsOn: validate
+  dependsOn: ${{ parameters.dependsOn }}
   variables:
     - template: ../common-variables.yml
   displayName: ${{ parameters.channelName }} Publishing
   jobs:
   - template: ../setup-maestro-vars.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}
 
-  - job:
+  - job: publish_symbols
     displayName: Symbol Publishing
     dependsOn: setupMaestroVars
-    condition: contains(dependencies.setupMaestroVars.outputs['setReleaseVars.InitialChannels'], format('[{0}]', ${{ parameters.channelId }} ))
+    condition: contains(dependencies.setupMaestroVars.outputs['setReleaseVars.TargetChannels'], format('[{0}]', ${{ parameters.channelId }} ))
     variables:
       - group: DotNet-Symbol-Server-Pats
+      - name: AzDOProjectName
+        value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOProjectName'] ]
+      - name: AzDOPipelineId
+        value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOPipelineId'] ]
+      - name: AzDOBuildId
+        value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOBuildId'] ]
     pool:
       vmImage: 'windows-2019'
     steps:
       - task: DownloadBuildArtifacts@0
-        displayName: Download Blob Artifacts
-        inputs:
-          artifactName: 'BlobArtifacts'
+        displayName: Download Build Assets
         continueOnError: true
-
-      - task: DownloadBuildArtifacts@0
-        displayName: Download PDB Artifacts
         inputs:
-          artifactName: 'PDBArtifacts'
-        continueOnError: true
+          buildType: specific
+          buildVersionToDownload: specific
+          project: $(AzDOProjectName)
+          pipeline: $(AzDOPipelineId)
+          buildId: $(AzDOBuildId)
+          downloadType: 'specific'
+          itemPattern: |
+            PdbArtifacts/**
+            BlobArtifacts/**
+          downloadPath: '$(Build.ArtifactStagingDirectory)'
 
       # This is necessary whenever we want to publish/restore to an AzDO private feed
       # Since sdk-task.ps1 tries to restore packages we need to do this authentication here
@@ -64,37 +82,47 @@ stages:
             /p:Configuration=Release
             ${{ parameters.symbolPublishingAdditionalParameters }}
 
+      - template: ../../steps/publish-logs.yml
+        parameters:
+          StageLabel: '${{ parameters.stageName }}'
+          JobLabel: 'SymbolPublishing'
+
   - job: publish_assets
     displayName: Publish Assets
     dependsOn: setupMaestroVars
+    timeoutInMinutes: 120
     variables:
       - name: BARBuildId
         value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.BARBuildId'] ]
       - name: IsStableBuild
         value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.IsStableBuild'] ]
-    condition: contains(dependencies.setupMaestroVars.outputs['setReleaseVars.InitialChannels'], format('[{0}]', ${{ parameters.channelId }}))
+      - name: AzDOProjectName
+        value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOProjectName'] ]
+      - name: AzDOPipelineId
+        value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOPipelineId'] ]
+      - name: AzDOBuildId
+        value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOBuildId'] ]
+      - name: ArtifactsCategory
+        value: ${{ coalesce(variables._DotNetArtifactsCategory, '.NETCore') }}
+    condition: contains(dependencies.setupMaestroVars.outputs['setReleaseVars.TargetChannels'], format('[{0}]', ${{ parameters.channelId }} ))
     pool:
       vmImage: 'windows-2019'
     steps:
       - task: DownloadBuildArtifacts@0
-        displayName: Download Package Artifacts
-        inputs:
-          buildType: current
-          artifactName: PackageArtifacts
+        displayName: Download Build Assets
         continueOnError: true
-
-      - task: DownloadBuildArtifacts@0
-        displayName: Download Blob Artifacts
         inputs:
-          buildType: current
-          artifactName: BlobArtifacts
-        continueOnError: true
-
-      - task: DownloadBuildArtifacts@0
-        displayName: Download Asset Manifests
-        inputs:
-          buildType: current
-          artifactName: AssetManifests
+          buildType: specific
+          buildVersionToDownload: specific
+          project: $(AzDOProjectName)
+          pipeline: $(AzDOPipelineId)
+          buildId: $(AzDOBuildId)
+          downloadType: 'specific'
+          itemPattern: |
+            PackageArtifacts/**
+            BlobArtifacts/**
+            AssetManifests/**
+          downloadPath: '$(Build.ArtifactStagingDirectory)'
 
       - task: NuGetToolInstaller@1
         displayName: 'Install NuGet.exe'
@@ -114,7 +142,8 @@ stages:
         inputs:
           filePath: eng\common\sdk-task.ps1
           arguments: -task PublishArtifactsInManifest -restore -msbuildEngine dotnet
-            /p:ArtifactsCategory=$(_DotNetArtifactsCategory)
+            /p:PublishingInfraVersion=2
+            /p:ArtifactsCategory=$(ArtifactsCategory)
             /p:IsStableBuild=$(IsStableBuild)
             /p:IsInternalBuild=$(IsInternalBuild)
             /p:RepositoryName=$(Build.Repository.Name)
@@ -134,15 +163,22 @@ stages:
             /p:InstallersAzureAccountKey=$(dotnetcli-storage-key)
             /p:ChecksumsTargetStaticFeed=$(ChecksumsBlobFeedUrl)
             /p:ChecksumsAzureAccountKey=$(dotnetclichecksums-storage-key)
-            /p:PublishToAzureDevOpsNuGetFeeds=true
             /p:AzureDevOpsStaticShippingFeed='${{ parameters.shippingFeed }}'
             /p:AzureDevOpsStaticShippingFeedKey='$(dn-bot-dnceng-artifact-feeds-rw)'
             /p:AzureDevOpsStaticTransportFeed='${{ parameters.transportFeed }}'
             /p:AzureDevOpsStaticTransportFeedKey='$(dn-bot-dnceng-artifact-feeds-rw)'
             /p:AzureDevOpsStaticSymbolsFeed='${{ parameters.symbolsFeed }}'
             /p:AzureDevOpsStaticSymbolsFeedKey='$(dn-bot-dnceng-artifact-feeds-rw)'
+            /p:LatestLinkShortUrlPrefix=dotnet/'${{ parameters.akaMSChannelName }}'
+            /p:AkaMSClientId=$(akams-client-id)
+            /p:AkaMSClientSecret=$(akams-client-secret)
             ${{ parameters.artifactsPublishingAdditionalParameters }}
 
-      - template: ../../steps/promote-build.yml
+      - template: ../../steps/publish-logs.yml
+        parameters:
+          StageLabel: '${{ parameters.stageName }}'
+          JobLabel: 'AssetsPublishing'
+
+      - template: ../../steps/add-build-to-channel.yml
         parameters:
           ChannelId: ${{ parameters.channelId }}
diff --git a/eng/common/templates/post-build/common-variables.yml b/eng/common/templates/post-build/common-variables.yml
index 1883d2b1700..c99fd750376 100644
--- a/eng/common/templates/post-build/common-variables.yml
+++ b/eng/common/templates/post-build/common-variables.yml
@@ -4,13 +4,13 @@ variables:
   - group: DotNet-DotNetCli-Storage
   - group: DotNet-MSRC-Storage
   - group: Publish-Build-Assets
-
+    
   # .NET Core 3.1 Dev
   - name: PublicDevRelease_31_Channel_Id
     value: 128
 
-  # .NET Core 5 Dev
-  - name: NetCore_5_Dev_Channel_Id
+  # .NET 5 Dev
+  - name: Net_5_Dev_Channel_Id
     value: 131
 
   # .NET Eng - Validation
@@ -29,6 +29,14 @@ variables:
   - name: NetCore_3_Tools_Channel_Id
     value: 344
 
+  # .NET Core 3.0 Internal Servicing
+  - name: InternalServicing_30_Channel_Id
+    value: 184
+
+  # .NET Core 3.0 Release
+  - name: PublicRelease_30_Channel_Id
+    value: 19
+
   # .NET Core 3.1 Release
   - name: PublicRelease_31_Channel_Id
     value: 129
@@ -41,6 +49,10 @@ variables:
   - name: NetCore_31_Blazor_Features_Channel_Id
     value: 531
 
+  # .NET Core Experimental
+  - name: NetCore_Experimental_Channel_Id
+    value: 562
+
   # Whether the build is internal or not
   - name: IsInternalBuild
     value: ${{ and(ne(variables['System.TeamProject'], 'public'), contains(variables['Build.SourceBranch'], 'internal')) }}
@@ -51,7 +63,7 @@ variables:
   - name: MaestroApiAccessToken
     value: $(MaestroAccessToken)
   - name: MaestroApiVersion
-    value: "2019-01-16"
+    value: "2020-02-20"
 
   - name: SourceLinkCLIVersion
     value: 3.0.0
@@ -78,3 +90,10 @@ variables:
     value: https://dotnetclimsrc.blob.core.windows.net/dotnet/index.json
   - name: InternalInstallersBlobFeedKey
     value: $(dotnetclimsrc-access-key)
+
+  # Skip component governance and codesign validation for SDL. These jobs
+  # create no content.
+  - name: skipComponentGovernanceDetection
+    value: true
+  - name: runCodesignValidationInjection
+    value: false
diff --git a/eng/common/templates/post-build/darc-gather-drop.yml b/eng/common/templates/post-build/darc-gather-drop.yml
deleted file mode 100644
index 3268ccaa551..00000000000
--- a/eng/common/templates/post-build/darc-gather-drop.yml
+++ /dev/null
@@ -1,23 +0,0 @@
-parameters:
-  ChannelId: 0
-
-jobs:
-- job: gatherDrop
-  displayName: Gather Drop
-  dependsOn: setupMaestroVars
-  condition: contains(dependencies.setupMaestroVars.outputs['setReleaseVars.InitialChannels'], format('[{0}]', ${{ parameters.ChannelId }}))
-  variables:
-    - name: BARBuildId
-      value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.BARBuildId'] ]
-  pool:
-    vmImage: 'windows-2019'
-  steps:
-    - task: PowerShell@2
-      displayName: Darc gather-drop
-      inputs:
-        filePath: $(Build.SourcesDirectory)/eng/common/post-build/darc-gather-drop.ps1
-        arguments: -BarBuildId $(BARBuildId) 
-          -DropLocation $(Agent.BuildDirectory)/Temp/Drop/ 
-          -MaestroApiAccessToken $(MaestroApiAccessToken)
-          -MaestroApiEndPoint $(MaestroApiEndPoint)
-          -MaestroApiVersion $(MaestroApiVersion)
diff --git a/eng/common/templates/post-build/post-build.yml b/eng/common/templates/post-build/post-build.yml
index 8ad0f9f66c2..1b0af40d52f 100644
--- a/eng/common/templates/post-build/post-build.yml
+++ b/eng/common/templates/post-build/post-build.yml
@@ -1,39 +1,124 @@
 parameters:
+ # Which publishing infra should be used. THIS SHOULD MATCH THE VERSION ON THE BUILD MANIFEST.
+  # Publishing V2 accepts optionally outlining the publishing stages - default is inline.
+  # Publishing V3 DOES NOT accept inlining the publishing stages.
+  publishingInfraVersion: 2
+  # When set to true the publishing templates from the repo will be used
+  # otherwise Darc add-build-to-channel will be used to trigger the promotion pipeline
+  inline: true
+
+  # Only used if inline==false. When set to true will stall the current build until
+  # the Promotion Pipeline build finishes. Otherwise, the current build will continue 
+  # execution concurrently with the promotion build.
+  waitPublishingFinish: true
+
+  BARBuildId: ''
+  PromoteToChannelIds: ''
+
   enableSourceLinkValidation: false
   enableSigningValidation: true
   enableSymbolValidation: false
   enableNugetValidation: true
-  publishInstallersAndChecksums: false
+  publishInstallersAndChecksums: true
   SDLValidationParameters:
     enable: false
     continueOnError: false
     params: ''
     artifactNames: ''
+    downloadArtifacts: true
 
   # These parameters let the user customize the call to sdk-task.ps1 for publishing
   # symbols & general artifacts as well as for signing validation
   symbolPublishingAdditionalParameters: ''
   artifactsPublishingAdditionalParameters: ''
   signingValidationAdditionalParameters: ''
+  useBuildManifest: false
 
   # Which stages should finish execution before post-build stages start
-  dependsOn: [build]
+  validateDependsOn:
+  - build
+  publishDependsOn: 
+  - Validate
+
+  # Channel ID's instantiated in this file.
+  # When adding a new channel implementation the call to `check-channel-consistency.ps1` 
+  # needs to be updated with the new channel ID
+  NetEngLatestChannelId: 2
+  NetEngValidationChannelId: 9
+  NetDev5ChannelId: 131
+  NetDev6ChannelId: 1296
+  GeneralTestingChannelId: 529
+  NETCoreToolingDevChannelId: 548
+  NETCoreToolingReleaseChannelId: 549
+  NETInternalToolingChannelId: 551
+  NETCoreExperimentalChannelId: 562
+  NetEngServicesIntChannelId: 678
+  NetEngServicesProdChannelId: 679
+  Net5Preview8ChannelId: 1155
+  Net5RC1ChannelId: 1157
+  Net5RC2ChannelId: 1329
+  NetCoreSDK313xxChannelId: 759
+  NetCoreSDK313xxInternalChannelId: 760
+  NetCoreSDK314xxChannelId: 921
+  NetCoreSDK314xxInternalChannelId: 922
+  VS166ChannelId: 1010
+  VS167ChannelId: 1011
+  VS168ChannelId: 1154
+  VSMasterChannelId: 1012
+  VS169ChannelId: 1473
+  VS1610ChannelId: 1692
 
 stages:
-- stage: validate
-  dependsOn: ${{ parameters.dependsOn }}
-  displayName: Validate
-  jobs:
-  - ${{ if eq(parameters.enableNugetValidation, 'true') }}:
+- ${{ if or(and(le(parameters.publishingInfraVersion, 2), eq(parameters.inline, 'true')), eq( parameters.enableNugetValidation, 'true'), eq(parameters.enableSigningValidation, 'true'), eq(parameters.enableSourceLinkValidation, 'true'), eq(parameters.SDLValidationParameters.enable, 'true')) }}:
+  - stage: Validate
+    dependsOn: ${{ parameters.validateDependsOn }}
+    displayName: Validate Build Assets
+    variables:
+      - template: common-variables.yml
+    jobs:
+    - template: setup-maestro-vars.yml
+      parameters:
+        BARBuildId: ${{ parameters.BARBuildId }}
+        PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}
+
+    - ${{ if and(le(parameters.publishingInfraVersion, 2), eq(parameters.inline, 'true')) }}:
+      - job:
+        displayName: Post-build Checks
+        dependsOn: setupMaestroVars
+        variables:
+          - name: TargetChannels
+            value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.TargetChannels'] ]
+        pool:
+          vmImage: 'windows-2019'
+        steps:
+          - task: PowerShell@2
+            displayName: Maestro Channels Consistency
+            inputs:
+              filePath: $(Build.SourcesDirectory)/eng/common/post-build/check-channel-consistency.ps1
+              arguments: -PromoteToChannels "$(TargetChannels)"
+                -AvailableChannelIds ${{parameters.NetEngLatestChannelId}},${{parameters.NetEngValidationChannelId}},${{parameters.NetDev5ChannelId}},${{parameters.NetDev6ChannelId}},${{parameters.GeneralTestingChannelId}},${{parameters.NETCoreToolingDevChannelId}},${{parameters.NETCoreToolingReleaseChannelId}},${{parameters.NETInternalToolingChannelId}},${{parameters.NETCoreExperimentalChannelId}},${{parameters.NetEngServicesIntChannelId}},${{parameters.NetEngServicesProdChannelId}},${{parameters.Net5Preview8ChannelId}},${{parameters.Net5RC1ChannelId}},${{parameters.Net5RC2ChannelId}},${{parameters.NetCoreSDK313xxChannelId}},${{parameters.NetCoreSDK313xxInternalChannelId}},${{parameters.NetCoreSDK314xxChannelId}},${{parameters.NetCoreSDK314xxInternalChannelId}},${{parameters.VS166ChannelId}},${{parameters.VS167ChannelId}},${{parameters.VS168ChannelId}},${{parameters.VSMasterChannelId}},${{parameters.VS169ChannelId}},${{parameters.VS1610ChannelId}}                
     - job:
       displayName: NuGet Validation
+      dependsOn: setupMaestroVars
+      condition: eq( ${{ parameters.enableNugetValidation }}, 'true')
       pool:
         vmImage: 'windows-2019'
+      variables:
+        - name: AzDOProjectName
+          value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOProjectName'] ]
+        - name: AzDOPipelineId
+          value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOPipelineId'] ]
+        - name: AzDOBuildId
+          value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOBuildId'] ]
       steps:
         - task: DownloadBuildArtifacts@0
           displayName: Download Package Artifacts
           inputs:
-            buildType: current
+            buildType: specific
+            buildVersionToDownload: specific
+            project: $(AzDOProjectName)
+            pipeline: $(AzDOPipelineId)
+            buildId: $(AzDOBuildId)
             artifactName: PackageArtifacts
 
         - task: PowerShell@2
@@ -43,46 +128,92 @@ stages:
             arguments: -PackagesPath $(Build.ArtifactStagingDirectory)/PackageArtifacts/ 
               -ToolDestinationPath $(Agent.BuildDirectory)/Extract/ 
 
-  - ${{ if eq(parameters.enableSigningValidation, 'true') }}:
     - job:
       displayName: Signing Validation
+      dependsOn: setupMaestroVars
+      condition: eq( ${{ parameters.enableSigningValidation }}, 'true')
+      variables:
+        - template: common-variables.yml
+        - name: AzDOProjectName
+          value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOProjectName'] ]
+        - name: AzDOPipelineId
+          value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOPipelineId'] ]
+        - name: AzDOBuildId
+          value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOBuildId'] ]
       pool:
         vmImage: 'windows-2019'
       steps:
+        - ${{ if eq(parameters.useBuildManifest, true) }}:
+          - task: DownloadBuildArtifacts@0
+            displayName: Download build manifest
+            inputs:
+              buildType: specific
+              buildVersionToDownload: specific
+              project: $(AzDOProjectName)
+              pipeline: $(AzDOPipelineId)
+              buildId: $(AzDOBuildId)
+              artifactName: BuildManifests
+        - task: DownloadBuildArtifacts@0
+          displayName: Download Package Artifacts
+          inputs:
+            buildType: specific
+            buildVersionToDownload: specific
+            project: $(AzDOProjectName)
+            pipeline: $(AzDOPipelineId)
+            buildId: $(AzDOBuildId)
+            artifactName: PackageArtifacts
+
         # This is necessary whenever we want to publish/restore to an AzDO private feed
         # Since sdk-task.ps1 tries to restore packages we need to do this authentication here
         # otherwise it'll complain about accessing a private feed.
         - task: NuGetAuthenticate@0
           displayName: 'Authenticate to AzDO Feeds'
 
-        - task: DownloadBuildArtifacts@0
-          displayName: Download Package Artifacts
+        - task: PowerShell@2
+          displayName: Enable cross-org publishing
           inputs:
-            buildType: current
-            artifactName: PackageArtifacts
+            filePath: eng\common\enable-cross-org-publishing.ps1
+            arguments: -token $(dn-bot-dnceng-artifact-feeds-rw)
 
+        # Signing validation will optionally work with the buildmanifest file which is downloaded from
+        # Azure DevOps above.
         - task: PowerShell@2
           displayName: Validate
           inputs:
             filePath: eng\common\sdk-task.ps1
-            arguments: -task SigningValidation -restore -msbuildEngine dotnet
+            arguments: -task SigningValidation -restore -msbuildEngine vs
               /p:PackageBasePath='$(Build.ArtifactStagingDirectory)/PackageArtifacts'
               /p:SignCheckExclusionsFile='$(Build.SourcesDirectory)/eng/SignCheckExclusionsFile.txt'
-              /p:Configuration=Release 
               ${{ parameters.signingValidationAdditionalParameters }}
 
-  - ${{ if eq(parameters.enableSourceLinkValidation, 'true') }}:
+        - template: ../steps/publish-logs.yml
+          parameters:
+            StageLabel: 'Validation'
+            JobLabel: 'Signing'
+
     - job:
       displayName: SourceLink Validation
+      dependsOn: setupMaestroVars
+      condition: eq( ${{ parameters.enableSourceLinkValidation }}, 'true')
       variables:
         - template: common-variables.yml
+        - name: AzDOProjectName
+          value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOProjectName'] ]
+        - name: AzDOPipelineId
+          value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOPipelineId'] ]
+        - name: AzDOBuildId
+          value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOBuildId'] ]
       pool:
         vmImage: 'windows-2019'
       steps:
         - task: DownloadBuildArtifacts@0
           displayName: Download Blob Artifacts
           inputs:
-            buildType: current
+            buildType: specific
+            buildVersionToDownload: specific
+            project: $(AzDOProjectName)
+            pipeline: $(AzDOPipelineId)
+            buildId: $(AzDOBuildId)
             artifactName: BlobArtifacts
 
         - task: PowerShell@2
@@ -96,297 +227,415 @@ stages:
               -SourcelinkCliVersion $(SourceLinkCLIVersion)
           continueOnError: true
 
-  - ${{ if eq(parameters.SDLValidationParameters.enable, 'true') }}:
     - template: /eng/common/templates/job/execute-sdl.yml
       parameters:
+        enable: ${{ parameters.SDLValidationParameters.enable }}
+        dependsOn: setupMaestroVars
         additionalParameters: ${{ parameters.SDLValidationParameters.params }}
         continueOnError: ${{ parameters.SDLValidationParameters.continueOnError }}
         artifactNames: ${{ parameters.SDLValidationParameters.artifactNames }}
+        downloadArtifacts: ${{ parameters.SDLValidationParameters.downloadArtifacts }}
+
+- ${{ if or(ge(parameters.publishingInfraVersion, 3), eq(parameters.inline, 'false')) }}:
+  - stage: publish_using_darc
+    ${{ if or(eq(parameters.enableNugetValidation, 'true'), eq(parameters.enableSigningValidation, 'true'), eq(parameters.enableSourceLinkValidation, 'true'), eq(parameters.SDLValidationParameters.enable, 'true')) }}:
+      dependsOn: Validate
+    ${{ if and(ne(parameters.enableNugetValidation, 'true'), ne(parameters.enableSigningValidation, 'true'), ne(parameters.enableSourceLinkValidation, 'true'), ne(parameters.SDLValidationParameters.enable, 'true')) }}:
+      dependsOn: ${{ parameters.validateDependsOn }}
+    displayName: Publish using Darc
+    variables:
+      - template: common-variables.yml
+    jobs:
+    - template: setup-maestro-vars.yml
+      parameters:
+        BARBuildId: ${{ parameters.BARBuildId }}
+        PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}
 
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NetCore_Dev31_Publish'
-    channelName: '.NET Core 3.1 Dev'
-    channelId: 128
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'Net_Eng_Latest_Publish'
-    channelName: '.NET Eng - Latest'
-    channelId: 2
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'Net_Eng_Validation_Publish'
-    channelName: '.NET Eng - Validation'
-    channelId: 9
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NetCore_3_Tools_Validation_Publish'
-    channelName: '.NET 3 Tools - Validation'
-    channelId: 390
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NetCore_3_Tools_Publish'
-    channelName: '.NET 3 Tools'
-    channelId: 344
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NetCore_Release31_Publish'
-    channelName: '.NET Core 3.1 Release'
-    channelId: 129
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NetCore_Blazor31_Features_Publish'
-    channelName: '.NET Core 3.1 Blazor Features'
-    channelId: 531
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-blazor/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-blazor/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-blazor-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-internal-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NetCore_31_Internal_Servicing_Publishing'
-    channelName: '.NET Core 3.1 Internal Servicing'
-    channelId: 550
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'General_Testing_Publish'
-    channelName: 'General Testing'
-    channelId: 529
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/general-testing/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/general-testing/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/general-testing-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NETCore_Tooling_Dev_Publishing'
-    channelName: '.NET Core Tooling Dev'
-    channelId: 548
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NETCore_Tooling_Release_Publishing'
-    channelName: '.NET Core Tooling Release'
-    channelId: 549
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NETCore_SDK_311xx_Publishing'
-    channelName: '.NET Core SDK 3.1.1xx'
-    channelId: 560
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-internal-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NETCore_SDK_311xx_Internal_Publishing'
-    channelName: '.NET Core SDK 3.1.1xx Internal'
-    channelId: 559
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NETCore_SDK_312xx_Publishing'
-    channelName: '.NET Core SDK 3.1.2xx'
-    channelId: 558
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-internal-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NETCore_SDK_312xx_Internal_Publishing'
-    channelName: '.NET Core SDK 3.1.2xx Internal'
-    channelId: 557
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NETCore_SDK_313xx_Publishing'
-    channelName: '.NET Core SDK 3.1.3xx'
-    channelId: 759
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-internal-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NETCore_SDK_313xx_Internal_Publishing'
-    channelName: '.NET Core SDK 3.1.3xx Internal'
-    channelId: 760
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-symbols/nuget/v3/index.json'
-    
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NETCore_SDK_314xx_Publishing'
-    channelName: '.NET Core SDK 3.1.4xx'
-    channelId: 921
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-internal-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NETCore_SDK_314xx_Internal_Publishing'
-    channelName: '.NET Core SDK 3.1.4xx Internal'
-    channelId: 922
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'VS16_6_Publishing'
-    channelName: 'VS 16.6'
-    channelId: 1010
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'VS16_7_Publishing'
-    channelName: 'VS 16.7'
-    channelId: 1011
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'VS16_8_Publishing'
-    channelName: 'VS 16.8'
-    channelId: 1154
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'VS16_9_Publishing'
-    channelName: 'VS 16.9'
-    channelId: 1473
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'VS_Master_Publishing'
-    channelName: 'VS Master'
-    channelId: 1012
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
\ No newline at end of file
+    - job:
+      displayName: Publish Using Darc
+      dependsOn: setupMaestroVars
+      variables:
+        - name: BARBuildId
+          value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.BARBuildId'] ]
+      pool:
+        vmImage: 'windows-2019'
+      steps:
+        - task: PowerShell@2
+          displayName: Publish Using Darc
+          inputs:
+            filePath: $(Build.SourcesDirectory)/eng/common/post-build/publish-using-darc.ps1
+            arguments: -BuildId $(BARBuildId) 
+              -PublishingInfraVersion ${{ parameters.PublishingInfraVersion }}
+              -AzdoToken '$(publishing-dnceng-devdiv-code-r-build-re)'
+              -MaestroToken '$(MaestroApiAccessToken)'
+              -WaitPublishingFinish ${{ parameters.waitPublishingFinish }}
+              -PublishInstallersAndChecksums ${{ parameters.publishInstallersAndChecksums }}
+
+- ${{ if and(le(parameters.publishingInfraVersion, 2), eq(parameters.inline, 'true')) }}:
+  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}    
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'NetCore_Dev5_Publish'
+      channelName: '.NET 5 Dev'
+      akaMSChannelName: 'net5/dev'
+      channelId: ${{ parameters.NetDev5ChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5-transport/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5-symbols/nuget/v3/index.json'
+
+  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'NetCore_Dev6_Publish'
+      channelName: '.NET 6 Dev'
+      akaMSChannelName: 'net6/dev'
+      channelId: ${{ parameters.NetDev6ChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet6-transport/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet6/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet6-symbols/nuget/v3/index.json'
+
+  - template: \eng\common\templates\post-build\channels\generic-internal-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}    
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'Net5_Preview8_Publish'
+      channelName: '.NET 5 Preview 8'
+      akaMSChannelName: 'net5/preview8'
+      channelId: ${{ parameters.Net5Preview8ChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet5-internal-transport/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet5-internal/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet5-internal-symbols/nuget/v3/index.json'
+
+  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'Net5_RC1_Publish'
+      channelName: '.NET 5 RC 1'
+      akaMSChannelName: 'net5/rc1'
+      channelId: ${{ parameters.Net5RC1ChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5-transport/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5-symbols/nuget/v3/index.json'
+
+  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'Net5_RC2_Publish'
+      channelName: '.NET 5 RC 2'
+      akaMSChannelName: 'net5/rc2'
+      channelId: ${{ parameters.Net5RC2ChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5-transport/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5-symbols/nuget/v3/index.json'
+
+  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'Net_Eng_Latest_Publish'
+      channelName: '.NET Eng - Latest'
+      akaMSChannelName: 'eng/daily'
+      channelId: ${{ parameters.NetEngLatestChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng-symbols/nuget/v3/index.json'
+
+  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}    
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'Net_Eng_Validation_Publish'
+      channelName: '.NET Eng - Validation'
+      akaMSChannelName: 'eng/validation'
+      channelId: ${{ parameters.NetEngValidationChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng-symbols/nuget/v3/index.json'
+
+  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}    
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'General_Testing_Publish'
+      channelName: 'General Testing'
+      akaMSChannelName: 'generaltesting'
+      channelId: ${{ parameters.GeneralTestingChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/general-testing/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/general-testing/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/general-testing-symbols/nuget/v3/index.json'
+
+  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}    
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'NETCore_Tooling_Dev_Publishing'
+      channelName: '.NET Core Tooling Dev'
+      channelId: ${{ parameters.NETCoreToolingDevChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
+
+  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}    
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'NETCore_Tooling_Release_Publishing'
+      channelName: '.NET Core Tooling Release'
+      channelId: ${{ parameters.NETCoreToolingReleaseChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
+
+  - template: \eng\common\templates\post-build\channels\generic-internal-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}    
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'NET_Internal_Tooling_Publishing'
+      channelName: '.NET Internal Tooling'
+      channelId: ${{ parameters.NETInternalToolingChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet-tools-internal/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet-tools-internal/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet-tools-internal-symbols/nuget/v3/index.json'
+
+  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}    
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'NETCore_Experimental_Publishing'
+      channelName: '.NET Core Experimental'
+      channelId: ${{ parameters.NETCoreExperimentalChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-experimental/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-experimental/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-experimental-symbols/nuget/v3/index.json'
+
+  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}    
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'Net_Eng_Services_Int_Publish'
+      channelName: '.NET Eng Services - Int'
+      channelId: ${{ parameters.NetEngServicesIntChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng-symbols/nuget/v3/index.json'
+
+  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}    
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'Net_Eng_Services_Prod_Publish'
+      channelName: '.NET Eng Services - Prod'
+      channelId: ${{ parameters.NetEngServicesProdChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng-symbols/nuget/v3/index.json'
+
+  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}    
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'NETCore_SDK_314xx_Publishing'
+      channelName: '.NET Core SDK 3.1.4xx'
+      channelId: ${{ parameters.NetCoreSDK314xxChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-transport/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-symbols/nuget/v3/index.json'
+
+  - template: \eng\common\templates\post-build\channels\generic-internal-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}    
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'NETCore_SDK_314xx_Internal_Publishing'
+      channelName: '.NET Core SDK 3.1.4xx Internal'
+      channelId: ${{ parameters.NetCoreSDK314xxInternalChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-transport/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-symbols/nuget/v3/index.json' 
+
+  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}    
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'NETCore_SDK_313xx_Publishing'
+      channelName: '.NET Core SDK 3.1.3xx'
+      channelId: ${{ parameters.NetCoreSDK313xxChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-transport/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-symbols/nuget/v3/index.json'
+
+  - template: \eng\common\templates\post-build\channels\generic-internal-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}    
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'NETCore_SDK_313xx_Internal_Publishing'
+      channelName: '.NET Core SDK 3.1.3xx Internal'
+      channelId: ${{ parameters.NetCoreSDK313xxInternalChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-transport/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-symbols/nuget/v3/index.json' 
+
+  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}    
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'VS16_6_Publishing'
+      channelName: 'VS 16.6'
+      channelId: ${{ parameters.VS166ChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-transport/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
+
+  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}    
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'VS16_7_Publishing'
+      channelName: 'VS 16.7'
+      channelId: ${{ parameters.VS167ChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-transport/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
+      
+  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}    
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'VS16_8_Publishing'
+      channelName: 'VS 16.8'
+      channelId: ${{ parameters.VS168ChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-transport/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
+
+  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}    
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'VS_Master_Publishing'
+      channelName: 'VS Master'
+      channelId: ${{ parameters.VSMasterChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-transport/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
+
+  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}    
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'VS_16_9_Publishing'
+      channelName: 'VS 16.9'
+      channelId: ${{ parameters.VS169ChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-transport/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
+
+  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}    
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'VS_16_10_Publishing'
+      channelName: 'VS 16.10'
+      channelId: ${{ parameters.VS1610ChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-transport/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
diff --git a/eng/common/templates/post-build/promote-build.yml b/eng/common/templates/post-build/promote-build.yml
deleted file mode 100644
index 6b479c3b82a..00000000000
--- a/eng/common/templates/post-build/promote-build.yml
+++ /dev/null
@@ -1,25 +0,0 @@
-parameters:
-  ChannelId: 0
-
-jobs:
-- job:
-  displayName: Promote Build
-  dependsOn: setupMaestroVars
-  condition: contains(dependencies.setupMaestroVars.outputs['setReleaseVars.InitialChannels'], format('[{0}]', ${{ parameters.ChannelId }}))
-  variables:
-    - name: BARBuildId
-      value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.BARBuildId'] ]
-    - name: ChannelId
-      value: ${{ parameters.ChannelId }}
-  pool:
-    vmImage: 'windows-2019'
-  steps:
-    - task: PowerShell@2
-      displayName: Add Build to Channel
-      inputs:
-        filePath: $(Build.SourcesDirectory)/eng/common/post-build/promote-build.ps1
-        arguments: -BuildId $(BARBuildId) 
-          -ChannelId $(ChannelId) 
-          -MaestroApiAccessToken $(MaestroApiAccessToken)
-          -MaestroApiEndPoint $(MaestroApiEndPoint)
-          -MaestroApiVersion $(MaestroApiVersion)
diff --git a/eng/common/templates/post-build/setup-maestro-vars.yml b/eng/common/templates/post-build/setup-maestro-vars.yml
index 56242b068e1..d0cbfb6c6ff 100644
--- a/eng/common/templates/post-build/setup-maestro-vars.yml
+++ b/eng/common/templates/post-build/setup-maestro-vars.yml
@@ -1,18 +1,77 @@
+parameters:
+  BARBuildId: ''
+  PromoteToChannelIds: ''
+
 jobs:
 - job: setupMaestroVars
   displayName: Setup Maestro Vars
+  variables:
+    - template: common-variables.yml
   pool:
     vmImage: 'windows-2019'
   steps:
-    - task: DownloadBuildArtifacts@0
-      displayName: Download Release Configs
-      inputs:
-        buildType: current
-        artifactName: ReleaseConfigs
+    - checkout: none
+
+    - ${{ if eq(coalesce(parameters.PromoteToChannelIds, 0), 0) }}:
+      - task: DownloadBuildArtifacts@0
+        displayName: Download Release Configs
+        inputs:
+          buildType: current
+          artifactName: ReleaseConfigs
 
     - task: PowerShell@2
       name: setReleaseVars
       displayName: Set Release Configs Vars
       inputs:
-        filePath: $(Build.SourcesDirectory)/eng/common/post-build/setup-maestro-vars.ps1
-        arguments: -ReleaseConfigsPath '$(Build.StagingDirectory)/ReleaseConfigs/ReleaseConfigs.txt'
+        targetType: inline
+        script: |
+          try {
+            if (!$Env:PromoteToMaestroChannels -or $Env:PromoteToMaestroChannels.Trim() -eq '') {
+              $Content = Get-Content $(Build.StagingDirectory)/ReleaseConfigs/ReleaseConfigs.txt
+
+              $BarId = $Content | Select -Index 0
+              $Channels = $Content | Select -Index 1             
+              $IsStableBuild = $Content | Select -Index 2
+
+              $AzureDevOpsProject = $Env:System_TeamProject
+              $AzureDevOpsBuildDefinitionId = $Env:System_DefinitionId
+              $AzureDevOpsBuildId = $Env:Build_BuildId
+            }
+            else {
+              $buildApiEndpoint = "${Env:MaestroApiEndPoint}/api/builds/${Env:BARBuildId}?api-version=${Env:MaestroApiVersion}"
+
+              $apiHeaders = New-Object 'System.Collections.Generic.Dictionary[[String],[String]]'
+              $apiHeaders.Add('Accept', 'application/json')
+              $apiHeaders.Add('Authorization',"Bearer ${Env:MAESTRO_API_TOKEN}")
+
+              $buildInfo = try { Invoke-WebRequest -Method Get -Uri $buildApiEndpoint -Headers $apiHeaders | ConvertFrom-Json } catch { Write-Host "Error: $_" }
+             
+              $BarId = $Env:BARBuildId
+              $Channels = $Env:PromoteToMaestroChannels -split ","
+              $Channels = $Channels -join "]["
+              $Channels = "[$Channels]"
+
+              $IsStableBuild = $buildInfo.stable
+              $AzureDevOpsProject = $buildInfo.azureDevOpsProject
+              $AzureDevOpsBuildDefinitionId = $buildInfo.azureDevOpsBuildDefinitionId
+              $AzureDevOpsBuildId = $buildInfo.azureDevOpsBuildId
+            }
+
+            Write-Host "##vso[task.setvariable variable=BARBuildId;isOutput=true]$BarId"
+            Write-Host "##vso[task.setvariable variable=TargetChannels;isOutput=true]$Channels"
+            Write-Host "##vso[task.setvariable variable=IsStableBuild;isOutput=true]$IsStableBuild"
+
+            Write-Host "##vso[task.setvariable variable=AzDOProjectName;isOutput=true]$AzureDevOpsProject"
+            Write-Host "##vso[task.setvariable variable=AzDOPipelineId;isOutput=true]$AzureDevOpsBuildDefinitionId"
+            Write-Host "##vso[task.setvariable variable=AzDOBuildId;isOutput=true]$AzureDevOpsBuildId"
+          }
+          catch {
+            Write-Host $_
+            Write-Host $_.Exception
+            Write-Host $_.ScriptStackTrace
+            exit 1
+          }
+      env:
+        MAESTRO_API_TOKEN: $(MaestroApiAccessToken)
+        BARBuildId: ${{ parameters.BARBuildId }}
+        PromoteToMaestroChannels: ${{ parameters.PromoteToChannelIds }}
diff --git a/eng/common/templates/steps/promote-build.yml b/eng/common/templates/steps/add-build-to-channel.yml
similarity index 68%
rename from eng/common/templates/steps/promote-build.yml
rename to eng/common/templates/steps/add-build-to-channel.yml
index b90404435dd..f67a210d62f 100644
--- a/eng/common/templates/steps/promote-build.yml
+++ b/eng/common/templates/steps/add-build-to-channel.yml
@@ -5,9 +5,9 @@ steps:
 - task: PowerShell@2
   displayName: Add Build to Channel
   inputs:
-    filePath: $(Build.SourcesDirectory)/eng/common/post-build/promote-build.ps1
+    filePath: $(Build.SourcesDirectory)/eng/common/post-build/add-build-to-channel.ps1
     arguments: -BuildId $(BARBuildId) 
       -ChannelId ${{ parameters.ChannelId }}
       -MaestroApiAccessToken $(MaestroApiAccessToken)
       -MaestroApiEndPoint $(MaestroApiEndPoint)
-      -MaestroApiVersion $(MaestroApiVersion)
+      -MaestroApiVersion $(MaestroApiVersion) 
diff --git a/eng/common/templates/steps/perf-send-to-helix.yml b/eng/common/templates/steps/perf-send-to-helix.yml
index b3ea9acf1f1..a468e92ce44 100644
--- a/eng/common/templates/steps/perf-send-to-helix.yml
+++ b/eng/common/templates/steps/perf-send-to-helix.yml
@@ -1,5 +1,6 @@
 # Please remember to update the documentation if you make changes to these parameters!
 parameters:
+  ProjectFile: ''                        # required -- project file that specifies the helix workitems
   HelixSource: 'pr/default'              # required -- sources must start with pr/, official/, prodcon/, or agent/
   HelixType: 'tests/default/'            # required -- Helix telemetry which identifies what type of data this is; should include "test" for clarity and must end in '/'
   HelixBuild: $(Build.BuildNumber)       # required -- the build number Helix will use to identify this -- automatically set to the AzDO build number
@@ -10,7 +11,7 @@ parameters:
   WorkItemDirectory: ''                  # optional -- a payload directory to zip up and send to Helix; requires WorkItemCommand; incompatible with XUnitProjects
   CorrelationPayloadDirectory: ''        # optional -- a directory to zip up and send to Helix as a correlation payload
   IncludeDotNetCli: false                # optional -- true will download a version of the .NET CLI onto the Helix machine as a correlation payload; requires DotNetCliPackageType and DotNetCliVersion
-  DotNetCliPackageType: ''               # optional -- either 'sdk' or 'runtime'; determines whether the sdk or runtime will be sent to Helix; see https://raw.githubusercontent.com/dotnet/core/master/release-notes/releases.json
+  DotNetCliPackageType: ''               # optional -- either 'sdk', 'runtime' or 'aspnetcore-runtime'; determines whether the sdk or runtime will be sent to Helix; see https://raw.githubusercontent.com/dotnet/core/master/release-notes/releases.json
   DotNetCliVersion: ''                   # optional -- version of the CLI to send to Helix; based on this: https://raw.githubusercontent.com/dotnet/core/master/release-notes/releases.json
   EnableXUnitReporter: false             # optional -- true enables XUnit result reporting to Mission Control
   WaitForWorkItemCompletion: true        # optional -- true will make the task wait until work items have been completed and fail the build if work items fail. False is "fire and forget."
@@ -18,33 +19,18 @@ parameters:
   DisplayNamePrefix: 'Send job to Helix' # optional -- rename the beginning of the displayName of the steps in AzDO 
   condition: succeeded()                 # optional -- condition for step to execute; defaults to succeeded()
   continueOnError: false                 # optional -- determines whether to continue the build if the step errors; defaults to false
+  osGroup: ''                            # required -- operating system for the job
+            
 
 steps:
-  - powershell: $(Build.SourcesDirectory)\eng\common\msbuild.ps1 $(Build.SourcesDirectory)\eng\common\performance\perfhelixpublish.proj /restore /t:Test /bl:$(Build.SourcesDirectory)\artifacts\log\$env:BuildConfig\SendToHelix.binlog
-    displayName: ${{ parameters.DisplayNamePrefix }} (Windows)
-    env:
-      BuildConfig: $(_BuildConfig)
-      HelixSource: ${{ parameters.HelixSource }}
-      HelixType: ${{ parameters.HelixType }}
-      HelixBuild: ${{ parameters.HelixBuild }}
-      HelixTargetQueues: ${{ parameters.HelixTargetQueues }}
-      HelixAccessToken: ${{ parameters.HelixAccessToken }}
-      HelixPreCommands: ${{ parameters.HelixPreCommands }}
-      HelixPostCommands: ${{ parameters.HelixPostCommands }}
-      WorkItemDirectory: ${{ parameters.WorkItemDirectory }}
-      CorrelationPayloadDirectory: ${{ parameters.CorrelationPayloadDirectory }}
-      IncludeDotNetCli: ${{ parameters.IncludeDotNetCli }}
-      DotNetCliPackageType: ${{ parameters.DotNetCliPackageType }}
-      DotNetCliVersion: ${{ parameters.DotNetCliVersion }}
-      EnableXUnitReporter: ${{ parameters.EnableXUnitReporter }}
-      WaitForWorkItemCompletion: ${{ parameters.WaitForWorkItemCompletion }}
-      Creator: ${{ parameters.Creator }}
-      SYSTEM_ACCESSTOKEN: $(System.AccessToken)
-    condition: and(${{ parameters.condition }}, eq(variables['Agent.Os'], 'Windows_NT'))
+- template: /eng/pipelines/common/templates/runtimes/send-to-helix-inner-step.yml
+  parameters:
+    osGroup: ${{ parameters.osGroup }}
+    sendParams: $(Build.SourcesDirectory)/eng/common/performance/${{ parameters.ProjectFile }} /restore /t:Test /bl:$(Build.SourcesDirectory)/artifacts/log/$(_BuildConfig)/SendToHelix.binlog
+    displayName: ${{ parameters.DisplayNamePrefix }}
+    condition: ${{ parameters.condition }}
     continueOnError: ${{ parameters.continueOnError }}
-  - script: $BUILD_SOURCESDIRECTORY/eng/common/msbuild.sh $BUILD_SOURCESDIRECTORY/eng/common/performance/perfhelixpublish.proj /restore /t:Test /bl:$BUILD_SOURCESDIRECTORY/artifacts/log/$BuildConfig/SendToHelix.binlog
-    displayName: ${{ parameters.DisplayNamePrefix }} (Unix)
-    env:
+    environment:
       BuildConfig: $(_BuildConfig)
       HelixSource: ${{ parameters.HelixSource }}
       HelixType: ${{ parameters.HelixType }}
@@ -62,5 +48,3 @@ steps:
       WaitForWorkItemCompletion: ${{ parameters.WaitForWorkItemCompletion }}
       Creator: ${{ parameters.Creator }}
       SYSTEM_ACCESSTOKEN: $(System.AccessToken)
-    condition: and(${{ parameters.condition }}, ne(variables['Agent.Os'], 'Windows_NT'))
-    continueOnError: ${{ parameters.continueOnError }}
diff --git a/eng/common/templates/steps/publish-logs.yml b/eng/common/templates/steps/publish-logs.yml
new file mode 100644
index 00000000000..88f238f36bf
--- /dev/null
+++ b/eng/common/templates/steps/publish-logs.yml
@@ -0,0 +1,23 @@
+parameters:
+  StageLabel: ''
+  JobLabel: ''
+
+steps:
+- task: Powershell@2
+  displayName: Prepare Binlogs to Upload
+  inputs:
+    targetType: inline
+    script: |
+      New-Item -ItemType Directory $(Build.SourcesDirectory)/PostBuildLogs/${{parameters.StageLabel}}/${{parameters.JobLabel}}/
+      Move-Item -Path $(Build.SourcesDirectory)/artifacts/log/Debug/* $(Build.SourcesDirectory)/PostBuildLogs/${{parameters.StageLabel}}/${{parameters.JobLabel}}/
+  continueOnError: true
+  condition: always()
+
+- task: PublishBuildArtifacts@1
+  displayName: Publish Logs
+  inputs:
+    PathtoPublish: '$(Build.SourcesDirectory)/PostBuildLogs'
+    PublishLocation: Container
+    ArtifactName: PostBuildLogs
+  continueOnError: true
+  condition: always()
diff --git a/eng/common/templates/steps/send-to-helix.yml b/eng/common/templates/steps/send-to-helix.yml
index 05df886f55f..bb5f1a92938 100644
--- a/eng/common/templates/steps/send-to-helix.yml
+++ b/eng/common/templates/steps/send-to-helix.yml
@@ -10,7 +10,7 @@ parameters:
   HelixPostCommands: ''                  # optional -- commands to run after Helix work item execution
   WorkItemDirectory: ''                  # optional -- a payload directory to zip up and send to Helix; requires WorkItemCommand; incompatible with XUnitProjects
   WorkItemCommand: ''                    # optional -- a command to execute on the payload; requires WorkItemDirectory; incompatible with XUnitProjects
-  WorkItemTimeout: ''                    # optional -- a timeout in seconds for the work item command; requires WorkItemDirectory; incompatible with XUnitProjects
+  WorkItemTimeout: ''                    # optional -- a timeout in TimeSpan.Parse-ready value (e.g. 00:02:00) for the work item command; requires WorkItemDirectory; incompatible with XUnitProjects
   CorrelationPayloadDirectory: ''        # optional -- a directory to zip up and send to Helix as a correlation payload
   XUnitProjects: ''                      # optional -- semicolon delimited list of XUnitProjects to parse and send to Helix; requires XUnitRuntimeTargetFramework, XUnitPublishTargetFramework, XUnitRunnerVersion, and IncludeDotNetCli=true
   XUnitWorkItemTimeout: ''               # optional -- the workitem timeout in seconds for all workitems created from the xUnit projects specified by XUnitProjects
@@ -18,11 +18,12 @@ parameters:
   XUnitRuntimeTargetFramework: ''        # optional -- framework to use for the xUnit console runner
   XUnitRunnerVersion: ''                 # optional -- version of the xUnit nuget package you wish to use on Helix; required for XUnitProjects
   IncludeDotNetCli: false                # optional -- true will download a version of the .NET CLI onto the Helix machine as a correlation payload; requires DotNetCliPackageType and DotNetCliVersion
-  DotNetCliPackageType: ''               # optional -- either 'sdk' or 'runtime'; determines whether the sdk or runtime will be sent to Helix; see https://raw.githubusercontent.com/dotnet/core/master/release-notes/releases.json
-  DotNetCliVersion: ''                   # optional -- version of the CLI to send to Helix; based on this: https://raw.githubusercontent.com/dotnet/core/master/release-notes/releases.json
+  DotNetCliPackageType: ''               # optional -- either 'sdk', 'runtime' or 'aspnetcore-runtime'; determines whether the sdk or runtime will be sent to Helix; see https://raw.githubusercontent.com/dotnet/core/master/release-notes/releases-index.json
+  DotNetCliVersion: ''                   # optional -- version of the CLI to send to Helix; based on this: https://raw.githubusercontent.com/dotnet/core/master/release-notes/releases-index.json
   EnableXUnitReporter: false             # optional -- true enables XUnit result reporting to Mission Control
   WaitForWorkItemCompletion: true        # optional -- true will make the task wait until work items have been completed and fail the build if work items fail. False is "fire and forget."
   IsExternal: false                      # [DEPRECATED] -- doesn't do anything, jobs are external if HelixAccessToken is empty and Creator is set
+  HelixBaseUri: 'https://helix.dot.net/' # optional -- sets the Helix API base URI (allows targeting int)
   Creator: ''                            # optional -- if the build is external, use this to specify who is sending the job
   DisplayNamePrefix: 'Run Tests'         # optional -- rename the beginning of the displayName of the steps in AzDO 
   condition: succeeded()                 # optional -- condition for step to execute; defaults to succeeded()
@@ -55,6 +56,7 @@ steps:
       DotNetCliVersion: ${{ parameters.DotNetCliVersion }}
       EnableXUnitReporter: ${{ parameters.EnableXUnitReporter }}
       WaitForWorkItemCompletion: ${{ parameters.WaitForWorkItemCompletion }}
+      HelixBaseUri: ${{ parameters.HelixBaseUri }}
       Creator: ${{ parameters.Creator }}
       SYSTEM_ACCESSTOKEN: $(System.AccessToken)
     condition: and(${{ parameters.condition }}, eq(variables['Agent.Os'], 'Windows_NT'))
@@ -85,6 +87,7 @@ steps:
       DotNetCliVersion: ${{ parameters.DotNetCliVersion }}
       EnableXUnitReporter: ${{ parameters.EnableXUnitReporter }}
       WaitForWorkItemCompletion: ${{ parameters.WaitForWorkItemCompletion }}
+      HelixBaseUri: ${{ parameters.HelixBaseUri }}
       Creator: ${{ parameters.Creator }}
       SYSTEM_ACCESSTOKEN: $(System.AccessToken)
     condition: and(${{ parameters.condition }}, ne(variables['Agent.Os'], 'Windows_NT'))
diff --git a/eng/common/templates/steps/source-build.yml b/eng/common/templates/steps/source-build.yml
new file mode 100644
index 00000000000..8e336b7d16b
--- /dev/null
+++ b/eng/common/templates/steps/source-build.yml
@@ -0,0 +1,66 @@
+parameters:
+  # This template adds arcade-powered source-build to CI.
+
+  # This is a 'steps' template, and is intended for advanced scenarios where the existing build
+  # infra has a careful build methodology that must be followed. For example, a repo
+  # (dotnet/runtime) might choose to clone the GitHub repo only once and store it as a pipeline
+  # artifact for all subsequent jobs to use, to reduce dependence on a strong network connection to
+  # GitHub. Using this steps template leaves room for that infra to be included.
+
+  # Defines the platform on which to run the steps. See 'eng/common/templates/job/source-build.yml'
+  # for details. The entire object is described in the 'job' template for simplicity, even though
+  # the usage of the properties on this object is split between the 'job' and 'steps' templates.
+  platform: {}
+
+steps:
+# Build. Keep it self-contained for simple reusability. (No source-build-specific job variables.)
+- script: |
+    set -x
+    df -h
+
+    buildConfig=Release
+    # Check if AzDO substitutes in a build config from a variable, and use it if so.
+    if [ '$(_BuildConfig)' != '$''(_BuildConfig)' ]; then
+      buildConfig='$(_BuildConfig)'
+    fi
+
+    officialBuildArgs=
+    if [ '${{ and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}' = 'True' ]; then
+      officialBuildArgs='/p:DotNetPublishUsingPipelines=true /p:OfficialBuildId=$(BUILD.BUILDNUMBER)'
+    fi
+
+    targetRidArgs=
+    if [ '${{ parameters.platform.targetRID }}' != '' ]; then
+      targetRidArgs='/p:TargetRid=${{ parameters.platform.targetRID }}'
+    fi
+
+    ${{ coalesce(parameters.platform.buildScript, './build.sh') }} --ci \
+      --configuration $buildConfig \
+      --restore --build --pack --publish \
+      $officialBuildArgs \
+      $targetRidArgs \
+      /p:SourceBuildNonPortable=${{ parameters.platform.nonPortable }} \
+      /p:ArcadeBuildFromSource=true
+  displayName: Build
+
+# Upload build logs for diagnosis.
+- task: CopyFiles@2
+  displayName: Prepare BuildLogs staging directory
+  inputs:
+    SourceFolder: '$(Build.SourcesDirectory)'
+    Contents: |
+      **/*.log
+      **/*.binlog
+      artifacts/source-build/self/prebuilt-report/**
+    TargetFolder: '$(Build.StagingDirectory)/BuildLogs'
+    CleanTargetFolder: true
+  continueOnError: true
+  condition: succeededOrFailed()
+
+- task: PublishPipelineArtifact@1
+  displayName: Publish BuildLogs
+  inputs:
+    targetPath: '$(Build.StagingDirectory)/BuildLogs'
+    artifactName: BuildLogs_SourceBuild_${{ parameters.platform.name }}_Attempt$(System.JobAttempt)
+  continueOnError: true
+  condition: succeededOrFailed()
diff --git a/eng/common/tools.ps1 b/eng/common/tools.ps1
index f50507a06c1..60eb601c8f3 100644
--- a/eng/common/tools.ps1
+++ b/eng/common/tools.ps1
@@ -5,11 +5,13 @@
 [bool]$ci = if (Test-Path variable:ci) { $ci } else { $false }
 
 # Build configuration. Common values include 'Debug' and 'Release', but the repository may use other names.
-[string]$configuration = if (Test-Path variable:configuration) { $configuration } else { "Debug" }
+[string]$configuration = if (Test-Path variable:configuration) { $configuration } else { 'Debug' }
+
+# Set to true to opt out of outputting binary log while running in CI
+[bool]$excludeCIBinarylog = if (Test-Path variable:excludeCIBinarylog) { $excludeCIBinarylog } else { $false }
 
 # Set to true to output binary log from msbuild. Note that emitting binary log slows down the build.
-# Binary log must be enabled on CI.
-[bool]$binaryLog = if (Test-Path variable:binaryLog) { $binaryLog } else { $ci }
+[bool]$binaryLog = if (Test-Path variable:binaryLog) { $binaryLog } else { $ci -and !$excludeCIBinarylog }
 
 # Set to true to use the pipelines logger which will enable Azure logging output.
 # https://github.com/Microsoft/azure-pipelines-tasks/blob/master/docs/authoring/commands.md
@@ -24,7 +26,7 @@
 [bool]$restore = if (Test-Path variable:restore) { $restore } else { $true }
 
 # Adjusts msbuild verbosity level.
-[string]$verbosity = if (Test-Path variable:verbosity) { $verbosity } else { "minimal" }
+[string]$verbosity = if (Test-Path variable:verbosity) { $verbosity } else { 'minimal' }
 
 # Set to true to reuse msbuild nodes. Recommended to not reuse on CI.
 [bool]$nodeReuse = if (Test-Path variable:nodeReuse) { $nodeReuse } else { !$ci }
@@ -41,22 +43,27 @@
 
 # Enable repos to use a particular version of the on-line dotnet-install scripts.
 #    default URL: https://dot.net/v1/dotnet-install.ps1
-[string]$dotnetInstallScriptVersion = if (Test-Path variable:dotnetInstallScriptVersion) { $dotnetInstallScriptVersion } else { "v1" }
+[string]$dotnetInstallScriptVersion = if (Test-Path variable:dotnetInstallScriptVersion) { $dotnetInstallScriptVersion } else { 'v1' }
 
 # True to use global NuGet cache instead of restoring packages to repository-local directory.
 [bool]$useGlobalNuGetCache = if (Test-Path variable:useGlobalNuGetCache) { $useGlobalNuGetCache } else { !$ci }
 
 # An array of names of processes to stop on script exit if prepareMachine is true.
-$processesToStopOnExit = if (Test-Path variable:processesToStopOnExit) { $processesToStopOnExit } else { @("msbuild", "dotnet", "vbcscompiler") }
+$processesToStopOnExit = if (Test-Path variable:processesToStopOnExit) { $processesToStopOnExit } else { @('msbuild', 'dotnet', 'vbcscompiler') }
+
+$disableConfigureToolsetImport = if (Test-Path variable:disableConfigureToolsetImport) { $disableConfigureToolsetImport } else { $null }
 
 set-strictmode -version 2.0
-$ErrorActionPreference = "Stop"
+$ErrorActionPreference = 'Stop'
 [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
 
-function Create-Directory([string[]] $path) {
-  if (!(Test-Path $path)) {
-    New-Item -path $path -force -itemType "Directory" | Out-Null
-  }
+# If specified, provides an alternate path for getting .NET Core SDKs and Runtimes. This script will still try public sources first.
+[string]$runtimeSourceFeed = if (Test-Path variable:runtimeSourceFeed) { $runtimeSourceFeed } else { $null }
+# Base-64 encoded SAS token that has permission to storage container described by $runtimeSourceFeed
+[string]$runtimeSourceFeedKey = if (Test-Path variable:runtimeSourceFeedKey) { $runtimeSourceFeedKey } else { $null }
+
+function Create-Directory ([string[]] $path) {
+    New-Item -Path $path -Force -ItemType 'Directory' | Out-Null
 }
 
 function Unzip([string]$zipfile, [string]$outpath) {
@@ -96,7 +103,10 @@ function Exec-Process([string]$command, [string]$commandArgs) {
   }
 }
 
-function InitializeDotNetCli([bool]$install) {
+# createSdkLocationFile parameter enables a file being generated under the toolset directory
+# which writes the sdk's location into. This is only necessary for cmd --> powershell invocations
+# as dot sourcing isn't possible.
+function InitializeDotNetCli([bool]$install, [bool]$createSdkLocationFile) {
   if (Test-Path variable:global:_DotNetInstallDir) {
     return $global:_DotNetInstallDir
   }
@@ -134,13 +144,13 @@ function InitializeDotNetCli([bool]$install) {
   if ((-not $globalJsonHasRuntimes) -and ($env:DOTNET_INSTALL_DIR -ne $null) -and (Test-Path(Join-Path $env:DOTNET_INSTALL_DIR "sdk\$dotnetSdkVersion"))) {
     $dotnetRoot = $env:DOTNET_INSTALL_DIR
   } else {
-    $dotnetRoot = Join-Path $RepoRoot ".dotnet"
+    $dotnetRoot = Join-Path $RepoRoot '.dotnet'
 
     if (-not (Test-Path(Join-Path $dotnetRoot "sdk\$dotnetSdkVersion"))) {
       if ($install) {
         InstallDotNetSdk $dotnetRoot $dotnetSdkVersion
       } else {
-        Write-PipelineTelemetryError -Category "InitializeToolset" -Message "Unable to find dotnet with SDK version '$dotnetSdkVersion'"
+        Write-PipelineTelemetryError -Category 'InitializeToolset' -Message "Unable to find dotnet with SDK version '$dotnetSdkVersion'"
         ExitWithExitCode 1
       }
     }
@@ -148,6 +158,24 @@ function InitializeDotNetCli([bool]$install) {
     $env:DOTNET_INSTALL_DIR = $dotnetRoot
   }
 
+  # Creates a temporary file under the toolset dir.
+  # The following code block is protecting against concurrent access so that this function can
+  # be called in parallel.
+  if ($createSdkLocationFile) {
+    do {
+      $sdkCacheFileTemp = Join-Path $ToolsetDir $([System.IO.Path]::GetRandomFileName())
+    }
+    until (!(Test-Path $sdkCacheFileTemp))
+    Set-Content -Path $sdkCacheFileTemp -Value $dotnetRoot
+
+    try {
+      Rename-Item -Force -Path $sdkCacheFileTemp 'sdk.txt'
+    } catch {
+      # Somebody beat us
+      Remove-Item -Path $sdkCacheFileTemp
+    }
+  }
+
   # Add dotnet to PATH. This prevents any bare invocation of dotnet in custom
   # build steps from using anything other than what we've downloaded.
   # It also ensures that VS msbuild will use the downloaded sdk targets.
@@ -156,15 +184,6 @@ function InitializeDotNetCli([bool]$install) {
   # Make Sure that our bootstrapped dotnet cli is available in future steps of the Azure Pipelines build
   Write-PipelinePrependPath -Path $dotnetRoot
 
-  # Work around issues with Azure Artifacts credential provider
-  # https://github.com/dotnet/arcade/issues/3932
-  if ($ci) {
-    $env:NUGET_PLUGIN_HANDSHAKE_TIMEOUT_IN_SECONDS = 20
-    $env:NUGET_PLUGIN_REQUEST_TIMEOUT_IN_SECONDS = 20
-    Write-PipelineSetVariable -Name 'NUGET_PLUGIN_HANDSHAKE_TIMEOUT_IN_SECONDS' -Value '20'
-    Write-PipelineSetVariable -Name 'NUGET_PLUGIN_REQUEST_TIMEOUT_IN_SECONDS' -Value '20'
-  }
-
   Write-PipelineSetVariable -Name 'DOTNET_MULTILEVEL_LOOKUP' -Value '0'
   Write-PipelineSetVariable -Name 'DOTNET_SKIP_FIRST_TIME_EXPERIENCE' -Value '1'
 
@@ -172,27 +191,54 @@ function InitializeDotNetCli([bool]$install) {
 }
 
 function GetDotNetInstallScript([string] $dotnetRoot) {
-  $installScript = Join-Path $dotnetRoot "dotnet-install.ps1"
+  $installScript = Join-Path $dotnetRoot 'dotnet-install.ps1'
   if (!(Test-Path $installScript)) {
     Create-Directory $dotnetRoot
     $ProgressPreference = 'SilentlyContinue' # Don't display the console progress UI - it's a huge perf hit
-    Invoke-WebRequest "https://dot.net/$dotnetInstallScriptVersion/dotnet-install.ps1" -OutFile $installScript
+
+    $maxRetries = 5
+    $retries = 1
+
+    $uri = "https://dot.net/$dotnetInstallScriptVersion/dotnet-install.ps1"
+
+    while($true) {
+      try {
+        Write-Host "GET $uri"
+        Invoke-WebRequest $uri -OutFile $installScript
+        break
+      }
+      catch {
+        Write-Host "Failed to download '$uri'"
+        Write-Error $_.Exception.Message -ErrorAction Continue
+      }
+
+      if (++$retries -le $maxRetries) {
+        $delayInSeconds = [math]::Pow(2, $retries) - 1 # Exponential backoff
+        Write-Host "Retrying. Waiting for $delayInSeconds seconds before next attempt ($retries of $maxRetries)."
+        Start-Sleep -Seconds $delayInSeconds
+      }
+      else {
+        throw "Unable to download file in $maxRetries attempts."
+      }
+
+    }
   }
 
   return $installScript
 }
 
-function InstallDotNetSdk([string] $dotnetRoot, [string] $version, [string] $architecture = "") {
-  InstallDotNet $dotnetRoot $version $architecture
+function InstallDotNetSdk([string] $dotnetRoot, [string] $version, [string] $architecture = '', [switch] $noPath) {
+  InstallDotNet $dotnetRoot $version $architecture '' $false $runtimeSourceFeed $runtimeSourceFeedKey -noPath:$noPath
 }
 
-function InstallDotNet([string] $dotnetRoot, 
-  [string] $version, 
-  [string] $architecture = "", 
-  [string] $runtime = "", 
-  [bool] $skipNonVersionedFiles = $false, 
-  [string] $runtimeSourceFeed = "", 
-  [string] $runtimeSourceFeedKey = "") {
+function InstallDotNet([string] $dotnetRoot,
+  [string] $version,
+  [string] $architecture = '',
+  [string] $runtime = '',
+  [bool] $skipNonVersionedFiles = $false,
+  [string] $runtimeSourceFeed = '',
+  [string] $runtimeSourceFeedKey = '',
+  [switch] $noPath) {
 
   $installScript = GetDotNetInstallScript $dotnetRoot
   $installParameters = @{
@@ -203,15 +249,14 @@ function InstallDotNet([string] $dotnetRoot,
   if ($architecture) { $installParameters.Architecture = $architecture }
   if ($runtime) { $installParameters.Runtime = $runtime }
   if ($skipNonVersionedFiles) { $installParameters.SkipNonVersionedFiles = $skipNonVersionedFiles }
+  if ($noPath) { $installParameters.NoPath = $True }
 
   try {
     & $installScript @installParameters
   }
   catch {
-    Write-PipelineTelemetryError -Category "InitializeToolset" -Message "Failed to install dotnet runtime '$runtime' from public location."
-
-    # Only the runtime can be installed from a custom [private] location.
-    if ($runtime -and ($runtimeSourceFeed -or $runtimeSourceFeedKey)) {
+    if ($runtimeSourceFeed -or $runtimeSourceFeedKey) {
+      Write-Host "Failed to install dotnet from public location. Trying from '$runtimeSourceFeed'"
       if ($runtimeSourceFeed) { $installParameters.AzureFeed = $runtimeSourceFeed }
 
       if ($runtimeSourceFeedKey) {
@@ -224,10 +269,11 @@ function InstallDotNet([string] $dotnetRoot,
         & $installScript @installParameters
       }
       catch {
-        Write-PipelineTelemetryError -Category "InitializeToolset" -Message "Failed to install dotnet runtime '$runtime' from custom location '$runtimeSourceFeed'."
+        Write-PipelineTelemetryError -Category 'InitializeToolset' -Message "Failed to install dotnet from custom location '$runtimeSourceFeed'."
         ExitWithExitCode 1
       }
     } else {
+      Write-PipelineTelemetryError -Category 'InitializeToolset' -Message "Failed to install dotnet from public location."
       ExitWithExitCode 1
     }
   }
@@ -253,17 +299,26 @@ function InitializeVisualStudioMSBuild([bool]$install, [object]$vsRequirements =
     return $global:_MSBuildExe
   }
 
+  # Minimum VS version to require.
+  $vsMinVersionReqdStr = '16.8'
+  $vsMinVersionReqd = [Version]::new($vsMinVersionReqdStr)
+
+  # If the version of msbuild is going to be xcopied,
+  # use this version. Version matches a package here:
+  # https://dev.azure.com/dnceng/public/_packaging?_a=package&feed=dotnet-eng&package=RoslynTools.MSBuild&protocolType=NuGet&version=16.8.0-preview3&view=overview
+  $defaultXCopyMSBuildVersion = '16.8.0-preview3'
+
   if (!$vsRequirements) { $vsRequirements = $GlobalJson.tools.vs }
-  $vsMinVersionStr = if ($vsRequirements.version) { $vsRequirements.version } else { "15.9" }
+  $vsMinVersionStr = if ($vsRequirements.version) { $vsRequirements.version } else { $vsMinVersionReqdStr }
   $vsMinVersion = [Version]::new($vsMinVersionStr)
 
   # Try msbuild command available in the environment.
   if ($env:VSINSTALLDIR -ne $null) {
-    $msbuildCmd = Get-Command "msbuild.exe" -ErrorAction SilentlyContinue
+    $msbuildCmd = Get-Command 'msbuild.exe' -ErrorAction SilentlyContinue
     if ($msbuildCmd -ne $null) {
       # Workaround for https://github.com/dotnet/roslyn/issues/35793
       # Due to this issue $msbuildCmd.Version returns 0.0.0.0 for msbuild.exe 16.2+
-      $msbuildVersion = [Version]::new((Get-Item $msbuildCmd.Path).VersionInfo.ProductVersion.Split(@('-', '+'))[0])
+      $msbuildVersion = [Version]::new((Get-Item $msbuildCmd.Path).VersionInfo.ProductVersion.Split([char[]]@('-', '+'))[0])
 
       if ($msbuildVersion -ge $vsMinVersion) {
         return $global:_MSBuildExe = $msbuildCmd.Path
@@ -283,17 +338,35 @@ function InitializeVisualStudioMSBuild([bool]$install, [object]$vsRequirements =
     InitializeVisualStudioEnvironmentVariables $vsInstallDir $vsMajorVersion
   } else {
 
-    if (Get-Member -InputObject $GlobalJson.tools -Name "xcopy-msbuild") {
+    if (Get-Member -InputObject $GlobalJson.tools -Name 'xcopy-msbuild') {
       $xcopyMSBuildVersion = $GlobalJson.tools.'xcopy-msbuild'
       $vsMajorVersion = $xcopyMSBuildVersion.Split('.')[0]
     } else {
-      $vsMajorVersion = $vsMinVersion.Major
-      $xcopyMSBuildVersion = "$vsMajorVersion.$($vsMinVersion.Minor).0-alpha"
+      #if vs version provided in global.json is incompatible (too low) then use the default version for xcopy msbuild download
+      if($vsMinVersion -lt $vsMinVersionReqd){
+        Write-Host "Using xcopy-msbuild version of $defaultXCopyMSBuildVersion since VS version $vsMinVersionStr provided in global.json is not compatible"
+        $xcopyMSBuildVersion = $defaultXCopyMSBuildVersion
+      }
+      else{
+        # If the VS version IS compatible, look for an xcopy msbuild package
+        # with a version matching VS.
+        # Note: If this version does not exist, then an explicit version of xcopy msbuild
+        # can be specified in global.json. This will be required for pre-release versions of msbuild.
+        $vsMajorVersion = $vsMinVersion.Major
+        $vsMinorVersion = $vsMinVersion.Minor
+        $xcopyMSBuildVersion = "$vsMajorVersion.$vsMinorVersion.0"
+      }
     }
 
-    $vsInstallDir = InitializeXCopyMSBuild $xcopyMSBuildVersion $install
+    $vsInstallDir = $null
+    if ($xcopyMSBuildVersion.Trim() -ine "none") {
+        $vsInstallDir = InitializeXCopyMSBuild $xcopyMSBuildVersion $install
+        if ($vsInstallDir -eq $null) {
+            throw "Could not xcopy msbuild. Please check that package 'RoslynTools.MSBuild @ $xcopyMSBuildVersion' exists on feed 'dotnet-eng'."
+        }
+    }
     if ($vsInstallDir -eq $null) {
-      throw "Unable to find Visual Studio that has required version and components installed"
+      throw 'Unable to find Visual Studio that has required version and components installed'
     }
   }
 
@@ -317,7 +390,7 @@ function InstallXCopyMSBuild([string]$packageVersion) {
 }
 
 function InitializeXCopyMSBuild([string]$packageVersion, [bool]$install) {
-  $packageName = "RoslynTools.MSBuild"
+  $packageName = 'RoslynTools.MSBuild'
   $packageDir = Join-Path $ToolsDir "msbuild\$packageVersion"
   $packagePath = Join-Path $packageDir "$packageName.$packageVersion.nupkg"
 
@@ -333,7 +406,7 @@ function InitializeXCopyMSBuild([string]$packageVersion, [bool]$install) {
     Unzip $packagePath $packageDir
   }
 
-  return Join-Path $packageDir "tools"
+  return Join-Path $packageDir 'tools'
 }
 
 #
@@ -357,29 +430,34 @@ function LocateVisualStudio([object]$vsRequirements = $null){
   if (Get-Member -InputObject $GlobalJson.tools -Name 'vswhere') {
     $vswhereVersion = $GlobalJson.tools.vswhere
   } else {
-    $vswhereVersion = "2.5.2"
+    $vswhereVersion = '2.5.2'
   }
 
   $vsWhereDir = Join-Path $ToolsDir "vswhere\$vswhereVersion"
-  $vsWhereExe = Join-Path $vsWhereDir "vswhere.exe"
+  $vsWhereExe = Join-Path $vsWhereDir 'vswhere.exe'
 
   if (!(Test-Path $vsWhereExe)) {
     Create-Directory $vsWhereDir
-    Write-Host "Downloading vswhere"
-    Invoke-WebRequest "https://github.com/Microsoft/vswhere/releases/download/$vswhereVersion/vswhere.exe" -OutFile $vswhereExe
+    Write-Host 'Downloading vswhere'
+    try {
+      Invoke-WebRequest "https://netcorenativeassets.blob.core.windows.net/resource-packages/external/windows/vswhere/$vswhereVersion/vswhere.exe" -OutFile $vswhereExe
+    }
+    catch {
+      Write-PipelineTelemetryError -Category 'InitializeToolset' -Message $_
+    }
   }
 
   if (!$vsRequirements) { $vsRequirements = $GlobalJson.tools.vs }
-  $args = @("-latest", "-prerelease", "-format", "json", "-requires", "Microsoft.Component.MSBuild", "-products", "*")
+  $args = @('-latest', '-prerelease', '-format', 'json', '-requires', 'Microsoft.Component.MSBuild', '-products', '*')
 
-  if (Get-Member -InputObject $vsRequirements -Name "version") {
-    $args += "-version"
+  if (Get-Member -InputObject $vsRequirements -Name 'version') {
+    $args += '-version'
     $args += $vsRequirements.version
   }
 
-  if (Get-Member -InputObject $vsRequirements -Name "components") {
+  if (Get-Member -InputObject $vsRequirements -Name 'components') {
     foreach ($component in $vsRequirements.components) {
-      $args += "-requires"
+      $args += '-requires'
       $args += $component
     }
   }
@@ -405,13 +483,13 @@ function InitializeBuildTool() {
 
   # Initialize dotnet cli if listed in 'tools'
   $dotnetRoot = $null
-  if (Get-Member -InputObject $GlobalJson.tools -Name "dotnet") {
+  if (Get-Member -InputObject $GlobalJson.tools -Name 'dotnet') {
     $dotnetRoot = InitializeDotNetCli -install:$restore
   }
 
-  if ($msbuildEngine -eq "dotnet") {
+  if ($msbuildEngine -eq 'dotnet') {
     if (!$dotnetRoot) {
-      Write-PipelineTelemetryError -Category "InitializeToolset" -Message "/global.json must specify 'tools.dotnet'."
+      Write-PipelineTelemetryError -Category 'InitializeToolset' -Message "/global.json must specify 'tools.dotnet'."
       ExitWithExitCode 1
     }
     $dotnetPath = Join-Path $dotnetRoot (GetExecutableFileName 'dotnet')
@@ -420,13 +498,13 @@ function InitializeBuildTool() {
     try {
       $msbuildPath = InitializeVisualStudioMSBuild -install:$restore
     } catch {
-      Write-PipelineTelemetryError -Category "InitializeToolset" -Message $_
+      Write-PipelineTelemetryError -Category 'InitializeToolset' -Message $_
       ExitWithExitCode 1
     }
 
     $buildTool = @{ Path = $msbuildPath; Command = ""; Tool = "vs"; Framework = "net472" }
   } else {
-    Write-PipelineTelemetryError -Category "InitializeToolset" -Message "Unexpected value of -msbuildEngine: '$msbuildEngine'."
+    Write-PipelineTelemetryError -Category 'InitializeToolset' -Message "Unexpected value of -msbuildEngine: '$msbuildEngine'."
     ExitWithExitCode 1
   }
 
@@ -435,26 +513,29 @@ function InitializeBuildTool() {
 
 function GetDefaultMSBuildEngine() {
   # Presence of tools.vs indicates the repo needs to build using VS msbuild on Windows.
-  if (Get-Member -InputObject $GlobalJson.tools -Name "vs") {
-    return "vs"
+  if (Get-Member -InputObject $GlobalJson.tools -Name 'vs') {
+    return 'vs'
   }
 
-  if (Get-Member -InputObject $GlobalJson.tools -Name "dotnet") {
-    return "dotnet"
+  if (Get-Member -InputObject $GlobalJson.tools -Name 'dotnet') {
+    return 'dotnet'
   }
 
-  Write-PipelineTelemetryError -Category "InitializeToolset" -Message "-msbuildEngine must be specified, or /global.json must specify 'tools.dotnet' or 'tools.vs'."
+  Write-PipelineTelemetryError -Category 'InitializeToolset' -Message "-msbuildEngine must be specified, or /global.json must specify 'tools.dotnet' or 'tools.vs'."
   ExitWithExitCode 1
 }
 
 function GetNuGetPackageCachePath() {
   if ($env:NUGET_PACKAGES -eq $null) {
-    # Use local cache on CI to ensure deterministic build,
+    # Use local cache on CI to ensure deterministic build. 
+    # Avoid using the http cache as workaround for https://github.com/NuGet/Home/issues/3116
     # use global cache in dev builds to avoid cost of downloading packages.
+    # For directory normalization, see also: https://github.com/NuGet/Home/issues/7968
     if ($useGlobalNuGetCache) {
-      $env:NUGET_PACKAGES = Join-Path $env:UserProfile ".nuget\packages"
+      $env:NUGET_PACKAGES = Join-Path $env:UserProfile '.nuget\packages\'
     } else {
-      $env:NUGET_PACKAGES = Join-Path $RepoRoot ".packages"
+      $env:NUGET_PACKAGES = Join-Path $RepoRoot '.packages\'
+      $env:RESTORENOCACHE = $true
     }
   }
 
@@ -467,7 +548,7 @@ function GetSdkTaskProject([string]$taskName) {
 }
 
 function InitializeNativeTools() {
-  if (Get-Member -InputObject $GlobalJson -Name "native-tools") {
+  if (-Not (Test-Path variable:DisableNativeToolsetInstalls) -And (Get-Member -InputObject $GlobalJson -Name "native-tools")) {
     $nativeArgs= @{}
     if ($ci) {
       $nativeArgs = @{
@@ -496,20 +577,20 @@ function InitializeToolset() {
   }
 
   if (-not $restore) {
-    Write-PipelineTelemetryError -Category "InitializeToolset" -Message "Toolset version $toolsetVersion has not been restored."
+    Write-PipelineTelemetryError -Category 'InitializeToolset' -Message "Toolset version $toolsetVersion has not been restored."
     ExitWithExitCode 1
   }
 
   $buildTool = InitializeBuildTool
 
-  $proj = Join-Path $ToolsetDir "restore.proj"
-  $bl = if ($binaryLog) { "/bl:" + (Join-Path $LogDir "ToolsetRestore.binlog") } else { "" }
+  $proj = Join-Path $ToolsetDir 'restore.proj'
+  $bl = if ($binaryLog) { '/bl:' + (Join-Path $LogDir 'ToolsetRestore.binlog') } else { '' }
 
   '<Project Sdk="Microsoft.DotNet.Arcade.Sdk"/>' | Set-Content $proj
 
   MSBuild-Core $proj $bl /t:__WriteToolsetLocation /clp:ErrorsOnly`;NoSummary /p:__ToolsetLocationOutputFile=$toolsetLocationFile
 
-  $path = Get-Content $toolsetLocationFile -TotalCount 1
+  $path = Get-Content $toolsetLocationFile -Encoding UTF8 -TotalCount 1
   if (!(Test-Path $path)) {
     throw "Invalid toolset path: $path"
   }
@@ -525,7 +606,7 @@ function ExitWithExitCode([int] $exitCode) {
 }
 
 function Stop-Processes() {
-  Write-Host "Killing running build processes..."
+  Write-Host 'Killing running build processes...'
   foreach ($processName in $processesToStopOnExit) {
     Get-Process -Name $processName -ErrorAction SilentlyContinue | Stop-Process
   }
@@ -540,15 +621,16 @@ function MSBuild() {
   if ($pipelinesLog) {
     $buildTool = InitializeBuildTool
 
-    # Work around issues with Azure Artifacts credential provider
-    # https://github.com/dotnet/arcade/issues/3932
-    if ($ci -and $buildTool.Tool -eq "dotnet") {
-      dotnet nuget locals http-cache -c
+    if ($ci -and $buildTool.Tool -eq 'dotnet') {
+      $env:NUGET_PLUGIN_HANDSHAKE_TIMEOUT_IN_SECONDS = 20
+      $env:NUGET_PLUGIN_REQUEST_TIMEOUT_IN_SECONDS = 20
+      Write-PipelineSetVariable -Name 'NUGET_PLUGIN_HANDSHAKE_TIMEOUT_IN_SECONDS' -Value '20'
+      Write-PipelineSetVariable -Name 'NUGET_PLUGIN_REQUEST_TIMEOUT_IN_SECONDS' -Value '20'
     }
 
     $toolsetBuildProject = InitializeToolset
     $path = Split-Path -parent $toolsetBuildProject
-    $path = Join-Path $path (Join-Path $buildTool.Framework "Microsoft.DotNet.Arcade.Sdk.dll")
+    $path = Join-Path $path (Join-Path $buildTool.Framework 'Microsoft.DotNet.Arcade.Sdk.dll')
     $args += "/logger:$path"
   }
 
@@ -562,13 +644,13 @@ function MSBuild() {
 #
 function MSBuild-Core() {
   if ($ci) {
-    if (!$binaryLog) {
-      Write-PipelineTaskError -Message "Binary log must be enabled in CI build."
+    if (!$binaryLog -and !$excludeCIBinarylog) {
+      Write-PipelineTelemetryError -Category 'Build' -Message 'Binary log must be enabled in CI build, or explicitly opted-out from with the -excludeCIBinarylog switch.'
       ExitWithExitCode 1
     }
 
     if ($nodeReuse) {
-      Write-PipelineTaskError -Message "Node reuse must be disabled in CI build."
+      Write-PipelineTelemetryError -Category 'Build' -Message 'Node reuse must be disabled in CI build.'
       ExitWithExitCode 1
     }
   }
@@ -578,10 +660,10 @@ function MSBuild-Core() {
   $cmdArgs = "$($buildTool.Command) /m /nologo /clp:Summary /v:$verbosity /nr:$nodeReuse /p:ContinuousIntegrationBuild=$ci"
 
   if ($warnAsError) {
-    $cmdArgs += " /warnaserror /p:TreatWarningsAsErrors=true"
+    $cmdArgs += ' /warnaserror /p:TreatWarningsAsErrors=true'
   }
   else {
-    $cmdArgs += " /p:TreatWarningsAsErrors=false"
+    $cmdArgs += ' /p:TreatWarningsAsErrors=false'
   }
 
   foreach ($arg in $args) {
@@ -590,10 +672,12 @@ function MSBuild-Core() {
     }
   }
 
+  $env:ARCADE_BUILD_TOOL_COMMAND = "$($buildTool.Path) $cmdArgs"
+
   $exitCode = Exec-Process $buildTool.Path $cmdArgs
 
   if ($exitCode -ne 0) {
-    Write-PipelineTaskError -Message "Build failed."
+    Write-PipelineTelemetryError -Category 'Build' -Message 'Build failed.'
 
     $buildLog = GetMSBuildBinaryLogCommandLineArgument $args
     if ($buildLog -ne $null) {
@@ -608,12 +692,12 @@ function GetMSBuildBinaryLogCommandLineArgument($arguments) {
   foreach ($argument in $arguments) {
     if ($argument -ne $null) {
       $arg = $argument.Trim()
-      if ($arg.StartsWith("/bl:", "OrdinalIgnoreCase")) {
-        return $arg.Substring("/bl:".Length)
+      if ($arg.StartsWith('/bl:', "OrdinalIgnoreCase")) {
+        return $arg.Substring('/bl:'.Length)
       }
 
-      if ($arg.StartsWith("/binaryLogger:", "OrdinalIgnoreCase")) {
-        return $arg.Substring("/binaryLogger:".Length)
+      if ($arg.StartsWith('/binaryLogger:', 'OrdinalIgnoreCase')) {
+        return $arg.Substring('/binaryLogger:'.Length)
       }
     }
   }
@@ -634,16 +718,26 @@ function IsWindowsPlatform() {
   return [environment]::OSVersion.Platform -eq [PlatformID]::Win32NT
 }
 
+function Get-Darc($version) {
+  $darcPath  = "$TempDir\darc\$(New-Guid)"
+  if ($version -ne $null) {
+    & $PSScriptRoot\darc-init.ps1 -toolpath $darcPath -darcVersion $version | Out-Host
+  } else {
+    & $PSScriptRoot\darc-init.ps1 -toolpath $darcPath | Out-Host
+  }
+  return "$darcPath\darc.exe"
+}
+
 . $PSScriptRoot\pipeline-logging-functions.ps1
 
-$RepoRoot = Resolve-Path (Join-Path $PSScriptRoot "..\..")
-$EngRoot = Resolve-Path (Join-Path $PSScriptRoot "..")
-$ArtifactsDir = Join-Path $RepoRoot "artifacts"
-$ToolsetDir = Join-Path $ArtifactsDir "toolset"
-$ToolsDir = Join-Path $RepoRoot ".tools"
-$LogDir = Join-Path (Join-Path $ArtifactsDir "log") $configuration
-$TempDir = Join-Path (Join-Path $ArtifactsDir "tmp") $configuration
-$GlobalJson = Get-Content -Raw -Path (Join-Path $RepoRoot "global.json") | ConvertFrom-Json
+$RepoRoot = Resolve-Path (Join-Path $PSScriptRoot '..\..')
+$EngRoot = Resolve-Path (Join-Path $PSScriptRoot '..')
+$ArtifactsDir = Join-Path $RepoRoot 'artifacts'
+$ToolsetDir = Join-Path $ArtifactsDir 'toolset'
+$ToolsDir = Join-Path $RepoRoot '.tools'
+$LogDir = Join-Path (Join-Path $ArtifactsDir 'log') $configuration
+$TempDir = Join-Path (Join-Path $ArtifactsDir 'tmp') $configuration
+$GlobalJson = Get-Content -Raw -Path (Join-Path $RepoRoot 'global.json') | ConvertFrom-Json
 # true if global.json contains a "runtimes" section
 $globalJsonHasRuntimes = if ($GlobalJson.tools.PSObject.Properties.Name -Match 'runtimes') { $true } else { $false }
 
@@ -656,3 +750,18 @@ Write-PipelineSetVariable -Name 'Artifacts.Toolset' -Value $ToolsetDir
 Write-PipelineSetVariable -Name 'Artifacts.Log' -Value $LogDir
 Write-PipelineSetVariable -Name 'TEMP' -Value $TempDir
 Write-PipelineSetVariable -Name 'TMP' -Value $TempDir
+
+# Import custom tools configuration, if present in the repo.
+# Note: Import in global scope so that the script set top-level variables without qualification.
+if (!$disableConfigureToolsetImport) {
+  $configureToolsetScript = Join-Path $EngRoot 'configure-toolset.ps1'
+  if (Test-Path $configureToolsetScript) {
+    . $configureToolsetScript
+    if ((Test-Path variable:failOnConfigureToolsetError) -And $failOnConfigureToolsetError) {
+      if ((Test-Path variable:LastExitCode) -And ($LastExitCode -ne 0)) {
+        Write-PipelineTelemetryError -Category 'Build' -Message 'configure-toolset.ps1 returned a non-zero exit code'
+        ExitWithExitCode $LastExitCode
+      }
+    }
+  }
+}
diff --git a/eng/common/tools.sh b/eng/common/tools.sh
index acbb0c5b3ff..98186e78496 100755
--- a/eng/common/tools.sh
+++ b/eng/common/tools.sh
@@ -18,9 +18,17 @@ fi
 # Build configuration. Common values include 'Debug' and 'Release', but the repository may use other names.
 configuration=${configuration:-'Debug'}
 
+# Set to true to opt out of outputting binary log while running in CI
+exclude_ci_binary_log=${exclude_ci_binary_log:-false}
+
+if [[ "$ci" == true && "$exclude_ci_binary_log" == false ]]; then
+  binary_log_default=true
+else
+  binary_log_default=false
+fi
+
 # Set to true to output binary log from msbuild. Note that emitting binary log slows down the build.
-# Binary log must be enabled on CI.
-binary_log=${binary_log:-$ci}
+binary_log=${binary_log:-$binary_log_default}
 
 # Turns on machine preparation/clean up code that changes the machine state (e.g. kills build processes).
 prepare_machine=${prepare_machine:-false}
@@ -41,7 +49,7 @@ fi
 # Configures warning treatment in msbuild.
 warn_as_error=${warn_as_error:-true}
 
-# True to attempt using .NET Core already that meets requirements specified in global.json 
+# True to attempt using .NET Core already that meets requirements specified in global.json
 # installed on the machine instead of downloading one.
 use_installed_dotnet_cli=${use_installed_dotnet_cli:-true}
 
@@ -56,6 +64,10 @@ else
   use_global_nuget_cache=${use_global_nuget_cache:-true}
 fi
 
+# Used when restoring .NET SDK from alternative feeds
+runtime_source_feed=${runtime_source_feed:-''}
+runtime_source_feed_key=${runtime_source_feed_key:-''}
+
 # Resolve any symlinks in the given path.
 function ResolvePath {
   local path=$1
@@ -77,11 +89,11 @@ function ResolvePath {
 function ReadGlobalVersion {
   local key=$1
 
-  local line=`grep -m 1 "$key" "$global_json_file"`
+  local line=$(awk "/$key/ {print; exit}" "$global_json_file")
   local pattern="\"$key\" *: *\"(.*)\""
 
   if [[ ! $line =~ $pattern ]]; then
-    Write-PipelineTelemetryError -category 'InitializeToolset' "Error: Cannot find \"$key\" in $global_json_file"
+    Write-PipelineTelemetryError -category 'Build' "Error: Cannot find \"$key\" in $global_json_file"
     ExitWithExitCode 1
   fi
 
@@ -152,15 +164,6 @@ function InitializeDotNetCli {
   # build steps from using anything other than what we've downloaded.
   Write-PipelinePrependPath -path "$dotnet_root"
 
-  # Work around issues with Azure Artifacts credential provider
-  # https://github.com/dotnet/arcade/issues/3932
-  if [[ "$ci" == true ]]; then
-    export NUGET_PLUGIN_HANDSHAKE_TIMEOUT_IN_SECONDS=20
-    export NUGET_PLUGIN_REQUEST_TIMEOUT_IN_SECONDS=20
-    Write-PipelineSetVariable -name "NUGET_PLUGIN_HANDSHAKE_TIMEOUT_IN_SECONDS" -value "20"
-    Write-PipelineSetVariable -name "NUGET_PLUGIN_REQUEST_TIMEOUT_IN_SECONDS" -value "20"
-  fi
-
   Write-PipelineSetVariable -name "DOTNET_MULTILEVEL_LOOKUP" -value "0"
   Write-PipelineSetVariable -name "DOTNET_SKIP_FIRST_TIME_EXPERIENCE" -value "1"
 
@@ -171,69 +174,91 @@ function InitializeDotNetCli {
 function InstallDotNetSdk {
   local root=$1
   local version=$2
-  local architecture=""
-  if [[ $# == 3 ]]; then
+  local architecture="unset"
+  if [[ $# -ge 3 ]]; then
     architecture=$3
   fi
-  InstallDotNet "$root" "$version" $architecture
+  InstallDotNet "$root" "$version" $architecture 'sdk' 'false' $runtime_source_feed $runtime_source_feed_key
 }
 
 function InstallDotNet {
   local root=$1
   local version=$2
- 
+
   GetDotNetInstallScript "$root"
   local install_script=$_GetDotNetInstallScript
 
   local archArg=''
-  if [[ -n "${3:-}" ]]; then
+  if [[ -n "${3:-}" ]] && [ "$3" != 'unset' ]; then
     archArg="--architecture $3"
   fi
   local runtimeArg=''
-  if [[ -n "${4:-}" ]]; then
+  if [[ -n "${4:-}" ]] && [ "$4" != 'sdk' ]; then
     runtimeArg="--runtime $4"
   fi
-
   local skipNonVersionedFilesArg=""
-  if [[ "$#" -ge "5" ]]; then
+  if [[ "$#" -ge "5" ]] && [[ "$5" != 'false' ]]; then
     skipNonVersionedFilesArg="--skip-non-versioned-files"
   fi
   bash "$install_script" --version $version --install-dir "$root" $archArg $runtimeArg $skipNonVersionedFilesArg || {
     local exit_code=$?
-    Write-PipelineTelemetryError -category 'InitializeToolset' "Failed to install dotnet SDK from public location (exit code '$exit_code')."
+    echo "Failed to install dotnet SDK from public location (exit code '$exit_code')."
 
-    if [[ -n "$runtimeArg" ]]; then
-      local runtimeSourceFeed=''
-      if [[ -n "${6:-}" ]]; then
-        runtimeSourceFeed="--azure-feed $6"
-      fi
+    local runtimeSourceFeed=''
+    if [[ -n "${6:-}" ]]; then
+      runtimeSourceFeed="--azure-feed $6"
+    fi
 
-      local runtimeSourceFeedKey=''
-      if [[ -n "${7:-}" ]]; then
-        # The 'base64' binary on alpine uses '-d' and doesn't support '--decode'
-        # '-d'. To work around this, do a simple detection and switch the parameter
-        # accordingly.
-        decodeArg="--decode"
-        if base64 --help 2>&1 | grep -q "BusyBox"; then
-            decodeArg="-d"
-        fi
-        decodedFeedKey=`echo $7 | base64 $decodeArg`
-        runtimeSourceFeedKey="--feed-credential $decodedFeedKey"
+    local runtimeSourceFeedKey=''
+    if [[ -n "${7:-}" ]]; then
+      # The 'base64' binary on alpine uses '-d' and doesn't support '--decode'
+      # '-d'. To work around this, do a simple detection and switch the parameter
+      # accordingly.
+      decodeArg="--decode"
+      if base64 --help 2>&1 | grep -q "BusyBox"; then
+          decodeArg="-d"
       fi
+      decodedFeedKey=`echo $7 | base64 $decodeArg`
+      runtimeSourceFeedKey="--feed-credential $decodedFeedKey"
+    fi
 
-      if [[ -n "$runtimeSourceFeed" || -n "$runtimeSourceFeedKey" ]]; then
-        bash "$install_script" --version $version --install-dir "$root" $archArg $runtimeArg $skipNonVersionedFilesArg $runtimeSourceFeed $runtimeSourceFeedKey || {
-          local exit_code=$?
-          Write-PipelineTelemetryError -category 'InitializeToolset' "Failed to install dotnet SDK from custom location '$runtimeSourceFeed' (exit code '$exit_code')."
-          ExitWithExitCode $exit_code
-        }
-      else
+    if [[ -n "$runtimeSourceFeed" || -n "$runtimeSourceFeedKey" ]]; then
+      bash "$install_script" --version $version --install-dir "$root" $archArg $runtimeArg $skipNonVersionedFilesArg $runtimeSourceFeed $runtimeSourceFeedKey || {
+        local exit_code=$?
+        Write-PipelineTelemetryError -category 'InitializeToolset' "Failed to install dotnet SDK from custom location '$runtimeSourceFeed' (exit code '$exit_code')."
         ExitWithExitCode $exit_code
+      }
+    else
+      if [[ $exit_code != 0 ]]; then
+        Write-PipelineTelemetryError -category 'InitializeToolset' "Failed to install dotnet SDK from public location (exit code '$exit_code')."
       fi
+      ExitWithExitCode $exit_code
     fi
   }
 }
 
+function with_retries {
+  local maxRetries=5
+  local retries=1
+  echo "Trying to run '$@' for maximum of $maxRetries attempts."
+  while [[ $((retries++)) -le $maxRetries ]]; do
+    "$@"
+
+    if [[ $? == 0 ]]; then
+      echo "Ran '$@' successfully."
+      return 0
+    fi
+
+    timeout=$((2**$retries-1))
+    echo "Failed to execute '$@'. Waiting $timeout seconds before next attempt ($retries out of $maxRetries)." 1>&2
+    sleep $timeout
+  done
+
+  echo "Failed to execute '$@' for $maxRetries times." 1>&2
+
+  return 1
+}
+
 function GetDotNetInstallScript {
   local root=$1
   local install_script="$root/dotnet-install.sh"
@@ -246,13 +271,13 @@ function GetDotNetInstallScript {
 
     # Use curl if available, otherwise use wget
     if command -v curl > /dev/null; then
-      curl "$install_script_url" -sSL --retry 10 --create-dirs -o "$install_script" || {
+      with_retries curl "$install_script_url" -sSL --retry 10 --create-dirs -o "$install_script" || {
         local exit_code=$?
         Write-PipelineTelemetryError -category 'InitializeToolset' "Failed to acquire dotnet install script (exit code '$exit_code')."
         ExitWithExitCode $exit_code
       }
-    else 
-      wget -q -O "$install_script" "$install_script_url" || {
+    else
+      with_retries wget -v -O "$install_script" "$install_script_url" || {
         local exit_code=$?
         Write-PipelineTelemetryError -category 'InitializeToolset' "Failed to acquire dotnet install script (exit code '$exit_code')."
         ExitWithExitCode $exit_code
@@ -267,21 +292,23 @@ function InitializeBuildTool {
   if [[ -n "${_InitializeBuildTool:-}" ]]; then
     return
   fi
-  
+
   InitializeDotNetCli $restore
 
   # return values
-  _InitializeBuildTool="$_InitializeDotNetCli/dotnet"  
+  _InitializeBuildTool="$_InitializeDotNetCli/dotnet"
   _InitializeBuildToolCommand="msbuild"
   _InitializeBuildToolFramework="netcoreapp2.1"
 }
 
+# Set RestoreNoCache as a workaround for https://github.com/NuGet/Home/issues/3116
 function GetNuGetPackageCachePath {
   if [[ -z ${NUGET_PACKAGES:-} ]]; then
     if [[ "$use_global_nuget_cache" == true ]]; then
       export NUGET_PACKAGES="$HOME/.nuget/packages"
     else
       export NUGET_PACKAGES="$repo_root/.packages"
+      export RESTORENOCACHE=true
     fi
   fi
 
@@ -290,6 +317,9 @@ function GetNuGetPackageCachePath {
 }
 
 function InitializeNativeTools() {
+  if [[ -n "${DisableNativeToolsetInstalls:-}" ]]; then
+    return
+  fi
   if grep -Fq "native-tools" $global_json_file
   then
     local nativeArgs=""
@@ -332,14 +362,14 @@ function InitializeToolset {
   if [[ "$binary_log" == true ]]; then
     bl="/bl:$log_dir/ToolsetRestore.binlog"
   fi
-  
+
   echo '<Project Sdk="Microsoft.DotNet.Arcade.Sdk"/>' > "$proj"
   MSBuild-Core "$proj" $bl /t:__WriteToolsetLocation /clp:ErrorsOnly\;NoSummary /p:__ToolsetLocationOutputFile="$toolset_location_file"
 
   local toolset_build_proj=`cat "$toolset_location_file"`
 
   if [[ ! -a "$toolset_build_proj" ]]; then
-    Write-PipelineTelemetryError -category 'InitializeToolset' "Invalid toolset path: $toolset_build_proj"
+    Write-PipelineTelemetryError -category 'Build' "Invalid toolset path: $toolset_build_proj"
     ExitWithExitCode 3
   fi
 
@@ -367,10 +397,11 @@ function MSBuild {
     InitializeBuildTool
     InitializeToolset
 
-    # Work around issues with Azure Artifacts credential provider
-    # https://github.com/dotnet/arcade/issues/3932
     if [[ "$ci" == true ]]; then
-      dotnet nuget locals http-cache -c
+      export NUGET_PLUGIN_HANDSHAKE_TIMEOUT_IN_SECONDS=20
+      export NUGET_PLUGIN_REQUEST_TIMEOUT_IN_SECONDS=20
+      Write-PipelineSetVariable -name "NUGET_PLUGIN_HANDSHAKE_TIMEOUT_IN_SECONDS" -value "20"
+      Write-PipelineSetVariable -name "NUGET_PLUGIN_REQUEST_TIMEOUT_IN_SECONDS" -value "20"
     fi
 
     local toolset_dir="${_InitializeToolset%/*}"
@@ -383,13 +414,13 @@ function MSBuild {
 
 function MSBuild-Core {
   if [[ "$ci" == true ]]; then
-    if [[ "$binary_log" != true ]]; then
-      Write-PipelineTaskError "Binary log must be enabled in CI build."
+    if [[ "$binary_log" != true && "$exclude_ci_binary_log" != true ]]; then
+      Write-PipelineTelemetryError -category 'Build'  "Binary log must be enabled in CI build, or explicitly opted-out from with the -noBinaryLog switch."
       ExitWithExitCode 1
     fi
 
     if [[ "$node_reuse" == true ]]; then
-      Write-PipelineTaskError "Node reuse must be disabled in CI build."
+      Write-PipelineTelemetryError -category 'Build'  "Node reuse must be disabled in CI build."
       ExitWithExitCode 1
     fi
   fi
@@ -401,11 +432,17 @@ function MSBuild-Core {
     warnaserror_switch="/warnaserror"
   fi
 
-  "$_InitializeBuildTool" "$_InitializeBuildToolCommand" /m /nologo /clp:Summary /v:$verbosity /nr:$node_reuse $warnaserror_switch /p:TreatWarningsAsErrors=$warn_as_error /p:ContinuousIntegrationBuild=$ci "$@" || {
-    local exit_code=$?
-    Write-PipelineTaskError "Build failed (exit code '$exit_code')."
-    ExitWithExitCode $exit_code
+  function RunBuildTool {
+    export ARCADE_BUILD_TOOL_COMMAND="$_InitializeBuildTool $@"
+
+    "$_InitializeBuildTool" "$@" || {
+      local exit_code=$?
+      Write-PipelineTaskError "Build failed (exit code '$exit_code')."
+      ExitWithExitCode $exit_code
+    }
   }
+
+  RunBuildTool "$_InitializeBuildToolCommand" /m /nologo /clp:Summary /v:$verbosity /nr:$node_reuse $warnaserror_switch /p:TreatWarningsAsErrors=$warn_as_error /p:ContinuousIntegrationBuild=$ci "$@"
 }
 
 ResolvePath "${BASH_SOURCE[0]}"
@@ -424,7 +461,7 @@ temp_dir="$artifacts_dir/tmp/$configuration"
 global_json_file="$repo_root/global.json"
 # determine if global.json contains a "runtimes" entry
 global_json_has_runtimes=false
-dotnetlocal_key=`grep -m 1 "runtimes" "$global_json_file"` || true
+dotnetlocal_key=$(awk "/runtimes/ {print; exit}" "$global_json_file") || true
 if [[ -n "$dotnetlocal_key" ]]; then
   global_json_has_runtimes=true
 fi
@@ -444,3 +481,18 @@ Write-PipelineSetVariable -name "Artifacts.Toolset" -value "$toolset_dir"
 Write-PipelineSetVariable -name "Artifacts.Log" -value "$log_dir"
 Write-PipelineSetVariable -name "Temp" -value "$temp_dir"
 Write-PipelineSetVariable -name "TMP" -value "$temp_dir"
+
+# Import custom tools configuration, if present in the repo.
+if [ -z "${disable_configure_toolset_import:-}" ]; then
+  configure_toolset_script="$eng_root/configure-toolset.sh"
+  if [[ -a "$configure_toolset_script" ]]; then
+    . "$configure_toolset_script"
+  fi
+fi
+
+# TODO: https://github.com/dotnet/arcade/issues/1468
+# Temporary workaround to avoid breaking change.
+# Remove once repos are updated.
+if [[ -n "${useInstalledDotNetCli:-}" ]]; then
+  use_installed_dotnet_cli="$useInstalledDotNetCli"
+fi
diff --git a/eng/config/OptProf.json b/eng/config/OptProf.json
index 53061450ff8..9f2887b156e 100644
--- a/eng/config/OptProf.json
+++ b/eng/config/OptProf.json
@@ -14,13 +14,13 @@
           "container": "MSBuild",
           "testCases": [
             "MSBuild.Managed.vs_perf_designtime_commandline_msbuild_cs_mstv_fullbuild",
-            "MSBuild.Managed.vs_perf_designtime_commandline_msbuild_cs_mstv_fullbuild_4proc",
+            "MSBuild.Managed.vs_perf_designtime_commandline_msbuild_cs_mstv_fullbuild_4proc"
           ]
         },
         {
           "container": "ManagedLangs",
           "testCases": [
-            "ManagedLangs.OptProfTests.DDRIT_RPS_ManagedLangs"
+            "VSPE.OptProfTests.DDRIT_RPS_ManagedLangs_Debug"
           ]
         }  
       ]
diff --git a/global.json b/global.json
index f3705522809..4d0b3b44e05 100644
--- a/global.json
+++ b/global.json
@@ -1,6 +1,6 @@
 {
   "tools": {
-    "dotnet": "3.1.100",
+    "dotnet": "5.0.102",
     "runtimes": {
       "dotnet/x64": [
         "2.1.7"
@@ -12,6 +12,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "1.0.0-beta.20580.3"
+    "Microsoft.DotNet.Arcade.Sdk": "5.0.0-beta.21112.3"
   }
 }
diff --git a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
index cbc25f139be..719440bead7 100644
--- a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
@@ -157,6 +157,24 @@ public CombinePath() { }
         public Microsoft.Build.Framework.ITaskItem[] Paths { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
+    public partial class CombineTargetFrameworkInfoProperties : Microsoft.Build.Tasks.TaskExtension
+    {
+        public CombineTargetFrameworkInfoProperties() { }
+        public Microsoft.Build.Framework.ITaskItem[] PropertiesAndValues { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public string Result { get { throw null; } set { } }
+        public string RootElementName { get { throw null; } set { } }
+        public override bool Execute() { throw null; }
+    }
+    public partial class CombineXmlElements : Microsoft.Build.Tasks.TaskExtension
+    {
+        public CombineXmlElements() { }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public string Result { get { throw null; } set { } }
+        public string RootElementName { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] XmlElements { get { throw null; } set { } }
+        public override bool Execute() { throw null; }
+    }
     public partial class CommandLineBuilderExtension : Microsoft.Build.Utilities.CommandLineBuilder
     {
         public CommandLineBuilderExtension() { }
@@ -926,6 +944,7 @@ public ResolveAssemblyReference() { }
         public Microsoft.Build.Framework.ITaskItem[] InstalledAssemblySubsetTables { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] InstalledAssemblyTables { get { throw null; } set { } }
         public string[] LatestTargetFrameworkDirectories { get { throw null; } set { } }
+        public bool OutputUnresolvedAssemblyConflicts { get { throw null; } set { } }
         public string ProfileName { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         public Microsoft.Build.Framework.ITaskItem[] RelatedFiles { get { throw null; } }
@@ -954,6 +973,8 @@ public ResolveAssemblyReference() { }
         public string[] TargetFrameworkSubsets { get { throw null; } set { } }
         public string TargetFrameworkVersion { get { throw null; } set { } }
         public string TargetProcessorArchitecture { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem[] UnresolvedAssemblyConflicts { get { throw null; } }
         public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get { throw null; } set { } }
         public string WarnOrErrorOnTargetArchitectureMismatch { get { throw null; } set { } }
         public override bool Execute() { throw null; }
@@ -1214,6 +1235,8 @@ public sealed partial class Unzip : Microsoft.Build.Tasks.TaskExtension, Microso
         public Unzip() { }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }
+        public string Exclude { get { throw null; } set { } }
+        public string Include { get { throw null; } set { } }
         public bool OverwriteReadOnlyFiles { get { throw null; } set { } }
         public bool SkipUnchangedFiles { get { throw null; } set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
diff --git a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
index 349308aac70..5bd884463da 100644
--- a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
@@ -87,6 +87,24 @@ public CombinePath() { }
         public Microsoft.Build.Framework.ITaskItem[] Paths { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
+    public partial class CombineTargetFrameworkInfoProperties : Microsoft.Build.Tasks.TaskExtension
+    {
+        public CombineTargetFrameworkInfoProperties() { }
+        public Microsoft.Build.Framework.ITaskItem[] PropertiesAndValues { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public string Result { get { throw null; } set { } }
+        public string RootElementName { get { throw null; } set { } }
+        public override bool Execute() { throw null; }
+    }
+    public partial class CombineXmlElements : Microsoft.Build.Tasks.TaskExtension
+    {
+        public CombineXmlElements() { }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public string Result { get { throw null; } set { } }
+        public string RootElementName { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] XmlElements { get { throw null; } set { } }
+        public override bool Execute() { throw null; }
+    }
     public partial class CommandLineBuilderExtension : Microsoft.Build.Utilities.CommandLineBuilder
     {
         public CommandLineBuilderExtension() { }
@@ -671,6 +689,7 @@ public ResolveAssemblyReference() { }
         public Microsoft.Build.Framework.ITaskItem[] InstalledAssemblySubsetTables { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] InstalledAssemblyTables { get { throw null; } set { } }
         public string[] LatestTargetFrameworkDirectories { get { throw null; } set { } }
+        public bool OutputUnresolvedAssemblyConflicts { get { throw null; } set { } }
         public string ProfileName { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         public Microsoft.Build.Framework.ITaskItem[] RelatedFiles { get { throw null; } }
@@ -699,6 +718,8 @@ public ResolveAssemblyReference() { }
         public string[] TargetFrameworkSubsets { get { throw null; } set { } }
         public string TargetFrameworkVersion { get { throw null; } set { } }
         public string TargetProcessorArchitecture { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem[] UnresolvedAssemblyConflicts { get { throw null; } }
         public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get { throw null; } set { } }
         public string WarnOrErrorOnTargetArchitectureMismatch { get { throw null; } set { } }
         public override bool Execute() { throw null; }
@@ -891,6 +912,8 @@ public sealed partial class Unzip : Microsoft.Build.Tasks.TaskExtension, Microso
         public Unzip() { }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }
+        public string Exclude { get { throw null; } set { } }
+        public string Include { get { throw null; } set { } }
         public bool OverwriteReadOnlyFiles { get { throw null; } set { } }
         public bool SkipUnchangedFiles { get { throw null; } set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
index 810f5bd3e55..495e9458e91 100644
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/net/Microsoft.Build.cs
@@ -889,6 +889,10 @@ public BuildAbortedException(string message, System.Exception innerException) {
         [System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.Demand, SerializationFormatter=true)]
         public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
     }
+    public partial class CircularDependencyException : System.Exception
+    {
+        protected CircularDependencyException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
+    }
     public sealed partial class InternalLoggerException : System.Exception
     {
         public InternalLoggerException() { }
@@ -994,6 +998,7 @@ public BuildParameters(Microsoft.Build.Evaluation.ProjectCollection projectColle
         public string NodeExeLocation { get { throw null; } set { } }
         public bool OnlyLogCriticalEvents { get { throw null; } set { } }
         public string OutputResultsCacheFile { get { throw null; } set { } }
+        public Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor ProjectCacheDescriptor { get { throw null; } set { } }
         public Microsoft.Build.Evaluation.ProjectLoadSettings ProjectLoadSettings { get { throw null; } set { } }
         public bool ResetCaches { get { throw null; } set { } }
         public string ResourceManagerSemaphoreName { get { throw null; } set { } }
@@ -1404,6 +1409,73 @@ public enum TargetResultCode : byte
         Success = (byte)1,
     }
 }
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    public partial class CacheContext
+    {
+        public CacheContext(System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem, Microsoft.Build.Graph.ProjectGraph graph=null, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> graphEntryPoints=null) { }
+        public Microsoft.Build.FileSystem.MSBuildFileSystemBase FileSystem { get { throw null; } }
+        public Microsoft.Build.Graph.ProjectGraph Graph { get { throw null; } }
+        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> GraphEntryPoints { get { throw null; } }
+        public string MSBuildExePath { get { throw null; } }
+        public System.Collections.Generic.IReadOnlyDictionary<string, string> PluginSettings { get { throw null; } }
+    }
+    public partial class CacheResult
+    {
+        internal CacheResult() { }
+        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(Microsoft.Build.Execution.BuildResult buildResult) { throw null; }
+        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) { throw null; }
+        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) { throw null; }
+        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateNonCacheHit(Microsoft.Build.Experimental.ProjectCache.CacheResultType resultType) { throw null; }
+    }
+    public enum CacheResultType
+    {
+        CacheHit = 1,
+        CacheMiss = 2,
+        CacheNotApplicable = 3,
+        None = 0,
+    }
+    public abstract partial class PluginLoggerBase
+    {
+        protected PluginLoggerBase(Microsoft.Build.Framework.LoggerVerbosity verbosity) { }
+        public abstract bool HasLoggedErrors { get; protected set; }
+        public abstract void LogError(string error);
+        public abstract void LogMessage(string message, System.Nullable<Microsoft.Build.Framework.MessageImportance> messageImportance=default(System.Nullable<Microsoft.Build.Framework.MessageImportance>));
+        public abstract void LogWarning(string warning);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public partial struct PluginTargetResult
+    {
+        public PluginTargetResult(string targetName, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> taskItems, Microsoft.Build.Execution.BuildResultCode resultCode) { throw null;}
+        public Microsoft.Build.Execution.BuildResultCode ResultCode { get { throw null; } }
+        public string TargetName { get { throw null; } }
+        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> TaskItems { get { throw null; } }
+    }
+    public partial class ProjectCacheDescriptor
+    {
+        internal ProjectCacheDescriptor() { }
+        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> EntryPoints { get { throw null; } }
+        public string PluginAssemblyPath { get { throw null; } }
+        public Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase PluginInstance { get { throw null; } }
+        public System.Collections.Generic.IReadOnlyDictionary<string, string> PluginSettings { get { throw null; } }
+        public Microsoft.Build.Graph.ProjectGraph ProjectGraph { get { throw null; } }
+        public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings=null) { throw null; }
+        public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings=null) { throw null; }
+        public string GetDetailedDescription() { throw null; }
+    }
+    public abstract partial class ProjectCachePluginBase
+    {
+        protected ProjectCachePluginBase() { }
+        public abstract System.Threading.Tasks.Task BeginBuildAsync(Microsoft.Build.Experimental.ProjectCache.CacheContext context, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken);
+        public abstract System.Threading.Tasks.Task EndBuildAsync(Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken);
+        public abstract System.Threading.Tasks.Task<Microsoft.Build.Experimental.ProjectCache.CacheResult> GetCacheResultAsync(Microsoft.Build.Execution.BuildRequestData buildRequest, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken);
+    }
+    public partial class ProxyTargets
+    {
+        public ProxyTargets(System.Collections.Generic.IReadOnlyDictionary<string, string> proxyTargetToRealTargetMap) { }
+        public System.Collections.Generic.IReadOnlyDictionary<string, string> ProxyTargetToRealTargetMap { get { throw null; } }
+    }
+}
 namespace Microsoft.Build.FileSystem
 {
     public abstract partial class MSBuildFileSystemBase
@@ -1474,6 +1546,21 @@ public static partial class MSBuildGlobExtensions
 }
 namespace Microsoft.Build.Graph
 {
+    public partial class GraphBuildOptions : System.IEquatable<Microsoft.Build.Graph.GraphBuildOptions>
+    {
+        public GraphBuildOptions() { }
+        protected GraphBuildOptions(Microsoft.Build.Graph.GraphBuildOptions original) { }
+        public bool Build { get { throw null; } set { } }
+        protected virtual System.Type EqualityContract { get { throw null; } }
+        public virtual bool Equals(Microsoft.Build.Graph.GraphBuildOptions other) { throw null; }
+        public override bool Equals(object obj) { throw null; }
+        public override int GetHashCode() { throw null; }
+        public static bool operator ==(Microsoft.Build.Graph.GraphBuildOptions r1, Microsoft.Build.Graph.GraphBuildOptions r2) { throw null; }
+        public static bool operator !=(Microsoft.Build.Graph.GraphBuildOptions r1, Microsoft.Build.Graph.GraphBuildOptions r2) { throw null; }
+        protected virtual bool PrintMembers(System.Text.StringBuilder builder) { throw null; }
+        public override string ToString() { throw null; }
+        public virtual Microsoft.Build.Graph.GraphBuildOptions <Clone>$() { throw null; }
+    }
     public sealed partial class GraphBuildRequestData
     {
         public GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild) { }
@@ -1485,9 +1572,11 @@ public GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projec
         public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild) { }
         public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
         public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
+        public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Graph.GraphBuildOptions graphBuildOptions) { }
         public GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
         public GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
         public Microsoft.Build.Execution.BuildRequestDataFlags Flags { get { throw null; } }
+        public Microsoft.Build.Graph.GraphBuildOptions GraphBuildOptions { get { throw null; } }
         public Microsoft.Build.Execution.HostServices HostServices { get { throw null; } }
         public Microsoft.Build.Graph.ProjectGraph ProjectGraph { get { throw null; } }
         public System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> ProjectGraphEntryPoints { get { throw null; } }
@@ -1588,9 +1677,10 @@ public BinaryLogReplayEventSource() { }
         public void Replay(string sourceFilePath) { }
         public void Replay(string sourceFilePath, System.Threading.CancellationToken cancellationToken) { }
     }
-    public partial class BuildEventArgsReader
+    public partial class BuildEventArgsReader : System.IDisposable
     {
         public BuildEventArgsReader(System.IO.BinaryReader binaryReader, int fileFormatVersion) { }
+        public void Dispose() { }
         public Microsoft.Build.Framework.BuildEventArgs Read() { throw null; }
     }
     public delegate void ColorResetter();
@@ -2049,20 +2139,3 @@ public partial struct XmlAttributeLink
         public string Value { get { throw null; } }
     }
 }
-namespace Microsoft.Build.Utilities
-{
-    public partial class ChangeWaves
-    {
-        public static readonly string[] AllWaves;
-        public static readonly System.Version[] AllWavesAsVersion;
-        public const string EnableAllFeatures = "999.999";
-        public const string Wave16_10 = "16.10";
-        public const string Wave16_8 = "16.8";
-        public const string Wave17_0 = "17.0";
-        public ChangeWaves() { }
-        public static string DisabledWave { get { throw null; } set { } }
-        public static bool AreFeaturesEnabled(string wave) { throw null; }
-        public static bool AreFeaturesEnabled(System.Version wave) { throw null; }
-        public static void ResetStateForTests() { }
-    }
-}
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
index 7b1ab0a40ee..4e3c04c3d1e 100644
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
@@ -888,6 +888,10 @@ public BuildAbortedException(string message, System.Exception innerException) {
         public string ErrorCode { get { throw null; } }
         public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
     }
+    public partial class CircularDependencyException : System.Exception
+    {
+        protected CircularDependencyException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
+    }
     public sealed partial class InternalLoggerException : System.Exception
     {
         public InternalLoggerException() { }
@@ -989,6 +993,7 @@ public BuildParameters(Microsoft.Build.Evaluation.ProjectCollection projectColle
         public string NodeExeLocation { get { throw null; } set { } }
         public bool OnlyLogCriticalEvents { get { throw null; } set { } }
         public string OutputResultsCacheFile { get { throw null; } set { } }
+        public Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor ProjectCacheDescriptor { get { throw null; } set { } }
         public Microsoft.Build.Evaluation.ProjectLoadSettings ProjectLoadSettings { get { throw null; } set { } }
         public bool ResetCaches { get { throw null; } set { } }
         public string ResourceManagerSemaphoreName { get { throw null; } set { } }
@@ -1398,6 +1403,73 @@ public enum TargetResultCode : byte
         Success = (byte)1,
     }
 }
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    public partial class CacheContext
+    {
+        public CacheContext(System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem, Microsoft.Build.Graph.ProjectGraph graph=null, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> graphEntryPoints=null) { }
+        public Microsoft.Build.FileSystem.MSBuildFileSystemBase FileSystem { get { throw null; } }
+        public Microsoft.Build.Graph.ProjectGraph Graph { get { throw null; } }
+        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> GraphEntryPoints { get { throw null; } }
+        public string MSBuildExePath { get { throw null; } }
+        public System.Collections.Generic.IReadOnlyDictionary<string, string> PluginSettings { get { throw null; } }
+    }
+    public partial class CacheResult
+    {
+        internal CacheResult() { }
+        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(Microsoft.Build.Execution.BuildResult buildResult) { throw null; }
+        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) { throw null; }
+        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) { throw null; }
+        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateNonCacheHit(Microsoft.Build.Experimental.ProjectCache.CacheResultType resultType) { throw null; }
+    }
+    public enum CacheResultType
+    {
+        CacheHit = 1,
+        CacheMiss = 2,
+        CacheNotApplicable = 3,
+        None = 0,
+    }
+    public abstract partial class PluginLoggerBase
+    {
+        protected PluginLoggerBase(Microsoft.Build.Framework.LoggerVerbosity verbosity) { }
+        public abstract bool HasLoggedErrors { get; protected set; }
+        public abstract void LogError(string error);
+        public abstract void LogMessage(string message, System.Nullable<Microsoft.Build.Framework.MessageImportance> messageImportance=default(System.Nullable<Microsoft.Build.Framework.MessageImportance>));
+        public abstract void LogWarning(string warning);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public partial struct PluginTargetResult
+    {
+        public PluginTargetResult(string targetName, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> taskItems, Microsoft.Build.Execution.BuildResultCode resultCode) { throw null;}
+        public Microsoft.Build.Execution.BuildResultCode ResultCode { get { throw null; } }
+        public string TargetName { get { throw null; } }
+        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> TaskItems { get { throw null; } }
+    }
+    public partial class ProjectCacheDescriptor
+    {
+        internal ProjectCacheDescriptor() { }
+        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> EntryPoints { get { throw null; } }
+        public string PluginAssemblyPath { get { throw null; } }
+        public Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase PluginInstance { get { throw null; } }
+        public System.Collections.Generic.IReadOnlyDictionary<string, string> PluginSettings { get { throw null; } }
+        public Microsoft.Build.Graph.ProjectGraph ProjectGraph { get { throw null; } }
+        public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings=null) { throw null; }
+        public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings=null) { throw null; }
+        public string GetDetailedDescription() { throw null; }
+    }
+    public abstract partial class ProjectCachePluginBase
+    {
+        protected ProjectCachePluginBase() { }
+        public abstract System.Threading.Tasks.Task BeginBuildAsync(Microsoft.Build.Experimental.ProjectCache.CacheContext context, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken);
+        public abstract System.Threading.Tasks.Task EndBuildAsync(Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken);
+        public abstract System.Threading.Tasks.Task<Microsoft.Build.Experimental.ProjectCache.CacheResult> GetCacheResultAsync(Microsoft.Build.Execution.BuildRequestData buildRequest, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken);
+    }
+    public partial class ProxyTargets
+    {
+        public ProxyTargets(System.Collections.Generic.IReadOnlyDictionary<string, string> proxyTargetToRealTargetMap) { }
+        public System.Collections.Generic.IReadOnlyDictionary<string, string> ProxyTargetToRealTargetMap { get { throw null; } }
+    }
+}
 namespace Microsoft.Build.FileSystem
 {
     public abstract partial class MSBuildFileSystemBase
@@ -1468,6 +1540,21 @@ public static partial class MSBuildGlobExtensions
 }
 namespace Microsoft.Build.Graph
 {
+    public partial class GraphBuildOptions : System.IEquatable<Microsoft.Build.Graph.GraphBuildOptions>
+    {
+        public GraphBuildOptions() { }
+        protected GraphBuildOptions(Microsoft.Build.Graph.GraphBuildOptions original) { }
+        public bool Build { get { throw null; } set { } }
+        protected virtual System.Type EqualityContract { get { throw null; } }
+        public virtual bool Equals(Microsoft.Build.Graph.GraphBuildOptions other) { throw null; }
+        public override bool Equals(object obj) { throw null; }
+        public override int GetHashCode() { throw null; }
+        public static bool operator ==(Microsoft.Build.Graph.GraphBuildOptions r1, Microsoft.Build.Graph.GraphBuildOptions r2) { throw null; }
+        public static bool operator !=(Microsoft.Build.Graph.GraphBuildOptions r1, Microsoft.Build.Graph.GraphBuildOptions r2) { throw null; }
+        protected virtual bool PrintMembers(System.Text.StringBuilder builder) { throw null; }
+        public override string ToString() { throw null; }
+        public virtual Microsoft.Build.Graph.GraphBuildOptions <Clone>$() { throw null; }
+    }
     public sealed partial class GraphBuildRequestData
     {
         public GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild) { }
@@ -1479,9 +1566,11 @@ public GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projec
         public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild) { }
         public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
         public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
+        public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Graph.GraphBuildOptions graphBuildOptions) { }
         public GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
         public GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
         public Microsoft.Build.Execution.BuildRequestDataFlags Flags { get { throw null; } }
+        public Microsoft.Build.Graph.GraphBuildOptions GraphBuildOptions { get { throw null; } }
         public Microsoft.Build.Execution.HostServices HostServices { get { throw null; } }
         public Microsoft.Build.Graph.ProjectGraph ProjectGraph { get { throw null; } }
         public System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> ProjectGraphEntryPoints { get { throw null; } }
@@ -1582,9 +1671,10 @@ public BinaryLogReplayEventSource() { }
         public void Replay(string sourceFilePath) { }
         public void Replay(string sourceFilePath, System.Threading.CancellationToken cancellationToken) { }
     }
-    public partial class BuildEventArgsReader
+    public partial class BuildEventArgsReader : System.IDisposable
     {
         public BuildEventArgsReader(System.IO.BinaryReader binaryReader, int fileFormatVersion) { }
+        public void Dispose() { }
         public Microsoft.Build.Framework.BuildEventArgs Read() { throw null; }
     }
     public delegate void ColorResetter();
@@ -2043,20 +2133,3 @@ public partial struct XmlAttributeLink
         public string Value { get { throw null; } }
     }
 }
-namespace Microsoft.Build.Utilities
-{
-    public partial class ChangeWaves
-    {
-        public static readonly string[] AllWaves;
-        public static readonly System.Version[] AllWavesAsVersion;
-        public const string EnableAllFeatures = "999.999";
-        public const string Wave16_10 = "16.10";
-        public const string Wave16_8 = "16.8";
-        public const string Wave17_0 = "17.0";
-        public ChangeWaves() { }
-        public static string DisabledWave { get { throw null; } set { } }
-        public static bool AreFeaturesEnabled(string wave) { throw null; }
-        public static bool AreFeaturesEnabled(System.Version wave) { throw null; }
-        public static void ResetStateForTests() { }
-    }
-}
diff --git a/scripts/Deploy-MSBuild.ps1 b/scripts/Deploy-MSBuild.ps1
index 125e9447ca5..b7bf08ced01 100644
--- a/scripts/Deploy-MSBuild.ps1
+++ b/scripts/Deploy-MSBuild.ps1
@@ -48,7 +48,7 @@ Write-Host "Existing MSBuild assemblies backed up to $BackupFolder"
 if ($runtime -eq "Desktop") {
     $targetFramework = "net472"
 } else {
-    $targetFramework = "netcoreapp2.1"
+    $targetFramework = "net5.0"
 }
 
 $bootstrapBinDirectory = "artifacts\bin\MSBuild.Bootstrap\$configuration\$targetFramework"
@@ -58,6 +58,7 @@ $filesToCopyToBin = @(
     FileToCopy "$bootstrapBinDirectory\Microsoft.Build.Framework.dll"
     FileToCopy "$bootstrapBinDirectory\Microsoft.Build.Tasks.Core.dll"
     FileToCopy "$bootstrapBinDirectory\Microsoft.Build.Utilities.Core.dll"
+    FileToCopy "$bootstrapBinDirectory\Microsoft.NET.StringTools.dll"
 
     FileToCopy "$bootstrapBinDirectory\en\Microsoft.Build.resources.dll" "en"
     FileToCopy "$bootstrapBinDirectory\en\Microsoft.Build.Tasks.Core.resources.dll" "en"
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index 9539898ed8b..8d9406a91cb 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -2604,6 +2604,92 @@ public void LastUpdateWins()
             ObjectModelHelpers.AssertItemHasMetadata(expectedUpdate, items[0]);
         }
 
+        [Theory]
+        [InlineData("abc", "def", "abc")]
+        [InlineData("abc", "de*", "abc")]
+        [InlineData("a*c", "def", "abc")]
+        [InlineData("abc", "def", "*bc")]
+        [InlineData("abc", "d*f", "*bc")]
+        [InlineData("*c", "d*f", "*bc")]
+        [InlineData("a*", "d*", "abc")]
+        public void UpdatesProceedInOrder(string first, string second, string third)
+        {
+            string contents = $@"
+<i Include='abc'>
+    <m1>m1_contents</m1>
+</i>
+<j Include='def'>
+    <m1>m1_contents</m1>
+</j>
+<i Update='{first}'>
+    <m1>first</m1>
+</i>
+<j Update='{second}'>
+    <m1>second</m1>
+</j>
+<i Update='{third}'>
+    <m1>third</m1>
+</i>
+";
+            IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(contents, allItems: true);
+            Dictionary<string, string> expectedUpdatei = new Dictionary<string, string>
+            {
+                {"m1", "third" }
+            };
+            Dictionary<string, string> expectedUpdatej = new Dictionary<string, string>
+            {
+                {"m1", "second" }
+            };
+
+            ObjectModelHelpers.AssertItemHasMetadata(expectedUpdatei, items[0]);
+            ObjectModelHelpers.AssertItemHasMetadata(expectedUpdatej, items[1]);
+        }
+
+        [Fact]
+        public void UpdatingIndividualItemsProceedsInOrder()
+        {
+            string contents = @"
+<i Include='a;b;c'>
+    <m1>m1_contents</m1>
+</i>
+<i Update='a'>
+    <m1>second</m1>
+</i>
+<i Update='b'>
+    <m1>third</m1>
+</i>
+<i Update='c'>
+    <m1>fourth</m1>
+</i>
+<afterFirst Include='@(i)' />
+<i Update='*'>
+    <m1>sixth</m1>
+</i>
+<afterSecond Include='@(i)' />
+<i Update='b'>
+    <m1>seventh</m1>
+</i>
+<afterThird Include='@(i)' />
+<i Update='c'>
+    <m1>eighth</m1>
+</i>
+<afterFourth Include='@(i)' />
+";
+            IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(contents, allItems: true);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "second", items[3]);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "third", items[4]);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "fourth", items[5]);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "sixth", items[6]);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "sixth", items[7]);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "sixth", items[8]);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "sixth", items[9]);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "seventh", items[10]);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "sixth", items[11]);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "sixth", items[12]);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "seventh", items[13]);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "eighth", items[14]);
+        }
+
         [Fact]
         public void UpdateWithNoMetadataShouldNotAffectItems()
         {
@@ -2850,6 +2936,25 @@ public void UpdateFromReferencedItemShouldBeCaseInsensitive()
             ObjectModelHelpers.AssertItemHasMetadata(expectedMetadataA, items[1]);
         }
 
+        [Fact]
+        public void UpdateMetadataWithoutItemReferenceShouldBeCaseInsensitive()
+        {
+            string content = @"
+                              <to Include='a' />
+
+                              <to Update='A' m='m1_contents' />";
+
+            IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(content, true);
+
+            var expectedMetadataA = new Dictionary<string, string>
+            {
+                {"m", "m1_contents"},
+            };
+
+            items[0].ItemType.ShouldBe("to");
+            ObjectModelHelpers.AssertItemHasMetadata(expectedMetadataA, items[0]);
+        }
+
         [Fact]
         public void UndeclaredQualifiedMetadataReferencesInUpdateShouldResolveToEmptyStrings()
         {
diff --git a/src/Build.OM.UnitTests/Definition/Project_Tests.cs b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
index 9474574afd5..6dcaa45e84e 100644
--- a/src/Build.OM.UnitTests/Definition/Project_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
@@ -2850,7 +2850,7 @@ public void GetItemProvenanceGlobMatchesItselfAsGlob()
         [Fact]
         public void GetItemProvenanceResultsShouldBeInItemElementOrder()
         {
-            var itemElements = Environment.ProcessorCount * 5;
+            var itemElements = NativeMethodsShared.GetLogicalCoreCount() * 5;
             var expected = new ProvenanceResultTupleList();
 
             var project =
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index 1f887d229ee..18ad711bac4 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -11,6 +11,8 @@
 
     <AssemblyName>Microsoft.Build.Engine.OM.UnitTests</AssemblyName>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
+
+    <DefineConstants>$(DefineConstants);MICROSOFT_BUILD_ENGINE_OM_UNITTESTS</DefineConstants>
   </PropertyGroup>
 
   <PropertyGroup>
@@ -97,10 +99,6 @@
     <Compile Include="..\Shared\StringBuilderCache.cs">
       <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\IInternable.cs" />
-    <Compile Include="..\Shared\WeakStringCache.cs" />
-    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs" />
-    <Compile Include="..\Shared\OpportunisticIntern.cs" />
     <Compile Include="..\Shared\ExceptionHandling.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index b2936c5c111..b09519f9f71 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -212,6 +212,14 @@ private void SimpleP2PBuild(BuildParameters buildParameters)
                 .ShouldBe(3);
         }
 
+        [Fact]
+        public void GraphBuildOptionsDefaults()
+        {
+            var options = new GraphBuildOptions();
+
+            options.Build.ShouldBeTrue();
+        }
+
         /// <summary>
         /// A simple successful graph build.
         /// </summary>
@@ -3986,7 +3994,7 @@ public void MultiProcReentrantProjectWithCallTargetDoesNotFail()
                 var buildParameters = new BuildParameters()
                 {
                     DisableInProcNode = true,
-                    MaxNodeCount = Environment.ProcessorCount,
+                    MaxNodeCount = NativeMethodsShared.GetLogicalCoreCount(),
                     EnableNodeReuse = false,
                     Loggers = new List<ILogger>()
                     {
@@ -4279,5 +4287,35 @@ public void GraphBuildCircular()
             result.OverallResult.ShouldBe(BuildResultCode.Failure);
             result.CircularDependency.ShouldBeTrue();
         }
+
+        [Fact]
+        public void GraphBuildShouldBeAbleToConstructGraphButSkipBuild()
+        {
+            var graph = Helpers.CreateProjectGraph(env: _env, dependencyEdges: new Dictionary<int, int[]> {{1, new[] {2, 3}}});
+
+            MockLogger logger = null;
+
+            using (var buildSession = new Helpers.BuildManagerSession(_env))
+            {
+                var graphResult = buildSession.BuildGraphSubmission(
+                    new GraphBuildRequestData(
+                        projectGraphEntryPoints: new[] {new ProjectGraphEntryPoint(graph.GraphRoots.First().ProjectInstance.FullPath)},
+                        targetsToBuild: new string[0],
+                        hostServices: null,
+                        flags: BuildRequestDataFlags.None,
+                        graphBuildOptions: new GraphBuildOptions {Build = false}));
+
+                graphResult.OverallResult.ShouldBe(BuildResultCode.Success);
+                logger = buildSession.Logger;
+            }
+
+            logger.EvaluationStartedEvents.Count.ShouldBe(3);
+            logger.ProjectStartedEvents.ShouldBeEmpty();
+            logger.TargetStartedEvents.ShouldBeEmpty();
+            logger.BuildStartedEvents.ShouldHaveSingleItem();
+            logger.BuildFinishedEvents.ShouldHaveSingleItem();
+            logger.FullLog.ShouldContain("Static graph loaded in");
+            logger.FullLog.ShouldContain("3 nodes, 2 edges");
+        }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
index 237fcf00856..e46a84eb0e4 100644
--- a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Engine.UnitTests.TestComparers;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
diff --git a/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs b/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
index 791db350934..738978a9e07 100644
--- a/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Unittest;
 using Shouldly;
 using Xunit;
 using static Microsoft.Build.Unittest.BuildResultUtilities;
@@ -279,25 +280,7 @@ private void AssertBuildResultsEquivalent(BuildResult inputResult, BuildResult a
             aggregatedBuildResult.NodeRequestId.ShouldBe(BuildRequest.InvalidNodeRequestId);
             aggregatedBuildResult.SubmissionId.ShouldBe(BuildEventContext.InvalidSubmissionId);
 
-            inputResult.InitialTargets.ShouldBe(aggregatedBuildResult.InitialTargets);
-            inputResult.DefaultTargets.ShouldBe(aggregatedBuildResult.DefaultTargets);
-            inputResult.CircularDependency.ShouldBe(aggregatedBuildResult.CircularDependency);
-            inputResult.Exception.ShouldBe(aggregatedBuildResult.Exception);
-            inputResult.OverallResult.ShouldBe(aggregatedBuildResult.OverallResult);
-            inputResult.ProjectStateAfterBuild.ShouldBe(aggregatedBuildResult.ProjectStateAfterBuild);
-
-            Helpers.AssertDictionariesEqual(inputResult.ResultsByTarget, aggregatedBuildResult.ResultsByTarget, (a, b) =>
-            {
-                a.Key.ShouldBe(b.Key);
-
-                a.Value.Exception.ShouldBe(b.Value.Exception);
-                a.Value.Items.ShouldBe(b.Value.Items);
-                a.Value.ResultCode.ShouldBe(b.Value.ResultCode);
-
-                a.Value.WorkUnitResult.ActionCode.ShouldBe(b.Value.WorkUnitResult.ActionCode);
-                a.Value.WorkUnitResult.Exception.ShouldBe(b.Value.WorkUnitResult.Exception);
-                a.Value.WorkUnitResult.ResultCode.ShouldBe(b.Value.WorkUnitResult.ResultCode);
-            });
+            SdkUtilities.EngineHelpers.AssertBuildResultsEqual(inputResult, aggregatedBuildResult);
         }
 
         private void AssertConfigurationsEquivalent(BuildRequestConfiguration inputConfiguration, BuildRequestConfiguration aggregatedConfig)
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index 27211e3edea..8c7c480a220 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -466,7 +466,7 @@ public void LogProjectEvaluationFinished(BuildEventContext projectEvaluationEven
         /// <summary>
         /// Logs a project started event
         /// </summary>
-        public BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventContext, int submissionId, int projectId, BuildEventContext parentBuildEventContext, string projectFile, string targetNames, IEnumerable<DictionaryEntry> properties, IEnumerable<DictionaryEntry> items)
+        public BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventContext, int submissionId, int projectId, BuildEventContext parentBuildEventContext, string projectFile, string targetNames, IEnumerable<DictionaryEntry> properties, IEnumerable<DictionaryEntry> items, int evaluationId = BuildEventContext.InvalidEvaluationId)
         {
             return new BuildEventContext(0, 0, 0, 0);
         }
diff --git a/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs b/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
index 9cd1fe75b02..346da6846b9 100644
--- a/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Execution;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using Xunit;
+using Microsoft.Build.Engine.UnitTests.TestComparers;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
diff --git a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
index 8660f8d86fc..93abec24663 100644
--- a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
@@ -20,6 +20,7 @@
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using Xunit;
+using Microsoft.Build.Engine.UnitTests.TestComparers;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index ca2de8f8f3b..afd56aea915 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -513,7 +513,7 @@ public void ReadingCorruptedStreamThrows()
                 memoryStream.Position = 0;
 
                 var binaryReader = new BinaryReader(memoryStream);
-                var buildEventArgsReader = new BuildEventArgsReader(binaryReader, BinaryLogger.FileFormatVersion);
+                using var buildEventArgsReader = new BuildEventArgsReader(binaryReader, BinaryLogger.FileFormatVersion);
 
                 Assert.Throws<EndOfStreamException>(() => buildEventArgsReader.Read());
             }
@@ -570,7 +570,7 @@ private void Roundtrip<T>(T args, params Func<T, string>[] fieldsToCompare)
             memoryStream.Position = 0;
 
             var binaryReader = new BinaryReader(memoryStream);
-            var buildEventArgsReader = new BuildEventArgsReader(binaryReader, BinaryLogger.FileFormatVersion);
+            using var buildEventArgsReader = new BuildEventArgsReader(binaryReader, BinaryLogger.FileFormatVersion);
             var deserializedArgs = (T)buildEventArgsReader.Read();
 
             Assert.Equal(length, memoryStream.Position);
diff --git a/src/Build.UnitTests/ChangeWaves_Tests.cs b/src/Build.UnitTests/ChangeWaves_Tests.cs
index 4574dee52b8..d561fcaf9ef 100644
--- a/src/Build.UnitTests/ChangeWaves_Tests.cs
+++ b/src/Build.UnitTests/ChangeWaves_Tests.cs
@@ -3,11 +3,12 @@
 
 using Xunit;
 using Shouldly;
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Utilities;
-using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Xunit.Abstractions;
-using Microsoft.Build.Evaluation;
+using System;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Engine.UnitTests
 {
@@ -19,120 +20,112 @@ public ChangeWaves_Tests(ITestOutputHelper output)
             _output = output;
         }
 
-        [Theory]
-        [InlineData("16.8")]
-        [InlineData("16.10")]
-        [InlineData("17.0")]
-        [InlineData("25.87")]
-        [InlineData("102.87")]
-        public void EnableAllFeaturesBehindChangeWavesEnablesAllFeaturesBehindChangeWaves(string featureWave)
+        /// <summary>
+        /// Performs necessary operations for setting the MSBuildDisableFeaturesFromVersion environment variable.
+        /// This is required because Change Waves is static and stale values can be seen between tests in the same assembly.
+        /// </summary>
+        /// <param name="wave">The version to set as the current Change Wave.</param>
+        private void SetChangeWave(string wave, TestEnvironment env)
         {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                env.SetChangeWave(ChangeWaves.EnableAllFeatures);
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-                ChangeWaves.AreFeaturesEnabled(featureWave).ShouldBe(true);
+            ChangeWaves.ResetStateForTests();
+            env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", wave);
+            BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+        }
+
+        /// <summary>
+        /// Helper function to build a simple project based on a particular change wave being set.
+        /// Call SetChangeWave on your TestEnvironment before calling this function.
+        /// </summary>
+        /// <param name="testEnvironment">The TestEnvironment being used for this test.</param>
+        /// <param name="versionToCheckAgainstCurrentChangeWave">The version to compare to the current set Change Wave.</param>
+        /// <param name="currentChangeWaveShouldUltimatelyResolveTo">What the project property for the environment variable MSBuildDisableFeaturesFromVersion ultimately resolves to.</param>
+        /// <param name="warningCodesLogShouldContain">An array of warning codes that should exist in the resulting log. Ex: "MSB4271".</param>
+        private void buildSimpleProjectAndValidateChangeWave(TestEnvironment testEnvironment, Version versionToCheckAgainstCurrentChangeWave, Version currentChangeWaveShouldUltimatelyResolveTo, params string[] warningCodesLogShouldContain)
+        {
+            bool isThisWaveEnabled = versionToCheckAgainstCurrentChangeWave < currentChangeWaveShouldUltimatelyResolveTo || currentChangeWaveShouldUltimatelyResolveTo == ChangeWaves.EnableAllFeatures;
 
-                string projectFile = $"" +
-                    $"<Project>" +
-                        $"<Target Name='HelloWorld' Condition=\"'$(MSBUILDDISABLEFEATURESFROMVERSION)' == '{ChangeWaves.EnableAllFeatures}' and $([MSBuild]::AreFeaturesEnabled('{featureWave}'))\">" +
-                            $"<Message Text='Hello World!'/>" +
-                        $"</Target>" +
-                    $"</Project>";
+            ChangeWaves.AreFeaturesEnabled(versionToCheckAgainstCurrentChangeWave).ShouldBe(isThisWaveEnabled);
 
-                TransientTestFile file = env.CreateFile("proj.csproj", projectFile);
+            string projectFile = $"" +
+                $"<Project>" +
+                    $"<Target Name='HelloWorld' Condition=\"$([MSBuild]::AreFeaturesEnabled('{versionToCheckAgainstCurrentChangeWave}')) and '$(MSBUILDDISABLEFEATURESFROMVERSION)' == '{currentChangeWaveShouldUltimatelyResolveTo}'\">" +
+                        $"<Message Text='Hello World!'/>" +
+                    $"</Target>" +
+                $"</Project>";
 
-                ProjectCollection collection = new ProjectCollection();
-                MockLogger log = new MockLogger();
-                collection.RegisterLogger(log);
+            TransientTestFile file = testEnvironment.CreateFile("proj.csproj", projectFile);
 
-                collection.LoadProject(file.Path).Build().ShouldBeTrue();
-                log.AssertLogContains("Hello World!");
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+            ProjectCollection collection = new ProjectCollection();
+            MockLogger log = new MockLogger(_output);
+            collection.RegisterLogger(log);
+
+            Project p = collection.LoadProject(file.Path);
+            p.Build().ShouldBeTrue();
+
+            log.FullLog.Contains("Hello World!").ShouldBe(isThisWaveEnabled);
+
+            if (warningCodesLogShouldContain != null)
+            {
+                log.WarningCount.ShouldBe(warningCodesLogShouldContain.Length);
+                log.AssertLogContains(warningCodesLogShouldContain);
             }
+
+            ChangeWaves.ResetStateForTests();
         }
 
-        [Theory]
-        [InlineData("16.8")]
-        [InlineData("16.10")]
-        [InlineData("17.0")]
-        [InlineData("27.3")]
-        public void NoChangeWaveSetMeansAllChangeWavesAreEnabled(string featureWave)
+        [Fact]
+        public void EnableAllFeaturesBehindChangeWavesEnablesAllFeaturesBehindChangeWaves()
         {
             using (TestEnvironment env = TestEnvironment.Create())
             {
-                ChangeWaves.ResetStateForTests();
-                ChangeWaves.AreFeaturesEnabled(featureWave).ShouldBe(true);
-
-                string projectFile = $"" +
-                    $"<Project>" +
-                        $"<Target Name='HelloWorld' Condition=\"'$(MSBUILDDISABLEFEATURESFROMVERSION)' == '{ChangeWaves.EnableAllFeatures}' and $([MSBuild]::AreFeaturesEnabled('{featureWave}'))\">" +
-                            $"<Message Text='Hello World!'/>" +
-                        $"</Target>" +
-                    $"</Project>";
-
-                TransientTestFile file = env.CreateFile("proj.csproj", projectFile);
+                SetChangeWave(ChangeWaves.EnableAllFeatures.ToString(), env);
 
-                ProjectCollection collection = new ProjectCollection();
-                MockLogger log = new MockLogger();
-                collection.RegisterLogger(log);
-
-                collection.LoadProject(file.Path).Build().ShouldBeTrue();
-                log.AssertLogContains("Hello World!");
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+                for (int i = 0; i < ChangeWaves.AllWaves.Length - 1; i++)
+                {
+                    buildSimpleProjectAndValidateChangeWave(testEnvironment: env,
+                                                            versionToCheckAgainstCurrentChangeWave: ChangeWaves.AllWaves[i],
+                                                            currentChangeWaveShouldUltimatelyResolveTo: ChangeWaves.EnableAllFeatures,
+                                                            warningCodesLogShouldContain: null);
+                }
             }
         }
 
         [Theory]
-        [InlineData("test")]
-        [InlineData("    ")]
-        [InlineData("")]
-        [InlineData("16-7")]
-        [InlineData("16x7")]
-        [InlineData("16=7")]
-        public void InvalidCallerForIsFeatureEnabledThrows(string waveToCheck)
+        [InlineData("16.8")]
+        [InlineData("16.10")]
+        [InlineData("17.0")]
+        [InlineData("27.3")]
+        public void NoChangeWaveSetMeansAllChangeWavesAreEnabled(string featureVersion)
         {
             using (TestEnvironment env = TestEnvironment.Create())
             {
-                env.SetChangeWave("16.8");
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-                Shouldly.Should.Throw<InternalErrorException>(() => ChangeWaves.AreFeaturesEnabled(waveToCheck));
+                // Reset static ChangeWave
+                SetChangeWave(string.Empty, env);
+                Version featureAsVersion = Version.Parse(featureVersion);
+                ChangeWaves.AreFeaturesEnabled(featureAsVersion).ShouldBe(true);
+
+                buildSimpleProjectAndValidateChangeWave(testEnvironment: env,
+                                                        versionToCheckAgainstCurrentChangeWave: featureAsVersion,
+                                                        currentChangeWaveShouldUltimatelyResolveTo: ChangeWaves.EnableAllFeatures,
+                                                        warningCodesLogShouldContain: null);
             }
         }
 
         [Theory]
-        [InlineData("test", "16.8")]
-        [InlineData("16_8", "5.7")]
-        [InlineData("16x8", "20.4")]
-        [InlineData("garbage", "18.20")]
-        public void InvalidFormatThrowsWarningAndLeavesFeaturesEnabled(string disableFromWave, string featureWave)
+        [InlineData("test")]
+        [InlineData("16_8")]
+        [InlineData("16x8")]
+        [InlineData("garbage")]
+        public void InvalidFormatThrowsWarningAndLeavesFeaturesEnabled(string disableFeaturesFromVersion)
         {
             using (TestEnvironment env = TestEnvironment.Create())
             {
-                env.SetChangeWave(disableFromWave);
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-                ChangeWaves.AreFeaturesEnabled(featureWave).ShouldBe(true);
-
-                string projectFile = $"" +
-                    $"<Project>" +
-                        $"<Target Name='HelloWorld' Condition=\"'$(MSBUILDDISABLEFEATURESFROMVERSION)' == '{ChangeWaves.EnableAllFeatures}' and $([MSBuild]::AreFeaturesEnabled('{featureWave}'))\">" +
-                            $"<Message Text='Hello World!'/>" +
-                        $"</Target>" +
-                    $"</Project>";
-
-                TransientTestFile file = env.CreateFile("proj.csproj", projectFile);
-
-                ProjectCollection collection = new ProjectCollection();
-                MockLogger log = new MockLogger();
-                collection.RegisterLogger(log);
-
-                Project p = collection.LoadProject(file.Path);
-                p.Build().ShouldBeTrue();
+                SetChangeWave(disableFeaturesFromVersion, env);
 
-                log.WarningCount.ShouldBe(1);
-                log.AssertLogContains("invalid format");
-                log.AssertLogContains("Hello World!");
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+                buildSimpleProjectAndValidateChangeWave(testEnvironment: env,
+                                                        versionToCheckAgainstCurrentChangeWave: ChangeWaves.HighestWave,
+                                                        currentChangeWaveShouldUltimatelyResolveTo: ChangeWaves.EnableAllFeatures,
+                                                        warningCodesLogShouldContain: "MSB4271");
             }
         }
 
@@ -140,79 +133,46 @@ public void InvalidFormatThrowsWarningAndLeavesFeaturesEnabled(string disableFro
         [InlineData("0.8")]
         [InlineData("4.5")]
         [InlineData("10.0")]
-        public void VersionTooLowClampsToLowestVersionInRotation(string disableFromWave)
+        public void VersionTooLowClampsToLowestVersionInRotation(string disableFeaturesFromVersion)
         {
             using (TestEnvironment env = TestEnvironment.Create())
             {
-                env.SetChangeWave(disableFromWave);
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+                SetChangeWave(disableFeaturesFromVersion, env);
 
                 // All waves should be disabled
                 for (int i = 0; i < ChangeWaves.AllWaves.Length; i++)
                 {
-                    ChangeWaves.ResetStateForTests();
-                    string projectFile = $"" +
-                        $"<Project>" +
-                            $"<Target Name='HelloWorld' Condition=\"'$(MSBUILDDISABLEFEATURESFROMVERSION)' == '{ChangeWaves.LowestWave}' and $([MSBuild]::AreFeaturesEnabled('{ChangeWaves.AllWaves[i]}')) == false\">" +
-                                $"<Message Text='Hello World!'/>" +
-                            $"</Target>" +
-                        $"</Project>";
-
-                    TransientTestFile file = env.CreateFile("proj.csproj", projectFile);
-
-                    ProjectCollection collection = new ProjectCollection();
-                    MockLogger log = new MockLogger();
-                    collection.RegisterLogger(log);
-
-                    Project p = collection.LoadProject(file.Path);
-                    p.Build().ShouldBeTrue();
-
-                    BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                    log.WarningCount.ShouldBe(1);
-                    log.AssertLogContains("out of rotation");
-                    log.AssertLogContains("Hello World!");
+                    buildSimpleProjectAndValidateChangeWave(testEnvironment: env,
+                                                            versionToCheckAgainstCurrentChangeWave: ChangeWaves.AllWaves[i],
+                                                            currentChangeWaveShouldUltimatelyResolveTo: ChangeWaves.LowestWave,
+                                                            warningCodesLogShouldContain: "MSB4272");
                 }
-
             }
         }
 
         [Theory]
         [InlineData("100.10")]
         [InlineData("203.45")]
-        public void VersionTooHighClampsToHighestVersionInRotation(string disableFromWave)
+        public void VersionTooHighClampsToHighestVersionInRotation(string disableFeaturesFromVersion)
         {
             using (TestEnvironment env = TestEnvironment.Create())
             {
-                env.SetChangeWave(disableFromWave);
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+                SetChangeWave(disableFeaturesFromVersion, env);
 
                 // all waves but the highest should pass
-                for (int i = 0; i < ChangeWaves.AllWaves.Length-1; i++)
+                for (int i = 0; i < ChangeWaves.AllWaves.Length - 1; i++)
                 {
-                    ChangeWaves.ResetStateForTests();
-                    string projectFile = $"" +
-                        $"<Project>" +
-                            $"<Target Name='HelloWorld' Condition=\"'$(MSBUILDDISABLEFEATURESFROMVERSION)' == '{ChangeWaves.HighestWave}' and $([MSBuild]::AreFeaturesEnabled('{ChangeWaves.AllWaves[i]}'))\">" +
-                                $"<Message Text='Hello World!'/>" +
-                            $"</Target>" +
-                        $"</Project>";
-
-                    TransientTestFile file = env.CreateFile("proj.csproj", projectFile);
-
-                    ProjectCollection collection = new ProjectCollection();
-                    MockLogger log = new MockLogger();
-                    collection.RegisterLogger(log);
-
-                    Project p = collection.LoadProject(file.Path);
-                    p.Build().ShouldBeTrue();
-
-                    BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                    log.WarningCount.ShouldBe(1);
-                    log.AssertLogContains("out of rotation");
-                    log.AssertLogContains("Hello World!");
+                    buildSimpleProjectAndValidateChangeWave(testEnvironment: env,
+                                        versionToCheckAgainstCurrentChangeWave: ChangeWaves.AllWaves[i],
+                                        currentChangeWaveShouldUltimatelyResolveTo: ChangeWaves.HighestWave,
+                                        warningCodesLogShouldContain: "MSB4272");
                 }
+
+                // Make sure the last wave is disabled.
+                buildSimpleProjectAndValidateChangeWave(testEnvironment: env,
+                                                        versionToCheckAgainstCurrentChangeWave: ChangeWaves.AllWaves[ChangeWaves.AllWaves.Length - 1],
+                                                        currentChangeWaveShouldUltimatelyResolveTo: ChangeWaves.HighestWave,
+                                                        warningCodesLogShouldContain: "MSB4272");
             }
         }
 
@@ -221,29 +181,12 @@ public void VersionSetToValidValueButInvalidVersionSetsNextVersion()
         {
             using (TestEnvironment env = TestEnvironment.Create())
             {
-                env.SetChangeWave($"{ChangeWaves.LowestWaveAsVersion.Major}.{ChangeWaves.LowestWaveAsVersion.Minor}.{ChangeWaves.LowestWaveAsVersion.Build+1}");
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                // All waves should be disabled
-                    string projectFile = $"" +
-                        $"<Project>" +
-                            $"<Target Name='HelloWorld' Condition=\"'$(MSBUILDDISABLEFEATURESFROMVERSION)' == '{ChangeWaves.AllWaves[1]}' and $([MSBuild]::AreFeaturesEnabled('{ChangeWaves.LowestWave}'))\">" +
-                                $"<Message Text='Hello World!'/>" +
-                            $"</Target>" +
-                        $"</Project>";
-
-                    TransientTestFile file = env.CreateFile("proj.csproj", projectFile);
-
-                    ProjectCollection collection = new ProjectCollection();
-                    MockLogger log = new MockLogger();
-                    collection.RegisterLogger(log);
-
-                    Project p = collection.LoadProject(file.Path);
-                    p.Build().ShouldBeTrue();
-
-                    BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-                    log.AssertLogContains("Hello World!");
+                SetChangeWave($"{ChangeWaves.LowestWave.Major}.{ChangeWaves.LowestWave.Minor}.{ChangeWaves.LowestWave.Build + 1}", env);
 
+                buildSimpleProjectAndValidateChangeWave(testEnvironment: env,
+                                                        versionToCheckAgainstCurrentChangeWave: ChangeWaves.LowestWave,
+                                                        currentChangeWaveShouldUltimatelyResolveTo: ChangeWaves.AllWaves[1],
+                                                        warningCodesLogShouldContain: null);
             }
         }
 
@@ -252,33 +195,21 @@ public void CorrectlyDetermineEnabledFeatures()
         {
             using (TestEnvironment env = TestEnvironment.Create())
             {
-                env.SetChangeWave(ChangeWaves.HighestWave);
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+                SetChangeWave(ChangeWaves.HighestWave.ToString(), env);
 
-                for (int i = 0; i < ChangeWaves.AllWaves.Length-1; i++)
+                for (int i = 0; i < ChangeWaves.AllWaves.Length - 1; i++)
                 {
-                    ChangeWaves.DisabledWave = null;
-                    ChangeWaves.AreFeaturesEnabled(ChangeWaves.AllWaves[i]).ShouldBe(true);
-
-                    string projectFile = $"" +
-                        $"<Project>" +
-                            $"<Target Name='HelloWorld' Condition=\"$([MSBuild]::AreFeaturesEnabled('{ChangeWaves.AllWaves[i]}'))\">" +
-                                $"<Message Text='Hello World!'/>" +
-                            $"</Target>" +
-                        $"</Project>";
-
-                    TransientTestFile file = env.CreateFile("proj.csproj", projectFile);
-
-                    ProjectCollection collection = new ProjectCollection();
-                    MockLogger log = new MockLogger();
-                    collection.RegisterLogger(log);
-
-                    Project p = collection.LoadProject(file.Path);
-                    p.Build().ShouldBeTrue();
-
-                    BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-                    log.AssertLogContains("Hello World!");
+                    buildSimpleProjectAndValidateChangeWave(testEnvironment: env,
+                                                            versionToCheckAgainstCurrentChangeWave: ChangeWaves.AllWaves[i],
+                                                            currentChangeWaveShouldUltimatelyResolveTo: ChangeWaves.HighestWave,
+                                                            warningCodesLogShouldContain: null);
                 }
+
+                // Make sure the last wave is disabled.
+                buildSimpleProjectAndValidateChangeWave(testEnvironment: env,
+                                                        versionToCheckAgainstCurrentChangeWave: ChangeWaves.AllWaves[ChangeWaves.AllWaves.Length - 1],
+                                                        currentChangeWaveShouldUltimatelyResolveTo: ChangeWaves.HighestWave,
+                                                        warningCodesLogShouldContain: null);
             }
         }
 
@@ -287,32 +218,15 @@ public void CorrectlyDetermineDisabledFeatures()
         {
             using (TestEnvironment env = TestEnvironment.Create())
             {
-                env.SetChangeWave(ChangeWaves.LowestWave);
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+                SetChangeWave(ChangeWaves.LowestWave.ToString(), env);
 
-                foreach (string wave in ChangeWaves.AllWaves)
+                foreach (Version wave in ChangeWaves.AllWaves)
                 {
-                    ChangeWaves.AreFeaturesEnabled(wave).ShouldBeFalse();
-
-                    string projectFile = $"" +
-                        $"<Project>" +
-                            $"<Target Name='HelloWorld' Condition=\"$([MSBuild]::AreFeaturesEnabled('{wave}')) == false\">" +
-                                $"<Message Text='Hello World!'/>" +
-                            $"</Target>" +
-                        $"</Project>";
-
-                    TransientTestFile file = env.CreateFile("proj.csproj", projectFile);
-
-                    ProjectCollection collection = new ProjectCollection();
-                    MockLogger log = new MockLogger();
-                    collection.RegisterLogger(log);
-
-                    Project p = collection.LoadProject(file.Path);
-                    p.Build().ShouldBeTrue();
-
-                    log.AssertLogContains("Hello World!");
+                    buildSimpleProjectAndValidateChangeWave(testEnvironment: env,
+                                                            versionToCheckAgainstCurrentChangeWave: wave,
+                                                            currentChangeWaveShouldUltimatelyResolveTo: ChangeWaves.LowestWave,
+                                                            warningCodesLogShouldContain: null);
                 }
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
             }
         }
     }
diff --git a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
index ea03579a917..786305ab9c0 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
@@ -1,21 +1,28 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Construction;
+using Microsoft.Build.Exceptions;
+using Microsoft.Build.Shared;
+using Shouldly;
 using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
-
-using Microsoft.Build.Construction;
-using Microsoft.Build.Shared;
-using Shouldly;
-using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
+using Xunit.Abstractions;
 
 namespace Microsoft.Build.UnitTests.Construction
 {
     public class SolutionFile_Tests
     {
+        public ITestOutputHelper TestOutputHelper { get; }
+
+        public SolutionFile_Tests(ITestOutputHelper testOutputHelper)
+        {
+            TestOutputHelper = testOutputHelper;
+        }
+
         /// <summary>
         /// Test that a solution filter file is parsed correctly, and it can accurately respond as to whether a project should be filtered out.
         /// </summary>
@@ -63,14 +70,20 @@ public void ParseSolutionFilter()
                       ""solution"": {
                         ""path"": """ + sln.Path.Replace("\\", "\\\\") + @""",
                         ""projects"": [
-                          """ + Path.Combine("src", Path.GetFileName(microsoftBuild.Path)).Replace("\\", "\\\\") + @""",
-                          """ + Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)).Replace("\\", "\\\\") + @"""
+                          """ + Path.Combine("src", Path.GetFileName(microsoftBuild.Path)!).Replace("\\", "\\\\") + @""",
+                          """ + Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)!).Replace("\\", "\\\\") + @"""
                         ]
                         }
                     }");
                 SolutionFile sp = SolutionFile.Parse(slnf.Path);
-                Assert.True(sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(microsoftBuild.Path))) && sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(tasksUnitTests.Path))));
-                Assert.False(sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(commandLineUnitTests.Path))) || sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(msbuild.Path))) || sp.ProjectShouldBuild(Path.Combine("src", "notAProject.csproj")));
+                sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(microsoftBuild.Path)!)).ShouldBeTrue();
+                sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)!)).ShouldBeTrue();
+
+                
+                (sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(commandLineUnitTests.Path)!))
+                 || sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(msbuild.Path)!))
+                 || sp.ProjectShouldBuild(Path.Combine("src", "notAProject.csproj")))
+                    .ShouldBeFalse();
             }
         }
 
@@ -89,10 +102,10 @@ public void BasicParseFirstProjectLine()
                 "Project(\"{Project GUID}\") = \"Project name\", \"Relative path to project file\", \"Unique name-GUID\"",
                  proj
             );
-            Assert.Equal(SolutionProjectType.Unknown, proj.ProjectType);
-            Assert.Equal("Project name", proj.ProjectName);
-            Assert.Equal("Relative path to project file", proj.RelativePath);
-            Assert.Equal("Unique name-GUID", proj.ProjectGuid);
+            proj.ProjectType.ShouldBe(SolutionProjectType.Unknown);
+            proj.ProjectName.ShouldBe("Project name");
+            proj.RelativePath.ShouldBe("Relative path to project file");
+            proj.ProjectGuid.ShouldBe("Unique name-GUID");
         }
 
         /// <summary>
@@ -105,7 +118,7 @@ public void BasicParseFirstProjectLine()
         [Trait("Category", "netcore-linux-failing")]
         public void ParseFirstProjectLine_VC()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 SolutionFile p = new SolutionFile();
                 p.FullPath = "c:\\foo.sln";
@@ -116,10 +129,7 @@ public void ParseFirstProjectLine_VC()
                     "Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"Project name.vcproj\", \"Relative path\\to\\Project name.vcproj\", \"Unique name-GUID\"",
                      proj
                 );
-
-                Assert.True(false, "Should not get here");
-            }
-           );
+            });
         }
         /// <summary>
         /// Test that the first project line of a project with the C++ project guid and an
@@ -138,10 +148,10 @@ public void ParseFirstProjectLine_VC2()
                 "Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"Project name.myvctype\", \"Relative path\\to\\Project name.myvctype\", \"Unique name-GUID\"",
                  proj
             );
-            Assert.Equal(SolutionProjectType.KnownToBeMSBuildFormat, proj.ProjectType);
-            Assert.Equal("Project name.myvctype", proj.ProjectName);
-            Assert.Equal("Relative path\\to\\Project name.myvctype", proj.RelativePath);
-            Assert.Equal("Unique name-GUID", proj.ProjectGuid);
+            proj.ProjectType.ShouldBe(SolutionProjectType.KnownToBeMSBuildFormat);
+            proj.ProjectName.ShouldBe("Project name.myvctype");
+            proj.RelativePath.ShouldBe("Relative path\\to\\Project name.myvctype");
+            proj.ProjectGuid.ShouldBe("Unique name-GUID");
         }
 
         /// <summary>
@@ -159,10 +169,10 @@ public void ParseFirstProjectLineWithDifferentSpacing()
                 "Project(\" {Project GUID} \")  = \" Project name \",  \" Relative path to project file \"    , \" Unique name-GUID \"",
                  proj
             );
-            Assert.Equal(SolutionProjectType.Unknown, proj.ProjectType);
-            Assert.Equal("Project name", proj.ProjectName);
-            Assert.Equal("Relative path to project file", proj.RelativePath);
-            Assert.Equal("Unique name-GUID", proj.ProjectGuid);
+            proj.ProjectType.ShouldBe(SolutionProjectType.Unknown);
+            proj.ProjectName.ShouldBe("Project name");
+            proj.RelativePath.ShouldBe("Relative path to project file");
+            proj.ProjectGuid.ShouldBe("Unique name-GUID");
         }
 
         /// <summary>
@@ -181,10 +191,10 @@ public void ParseFirstProjectLine_InvalidProject()
                 "Project(\"{Project GUID}\") = \"\", \"src\\.proj\", \"Unique name-GUID\"",
                  proj
             );
-            Assert.Equal(SolutionProjectType.Unknown, proj.ProjectType);
-            Assert.StartsWith("EmptyProjectName", proj.ProjectName);
-            Assert.Equal("src\\.proj", proj.RelativePath);
-            Assert.Equal("Unique name-GUID", proj.ProjectGuid);
+            proj.ProjectType.ShouldBe(SolutionProjectType.Unknown);
+            proj.ProjectName.ShouldStartWith("EmptyProjectName");
+            proj.RelativePath.ShouldBe("src\\.proj");
+            proj.ProjectGuid.ShouldBe("Unique name-GUID");
         }
 
         /// <summary>
@@ -228,8 +238,8 @@ public void ParseEtpProject()
                         EndProject";
                 SolutionFile solution = ParseSolutionHelper(solutionFileContents);
                 //Project should get added to the solution
-                Assert.Equal(@"someproj.etp", solution.ProjectsInOrder[0].RelativePath);
-                Assert.Equal(@"ClassLibrary2.csproj", solution.ProjectsInOrder[1].RelativePath);
+                solution.ProjectsInOrder[0].RelativePath.ShouldBe(@"someproj.etp");
+                solution.ProjectsInOrder[1].RelativePath.ShouldBe(@"ClassLibrary2.csproj");
             }
             // Delete the files created during the test
             finally
@@ -301,11 +311,10 @@ public void CanBeMSBuildFile()
 
 
                 SolutionFile solution = ParseSolutionHelper(solutionFileContents);
-                ProjectInSolution project = (ProjectInSolution)solution.ProjectsByGuid["{AD0F3D02-9925-4D57-9DAF-E0A9D936ABDB}"];
-                ProjectInSolution project2 = (ProjectInSolution)solution.ProjectsByGuid["{CCCCCCCC-9925-4D57-9DAF-E0A9D936ABDB}"];
-                string error = null;
-                Assert.False(project.CanBeMSBuildProjectFile(out error));
-                Assert.True(project2.CanBeMSBuildProjectFile(out error));
+                ProjectInSolution project = solution.ProjectsByGuid["{AD0F3D02-9925-4D57-9DAF-E0A9D936ABDB}"];
+                ProjectInSolution project2 = solution.ProjectsByGuid["{CCCCCCCC-9925-4D57-9DAF-E0A9D936ABDB}"];
+                project.CanBeMSBuildProjectFile(out _).ShouldBeFalse();
+                project2.CanBeMSBuildProjectFile(out _).ShouldBeTrue();
             }
             // Delete the files created during the test
             finally
@@ -355,13 +364,12 @@ public void CanBeMSBuildFileRejectsMSBuildLikeFiles()
                             EndProjectSection
                         EndProject";
 
-                string error = null;
                 SolutionFile solution = ParseSolutionHelper(solutionFileContents);
                 ProjectInSolution project1 = solution.ProjectsByGuid["{CCCCCCCC-9925-4D57-9DAF-E0A9D936ABDB}"];
                 ProjectInSolution project2 = solution.ProjectsByGuid["{DEA89696-F42B-4B58-B7EE-017FF40817D1}"];
 
-                project1.CanBeMSBuildProjectFile(out error).ShouldBe(false);
-                project2.CanBeMSBuildProjectFile(out error).ShouldBe(false);
+                project1.CanBeMSBuildProjectFile(out _).ShouldBe(false);
+                project2.CanBeMSBuildProjectFile(out _).ShouldBe(false);
             }
         }
 
@@ -420,9 +428,9 @@ public void ParseNestedEtpProjectSingleLevel()
                 SolutionFile solution = ParseSolutionHelper(solutionFileContents);
 
                 //Project should get added to the solution
-                Assert.Equal(@"someproj.etp", solution.ProjectsInOrder[0].RelativePath);
-                Assert.Equal(@"someproj2.etp", solution.ProjectsInOrder[1].RelativePath);
-                Assert.Equal(@"ClassLibrary1.csproj", solution.ProjectsInOrder[2].RelativePath);
+                solution.ProjectsInOrder[0].RelativePath.ShouldBe(@"someproj.etp");
+                solution.ProjectsInOrder[1].RelativePath.ShouldBe(@"someproj2.etp");
+                solution.ProjectsInOrder[2].RelativePath.ShouldBe(@"ClassLibrary1.csproj");
             }
             // Delete the files created during the test
             finally
@@ -446,8 +454,8 @@ public void TestVSAndSolutionVersionParsing()
 
             SolutionFile solutionPriorToDev12 = ParseSolutionHelper(solutionFileContentsPriorToDev12);
 
-            Assert.Equal(11, solutionPriorToDev12.Version);
-            Assert.Equal(10, solutionPriorToDev12.VisualStudioVersion);
+            solutionPriorToDev12.Version.ShouldBe(11);
+            solutionPriorToDev12.VisualStudioVersion.ShouldBe(10);
 
             // Create the SolutionFile object
             string solutionFileContentsDev12 =
@@ -462,8 +470,8 @@ public void TestVSAndSolutionVersionParsing()
 
             SolutionFile solutionDev12 = ParseSolutionHelper(solutionFileContentsDev12);
 
-            Assert.Equal(11, solutionDev12.Version);
-            Assert.Equal(12, solutionDev12.VisualStudioVersion);
+            solutionDev12.Version.ShouldBe(11);
+            solutionDev12.VisualStudioVersion.ShouldBe(12);
 
             // Test parsing of corrupted VisualStudioVersion lines
 
@@ -479,8 +487,8 @@ public void TestVSAndSolutionVersionParsing()
                         EndProject";
 
             SolutionFile solutionDev12Corrupted1 = ParseSolutionHelper(solutionFileContentsDev12Corrupted1);
-            Assert.Equal(11, solutionDev12Corrupted1.Version);
-            Assert.Equal(10, solutionDev12Corrupted1.VisualStudioVersion);
+            solutionDev12Corrupted1.Version.ShouldBe(11);
+            solutionDev12Corrupted1.VisualStudioVersion.ShouldBe(10);
 
             // Remove version number and VSPRO_PLATFORM tag
             string solutionFileContentsDev12Corrupted2 =
@@ -494,8 +502,8 @@ public void TestVSAndSolutionVersionParsing()
                         EndProject";
 
             SolutionFile solutionDev12Corrupted2 = ParseSolutionHelper(solutionFileContentsDev12Corrupted2);
-            Assert.Equal(11, solutionDev12Corrupted2.Version);
-            Assert.Equal(10, solutionDev12Corrupted2.VisualStudioVersion);
+            solutionDev12Corrupted2.Version.ShouldBe(11);
+            solutionDev12Corrupted2.VisualStudioVersion.ShouldBe(10);
 
             // Switch positions between VSPRO_PLATFORM tag and version number
             string solutionFileContentsDev12Corrupted3 =
@@ -509,8 +517,8 @@ public void TestVSAndSolutionVersionParsing()
                         EndProject";
 
             SolutionFile solutionDev12Corrupted3 = ParseSolutionHelper(solutionFileContentsDev12Corrupted3);
-            Assert.Equal(11, solutionDev12Corrupted3.Version);
-            Assert.Equal(10, solutionDev12Corrupted3.VisualStudioVersion);
+            solutionDev12Corrupted3.Version.ShouldBe(11);
+            solutionDev12Corrupted3.VisualStudioVersion.ShouldBe(10);
 
             // Add a number of spaces before version number and glue it together with VSPRO_PLATFORM
             string solutionFileContentsDev12Corrupted4 =
@@ -524,8 +532,8 @@ public void TestVSAndSolutionVersionParsing()
                         EndProject";
 
             SolutionFile solutionDev12Corrupted4 = ParseSolutionHelper(solutionFileContentsDev12Corrupted4);
-            Assert.Equal(11, solutionDev12Corrupted4.Version);
-            Assert.Equal(10, solutionDev12Corrupted4.VisualStudioVersion);
+            solutionDev12Corrupted4.Version.ShouldBe(11);
+            solutionDev12Corrupted4.VisualStudioVersion.ShouldBe(10);
 
             // Corrupted version number
             string solutionFileContentsDev12Corrupted5 =
@@ -539,8 +547,8 @@ public void TestVSAndSolutionVersionParsing()
                         EndProject";
 
             SolutionFile solutionDev12Corrupted5 = ParseSolutionHelper(solutionFileContentsDev12Corrupted5);
-            Assert.Equal(11, solutionDev12Corrupted5.Version);
-            Assert.Equal(10, solutionDev12Corrupted5.VisualStudioVersion);
+            solutionDev12Corrupted5.Version.ShouldBe(11);
+            solutionDev12Corrupted5.VisualStudioVersion.ShouldBe(10);
 
             // Add a number of spaces before version number
             string solutionFileContentsDev12Corrupted6 =
@@ -554,8 +562,8 @@ public void TestVSAndSolutionVersionParsing()
                         EndProject";
 
             SolutionFile solutionDev12Corrupted6 = ParseSolutionHelper(solutionFileContentsDev12Corrupted6);
-            Assert.Equal(11, solutionDev12Corrupted6.Version);
-            Assert.Equal(12, solutionDev12Corrupted6.VisualStudioVersion);
+            solutionDev12Corrupted6.Version.ShouldBe(11);
+            solutionDev12Corrupted6.VisualStudioVersion.ShouldBe(12);
         }
 
         /// <summary>
@@ -635,12 +643,10 @@ public void ParseNestedEtpProjectMultipleLevel()
                 SolutionFile solution = ParseSolutionHelper(solutionFileContents);
 
                 //Project should get added to the solution
-                Assert.Equal(@"someproj.etp", solution.ProjectsInOrder[0].RelativePath);
-                Assert.Equal(@"someproj2.etp", solution.ProjectsInOrder[1].RelativePath);
-                Assert.Equal(@"ETPProjUpgradeTest\someproj3.etp", solution.ProjectsInOrder[2].RelativePath);
-                Assert.Equal(
-                    Path.Combine("ETPProjUpgradeTest", "..", "SomeFolder", "ClassLibrary1.csproj"),
-                    solution.ProjectsInOrder[3].RelativePath);
+                solution.ProjectsInOrder[0].RelativePath.ShouldBe(@"someproj.etp");
+                solution.ProjectsInOrder[1].RelativePath.ShouldBe(@"someproj2.etp");
+                solution.ProjectsInOrder[2].RelativePath.ShouldBe(@"ETPProjUpgradeTest\someproj3.etp");
+                solution.ProjectsInOrder[3].RelativePath.ShouldBe(Path.Combine("ETPProjUpgradeTest", "..", "SomeFolder", "ClassLibrary1.csproj"));
             }
             // Delete the files created during the test
             finally
@@ -693,14 +699,14 @@ public void MalformedEtpProjFile()
                             EndProjectSection
                         EndProject";
                 SolutionFile solution = ParseSolutionHelper(solutionFileContents);
-                string errCode, ignoredKeyword;
-                ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out errCode, out ignoredKeyword, "Shared.InvalidProjectFile",
+                string errCode;
+                ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out errCode, out _, "Shared.InvalidProjectFile",
                    "someproj.etp", String.Empty);
                 foreach (string warningString in solution.SolutionParserWarnings)
                 {
-                    Console.WriteLine(warningString);
+                    TestOutputHelper.WriteLine(warningString);
                 }
-                Assert.Contains(errCode, solution.SolutionParserErrorCodes[0]);
+                solution.SolutionParserErrorCodes[0].ShouldContain(errCode);
             }
             // Delete the files created during the test
             finally
@@ -728,10 +734,10 @@ public void MissingEtpProjFile()
             // Delete the someproj.etp file if it exists
             File.Delete(proj1Path);
             SolutionFile solution = ParseSolutionHelper(solutionFileContents);
-            string errCode, ignoredKeyword;
-            ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out errCode, out ignoredKeyword, "Shared.ProjectFileCouldNotBeLoaded",
+            string errCode;
+            ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out errCode, out _, "Shared.ProjectFileCouldNotBeLoaded",
                   "someproj.etp", String.Empty);
-            Assert.Contains(errCode, solution.SolutionParserErrorCodes[0]);
+            solution.SolutionParserErrorCodes[0].ShouldContain(errCode);
         }
 
         /// <summary>
@@ -750,10 +756,10 @@ public void ParseFirstProjectLineWhereProjectNameHasSpecialCharacters()
                 "Project(\"{Project GUID}\")  = \"MyProject,(=IsGreat)\",  \"Relative path to project file\"    , \"Unique name-GUID\"",
                  proj
             );
-            Assert.Equal(SolutionProjectType.Unknown, proj.ProjectType);
-            Assert.Equal("MyProject,(=IsGreat)", proj.ProjectName);
-            Assert.Equal("Relative path to project file", proj.RelativePath);
-            Assert.Equal("Unique name-GUID", proj.ProjectGuid);
+            proj.ProjectType.ShouldBe(SolutionProjectType.Unknown);
+            proj.ProjectName.ShouldBe("MyProject,(=IsGreat)");
+            proj.RelativePath.ShouldBe("Relative path to project file");
+            proj.ProjectGuid.ShouldBe("Unique name-GUID");
         }
 
         /// <summary>
@@ -778,10 +784,10 @@ public void ParseFirstProjectLineWhereProjectPathHasBackslash()
                     "Project(\"{Project GUID}\")  = \"ProjectInSubdirectory\",  \"RelativePath\\project file\"    , \"Unique name-GUID\"",
                     proj
                 );
-                Assert.Equal(SolutionProjectType.Unknown, proj.ProjectType);
-                Assert.Equal("ProjectInSubdirectory", proj.ProjectName);
-                Assert.Equal(Path.Combine("RelativePath", "project file"), proj.RelativePath);
-                Assert.Equal("Unique name-GUID", proj.ProjectGuid);
+                proj.ProjectType.ShouldBe(SolutionProjectType.Unknown);
+                proj.ProjectName.ShouldBe("ProjectInSubdirectory");
+                proj.RelativePath.ShouldBe(Path.Combine("RelativePath", "project file"));
+                proj.ProjectGuid.ShouldBe("Unique name-GUID");
             }
         }
 
@@ -812,7 +818,7 @@ static internal SolutionFile ParseSolutionHelper(string solutionFileContents)
         [Fact]
         public void BadVersionStamp()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 string solutionFileContents =
                     @"
@@ -821,8 +827,7 @@ public void BadVersionStamp()
                 ";
 
                 ParseSolutionHelper(solutionFileContents);
-            }
-           );
+            });
         }
         /// <summary>
         /// Expected version numbers less than 7 to cause an invalid project file exception.
@@ -830,7 +835,7 @@ public void BadVersionStamp()
         [Fact]
         public void VersionTooLow()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 string solutionFileContents =
                     @"
@@ -856,8 +861,8 @@ public void UnsupportedVersion()
                 ";
 
             SolutionFile solution = ParseSolutionHelper(solutionFileContents);
-            Assert.Single(solution.SolutionParserComments); // "Expected the solution parser to contain one comment"
-            Assert.Equal(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnrecognizedSolutionComment", "999"), (string)solution.SolutionParserComments[0]);
+            solution.SolutionParserComments.ShouldHaveSingleItem(); // "Expected the solution parser to contain one comment"
+            solution.SolutionParserComments[0].ShouldBe(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnrecognizedSolutionComment", "999"));
         }
 
         [Fact]
@@ -871,7 +876,7 @@ public void Version9()
 
             SolutionFile solution = ParseSolutionHelper(solutionFileContents);
 
-            Assert.Equal(9, solution.Version);
+            solution.Version.ShouldBe(9);
         }
 
         [Fact]
@@ -885,7 +890,7 @@ public void Version10()
 
             SolutionFile solution = ParseSolutionHelper(solutionFileContents);
 
-            Assert.Equal(10, solution.Version);
+            solution.Version.ShouldBe(10);
         }
 
         /// <summary>
@@ -924,7 +929,7 @@ public void ParseSolutionFileWithDescriptionInformation()
             }
             catch (Exception ex)
             {
-                Assert.True(false, "Failed to parse solution containing description information. Error: " + ex.Message);
+                throw new Exception("Failed to parse solution containing description information. Error: " + ex.Message, ex);
             }
         }
 
@@ -977,39 +982,39 @@ public void BasicSolution()
 
             SolutionFile solution = ParseSolutionHelper(solutionFileContents);
 
-            Assert.Equal(4, solution.ProjectsInOrder.Count);
-
-            Assert.Equal(SolutionProjectType.KnownToBeMSBuildFormat, solution.ProjectsInOrder[0].ProjectType);
-            Assert.Equal("ConsoleApplication1", solution.ProjectsInOrder[0].ProjectName);
-            Assert.Equal(@"ConsoleApplication1\ConsoleApplication1.vbproj", solution.ProjectsInOrder[0].RelativePath);
-            Assert.Equal("{AB3413A6-D689-486D-B7F0-A095371B3F13}", solution.ProjectsInOrder[0].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[0].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[0].ParentProjectGuid);
-            Assert.Equal("ConsoleApplication1", solution.ProjectsInOrder[0].GetUniqueProjectName());
-
-            Assert.Equal(SolutionProjectType.KnownToBeMSBuildFormat, solution.ProjectsInOrder[1].ProjectType);
-            Assert.Equal("vbClassLibrary", solution.ProjectsInOrder[1].ProjectName);
-            Assert.Equal(@"vbClassLibrary\vbClassLibrary.vbproj", solution.ProjectsInOrder[1].RelativePath);
-            Assert.Equal("{BA333A76-4511-47B8-8DF4-CA51C303AD0B}", solution.ProjectsInOrder[1].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[1].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[1].ParentProjectGuid);
-            Assert.Equal("vbClassLibrary", solution.ProjectsInOrder[1].GetUniqueProjectName());
-
-            Assert.Equal(SolutionProjectType.KnownToBeMSBuildFormat, solution.ProjectsInOrder[2].ProjectType);
-            Assert.Equal("ClassLibrary1", solution.ProjectsInOrder[2].ProjectName);
-            Assert.Equal(@"ClassLibrary1\ClassLibrary1.csproj", solution.ProjectsInOrder[2].RelativePath);
-            Assert.Equal("{DEBCE986-61B9-435E-8018-44B9EF751655}", solution.ProjectsInOrder[2].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[2].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[2].ParentProjectGuid);
-            Assert.Equal("ClassLibrary1", solution.ProjectsInOrder[2].GetUniqueProjectName());
-
-            Assert.Equal(SolutionProjectType.KnownToBeMSBuildFormat, solution.ProjectsInOrder[3].ProjectType);
-            Assert.Equal("cpsFsProject", solution.ProjectsInOrder[3].ProjectName);
-            Assert.Equal(@"cpsFsProject\ProjectFileName.fsproj", solution.ProjectsInOrder[3].RelativePath);
-            Assert.Equal("{9200923E-1814-4E76-A677-C61E4896D67F}", solution.ProjectsInOrder[3].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[3].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[3].ParentProjectGuid);
-            Assert.Equal("cpsFsProject", solution.ProjectsInOrder[3].GetUniqueProjectName());
+            solution.ProjectsInOrder.Count.ShouldBe(4);
+
+            solution.ProjectsInOrder[0].ProjectType.ShouldBe(SolutionProjectType.KnownToBeMSBuildFormat);
+            solution.ProjectsInOrder[0].ProjectName.ShouldBe("ConsoleApplication1");
+            solution.ProjectsInOrder[0].RelativePath.ShouldBe(@"ConsoleApplication1\ConsoleApplication1.vbproj");
+            solution.ProjectsInOrder[0].ProjectGuid.ShouldBe("{AB3413A6-D689-486D-B7F0-A095371B3F13}");
+            solution.ProjectsInOrder[0].Dependencies.ShouldBeEmpty();
+            solution.ProjectsInOrder[0].ParentProjectGuid.ShouldBeNull();
+            solution.ProjectsInOrder[0].GetUniqueProjectName().ShouldBe("ConsoleApplication1");
+
+            solution.ProjectsInOrder[1].ProjectType.ShouldBe(SolutionProjectType.KnownToBeMSBuildFormat);
+            solution.ProjectsInOrder[1].ProjectName.ShouldBe("vbClassLibrary");
+            solution.ProjectsInOrder[1].RelativePath.ShouldBe(@"vbClassLibrary\vbClassLibrary.vbproj");
+            solution.ProjectsInOrder[1].ProjectGuid.ShouldBe("{BA333A76-4511-47B8-8DF4-CA51C303AD0B}");
+            solution.ProjectsInOrder[1].Dependencies.ShouldBeEmpty();
+            solution.ProjectsInOrder[1].ParentProjectGuid.ShouldBeNull();
+            solution.ProjectsInOrder[1].GetUniqueProjectName().ShouldBe("vbClassLibrary");
+
+            solution.ProjectsInOrder[2].ProjectType.ShouldBe(SolutionProjectType.KnownToBeMSBuildFormat);
+            solution.ProjectsInOrder[2].ProjectName.ShouldBe("ClassLibrary1");
+            solution.ProjectsInOrder[2].RelativePath.ShouldBe(@"ClassLibrary1\ClassLibrary1.csproj");
+            solution.ProjectsInOrder[2].ProjectGuid.ShouldBe("{DEBCE986-61B9-435E-8018-44B9EF751655}");
+            solution.ProjectsInOrder[2].Dependencies.ShouldBeEmpty();
+            solution.ProjectsInOrder[2].ParentProjectGuid.ShouldBeNull();
+            solution.ProjectsInOrder[2].GetUniqueProjectName().ShouldBe("ClassLibrary1");
+
+            solution.ProjectsInOrder[3].ProjectType.ShouldBe(SolutionProjectType.KnownToBeMSBuildFormat);
+            solution.ProjectsInOrder[3].ProjectName.ShouldBe("cpsFsProject");
+            solution.ProjectsInOrder[3].RelativePath.ShouldBe(@"cpsFsProject\ProjectFileName.fsproj");
+            solution.ProjectsInOrder[3].ProjectGuid.ShouldBe("{9200923E-1814-4E76-A677-C61E4896D67F}");
+            solution.ProjectsInOrder[3].Dependencies.ShouldBeEmpty();
+            solution.ProjectsInOrder[3].ParentProjectGuid.ShouldBeNull();
+            solution.ProjectsInOrder[3].GetUniqueProjectName().ShouldBe("cpsFsProject");
         }
 
         /// <summary>
@@ -1065,37 +1070,37 @@ public void SolutionFolders()
 
             SolutionFile solution = ParseSolutionHelper(solutionFileContents);
 
-            Assert.Equal(5, solution.ProjectsInOrder.Count);
-
-            Assert.Equal(@"ClassLibrary1\ClassLibrary1.csproj", solution.ProjectsInOrder[0].RelativePath);
-            Assert.Equal("{34E0D07D-CF8F-459D-9449-C4188D8C5564}", solution.ProjectsInOrder[0].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[0].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[0].ParentProjectGuid);
-            Assert.Equal("ClassLibrary1", solution.ProjectsInOrder[0].GetUniqueProjectName());
-
-            Assert.Equal(SolutionProjectType.SolutionFolder, solution.ProjectsInOrder[1].ProjectType);
-            Assert.Equal("{E0F97730-25D2-418A-A7BD-02CAFDC6E470}", solution.ProjectsInOrder[1].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[1].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[1].ParentProjectGuid);
-            Assert.Equal("MySlnFolder", solution.ProjectsInOrder[1].GetUniqueProjectName());
-
-            Assert.Equal(@"MyPhysicalFolder\ClassLibrary1\ClassLibrary1.csproj", solution.ProjectsInOrder[2].RelativePath);
-            Assert.Equal("{A5EE8128-B08E-4533-86C5-E46714981680}", solution.ProjectsInOrder[2].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[2].Dependencies);
-            Assert.Equal("{E0F97730-25D2-418A-A7BD-02CAFDC6E470}", solution.ProjectsInOrder[2].ParentProjectGuid);
-            Assert.Equal(@"MySlnFolder\ClassLibrary1", solution.ProjectsInOrder[2].GetUniqueProjectName());
-
-            Assert.Equal(SolutionProjectType.SolutionFolder, solution.ProjectsInOrder[3].ProjectType);
-            Assert.Equal("{2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}", solution.ProjectsInOrder[3].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[3].Dependencies);
-            Assert.Equal("{E0F97730-25D2-418A-A7BD-02CAFDC6E470}", solution.ProjectsInOrder[3].ParentProjectGuid);
-            Assert.Equal(@"MySlnFolder\MySubSlnFolder", solution.ProjectsInOrder[3].GetUniqueProjectName());
-
-            Assert.Equal(@"ClassLibrary2\ClassLibrary2.csproj", solution.ProjectsInOrder[4].RelativePath);
-            Assert.Equal("{6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}", solution.ProjectsInOrder[4].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[4].Dependencies);
-            Assert.Equal("{2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}", solution.ProjectsInOrder[4].ParentProjectGuid);
-            Assert.Equal(@"MySlnFolder\MySubSlnFolder\ClassLibrary2", solution.ProjectsInOrder[4].GetUniqueProjectName());
+            solution.ProjectsInOrder.Count.ShouldBe(5);
+
+            solution.ProjectsInOrder[0].RelativePath.ShouldBe(@"ClassLibrary1\ClassLibrary1.csproj");
+            solution.ProjectsInOrder[0].ProjectGuid.ShouldBe("{34E0D07D-CF8F-459D-9449-C4188D8C5564}");
+            solution.ProjectsInOrder[0].Dependencies.ShouldBeEmpty();
+            solution.ProjectsInOrder[0].ParentProjectGuid.ShouldBeNull();
+            solution.ProjectsInOrder[0].GetUniqueProjectName().ShouldBe("ClassLibrary1");
+
+            solution.ProjectsInOrder[1].ProjectType.ShouldBe(SolutionProjectType.SolutionFolder);
+            solution.ProjectsInOrder[1].ProjectGuid.ShouldBe("{E0F97730-25D2-418A-A7BD-02CAFDC6E470}");
+            solution.ProjectsInOrder[1].Dependencies.ShouldBeEmpty();
+            solution.ProjectsInOrder[1].ParentProjectGuid.ShouldBeNull();
+            solution.ProjectsInOrder[1].GetUniqueProjectName().ShouldBe("MySlnFolder");
+
+            solution.ProjectsInOrder[2].RelativePath.ShouldBe(@"MyPhysicalFolder\ClassLibrary1\ClassLibrary1.csproj");
+            solution.ProjectsInOrder[2].ProjectGuid.ShouldBe("{A5EE8128-B08E-4533-86C5-E46714981680}");
+            solution.ProjectsInOrder[2].Dependencies.ShouldBeEmpty();
+            solution.ProjectsInOrder[2].ParentProjectGuid.ShouldBe("{E0F97730-25D2-418A-A7BD-02CAFDC6E470}");
+            solution.ProjectsInOrder[2].GetUniqueProjectName().ShouldBe(@"MySlnFolder\ClassLibrary1");
+
+            solution.ProjectsInOrder[3].ProjectType.ShouldBe(SolutionProjectType.SolutionFolder);
+            solution.ProjectsInOrder[3].ProjectGuid.ShouldBe("{2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}");
+            solution.ProjectsInOrder[3].Dependencies.ShouldBeEmpty();
+            solution.ProjectsInOrder[3].ParentProjectGuid.ShouldBe("{E0F97730-25D2-418A-A7BD-02CAFDC6E470}");
+            solution.ProjectsInOrder[3].GetUniqueProjectName().ShouldBe(@"MySlnFolder\MySubSlnFolder");
+
+            solution.ProjectsInOrder[4].RelativePath.ShouldBe(@"ClassLibrary2\ClassLibrary2.csproj");
+            solution.ProjectsInOrder[4].ProjectGuid.ShouldBe("{6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}");
+            solution.ProjectsInOrder[4].Dependencies.ShouldBeEmpty();
+            solution.ProjectsInOrder[4].ParentProjectGuid.ShouldBe("{2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}");
+            solution.ProjectsInOrder[4].GetUniqueProjectName().ShouldBe(@"MySlnFolder\MySubSlnFolder\ClassLibrary2");
         }
 
         /// <summary>
@@ -1208,19 +1213,13 @@ public void MissingNestedProject()
                 EndGlobal
                 ";
 
-            try
+            InvalidProjectFileException e = Should.Throw<InvalidProjectFileException>(() =>
             {
                 ParseSolutionHelper(solutionFileContents);
-            }
-            catch (InvalidProjectFileException e)
-            {
-                Assert.Equal("MSB5023", e.ErrorCode);
-                Assert.Contains("{2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}", e.Message);
-                return;
-            }
+            });
 
-            // Should not get here
-            Assert.True(false);
+            e.ErrorCode.ShouldBe("MSB5023");
+            e.Message.ShouldContain("{2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}");
         }
 
         /// <summary>
@@ -1388,33 +1387,33 @@ public void BuildableProjects()
 
             SolutionFile solution = ParseSolutionHelper(solutionFileContents);
 
-            Assert.Equal(6, solution.ProjectsInOrder.Count);
+            solution.ProjectsInOrder.Count.ShouldBe(6);
 
-            Assert.Equal("{892B5932-9AA8-46F9-A857-8967DCDBE4F5}", solution.ProjectsInOrder[0].ProjectGuid);
-            Assert.Equal("HubApp2", solution.ProjectsInOrder[0].ProjectName);
-            Assert.False(SolutionFile.IsBuildableProject(solution.ProjectsInOrder[0]));
+            solution.ProjectsInOrder[0].ProjectGuid.ShouldBe("{892B5932-9AA8-46F9-A857-8967DCDBE4F5}");
+            solution.ProjectsInOrder[0].ProjectName.ShouldBe("HubApp2");
+            SolutionFile.IsBuildableProject(solution.ProjectsInOrder[0]).ShouldBeFalse();
 
-            Assert.Equal("{A5526AEA-E0A2-496D-94B7-2BBE835C83F8}", solution.ProjectsInOrder[1].ProjectGuid);
-            Assert.Equal("HubApp2.Store", solution.ProjectsInOrder[1].ProjectName);
-            Assert.True(SolutionFile.IsBuildableProject(solution.ProjectsInOrder[1]));
+            solution.ProjectsInOrder[1].ProjectGuid.ShouldBe("{A5526AEA-E0A2-496D-94B7-2BBE835C83F8}");
+            solution.ProjectsInOrder[1].ProjectName.ShouldBe("HubApp2.Store");
+            SolutionFile.IsBuildableProject(solution.ProjectsInOrder[1]).ShouldBeTrue();
 
-            Assert.Equal("{FF6AEDF3-950A-46DD-910B-52BC69B9C99A}", solution.ProjectsInOrder[2].ProjectGuid);
-            Assert.Equal("Shared", solution.ProjectsInOrder[2].ProjectName);
-            Assert.False(SolutionFile.IsBuildableProject(solution.ProjectsInOrder[2]));
+            solution.ProjectsInOrder[2].ProjectGuid.ShouldBe("{FF6AEDF3-950A-46DD-910B-52BC69B9C99A}");
+            solution.ProjectsInOrder[2].ProjectName.ShouldBe("Shared");
+            SolutionFile.IsBuildableProject(solution.ProjectsInOrder[2]).ShouldBeFalse();
 
-            Assert.Equal("{024E8607-06B0-440D-8741-5A888DC4B176}", solution.ProjectsInOrder[3].ProjectGuid);
-            Assert.Equal("HubApp2.Phone", solution.ProjectsInOrder[3].ProjectName);
-            Assert.True(SolutionFile.IsBuildableProject(solution.ProjectsInOrder[3]));
+            solution.ProjectsInOrder[3].ProjectGuid.ShouldBe("{024E8607-06B0-440D-8741-5A888DC4B176}");
+            solution.ProjectsInOrder[3].ProjectName.ShouldBe("HubApp2.Phone");
+            SolutionFile.IsBuildableProject(solution.ProjectsInOrder[3]).ShouldBeTrue();
 
-            Assert.Equal("{E0F97730-25D2-418A-A7BD-02CAFDC6E470}", solution.ProjectsInOrder[4].ProjectGuid);
-            Assert.Equal("MySlnFolder", solution.ProjectsInOrder[4].ProjectName);
-            Assert.False(SolutionFile.IsBuildableProject(solution.ProjectsInOrder[4]));
+            solution.ProjectsInOrder[4].ProjectGuid.ShouldBe("{E0F97730-25D2-418A-A7BD-02CAFDC6E470}");
+            solution.ProjectsInOrder[4].ProjectName.ShouldBe("MySlnFolder");
+            SolutionFile.IsBuildableProject(solution.ProjectsInOrder[4]).ShouldBeFalse();
 
             // Even though it doesn't have project configurations mapped for all solution configurations,
             // it at least has some, so this project should still be marked as "buildable"
-            Assert.Equal("{A5EE8128-B08E-4533-86C5-E46714981680}", solution.ProjectsInOrder[5].ProjectGuid);
-            Assert.Equal("ClassLibrary1", solution.ProjectsInOrder[5].ProjectName);
-            Assert.True(SolutionFile.IsBuildableProject(solution.ProjectsInOrder[5]));
+            solution.ProjectsInOrder[5].ProjectGuid.ShouldBe("{A5EE8128-B08E-4533-86C5-E46714981680}");
+            solution.ProjectsInOrder[5].ProjectName.ShouldBe("ClassLibrary1");
+            SolutionFile.IsBuildableProject(solution.ProjectsInOrder[5]).ShouldBeTrue();
         }
 
         /// <summary>
@@ -1468,28 +1467,28 @@ public void SolutionDependencies()
 
             SolutionFile solution = ParseSolutionHelper(solutionFileContents);
 
-            Assert.Equal(3, solution.ProjectsInOrder.Count);
-
-            Assert.Equal(@"ClassLibrary1\ClassLibrary1.csproj", solution.ProjectsInOrder[0].RelativePath);
-            Assert.Equal("{05A5AD00-71B5-4612-AF2F-9EA9121C4111}", solution.ProjectsInOrder[0].ProjectGuid);
-            Assert.Single(solution.ProjectsInOrder[0].Dependencies);
-            Assert.Equal("{FAB4EE06-6E01-495A-8926-5514599E3DD9}", (string)solution.ProjectsInOrder[0].Dependencies[0]);
-            Assert.Null(solution.ProjectsInOrder[0].ParentProjectGuid);
-            Assert.Equal("ClassLibrary1", solution.ProjectsInOrder[0].GetUniqueProjectName());
-
-            Assert.Equal(@"ClassLibrary2\ClassLibrary2.csproj", solution.ProjectsInOrder[1].RelativePath);
-            Assert.Equal("{7F316407-AE3E-4F26-BE61-2C50D30DA158}", solution.ProjectsInOrder[1].ProjectGuid);
-            Assert.Equal(2, solution.ProjectsInOrder[1].Dependencies.Count);
-            Assert.Equal("{FAB4EE06-6E01-495A-8926-5514599E3DD9}", (string)solution.ProjectsInOrder[1].Dependencies[0]);
-            Assert.Equal("{05A5AD00-71B5-4612-AF2F-9EA9121C4111}", (string)solution.ProjectsInOrder[1].Dependencies[1]);
-            Assert.Null(solution.ProjectsInOrder[1].ParentProjectGuid);
-            Assert.Equal("ClassLibrary2", solution.ProjectsInOrder[1].GetUniqueProjectName());
-
-            Assert.Equal(@"ClassLibrary3\ClassLibrary3.csproj", solution.ProjectsInOrder[2].RelativePath);
-            Assert.Equal("{FAB4EE06-6E01-495A-8926-5514599E3DD9}", solution.ProjectsInOrder[2].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[2].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[2].ParentProjectGuid);
-            Assert.Equal("ClassLibrary3", solution.ProjectsInOrder[2].GetUniqueProjectName());
+            solution.ProjectsInOrder.Count.ShouldBe(3);
+
+            solution.ProjectsInOrder[0].RelativePath.ShouldBe(@"ClassLibrary1\ClassLibrary1.csproj");
+            solution.ProjectsInOrder[0].ProjectGuid.ShouldBe("{05A5AD00-71B5-4612-AF2F-9EA9121C4111}");
+            solution.ProjectsInOrder[0].Dependencies.ShouldHaveSingleItem();
+            solution.ProjectsInOrder[0].Dependencies[0].ShouldBe("{FAB4EE06-6E01-495A-8926-5514599E3DD9}");
+            solution.ProjectsInOrder[0].ParentProjectGuid.ShouldBeNull();
+            solution.ProjectsInOrder[0].GetUniqueProjectName().ShouldBe("ClassLibrary1");
+
+            solution.ProjectsInOrder[1].RelativePath.ShouldBe(@"ClassLibrary2\ClassLibrary2.csproj");
+            solution.ProjectsInOrder[1].ProjectGuid.ShouldBe("{7F316407-AE3E-4F26-BE61-2C50D30DA158}");
+            solution.ProjectsInOrder[1].Dependencies.Count.ShouldBe(2);
+            solution.ProjectsInOrder[1].Dependencies[0].ShouldBe("{FAB4EE06-6E01-495A-8926-5514599E3DD9}");
+            solution.ProjectsInOrder[1].Dependencies[1].ShouldBe("{05A5AD00-71B5-4612-AF2F-9EA9121C4111}");
+            solution.ProjectsInOrder[1].ParentProjectGuid.ShouldBeNull();
+            solution.ProjectsInOrder[1].GetUniqueProjectName().ShouldBe("ClassLibrary2");
+
+            solution.ProjectsInOrder[2].RelativePath.ShouldBe(@"ClassLibrary3\ClassLibrary3.csproj");
+            solution.ProjectsInOrder[2].ProjectGuid.ShouldBe("{FAB4EE06-6E01-495A-8926-5514599E3DD9}");
+            solution.ProjectsInOrder[2].Dependencies.ShouldBeEmpty();
+            solution.ProjectsInOrder[2].ParentProjectGuid.ShouldBeNull();
+            solution.ProjectsInOrder[2].GetUniqueProjectName().ShouldBe("ClassLibrary3");
         }
 
         /// <summary>
@@ -1543,48 +1542,48 @@ public void VenusProject()
 
             SolutionFile solution = ParseSolutionHelper(solutionFileContents.Replace('`', '"'));
 
-            Assert.Single(solution.ProjectsInOrder);
+            solution.ProjectsInOrder.ShouldHaveSingleItem();
 
-            Assert.Equal(SolutionProjectType.WebProject, solution.ProjectsInOrder[0].ProjectType);
-            Assert.Equal(@"C:\WebSites\WebApplication3\", solution.ProjectsInOrder[0].ProjectName);
-            Assert.Equal(@"C:\WebSites\WebApplication3\", solution.ProjectsInOrder[0].RelativePath);
-            Assert.Equal("{464FD0B9-E335-4677-BE1E-6B2F982F4D86}", solution.ProjectsInOrder[0].ProjectGuid);
-            Assert.Equal(2, solution.ProjectsInOrder[0].Dependencies.Count);
-            Assert.Null(solution.ProjectsInOrder[0].ParentProjectGuid);
-            Assert.Equal(@"C:\WebSites\WebApplication3\", solution.ProjectsInOrder[0].GetUniqueProjectName());
+            solution.ProjectsInOrder[0].ProjectType.ShouldBe(SolutionProjectType.WebProject);
+            solution.ProjectsInOrder[0].ProjectName.ShouldBe(@"C:\WebSites\WebApplication3\");
+            solution.ProjectsInOrder[0].RelativePath.ShouldBe(@"C:\WebSites\WebApplication3\");
+            solution.ProjectsInOrder[0].ProjectGuid.ShouldBe("{464FD0B9-E335-4677-BE1E-6B2F982F4D86}");
+            solution.ProjectsInOrder[0].Dependencies.Count.ShouldBe(2);
+            solution.ProjectsInOrder[0].ParentProjectGuid.ShouldBeNull();
+            solution.ProjectsInOrder[0].GetUniqueProjectName().ShouldBe(@"C:\WebSites\WebApplication3\");
 
             Hashtable aspNetCompilerParameters = solution.ProjectsInOrder[0].AspNetConfigurations;
             AspNetCompilerParameters debugAspNetCompilerParameters = (AspNetCompilerParameters)aspNetCompilerParameters["Debug"];
             AspNetCompilerParameters releaseAspNetCompilerParameters = (AspNetCompilerParameters)aspNetCompilerParameters["Release"];
 
-            Assert.Equal(@"/publishfirst", debugAspNetCompilerParameters.aspNetVirtualPath);
-            Assert.Equal(@"..\rajeev\temp\websites\myfirstwebsite\", debugAspNetCompilerParameters.aspNetPhysicalPath);
-            Assert.Equal(@"..\rajeev\temp\publishfirst\", debugAspNetCompilerParameters.aspNetTargetPath);
-            Assert.Equal(@"true", debugAspNetCompilerParameters.aspNetForce);
-            Assert.Equal(@"false", debugAspNetCompilerParameters.aspNetUpdateable);
-            Assert.Equal(@"true", debugAspNetCompilerParameters.aspNetDebug);
-            Assert.Equal(@"debugkeyfile.snk", debugAspNetCompilerParameters.aspNetKeyFile);
-            Assert.Equal(@"12345.container", debugAspNetCompilerParameters.aspNetKeyContainer);
-            Assert.Equal(@"true", debugAspNetCompilerParameters.aspNetDelaySign);
-            Assert.Equal(@"false", debugAspNetCompilerParameters.aspNetAPTCA);
-            Assert.Equal(@"debugfixednames", debugAspNetCompilerParameters.aspNetFixedNames);
-
-            Assert.Equal(@"/publishfirst_release", releaseAspNetCompilerParameters.aspNetVirtualPath);
-            Assert.Equal(@"..\rajeev\temp\websites\myfirstwebsite_release\", releaseAspNetCompilerParameters.aspNetPhysicalPath);
-            Assert.Equal(@"..\rajeev\temp\publishfirst_release\", releaseAspNetCompilerParameters.aspNetTargetPath);
-            Assert.Equal(@"true", releaseAspNetCompilerParameters.aspNetForce);
-            Assert.Equal(@"true", releaseAspNetCompilerParameters.aspNetUpdateable);
-            Assert.Equal(@"false", releaseAspNetCompilerParameters.aspNetDebug);
-            Assert.Equal("", releaseAspNetCompilerParameters.aspNetKeyFile);
-            Assert.Equal("", releaseAspNetCompilerParameters.aspNetKeyContainer);
-            Assert.Equal("", releaseAspNetCompilerParameters.aspNetDelaySign);
-            Assert.Equal("", releaseAspNetCompilerParameters.aspNetAPTCA);
-            Assert.Equal("", releaseAspNetCompilerParameters.aspNetFixedNames);
+            debugAspNetCompilerParameters.aspNetVirtualPath.ShouldBe(@"/publishfirst");
+            debugAspNetCompilerParameters.aspNetPhysicalPath.ShouldBe(@"..\rajeev\temp\websites\myfirstwebsite\");
+            debugAspNetCompilerParameters.aspNetTargetPath.ShouldBe(@"..\rajeev\temp\publishfirst\");
+            debugAspNetCompilerParameters.aspNetForce.ShouldBe(@"true");
+            debugAspNetCompilerParameters.aspNetUpdateable.ShouldBe(@"false");
+            debugAspNetCompilerParameters.aspNetDebug.ShouldBe(@"true");
+            debugAspNetCompilerParameters.aspNetKeyFile.ShouldBe(@"debugkeyfile.snk");
+            debugAspNetCompilerParameters.aspNetKeyContainer.ShouldBe(@"12345.container");
+            debugAspNetCompilerParameters.aspNetDelaySign.ShouldBe(@"true");
+            debugAspNetCompilerParameters.aspNetAPTCA.ShouldBe(@"false");
+            debugAspNetCompilerParameters.aspNetFixedNames.ShouldBe(@"debugfixednames");
+
+            releaseAspNetCompilerParameters.aspNetVirtualPath.ShouldBe(@"/publishfirst_release");
+            releaseAspNetCompilerParameters.aspNetPhysicalPath.ShouldBe(@"..\rajeev\temp\websites\myfirstwebsite_release\");
+            releaseAspNetCompilerParameters.aspNetTargetPath.ShouldBe(@"..\rajeev\temp\publishfirst_release\");
+            releaseAspNetCompilerParameters.aspNetForce.ShouldBe(@"true");
+            releaseAspNetCompilerParameters.aspNetUpdateable.ShouldBe(@"true");
+            releaseAspNetCompilerParameters.aspNetDebug.ShouldBe(@"false");
+            releaseAspNetCompilerParameters.aspNetKeyFile.ShouldBe("");
+            releaseAspNetCompilerParameters.aspNetKeyContainer.ShouldBe("");
+            releaseAspNetCompilerParameters.aspNetDelaySign.ShouldBe("");
+            releaseAspNetCompilerParameters.aspNetAPTCA.ShouldBe("");
+            releaseAspNetCompilerParameters.aspNetFixedNames.ShouldBe("");
 
             List<string> aspNetProjectReferences = solution.ProjectsInOrder[0].ProjectReferences;
-            Assert.Equal(2, aspNetProjectReferences.Count);
-            Assert.Equal("{FD705688-88D1-4C22-9BFF-86235D89C2FC}", aspNetProjectReferences[0]);
-            Assert.Equal("{F0726D09-042B-4A7A-8A01-6BED2422BD5D}", aspNetProjectReferences[1]);
+            aspNetProjectReferences.Count.ShouldBe(2);
+            aspNetProjectReferences[0].ShouldBe("{FD705688-88D1-4C22-9BFF-86235D89C2FC}");
+            aspNetProjectReferences[1].ShouldBe("{F0726D09-042B-4A7A-8A01-6BED2422BD5D}");
         }
 
         /// <summary>
@@ -1626,17 +1625,17 @@ public void VenusProjectInASolutionFolder()
 
             SolutionFile solution = ParseSolutionHelper(solutionFileContents);
 
-            Assert.Equal(3, solution.ProjectsInOrder.Count);
+            solution.ProjectsInOrder.Count.ShouldBe(3);
 
-            Assert.Equal(SolutionProjectType.WebProject, solution.ProjectsInOrder[0].ProjectType);
-            Assert.Equal(@"C:\WebSites\WebApplication3\", solution.ProjectsInOrder[0].GetUniqueProjectName());
+            solution.ProjectsInOrder[0].ProjectType.ShouldBe(SolutionProjectType.WebProject);
+            solution.ProjectsInOrder[0].GetUniqueProjectName().ShouldBe(@"C:\WebSites\WebApplication3\");
 
-            Assert.Equal(SolutionProjectType.SolutionFolder, solution.ProjectsInOrder[1].ProjectType);
-            Assert.Equal("{092FE6E5-71F8-43F7-9C92-30E3124B8A22}", solution.ProjectsInOrder[1].ProjectGuid);
+            solution.ProjectsInOrder[1].ProjectType.ShouldBe(SolutionProjectType.SolutionFolder);
+            solution.ProjectsInOrder[1].ProjectGuid.ShouldBe("{092FE6E5-71F8-43F7-9C92-30E3124B8A22}");
 
-            Assert.Equal(SolutionProjectType.WebProject, solution.ProjectsInOrder[2].ProjectType);
-            Assert.Equal(@"C:\WebSites\WebApplication4\", solution.ProjectsInOrder[2].GetUniqueProjectName());
-            Assert.Equal("{092FE6E5-71F8-43F7-9C92-30E3124B8A22}", solution.ProjectsInOrder[2].ParentProjectGuid);
+            solution.ProjectsInOrder[2].ProjectType.ShouldBe(SolutionProjectType.WebProject);
+            solution.ProjectsInOrder[2].GetUniqueProjectName().ShouldBe(@"C:\WebSites\WebApplication4\");
+            solution.ProjectsInOrder[2].ParentProjectGuid.ShouldBe("{092FE6E5-71F8-43F7-9C92-30E3124B8A22}");
         }
 
         /// <summary>
@@ -1695,7 +1694,7 @@ public void ParseSolutionConfigurations()
 
             SolutionFile solution = ParseSolutionHelper(solutionFileContents);
 
-            Assert.Equal(7, solution.SolutionConfigurations.Count);
+            solution.SolutionConfigurations.Count.ShouldBe(7);
 
             List<string> configurationNames = new List<string>(6);
             foreach (SolutionConfigurationInSolution configuration in solution.SolutionConfigurations)
@@ -1703,15 +1702,15 @@ public void ParseSolutionConfigurations()
                 configurationNames.Add(configuration.FullName);
             }
 
-            Assert.Contains("Debug|Any CPU", configurationNames);
-            Assert.Contains("Debug|Mixed Platforms", configurationNames);
-            Assert.Contains("Debug|Win32", configurationNames);
-            Assert.Contains("Release|Any CPU", configurationNames);
-            Assert.Contains("Release|Mixed Platforms", configurationNames);
-            Assert.Contains("Release|Win32", configurationNames);
+            configurationNames.ShouldContain("Debug|Any CPU");
+            configurationNames.ShouldContain("Debug|Mixed Platforms");
+            configurationNames.ShouldContain("Debug|Win32");
+            configurationNames.ShouldContain("Release|Any CPU");
+            configurationNames.ShouldContain("Release|Mixed Platforms");
+            configurationNames.ShouldContain("Release|Win32");
 
-            Assert.Equal("Debug", solution.GetDefaultConfigurationName()); // "Default solution configuration"
-            Assert.Equal("Mixed Platforms", solution.GetDefaultPlatformName()); // "Default solution platform"
+            solution.GetDefaultConfigurationName().ShouldBe("Debug"); // "Default solution configuration"
+            solution.GetDefaultPlatformName().ShouldBe("Mixed Platforms"); // "Default solution platform"
         }
 
         /// <summary>
@@ -1755,7 +1754,7 @@ public void ParseSolutionConfigurationsNoMixedPlatform()
 
             SolutionFile solution = ParseSolutionHelper(solutionFileContents);
 
-            Assert.Equal(6, solution.SolutionConfigurations.Count);
+            solution.SolutionConfigurations.Count.ShouldBe(6);
 
             List<string> configurationNames = new List<string>(6);
             foreach (SolutionConfigurationInSolution configuration in solution.SolutionConfigurations)
@@ -1763,15 +1762,15 @@ public void ParseSolutionConfigurationsNoMixedPlatform()
                 configurationNames.Add(configuration.FullName);
             }
 
-            Assert.Contains("Debug|Any CPU", configurationNames);
-            Assert.Contains("Debug|ARM", configurationNames);
-            Assert.Contains("Debug|x86", configurationNames);
-            Assert.Contains("Release|Any CPU", configurationNames);
-            Assert.Contains("Release|ARM", configurationNames);
-            Assert.Contains("Release|x86", configurationNames);
+            configurationNames.ShouldContain("Debug|Any CPU");
+            configurationNames.ShouldContain("Debug|ARM");
+            configurationNames.ShouldContain("Debug|x86");
+            configurationNames.ShouldContain("Release|Any CPU");
+            configurationNames.ShouldContain("Release|ARM");
+            configurationNames.ShouldContain("Release|x86");
 
-            Assert.Equal("Debug", solution.GetDefaultConfigurationName()); // "Default solution configuration"
-            Assert.Equal("Any CPU", solution.GetDefaultPlatformName()); // "Default solution platform"
+            solution.GetDefaultConfigurationName().ShouldBe("Debug"); // "Default solution configuration"
+            solution.GetDefaultPlatformName().ShouldBe("Any CPU"); // "Default solution platform"
         }
 
         /// <summary>
@@ -1781,7 +1780,7 @@ public void ParseSolutionConfigurationsNoMixedPlatform()
         [Fact]
         public void ParseInvalidSolutionConfigurations1()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 string solutionFileContents =
                     @"
@@ -1808,7 +1807,7 @@ public void ParseInvalidSolutionConfigurations1()
         [Fact]
         public void ParseInvalidSolutionConfigurations2()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 string solutionFileContents =
                     @"
@@ -1835,7 +1834,7 @@ public void ParseInvalidSolutionConfigurations2()
         [Fact]
         public void ParseInvalidSolutionConfigurations3()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 string solutionFileContents =
                     @"
@@ -1898,10 +1897,10 @@ public void ParseAllProjectsContainedInInvalidSolutionEvenWhenMissingEndProject(
             SolutionFile solution = ParseSolutionHelper(solutionFileContents);
 
             // What is needed to be checked is whether there were still both projects found in the invalid solution file
-            ProjectInSolution classLibraryProject = (ProjectInSolution)solution.ProjectsByGuid["{6185CC21-BE89-448A-B3C0-D1C27112E595}"];
-            ProjectInSolution mainAppProject = (ProjectInSolution)solution.ProjectsByGuid["{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}"];
-            ProjectInSolution lowLevelProject = (ProjectInSolution)solution.ProjectsByGuid["{E8E75132-67E4-4D6F-9CAE-8DA4C883F419}"];
-            ProjectInSolution highLevelProject = (ProjectInSolution)solution.ProjectsByGuid["{D2633E4D-46FF-4C4E-8340-4BC7CDF78615}"];
+            ProjectInSolution classLibraryProject = solution.ProjectsByGuid["{6185CC21-BE89-448A-B3C0-D1C27112E595}"];
+            ProjectInSolution mainAppProject = solution.ProjectsByGuid["{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}"];
+            ProjectInSolution lowLevelProject = solution.ProjectsByGuid["{E8E75132-67E4-4D6F-9CAE-8DA4C883F419}"];
+            ProjectInSolution highLevelProject = solution.ProjectsByGuid["{D2633E4D-46FF-4C4E-8340-4BC7CDF78615}"];
             mainAppProject.GetUniqueProjectName().ShouldNotBe(classLibraryProject.GetUniqueProjectName());
             classLibraryProject.GetUniqueProjectName().ShouldBe("ClassLibrary");
             mainAppProject.GetUniqueProjectName().ShouldBe("MainApp");
@@ -1964,48 +1963,48 @@ public void ParseProjectConfigurationsInSolutionConfigurations1()
 
             SolutionFile solution = ParseSolutionHelper(solutionFileContents);
 
-            ProjectInSolution csProject = (ProjectInSolution)solution.ProjectsByGuid["{6185CC21-BE89-448A-B3C0-D1C27112E595}"];
-            ProjectInSolution vcProject = (ProjectInSolution)solution.ProjectsByGuid["{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}"];
+            ProjectInSolution csProject = solution.ProjectsByGuid["{6185CC21-BE89-448A-B3C0-D1C27112E595}"];
+            ProjectInSolution vcProject = solution.ProjectsByGuid["{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}"];
 
-            Assert.Equal(6, csProject.ProjectConfigurations.Count);
+            csProject.ProjectConfigurations.Count.ShouldBe(6);
 
-            Assert.Equal("Debug|AnyCPU", csProject.ProjectConfigurations["Debug|Any CPU"].FullName);
-            Assert.True(csProject.ProjectConfigurations["Debug|Any CPU"].IncludeInBuild);
+            csProject.ProjectConfigurations["Debug|Any CPU"].FullName.ShouldBe("Debug|AnyCPU");
+            csProject.ProjectConfigurations["Debug|Any CPU"].IncludeInBuild.ShouldBeTrue();
 
-            Assert.Equal("Release|AnyCPU", csProject.ProjectConfigurations["Debug|Mixed Platforms"].FullName);
-            Assert.True(csProject.ProjectConfigurations["Debug|Mixed Platforms"].IncludeInBuild);
+            csProject.ProjectConfigurations["Debug|Mixed Platforms"].FullName.ShouldBe("Release|AnyCPU");
+            csProject.ProjectConfigurations["Debug|Mixed Platforms"].IncludeInBuild.ShouldBeTrue();
 
-            Assert.Equal("Debug|AnyCPU", csProject.ProjectConfigurations["Debug|Win32"].FullName);
-            Assert.False(csProject.ProjectConfigurations["Debug|Win32"].IncludeInBuild);
+            csProject.ProjectConfigurations["Debug|Win32"].FullName.ShouldBe("Debug|AnyCPU");
+            csProject.ProjectConfigurations["Debug|Win32"].IncludeInBuild.ShouldBeFalse();
 
-            Assert.Equal("Release|AnyCPU", csProject.ProjectConfigurations["Release|Any CPU"].FullName);
-            Assert.True(csProject.ProjectConfigurations["Release|Any CPU"].IncludeInBuild);
+            csProject.ProjectConfigurations["Release|Any CPU"].FullName.ShouldBe("Release|AnyCPU");
+            csProject.ProjectConfigurations["Release|Any CPU"].IncludeInBuild.ShouldBeTrue();
 
-            Assert.Equal("Release|AnyCPU", csProject.ProjectConfigurations["Release|Mixed Platforms"].FullName);
-            Assert.True(csProject.ProjectConfigurations["Release|Mixed Platforms"].IncludeInBuild);
+            csProject.ProjectConfigurations["Release|Mixed Platforms"].FullName.ShouldBe("Release|AnyCPU");
+            csProject.ProjectConfigurations["Release|Mixed Platforms"].IncludeInBuild.ShouldBeTrue();
 
-            Assert.Equal("Release|AnyCPU", csProject.ProjectConfigurations["Release|Win32"].FullName);
-            Assert.False(csProject.ProjectConfigurations["Release|Win32"].IncludeInBuild);
+            csProject.ProjectConfigurations["Release|Win32"].FullName.ShouldBe("Release|AnyCPU");
+            csProject.ProjectConfigurations["Release|Win32"].IncludeInBuild.ShouldBeFalse();
 
-            Assert.Equal(6, vcProject.ProjectConfigurations.Count);
+            vcProject.ProjectConfigurations.Count.ShouldBe(6);
 
-            Assert.Equal("Debug|Win32", vcProject.ProjectConfigurations["Debug|Any CPU"].FullName);
-            Assert.False(vcProject.ProjectConfigurations["Debug|Any CPU"].IncludeInBuild);
+            vcProject.ProjectConfigurations["Debug|Any CPU"].FullName.ShouldBe("Debug|Win32");
+            vcProject.ProjectConfigurations["Debug|Any CPU"].IncludeInBuild.ShouldBeFalse();
 
-            Assert.Equal("Debug|Win32", vcProject.ProjectConfigurations["Debug|Mixed Platforms"].FullName);
-            Assert.True(vcProject.ProjectConfigurations["Debug|Mixed Platforms"].IncludeInBuild);
+            vcProject.ProjectConfigurations["Debug|Mixed Platforms"].FullName.ShouldBe("Debug|Win32");
+            vcProject.ProjectConfigurations["Debug|Mixed Platforms"].IncludeInBuild.ShouldBeTrue();
 
-            Assert.Equal("Debug|Win32", vcProject.ProjectConfigurations["Debug|Win32"].FullName);
-            Assert.True(vcProject.ProjectConfigurations["Debug|Win32"].IncludeInBuild);
+            vcProject.ProjectConfigurations["Debug|Win32"].FullName.ShouldBe("Debug|Win32");
+            vcProject.ProjectConfigurations["Debug|Win32"].IncludeInBuild.ShouldBeTrue();
 
-            Assert.Equal("Release|Win32", vcProject.ProjectConfigurations["Release|Any CPU"].FullName);
-            Assert.False(vcProject.ProjectConfigurations["Release|Any CPU"].IncludeInBuild);
+            vcProject.ProjectConfigurations["Release|Any CPU"].FullName.ShouldBe("Release|Win32");
+            vcProject.ProjectConfigurations["Release|Any CPU"].IncludeInBuild.ShouldBeFalse();
 
-            Assert.Equal("Release|Win32", vcProject.ProjectConfigurations["Release|Mixed Platforms"].FullName);
-            Assert.True(vcProject.ProjectConfigurations["Release|Mixed Platforms"].IncludeInBuild);
+            vcProject.ProjectConfigurations["Release|Mixed Platforms"].FullName.ShouldBe("Release|Win32");
+            vcProject.ProjectConfigurations["Release|Mixed Platforms"].IncludeInBuild.ShouldBeTrue();
 
-            Assert.Equal("Release|Win32", vcProject.ProjectConfigurations["Release|Win32"].FullName);
-            Assert.True(vcProject.ProjectConfigurations["Release|Win32"].IncludeInBuild);
+            vcProject.ProjectConfigurations["Release|Win32"].FullName.ShouldBe("Release|Win32");
+            vcProject.ProjectConfigurations["Release|Win32"].IncludeInBuild.ShouldBeTrue();
         }
 
         /// <summary>
@@ -2049,24 +2048,24 @@ public void ParseProjectConfigurationsInSolutionConfigurations2()
 
             SolutionFile solution = ParseSolutionHelper(solutionFileContents);
 
-            ProjectInSolution webProject = (ProjectInSolution)solution.ProjectsByGuid["{E8E75132-67E4-4D6F-9CAE-8DA4C883F418}"];
-            ProjectInSolution exeProject = (ProjectInSolution)solution.ProjectsByGuid["{25FD9E7C-F37E-48E0-9A7C-607FE4AACCC0}"];
-            ProjectInSolution missingWebProject = (ProjectInSolution)solution.ProjectsByGuid["{E8E75132-67E4-4D6F-9CAE-8DA4C883F419}"];
+            ProjectInSolution webProject = solution.ProjectsByGuid["{E8E75132-67E4-4D6F-9CAE-8DA4C883F418}"];
+            ProjectInSolution exeProject = solution.ProjectsByGuid["{25FD9E7C-F37E-48E0-9A7C-607FE4AACCC0}"];
+            ProjectInSolution missingWebProject = solution.ProjectsByGuid["{E8E75132-67E4-4D6F-9CAE-8DA4C883F419}"];
 
-            Assert.Single(webProject.ProjectConfigurations);
+            webProject.ProjectConfigurations.ShouldHaveSingleItem();
 
-            Assert.Equal("Debug|.NET", webProject.ProjectConfigurations["Debug|.NET"].FullName);
-            Assert.True(webProject.ProjectConfigurations["Debug|.NET"].IncludeInBuild);
+            webProject.ProjectConfigurations["Debug|.NET"].FullName.ShouldBe("Debug|.NET");
+            webProject.ProjectConfigurations["Debug|.NET"].IncludeInBuild.ShouldBeTrue();
 
-            Assert.Single(exeProject.ProjectConfigurations);
+            exeProject.ProjectConfigurations.ShouldHaveSingleItem();
 
-            Assert.Equal("Debug", exeProject.ProjectConfigurations["Debug|.NET"].FullName);
-            Assert.False(exeProject.ProjectConfigurations["Debug|.NET"].IncludeInBuild);
+            exeProject.ProjectConfigurations["Debug|.NET"].FullName.ShouldBe("Debug");
+            exeProject.ProjectConfigurations["Debug|.NET"].IncludeInBuild.ShouldBeFalse();
 
-            Assert.Empty(missingWebProject.ProjectConfigurations);
+            missingWebProject.ProjectConfigurations.ShouldBeEmpty();
 
-            Assert.Equal("Debug", solution.GetDefaultConfigurationName()); // "Default solution configuration"
-            Assert.Equal(".NET", solution.GetDefaultPlatformName()); // "Default solution platform"
+            solution.GetDefaultConfigurationName().ShouldBe("Debug"); // "Default solution configuration"
+            solution.GetDefaultPlatformName().ShouldBe(".NET"); // "Default solution platform"
         }
 
         [Fact]
@@ -2104,8 +2103,8 @@ public void ParseSolutionFileContainingProjectsWithParentSlnFolder()
 
             SolutionFile solution = ParseSolutionHelper(solutionFileContents);
 
-            ProjectInSolution project1 = (ProjectInSolution)solution.ProjectsByGuid["{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}"];
-            ProjectInSolution project2 = (ProjectInSolution)solution.ProjectsByGuid["{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}"];
+            ProjectInSolution project1 = solution.ProjectsByGuid["{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}"];
+            ProjectInSolution project2 = solution.ProjectsByGuid["{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}"];
 
             project2.GetUniqueProjectName().ShouldNotBe(project1.GetUniqueProjectName());
             project1.GetUniqueProjectName().ShouldBe(@"MySlnFolder\Project_Named_With_Dots");
@@ -2173,8 +2172,8 @@ public void ParseSolutionFileContainingProjectsWithSimilarNames_TwoProjects(stri
         {
             SolutionFile solution = ParseSolutionHelper(solutionFileContents);
 
-            ProjectInSolution project1 = (ProjectInSolution)solution.ProjectsByGuid["{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}"];
-            ProjectInSolution project2 = (ProjectInSolution)solution.ProjectsByGuid["{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}"];
+            ProjectInSolution project1 = solution.ProjectsByGuid["{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}"];
+            ProjectInSolution project2 = solution.ProjectsByGuid["{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}"];
 
             project2.GetUniqueProjectName().ShouldNotBe(project1.GetUniqueProjectName());
             project1.GetUniqueProjectName().ShouldBe("Project_Named_With_Dots_FC2889D9-6050-4D2E-B022-979CCFEEAAAC");
@@ -2250,9 +2249,9 @@ public void ParseSolutionFileContainingProjectsWithSimilarNames_ThreeProjects(st
         {
             SolutionFile solution = ParseSolutionHelper(solutionFileContents);
 
-            ProjectInSolution project1 = (ProjectInSolution)solution.ProjectsByGuid["{6185CC21-BE89-448A-B3C0-D1C27112E595}"];
-            ProjectInSolution project2 = (ProjectInSolution)solution.ProjectsByGuid["{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}"];
-            ProjectInSolution project3 = (ProjectInSolution)solution.ProjectsByGuid["{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}"];
+            ProjectInSolution project1 = solution.ProjectsByGuid["{6185CC21-BE89-448A-B3C0-D1C27112E595}"];
+            ProjectInSolution project2 = solution.ProjectsByGuid["{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}"];
+            ProjectInSolution project3 = solution.ProjectsByGuid["{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}"];
 
             project2.GetUniqueProjectName().ShouldNotBe(project1.GetUniqueProjectName());
             project3.GetUniqueProjectName().ShouldNotBe(project2.GetUniqueProjectName());
@@ -2304,9 +2303,9 @@ public void ParseSolutionFileContainingProjectsWithSimilarNames_ThreeProjects_On
                 ";
 
             Action parseSolution = () => ParseSolutionHelper(solutionFileContents);
-            var exception = Assert.Throws<InvalidProjectFileException>(parseSolution);
+            var exception = Should.Throw<InvalidProjectFileException>(parseSolution);
 
-            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, "SolutionParseDuplicateProject", "Project.Named.With.Dots");
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out _, out _, "SolutionParseDuplicateProject", "Project.Named.With.Dots");
 
             exception.Message.ShouldStartWith(message);
         }
@@ -2348,9 +2347,9 @@ public void ParseSolutionFileContainingProjectsWithSimilarNames_ThreeProjects_On
                 ";
 
             Action parseSolution = () => ParseSolutionHelper(solutionFileContents);
-            var exception = Assert.Throws<InvalidProjectFileException>(parseSolution);
+            var exception = Should.Throw<InvalidProjectFileException>(parseSolution);
 
-            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, "SolutionParseDuplicateProject", "Project_Named_With_Dots");
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out _, out _, "SolutionParseDuplicateProject", "Project_Named_With_Dots");
 
             exception.Message.ShouldStartWith(message);
         }
@@ -2394,11 +2393,48 @@ public void ParseSolutionFileContainingProjectsWithSimilarNames_FourProjects_One
                 ";
 
             Action parseSolution = () => ParseSolutionHelper(solutionFileContents);
-            var exception = Assert.Throws<InvalidProjectFileException>(parseSolution);
+            var exception = Should.Throw<InvalidProjectFileException>(parseSolution);
 
-            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, "SolutionParseDuplicateProject", "Project_Named_With_Dots");
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out _, out _, "SolutionParseDuplicateProject", "Project_Named_With_Dots");
 
             exception.Message.ShouldStartWith(message);
         }
+
+        /// <summary>
+        /// A test where paths contain ..\ segments to ensure the paths are normalized.
+        /// </summary>
+        [Fact]
+        public void ParseSolutionWithParentedPaths()
+        {
+            string solutionFileContents =
+                @"
+                Microsoft Visual Studio Solution File, Format Version 9.00
+                # Visual Studio 2005
+                Project('{749ABBD6-B803-4DA5-8209-498127164114}')  = 'ProjectA',  '..\ProjectA\ProjectA.csproj', '{0ABED153-9451-483C-8140-9E8D7306B216}'
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|AnyCPU = Debug|AnyCPU
+                        Release|AnyCPU = Release|AnyCPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.ActiveCfg = Debug|AnyCPU
+                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.Build.0 = Debug|AnyCPU
+                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.ActiveCfg = Release|AnyCPU
+                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.Build.0 = Release|AnyCPU
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                EndGlobal
+                ";
+
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+            string expectedRelativePath = Path.Combine("..", "ProjectA", "ProjectA.csproj");
+            solution.ProjectsInOrder[0].ProjectName.ShouldBe("ProjectA");
+            solution.ProjectsInOrder[0].RelativePath.ShouldBe(expectedRelativePath);
+            solution.ProjectsInOrder[0].AbsolutePath.ShouldBe(Path.GetFullPath(Path.Combine(Path.GetDirectoryName(solution.FullPath)!, expectedRelativePath)));
+            solution.ProjectsInOrder[0].ProjectGuid.ShouldBe("{0ABED153-9451-483C-8140-9E8D7306B216}");
+        }
     }
 }
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 45b18658d45..ad133c08db8 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -740,10 +740,10 @@ public void SolutionConfigurationWithDependencies()
             string solutionConfigurationContents = msbuildProject.GetPropertyValue("CurrentSolutionConfigurationContents");
 
             // Only the specified solution configuration is represented in THE BLOB: nothing for x64 in this case
-            string expected = @"<SolutionConfiguration>
-  <ProjectConfiguration Project=`{786E302A-96CE-43DC-B640-D6B6CC9BF6C0}` AbsolutePath=`##temp##Project1\A.csproj` BuildProjectInSolution=`True`>Debug|AnyCPU</ProjectConfiguration>
-  <ProjectConfiguration Project=`{881C1674-4ECA-451D-85B6-D7C59B7F16FA}` AbsolutePath=`##temp##Project2\B.csproj` BuildProjectInSolution=`True`>Debug|AnyCPU<ProjectDependency Project=`{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}` /></ProjectConfiguration>
-  <ProjectConfiguration Project=`{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}` AbsolutePath=`##temp##Project3\C.csproj` BuildProjectInSolution=`True`>Debug|AnyCPU</ProjectConfiguration>
+            string expected = $@"<SolutionConfiguration>
+  <ProjectConfiguration Project=`{{786E302A-96CE-43DC-B640-D6B6CC9BF6C0}}` AbsolutePath=`##temp##{Path.Combine("Project1", "A.csproj")}` BuildProjectInSolution=`True`>Debug|AnyCPU</ProjectConfiguration>
+  <ProjectConfiguration Project=`{{881C1674-4ECA-451D-85B6-D7C59B7F16FA}}` AbsolutePath=`##temp##{Path.Combine("Project2", "B.csproj")}` BuildProjectInSolution=`True`>Debug|AnyCPU<ProjectDependency Project=`{{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}}` /></ProjectConfiguration>
+  <ProjectConfiguration Project=`{{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}}` AbsolutePath=`##temp##{Path.Combine("Project3", "C.csproj")}` BuildProjectInSolution=`True`>Debug|AnyCPU</ProjectConfiguration>
 </SolutionConfiguration>".Replace("`", "\"").Replace("##temp##", Path.GetTempPath());
 
             Helpers.VerifyAssertLineByLine(expected, solutionConfigurationContents);
@@ -953,14 +953,14 @@ public void TestAddPropertyGroupForSolutionConfiguration()
             msbuildProject.ReevaluateIfNecessary();
 
             string solutionConfigurationContents = msbuildProject.GetPropertyValue("CurrentSolutionConfigurationContents");
-            string tempProjectPath = Path.Combine(Path.GetTempPath(), "ClassLibrary1\\ClassLibrary1.csproj");
+            string tempProjectPath = Path.Combine(Path.GetTempPath(), "ClassLibrary1", "ClassLibrary1.csproj");
 
             Assert.Contains("{6185CC21-BE89-448A-B3C0-D1C27112E595}", solutionConfigurationContents);
             tempProjectPath = Path.GetFullPath(tempProjectPath);
             Assert.True(solutionConfigurationContents.IndexOf(tempProjectPath, StringComparison.OrdinalIgnoreCase) > 0);
             Assert.Contains("CSConfig1|AnyCPU", solutionConfigurationContents);
 
-            tempProjectPath = Path.Combine(Path.GetTempPath(), "MainApp\\MainApp.vcxproj");
+            tempProjectPath = Path.Combine(Path.GetTempPath(), "MainApp", "MainApp.vcxproj");
             tempProjectPath = Path.GetFullPath(tempProjectPath);
             Assert.Contains("{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}", solutionConfigurationContents);
             Assert.True(solutionConfigurationContents.IndexOf(tempProjectPath, StringComparison.OrdinalIgnoreCase) > 0);
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 48164d9284d..76dd7380d59 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -1555,7 +1555,8 @@ public void ExpandAllIntoStringNotTruncated()
         {
             using (TestEnvironment env = TestEnvironment.Create())
             {
-                env.SetChangeWave(ChangeWaves.Wave16_8);
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave16_8.ToString());
                 BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
                 ProjectInstance project = ProjectHelpers.CreateEmptyProjectInstance();
                 var manySpaces = "".PadLeft(2000);
@@ -1612,6 +1613,7 @@ public void ExpandAllIntoStringNotTruncated()
                 // but that goes back to MSBuild 4.something so I'm codifying it in this test. If you're here because you cleaned it up
                 // and want to fix the test my current opinion is that's fine.
                 actual.ShouldBe(expected);
+                ChangeWaves.ResetStateForTests();
             }
         }
 
diff --git a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
index e95fb7d8251..c1f0161e91d 100644
--- a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
+++ b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
@@ -194,7 +194,7 @@ var currentSolutionConfigurationPlatform in SolutionFileBuilder.SolutionConfigur
             }
         }
 
-        [Theory(Timeout = 20_000)] // Test hangs intermittently: https://github.com/dotnet/msbuild/issues/5520
+        [Theory(Skip = "hangs in CI, can't repro locally: https://github.com/dotnet/msbuild/issues/5453")]
         [MemberData(nameof(GraphsWithUniformSolutionConfigurations))]
         public void GraphConstructionCanLoadEntryPointsFromSolution(
             Dictionary<int, int[]> edges,
diff --git a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
index 7cc2060da0f..62cc2016a58 100644
--- a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
+++ b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
@@ -473,8 +473,9 @@ public void SkippedTargetsShouldNotTriggerCacheMissEnforcement()
 ".Cleanup()).Path;
 
             _buildParametersPrototype.IsolateProjects.ShouldBeTrue();
+            var buildParameters = _buildParametersPrototype.Clone();
 
-            using (var buildManagerSession = new Helpers.BuildManagerSession(_env, _buildParametersPrototype))
+            using (var buildManagerSession = new Helpers.BuildManagerSession(_env, buildParameters))
             {
                 // seed caches with results from the reference
                 buildManagerSession.BuildProjectFile(referenceFile).OverallResult.ShouldBe(BuildResultCode.Success);
diff --git a/src/Build.UnitTests/Graph/ParallelWorkSet_Tests.cs b/src/Build.UnitTests/Graph/ParallelWorkSet_Tests.cs
index 234f6f3a47d..5592f324956 100644
--- a/src/Build.UnitTests/Graph/ParallelWorkSet_Tests.cs
+++ b/src/Build.UnitTests/Graph/ParallelWorkSet_Tests.cs
@@ -1,6 +1,7 @@
 ﻿using System;
 using System.Collections.Generic;
 using System.Threading;
+using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Shouldly;
 using Xunit;
@@ -61,7 +62,7 @@ public void GivenExceptionsOnWorkerThread_CompletesAndThrowsExceptions()
         {
             TestParallelWorkSet(new ParallelWorkSetTestCase
             {
-                DegreeOfParallelism = Environment.ProcessorCount,
+                DegreeOfParallelism = NativeMethodsShared.GetLogicalCoreCount(),
                 WorkItemsToAdd = new List<WorkItem>
                 {
                     new WorkItem
@@ -89,7 +90,7 @@ public void GivenNoWorkItemAndMultipleWorkers_Completes()
         {
             TestParallelWorkSet(new ParallelWorkSetTestCase
             {
-                DegreeOfParallelism = Environment.ProcessorCount
+                DegreeOfParallelism = NativeMethodsShared.GetLogicalCoreCount()
             });
         }
 
@@ -104,7 +105,7 @@ public void GivenRecursiveWorkItemsAndMultipleWorkers_Completes()
         {
             TestParallelWorkSet(new ParallelWorkSetTestCase
             {
-                DegreeOfParallelism = Environment.ProcessorCount,
+                DegreeOfParallelism = NativeMethodsShared.GetLogicalCoreCount(),
                 WorkItemsToAdd = new List<WorkItem>
                 {
                     new WorkItem
@@ -168,7 +169,7 @@ public void GivenWorkItemsAndMultipleWorkers_Completes()
         {
             TestParallelWorkSet(new ParallelWorkSetTestCase
             {
-                DegreeOfParallelism = Environment.ProcessorCount,
+                DegreeOfParallelism = NativeMethodsShared.GetLogicalCoreCount(),
                 WorkItemsToAdd = new List<WorkItem>
                 {
                     new WorkItem
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index a52d2eace20..548a25b3858 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -7,7 +7,6 @@
 using System.IO;
 using System.Linq;
 using System.Text.RegularExpressions;
-using Microsoft.Build.BackEnd;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
diff --git a/src/Build.UnitTests/InternalEngineHelpers.cs b/src/Build.UnitTests/InternalEngineHelpers.cs
index 2a4de9d485d..aa0ae0c34be 100644
--- a/src/Build.UnitTests/InternalEngineHelpers.cs
+++ b/src/Build.UnitTests/InternalEngineHelpers.cs
@@ -7,8 +7,13 @@
 using System.Linq;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Definition;
+using Microsoft.Build.Engine.UnitTests.TestComparers;
 using Microsoft.Build.Evaluation.Context;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
+using Microsoft.Build.UnitTests;
+using Microsoft.Build.UnitTests.BackEnd;
+using Shouldly;
 using SdkResolverContext = Microsoft.Build.Framework.SdkResolverContext;
 using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
 using SdkResultFactory = Microsoft.Build.Framework.SdkResultFactory;
@@ -143,5 +148,40 @@ public override Framework.SdkResult Resolve(SdkReference sdkReference, SdkResolv
                     : factory.IndicateFailure(new[] { $"Not in {nameof(_mapping)}" });
             }
         }
+
+        internal static class EngineHelpers
+        {
+            internal static void AssertBuildResultsEqual(BuildResult actualBuildResult, BuildResult expectedBuildResult)
+            {
+                actualBuildResult.InitialTargets.ShouldBe(expectedBuildResult.InitialTargets);
+                actualBuildResult.DefaultTargets.ShouldBe(expectedBuildResult.DefaultTargets);
+                actualBuildResult.CircularDependency.ShouldBe(expectedBuildResult.CircularDependency);
+                actualBuildResult.Exception.ShouldBe(expectedBuildResult.Exception);
+                actualBuildResult.OverallResult.ShouldBe(expectedBuildResult.OverallResult);
+                actualBuildResult.ProjectStateAfterBuild.ShouldBe(expectedBuildResult.ProjectStateAfterBuild);
+
+                Helpers.AssertDictionariesEqual(
+                    actualBuildResult.ResultsByTarget,
+                    expectedBuildResult.ResultsByTarget,
+                    (a, b) =>
+                    {
+                        a.Key.ShouldBe(b.Key);
+
+                        AssertTargetResultsEqual(a.Value, b.Value);
+                    });
+            }
+
+            internal static void AssertTargetResultsEqual(TargetResult a, TargetResult b)
+            {
+                TranslationHelpers.CompareExceptions(a.Exception, b.Exception).ShouldBeTrue();
+                TranslationHelpers.CompareCollections(a.Items, b.Items, TaskItemComparer.Instance).ShouldBeTrue();
+
+                a.ResultCode.ShouldBe(b.ResultCode);
+
+                a.WorkUnitResult.ActionCode.ShouldBe(b.WorkUnitResult.ActionCode);
+                a.WorkUnitResult.Exception.ShouldBe(b.WorkUnitResult.Exception);
+                a.WorkUnitResult.ResultCode.ShouldBe(b.WorkUnitResult.ResultCode);
+            }
+        }
     }
 }
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index fdeaf730a1b..756dffdbd0e 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -16,7 +16,6 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <PackageReference Include="System.Collections.Concurrent" />
     <PackageReference Include="Shouldly" />
     <PackageReference Include="Microsoft.CodeAnalysis.Build.Tasks" />
     <PackageReference Include="NuGet.Frameworks" >
@@ -40,6 +39,12 @@
     </ProjectReference>
     <ProjectReference Include="..\Samples\PortableTask\PortableTask.csproj" Private="false" ReferenceOutputAssembly="false" OutputItemType="PortableTaskResolvedProjectReferencePath" SetTargetFramework="TargetFramework=netstandard1.3" />
 
+    <ProjectReference Include="..\Samples\ProjectCachePlugin\ProjectCachePlugin.csproj" Private="false" ReferenceOutputAssembly="false">
+      <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">TargetFramework=$(FullFrameworkTFM)</SetTargetFramework>
+      <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MonoBuild)' == 'true'">TargetFramework=$(FullFrameworkTFM)</SetTargetFramework>
+      <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">TargetFramework=net5.0</SetTargetFramework>
+    </ProjectReference>
+
     <Reference Include="System.Configuration" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
   </ItemGroup>
 
diff --git a/src/Build.UnitTests/OpportunisticIntern_Tests.cs b/src/Build.UnitTests/OpportunisticIntern_Tests.cs
deleted file mode 100644
index c47f751c349..00000000000
--- a/src/Build.UnitTests/OpportunisticIntern_Tests.cs
+++ /dev/null
@@ -1,217 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-using System.Text;
-using Microsoft.Build.Shared;
-using Xunit;
-using Xunit.Abstractions;
-
-namespace Microsoft.Build.UnitTests
-{
-    public abstract class OpportunisticInternTestBase : IDisposable
-    {
-        protected TestEnvironment _env;
-
-        public void Dispose()
-        {
-            _env.Dispose();
-        }
-
-        protected OpportunisticInternTestBase(ITestOutputHelper testOutput)
-        {
-            _env = TestEnvironment.Create(testOutput);
-        }
-
-        private static bool IsInternable(IInternable internable)
-        {
-            string i1 = OpportunisticIntern.InternableToString(internable);
-            string i2 = OpportunisticIntern.InternableToString(internable);
-            Assert.Equal(i1, i2); // No matter what, the same string value should return.
-            return Object.ReferenceEquals(i1, i2);
-        }
-
-        private static void AssertInternable(IInternable internable)
-        {
-            Assert.True(IsInternable(internable));
-        }
-
-        private static void AssertInternable(StringBuilder sb)
-        {
-            AssertInternable(new StringBuilderInternTarget(sb));
-        }
-
-        private static string AssertInternable(char[] ch, int startIndex, int count)
-        {
-            var target = new CharArrayInternTarget(ch, startIndex, count);
-            AssertInternable(target);
-            Assert.Equal(target.Length, count);
-
-            return target.ExpensiveConvertToString();
-        }
-
-        private static void AssertInternable(string value)
-        {
-            AssertInternable(new StringBuilder(value));
-            AssertInternable(value.ToCharArray(), 0, value.ToCharArray().Length);
-        }
-
-        private static void AssertNotInternable(IInternable internable)
-        {
-            Assert.False(IsInternable(internable));
-        }
-
-        private static void AssertNotInternable(StringBuilder sb)
-        {
-            AssertNotInternable(new StringBuilderInternTarget(sb));
-        }
-
-        private static void AssertNotInternable(char[] ch)
-        {
-            AssertNotInternable(new CharArrayInternTarget(ch, ch.Length));
-        }
-
-        protected static void AssertNotInternable(string value)
-        {
-            AssertNotInternable(new StringBuilder(value));
-            AssertNotInternable(value.ToCharArray());
-        }
-
-        /// <summary>
-        /// Test interning segment of char array
-        /// </summary>
-        [Fact]
-        public void SubArray()
-        {
-            var result = AssertInternable(new char[] { 'a', 't', 'r', 'u', 'e' }, 1, 4);
-
-            Assert.Equal("true", result);
-        }
-
-        /// <summary>
-        /// Test interning segment of char array
-        /// </summary>
-        [Fact]
-        public void SubArray2()
-        {
-            var result = AssertInternable(new char[] { 'a', 't', 'r', 'u', 'e', 'x' }, 1, 4);
-
-            Assert.Equal("true", result);
-        }
-
-        /// <summary>
-        /// Unique strings should not be interned
-        /// </summary>
-        [Fact]
-        public void NonInternableDummyGlobalVariable()
-        {
-            AssertNotInternable($"{MSBuildConstants.MSBuildDummyGlobalPropertyHeader}{new string('1', 100)}");
-        }
-
-        /// <summary>
-        /// This is the list of hard-coded interns. They should report interned even though they are too small for normal interning.
-        /// </summary>
-        [Fact]
-        public void KnownInternableTinyStrings()
-        {
-            AssertInternable("C#");
-            AssertInternable("F#");
-            AssertInternable("VB");
-            AssertInternable("True");
-            AssertInternable("TRUE");
-            AssertInternable("Copy");
-            AssertInternable("v4.0");
-            AssertInternable("true");
-            AssertInternable("FALSE");
-            AssertInternable("false");
-            AssertInternable("Debug");
-            AssertInternable("Build");
-            AssertInternable("''!=''");
-            AssertInternable("AnyCPU");
-            AssertInternable("Library");
-            AssertInternable("MSBuild");
-            AssertInternable("Release");
-            AssertInternable("ResolveAssemblyReference");
-        }
-
-        /// <summary>
-        /// Test a set of strings that are similar to each other
-        /// </summary>
-        [Fact]
-        public void InternableDifferingOnlyByNthCharacter()
-        {
-            string test = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890!@#$%^&*()_+ABCDEFGHIJKLMNOPQRSTUVabcdefghijklmnopqrstuvwxyz0150";
-            for (int i = 0; i < test.Length; ++i)
-            {
-                string mutated = test.Substring(0, i) + " " + test.Substring(i + 1);
-                AssertInternable(mutated);
-            }
-        }
-
-        /// <summary>
-        /// Test The empty string
-        /// </summary>
-        [Fact]
-        public void StringDotEmpty()
-        {
-            AssertInternable(String.Empty);
-        }
-
-        /// <summary>
-        /// Test an empty string.
-        /// </summary>
-        [Fact]
-        public void DoubleDoubleQuotes()
-        {
-            AssertInternable("");
-        }
-    }
-
-    /// <summary>
-    /// Tests the new (default) implementation of OpportunisticIntern.
-    /// </summary>
-    public class OpportunisticIntern_Tests : OpportunisticInternTestBase
-    {
-        public OpportunisticIntern_Tests(ITestOutputHelper testOutput)
-            : base(testOutput)
-        {
-            OpportunisticIntern.ResetForTests();
-        }
-    }
-
-    /// <summary>
-    /// Tests the legacy implementation of OpportunisticIntern.
-    /// </summary>
-    public class OpportunisticInternLegacy_Tests : OpportunisticInternTestBase
-    {
-        public OpportunisticInternLegacy_Tests(ITestOutputHelper testOutput)
-            : base(testOutput)
-        {
-            _env.SetEnvironmentVariable("MSBuildUseLegacyStringInterner", "1");
-            OpportunisticIntern.ResetForTests();
-        }
-
-        /// <summary>
-        /// The legacy implementation does not intern tiny strings unless they are on the hard-coded list.
-        /// </summary>
-        [Fact]
-        public void NonInternableTinyString()
-        {
-            AssertNotInternable("1234");
-        }
-    }
-
-    /// <summary>
-    /// Tests the legacy implementation of OpportunisticIntern with simple concurrency enabled.
-    /// </summary>
-    public class OpportunisticInternLegacySimpleConcurrecy_Tests : OpportunisticInternTestBase
-    {
-        public OpportunisticInternLegacySimpleConcurrecy_Tests(ITestOutputHelper testOutput)
-            : base(testOutput)
-        {
-            _env.SetEnvironmentVariable("MSBuildUseLegacyStringInterner", "1");
-            _env.SetEnvironmentVariable("MSBuildUseSimpleInternConcurrency", "1");
-            OpportunisticIntern.ResetForTests();
-        }
-    }
-}
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
new file mode 100644
index 00000000000..f7d7eca1c2c
--- /dev/null
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -0,0 +1,884 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using System;
+using System.Collections.Concurrent;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text.RegularExpressions;
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.ProjectCache;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Graph;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Unittest;
+using Microsoft.Build.UnitTests;
+using Microsoft.Build.Utilities;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+using Task = System.Threading.Tasks.Task;
+
+namespace Microsoft.Build.Engine.UnitTests.ProjectCache
+{
+    public class ProjectCacheTests : IDisposable
+    {
+        public ProjectCacheTests(ITestOutputHelper output)
+        {
+            _output = output;
+            _env = TestEnvironment.Create(output);
+
+            BuildManager.ProjectCacheItems.ShouldBeEmpty();
+            _env.WithInvariant(new CustomConditionInvariant(() => BuildManager.ProjectCacheItems.Count == 0));
+        }
+
+        public void Dispose()
+        {
+            _env.Dispose();
+        }
+
+        private static readonly string AssemblyMockCache = nameof(AssemblyMockCache);
+
+        private static readonly Lazy<string> SamplePluginAssemblyPath =
+            new Lazy<string>(
+                () =>
+                {
+                    return Directory.EnumerateFiles(
+                        Path.GetFullPath(
+                            Path.Combine(
+                                BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory,
+                                "..",
+                                "..",
+                                "..",
+                                "Samples",
+                                "ProjectCachePlugin")),
+                        "ProjectCachePlugin.dll",
+                        SearchOption.AllDirectories).First();
+                });
+
+        public class GraphCacheResponse
+        {
+            public const string CacheHitByProxy = nameof(CacheHitByProxy);
+            public const string CacheHitByTargetResult = nameof(CacheHitByTargetResult);
+
+            private static readonly string P2PTargets =
+                @$"
+                    <ItemGroup>
+                        <ProjectReferenceTargets Include=`Build` Targets=`Build` />
+                        <{ItemTypeNames.ProjectCachePlugin} Include=`{SamplePluginAssemblyPath.Value}` />
+                    </ItemGroup>
+
+                    <Target Name=`Build` Returns=`@(ReturnValue)`>
+                        <MSBuild Projects=`@(ProjectReference)` Targets=`Build`>
+                            <Output TaskParameter=`TargetOutputs` ItemName=`ReferenceReturns` />
+                        </MSBuild>
+
+                        <Message Text=`Reference: %(ReferenceReturns.Identity) : %(ReferenceReturns.File)` Importance=`High` />
+                        <Error Text=`Reference file [%(ReferenceReturns.File)] does not exist` Condition=`@(ReferenceReturns->Count()) != 0 and !Exists(%(ReferenceReturns.File))` />
+
+                        <ItemGroup>
+                            <ReturnValue Include=`$(MSBuildProjectName)` File=`$(MSBuildProjectFile)` />
+                        </ItemGroup>
+                    </Target>
+
+                    <Target Name=`ProxyBuild` Returns=`@(ReturnValue)`>
+                        <ItemGroup>
+                            <ReturnValue Include=`$(MSBuildProjectName)` File=`$(MSBuildProjectFile)` {CacheHitByProxy}=`true`/>
+                        </ItemGroup>
+                    </Target>";
+
+            private Dictionary<int, int[]> GraphEdges { get; }
+
+            public Dictionary<int, CacheResult> NonCacheMissResults { get; }
+
+            public GraphCacheResponse(Dictionary<int, int[]> graphEdges, Dictionary<int, CacheResult>? nonCacheMissResults = null)
+            {
+                GraphEdges = graphEdges;
+                NonCacheMissResults = nonCacheMissResults ?? new Dictionary<int, CacheResult>();
+            }
+
+            public ProjectGraph CreateGraph(TestEnvironment env)
+            {
+                return Helpers.CreateProjectGraph(
+                    env,
+                    GraphEdges,
+                    null,
+                    P2PTargets);
+            }
+
+            public static CacheResult SuccessfulProxyTargetResult()
+            {
+                return CacheResult.IndicateCacheHit(
+                    new ProxyTargets(
+                        new Dictionary<string, string>
+                        {
+                            {"ProxyBuild", "Build"}
+                        }));
+            }
+
+            public static CacheResult SuccessfulTargetResult(int projectNumber, string projectPath)
+            {
+                return CacheResult.IndicateCacheHit(
+                    new[]
+                    {
+                        new PluginTargetResult(
+                            "Build",
+                            new ITaskItem2[]
+                            {
+                                new TaskItem(
+                                    projectNumber.ToString(),
+                                    new Dictionary<string, string>
+                                    {
+                                        {"File", projectPath},
+                                        {CacheHitByTargetResult, "true"}
+                                    })
+                            },
+                            BuildResultCode.Success
+                            )
+                    });
+            }
+
+            public CacheResult GetExpectedCacheResultForNode(ProjectGraphNode node)
+            {
+                return GetExpectedCacheResultForProjectNumber(GetProjectNumber(node));
+            }
+
+            public CacheResult GetExpectedCacheResultForProjectNumber(int projectNumber)
+            {
+                return NonCacheMissResults.TryGetValue(projectNumber, out var cacheResult)
+                    ? cacheResult
+                    : CacheResult.IndicateNonCacheHit(CacheResultType.CacheMiss);
+            }
+
+            public override string ToString()
+            {
+                //return base.ToString();
+                return string.Join(
+                    ", ",
+                    GraphEdges.Select(e => $"{Node(e.Key)}->{FormatChildren(e.Value)}"));
+
+                string FormatChildren(int[] children)
+                {
+                    return children == null
+                        ? "Null"
+                        : string.Join(",", children.Select(c => Node(c)));
+                }
+
+                string Node(int projectNumber)
+                {
+                    return $"{projectNumber}({Chr(projectNumber)})";
+                }
+
+                char Chr(int projectNumber)
+                {
+                    var cacheResult = GetExpectedCacheResultForProjectNumber(projectNumber);
+                    return cacheResult.ResultType switch
+                    {
+
+                        CacheResultType.CacheHit => cacheResult.ProxyTargets != null
+                            ? 'P'
+                            : 'T',
+                        CacheResultType.CacheMiss => 'M',
+                        CacheResultType.CacheNotApplicable => 'N',
+                        CacheResultType.None => 'E',
+                        _ => throw new ArgumentOutOfRangeException()
+                        };
+                }
+            }
+        }
+
+        [Flags]
+        public enum ExceptionLocations
+        {
+            Constructor = 1 << 0,
+            BeginBuildAsync = 1 << 1,
+            GetCacheResultAsync = 1 << 2,
+            EndBuildAsync = 1 << 3
+        }
+
+        public class InstanceMockCache : ProjectCachePluginBase
+        {
+            private readonly GraphCacheResponse? _testData;
+            public ConcurrentQueue<BuildRequestData> Requests { get; } = new ConcurrentQueue<BuildRequestData>();
+
+            public bool BeginBuildCalled { get; set; }
+            public bool EndBuildCalled { get; set; }
+
+            public InstanceMockCache(GraphCacheResponse? testData = null)
+            {
+                _testData = testData;
+            }
+
+            public override Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken)
+            {
+                logger.LogMessage("MockCache: BeginBuildAsync", MessageImportance.High);
+
+                BeginBuildCalled = true;
+
+                return Task.CompletedTask;
+            }
+
+            public override Task<CacheResult> GetCacheResultAsync(
+                BuildRequestData buildRequest,
+                PluginLoggerBase logger,
+                CancellationToken cancellationToken)
+            {
+                Requests.Enqueue(buildRequest);
+                logger.LogMessage($"MockCache: GetCacheResultAsync for {buildRequest.ProjectFullPath}", MessageImportance.High);
+
+                return
+                    Task.FromResult(
+                        _testData?.GetExpectedCacheResultForProjectNumber(GetProjectNumber(buildRequest.ProjectFullPath))
+                        ?? CacheResult.IndicateNonCacheHit(CacheResultType.CacheMiss));
+            }
+
+            public override Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken)
+            {
+                logger.LogMessage("MockCache: EndBuildAsync", MessageImportance.High);
+
+                EndBuildCalled = true;
+
+                return Task.CompletedTask;
+            }
+
+            public CacheResult GetCacheResultForNode(ProjectGraphNode node)
+            {
+                throw new NotImplementedException();
+            }
+        }
+
+        private readonly TestEnvironment _env;
+
+        private readonly ITestOutputHelper _output;
+
+        public static IEnumerable<GraphCacheResponse> SuccessfulGraphs
+        {
+            get
+            {
+                yield return new GraphCacheResponse(
+                    new Dictionary<int, int[]>
+                    {
+                        {1, null!}
+                    });
+
+                yield return new GraphCacheResponse(
+                    new Dictionary<int, int[]>
+                    {
+                        {1, null!}
+                    },
+                    new Dictionary<int, CacheResult>
+                    {
+                        {1, GraphCacheResponse.SuccessfulProxyTargetResult()}
+                    });
+
+                yield return new GraphCacheResponse(
+                    new Dictionary<int, int[]>
+                    {
+                        {1, null!}
+                    },
+                    new Dictionary<int, CacheResult>
+                    {
+                        {1, GraphCacheResponse.SuccessfulTargetResult(1, "1.proj")}
+                    });
+
+                yield return new GraphCacheResponse(
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {2}}
+                    });
+
+                yield return new GraphCacheResponse(
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {2}}
+                    },
+                    new Dictionary<int, CacheResult>
+                    {
+                        {2, GraphCacheResponse.SuccessfulProxyTargetResult()}
+                    });
+
+                yield return new GraphCacheResponse(
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {2}}
+                    },
+                    new Dictionary<int, CacheResult>
+                    {
+                        {2, GraphCacheResponse.SuccessfulTargetResult(2, "2.proj")}
+                    });
+
+                yield return new GraphCacheResponse(
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {2}}
+                    },
+                    new Dictionary<int, CacheResult>
+                    {
+                        {1, GraphCacheResponse.SuccessfulProxyTargetResult()},
+                        {2, GraphCacheResponse.SuccessfulTargetResult(2, "2.proj")}
+                    });
+
+                yield return new GraphCacheResponse(
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {2, 3, 7}},
+                        {2, new[] {4}},
+                        {3, new[] {4}},
+                        {4, new[] {5, 6, 7}}
+                    });
+            }
+        }
+
+        public static IEnumerable<object[]> MultiProcWithAndWithoutInProcNode
+        {
+            get
+            {
+                yield return new object[]
+                {
+                    new BuildParameters
+                    {
+                        DisableInProcNode = false,
+                        MaxNodeCount = Environment.ProcessorCount
+                    }
+                };
+
+                yield return new object[]
+                {
+                    new BuildParameters
+                    {
+                        DisableInProcNode = true,
+                        MaxNodeCount = Environment.ProcessorCount
+                    }
+                };
+            }
+        }
+
+        public static IEnumerable<object[]> SuccessfulGraphsWithBuildParameters
+        {
+            get
+            {
+                foreach (var graph in SuccessfulGraphs)
+                {
+                    foreach (var buildParameters in MultiProcWithAndWithoutInProcNode)
+                    {
+                        yield return new object[]
+                        {
+                            graph,
+                            ((BuildParameters) buildParameters.First()).Clone()
+                        };
+                    }
+                }
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(SuccessfulGraphsWithBuildParameters))]
+        public void ProjectCacheByBuildParametersAndGraphBuildWorks(GraphCacheResponse testData, BuildParameters buildParameters)
+        {
+            _output.WriteLine(testData.ToString());
+            var graph = testData.CreateGraph(_env);
+            var mockCache = new InstanceMockCache(testData);
+
+            buildParameters.ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
+                mockCache,
+                null,
+                graph);
+
+            using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
+
+            var graphResult = buildSession.BuildGraph(graph);
+
+            graphResult.OverallResult.ShouldBe(BuildResultCode.Success);
+
+            buildSession.Dispose();
+
+            buildSession.Logger.FullLog.ShouldContain("Static graph based");
+
+            AssertCacheBuild(graph, testData, mockCache, buildSession.Logger, graphResult.ResultsByNode);
+        }
+
+        [Theory]
+        [MemberData(nameof(SuccessfulGraphsWithBuildParameters))]
+        public void ProjectCacheByBuildParametersAndBottomUpBuildWorks(GraphCacheResponse testData, BuildParameters buildParameters)
+        {
+            var graph = testData.CreateGraph(_env);
+            var mockCache = new InstanceMockCache(testData);
+
+            buildParameters.ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
+                mockCache,
+                null,
+                graph);
+
+            using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
+            var nodesToBuildResults = new Dictionary<ProjectGraphNode, BuildResult>();
+
+            foreach (var node in graph.ProjectNodesTopologicallySorted)
+            {
+                var buildResult = buildSession.BuildProjectFile(node.ProjectInstance.FullPath);
+                buildResult.OverallResult.ShouldBe(BuildResultCode.Success);
+
+                nodesToBuildResults[node] = buildResult;
+            }
+
+            buildSession.Dispose();
+
+            buildSession.Logger.FullLog.ShouldContain("Static graph based");
+
+            AssertCacheBuild(graph, testData, mockCache, buildSession.Logger, nodesToBuildResults);
+        }
+
+        [Theory]
+        [MemberData(nameof(SuccessfulGraphsWithBuildParameters))]
+        public void ProjectCacheByVSWorkaroundWorks(GraphCacheResponse testData, BuildParameters buildParameters)
+        {
+            var currentBuildEnvironment = BuildEnvironmentHelper.Instance;
+
+            try
+            {
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly(
+                    new BuildEnvironment(
+                        currentBuildEnvironment.Mode,
+                        currentBuildEnvironment.CurrentMSBuildExePath,
+                        currentBuildEnvironment.RunningTests,
+                        true,
+                        currentBuildEnvironment.VisualStudioInstallRootDirectory));
+
+                BuildManager.ProjectCacheItems.ShouldBeEmpty();
+
+                var graph = testData.CreateGraph(_env);
+
+                BuildManager.ProjectCacheItems.ShouldHaveSingleItem();
+
+                using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
+                var nodesToBuildResults = new Dictionary<ProjectGraphNode, BuildResult>();
+
+                foreach (var node in graph.ProjectNodesTopologicallySorted)
+                {
+                    var buildResult = buildSession.BuildProjectFile(
+                        node.ProjectInstance.FullPath,
+                        globalProperties:
+                            new Dictionary<string, string> {{"SolutionPath", graph.GraphRoots.First().ProjectInstance.FullPath}});
+                    buildResult.OverallResult.ShouldBe(BuildResultCode.Success);
+
+                    nodesToBuildResults[node] = buildResult;
+                }
+
+                buildSession.Logger.FullLog.ShouldContain("Graph entrypoint based");
+
+                AssertCacheBuild(graph, testData, null, buildSession.Logger, nodesToBuildResults);
+            }
+            finally
+            {
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly(currentBuildEnvironment);
+                BuildManager.ProjectCacheItems.Clear();
+            }
+        }
+
+        private void AssertCacheBuild(
+            ProjectGraph graph,
+            GraphCacheResponse testData,
+            InstanceMockCache? instanceMockCache,
+            MockLogger mockLogger,
+            IReadOnlyDictionary<ProjectGraphNode, BuildResult> projectPathToBuildResults)
+        {
+            if (instanceMockCache != null)
+            {
+                mockLogger.FullLog.ShouldContain("MockCache: BeginBuildAsync");
+                mockLogger.FullLog.ShouldContain("Instance based");
+                mockLogger.FullLog.ShouldNotContain("Assembly path based");
+
+                instanceMockCache.Requests.Count.ShouldBe(graph.ProjectNodes.Count);
+            }
+            else
+            {
+                mockLogger.FullLog.ShouldContain($"{AssemblyMockCache}: BeginBuildAsync");
+                mockLogger.FullLog.ShouldContain("Assembly path based");
+                mockLogger.FullLog.ShouldNotContain("Instance based");
+
+                Regex.Matches(mockLogger.FullLog, $"{AssemblyMockCache}: GetCacheResultAsync for").Count.ShouldBe(graph.ProjectNodes.Count);
+            }
+
+            foreach (var node in graph.ProjectNodes)
+            {
+                var expectedCacheResponse = testData.GetExpectedCacheResultForNode(node);
+
+                mockLogger.FullLog.ShouldContain($"====== Querying project cache for project {node.ProjectInstance.FullPath}");
+
+                if (instanceMockCache != null)
+                {
+                    instanceMockCache.Requests.ShouldContain(r => r.ProjectFullPath.Equals(node.ProjectInstance.FullPath));
+                    instanceMockCache.BeginBuildCalled.ShouldBeTrue();
+                    instanceMockCache.EndBuildCalled.ShouldBeTrue();
+                }
+                else
+                {
+                    mockLogger.FullLog.ShouldContain($"{AssemblyMockCache}: GetCacheResultAsync for {node.ProjectInstance.FullPath}");
+                }
+
+                if (instanceMockCache == null)
+                {
+                    // Too complicated, not worth it to send expected results to the assembly plugin, so skip checking the build results.
+                    continue;
+                }
+
+                switch (expectedCacheResponse.ResultType)
+                {
+                    case CacheResultType.CacheHit:
+                        AssertBuildResultForCacheHit(node.ProjectInstance.FullPath, projectPathToBuildResults[node], expectedCacheResponse);
+                        break;
+                    case CacheResultType.CacheMiss:
+                        break;
+                    case CacheResultType.CacheNotApplicable:
+                        break;
+                    case CacheResultType.None:
+                        break;
+                    default:
+                        throw new ArgumentOutOfRangeException();
+                }
+            }
+        }
+
+        private static int GetProjectNumber(ProjectGraphNode node)
+        {
+            return GetProjectNumber(node.ProjectInstance.FullPath);
+        }
+
+        private static int GetProjectNumber(string projectPath)
+        {
+            return int.Parse(Path.GetFileNameWithoutExtension(projectPath));
+        }
+
+        private void AssertBuildResultForCacheHit(
+            string projectPath,
+            BuildResult buildResult,
+            CacheResult expectedCacheResponse)
+        {
+            // If the cache hit is via proxy targets then the build result should contain entry for both the real target
+            // and the proxy target. Both target results should be the same.
+            // If it's not a cache result by proxy targets then the cache constructed the target results by hand and only the real target result
+            // exists in the BuildResult.
+
+            var targetResult = buildResult.ResultsByTarget["Build"];
+
+            targetResult.Items.ShouldHaveSingleItem();
+            var itemResult = targetResult.Items.First();
+            string expectedMetadata;
+
+            if (expectedCacheResponse.ProxyTargets != null)
+            {
+                var proxyTargetResult = buildResult.ResultsByTarget["ProxyBuild"];
+                SdkUtilities.EngineHelpers.AssertTargetResultsEqual(targetResult, proxyTargetResult);
+
+                expectedMetadata = GraphCacheResponse.CacheHitByProxy;
+            }
+            else
+            {
+                expectedMetadata = GraphCacheResponse.CacheHitByTargetResult;
+            }
+
+            itemResult.ItemSpec.ShouldBe(GetProjectNumber(projectPath).ToString());
+            itemResult.GetMetadata("File").ShouldBe(Path.GetFileName(projectPath));
+            itemResult.GetMetadata(expectedMetadata).ShouldBe("true");
+        }
+
+        [Theory]
+        [MemberData(nameof(MultiProcWithAndWithoutInProcNode))]
+        public void CacheShouldNotGetQueriedForNestedBuildRequests(BuildParameters buildParameters)
+        {
+            var project1 = _env.CreateFile("1.proj", @"
+                    <Project>
+                        <Target Name=`Build`>
+                            <MSBuild Projects=`2.proj` />
+                        </Target>
+                    </Project>".Cleanup());
+
+            _env.CreateFile("2.proj", @"
+                    <Project>
+                        <Target Name=`Build`>
+                            <Message Text=`Hello` Importance=`High` />
+                        </Target>
+                    </Project>".Cleanup());
+
+            var mockCache = new InstanceMockCache();
+            buildParameters.ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
+                mockCache,
+                new[] {new ProjectGraphEntryPoint(project1.Path)},
+                null);
+
+            using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
+
+            var buildResult = buildSession.BuildProjectFile(project1.Path);
+
+            buildResult.OverallResult.ShouldBe(BuildResultCode.Success);
+
+            buildSession.Logger.ProjectStartedEvents.Count.ShouldBe(2);
+
+            mockCache.Requests.Count.ShouldBe(1);
+            mockCache.Requests.First().ProjectFullPath.ShouldEndWith("1.proj");
+        }
+
+        [Fact]
+        public void CacheViaBuildParametersCanDiscoverAndLoadPluginFromAssembly()
+        {
+            var testData = new GraphCacheResponse(
+                new Dictionary<int, int[]>
+                {
+                    {1, new[] {2, 3}}
+                }
+                );
+
+            var graph = testData.CreateGraph(_env);
+
+            using var buildSession = new Helpers.BuildManagerSession(
+                _env,
+                new BuildParameters
+                {
+                    ProjectCacheDescriptor = ProjectCacheDescriptor.FromAssemblyPath(
+                        SamplePluginAssemblyPath.Value,
+                        graph.EntryPointNodes.Select(n => new ProjectGraphEntryPoint(n.ProjectInstance.FullPath)).ToArray(),
+                        null)
+                });
+
+            var graphResult = buildSession.BuildGraph(graph);
+
+            graphResult.OverallResult.ShouldBe(BuildResultCode.Success);
+
+            buildSession.Logger.FullLog.ShouldContain("Graph entrypoint based");
+
+            AssertCacheBuild(graph, testData, null, buildSession.Logger, graphResult.ResultsByNode);
+        }
+
+        [Fact]
+        public void GraphBuildCanDiscoverAndLoadPluginFromAssembly()
+        {
+            var testData = new GraphCacheResponse(
+                new Dictionary<int, int[]>
+                {
+                    {1, new[] {2, 3}}
+                }
+                );
+
+            var graph = testData.CreateGraph(_env);
+
+            using var buildSession = new Helpers.BuildManagerSession(_env);
+
+            var graphResult = buildSession.BuildGraph(graph);
+
+            graphResult.OverallResult.ShouldBe(BuildResultCode.Success);
+
+            buildSession.Logger.FullLog.ShouldContain("Static graph based");
+
+            AssertCacheBuild(graph, testData, null, buildSession.Logger, graphResult.ResultsByNode);
+        }
+
+        [Fact]
+        public void BuildFailsWhenCacheBuildResultIsWrong()
+        {
+            var testData = new GraphCacheResponse(
+                new Dictionary<int, int[]>
+                {
+                    {1, new[] {2}}
+                },
+                new Dictionary<int, CacheResult>
+                {
+                    {
+                        2, CacheResult.IndicateCacheHit(
+                            new[]
+                            {
+                                new PluginTargetResult(
+                                    "Build",
+                                    new ITaskItem2[]
+                                    {
+                                        new TaskItem(
+                                            "NA",
+                                            new Dictionary<string, string>
+                                            {
+                                                {"File", "Invalid file"}
+                                            })
+                                    },
+                                    BuildResultCode.Success
+                                    )
+                            })
+                    }
+                }
+                );
+
+            var graph = testData.CreateGraph(_env);
+            var mockCache = new InstanceMockCache(testData);
+
+            using var buildSession = new Helpers.BuildManagerSession(
+                _env,
+                new BuildParameters
+                {
+                    ProjectCacheDescriptor =
+                        ProjectCacheDescriptor.FromInstance(mockCache, null, graph)
+                });
+
+            var buildResult = buildSession.BuildGraph(graph);
+
+            mockCache.Requests.Count.ShouldBe(2);
+
+            buildResult.ResultsByNode.First(r => GetProjectNumber(r.Key) == 2).Value.OverallResult.ShouldBe(BuildResultCode.Success);
+            buildResult.ResultsByNode.First(r => GetProjectNumber(r.Key) == 1).Value.OverallResult.ShouldBe(BuildResultCode.Failure);
+
+            buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
+
+            buildSession.Logger.FullLog.ShouldContain("Reference file [Invalid file] does not exist");
+        }
+
+        [Fact]
+        public void GraphBuildErrorsIfMultiplePluginsAreFound()
+        {
+            _env.DoNotLaunchDebugger();
+
+            var graph = Helpers.CreateProjectGraph(
+                _env,
+                new Dictionary<int, int[]>
+                {
+                    {1, new[] {2}}
+                },
+                extraContentPerProjectNumber: null,
+                extraContentForAllNodes: @$"
+<ItemGroup>
+   <{ItemTypeNames.ProjectCachePlugin} Include='Plugin$(MSBuildProjectName)' />
+</ItemGroup>
+");
+
+            using var buildSession = new Helpers.BuildManagerSession(_env);
+
+            var graphResult = buildSession.BuildGraph(graph);
+
+            graphResult.OverallResult.ShouldBe(BuildResultCode.Failure);
+            graphResult.Exception.Message.ShouldContain("A single project cache plugin must be specified but multiple where found:");
+        }
+
+        [Fact]
+        public void GraphBuildErrorsIfNotAllNodeDefineAPlugin()
+        {
+            _env.DoNotLaunchDebugger();
+
+            var graph = Helpers.CreateProjectGraph(
+                _env,
+                dependencyEdges: new Dictionary<int, int[]>
+                {
+                    {1, new[] {2}}
+                },
+                extraContentPerProjectNumber: new Dictionary<int, string>
+                {
+                    {
+                        2,
+                        @$"
+<ItemGroup>
+   <{ItemTypeNames.ProjectCachePlugin} Include='Plugin$(MSBuildProjectName)' />
+</ItemGroup>
+"
+                    }
+                });
+
+            using var buildSession = new Helpers.BuildManagerSession(_env);
+
+            var graphResult = buildSession.BuildGraph(graph);
+
+            graphResult.OverallResult.ShouldBe(BuildResultCode.Failure);
+            graphResult.Exception.Message.ShouldContain("When any static graph node defines a project cache, all nodes must define the same project cache.");
+        }
+
+        public static IEnumerable<object[]> CacheExceptionLocationsTestData
+        {
+            get
+            {
+                yield return new object[]{ExceptionLocations.Constructor};
+
+                yield return new object[]{ExceptionLocations.BeginBuildAsync};
+                yield return new object[]{ExceptionLocations.BeginBuildAsync | ExceptionLocations.GetCacheResultAsync};
+                yield return new object[]{ExceptionLocations.BeginBuildAsync | ExceptionLocations.GetCacheResultAsync | ExceptionLocations.EndBuildAsync};
+                yield return new object[]{ExceptionLocations.BeginBuildAsync | ExceptionLocations.EndBuildAsync};
+
+                yield return new object[]{ExceptionLocations.GetCacheResultAsync};
+                yield return new object[]{ExceptionLocations.GetCacheResultAsync | ExceptionLocations.EndBuildAsync};
+
+                yield return new object[]{ExceptionLocations.EndBuildAsync};
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(CacheExceptionLocationsTestData))]
+        public void EngineShouldHandleExceptionsFromCachePlugin(ExceptionLocations exceptionLocations)
+        {
+            _env.DoNotLaunchDebugger();
+
+            var project = _env.CreateFile("1.proj", @$"
+                    <Project>
+                        <Target Name=`Build`>
+                            <Message Text=`Hello EngineShouldHandleExceptionsFromCachePlugin` Importance=`High` />
+                        </Target>
+                    </Project>".Cleanup());
+
+            foreach (var enumValue in Enum.GetValues(typeof(ExceptionLocations)))
+            {
+                var typedValue = (ExceptionLocations) enumValue;
+                if (exceptionLocations.HasFlag(typedValue))
+                {
+                    var exceptionLocation = typedValue.ToString();
+                    _env.SetEnvironmentVariable(exceptionLocation, "1");
+                    _output.WriteLine($"Set exception location: {exceptionLocation}");
+                }
+            }
+
+            using var buildSession = new Helpers.BuildManagerSession(
+                _env,
+                new BuildParameters
+                {
+                    UseSynchronousLogging = true,
+                    ProjectCacheDescriptor = ProjectCacheDescriptor.FromAssemblyPath(
+                        SamplePluginAssemblyPath.Value,
+                        new[] {new ProjectGraphEntryPoint(project.Path)},
+                        null)
+                });
+
+            var logger = buildSession.Logger;
+            var buildResult = buildSession.BuildProjectFile(project.Path);
+
+            if (exceptionLocations == ExceptionLocations.EndBuildAsync || exceptionLocations == (ExceptionLocations.GetCacheResultAsync
+                                                                                                 | ExceptionLocations.EndBuildAsync))
+            {
+                var e = Should.Throw<Exception>(() => buildSession.Dispose());
+                e.Message.ShouldContain("Cache plugin exception from EndBuildAsync");
+            }
+            else
+            {
+                buildSession.Dispose();
+            }
+
+            var exceptionsThatEndUpInBuildResult = ExceptionLocations.Constructor | ExceptionLocations.BeginBuildAsync | ExceptionLocations.GetCacheResultAsync;
+
+            if ((exceptionsThatEndUpInBuildResult & exceptionLocations) != 0)
+            {
+                buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
+                buildResult.Exception.Message.ShouldContain("Cache plugin exception from");
+            }
+
+            if (exceptionLocations == ExceptionLocations.EndBuildAsync)
+            {
+                buildResult.OverallResult.ShouldBe(BuildResultCode.Success);
+            }
+
+            var exceptionsThatShouldPreventCacheQueryAndEndBuildAsync = ExceptionLocations.Constructor | ExceptionLocations.BeginBuildAsync;
+
+            if ((exceptionsThatShouldPreventCacheQueryAndEndBuildAsync & exceptionLocations) != 0)
+            {
+                logger.FullLog.ShouldNotContain($"{AssemblyMockCache}: GetCacheResultAsync for");
+                logger.FullLog.ShouldNotContain($"{AssemblyMockCache}: EndBuildAsync");
+            }
+            else
+            {
+                logger.FullLog.ShouldContain($"{AssemblyMockCache}: GetCacheResultAsync for");
+                logger.FullLog.ShouldContain($"{AssemblyMockCache}: EndBuildAsync");
+            }
+        }
+    }
+}
diff --git a/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs b/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs
index 57924761e84..93c1af36e9d 100644
--- a/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs
+++ b/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs
@@ -1,4 +1,4 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
@@ -26,7 +26,7 @@ public class ProjectEvaluationFinishedEventArgs_Tests
         public void ProfilerResultRoundTrip(ProfilerResult profilerResult)
         {
             var writeTranslator = TranslationHelpers.GetWriteTranslator();
-            ProfilerResult deserializedResult;
+            ProfilerResult deserializedResult = default;
 
             writeTranslator.TranslateDotNet(ref profilerResult);
 
diff --git a/src/Build.UnitTests/Scanner_Tests.cs b/src/Build.UnitTests/Scanner_Tests.cs
index 7843e239d6c..869a90027cf 100644
--- a/src/Build.UnitTests/Scanner_Tests.cs
+++ b/src/Build.UnitTests/Scanner_Tests.cs
@@ -5,6 +5,7 @@
 
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
+using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
@@ -133,7 +134,9 @@ public void SpaceInMiddleOfProperty(string pattern)
         public void SpacePropertyOptOutWave16_10()
         {
             using TestEnvironment env = TestEnvironment.Create();
-            env.SetChangeWave(ChangeWaves.Wave16_10);
+            ChangeWaves.ResetStateForTests();
+            env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave16_10.ToString());
+            BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
 
             Scanner lexer = new Scanner("$(x )", ParserOptions.AllowProperties);
             AdvanceToScannerError(lexer);
@@ -142,6 +145,7 @@ public void SpacePropertyOptOutWave16_10()
             lexer = new Scanner("$( x)", ParserOptions.AllowProperties);
             AdvanceToScannerError(lexer);
             Assert.Null(lexer.UnexpectedlyFound);
+            ChangeWaves.ResetStateForTests();
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/TaskItemComparer.cs b/src/Build.UnitTests/TestComparers/TaskItemComparer.cs
similarity index 97%
rename from src/Build.UnitTests/BackEnd/TaskItemComparer.cs
rename to src/Build.UnitTests/TestComparers/TaskItemComparer.cs
index 61e423692eb..cc089195da3 100644
--- a/src/Build.UnitTests/BackEnd/TaskItemComparer.cs
+++ b/src/Build.UnitTests/TestComparers/TaskItemComparer.cs
@@ -5,7 +5,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-namespace Microsoft.Build.UnitTests.BackEnd
+namespace Microsoft.Build.Engine.UnitTests.TestComparers
 {
     /// <summary>
     /// Implementation of IComparer on ITaskItems used for testing.
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 72d7b1e9c51..e071160c912 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.Collections.ObjectModel;
@@ -18,17 +19,23 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
+using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
 
+using Microsoft.NET.StringTools;
+
 namespace Microsoft.Build.Execution
 {
     /// <summary>
@@ -37,6 +44,9 @@ namespace Microsoft.Build.Execution
     [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Refactoring at the end of Beta1 is not appropriate.")]
     public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
     {
+        // TODO: Remove this when VS gets updated to setup project cache plugins.
+        internal static ConcurrentDictionary<string, ProjectCacheItem> ProjectCacheItems { get; } = new ConcurrentDictionary<string, ProjectCacheItem>();
+
         /// <summary>
         /// The object used for thread-safe synchronization of static members.
         /// </summary>
@@ -233,6 +243,8 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         private DateTime _instantiationTimeUtc;
 
         private IEnumerable<DeferredBuildMessage> _deferredBuildMessages;
+        private Task<ProjectCacheService> _projectCacheService;
+        private bool _projectCacheServiceInstantiatedByVSWorkaround;
 
 #if DEBUG
         /// <summary>
@@ -405,7 +417,7 @@ public void BeginBuild(BuildParameters parameters)
 
                 if (BuildParameters.DumpOpportunisticInternStats)
                 {
-                    OpportunisticIntern.Instance.EnableStatisticsGathering();
+                    Strings.EnableDiagnostics();
                 }
 
                 _overallBuildSuccess = true;
@@ -435,6 +447,12 @@ public void BeginBuild(BuildParameters parameters)
 
                 InitializeCaches();
 
+                if (_buildParameters.ProjectCacheDescriptor != null)
+                {
+                    // TODO: Implement cancellation.
+                    InitializeProjectCacheService(_buildParameters.ProjectCacheDescriptor, CancellationToken.None);
+                }
+
                 _taskHostNodeManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.TaskHostNodeManager) as INodeManager;
                 _scheduler = ((IBuildComponentHost)this).GetComponent(BuildComponentType.Scheduler) as IScheduler;
 
@@ -539,6 +557,24 @@ void InitializeCaches()
             }
         }
 
+        private void InitializeProjectCacheService(
+            ProjectCacheDescriptor pluginDescriptor,
+            CancellationToken cancellationToken)
+        {
+            if (_projectCacheService != null)
+            {
+                ErrorUtilities.ThrowInternalError("Only one project cache plugin may be set on the BuildManager during a begin / end build session");
+            }
+
+            LogMessage(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("LoadingProjectCachePlugin", pluginDescriptor.GetDetailedDescription()));
+
+            _projectCacheService = ProjectCacheService.FromDescriptorAsync(
+                pluginDescriptor,
+                this,
+                ((IBuildComponentHost) this).LoggingService,
+                cancellationToken);
+        }
+
         /// <summary>
         /// Cancels all outstanding submissions asynchronously.
         /// </summary>
@@ -693,8 +729,6 @@ public BuildResult BuildRequest(BuildRequestData requestData)
             BuildSubmission submission = PendBuildRequest(requestData);
             BuildResult result = submission.Execute();
 
-            SetOverallResultIfWarningsAsErrors(result);
-
             return result;
         }
 
@@ -751,6 +785,8 @@ public void EndBuild()
                 // Stop the graph scheduling thread(s)
                 _graphSchedulingCancellationSource?.Cancel();
 
+                var projectCacheShutdown = _projectCacheService?.Result.ShutDown();
+
                 ErrorUtilities.VerifyThrow(_buildSubmissions.Count == 0 && _graphBuildSubmissions.Count == 0, "All submissions not yet complete.");
                 ErrorUtilities.VerifyThrow(_activeNodes.Count == 0, "All nodes not yet shut down.");
 
@@ -759,6 +795,8 @@ public void EndBuild()
                     SerializeCaches();
                 }
 
+                projectCacheShutdown?.Wait();
+
                 if (loggingService != null)
                 {
                     // Override the build success if the user specified /warnaserror and any errors were logged outside of a build submission.
@@ -800,6 +838,10 @@ public void EndBuild()
                     _resultsCache.ClearResults();
                 }
             }
+            catch (AggregateException ae) when (ae.InnerExceptions.Count == 1)
+            {
+                throw ae.InnerExceptions.First();
+            }
             finally
             {
                 try
@@ -820,7 +862,7 @@ public void EndBuild()
 
                     if (BuildParameters.DumpOpportunisticInternStats)
                     {
-                        OpportunisticIntern.Instance.ReportStatistics();
+                        Console.WriteLine(Strings.CreateDiagnosticReport());
                     }
                 }
             }
@@ -962,119 +1004,316 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread
             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));
             ErrorUtilities.VerifyThrow(!submission.IsCompleted, "Submission already complete.");
 
-            lock (_syncLock)
+            bool thisMethodIsAsync = false;
+
+            if (ProjectCacheIsPresent())
+            {
+                thisMethodIsAsync = true;
+
+                // Potential long running operations:
+                //  - submission may need evaluation
+                //  - project cache may need initializing
+                //  - project cache will be queried
+                // Use separate thread to unblock calling thread.
+                Task.Factory.StartNew(
+                    ExecuteSubmissionImpl,
+                    CancellationToken.None,
+                    TaskCreationOptions.LongRunning,
+                    TaskScheduler.Default
+                );
+            }
+            else
             {
-                ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;
-                if (projectInstance != null)
+                ExecuteSubmissionImpl();
+            }
+
+            void ExecuteSubmissionImpl()
+            {
+                lock (_syncLock)
                 {
-                    if (_acquiredProjectRootElementCacheFromProjectInstance)
+                    ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;
+                    if (projectInstance != null)
                     {
-                        ErrorUtilities.VerifyThrowArgument(
-                            _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,
-                            "OM_BuildSubmissionsMultipleProjectCollections");
+                        if (_acquiredProjectRootElementCacheFromProjectInstance)
+                        {
+                            ErrorUtilities.VerifyThrowArgument(
+                                _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,
+                                "OM_BuildSubmissionsMultipleProjectCollections");
+                        }
+                        else
+                        {
+                            _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;
+                            _acquiredProjectRootElementCacheFromProjectInstance = true;
+                        }
                     }
-                    else
+                    else if (_buildParameters.ProjectRootElementCache == null)
                     {
-                        _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;
-                        _acquiredProjectRootElementCacheFromProjectInstance = true;
+                        // Create our own cache; if we subsequently get a build submission with a project instance attached,
+                        // we'll dump our cache and use that one.
+                        _buildParameters.ProjectRootElementCache =
+                            new ProjectRootElementCache(false /* do not automatically reload from disk */);
                     }
-                }
-                else if (_buildParameters.ProjectRootElementCache == null)
-                {
-                    // Create our own cache; if we subsequently get a build submission with a project instance attached,
-                    // we'll dump our cache and use that one.
-                    _buildParameters.ProjectRootElementCache =
-                        new ProjectRootElementCache(false /* do not automatically reload from disk */);
-                }
 
-                VerifyStateInternal(BuildManagerState.Building);
+                    VerifyStateInternal(BuildManagerState.Building);
 
-                try
-                {
-                    // If we have an unnamed project, assign it a temporary name.
-                    if (String.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))
+                    try
                     {
-                        ErrorUtilities.VerifyThrow(submission.BuildRequestData.ProjectInstance != null,
-                            "Unexpected null path for a submission with no ProjectInstance.");
-
-                        // If we have already named this instance when it was submitted previously during this build, use the same
-                        // name so that we get the same configuration (and thus don't cause it to rebuild.)
-                        if (!_unnamedProjectInstanceToNames.TryGetValue(submission.BuildRequestData.ProjectInstance,
-                            out string tempName))
+                        // If we have an unnamed project, assign it a temporary name.
+                        if (string.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))
                         {
-                            tempName = "Unnamed_" + _nextUnnamedProjectId++;
-                            _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;
+                            ErrorUtilities.VerifyThrow(
+                                submission.BuildRequestData.ProjectInstance != null,
+                                "Unexpected null path for a submission with no ProjectInstance.");
+
+                            // If we have already named this instance when it was submitted previously during this build, use the same
+                            // name so that we get the same configuration (and thus don't cause it to rebuild.)
+                            if (!_unnamedProjectInstanceToNames.TryGetValue(submission.BuildRequestData.ProjectInstance, out var tempName))
+                            {
+                                tempName = "Unnamed_" + _nextUnnamedProjectId++;
+                                _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;
+                            }
+
+                            submission.BuildRequestData.ProjectFullPath = Path.Combine(
+                                submission.BuildRequestData.ProjectInstance.GetProperty(ReservedPropertyNames.projectDirectory).EvaluatedValue,
+                                tempName);
                         }
 
-                        submission.BuildRequestData.ProjectFullPath = Path.Combine(
-                            submission.BuildRequestData.ProjectInstance
-                                .GetProperty(ReservedPropertyNames.projectDirectory).EvaluatedValue, tempName);
-                    }
+                        // Create/Retrieve a configuration for each request
+                        var buildRequestConfiguration = new BuildRequestConfiguration(submission.BuildRequestData, _buildParameters.DefaultToolsVersion);
+                        var matchingConfiguration = _configCache.GetMatchingConfiguration(buildRequestConfiguration);
+                        var newConfiguration = ResolveConfiguration(
+                            buildRequestConfiguration,
+                            matchingConfiguration,
+                            submission.BuildRequestData.Flags.HasFlag(BuildRequestDataFlags.ReplaceExistingProjectInstance));
 
-                    // Create/Retrieve a configuration for each request
-                    BuildRequestConfiguration buildRequestConfiguration =
-                        new BuildRequestConfiguration(submission.BuildRequestData,
-                            _buildParameters.DefaultToolsVersion);
-                    BuildRequestConfiguration matchingConfiguration =
-                        _configCache.GetMatchingConfiguration(buildRequestConfiguration);
-                    BuildRequestConfiguration newConfiguration = ResolveConfiguration(buildRequestConfiguration,
-                        matchingConfiguration,
-                        submission.BuildRequestData.Flags.HasFlag(BuildRequestDataFlags
-                            .ReplaceExistingProjectInstance));
-
-                    newConfiguration.ExplicitlyLoaded = true;
-
-                    // Now create the build request
-                    submission.BuildRequest = new BuildRequest(
-                        submission.SubmissionId,
-                        BackEnd.BuildRequest.InvalidNodeRequestId,
-                        newConfiguration.ConfigurationId,
-                        submission.BuildRequestData.TargetNames,
-                        submission.BuildRequestData.HostServices,
-                        BuildEventContext.Invalid,
-                        null,
-                        submission.BuildRequestData.Flags,
-                        submission.BuildRequestData.RequestedProjectState);
+                        newConfiguration.ExplicitlyLoaded = true;
 
-                    if (_shuttingDown)
-                    {
-                        // We were already canceled!
-                        BuildResult result = new BuildResult(submission.BuildRequest, new BuildAbortedException());
-                        submission.CompleteResults(result);
-                        submission.CompleteLogging(true);
-                        CheckSubmissionCompletenessAndRemove(submission);
-                        return;
-                    }
+                        submission.BuildRequest = CreateRealBuildRequest(submission, newConfiguration.ConfigurationId);
 
-                    // Submit the build request.
-                    _workQueue.Post(() =>
-                    {
-                        try
+                        // TODO: Remove this when VS gets updated to setup project cache plugins.
+                        AutomaticallyDetectAndInstantiateProjectCacheServiceForVisualStudio(submission, newConfiguration);
+
+                        CacheResult cacheResult = null;
+                        if (_projectCacheService != null)
                         {
-                            IssueBuildSubmissionToScheduler(submission, allowMainThreadBuild);
+                            cacheResult = QueryCache(submission, newConfiguration);
                         }
-                        catch (BuildAbortedException bae)
+
+                        if (cacheResult == null || cacheResult.ResultType != CacheResultType.CacheHit)
                         {
-                            // We were canceled before we got issued by the work queue.
-                            var result = new BuildResult(submission.BuildRequest, bae);
-                            submission.CompleteResults(result);
-                            submission.CompleteLogging(true);
-                            CheckSubmissionCompletenessAndRemove(submission);
+                            // Issue the real build request.
+                            SubmitBuildRequest();
+                        }
+                        else if (cacheResult?.ResultType == CacheResultType.CacheHit && cacheResult.ProxyTargets != null)
+                        {
+                            // Setup submission.BuildRequest with proxy targets. The proxy request is built on the inproc node (to avoid ProjectInstance serialization).
+                            // The proxy target results are used as results for the real targets.
+
+                            submission.BuildRequest = CreateProxyBuildRequest(
+                                submission,
+                                newConfiguration.ConfigurationId,
+                                cacheResult.ProxyTargets);
+
+                            SubmitBuildRequest();
                         }
-                        catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
+                        else if (cacheResult?.ResultType == CacheResultType.CacheHit && cacheResult.BuildResult != null)
                         {
-                            HandleExecuteSubmissionException(submission, ex);
+                            // Mark the build submission as complete with the provided results and return.
+                            var result = new BuildResult(submission.BuildRequest);
+
+                            foreach (var targetResult in cacheResult.BuildResult.ResultsByTarget)
+                            {
+                                result.AddResultsForTarget(targetResult.Key, targetResult.Value);
+                            }
+
+                            _resultsCache.AddResult(result);
+                            submission.CompleteLogging(false);
+                            ReportResultsToSubmission(result);
+                        }
+                    }
+                    catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
+                    {
+                        HandleExecuteSubmissionException(submission, ex);
+                        throw;
+                    }
+                    catch (Exception ex) when (thisMethodIsAsync)
+                    {
+                        OnThreadException(ex);
+                    }
+                    void SubmitBuildRequest()
+                    {
+                        if (CheckForShutdown())
+                        {
+                            return;
                         }
-                    });
+
+                        _workQueue.Post(
+                            () =>
+                            {
+                                try
+                                {
+                                    IssueBuildSubmissionToScheduler(submission, allowMainThreadBuild);
+                                }
+                                catch (BuildAbortedException bae)
+                                {
+                                    // We were canceled before we got issued by the work queue.
+                                    var result = new BuildResult(submission.BuildRequest, bae);
+                                    submission.CompleteResults(result);
+                                    submission.CompleteLogging(true);
+                                    CheckSubmissionCompletenessAndRemove(submission);
+                                }
+                                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
+                                {
+                                    HandleExecuteSubmissionException(submission, ex);
+                                }
+                            });
+                    }
                 }
-                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
+            }
+
+            bool ProjectCacheIsPresent()
+            {
+                return _projectCacheService != null ||
+                       _buildParameters.ProjectCacheDescriptor != null ||
+                       (BuildEnvironmentHelper.Instance.RunningInVisualStudio && ProjectCacheItems.Count > 0);
+            }
+
+            bool CheckForShutdown()
+            {
+                if (!_shuttingDown)
                 {
-                    HandleExecuteSubmissionException(submission, ex);
+                    return false;
+                }
+
+                // We were already canceled!
+                var result = new BuildResult(submission.BuildRequest, new BuildAbortedException());
+                submission.CompleteResults(result);
+                submission.CompleteLogging(true);
+                CheckSubmissionCompletenessAndRemove(submission);
+
+                return true;
+            }
+
+            CacheResult QueryCache(BuildSubmission buildSubmission, BuildRequestConfiguration newConfiguration)
+            {
+                ProjectCacheService cacheService = null;
+
+                try
+                {
+                    cacheService = _projectCacheService.Result;
+                }
+                catch
+                {
+                    // Set to null so that EndBuild does not try to shut it down and thus rethrow the exception.
+                    _projectCacheService = null;
                     throw;
                 }
+
+                // Project cache plugins require an evaluated project. Evaluate the submission if it's by path.
+                LoadSubmissionProjectIntoConfiguration(buildSubmission, newConfiguration);
+
+                var cacheResult = cacheService.GetCacheResultAsync(
+                        new BuildRequestData(
+                            newConfiguration.Project,
+                            buildSubmission.BuildRequestData.TargetNames.ToArray()))
+                    .GetAwaiter()
+                    .GetResult();
+
+                return cacheResult;
+            }
+
+            static BuildRequest CreateRealBuildRequest(BuildSubmission submission, int configurationId)
+            {
+                return new BuildRequest(
+                    submission.SubmissionId,
+                    BackEnd.BuildRequest.InvalidNodeRequestId,
+                    configurationId,
+                    submission.BuildRequestData.TargetNames,
+                    submission.BuildRequestData.HostServices,
+                    BuildEventContext.Invalid,
+                    null,
+                    submission.BuildRequestData.Flags,
+                    submission.BuildRequestData.RequestedProjectState);
+            }
+
+            static BuildRequest CreateProxyBuildRequest(
+                BuildSubmission submission,
+                int configurationId,
+                ProxyTargets proxyTargets)
+            {
+                return new BuildRequest(
+                    submission.SubmissionId,
+                    BackEnd.BuildRequest.InvalidNodeRequestId,
+                    configurationId,
+                    proxyTargets,
+                    submission.BuildRequestData.HostServices,
+                    submission.BuildRequestData.Flags,
+                    submission.BuildRequestData.RequestedProjectState);
             }
         }
 
+        private void AutomaticallyDetectAndInstantiateProjectCacheServiceForVisualStudio(
+            BuildSubmission submission,
+            BuildRequestConfiguration config)
+        {
+            if (BuildEnvironmentHelper.Instance.RunningInVisualStudio &&
+                ProjectCacheItems.Count > 0 &&
+                !_projectCacheServiceInstantiatedByVSWorkaround &&
+                _projectCacheService == null &&
+                _buildParameters.ProjectCacheDescriptor == null)
+            {
+                _projectCacheServiceInstantiatedByVSWorkaround = true;
+                ErrorUtilities.VerifyThrowInvalidOperation(
+                    ProjectCacheItems.Count == 1,
+                    "OnlyOneCachePluginMustBeSpecified",
+                    string.Join("; ", ProjectCacheItems.Values.Select(c => c.PluginPath)));
+
+                LoadSubmissionProjectIntoConfiguration(submission, config);
+
+                if (IsDesignTimeBuild(config.Project))
+                {
+                    // Design time builds do not use the project cache.
+                    return;
+                }
+
+                var solutionPath = config.Project.GetPropertyValue(SolutionProjectGenerator.SolutionPathPropertyName);
+
+                ErrorUtilities.VerifyThrow(
+                    solutionPath != null && !string.IsNullOrWhiteSpace(solutionPath) && solutionPath != "*Undefined*",
+                    $"Expected VS to set a valid SolutionPath property but got: {solutionPath}");
+                ErrorUtilities.VerifyThrow(
+                    FileSystems.Default.FileExists(solutionPath),
+                    $"Solution file does not exist: {solutionPath}");
+
+                var projectCacheItem = ProjectCacheItems.First().Value;
+
+                InitializeProjectCacheService(
+                    ProjectCacheDescriptor.FromAssemblyPath(
+                        projectCacheItem.PluginPath,
+                        new[]
+                        {
+                            new ProjectGraphEntryPoint(
+                                solutionPath,
+                                config.Project.GlobalProperties)
+                        },
+                        null,
+                        projectCacheItem.PluginSettings),
+                    CancellationToken.None);
+            }
+
+            static bool IsDesignTimeBuild(ProjectInstance project)
+            {
+                var designTimeBuild = project.GetPropertyValue(DesignTimeProperties.DesignTimeBuild);
+                var buildingProject = project.GlobalPropertiesDictionary[DesignTimeProperties.BuildingProject]?.EvaluatedValue;
+
+                return MSBuildStringIsTrue(designTimeBuild) ||
+                       buildingProject != null && !MSBuildStringIsTrue(buildingProject);
+            }
+
+            static bool MSBuildStringIsTrue(string msbuildString) =>
+                ConversionUtilities.ConvertStringToBool(msbuildString, nullOrWhitespaceIsFalse: true);
+        }
+
         /// <summary>
         /// This method adds the graph build request in the specified submission to the set of requests being handled by the scheduler.
         /// </summary>
@@ -1128,10 +1367,27 @@ internal void ExecuteSubmission(GraphBuildSubmission submission)
             }
         }
 
+        private void LoadSubmissionProjectIntoConfiguration(BuildSubmission submission, BuildRequestConfiguration config)
+        {
+            if (!config.IsLoaded)
+            {
+                config.LoadProjectIntoConfiguration(
+                    this,
+                    submission.BuildRequestData.Flags,
+                    submission.SubmissionId,
+                    Scheduler.InProcNodeId
+                );
+
+                // If we're taking the time to evaluate, avoid having other nodes to repeat the same evaluation.
+                // Based on the assumption that ProjectInstance serialization is faster than evaluating from scratch.
+                config.Project.TranslateEntireState = true;
+            }
+        }
+
         /// <summary>
         /// Creates the traversal and metaproject instances necessary to represent the solution and populates new configurations with them.
         /// </summary>
-        internal void LoadSolutionIntoConfiguration(BuildRequestConfiguration config, BuildRequest request)
+        private void LoadSolutionIntoConfiguration(BuildRequestConfiguration config, BuildRequest request)
         {
             if (config.IsLoaded)
             {
@@ -1140,7 +1396,17 @@ internal void LoadSolutionIntoConfiguration(BuildRequestConfiguration config, Bu
             }
 
             ErrorUtilities.VerifyThrow(FileUtilities.IsSolutionFilename(config.ProjectFullPath), "{0} is not a solution", config.ProjectFullPath);
-            ProjectInstance[] instances = ProjectInstance.LoadSolutionForBuild(config.ProjectFullPath, config.GlobalProperties, config.ExplicitToolsVersionSpecified ? config.ToolsVersion : null, _buildParameters, ((IBuildComponentHost)this).LoggingService, request.BuildEventContext, false /* loaded by solution parser*/, config.TargetNames, SdkResolverService, request.SubmissionId);
+            var instances = ProjectInstance.LoadSolutionForBuild(
+                config.ProjectFullPath,
+                config.GlobalProperties,
+                config.ExplicitToolsVersionSpecified ? config.ToolsVersion : null,
+                _buildParameters,
+                ((IBuildComponentHost) this).LoggingService,
+                request.BuildEventContext,
+                false /* loaded by solution parser*/,
+                config.TargetNames,
+                SdkResolverService,
+                request.SubmissionId);
 
             // The first instance is the traversal project, which goes into this configuration
             config.Project = instances[0];
@@ -1289,6 +1555,10 @@ private void ProcessPacket(int node, INodePacket packet)
         /// </summary>
         private void HandleExecuteSubmissionException(BuildSubmission submission, Exception ex)
         {
+            if (ex is AggregateException ae && ae.InnerExceptions.Count == 1)
+            {
+                ex = ae.InnerExceptions.First();
+            }
             if (ex is InvalidProjectFileException projectException)
             {
                 if (!projectException.HasBeenLogged)
@@ -1326,6 +1596,10 @@ private void HandleExecuteSubmissionException(GraphBuildSubmission submission, E
                 }
             }
 
+            ex = ex is AggregateException ae && ae.InnerExceptions.Count == 1
+                ? ae.InnerExceptions.First()
+                : ex;
+
             if (submission.IsStarted)
             {
                 submission.CompleteResults(new GraphBuildResult(submission.SubmissionId, ex));
@@ -1449,71 +1723,23 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                         projectGraph.ConstructionMetrics.NodeCount,
                         projectGraph.ConstructionMetrics.EdgeCount));
 
-                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(submission.BuildRequestData.TargetNames);
-
-                var waitHandle = new AutoResetEvent(true);
-                var graphBuildStateLock = new object();
+                Dictionary<ProjectGraphNode, BuildResult> resultsPerNode = null;
 
-                var blockedNodes = new HashSet<ProjectGraphNode>(projectGraph.ProjectNodes);
-                var finishedNodes = new HashSet<ProjectGraphNode>(projectGraph.ProjectNodes.Count);
-                var buildingNodes = new Dictionary<BuildSubmission, ProjectGraphNode>();
-                Dictionary<ProjectGraphNode, BuildResult> resultsPerNode = new Dictionary<ProjectGraphNode, BuildResult>(projectGraph.ProjectNodes.Count);
-                while (blockedNodes.Count > 0 || buildingNodes.Count > 0)
+                if (submission.BuildRequestData.GraphBuildOptions.Build)
                 {
-                    waitHandle.WaitOne();
-
-                    lock (graphBuildStateLock)
-                    {
-                        var unblockedNodes = blockedNodes
-                            .Where(node => node.ProjectReferences.All(projectReference => finishedNodes.Contains(projectReference)))
-                            .ToList();
-                        foreach (var node in unblockedNodes)
-                        {
-                            var targetList = targetLists[node];
-                            if (targetList.Count == 0)
-                            {
-                                // An empty target list here means "no targets" instead of "default targets", so don't even build it.
-                                finishedNodes.Add(node);
-                                blockedNodes.Remove(node);
+                    var cacheServiceTask = Task.Run(() => SearchAndInitializeProjectCachePluginFromGraph(projectGraph));
+                    var targetListTask = Task.Run(() => projectGraph.GetTargetLists(submission.BuildRequestData.TargetNames));
 
-                                waitHandle.Set();
-
-                                continue;
-                            }
+                    using var cacheService = cacheServiceTask.Result;
 
-                            var request = new BuildRequestData(
-                                node.ProjectInstance,
-                                targetList.ToArray(),
-                                submission.BuildRequestData.HostServices,
-                                submission.BuildRequestData.Flags);
-
-                            // TODO Tack onto the existing submission instead of pending a whole new submission for every node
-                            // Among other things, this makes BuildParameters.DetailedSummary produce a summary for each node, which is not desirable.
-                            // We basically want to submit all requests to the scheduler all at once and describe dependencies by requests being blocked by other requests.
-                            // However today the scheduler only keeps track of MSBuild nodes being blocked by other MSBuild nodes, and MSBuild nodes haven't been assigned to the graph nodes yet.
-                            var innerBuildSubmission = PendBuildRequest(request);
-                            buildingNodes.Add(innerBuildSubmission, node);
-                            blockedNodes.Remove(node);
-                            innerBuildSubmission.ExecuteAsync(finishedBuildSubmission =>
-                            {
-                                lock (graphBuildStateLock)
-                                {
-                                    ProjectGraphNode finishedNode = buildingNodes[finishedBuildSubmission];
-
-                                    finishedNodes.Add(finishedNode);
-                                    buildingNodes.Remove(finishedBuildSubmission);
-
-                                    resultsPerNode.Add(finishedNode, finishedBuildSubmission.BuildResult);
-                                }
-
-                                waitHandle.Set();
-                            }, null);
-                        }
-                    }
+                    resultsPerNode = BuildGraph(projectGraph, targetListTask.Result, submission.BuildRequestData);
                 }
 
                 // The overall submission is complete, so report it as complete
-                ReportResultsToSubmission(new GraphBuildResult(submission.SubmissionId, new ReadOnlyDictionary<ProjectGraphNode, BuildResult>(resultsPerNode)));
+                ReportResultsToSubmission(
+                    new GraphBuildResult(
+                        submission.SubmissionId,
+                        new ReadOnlyDictionary<ProjectGraphNode, BuildResult>(resultsPerNode ?? new Dictionary<ProjectGraphNode, BuildResult>())));
             }
             catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
             {
@@ -1560,10 +1786,171 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                 }
 
                 ReportResultsToSubmission(result);
+
                 _overallBuildSuccess = false;
             }
         }
 
+        private Dictionary<ProjectGraphNode, BuildResult> BuildGraph(
+            ProjectGraph projectGraph,
+            IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetsPerNode,
+            GraphBuildRequestData graphBuildRequestData)
+        {
+            var waitHandle = new AutoResetEvent(true);
+            var graphBuildStateLock = new object();
+
+            var blockedNodes = new HashSet<ProjectGraphNode>(projectGraph.ProjectNodes);
+            var finishedNodes = new HashSet<ProjectGraphNode>(projectGraph.ProjectNodes.Count);
+            var buildingNodes = new Dictionary<BuildSubmission, ProjectGraphNode>();
+            var resultsPerNode = new Dictionary<ProjectGraphNode, BuildResult>(projectGraph.ProjectNodes.Count);
+
+            while (blockedNodes.Count > 0 || buildingNodes.Count > 0)
+            {
+                waitHandle.WaitOne();
+
+                lock (graphBuildStateLock)
+                {
+                    var unblockedNodes = blockedNodes
+                        .Where(node => node.ProjectReferences.All(projectReference => finishedNodes.Contains(projectReference)))
+                        .ToList();
+                    foreach (var node in unblockedNodes)
+                    {
+                        var targetList = targetsPerNode[node];
+                        if (targetList.Count == 0)
+                        {
+                            // An empty target list here means "no targets" instead of "default targets", so don't even build it.
+                            finishedNodes.Add(node);
+                            blockedNodes.Remove(node);
+
+                            waitHandle.Set();
+
+                            continue;
+                        }
+
+                        var request = new BuildRequestData(
+                            node.ProjectInstance,
+                            targetList.ToArray(),
+                            graphBuildRequestData.HostServices,
+                            graphBuildRequestData.Flags);
+
+                        // TODO Tack onto the existing submission instead of pending a whole new submission for every node
+                        // Among other things, this makes BuildParameters.DetailedSummary produce a summary for each node, which is not desirable.
+                        // We basically want to submit all requests to the scheduler all at once and describe dependencies by requests being blocked by other requests.
+                        // However today the scheduler only keeps track of MSBuild nodes being blocked by other MSBuild nodes, and MSBuild nodes haven't been assigned to the graph nodes yet.
+                        var innerBuildSubmission = PendBuildRequest(request);
+                        buildingNodes.Add(innerBuildSubmission, node);
+                        blockedNodes.Remove(node);
+                        innerBuildSubmission.ExecuteAsync(finishedBuildSubmission =>
+                        {
+                            lock (graphBuildStateLock)
+                            {
+                                ProjectGraphNode finishedNode = buildingNodes[finishedBuildSubmission];
+
+                                finishedNodes.Add(finishedNode);
+                                buildingNodes.Remove(finishedBuildSubmission);
+
+                                resultsPerNode.Add(finishedNode, finishedBuildSubmission.BuildResult);
+                            }
+
+                            waitHandle.Set();
+                        }, null);
+                    }
+                }
+            }
+
+            return resultsPerNode;
+        }
+
+        private DisposePluginService SearchAndInitializeProjectCachePluginFromGraph(ProjectGraph projectGraph)
+        {
+            // TODO: Consider allowing parallel graph submissions, each with its own separate cache plugin. Right now the second graph submission with a cache will fail.
+
+            if (_buildParameters.ProjectCacheDescriptor != null)
+            {
+                // Build parameter specified project cache takes precedence.
+                return new DisposePluginService(null);
+            }
+
+            var nodeToCacheItems = projectGraph.ProjectNodes.ToDictionary(
+                n => n,
+                n => n.ProjectInstance.GetItems(ItemTypeNames.ProjectCachePlugin)
+                    .Select(
+                        i =>
+                        {
+                            var metadataDictionary = i.Metadata.ToDictionary(
+                                m => ((IKeyed) m).Key,
+                                m => ((IValued) m).EscapedValue);
+
+                            var pluginPath = Path.Combine(i.Project.Directory, i.EvaluatedInclude);
+
+                            var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);
+
+                            return projectCacheItem;
+                        })
+                    .ToArray());
+
+            var cacheItems = nodeToCacheItems.Values.SelectMany(i => i).ToHashSet();
+
+            if (cacheItems.Count == 0)
+            {
+                return new DisposePluginService(null);
+            }
+
+            ErrorUtilities.VerifyThrowInvalidOperation(
+                cacheItems.Count == 1,
+                "OnlyOneCachePluginMustBeSpecified",
+                string.Join("; ", cacheItems.Select(ci => ci.PluginPath)));
+
+            var nodesWithoutCacheItems = nodeToCacheItems.Where(kvp => kvp.Value.Length == 0).ToArray();
+
+            if (nodesWithoutCacheItems.Length > 0)
+            {
+                ErrorUtilities.ThrowInvalidOperation(
+                    "NotAllNodesDefineACacheItem",
+                    ItemTypeNames.ProjectCachePlugin,
+                    string.Join(", ", nodesWithoutCacheItems.Select(kvp => kvp.Key.ProjectInstance.FullPath)));
+            }
+
+            var cacheItem = cacheItems.First();
+
+            lock (_syncLock)
+            {
+                InitializeProjectCacheService(
+                    ProjectCacheDescriptor.FromAssemblyPath(
+                        cacheItem.PluginPath,
+                        entryPoints: null,
+                        projectGraph,
+                        cacheItem.PluginSettings),
+                    _graphSchedulingCancellationSource.Token);
+            }
+
+            return new DisposePluginService(this);
+        }
+
+        private class DisposePluginService : IDisposable
+        {
+            private readonly BuildManager _buildManager;
+
+            public DisposePluginService(BuildManager buildManager)
+            {
+                _buildManager = buildManager;
+            }
+
+            public void Dispose()
+            {
+                if (_buildManager == null)
+                {
+                    return;
+                }
+
+                lock (_buildManager._syncLock)
+                {
+                    _buildManager._projectCacheService?.Result.ShutDown().GetAwaiter().GetResult();
+                    _buildManager._projectCacheService = null;
+                }
+            }
+        }
+
         /// <summary>
         /// Asks the nodeManager to tell the currently connected nodes to shut down and sets a flag preventing all non-shutdown-related packets from
         /// being processed.
@@ -1632,6 +2019,7 @@ private void Reset()
             _nodeManager.UnregisterPacketHandler(NodePacketType.BuildRequestConfigurationResponse);
             _nodeManager.UnregisterPacketHandler(NodePacketType.BuildResult);
             _nodeManager.UnregisterPacketHandler(NodePacketType.NodeShutdown);
+
             _nodeManager.ClearPerBuildState();
             _nodeManager = null;
 
@@ -1639,10 +2027,13 @@ private void Reset()
             _nodeConfiguration = null;
             _buildSubmissions.Clear();
             _graphBuildSubmissions.Clear();
+
             _scheduler.Reset();
             _scheduler = null;
             _workQueue = null;
             _graphSchedulingCancellationSource = null;
+            _projectCacheService = null;
+            _projectCacheServiceInstantiatedByVSWorkaround = false;
             _acquiredProjectRootElementCacheFromProjectInstance = false;
 
             _unnamedProjectInstanceToNames.Clear();
@@ -2084,8 +2475,6 @@ private void CheckSubmissionCompletenessAndRemove(BuildSubmission submission)
                 // If the submission has completed or never started, remove it.
                 if (submission.IsCompleted || submission.BuildRequest == null)
                 {
-                    SetOverallResultIfWarningsAsErrors(submission.BuildResult);
-
                     _buildSubmissions.Remove(submission.SubmissionId);
 
                     // Clear all cached SDKs for the submission
@@ -2345,25 +2734,6 @@ private static I ExpectPacketType<I>(INodePacket packet, NodePacketType expected
             return castPacket;
         }
 
-        /// <summary>
-        /// Sets the overall result of a build only if the user had specified /warnaserror and there were any errors.
-        /// This ensures the old behavior stays intact where builds could succeed even if a failure was logged.
-        /// </summary>
-        private void SetOverallResultIfWarningsAsErrors(BuildResult result)
-        {
-            if (result?.OverallResult == BuildResultCode.Success)
-            {
-                ILoggingService loggingService = ((IBuildComponentHost)this).LoggingService;
-
-                if (loggingService.HasBuildSubmissionLoggedErrors(result.SubmissionId))
-                {
-                    result.SetOverallResult(overallResult: false);
-
-                    _overallBuildSuccess = false;
-                }
-            }
-        }
-
         /// <summary>
         ///  Shutdown the logging service
         /// </summary>
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 3dcea354ea1..4869dfbda9d 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -10,7 +10,9 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Graph;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
@@ -68,7 +70,7 @@ public class BuildParameters : ITranslatable
         /// <summary>
         /// Indicates if we should dump string interning stats.
         /// </summary>
-        private static bool? s_dumpOpportunisticInternStats;
+        private static bool? s_dumpStringInterningStats;
 
         /// <summary>
         /// Indicates if we should debug the expander.
@@ -297,6 +299,7 @@ private BuildParameters(BuildParameters other)
             _outputResultsCacheFile = other._outputResultsCacheFile;
             DiscardBuildResults = other.DiscardBuildResults;
             LowPriority = other.LowPriority;
+            ProjectCacheDescriptor = other.ProjectCacheDescriptor;
         }
 
 #if FEATURE_THREAD_PRIORITY
@@ -556,7 +559,7 @@ public bool OnlyLogCriticalEvents
         /// <comments>
         /// toolsetProvider.Toolsets is already a readonly collection.
         /// </comments>
-        public ICollection<Toolset> Toolsets => _toolsetProvider.Toolsets;
+        public ICollection<Toolset> Toolsets => ToolsetProvider.Toolsets;
 
         /// <summary>
         /// The name of the UI culture to use during the build.
@@ -645,7 +648,7 @@ internal static bool WarnOnUninitializedProperty
         /// Indicates whether we should dump string interning stats
         /// </summary>
         internal static bool DumpOpportunisticInternStats => GetStaticBoolVariableOrDefault(
-            "MSBUILDDUMPOPPORTUNISTICINTERNSTATS", ref s_dumpOpportunisticInternStats, false);
+            "MSBUILDDUMPOPPORTUNISTICINTERNSTATS", ref s_dumpStringInterningStats, false);
 
         /// <summary>
         /// Indicates whether we should dump debugging information about the expander
@@ -787,6 +790,14 @@ public string ResourceManagerSemaphoreName
         /// </summary>
         public bool LowPriority { get; set; }
 
+        /// <summary>
+        /// If set, the BuildManager will query all
+        /// incoming <see cref="BuildSubmission"/> requests against the specified project cache.
+        /// Any <see cref="GraphBuildSubmission"/> requests will also use this project cache instead of
+        /// the potential project caches described in graph node's evaluations.
+        /// </summary>
+        public ProjectCacheDescriptor ProjectCacheDescriptor { get; set; }
+
         /// <summary>
         /// Retrieves a toolset.
         /// </summary>
diff --git a/src/Build/BackEnd/BuildManager/BuildSubmission.cs b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
index 3a53fbbf3ee..91356f814c6 100644
--- a/src/Build/BackEnd/BuildManager/BuildSubmission.cs
+++ b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
@@ -198,6 +198,13 @@ private void CheckForCompletion()
                 bool hasCompleted = (Interlocked.Exchange(ref _completionInvoked, 1) == 1);
                 if (!hasCompleted)
                 {
+                    // Did this submission have warnings elevated to errors? If so, mark it as
+                    // failed even though it succeeded (with warnings--but they're errors).
+                    if (((IBuildComponentHost)BuildManager).LoggingService.HasBuildSubmissionLoggedErrors(BuildResult.SubmissionId))
+                    {
+                        BuildResult.SetOverallResult(overallResult: false);
+                    }
+
                     _completionEvent.Set();
 
                     if (_completionCallback != null)
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index bd5d8815eb6..05e6671a6d6 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -1160,7 +1160,7 @@ private void IssueBuildRequests(BuildRequestEntry issuingEntry, FullyQualifiedBu
                             configurationId: matchingConfig.ConfigurationId,
                             escapedTargets: request.Targets,
                             hostServices: issuingEntry.Request.HostServices,
-                            parentBuildEventContext: issuingEntry.Request.BuildEventContext,
+                            parentBuildEventContext: issuingEntry.Request.CurrentTaskContext ?? issuingEntry.Request.BuildEventContext,
                             parentRequest: issuingEntry.Request,
                             buildRequestDataFlags: buildRequestDataFlags,
                             requestedProjectState: null,
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index a59c7f60914..0cf24b8aa14 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -240,7 +240,7 @@ public void Translate(ITranslator translator)
                 ref localReference,
                 (ITranslator aTranslator, ref int i) => aTranslator.Translate(ref i),
                 (ITranslator aTranslator, ref BuildResult result) => aTranslator.Translate(ref result),
-                capacity => new ConcurrentDictionary<int, BuildResult>(Environment.ProcessorCount, capacity));
+                capacity => new ConcurrentDictionary<int, BuildResult>(NativeMethodsShared.GetLogicalCoreCount(), capacity));
 
             if (translator.Mode == TranslationDirection.ReadFromStream)
             {
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index e65f614e08e..501d9ddbbc8 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -3,14 +3,13 @@
 
 using System;
 using System.Collections.Generic;
+using System.Collections.Concurrent;
 using System.Globalization;
 using System.IO;
 using System.IO.Pipes;
 using System.Diagnostics;
 using System.Threading;
-#if !FEATURE_APM
 using System.Threading.Tasks;
-#endif
 using System.Runtime.InteropServices;
 #if FEATURE_PIPE_SECURITY
 using System.Security.Principal;
@@ -609,8 +608,27 @@ internal class NodeContext
 
             /// <summary>
             /// A buffer typically big enough to handle a packet body.
+            /// We use this as a convenient way to manage and cache a byte[] that's resized
+            /// automatically to fit our payload.
+            /// </summary>
+            private MemoryStream _readBufferMemoryStream;
+
+            /// <summary>
+            /// A reusable buffer for writing packets.
+            /// </summary>
+            private MemoryStream _writeBufferMemoryStream;
+
+            /// <summary>
+            /// A queue used for enqueuing packets to write to the stream asynchronously.
             /// </summary>
-            private byte[] _smallReadBuffer;
+            private BlockingCollection<INodePacket> _packetWriteQueue = new BlockingCollection<INodePacket>();
+
+            /// <summary>
+            /// A task representing the last packet write, so we can chain packet writes one after another.
+            /// We want to queue up writing packets on a separate thread asynchronously, but serially.
+            /// Each task drains the <see cref="_packetWriteQueue"/>
+            /// </summary>
+            private Task _packetWriteDrainTask = Task.CompletedTask;
 
             /// <summary>
             /// Event indicating the node has terminated.
@@ -640,7 +658,9 @@ public NodeContext(int nodeId, int processId,
                 _serverToClientStream = nodePipe;
                 _packetFactory = factory;
                 _headerByte = new byte[5]; // 1 for the packet type, 4 for the body length
-                _smallReadBuffer = new byte[1000]; // 1000 was just an average seen on one profile run.
+
+                _readBufferMemoryStream = new MemoryStream();
+                _writeBufferMemoryStream = new MemoryStream();
                 _nodeTerminated = new ManualResetEvent(false);
                 _terminateDelegate = terminateDelegate;
                 _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();
@@ -685,16 +705,8 @@ public async Task RunPacketReadLoopAsync()
                     NodePacketType packetType = (NodePacketType)_headerByte[0];
                     int packetLength = BitConverter.ToInt32(_headerByte, 1);
 
-                    byte[] packetData;
-                    if (packetLength < _smallReadBuffer.Length)
-                    {
-                        packetData = _smallReadBuffer;
-                    }
-                    else
-                    {
-                        // Preallocated buffer is not large enough to hold the body. Allocate now, but don't hold it forever.
-                        packetData = new byte[packetLength];
-                    }
+                    _readBufferMemoryStream.SetLength(packetLength);
+                    byte[] packetData = _readBufferMemoryStream.GetBuffer();
 
                     try
                     {
@@ -728,54 +740,81 @@ public async Task RunPacketReadLoopAsync()
 #endif
 
             /// <summary>
-            /// Sends the specified packet to this node.
+            /// Sends the specified packet to this node asynchronously.
+            /// The method enqueues a task to write the packet and returns
+            /// immediately. This is because SendData() is on a hot path
+            /// under the primary lock (BuildManager's _syncLock)
+            /// and we want to minimize our time there.
             /// </summary>
             /// <param name="packet">The packet to send.</param>
             public void SendData(INodePacket packet)
             {
-                MemoryStream writeStream = new MemoryStream();
+                _packetWriteQueue.Add(packet);
+                DrainPacketQueue();
+            }
+
+            /// <summary>
+            /// Schedule a task to drain the packet write queue. We could have had a
+            /// dedicated thread that would pump the queue constantly, but
+            /// we don't want to allocate a dedicated thread per node (1MB stack)
+            /// </summary>
+            /// <remarks>Usually there'll be a single packet in the queue, but sometimes
+            /// a burst of SendData comes in, with 10-20 packets scheduled. In this case
+            /// the first scheduled task will drain all of them, and subsequent tasks
+            /// will run on an empty queue. I tried to write logic that avoids queueing
+            /// a new task if the queue is already being drained, but it didn't show any
+            /// improvement and made things more complicated.</remarks>
+            private void DrainPacketQueue()
+            {
+                // this lock is only necessary to protect a write to _packetWriteDrainTask field
+                lock (_packetWriteQueue)
+                {
+                    // average latency between the moment this runs and when the delegate starts
+                    // running is about 100-200 microseconds (unless there's thread pool saturation)
+                    _packetWriteDrainTask = _packetWriteDrainTask.ContinueWith(_ =>
+                    {
+                        while (_packetWriteQueue.TryTake(out var packet))
+                        {
+                            SendDataCore(packet);
+                        }
+                    }, TaskScheduler.Default);
+                }
+            }
+
+            /// <summary>
+            /// Actually writes and sends the packet. This can't be called in parallel
+            /// because it reuses the _writeBufferMemoryStream, and this is why we use
+            /// the _packetWriteDrainTask to serially chain invocations one after another.
+            /// </summary>
+            /// <param name="packet">The packet to send.</param>
+            private void SendDataCore(INodePacket packet)
+            {
+                MemoryStream writeStream = _writeBufferMemoryStream;
+
+                // clear the buffer but keep the underlying capacity to avoid reallocations
+                writeStream.SetLength(0);
+
                 ITranslator writeTranslator = BinaryTranslator.GetWriteTranslator(writeStream);
                 try
                 {
                     writeStream.WriteByte((byte)packet.Type);
 
                     // Pad for the packet length
-                    writeStream.Write(BitConverter.GetBytes((int)0), 0, 4);
+                    WriteInt32(writeStream, 0);
                     packet.Translate(writeTranslator);
 
+                    int writeStreamLength = (int)writeStream.Position;
+
                     // Now plug in the real packet length
                     writeStream.Position = 1;
-                    writeStream.Write(BitConverter.GetBytes((int)writeStream.Length - 5), 0, 4);
+                    WriteInt32(writeStream, writeStreamLength - 5);
 
                     byte[] writeStreamBuffer = writeStream.GetBuffer();
 
-                    for (int i = 0; i < writeStream.Length; i += MaxPacketWriteSize)
+                    for (int i = 0; i < writeStreamLength; i += MaxPacketWriteSize)
                     {
-                        int lengthToWrite = Math.Min((int)writeStream.Length - i, MaxPacketWriteSize);
-                        if ((int)writeStream.Length - i <= MaxPacketWriteSize)
-                        {
-                            // We are done, write the last bit asynchronously.  This is actually the general case for
-                            // most packets in the build, and the asynchronous behavior here is desirable.
-#if FEATURE_APM
-                            _serverToClientStream.BeginWrite(writeStreamBuffer, i, lengthToWrite, PacketWriteComplete, null);
-#else
-                            _serverToClientStream.WriteAsync(writeStreamBuffer, i, lengthToWrite);
-#endif
-                            return;
-                        }
-                        else
-                        {
-                            // If this packet is longer that we can write in one go, then we need to break it up.  We can't
-                            // return out of this function and let the rest of the system continue because another operation
-                            // might want to send data immediately afterward, and that could result in overlapping writes
-                            // to the pipe on different threads.
-#if FEATURE_APM
-                            IAsyncResult result = _serverToClientStream.BeginWrite(writeStream.GetBuffer(), i, lengthToWrite, null, null);
-                            _serverToClientStream.EndWrite(result);
-#else
-                            _serverToClientStream.Write(writeStreamBuffer, i, lengthToWrite);
-#endif
-                        }
+                        int lengthToWrite = Math.Min(writeStreamLength - i, MaxPacketWriteSize);
+                        _serverToClientStream.Write(writeStreamBuffer, i, lengthToWrite);
                     }
                 }
                 catch (IOException e)
@@ -789,6 +828,17 @@ public void SendData(INodePacket packet)
                 }
             }
 
+            /// <summary>
+            /// Avoid having a BinaryWriter just to write a 4-byte int
+            /// </summary>
+            private void WriteInt32(MemoryStream stream, int value)
+            {
+                stream.WriteByte((byte)value);
+                stream.WriteByte((byte)(value >> 8));
+                stream.WriteByte((byte)(value >> 16));
+                stream.WriteByte((byte)(value >> 24));
+            }
+
             /// <summary>
             /// Closes the node's context, disconnecting it from the node.
             /// </summary>
@@ -887,16 +937,10 @@ private void HeaderReadComplete(IAsyncResult result)
                 int packetLength = BitConverter.ToInt32(_headerByte, 1);
                 MSBuildEventSource.Log.PacketReadSize(packetLength);
 
-                byte[] packetData;
-                if (packetLength < _smallReadBuffer.Length)
-                {
-                    packetData = _smallReadBuffer;
-                }
-                else
-                {
-                    // Preallocated buffer is not large enough to hold the body. Allocate now, but don't hold it forever.
-                    packetData = new byte[packetLength];
-                }
+                // Ensures the buffer is at least this length.
+                // It avoids reallocations if the buffer is already large enough.
+                _readBufferMemoryStream.SetLength(packetLength);
+                byte[] packetData = _readBufferMemoryStream.GetBuffer();
 
                 _clientToServerStream.BeginRead(packetData, 0, packetLength, BodyReadComplete, new Tuple<byte[], int>(packetData, packetLength));
             }
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index d0ba8d88919..42feb90220b 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -427,8 +427,9 @@ bool IncludeTaskInputs
         /// <param name="targetNames">The entrypoint target names for this project</param>
         /// <param name="properties">The initial properties of the project</param>
         /// <param name="items">The initial items of the project</param>
+        /// <param name="evaluationId">EvaluationId of the project instance</param>
         /// <returns>The BuildEventContext to use for this project.</returns>
-        BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventContext, int submissionId, int projectId, BuildEventContext parentBuildEventContext, string projectFile, string targetNames, IEnumerable<DictionaryEntry> properties, IEnumerable<DictionaryEntry> items);
+        BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventContext, int submissionId, int projectId, BuildEventContext parentBuildEventContext, string projectFile, string targetNames, IEnumerable<DictionaryEntry> properties, IEnumerable<DictionaryEntry> items, int evaluationId = BuildEventContext.InvalidEvaluationId);
 
         /// <summary>
         /// Log that the project has finished
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index aa386336ac3..b4fb5ad461c 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -541,15 +541,16 @@ public void LogProjectEvaluationFinished(BuildEventContext projectEvaluationEven
         /// <param name="targetNames">Target names to build</param>
         /// <param name="properties">Initial property list</param>
         /// <param name="items">Initial items list</param>
+        /// <param name="evaluationId">EvaluationId of the project instance</param>
         /// <returns>The build event context for the project.</returns>
         /// <exception cref="InternalErrorException">parentBuildEventContext is null</exception>
         /// <exception cref="InternalErrorException">projectBuildEventContext is null</exception>
-        public BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventContext, int submissionId, int projectInstanceId, BuildEventContext parentBuildEventContext, string projectFile, string targetNames, IEnumerable<DictionaryEntry> properties, IEnumerable<DictionaryEntry> items)
+        public BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventContext, int submissionId, int projectInstanceId, BuildEventContext parentBuildEventContext, string projectFile, string targetNames, IEnumerable<DictionaryEntry> properties, IEnumerable<DictionaryEntry> items, int evaluationId = BuildEventContext.InvalidEvaluationId)
         {
             lock (_lockObject)
             {
                 ErrorUtilities.VerifyThrow(nodeBuildEventContext != null, "Need a nodeBuildEventContext");
-                BuildEventContext projectBuildEventContext = new BuildEventContext(submissionId, nodeBuildEventContext.NodeId, projectInstanceId, NextProjectId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
+                BuildEventContext projectBuildEventContext = new BuildEventContext(submissionId, nodeBuildEventContext.NodeId, evaluationId, projectInstanceId, NextProjectId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
 
                 // PERF: Not using VerifyThrow to avoid boxing of projectBuildEventContext.ProjectContextId in the non-error case.
                 if (_projectFileMap.ContainsKey(projectBuildEventContext.ProjectContextId))
diff --git a/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs b/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
index 512cba7c0c8..05c5ae53708 100644
--- a/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
@@ -69,7 +69,7 @@ internal ProjectLoggingContext LogProjectStarted(BuildRequestEntry requestEntry)
         internal ProjectLoggingContext LogProjectStarted(BuildRequest request, BuildRequestConfiguration configuration)
         {
             ErrorUtilities.VerifyThrow(this.IsValid, "Build not started.");
-            return new ProjectLoggingContext(this, request, configuration.ProjectFullPath, configuration.ToolsVersion, request.ParentBuildEventContext);
+            return new ProjectLoggingContext(this, request, configuration.ProjectFullPath, configuration.ToolsVersion, request.ParentBuildEventContext, configuration.Project?.EvaluationId ?? BuildEventContext.InvalidEvaluationId);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index cfd9089f1bc..be1a86b0229 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -41,7 +41,8 @@ internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildReque
             requestEntry.RequestConfiguration.ToolsVersion,
             requestEntry.RequestConfiguration.Project.PropertiesToBuildWith,
             requestEntry.RequestConfiguration.Project.ItemsToBuildWith,
-            parentBuildEventContext
+            parentBuildEventContext,
+            requestEntry.RequestConfiguration.Project.EvaluationId
             )
         {
         }
@@ -49,7 +50,7 @@ internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildReque
         /// <summary>
         /// Constructs a project logging context.
         /// </summary>
-        internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildRequest request, string projectFullPath, string toolsVersion, BuildEventContext parentBuildEventContext)
+        internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildRequest request, string projectFullPath, string toolsVersion, BuildEventContext parentBuildEventContext, int evaluationId = BuildEventContext.InvalidEvaluationId)
             : this
             (
             nodeLoggingContext,
@@ -60,7 +61,8 @@ internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildReque
             toolsVersion,
             null,
             null,
-            parentBuildEventContext
+            parentBuildEventContext,
+            evaluationId
             )
         {
         }
@@ -68,7 +70,7 @@ internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildReque
         /// <summary>
         /// Constructs a project logging contexts.
         /// </summary>
-        private ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, int submissionId, int configurationId, string projectFullPath, List<string> targets, string toolsVersion, PropertyDictionary<ProjectPropertyInstance> projectProperties, ItemDictionary<ProjectItemInstance> projectItems, BuildEventContext parentBuildEventContext)
+        private ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, int submissionId, int configurationId, string projectFullPath, List<string> targets, string toolsVersion, PropertyDictionary<ProjectPropertyInstance> projectProperties, ItemDictionary<ProjectItemInstance> projectItems, BuildEventContext parentBuildEventContext, int evaluationId = BuildEventContext.InvalidEvaluationId)
             : base(nodeLoggingContext)
         {
             _nodeLoggingContext = nodeLoggingContext;
@@ -125,8 +127,8 @@ private ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, int submiss
                 projectFullPath,
                 String.Join(";", targets),
                 properties,
-                items
-                );
+                items,
+                evaluationId);
             LoggingService.LogComment(this.BuildEventContext, MessageImportance.Low, "ToolsVersionInEffectForBuild", toolsVersion);
 
             this.IsValid = true;
diff --git a/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs b/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs
new file mode 100644
index 00000000000..bc7354b9a90
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs
@@ -0,0 +1,44 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using System.Collections.Generic;
+using Microsoft.Build.FileSystem;
+using Microsoft.Build.Graph;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    /// <summary>
+    ///     Holds various information about the current msbuild execution that the cache might use.
+    ///     The cache may need to know about the top level projects or the entire project graph, so MSBuild
+    ///     provides a graph when one is available. When it isn't available, MSBuild provides the top level projects
+    ///     and the plugin can construct its own graph based on those.
+    ///     So either <see cref="Graph" />is null, or <see cref="GraphEntryPoints" /> is null. But not both.
+    /// </summary>
+    public class CacheContext
+    {
+        public IReadOnlyDictionary<string, string> PluginSettings { get; }
+        public ProjectGraph? Graph { get; }
+        public IReadOnlyCollection<ProjectGraphEntryPoint>? GraphEntryPoints { get; }
+        public string? MSBuildExePath { get; }
+        public MSBuildFileSystemBase FileSystem { get; }
+
+        public CacheContext(
+            IReadOnlyDictionary<string, string> pluginSettings,
+            MSBuildFileSystemBase fileSystem,
+            ProjectGraph? graph = null,
+            IReadOnlyCollection<ProjectGraphEntryPoint>? graphEntryPoints = null)
+        {
+            ErrorUtilities.VerifyThrow(
+                (graph != null) ^ (graphEntryPoints != null),
+                "Either Graph is specified, or GraphEntryPoints is specified. Not both.");
+
+            PluginSettings = pluginSettings;
+            Graph = graph;
+            GraphEntryPoints = graphEntryPoints;
+            MSBuildExePath = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
+            FileSystem = fileSystem;
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs b/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs
new file mode 100644
index 00000000000..af194e45728
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs
@@ -0,0 +1,128 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using System.Collections.Generic;
+using System.Linq;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    /// <summary>
+    /// Result types that a plugin can return for a given build request.
+    /// </summary>
+    public enum CacheResultType
+    {
+        /// <summary>
+        /// The plugin failed and couldn't return a result. The plugin should log an error detailing the failure. MSBuild will stop the build.
+        /// </summary>
+        None = 0,
+
+        /// <summary>
+        /// The plugin determined that it supports a build request and found that it can be skipped. MSBuild won't build the request.
+        /// </summary>
+        CacheHit,
+
+        /// <summary>
+        /// The plugin determined that it supports a build request and found that it cannot be skipped. MSBuild will build the request.
+        /// </summary>
+        CacheMiss,
+
+        /// <summary>
+        /// The plugin determined that it does not support a certain build request. MSBuild will build the request.
+        /// For example, a plugin may not support projects with a certain extension, certain properties, or certain called targets.
+        /// </summary>
+        CacheNotApplicable
+    }
+
+    /// <summary>
+    ///     Represents the cache result a plugin returns back to MSBuild when queried about a certain project.
+    ///     Results representing cache hits (with <see cref="ResultType"/> == <see cref="CacheResultType.CacheHit"/>)
+    ///     contain information about what <see cref="Execution.BuildResult"/> MSBuild should use for the queried project.
+    ///     It is assumed that all cache hits result in a successful <see cref="Execution.BuildResult"/>.
+    /// </summary>
+    public class CacheResult
+    {
+        private CacheResult(
+            CacheResultType resultType,
+            BuildResult? buildResult = null,
+            ProxyTargets? proxyTargets = null)
+        {
+            if (resultType == CacheResultType.CacheHit)
+            {
+                ErrorUtilities.VerifyThrow(
+                    buildResult != null ^ proxyTargets != null,
+                    "Either buildResult is specified, or proxyTargets is specified. Not both.");
+            }
+
+            ResultType = resultType;
+            BuildResult = buildResult;
+            ProxyTargets = proxyTargets;
+        }
+
+        internal CacheResultType ResultType { get; }
+        internal BuildResult? BuildResult { get; }
+        internal ProxyTargets? ProxyTargets { get; }
+
+        public static CacheResult IndicateCacheHit(BuildResult buildResult)
+        {
+            return new CacheResult(CacheResultType.CacheHit, buildResult);
+        }
+
+        public static CacheResult IndicateCacheHit(ProxyTargets proxyTargets)
+        {
+            return new CacheResult(CacheResultType.CacheHit, proxyTargets: proxyTargets);
+        }
+
+        public static CacheResult IndicateCacheHit(IReadOnlyCollection<PluginTargetResult> targetResults)
+        {
+            ErrorUtilities.VerifyThrowArgumentLength(targetResults, nameof(targetResults));
+
+            return new CacheResult(CacheResultType.CacheHit, ConstructBuildResult(targetResults));
+        }
+
+        public static CacheResult IndicateNonCacheHit(CacheResultType resultType)
+        {
+            ErrorUtilities.VerifyThrowInvalidOperation(resultType != CacheResultType.CacheHit, "CantBeCacheHit");
+            return new CacheResult(resultType);
+        }
+
+        private static BuildResult ConstructBuildResult(IReadOnlyCollection<PluginTargetResult> targetResults)
+        {
+            var buildResult = new BuildResult();
+
+            foreach (var pluginTargetResult in targetResults)
+            {
+                buildResult.AddResultsForTarget(
+                    pluginTargetResult.TargetName,
+                    new TargetResult(
+                        pluginTargetResult.TaskItems.Select(ti => CreateTaskItem(ti)).ToArray(),
+                        CreateWorkUnitResult(pluginTargetResult.ResultCode)));
+            }
+
+            return buildResult;
+        }
+
+        private static WorkUnitResult CreateWorkUnitResult(BuildResultCode resultCode)
+        {
+            return resultCode == BuildResultCode.Success
+                ? new WorkUnitResult(WorkUnitResultCode.Success, WorkUnitActionCode.Continue, null)
+                : new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, null);
+        }
+
+        private static ProjectItemInstance.TaskItem CreateTaskItem(ITaskItem2 taskItemInterface)
+        {
+            var taskItem = new ProjectItemInstance.TaskItem(taskItemInterface.EvaluatedIncludeEscaped, null);
+
+            foreach (string metadataName in taskItemInterface.MetadataNames)
+            {
+                taskItem.SetMetadata(metadataName, taskItemInterface.GetMetadataValueEscaped(metadataName));
+            }
+
+            return taskItem;
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/PluginLoggerBase.cs b/src/Build/BackEnd/Components/ProjectCache/PluginLoggerBase.cs
new file mode 100644
index 00000000000..15ae99e97f5
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/PluginLoggerBase.cs
@@ -0,0 +1,32 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    /// <summary>
+    ///     Events logged with this logger will get pushed into MSBuild's logging infrastructure.
+    /// </summary>
+    public abstract class PluginLoggerBase
+    {
+        protected PluginLoggerBase(LoggerVerbosity verbosity)
+        {
+            Verbosity = verbosity;
+        }
+
+        /// <summary>
+        ///     See <see cref="ILogger.Verbosity" />
+        /// </summary>
+        private LoggerVerbosity Verbosity { get; }
+
+        public abstract bool HasLoggedErrors { get; protected set; }
+
+        public abstract void LogMessage(string message, MessageImportance? messageImportance = null);
+
+        public abstract void LogWarning(string warning);
+
+        public abstract void LogError(string error);
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/PluginTargetResult.cs b/src/Build/BackEnd/Components/ProjectCache/PluginTargetResult.cs
new file mode 100644
index 00000000000..7afe81169c0
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/PluginTargetResult.cs
@@ -0,0 +1,31 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using System.Collections.Generic;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    /// <summary>
+    ///     A cache hit can use this to instruct MSBuild to construct a BuildResult with the target result specified in this
+    ///     type.
+    /// </summary>
+    public readonly struct PluginTargetResult
+    {
+        public string TargetName { get; }
+        public IReadOnlyCollection<ITaskItem2> TaskItems { get; }
+        public BuildResultCode ResultCode { get; }
+
+        public PluginTargetResult(
+            string targetName,
+            IReadOnlyCollection<ITaskItem2> taskItems,
+            BuildResultCode resultCode)
+        {
+            TargetName = targetName;
+            TaskItems = taskItems;
+            ResultCode = resultCode;
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs
new file mode 100644
index 00000000000..22d98780b2b
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs
@@ -0,0 +1,113 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using System.Collections.Generic;
+using System.Linq;
+using Microsoft.Build.Graph;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    public class ProjectCacheDescriptor
+    {
+        /// <summary>
+        ///     The path to the assembly containing the project cache plugin.
+        /// </summary>
+        public string? PluginAssemblyPath { get; }
+
+        /// <summary>
+        ///     The entry points with which the plugin will be initialized.
+        /// </summary>
+        public IReadOnlyCollection<ProjectGraphEntryPoint>? EntryPoints { get; }
+
+        /// <summary>
+        ///     The graph with which the plugin will be initialized.
+        /// </summary>
+        public ProjectGraph? ProjectGraph { get; }
+
+        public IReadOnlyDictionary<string, string> PluginSettings { get; }
+
+        public ProjectCachePluginBase? PluginInstance { get; }
+
+        private ProjectCacheDescriptor(
+            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
+            ProjectGraph? projectGraph,
+            IReadOnlyDictionary<string, string>? pluginSettings)
+        {
+            ErrorUtilities.VerifyThrowArgument(
+                (entryPoints == null) ^ (projectGraph == null),
+                "EitherEntryPointsOrTheProjectGraphIsSet");
+
+            EntryPoints = entryPoints;
+            ProjectGraph = projectGraph;
+            PluginSettings = pluginSettings ?? new Dictionary<string, string>();
+        }
+
+        private ProjectCacheDescriptor(
+            string pluginAssemblyPath,
+            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
+            ProjectGraph? projectGraph,
+            IReadOnlyDictionary<string, string>? pluginSettings) : this(entryPoints, projectGraph, pluginSettings)
+        {
+            PluginAssemblyPath = pluginAssemblyPath;
+        }
+
+        private ProjectCacheDescriptor(
+            ProjectCachePluginBase pluginInstance,
+            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
+            ProjectGraph? projectGraph,
+            IReadOnlyDictionary<string, string>? pluginSettings) : this(entryPoints, projectGraph, pluginSettings)
+        {
+            PluginInstance = pluginInstance;
+        }
+
+        public static ProjectCacheDescriptor FromAssemblyPath(
+            string pluginAssemblyPath,
+            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
+            ProjectGraph? projectGraph,
+            IReadOnlyDictionary<string, string>? pluginSettings = null)
+        {
+            return new ProjectCacheDescriptor(pluginAssemblyPath, entryPoints, projectGraph, pluginSettings);
+        }
+
+        public static ProjectCacheDescriptor FromInstance(
+            ProjectCachePluginBase pluginInstance,
+            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
+            ProjectGraph? projectGraph,
+            IReadOnlyDictionary<string, string>? pluginSettings = null)
+        {
+            return new ProjectCacheDescriptor(pluginInstance, entryPoints, projectGraph, pluginSettings);
+        }
+
+        public string GetDetailedDescription()
+        {
+            var loadStyle = PluginInstance != null
+                ? $"Instance based: {PluginInstance.GetType().AssemblyQualifiedName}"
+                : $"Assembly path based: {PluginAssemblyPath}";
+
+            var entryPointStyle = EntryPoints != null
+                ? "Graph entrypoint based"
+                : "Static graph based";
+
+            var entryPoints = EntryPoints != null
+                ? string.Join(
+                    "\n",
+                    EntryPoints.Select(e => $"{e.ProjectFile} {{{FormatGlobalProperties(e.GlobalProperties)}}}"))
+                : string.Join(
+                    "\n",
+                    ProjectGraph!.EntryPointNodes.Select(
+                        n =>
+                            $"{n.ProjectInstance.FullPath} {{{FormatGlobalProperties(n.ProjectInstance.GlobalProperties)}}}"));
+
+            return $"{loadStyle}\nEntry-point style: {entryPointStyle}\nEntry-points:\n{entryPoints}";
+
+            static string FormatGlobalProperties(IDictionary<string, string>? globalProperties)
+            {
+                return globalProperties == null
+                    ? string.Empty
+                    : string.Join(", ", globalProperties.Select(gp => $"{gp.Key}={gp.Value}"));
+            }
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheItem.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheItem.cs
new file mode 100644
index 00000000000..b1d781b1ca2
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheItem.cs
@@ -0,0 +1,70 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    internal class ProjectCacheItem : IEquatable<ProjectCacheItem>
+    {
+        private readonly IReadOnlyCollection<KeyValuePair<string, string>> _pluginSettingsSorted;
+
+        public ProjectCacheItem(string pluginPath, IReadOnlyDictionary<string, string> pluginSettings)
+        {
+            PluginPath = pluginPath;
+
+            PluginSettings = pluginSettings;
+
+            // Sort by key to avoid doing it during hashcode computation.
+            _pluginSettingsSorted = pluginSettings.OrderBy(_ => _.Key).ToArray();
+        }
+
+        public string PluginPath { get; }
+        public IReadOnlyDictionary<string, string> PluginSettings { get; }
+
+        public bool Equals(ProjectCacheItem? other)
+        {
+            if (ReferenceEquals(this, other))
+            {
+                return true;
+            }
+
+            return PluginPath == other?.PluginPath &&
+                   CollectionHelpers.DictionaryEquals(PluginSettings, other.PluginSettings);
+        }
+
+        public override bool Equals(object? obj)
+        {
+            if (ReferenceEquals(this, obj))
+            {
+                return true;
+            }
+
+            if (obj?.GetType() != GetType())
+            {
+                return false;
+            }
+
+            return Equals((ProjectCacheItem) obj);
+        }
+
+        public override int GetHashCode()
+        {
+            int hashCode = -1043047289;
+
+            hashCode = (hashCode * -1521134295) + PluginPath.GetHashCode();
+
+            foreach (var pluginSetting in _pluginSettingsSorted)
+            {
+                hashCode = (hashCode * -1521134295) + pluginSetting.Key.GetHashCode();
+                hashCode = (hashCode * -1521134295) + pluginSetting.Value.GetHashCode();
+            }
+
+            return hashCode;
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs
new file mode 100644
index 00000000000..2fe895fe150
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs
@@ -0,0 +1,43 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.Execution;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    /// <summary>
+    ///     Only one plugin instance can exist for a given BuildManager BeginBuild / EndBuild session.
+    /// </summary>
+    public abstract class ProjectCachePluginBase
+    {
+        /// <summary>
+        ///     Called once before the build, to have the plugin instantiate its state.
+        ///     Errors are checked via <see cref="PluginLoggerBase.HasLoggedErrors" />.
+        /// </summary>
+        public abstract Task BeginBuildAsync(
+            CacheContext context,
+            PluginLoggerBase logger,
+            CancellationToken cancellationToken);
+
+        /// <summary>
+        ///     Called once for each build request.
+        ///     Operation needs to be atomic. Any side effects (IO, environment variables, etc) need to be reverted upon
+        ///     cancellation.
+        ///     MSBuild may choose to cancel this method and build the project itself.
+        ///     Errors are checked via <see cref="PluginLoggerBase.HasLoggedErrors" />.
+        /// </summary>
+        public abstract Task<CacheResult> GetCacheResultAsync(
+            BuildRequestData buildRequest,
+            PluginLoggerBase logger,
+            CancellationToken cancellationToken);
+
+        /// <summary>
+        ///     Called once after all the build to let the plugin do any post build operations (log metrics, cleanup, etc).
+        ///     Errors are checked via <see cref="PluginLoggerBase.HasLoggedErrors" />.
+        /// </summary>
+        public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
new file mode 100644
index 00000000000..3103b05ddf6
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -0,0 +1,239 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Reflection;
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Execution;
+using Microsoft.Build.FileSystem;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    internal class ProjectCacheService
+    {
+        private readonly BuildManager _buildManager;
+        private readonly PluginLoggerBase _logger;
+        private readonly ProjectCacheDescriptor _projectCacheDescriptor;
+        private readonly CancellationToken _cancellationToken;
+        private readonly ProjectCachePluginBase _projectCachePlugin;
+
+        private ProjectCacheService(
+            ProjectCachePluginBase projectCachePlugin,
+            BuildManager buildManager,
+            PluginLoggerBase logger,
+            ProjectCacheDescriptor projectCacheDescriptor,
+            CancellationToken cancellationToken)
+        {
+            _projectCachePlugin = projectCachePlugin;
+            _buildManager = buildManager;
+            _logger = logger;
+            _projectCacheDescriptor = projectCacheDescriptor;
+            _cancellationToken = cancellationToken;
+        }
+
+        public static async Task<ProjectCacheService> FromDescriptorAsync(
+            ProjectCacheDescriptor pluginDescriptor,
+            BuildManager buildManager,
+            ILoggingService loggingService,
+            CancellationToken cancellationToken)
+        {
+            var plugin = await Task.Run(() => GetPluginInstance(pluginDescriptor), cancellationToken)
+                .ConfigureAwait(false);
+
+            // TODO: Detect and use the highest verbosity from all the user defined loggers. That's tricky because right now we can't discern between user set loggers and msbuild's internally added loggers.
+            var logger = new LoggingServiceToPluginLoggerAdapter(LoggerVerbosity.Normal, loggingService);
+
+            await plugin.BeginBuildAsync(
+                new CacheContext(
+                    pluginDescriptor.PluginSettings,
+                    new IFileSystemAdapter(FileSystems.Default),
+                    pluginDescriptor.ProjectGraph,
+                    pluginDescriptor.EntryPoints),
+                // TODO: Detect verbosity from logging service.
+                logger,
+                cancellationToken);
+
+            if (logger.HasLoggedErrors)
+            {
+                throw new Exception(
+                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectCacheInitializationFailed"));
+            }
+
+            return new ProjectCacheService(plugin, buildManager, logger, pluginDescriptor, cancellationToken);
+        }
+
+        private static ProjectCachePluginBase GetPluginInstance(ProjectCacheDescriptor pluginDescriptor)
+        {
+            if (pluginDescriptor.PluginInstance != null)
+            {
+                return pluginDescriptor.PluginInstance;
+            }
+            if (pluginDescriptor.PluginAssemblyPath != null)
+            {
+                return GetPluginInstanceFromType(GetTypeFromAssemblyPath(pluginDescriptor.PluginAssemblyPath));
+            }
+
+            ErrorUtilities.ThrowInternalErrorUnreachable();
+
+#pragma warning disable CS8603 // Possible null reference return.
+            return null;
+#pragma warning restore CS8603 // Possible null reference return.
+        }
+
+        private static ProjectCachePluginBase GetPluginInstanceFromType(Type pluginType)
+        {
+            try
+            {
+                return (ProjectCachePluginBase) Activator.CreateInstance(pluginType)!;
+            }
+            catch (TargetInvocationException e) when (e.InnerException != null)
+            {
+                throw e.InnerException;
+            }
+        }
+
+        private static Type GetTypeFromAssemblyPath(string pluginAssemblyPath)
+        {
+            var assembly = LoadAssembly(pluginAssemblyPath);
+
+            var type = GetTypes<ProjectCachePluginBase>(assembly).FirstOrDefault();
+
+            ErrorUtilities.VerifyThrow(type != null, "NoProjectCachePluginFoundInAssembly", pluginAssemblyPath);
+
+            return type!;
+
+            Assembly LoadAssembly(string resolverPath)
+            {
+#if !FEATURE_ASSEMBLYLOADCONTEXT
+                return Assembly.LoadFrom(resolverPath);
+#else
+                return _loader.LoadFromPath(resolverPath);
+#endif
+            }
+
+            IEnumerable<Type> GetTypes<T>(Assembly assembly)
+            {
+                return assembly.ExportedTypes
+                    .Select(type => new {type, info = type.GetTypeInfo()})
+                    .Where(
+                        t => t.info.IsClass &&
+                             t.info.IsPublic &&
+                             !t.info.IsAbstract &&
+                             typeof(T).IsAssignableFrom(t.type))
+                    .Select(t => t.type);
+            }
+        }
+
+#if FEATURE_ASSEMBLYLOADCONTEXT
+        private static readonly CoreClrAssemblyLoader _loader = new CoreClrAssemblyLoader();
+#endif
+
+        public async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest)
+        {
+            // TODO: Parent these logs under the project build event so they appear nested under the project in the binlog viewer.
+            var queryDescription = $"{buildRequest.ProjectFullPath}" +
+                                   $"\n\tTargets:[{string.Join(", ", buildRequest.TargetNames)}]" +
+                                   $"\n\tGlobal Properties: {{{string.Join(",", buildRequest.GlobalProperties.Select(kvp => $"{kvp.Name}={kvp.EvaluatedValue}"))}}}";
+
+            _logger.LogMessage(
+                "\n====== Querying project cache for project " + queryDescription,
+                MessageImportance.High);
+
+            var cacheResult = await _projectCachePlugin.GetCacheResultAsync(buildRequest, _logger, _cancellationToken);
+
+            if (_logger.HasLoggedErrors || cacheResult.ResultType == CacheResultType.None)
+            {
+                throw new Exception(
+                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectCacheQueryFailed", queryDescription));
+            }
+
+            var message = $"Plugin result: {cacheResult.ResultType}.";
+
+            switch (cacheResult.ResultType)
+            {
+                case CacheResultType.CacheHit:
+                    message += " Skipping project.";
+                    break;
+                case CacheResultType.CacheMiss:
+                case CacheResultType.CacheNotApplicable:
+                    message += " Building project.";
+                    break;
+                case CacheResultType.None:
+                    break;
+                default:
+                    throw new ArgumentOutOfRangeException();
+            }
+
+            _logger.LogMessage(
+                message,
+                MessageImportance.High);
+
+            return cacheResult;
+        }
+
+        public async Task ShutDown()
+        {
+            await _projectCachePlugin.EndBuildAsync(_logger, _cancellationToken);
+
+            if (_logger.HasLoggedErrors)
+            {
+                throw new Exception(
+                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectCacheShutdownFailed"));
+            }
+        }
+
+        private class LoggingServiceToPluginLoggerAdapter : PluginLoggerBase
+        {
+            private readonly ILoggingService _loggingService;
+
+            public override bool HasLoggedErrors { get; protected set; }
+
+            public LoggingServiceToPluginLoggerAdapter(
+                LoggerVerbosity verbosity,
+                ILoggingService loggingService) : base(verbosity)
+            {
+                _loggingService = loggingService;
+            }
+
+            public override void LogMessage(string message, MessageImportance? messageImportance = null)
+            {
+                _loggingService.LogCommentFromText(
+                    BuildEventContext.Invalid,
+                    messageImportance ?? MessageImportance.Normal,
+                    message);
+            }
+
+            public override void LogWarning(string warning)
+            {
+                _loggingService.LogWarningFromText(
+                    BuildEventContext.Invalid,
+                    null,
+                    null,
+                    null,
+                    BuildEventFileInfo.Empty,
+                    warning);
+            }
+
+            public override void LogError(string error)
+            {
+                HasLoggedErrors = true;
+
+                _loggingService.LogErrorFromText(
+                    BuildEventContext.Invalid,
+                    null,
+                    null,
+                    null,
+                    BuildEventFileInfo.Empty,
+                    error);
+            }
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProxyTargets.cs b/src/Build/BackEnd/Components/ProjectCache/ProxyTargets.cs
new file mode 100644
index 00000000000..6b83993c148
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/ProxyTargets.cs
@@ -0,0 +1,55 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    /// <summary>
+    ///     A cache hit can use this to instruct MSBuild to build the cheaper version of the targets that the plugin avoided
+    ///     running.
+    ///     For example, GetTargetPath is the cheaper version of Build.
+    ///
+    ///     MSBuild will build the proxy targets and assign their target results to the real targets the mapping points to.
+    ///     The proxy targets are left in the build result (i.e., both GetTargetPath and Build will appear in the build result).
+    ///     Real targets can be committed in which case msbuild only keeps the proxy target in the build result.
+    /// </summary>
+    public class ProxyTargets: ITranslatable
+    {
+        private Dictionary<string, string> _proxyTargetToRealTargetMap = null!;
+
+        /// <summary>
+        /// Mapping from proxy targets to real targets. Case insensitive.
+        /// </summary>
+        public IReadOnlyDictionary<string, string> ProxyTargetToRealTargetMap => _proxyTargetToRealTargetMap;
+
+        private ProxyTargets()
+        {
+        }
+
+        public ProxyTargets(IReadOnlyDictionary<string, string> proxyTargetToRealTargetMap)
+        {
+            ErrorUtilities.VerifyThrowArgumentLength(proxyTargetToRealTargetMap, nameof(proxyTargetToRealTargetMap));
+
+            _proxyTargetToRealTargetMap = proxyTargetToRealTargetMap.ToDictionary(kvp => kvp.Key, kvp => kvp.Value, StringComparer.OrdinalIgnoreCase);
+        }
+
+        void ITranslatable.Translate(ITranslator translator)
+        {
+            translator.TranslateDictionary(ref _proxyTargetToRealTargetMap, StringComparer.OrdinalIgnoreCase);
+        }
+
+        internal static ProxyTargets FactoryForDeserialization(ITranslator translator)
+        {
+            var instance = new ProxyTargets();
+            ((ITranslatable) instance).Translate(translator);
+
+            return instance;
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 00512fc9c9b..d5b83a1566c 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -19,6 +19,7 @@
 using System.Linq;
 using System.Threading;
 using System.Threading.Tasks;
+using Microsoft.Build.Experimental.ProjectCache;
 using NodeLoggingContext = Microsoft.Build.BackEnd.Logging.NodeLoggingContext;
 using ProjectLoggingContext = Microsoft.Build.BackEnd.Logging.ProjectLoggingContext;
 
@@ -1019,7 +1020,12 @@ private async Task<BuildResult> BuildProject()
                 // Load the project
                 if (!_requestEntry.RequestConfiguration.IsLoaded)
                 {
-                    LoadProjectIntoConfiguration();
+                    _requestEntry.RequestConfiguration.LoadProjectIntoConfiguration(
+                        _componentHost,
+                        RequestEntry.Request.BuildRequestDataFlags,
+                        RequestEntry.Request.SubmissionId,
+                        _nodeLoggingContext.BuildEventContext.NodeId
+                    );
                 }
             }
             catch
@@ -1078,77 +1084,45 @@ private async Task<BuildResult> BuildProject()
             // Build the targets
             BuildResult result = await _targetBuilder.BuildTargets(_projectLoggingContext, _requestEntry, this, allTargets, _requestEntry.RequestConfiguration.BaseLookup, _cancellationTokenSource.Token);
 
+            result = _requestEntry.Request.ProxyTargets == null
+                ? result
+                : CopyTargetResultsFromProxyTargetsToRealTargets(result);
+
             if (MSBuildEventSource.Log.IsEnabled())
             {
                 MSBuildEventSource.Log.BuildProjectStop(_requestEntry.RequestConfiguration.ProjectFullPath, string.Join(", ", allTargets));
             }
 
             return result;
-        }
-
-        /// <summary>
-        /// Loads the project specified by the configuration's parameters into the configuration block.
-        /// </summary>
-        private void LoadProjectIntoConfiguration()
-        {
-            ErrorUtilities.VerifyThrow(!_requestEntry.RequestConfiguration.IsLoaded, "Already loaded the project for this configuration id {0}.", _requestEntry.RequestConfiguration.ConfigurationId);
-
-            _requestEntry.RequestConfiguration.InitializeProject(_componentHost.BuildParameters, LoadProjectFromFile);
-        }
 
-        private ProjectInstance LoadProjectFromFile()
-        {
-            if (_componentHost.BuildParameters.SaveOperatingEnvironment)
+            BuildResult CopyTargetResultsFromProxyTargetsToRealTargets(BuildResult resultFromTargetBuilder)
             {
-                try
-                {
-                    NativeMethodsShared.SetCurrentDirectory(BuildParameters.StartupDirectory);
-                }
-                catch (DirectoryNotFoundException)
-                {
-                    // Somehow the startup directory vanished. This can happen if build was started from a USB Key and it was removed.
-                    NativeMethodsShared.SetCurrentDirectory(
-                        BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);
-                }
-            }
+                var proxyTargetMapping = _requestEntry.Request.ProxyTargets.ProxyTargetToRealTargetMap;
 
-            Dictionary<string, string> globalProperties = new Dictionary<string, string>(MSBuildNameIgnoreCaseComparer.Default);
+                var resultsCache = (IResultsCache)_componentHost.GetComponent(BuildComponentType.ResultsCache);
+                var cachedResult = resultsCache.GetResultsForConfiguration(_requestEntry.Request.ConfigurationId);
 
-            foreach (ProjectPropertyInstance property in _requestEntry.RequestConfiguration.GlobalProperties)
-            {
-                globalProperties.Add(property.Name, ((IProperty)property).EvaluatedValueEscaped);
-            }
+                // Some proxy targets do not point to real targets. Exclude those.
+                foreach (var proxyMapping in proxyTargetMapping.Where(kvp => kvp.Value != null))
+                {
+                    var proxyTarget = proxyMapping.Key;
+                    var realTarget = proxyMapping.Value;
 
-            string toolsVersionOverride = _requestEntry.RequestConfiguration.ExplicitToolsVersionSpecified ? _requestEntry.RequestConfiguration.ToolsVersion : null;
+                    var proxyTargetResult = resultFromTargetBuilder.ResultsByTarget[proxyTarget];
 
-            // Get the hosted ISdkResolverService.  This returns either the MainNodeSdkResolverService or the OutOfProcNodeSdkResolverService depending on who created the current RequestBuilder
-            ISdkResolverService sdkResolverService = _componentHost.GetComponent(BuildComponentType.SdkResolverService) as ISdkResolverService;
+                    // Update the results cache.
+                    cachedResult.AddResultsForTarget(
+                        realTarget,
+                        proxyTargetResult);
 
-            // Use different project load settings if the build request indicates to do so
-            ProjectLoadSettings projectLoadSettings = _componentHost.BuildParameters.ProjectLoadSettings;
+                    // Update and return this one because TargetBuilder.BuildTargets did some mutations on it not present in the cached result.
+                    resultFromTargetBuilder.AddResultsForTarget(
+                        realTarget,
+                        proxyTargetResult);
+                }
 
-            if (_requestEntry.Request.BuildRequestDataFlags.HasFlag(BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports))
-            {
-                projectLoadSettings |= ProjectLoadSettings.IgnoreMissingImports | ProjectLoadSettings.IgnoreInvalidImports | ProjectLoadSettings.IgnoreEmptyImports;
+                return resultFromTargetBuilder;
             }
-
-            return new ProjectInstance(
-                _requestEntry.RequestConfiguration.ProjectFullPath,
-                globalProperties,
-                toolsVersionOverride,
-                _componentHost.BuildParameters,
-                _nodeLoggingContext.LoggingService,
-                new BuildEventContext(
-                    _requestEntry.Request.SubmissionId,
-                    _nodeLoggingContext.BuildEventContext.NodeId,
-                    BuildEventContext.InvalidEvaluationId,
-                    BuildEventContext.InvalidProjectInstanceId,
-                    BuildEventContext.InvalidProjectContextId,
-                    BuildEventContext.InvalidTargetId,
-                    BuildEventContext.InvalidTaskId),
-                sdkResolverService,
-                _requestEntry.Request.SubmissionId,
-                projectLoadSettings);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index 1ca540e9788..237ea72d01e 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -243,7 +243,7 @@ private void SetResolverState(int submissionId, SdkResolver resolver, object sta
             // Do not set state for resolution requests that are not associated with a valid build submission ID
             if (submissionId != BuildEventContext.InvalidSubmissionId)
             {
-                ConcurrentDictionary<SdkResolver, object> resolverState = _resolverStateBySubmission.GetOrAdd(submissionId, new ConcurrentDictionary<SdkResolver, object>(Environment.ProcessorCount, _resolvers.Count));
+                ConcurrentDictionary<SdkResolver, object> resolverState = _resolverStateBySubmission.GetOrAdd(submissionId, new ConcurrentDictionary<SdkResolver, object>(NativeMethodsShared.GetLogicalCoreCount(), _resolvers.Count));
 
                 resolverState.AddOrUpdate(resolver, state, (sdkResolver, obj) => state);
             }
diff --git a/src/Build/BackEnd/Shared/BuildRequest.cs b/src/Build/BackEnd/Shared/BuildRequest.cs
index 3d72ed52c91..4a0a4efb7f1 100644
--- a/src/Build/BackEnd/Shared/BuildRequest.cs
+++ b/src/Build/BackEnd/Shared/BuildRequest.cs
@@ -3,9 +3,11 @@
 
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Linq;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.ProjectCache;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -55,11 +57,12 @@ internal class BuildRequest : INodePacket
         /// </summary>
         private int _nodeRequestId;
 
-        /// <summary>
-        /// The targets specified when the request was made.  Doesn't include default or initial targets.
-        /// </summary>
+        /// <inheritdoc cref="BuildRequest.Targets"/>
         private List<string> _targets;
 
+        /// <inheritdoc cref="BuildRequest.ProxyTargets"/>
+        private ProxyTargets _proxyTargets;
+
         /// <summary>
         /// The build event context of the parent
         /// </summary>
@@ -87,6 +90,56 @@ internal class BuildRequest : INodePacket
         /// </summary>
         public BuildRequest()
         {
+
+        }
+
+        private BuildRequest(
+            int submissionId,
+            int nodeRequestId,
+            int configurationId,
+            HostServices hostServices,
+            BuildRequestDataFlags buildRequestDataFlags = BuildRequestDataFlags.None,
+            RequestedProjectState requestedProjectState = null)
+        {
+            _submissionId = submissionId;
+            _configurationId = configurationId;
+
+            HostServices = hostServices;
+            _buildEventContext = BuildEventContext.Invalid;
+            _globalRequestId = InvalidGlobalRequestId;
+
+            _nodeRequestId = nodeRequestId;
+            _buildRequestDataFlags = buildRequestDataFlags;
+            _requestedProjectState = requestedProjectState;
+        }
+
+        /// <summary>
+        /// Initializes a build request with a parent context.
+        /// </summary>
+        /// <param name="submissionId">The id of the build submission.</param>
+        /// <param name="nodeRequestId">The id of the node issuing the request</param>
+        /// <param name="configurationId">The configuration id to use.</param>
+        /// <param name="proxyTargets"><see cref="ProxyTargets"/></param>
+        /// <param name="hostServices">Host services if any. May be null.</param>
+        /// <param name="buildRequestDataFlags">Additional flags for the request.</param>
+        /// <param name="requestedProjectState">Filter for desired build results.</param>
+        public BuildRequest(
+            int submissionId,
+            int nodeRequestId,
+            int configurationId,
+            ProxyTargets proxyTargets,
+            HostServices hostServices,
+            BuildRequestDataFlags buildRequestDataFlags = BuildRequestDataFlags.None,
+            RequestedProjectState requestedProjectState = null)
+            : this(submissionId, nodeRequestId, configurationId, hostServices, buildRequestDataFlags,
+                requestedProjectState)
+        {
+            _proxyTargets = proxyTargets;
+            _targets = proxyTargets.ProxyTargetToRealTargetMap.Keys.ToList();
+
+            // Only root requests can have proxy targets.
+            _parentGlobalRequestId = InvalidGlobalRequestId;
+            _parentBuildEventContext = BuildEventContext.Invalid;
         }
 
         /// <summary>
@@ -113,13 +166,11 @@ public BuildRequest(
             BuildRequestDataFlags buildRequestDataFlags = BuildRequestDataFlags.None,
             RequestedProjectState requestedProjectState = null,
             bool skipStaticGraphIsolationConstraints = false)
+        : this(submissionId, nodeRequestId, configurationId, hostServices, buildRequestDataFlags, requestedProjectState)
         {
             ErrorUtilities.VerifyThrowArgumentNull(escapedTargets, "targets");
             ErrorUtilities.VerifyThrowArgumentNull(parentBuildEventContext, nameof(parentBuildEventContext));
 
-            _submissionId = submissionId;
-            _configurationId = configurationId;
-
             // When targets come into a build request, we unescape them.
             _targets = new List<string>(escapedTargets.Count);
             foreach (string target in escapedTargets)
@@ -127,16 +178,9 @@ public BuildRequest(
                 _targets.Add(EscapingUtilities.UnescapeAll(target));
             }
 
-            HostServices = hostServices;
-            _buildEventContext = BuildEventContext.Invalid;
             _parentBuildEventContext = parentBuildEventContext;
-            _globalRequestId = InvalidGlobalRequestId;
             _parentGlobalRequestId = parentRequest?.GlobalRequestId ?? InvalidGlobalRequestId;
 
-            _nodeRequestId = nodeRequestId;
-            _buildRequestDataFlags = buildRequestDataFlags;
-            _requestedProjectState = requestedProjectState;
-
             _skipStaticGraphIsolationConstraints = skipStaticGraphIsolationConstraints;
         }
 
@@ -221,7 +265,8 @@ public int NodeRequestId
         }
 
         /// <summary>
-        /// Returns the set of unescaped targets to be built
+        /// The targets specified when the request was made.  Doesn't include default or initial targets.
+        /// Either this is null or <see cref="ProxyTargets"/> is null;
         /// </summary>
         public List<string> Targets
         {
@@ -230,6 +275,16 @@ public List<string> Targets
             { return _targets; }
         }
 
+        /// <summary>
+        /// See <see cref="ProxyTargets"/>. Either this is null, or <see cref="_targets"/> is null;
+        /// </summary>
+        public ProxyTargets ProxyTargets
+        {
+            [DebuggerStepThrough]
+            get
+            { return _proxyTargets; }
+        }
+
         /// <summary>
         /// Returns the type of packet.
         /// </summary>
@@ -350,6 +405,7 @@ public void Translate(ITranslator translator)
             translator.Translate(ref _skipStaticGraphIsolationConstraints);
             translator.Translate(ref _requestedProjectState);
             translator.Translate(ref _hostServices);
+            translator.Translate(ref _proxyTargets, ProxyTargets.FactoryForDeserialization);
 
             // UNDONE: (Compat) Serialize the host object.
         }
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index feb27293007..97f9531e074 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -10,7 +10,9 @@
 using System.Diagnostics;
 using System.IO;
 using System.Linq;
+using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Globbing;
 using Microsoft.Build.Shared.FileSystem;
 
@@ -417,7 +419,74 @@ private void SetProjectBasedState(ProjectInstance project)
             }
         }
 
-        public void InitializeProject(BuildParameters buildParameters, Func<ProjectInstance> loadProjectFromFile)
+        /// <summary>
+        /// Loads the project specified by the configuration's parameters into the configuration block.
+        /// </summary>
+        internal void LoadProjectIntoConfiguration(
+            IBuildComponentHost componentHost,
+            BuildRequestDataFlags buildRequestDataFlags,
+            int submissionId,
+            int nodeId)
+        {
+            ErrorUtilities.VerifyThrow(!IsLoaded, "Already loaded the project for this configuration id {0}.", ConfigurationId);
+
+            InitializeProject(componentHost.BuildParameters, () =>
+            {
+                if (componentHost.BuildParameters.SaveOperatingEnvironment)
+                {
+                    try
+                    {
+                        NativeMethodsShared.SetCurrentDirectory(BuildParameters.StartupDirectory);
+                    }
+                    catch (DirectoryNotFoundException)
+                    {
+                        // Somehow the startup directory vanished. This can happen if build was started from a USB Key and it was removed.
+                        NativeMethodsShared.SetCurrentDirectory(
+                            BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);
+                    }
+                }
+
+                Dictionary<string, string> globalProperties = new Dictionary<string, string>(MSBuildNameIgnoreCaseComparer.Default);
+
+                foreach (ProjectPropertyInstance property in GlobalProperties)
+                {
+                    globalProperties.Add(property.Name, ((IProperty)property).EvaluatedValueEscaped);
+                }
+
+                string toolsVersionOverride = ExplicitToolsVersionSpecified ? ToolsVersion : null;
+
+                // Get the hosted ISdkResolverService.  This returns either the MainNodeSdkResolverService or the OutOfProcNodeSdkResolverService depending on who created the current RequestBuilder
+                ISdkResolverService sdkResolverService = componentHost.GetComponent(BuildComponentType.SdkResolverService) as ISdkResolverService;
+
+                // Use different project load settings if the build request indicates to do so
+                ProjectLoadSettings projectLoadSettings = componentHost.BuildParameters.ProjectLoadSettings;
+
+                if (buildRequestDataFlags.HasFlag(BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports))
+                {
+                    projectLoadSettings |= ProjectLoadSettings.IgnoreMissingImports | ProjectLoadSettings.IgnoreInvalidImports | ProjectLoadSettings.IgnoreEmptyImports;
+                }
+
+                return new ProjectInstance(
+                    ProjectFullPath,
+                    globalProperties,
+                    toolsVersionOverride,
+                    componentHost.BuildParameters,
+                    componentHost.LoggingService,
+                    new BuildEventContext(
+                        submissionId,
+                        nodeId,
+                        BuildEventContext.InvalidEvaluationId,
+                        BuildEventContext.InvalidProjectInstanceId,
+                        BuildEventContext.InvalidProjectContextId,
+                        BuildEventContext.InvalidTargetId,
+                        BuildEventContext.InvalidTaskId),
+                    sdkResolverService,
+                    submissionId,
+                    projectLoadSettings);
+            });
+        }
+
+        private void InitializeProject(BuildParameters buildParameters, Func<ProjectInstance> loadProjectFromFile)
         {
             if (_project == null || // building from file. Load project from file
                 _transferredProperties != null // need to overwrite particular properties, so load project from file and overwrite properties
@@ -664,6 +733,13 @@ public List<string> GetTargetsUsedToBuildRequest(BuildRequest request)
             ErrorUtilities.VerifyThrow(_projectInitialTargets != null, "Initial targets have not been set.");
             ErrorUtilities.VerifyThrow(_projectDefaultTargets != null, "Default targets have not been set.");
 
+            if (request.ProxyTargets != null)
+            {
+                ErrorUtilities.VerifyThrow(
+                    CollectionHelpers.SetEquivalent(request.Targets, request.ProxyTargets.ProxyTargetToRealTargetMap.Keys),
+                    "Targets must be same as proxy targets");
+            }
+
             List<string> initialTargets = _projectInitialTargets;
             List<string> nonInitialTargets = (request.Targets.Count == 0) ? _projectDefaultTargets : request.Targets;
 
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index b5bf9d3706d..ec989c4e92d 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -464,6 +464,12 @@ public void AddResultsForTarget(string target, TargetResult result)
         {
             ErrorUtilities.VerifyThrowArgumentNull(target, nameof(target));
             ErrorUtilities.VerifyThrowArgumentNull(result, nameof(result));
+
+            lock (this)
+            {
+                _resultsByTarget ??= CreateTargetResultDictionary(1);
+            }
+
             if (_resultsByTarget.ContainsKey(target))
             {
                 ErrorUtilities.VerifyThrow(_resultsByTarget[target].ResultCode == TargetResultCode.Skipped, "Items already exist for target {0}.", target);
diff --git a/src/Build/BackEnd/Shared/CircularDependencyException.cs b/src/Build/BackEnd/Shared/CircularDependencyException.cs
index 149c7dd46ba..d8765b2e968 100644
--- a/src/Build/BackEnd/Shared/CircularDependencyException.cs
+++ b/src/Build/BackEnd/Shared/CircularDependencyException.cs
@@ -4,7 +4,7 @@
 using System;
 using System.Runtime.Serialization;
 
-namespace Microsoft.Build.BackEnd
+namespace Microsoft.Build.Exceptions
 {
     /// <summary>
     /// An exception representing the case where a BuildRequest has caused a circular project dependency.  This is used to
@@ -14,7 +14,7 @@ namespace Microsoft.Build.BackEnd
     /// If you add fields to this class, add a custom serialization constructor and override GetObjectData().
     /// </remarks>
     [Serializable]
-    internal class CircularDependencyException : Exception
+    public class CircularDependencyException : Exception
     {
         /// <summary>
         /// Constructs a standard BuildAbortedException.
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 2a98b2fdf32..9a329a707b5 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -1098,13 +1098,30 @@ out parameterSet
                 else
                 {
                     // flag an error if we find a parameter that has no .NET property equivalent
-                    _taskLoggingContext.LogError
-                        (
-                        new BuildEventFileInfo(parameterLocation),
-                        "UnexpectedTaskAttribute",
-                        parameterName,
-                        _taskName
-                        );
+                    if (_taskFactoryWrapper.TaskFactoryLoadedType.LoadedAssembly is null)
+                    {
+                        _taskLoggingContext.LogError
+                            (
+                            new BuildEventFileInfo( parameterLocation ),
+                            "UnexpectedTaskAttribute",
+                            parameterName,
+                            _taskName,
+                            _taskFactoryWrapper.TaskFactoryLoadedType.Type.Assembly.FullName,
+                            _taskFactoryWrapper.TaskFactoryLoadedType.Type.Assembly.Location
+                            );
+                    }
+                    else
+                    {
+                        _taskLoggingContext.LogError
+                            (
+                            new BuildEventFileInfo( parameterLocation ),
+                            "UnexpectedTaskAttribute",
+                            parameterName,
+                            _taskName,
+                            _taskFactoryWrapper.TaskFactoryLoadedType.LoadedAssembly.FullName,
+                            _taskFactoryWrapper.TaskFactoryLoadedType.LoadedAssembly.Location
+                            );
+                    }
                 }
             }
             catch (AmbiguousMatchException)
diff --git a/src/Build/Construction/ProjectItemElement.cs b/src/Build/Construction/ProjectItemElement.cs
index 8e6bbd2ffa8..dd7f7f6ea6c 100644
--- a/src/Build/Construction/ProjectItemElement.cs
+++ b/src/Build/Construction/ProjectItemElement.cs
@@ -171,7 +171,7 @@ public string Update
         }
 
         /// <summary>
-        /// Gets of sets the MatchOnMetadata value.
+        /// Gets or sets the MatchOnMetadata value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty or null.
         /// </summary>
@@ -194,7 +194,7 @@ public string MatchOnMetadata
         }
 
         /// <summary>
-        /// Gets of sets the MatchOnMetadataOptions value.
+        /// Gets or sets the MatchOnMetadataOptions value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty or null.
         /// </summary>
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index 94e72cf546c..08a7def219e 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -94,6 +94,7 @@ public sealed class ProjectInSolution
         #endregion
         #region Member data
         private string _relativePath;         // Relative from .SLN file.  For example, "WindowsApplication1\WindowsApplication1.csproj"
+        private string _absolutePath;         // Absolute path to the project file
         private readonly List<string> _dependencies;     // A list of strings representing the Guids of the dependent projects.
         private IReadOnlyList<string> _dependenciesAsReadonly;
         private string _uniqueProjectName;    // For example, "MySlnFolder\MySubSlnFolder\Windows_Application1"
@@ -153,8 +154,7 @@ internal set
                 // cases. It caused https://github.com/NuGet/Home/issues/6918.
                 _relativePath = value;
 #else
-                _relativePath = FileUtilities.MaybeAdjustFilePath(value,
-                                                    baseDirectory:ParentSolution.SolutionFileDirectory ?? String.Empty);
+                _relativePath = FileUtilities.MaybeAdjustFilePath(value, ParentSolution.SolutionFileDirectory);
 #endif
             }
         }
@@ -162,7 +162,22 @@ internal set
         /// <summary>
         /// Returns the absolute path for this project
         /// </summary>
-        public string AbsolutePath => Path.Combine(ParentSolution.SolutionFileDirectory, RelativePath);
+        public string AbsolutePath
+        {
+            get
+            {
+                if (_absolutePath == null)
+                {
+#if NETFRAMEWORK && !MONO
+                    _absolutePath = Path.GetFullPath(Path.Combine(ParentSolution.SolutionFileDirectory, _relativePath));
+#else
+                    _absolutePath = FileUtilities.NormalizePath(Path.Combine(ParentSolution.SolutionFileDirectory, _relativePath));
+#endif
+                }
+
+                return _absolutePath;
+            }
+        }
 
         /// <summary>
         /// The unique guid associated with this project, in "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" form
@@ -214,9 +229,9 @@ public IReadOnlyDictionary<string, ProjectConfigurationInSolution> ProjectConfig
 
         internal string TargetFrameworkMoniker { get; set; }
 
-        #endregion
+#endregion
 
-        #region Methods
+#region Methods
 
         private bool _checkedIfCanBeMSBuildProjectFile;
         private bool _canBeMSBuildProjectFile;
@@ -514,13 +529,13 @@ private static bool ElementContainsInvalidNamespaceDefitions(XmlElement mainProj
             return false;
         }
 
-        #endregion
+#endregion
 
-        #region Constants
+#region Constants
 
         internal const int DependencyLevelUnknown = -1;
         internal const int DependencyLevelBeingDetermined = -2;
 
-        #endregion
+#endregion
     }
 }
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 2ea517136d9..c365c1ee730 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -210,6 +210,8 @@ internal string FullPath
                 {
                     _solutionFile = value;
                     _solutionFilter = null;
+
+                    SolutionFileDirectory = Path.GetDirectoryName(_solutionFile);
                 }
             }
         }
@@ -381,6 +383,9 @@ private void ParseSolutionFilter(string solutionFilterFile)
                         _solutionFile
                     );
                 }
+
+                SolutionFileDirectory = Path.GetDirectoryName(_solutionFile);
+
                 _solutionFilter = new HashSet<string>(NativeMethodsShared.OSUsesCaseSensitivePaths ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
                 foreach (JsonElement project in solution.GetProperty("projects").EnumerateArray())
                 {
@@ -475,8 +480,6 @@ internal void ParseSolutionFile()
             {
                 // Open the file
                 fileStream = File.OpenRead(_solutionFile);
-                // Store the directory of the file as the current directory may change while we are processes the file
-                SolutionFileDirectory = Path.GetDirectoryName(_solutionFile);
                 SolutionReader = new StreamReader(fileStream, Encoding.GetEncoding(0)); // HIGHCHAR: If solution files have no byte-order marks, then assume ANSI rather than ASCII.
                 ParseSolution();
             }
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index e935b5cc18d..d26fca3b0d3 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -28,6 +28,8 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Utilities;
 
+using Microsoft.NET.StringTools;
+
 namespace Microsoft.Build.Construction
 {
     /// <summary>
@@ -1097,7 +1099,7 @@ private static string GetConfigurationAndPlatformPropertiesString(ProjectConfigu
         /// </summary>
         private static string GetPropertiesAttributeForDirectMSBuildTask(ProjectConfigurationInSolution projectConfiguration)
         {
-            string directProjectProperties = OpportunisticIntern.InternStringIfPossible(String.Join(";", GetConfigurationAndPlatformPropertiesString(projectConfiguration), SolutionProperties));
+            string directProjectProperties = Strings.WeakIntern(String.Join(";", GetConfigurationAndPlatformPropertiesString(projectConfiguration), SolutionProperties));
             return directProjectProperties;
         }
 
@@ -1343,7 +1345,7 @@ private static void AddProjectBuildTask(ProjectInstance traversalProject, Projec
         /// </summary>
         private void AddMetaprojectBuildTask(ProjectInSolution project, ProjectTargetInstance target, string targetToBuild, string outputItem)
         {
-            ProjectTaskInstance task = target.AddTask("MSBuild", OpportunisticIntern.InternStringIfPossible("'%(ProjectReference.Identity)' == '" + GetMetaprojectName(project) + "'"), String.Empty);
+            ProjectTaskInstance task = target.AddTask("MSBuild", Strings.WeakIntern("'%(ProjectReference.Identity)' == '" + GetMetaprojectName(project) + "'"), String.Empty);
             task.SetParameter("Projects", "@(ProjectReference)");
 
             if (targetToBuild != null)
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 8d48735d241..285c4cc592a 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -42,9 +42,7 @@ namespace Microsoft.Build.Evaluation
     /// Always backed by XML; can be built directly, or an instance can be cloned off to add virtual items/properties and build.
     /// Edits to this project always update the backing XML.
     /// </summary>
-    /// <remarks>
-    /// UNDONE: (Multiple configurations.) Protect against problems when attempting to edit, after edits were made to the same ProjectRootElement either directly or through other projects evaluated from that ProjectRootElement.
-    /// </remarks>
+    // UNDONE: (Multiple configurations.) Protect against problems when attempting to edit, after edits were made to the same ProjectRootElement either directly or through other projects evaluated from that ProjectRootElement.
     [DebuggerDisplay("{FullPath} EffectiveToolsVersion={ToolsVersion} #GlobalProperties={_data.GlobalPropertiesDictionary.Count} #Properties={_data.Properties.Count} #ItemTypes={_data.ItemTypes.Count} #ItemDefinitions={_data.ItemDefinitions.Count} #Items={_data.Items.Count} #Targets={_data.Targets.Count}")]
     public class Project : ILinkableObject
     {
@@ -262,11 +260,11 @@ private Project(ProjectRootElement xml, IDictionary<string, string> globalProper
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
             ErrorUtilities.VerifyThrowArgumentNull(projectCollection, nameof(projectCollection));
             ProjectCollection = projectCollection;
-            var defailtImplementation = new ProjectImpl(this, xml, globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
-            implementationInternal = (IProjectLinkInternal)defailtImplementation;
-            implementation = defailtImplementation;
+            var defaultImplementation = new ProjectImpl(this, xml, globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+            implementationInternal = (IProjectLinkInternal)defaultImplementation;
+            implementation = defaultImplementation;
 
-            defailtImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+            defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
         }
 
         /// <summary>
@@ -1331,7 +1329,7 @@ public ProjectInstance CreateProjectInstance()
         /// access concurrently from multiple threads.
         /// </summary>
         /// <param name="settings">The project instance creation settings.</param>
-        /// <returns>the created project instance.</returns>
+        /// <returns>The created project instance.</returns>
         public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings)
         {
             return CreateProjectInstance(settings, null);
@@ -1342,7 +1340,7 @@ public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings)
         /// </summary>
         /// <param name="settings">The project instance creation settings.</param>
         /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
-        /// <returns>the created project instance.</returns>
+        /// <returns>The created project instance.</returns>
         public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings, EvaluationContext evaluationContext)
         {
             return implementation.CreateProjectInstance(settings, evaluationContext);
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 5ef5fdfe6e8..ec52f815e3d 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -582,9 +582,9 @@ public int Count
         /// <summary>
         /// Loggers that all contained projects will use for their builds.
         /// Loggers are added with the <see cref="RegisterLogger"/>.
-        /// UNDONE: Currently they cannot be removed.
         /// Returns an empty collection if there are no loggers.
         /// </summary>
+        // UNDONE: Currently loggers cannot be removed.
         public ICollection<ILogger> Loggers
         {
             [DebuggerStepThrough]
@@ -1465,10 +1465,10 @@ public bool RemoveGlobalProperty(string name)
 
         /// <summary>
         /// Called when a host is completely done with the project collection.
-        /// UNDONE: This is a hack to make sure the logging thread shuts down if the build used the logging service
-        /// off the ProjectCollection. After CTP we need to rationalize this and see if we can remove the logging service from
-        /// the project collection entirely so this isn't necessary.
         /// </summary>
+        // UNDONE: This is a hack to make sure the logging thread shuts down if the build used the logging service
+        // off the ProjectCollection. After CTP we need to rationalize this and see if we can remove the logging service from
+        // the project collection entirely so this isn't necessary.
         public void Dispose()
         {
             Dispose(true);
diff --git a/src/Build/Definition/ProjectItem.cs b/src/Build/Definition/ProjectItem.cs
index 220cd07daba..0b3c28e1562 100644
--- a/src/Build/Definition/ProjectItem.cs
+++ b/src/Build/Definition/ProjectItem.cs
@@ -25,7 +25,7 @@ namespace Microsoft.Build.Evaluation
     /// we do use it for build-time items.
     /// </comment>
     [DebuggerDisplay("{ItemType}={EvaluatedInclude} [{UnevaluatedInclude}] #DirectMetadata={DirectMetadataCount}")]
-    public class ProjectItem : IKeyed, IItem<ProjectMetadata>, IMetadataTable, IProjectMetadataParent
+    public class ProjectItem : IItem<ProjectMetadata>, IProjectMetadataParent
     {
         /// <summary>
         /// Project that this item lives in.
@@ -280,6 +280,8 @@ public ICollection<ProjectMetadata> Metadata
             { return Link != null ? Link.MetadataCollection : MetadataCollection; }
         }
 
+        IEnumerable<ProjectMetadata> IItem<ProjectMetadata>.Metadata => Metadata;
+
         /// <summary>
         /// Count of metadata on this item, if any.
         /// Includes any metadata inherited from item definitions.
diff --git a/src/Build/Definition/ProjectMetadata.cs b/src/Build/Definition/ProjectMetadata.cs
index 7bf9f740605..2e5f4c958ae 100644
--- a/src/Build/Definition/ProjectMetadata.cs
+++ b/src/Build/Definition/ProjectMetadata.cs
@@ -18,7 +18,7 @@ namespace Microsoft.Build.Evaluation
     /// Never used to represent built-in metadata, like %(Filename). There is always a backing XML object.
     /// </remarks>
     [DebuggerDisplay("{Name}={EvaluatedValue} [{_xml.Value}]")]
-    public class ProjectMetadata : IKeyed, IValued, IEquatable<ProjectMetadata>, IMetadatum
+    public class ProjectMetadata : IEquatable<ProjectMetadata>, IMetadatum
     {
         /// <summary>
         /// Parent item or item definition that this metadatum lives in.
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index fc08972debb..a4e4d21565b 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -35,9 +35,7 @@ namespace Microsoft.Build.Evaluation
     /// Aggregation of a toolset version (eg. "2.0"), tools path, and optional set of associated properties.
     /// Toolset is immutable.
     /// </summary>
-    /// <remarks>
-    /// UNDONE: Review immutability. If this is not immutable, add a mechanism to notify the project collection/s owning it to increment their toolsetVersion.
-    /// </remarks>
+    // UNDONE: Review immutability. If this is not immutable, add a mechanism to notify the project collection/s owning it to increment their toolsetVersion.
     [DebuggerDisplay("ToolsVersion={ToolsVersion} ToolsPath={ToolsPath} #Properties={_properties.Count}")]
     public class Toolset : ITranslatable
     {
diff --git a/src/Build/Errors/InternalLoggerException.cs b/src/Build/Errors/InternalLoggerException.cs
index d1872605c82..7a1e0aa25ad 100644
--- a/src/Build/Errors/InternalLoggerException.cs
+++ b/src/Build/Errors/InternalLoggerException.cs
@@ -16,11 +16,9 @@ namespace Microsoft.Build.Exceptions
     /// This exception is used to wrap an unhandled exception from a logger. This exception aborts the build, and it can only be
     /// thrown by the MSBuild engine.
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
     public sealed class InternalLoggerException : Exception
     {
diff --git a/src/Build/Errors/InvalidProjectFileException.cs b/src/Build/Errors/InvalidProjectFileException.cs
index ce0835ec396..6588acce0b8 100644
--- a/src/Build/Errors/InvalidProjectFileException.cs
+++ b/src/Build/Errors/InvalidProjectFileException.cs
@@ -15,11 +15,9 @@ namespace Microsoft.Build.Exceptions
     /// This exception is thrown whenever there is a problem with the user's XML project file. The problem might be semantic or
     /// syntactical. The latter would be of a type typically caught by XSD validation (if it was performed by the project writer).
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
     public sealed class InvalidProjectFileException : Exception
     {
diff --git a/src/Build/Evaluation/Conditionals/IItem.cs b/src/Build/Evaluation/Conditionals/IItem.cs
index c59074f73f1..000aacf9c0a 100644
--- a/src/Build/Evaluation/Conditionals/IItem.cs
+++ b/src/Build/Evaluation/Conditionals/IItem.cs
@@ -1,6 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System.Collections.Generic;
 using Microsoft.Build.Construction;
 
 namespace Microsoft.Build.Evaluation
@@ -25,5 +26,7 @@ internal interface IItem<M> : IItem
         /// Predecessor is any preceding overridden metadata
         /// </summary>
         M SetMetadata(ProjectMetadataElement metadataElement, string evaluatedValue);
+
+        IEnumerable<M> Metadata { get; }
     }
 }
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index e385eece4e5..5df077fe418 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
 using ObjectModel = System.Collections.ObjectModel;
 using System.Diagnostics;
@@ -17,6 +18,7 @@
 using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Internal;
@@ -624,7 +626,7 @@ private void Evaluate()
                 }
 
                 _data.InitialTargets = initialTargets;
-                MSBuildEventSource.Log.EvaluatePass1Stop(projectFile);
+                MSBuildEventSource.Log.EvaluatePass1Stop(projectFile, _projectRootElement.Properties.Count, _projectRootElement.Imports.Count);
                 // Pass2: evaluate item definitions
                 // Don't box via IEnumerator and foreach; cache count so not to evaluate via interface each iteration
                 MSBuildEventSource.Log.EvaluatePass2Start(projectFile);
@@ -638,7 +640,7 @@ private void Evaluate()
                         }
                     }
                 }
-                MSBuildEventSource.Log.EvaluatePass2Stop(projectFile);
+                MSBuildEventSource.Log.EvaluatePass2Stop(projectFile, _itemDefinitionGroupElements.Count);
                 LazyItemEvaluator<P, I, M, D> lazyEvaluator = null;
                 using (_evaluationProfiler.TrackPass(EvaluationPass.Items))
                 {
@@ -681,7 +683,7 @@ private void Evaluate()
                     lazyEvaluator = null;
                 }
 
-                MSBuildEventSource.Log.EvaluatePass3Stop(projectFile);
+                MSBuildEventSource.Log.EvaluatePass3Stop(projectFile, _itemGroupElements.Count);
 
                 // Pass4: evaluate using-tasks
                 MSBuildEventSource.Log.EvaluatePass4Start(projectFile);
@@ -711,7 +713,7 @@ private void Evaluate()
                 Dictionary<string, List<TargetSpecification>> targetsWhichRunAfterByTarget = new Dictionary<string, List<TargetSpecification>>(StringComparer.OrdinalIgnoreCase);
                 LinkedList<ProjectTargetElement> activeTargetsByEvaluationOrder = new LinkedList<ProjectTargetElement>();
                 Dictionary<string, LinkedListNode<ProjectTargetElement>> activeTargets = new Dictionary<string, LinkedListNode<ProjectTargetElement>>(StringComparer.OrdinalIgnoreCase);
-                MSBuildEventSource.Log.EvaluatePass4Stop(projectFile);
+                MSBuildEventSource.Log.EvaluatePass4Stop(projectFile, _usingTaskElements.Count);
 
                 using (_evaluationProfiler.TrackPass(EvaluationPass.Targets))
                 {
@@ -737,6 +739,12 @@ private void Evaluate()
                     _data.BeforeTargets = targetsWhichRunBeforeByTarget;
                     _data.AfterTargets = targetsWhichRunAfterByTarget;
 
+                    if (BuildEnvironmentHelper.Instance.RunningInVisualStudio)
+                    {
+                        // TODO: Remove this when VS gets updated to setup project cache plugins.
+                        CollectProjectCachePlugins();
+                    }
+
                     if (Traits.Instance.EscapeHatches.DebugEvaluation)
                     {
                         // This is so important for VS performance it's worth always tracing; accidentally having 
@@ -764,7 +772,7 @@ private void Evaluate()
                     }
 
                     _data.FinishEvaluation();
-                    MSBuildEventSource.Log.EvaluatePass5Stop(projectFile);
+                    MSBuildEventSource.Log.EvaluatePass5Stop(projectFile, targetElementsCount);
                 }
             }
 
@@ -777,6 +785,20 @@ private void Evaluate()
             });
         }
 
+        private void CollectProjectCachePlugins()
+        {
+            foreach (var item in _data.GetItems(ItemTypeNames.ProjectCachePlugin))
+            {
+                var metadataDictionary = item.Metadata.ToDictionary(m => m.Key, m => m.EscapedValue);
+
+                var pluginPath = Path.Combine(_data.Directory, item.EvaluatedInclude);
+
+                var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);
+
+                BuildManager.ProjectCacheItems[pluginPath] = projectCacheItem;
+            }
+        }
+
         /// <summary>
         /// Evaluate the properties in the passed in XML, into the project.
         /// Does a depth first traversal into Imports.
@@ -1052,18 +1074,15 @@ private void AddBeforeAndAfterTargetMappings(ProjectTargetElement targetElement,
 
         private void ValidateChangeWaveState()
         {
-            if (ChangeWaves.ConversionState == ChangeWaveConversionState.NotConvertedYet)
-            {
-                ChangeWaves.ApplyChangeWave();
-            }
+            ChangeWaves.ApplyChangeWave();
 
             switch (ChangeWaves.ConversionState)
             {
                 case ChangeWaveConversionState.InvalidFormat:
-                    _evaluationLoggingContext.LogWarning("", new BuildEventFileInfo(""), "ChangeWave_InvalidFormat", Traits.Instance.MSBuildDisableFeaturesFromVersion);
+                    _evaluationLoggingContext.LogWarning("", new BuildEventFileInfo(""), "ChangeWave_InvalidFormat", Traits.Instance.MSBuildDisableFeaturesFromVersion, $"[{String.Join(", ", ChangeWaves.AllWaves.Select(x => x.ToString()))}]");
                     break;
                 case ChangeWaveConversionState.OutOfRotation:
-                    _evaluationLoggingContext.LogWarning("", new BuildEventFileInfo(""), "ChangeWave_OutOfRotation", ChangeWaves.DisabledWave, Traits.Instance.MSBuildDisableFeaturesFromVersion);
+                    _evaluationLoggingContext.LogWarning("", new BuildEventFileInfo(""), "ChangeWave_OutOfRotation", ChangeWaves.DisabledWave, Traits.Instance.MSBuildDisableFeaturesFromVersion, $"[{String.Join(", ", ChangeWaves.AllWaves.Select(x => x.ToString()))}]");
                     break;
             }
         }
@@ -1086,7 +1105,7 @@ private void AddBuiltInProperties()
 
             ValidateChangeWaveState();
 
-            SetBuiltInProperty(ReservedPropertyNames.msbuilddisablefeaturesfromversion, ChangeWaves.DisabledWave);
+            SetBuiltInProperty(ReservedPropertyNames.msbuilddisablefeaturesfromversion, ChangeWaves.DisabledWave.ToString());
 
             // Fake OS env variables when not on Windows
             if (!NativeMethodsShared.IsWindows)
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index d933594e66b..ad43ca4dc2a 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -1,4 +1,4 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
@@ -24,6 +24,8 @@
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using TaskItemFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory;
 
+using Microsoft.NET.StringTools;
+
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
@@ -586,16 +588,12 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in
         /// Add the argument in the StringBuilder to the arguments list, handling nulls
         /// appropriately.
         /// </summary>
-        private static void AddArgument(List<string> arguments, ReuseableStringBuilder argumentBuilder)
+        private static void AddArgument(List<string> arguments, SpanBasedStringBuilder argumentBuilder)
         {
-            // If we don't have something that can be treated as an argument
-            // then we should treat it as a null so that passing nulls
-            // becomes possible through an empty argument between commas.
-            ErrorUtilities.VerifyThrowArgumentNull(argumentBuilder, nameof(argumentBuilder));
-
             // we reached the end of an argument, add the builder's final result
-            // to our arguments. 
-            string argValue = OpportunisticIntern.InternableToString(argumentBuilder).Trim();
+            // to our arguments.
+            argumentBuilder.Trim();
+            string argValue = argumentBuilder.ToString();
 
             // We support passing of null through the argument constant value null
             if (String.Equals("null", argValue, StringComparison.OrdinalIgnoreCase))
@@ -642,69 +640,81 @@ private static string[] ExtractFunctionArguments(IElementLocation elementLocatio
 
             List<string> arguments = new List<string>();
 
-            // With the reuseable string builder, there's no particular need to initialize the length as it will already have grown.
-            using (var argumentBuilder = new ReuseableStringBuilder())
+            using SpanBasedStringBuilder argumentBuilder = Strings.GetSpanBasedStringBuilder();
+            int? argumentStartIndex = null;
+
+            // We iterate over the string in the for loop below. When we find an argument, instead of adding it to the argument
+            // builder one-character-at-a-time, we remember the start index and then call this function when we find the end of
+            // the argument. This appends the entire {start, end} span to the builder in one call.
+            void FlushCurrentArgumentToArgumentBuilder(int argumentEndIndex)
             {
-                unsafe
+                if (argumentStartIndex.HasValue)
                 {
-                    fixed (char* argumentsContent = argumentsString)
-                    {
-                        // Iterate over the contents of the arguments extracting the
-                        // the individual arguments as we go
-                        for (int n = 0; n < argumentsContentLength; n++)
-                        {
-                            // We found a property expression.. skip over all of it.
-                            if ((n < argumentsContentLength - 1) && (argumentsContent[n] == '$' && argumentsContent[n + 1] == '('))
-                            {
-                                int nestedPropertyStart = n;
-                                n += 2; // skip over the opening '$('
-
-                                // Scan for the matching closing bracket, skipping any nested ones
-                                n = ScanForClosingParenthesis(argumentsString, n);
+                    argumentBuilder.Append(argumentsString, argumentStartIndex.Value, argumentEndIndex - argumentStartIndex.Value);
+                    argumentStartIndex = null;
+                }
+            }
 
-                                if (n == -1)
-                                {
-                                    ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "InvalidFunctionPropertyExpression", expressionFunction, AssemblyResources.GetString("InvalidFunctionPropertyExpressionDetailMismatchedParenthesis"));
-                                }
+            // Iterate over the contents of the arguments extracting the
+            // the individual arguments as we go
+            for (int n = 0; n < argumentsContentLength; n++)
+            {
+                // We found a property expression.. skip over all of it.
+                if ((n < argumentsContentLength - 1) && (argumentsString[n] == '$' && argumentsString[n + 1] == '('))
+                {
+                    int nestedPropertyStart = n;
+                    n += 2; // skip over the opening '$('
 
-                                argumentBuilder.Append(argumentsString, nestedPropertyStart, (n - nestedPropertyStart) + 1);
-                            }
-                            else if (argumentsContent[n] == '`' || argumentsContent[n] == '"' || argumentsContent[n] == '\'')
-                            {
-                                int quoteStart = n;
-                                n++; // skip over the opening quote
+                    // Scan for the matching closing bracket, skipping any nested ones
+                    n = ScanForClosingParenthesis(argumentsString, n);
 
-                                n = ScanForClosingQuote(argumentsString[quoteStart], argumentsString, n);
+                    if (n == -1)
+                    {
+                        ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "InvalidFunctionPropertyExpression", expressionFunction, AssemblyResources.GetString("InvalidFunctionPropertyExpressionDetailMismatchedParenthesis"));
+                    }
 
-                                if (n == -1)
-                                {
-                                    ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "InvalidFunctionPropertyExpression", expressionFunction, AssemblyResources.GetString("InvalidFunctionPropertyExpressionDetailMismatchedQuote"));
-                                }
+                    FlushCurrentArgumentToArgumentBuilder(argumentEndIndex: nestedPropertyStart);
+                    argumentBuilder.Append(argumentsString, nestedPropertyStart, (n - nestedPropertyStart) + 1);
+                }
+                else if (argumentsString[n] == '`' || argumentsString[n] == '"' || argumentsString[n] == '\'')
+                {
+                    int quoteStart = n;
+                    n++; // skip over the opening quote
 
-                                argumentBuilder.Append(argumentsString, quoteStart, (n - quoteStart) + 1);
-                            }
-                            else if (argumentsContent[n] == ',')
-                            {
-                                // We have reached the end of the current argument, go ahead and add it
-                                // to our list
-                                AddArgument(arguments, argumentBuilder);
+                    n = ScanForClosingQuote(argumentsString[quoteStart], argumentsString, n);
 
-                                // Clear out the argument builder ready for the next argument
-                                argumentBuilder.Remove(0, argumentBuilder.Length);
-                            }
-                            else
-                            {
-                                argumentBuilder.Append(argumentsContent[n]);
-                            }
-                        }
+                    if (n == -1)
+                    {
+                        ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "InvalidFunctionPropertyExpression", expressionFunction, AssemblyResources.GetString("InvalidFunctionPropertyExpressionDetailMismatchedQuote"));
                     }
+
+                    FlushCurrentArgumentToArgumentBuilder(argumentEndIndex: quoteStart);
+                    argumentBuilder.Append(argumentsString, quoteStart, (n - quoteStart) + 1);
                 }
+                else if (argumentsString[n] == ',')
+                {
+                    FlushCurrentArgumentToArgumentBuilder(argumentEndIndex: n);
+
+                    // We have reached the end of the current argument, go ahead and add it
+                    // to our list
+                    AddArgument(arguments, argumentBuilder);
 
-                // This will either be the one and only argument, or the last one
-                // so add it to our list
-                AddArgument(arguments, argumentBuilder);
+                    // Clear out the argument builder ready for the next argument
+                    argumentBuilder.Clear();
+                }
+                else
+                {
+                    argumentStartIndex ??= n;
+                }
             }
 
+            // We reached the end of the string but we may have seen the start but not the end of the last (or only) argument so flush it now.
+            FlushCurrentArgumentToArgumentBuilder(argumentEndIndex: argumentsContentLength);
+
+            // This will either be the one and only argument, or the last one
+            // so add it to our list
+            AddArgument(arguments, argumentBuilder);
+
             return arguments.ToArray();
         }
 
@@ -766,55 +776,53 @@ internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTa
                         }
 
                         // otherwise, run the more complex Regex to find item metadata references not contained in transforms
-                        // With the reuseable string builder, there's no particular need to initialize the length as it will already have grown.
-                        using (var finalResultBuilder = new ReuseableStringBuilder())
-                        {
-                            int start = 0;
-                            MetadataMatchEvaluator matchEvaluator = new MetadataMatchEvaluator(metadata, options);
-
-                            if (itemVectorExpressions != null)
-                            {
-                                // Move over the expression, skipping those that have been recognized as an item vector expression
-                                // Anything other than an item vector expression we want to expand bare metadata in.
-                                for (int n = 0; n < itemVectorExpressions.Count; n++)
-                                {
-                                    string vectorExpression = itemVectorExpressions[n].Value;
+                        using SpanBasedStringBuilder finalResultBuilder = Strings.GetSpanBasedStringBuilder();
 
-                                    // Extract the part of the expression that appears before the item vector expression
-                                    // e.g. the ABC in ABC@(foo->'%(FullPath)')
-                                    string subExpressionToReplaceIn = expression.Substring(start, itemVectorExpressions[n].Index - start);
-                                    string replacementResult = RegularExpressions.NonTransformItemMetadataPattern.Value.Replace(subExpressionToReplaceIn, new MatchEvaluator(matchEvaluator.ExpandSingleMetadata));
+                        int start = 0;
+                        MetadataMatchEvaluator matchEvaluator = new MetadataMatchEvaluator(metadata, options);
 
-                                    // Append the metadata replacement
-                                    finalResultBuilder.Append(replacementResult);
+                        if (itemVectorExpressions != null)
+                        {
+                            // Move over the expression, skipping those that have been recognized as an item vector expression
+                            // Anything other than an item vector expression we want to expand bare metadata in.
+                            for (int n = 0; n < itemVectorExpressions.Count; n++)
+                            {
+                                string vectorExpression = itemVectorExpressions[n].Value;
 
-                                    // Expand any metadata that appears in the item vector expression's separator
-                                    if (itemVectorExpressions[n].Separator != null)
-                                    {
-                                        vectorExpression = RegularExpressions.NonTransformItemMetadataPattern.Value.Replace(itemVectorExpressions[n].Value, new MatchEvaluator(matchEvaluator.ExpandSingleMetadata), -1, itemVectorExpressions[n].SeparatorStart);
-                                    }
+                                // Extract the part of the expression that appears before the item vector expression
+                                // e.g. the ABC in ABC@(foo->'%(FullPath)')
+                                string subExpressionToReplaceIn = expression.Substring(start, itemVectorExpressions[n].Index - start);
+                                string replacementResult = RegularExpressions.NonTransformItemMetadataPattern.Value.Replace(subExpressionToReplaceIn, new MatchEvaluator(matchEvaluator.ExpandSingleMetadata));
 
-                                    // Append the item vector expression as is
-                                    // e.g. the @(foo->'%(FullPath)') in ABC@(foo->'%(FullPath)')
-                                    finalResultBuilder.Append(vectorExpression);
+                                // Append the metadata replacement
+                                finalResultBuilder.Append(replacementResult);
 
-                                    // Move onto the next part of the expression that isn't an item vector expression
-                                    start = (itemVectorExpressions[n].Index + itemVectorExpressions[n].Length);
+                                // Expand any metadata that appears in the item vector expression's separator
+                                if (itemVectorExpressions[n].Separator != null)
+                                {
+                                    vectorExpression = RegularExpressions.NonTransformItemMetadataPattern.Value.Replace(itemVectorExpressions[n].Value, new MatchEvaluator(matchEvaluator.ExpandSingleMetadata), -1, itemVectorExpressions[n].SeparatorStart);
                                 }
-                            }
 
-                            // If there's anything left after the last item vector expression
-                            // then we need to metadata replace and then append that
-                            if (start < expression.Length)
-                            {
-                                string subExpressionToReplaceIn = expression.Substring(start);
-                                string replacementResult = RegularExpressions.NonTransformItemMetadataPattern.Value.Replace(subExpressionToReplaceIn, new MatchEvaluator(matchEvaluator.ExpandSingleMetadata));
+                                // Append the item vector expression as is
+                                // e.g. the @(foo->'%(FullPath)') in ABC@(foo->'%(FullPath)')
+                                finalResultBuilder.Append(vectorExpression);
 
-                                finalResultBuilder.Append(replacementResult);
+                                // Move onto the next part of the expression that isn't an item vector expression
+                                start = (itemVectorExpressions[n].Index + itemVectorExpressions[n].Length);
                             }
+                        }
+
+                        // If there's anything left after the last item vector expression
+                        // then we need to metadata replace and then append that
+                        if (start < expression.Length)
+                        {
+                            string subExpressionToReplaceIn = expression.Substring(start);
+                            string replacementResult = RegularExpressions.NonTransformItemMetadataPattern.Value.Replace(subExpressionToReplaceIn, new MatchEvaluator(matchEvaluator.ExpandSingleMetadata));
 
-                            result = OpportunisticIntern.InternableToString(finalResultBuilder);
+                            finalResultBuilder.Append(replacementResult);
                         }
+
+                        result = finalResultBuilder.ToString();
                     }
 
                     // Don't create more strings
@@ -1144,34 +1152,32 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
 
                     // Initialize our output string to empty string.
                     // This method is called very often - of the order of 3,000 times per project.
-                    // With the reuseable string builder, there's no particular need to initialize the length as it will already have grown.
-                    using (var result = new ReuseableStringBuilder())
-                    {
-                        // Append our collected results
-                        if (results != null)
-                        {
-                            // Create a combined result string from the result components that we've gathered
-                            foreach (object component in results)
-                            {
-                                result.Append(FileUtilities.MaybeAdjustFilePath(component.ToString()));
-                            }
-                        }
+                    using SpanBasedStringBuilder result = Strings.GetSpanBasedStringBuilder();
 
-                        // Append the last result we collected (it wasn't added to the list)
-                        if (lastResult != null)
+                    // Append our collected results
+                    if (results != null)
+                    {
+                        // Create a combined result string from the result components that we've gathered
+                        foreach (object component in results)
                         {
-                            result.Append(FileUtilities.MaybeAdjustFilePath(lastResult.ToString()));
+                            result.Append(FileUtilities.MaybeAdjustFilePath(component.ToString()));
                         }
+                    }
 
-                        // And if we couldn't find anymore property tags in the expression,
-                        // so just literally copy the remainder into the result.
-                        if (expression.Length - sourceIndex > 0)
-                        {
-                            result.Append(expression, sourceIndex, expression.Length - sourceIndex);
-                        }
+                    // Append the last result we collected (it wasn't added to the list)
+                    if (lastResult != null)
+                    {
+                        result.Append(FileUtilities.MaybeAdjustFilePath(lastResult.ToString()));
+                    }
 
-                        return OpportunisticIntern.InternableToString(result);
+                    // And if we couldn't find anymore property tags in the expression,
+                    // so just literally copy the remainder into the result.
+                    if (expression.Length - sourceIndex > 0)
+                    {
+                        result.Append(expression, sourceIndex, expression.Length - sourceIndex);
                     }
+
+                    return result.ToString();
                 }
             }
 
@@ -1310,51 +1316,53 @@ internal static string ConvertToString(object valueToConvert)
                     {
                         convertedString = (string)valueToConvert;
                     }
-                    else if (valueToConvert is IDictionary)
+                    else if (valueToConvert is IDictionary dictionary)
                     {
                         // If the return type is an IDictionary, then we convert this to
                         // a semi-colon delimited set of A=B pairs.
                         // Key and Value are converted to string and escaped
-                        IDictionary dictionary = valueToConvert as IDictionary;
-                        using (var builder = new ReuseableStringBuilder())
+                        if (dictionary.Count > 0)
                         {
+                            using SpanBasedStringBuilder builder = Strings.GetSpanBasedStringBuilder();
+
                             foreach (DictionaryEntry entry in dictionary)
                             {
                                 if (builder.Length > 0)
                                 {
-                                    builder.Append(';');
+                                    builder.Append(";");
                                 }
 
                                 // convert and escape each key and value in the dictionary entry
                                 builder.Append(EscapingUtilities.Escape(ConvertToString(entry.Key)));
-                                builder.Append('=');
+                                builder.Append("=");
                                 builder.Append(EscapingUtilities.Escape(ConvertToString(entry.Value)));
                             }
 
-                            convertedString = OpportunisticIntern.InternableToString(builder);
+                            convertedString = builder.ToString();
+                        }
+                        else
+                        {
+                            convertedString = string.Empty;
                         }
                     }
-                    else if (valueToConvert is IEnumerable)
+                    else if (valueToConvert is IEnumerable enumerable)
                     {
                         // If the return is enumerable, then we'll convert to semi-colon delimited elements
                         // each of which must be converted, so we'll recurse for each element
-                        using (var builder = new ReuseableStringBuilder())
-                        {
-                            IEnumerable enumerable = (IEnumerable)valueToConvert;
+                        using SpanBasedStringBuilder builder = Strings.GetSpanBasedStringBuilder();
 
-                            foreach (object element in enumerable)
+                        foreach (object element in enumerable)
+                        {
+                            if (builder.Length > 0)
                             {
-                                if (builder.Length > 0)
-                                {
-                                    builder.Append(';');
-                                }
-
-                                // we need to convert and escape each element of the array
-                                builder.Append(EscapingUtilities.Escape(ConvertToString(element)));
+                                builder.Append(";");
                             }
 
-                            convertedString = OpportunisticIntern.InternableToString(builder);
+                            // we need to convert and escape each element of the array
+                            builder.Append(EscapingUtilities.Escape(ConvertToString(element)));
                         }
+
+                        convertedString = builder.ToString();
                     }
                     else
                     {
@@ -1759,18 +1767,16 @@ internal static IList<T> ExpandExpressionCaptureIntoItems<S, T>(
                     // a scalar and then create a single item. Basically we need this
                     // to be able to convert item lists with user specified separators into properties.
                     string expandedItemVector;
-                    using (var builder = new ReuseableStringBuilder())
-                    {
-                        brokeEarlyNonEmpty = ExpandExpressionCaptureIntoStringBuilder(expander, expressionCapture, items, elementLocation, builder, options);
-
-                        if (brokeEarlyNonEmpty)
-                        {
-                            return null;
-                        }
+                    using SpanBasedStringBuilder builder = Strings.GetSpanBasedStringBuilder();
+                    brokeEarlyNonEmpty = ExpandExpressionCaptureIntoStringBuilder(expander, expressionCapture, items, elementLocation, builder, options);
 
-                        expandedItemVector = OpportunisticIntern.InternableToString(builder);
+                    if (brokeEarlyNonEmpty)
+                    {
+                        return null;
                     }
 
+                    expandedItemVector = builder.ToString();
+
                     result = new List<T>(1);
 
                     if (expandedItemVector.Length > 0)
@@ -1941,38 +1947,36 @@ internal static string ExpandItemVectorsIntoString<T>(Expander<P, I> expander, s
                     return expression;
                 }
 
-                using (var builder = new ReuseableStringBuilder())
+                using SpanBasedStringBuilder builder = Strings.GetSpanBasedStringBuilder();
+                // As we walk through the matches, we need to copy out the original parts of the string which
+                // are not covered by the match.  This preserves original behavior which did not trim whitespace
+                // from between separators.
+                int lastStringIndex = 0;
+                for (int i = 0; i < matches.Count; i++)
                 {
-                    // As we walk through the matches, we need to copy out the original parts of the string which
-                    // are not covered by the match.  This preserves original behavior which did not trim whitespace
-                    // from between separators.
-                    int lastStringIndex = 0;
-                    for (int i = 0; i < matches.Count; i++)
+                    if (matches[i].Index > lastStringIndex)
                     {
-                        if (matches[i].Index > lastStringIndex)
-                        {
-                            if ((options & ExpanderOptions.BreakOnNotEmpty) != 0)
-                            {
-                                return null;
-                            }
-
-                            builder.Append(expression, lastStringIndex, matches[i].Index - lastStringIndex);
-                        }
-
-                        bool brokeEarlyNonEmpty = ExpandExpressionCaptureIntoStringBuilder(expander, matches[i], items, elementLocation, builder, options);
-
-                        if (brokeEarlyNonEmpty)
+                        if ((options & ExpanderOptions.BreakOnNotEmpty) != 0)
                         {
                             return null;
                         }
 
-                        lastStringIndex = matches[i].Index + matches[i].Length;
+                        builder.Append(expression, lastStringIndex, matches[i].Index - lastStringIndex);
                     }
 
-                    builder.Append(expression, lastStringIndex, expression.Length - lastStringIndex);
+                    bool brokeEarlyNonEmpty = ExpandExpressionCaptureIntoStringBuilder(expander, matches[i], items, elementLocation, builder, options);
+
+                    if (brokeEarlyNonEmpty)
+                    {
+                        return null;
+                    }
 
-                    return OpportunisticIntern.InternableToString(builder);
+                    lastStringIndex = matches[i].Index + matches[i].Length;
                 }
+
+                builder.Append(expression, lastStringIndex, expression.Length - lastStringIndex);
+
+                return builder.ToString();
             }
 
             /// <summary>
@@ -2019,7 +2023,7 @@ private static Stack<TransformFunction<S>> PrepareTransformStackFromMatch<S>(IEl
             }
 
             /// <summary>
-            /// Expand the match provided into a string, and append that to the provided string builder.
+            /// Expand the match provided into a string, and append that to the provided InternableString.
             /// Returns true if ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and so it broke out early.
             /// </summary>
             /// <typeparam name="S">Type of source items.</typeparam>
@@ -2028,7 +2032,7 @@ private static bool ExpandExpressionCaptureIntoStringBuilder<S>(
                 ExpressionShredder.ItemExpressionCapture capture,
                 IItemProvider<S> evaluatedItems,
                 IElementLocation elementLocation,
-                ReuseableStringBuilder builder,
+                SpanBasedStringBuilder builder,
                 ExpanderOptions options
                 )
                 where S : class, IItem
@@ -2069,12 +2073,11 @@ ExpanderOptions options
                         }
                     }
                     builder.Append(item.Key);
-                    builder.Append(';');
+                    if (i < itemsFromCapture.Count - 1)
+                    {
+                        builder.Append(";");
+                    }
                 }
-
-                // Remove trailing separator if we added one
-                if (itemsFromCapture.Count > 0)
-                    builder.Length--;
                 
                 return false;
             }
@@ -4016,7 +4019,7 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                         }
                         else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.AreFeaturesEnabled), StringComparison.OrdinalIgnoreCase))
                         {
-                            if (TryGetArg(args, out string arg0))
+                            if (TryGetArg(args, out Version arg0))
                             {
                                 returnVal = IntrinsicFunctions.AreFeaturesEnabled(arg0);
                                 return true;
@@ -4302,6 +4305,30 @@ private static bool TryGetArg(object[] args, out int arg0)
                 return TryConvertToInt(args[0], out arg0);
             }
 
+            private static bool TryGetArg(object[] args, out Version arg0)
+            {
+                if (args.Length != 1)
+                {
+                    arg0 = default;
+                    return false;
+                }
+
+                return TryConvertToVersion(args[0], out arg0);
+            }
+
+            private static bool TryConvertToVersion(object value, out Version arg0)
+            {
+                string val = value as string;
+
+                if (string.IsNullOrEmpty(val) || !Version.TryParse(val, out arg0))
+                {
+                    arg0 = default;
+                    return false;
+                }
+
+                return true;
+            }
+
             private static bool TryConvertToInt(object value, out int arg0)
             {
                 switch (value)
@@ -4911,7 +4938,7 @@ private string GenerateStringOfMethodExecuted(string expression, object objectIn
                 }
                 else
                 {
-                    string propertyValue = "\"" + objectInstance as string + "\"";
+                    string propertyValue = $"\"{objectInstance as string}\"";
 
                     if ((_bindingFlags & BindingFlags.InvokeMethod) == BindingFlags.InvokeMethod)
                     {
diff --git a/src/Build/Evaluation/IMetadatum.cs b/src/Build/Evaluation/IMetadatum.cs
index aa828e835ad..5521a562ea6 100644
--- a/src/Build/Evaluation/IMetadatum.cs
+++ b/src/Build/Evaluation/IMetadatum.cs
@@ -1,12 +1,14 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Collections;
+
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
     /// This interface represents a metadata object.
     /// </summary>
-    internal interface IMetadatum
+    internal interface IMetadatum : IKeyed, IValued
     {
     }
 }
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 7bdedf62916..aa1cdeaa90b 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -514,9 +514,9 @@ internal static string GetTargetPlatformVersion(string tfm, int versionPartCount
             return NuGetFramework.Value.GetTargetPlatformVersion(tfm, versionPartCount);
         }
 
-        internal static bool AreFeaturesEnabled(string wave)
+        internal static bool AreFeaturesEnabled(Version wave)
         {
-            return string.IsNullOrEmpty(wave) ? false : ChangeWaves.AreFeaturesEnabled(wave);
+            return ChangeWaves.AreFeaturesEnabled(wave);
         }
 
         public static string GetCurrentToolsDirectory()
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index ba38ae601d5..2756ccb9c37 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -414,7 +414,7 @@ internal abstract class ItemSpecFragment
         /// <summary>
         ///     Path of the project the itemspec is coming from
         /// </summary>
-        protected string ProjectDirectory { get; }
+        internal string ProjectDirectory { get; }
 
         // not a Lazy to reduce memory
         private ref FileSpecMatcherTester FileMatcher
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index 146e15c4df2..9934759efbf 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -30,7 +30,8 @@ private abstract class LazyItemOperation : IItemOperation
             //  This is used only when evaluating an expression, which instantiates
             //  the items and then removes them
             protected readonly IItemFactory<I, I> _itemFactory;
-
+            internal ItemSpec<P, I> Spec => _itemSpec;
+            
             protected LazyItemOperation(OperationBuilder builder, LazyItemEvaluator<P, I, M, D> lazyEvaluator)
             {
                 _itemElement = builder.ItemElement;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
index b1e13d2ed83..5423bcf0286 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
@@ -15,6 +15,9 @@ internal partial class LazyItemEvaluator<P, I, M, D>
         class UpdateOperation : LazyItemOperation
         {
             private readonly ImmutableList<ProjectMetadataElement> _metadata;
+            private ImmutableList<ItemBatchingContext>.Builder _itemsToUpdate = null;
+            private ItemSpecMatchesItem _matchItemSpec = null;
+            private bool? _needToExpandMetadataForEachItem = null;
 
             public UpdateOperation(OperationBuilderWithMetadata builder, LazyItemEvaluator<P, I, M, D> lazyEvaluator)
                 : base(builder, lazyEvaluator)
@@ -43,23 +46,77 @@ protected override void ApplyImpl(ImmutableList<ItemData>.Builder listBuilder, I
                     return;
                 }
 
-                ItemSpecMatchesItem matchItemspec;
-                bool? needToExpandMetadataForEachItem = null;
+                SetMatchItemSpec();
+                _itemsToUpdate ??= ImmutableList.CreateBuilder<ItemBatchingContext>();
+                _itemsToUpdate.Clear();
 
+                for (int i = 0; i < listBuilder.Count; i++)
+                {
+                    var itemData = listBuilder[i];
+
+                    var matchResult = _matchItemSpec(_itemSpec, itemData.Item);
+
+                    if (matchResult.IsMatch)
+                    {
+                        listBuilder[i] = UpdateItem(listBuilder[i], matchResult.CapturedItemsFromReferencedItemTypes);
+                    }
+                }
+
+                DecorateItemsWithMetadata(_itemsToUpdate.ToImmutableList(), _metadata, _needToExpandMetadataForEachItem);
+            }
+
+            /// <summary>
+            /// Apply the Update operation to the item if it matches.
+            /// </summary>
+            /// <param name="item">The item to check for a match.</param>
+            /// <returns>The updated item.</returns>
+            internal ItemData UpdateItem(ItemData item)
+            {
+                if (_conditionResult)
+                {
+                    SetMatchItemSpec();
+                    _itemsToUpdate ??= ImmutableList.CreateBuilder<ItemBatchingContext>();
+                    _itemsToUpdate.Clear();
+                    MatchResult matchResult = _matchItemSpec(_itemSpec, item.Item);
+                    if (matchResult.IsMatch)
+                    {
+                        ItemData clonedData = UpdateItem(item, matchResult.CapturedItemsFromReferencedItemTypes);
+                        DecorateItemsWithMetadata(_itemsToUpdate.ToImmutableList(), _metadata, _needToExpandMetadataForEachItem);
+                        return clonedData;
+                    }
+                }
+                return item;
+            }
+
+            private ItemData UpdateItem(ItemData item, Dictionary<string, I> capturedItemsFromReferencedItemTypes)
+            {
+                // items should be deep immutable, so clone and replace items before mutating them
+                // otherwise, with GetItems caching enabled, the mutations would leak into the cache causing
+                // future operations to mutate the state of past operations
+                ItemData clonedData = item.Clone(_itemFactory, _itemElement);
+                _itemsToUpdate.Add(new ItemBatchingContext(clonedData.Item, capturedItemsFromReferencedItemTypes));
+                return clonedData;
+            }
+
+            /// <summary>
+            /// This sets the function used to determine whether an item matches an item spec.
+            /// </summary>
+            private void SetMatchItemSpec()
+            {
                 if (ItemspecContainsASingleBareItemReference(_itemSpec, _itemElement.ItemType))
                 {
                     // Perf optimization: If the Update operation references itself (e.g. <I Update="@(I)"/>)
                     // then all items are updated and matching is not necessary
-                    matchItemspec = (itemSpec, item) => new MatchResult(true, null);
+                    _matchItemSpec = (itemSpec, item) => new MatchResult(true, null);
                 }
                 else if (ItemSpecContainsItemReferences(_itemSpec)
-                         && QualifiedMetadataReferencesExist(_metadata, out needToExpandMetadataForEachItem)
+                         && QualifiedMetadataReferencesExist(_metadata, out _needToExpandMetadataForEachItem)
                          && !Traits.Instance.EscapeHatches.DoNotExpandQualifiedMetadataInUpdateOperation)
                 {
-                    var itemReferenceFragments = _itemSpec.Fragments.OfType<ItemSpec<P,I>.ItemExpressionFragment>().ToArray();
-                    var nonItemReferenceFragments = _itemSpec.Fragments.Where(f => !(f is ItemSpec<P,I>.ItemExpressionFragment)).ToArray();
+                    var itemReferenceFragments = _itemSpec.Fragments.OfType<ItemSpec<P, I>.ItemExpressionFragment>().ToArray();
+                    var nonItemReferenceFragments = _itemSpec.Fragments.Where(f => !(f is ItemSpec<P, I>.ItemExpressionFragment)).ToArray();
 
-                    matchItemspec = (itemSpec, item) =>
+                    _matchItemSpec = (itemSpec, item) =>
                     {
                         var isMatch = nonItemReferenceFragments.Any(f => f.IsMatch(item.EvaluatedInclude));
                         Dictionary<string, I> capturedItemsFromReferencedItemTypes = null;
@@ -84,30 +141,8 @@ protected override void ApplyImpl(ImmutableList<ItemData>.Builder listBuilder, I
                 }
                 else
                 {
-                    matchItemspec = (itemSpec, item) => new MatchResult(itemSpec.MatchesItem(item), null);
-                }
-
-                var itemsToUpdate = ImmutableList.CreateBuilder<ItemBatchingContext>();
-
-                for (int i = 0; i < listBuilder.Count; i++)
-                {
-                    var itemData = listBuilder[i];
-
-                    var matchResult = matchItemspec(_itemSpec, itemData.Item);
-
-                    if (matchResult.IsMatch)
-                    {
-                        // items should be deep immutable, so clone and replace items before mutating them
-                        // otherwise, with GetItems caching enabled, the mutations would leak into the cache causing
-                        // future operations to mutate the state of past operations
-                        var clonedItemData = listBuilder[i].Clone(_itemFactory, _itemElement);
-                        listBuilder[i] = clonedItemData;
-
-                        itemsToUpdate.Add(new ItemBatchingContext(clonedItemData.Item, matchResult.CapturedItemsFromReferencedItemTypes));
-                    }
+                    _matchItemSpec = (itemSpec, item) => new MatchResult(itemSpec.MatchesItem(item), null);
                 }
-
-                DecorateItemsWithMetadata(itemsToUpdate.ToImmutableList(), _metadata, needToExpandMetadataForEachItem);
             }
 
             private bool QualifiedMetadataReferencesExist(ImmutableList<ProjectMetadataElement> metadata, out bool? needToExpandMetadataForEachItem)
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index 64df2a7402f..e5f2a72f61a 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -151,7 +151,7 @@ public ItemData Clone(IItemFactory<I, I> itemFactory, ProjectItemElement initial
 
         private class MemoizedOperation : IItemOperation
         {
-            public IItemOperation Operation { get; }
+            public LazyItemOperation Operation { get; }
             private Dictionary<ISet<string>, ImmutableList<ItemData>> _cache;
 
             private bool _isReferenced;
@@ -159,7 +159,7 @@ private class MemoizedOperation : IItemOperation
             private int _applyCalls;
 #endif
 
-            public MemoizedOperation(IItemOperation operation)
+            public MemoizedOperation(LazyItemOperation operation)
             {
                 Operation = operation;
             }
@@ -291,6 +291,14 @@ public ImmutableList<ItemData>.Builder GetItemData(ImmutableHashSet<string> glob
                 }
             }
 
+            /// <summary>
+            /// Applies uncached item operations (include, remove, update) in order. Since Remove effectively overwrites Include or Update,
+            /// Remove operations are preprocessed (adding to globsToIgnore) to create a longer list of globs we don't need to process
+            /// properly because we know they will be removed. Update operations are batched as much as possible, meaning rather
+            /// than being applied immediately, they are combined into a dictionary of UpdateOperations that need to be applied. This
+            /// is to optimize the case in which as series of UpdateOperations, each of which affects a single ItemSpec, are applied to all
+            /// items in the list, leading to a quadratic-time operation.
+            /// </summary>
             private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyItemList, ImmutableHashSet<string> globsToIgnore)
             {
                 // Stack of operations up to the first one that's cached (exclusive)
@@ -315,13 +323,9 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte
 
                     //  If this is a remove operation, then add any globs that will be removed
                     //  to a list of globs to ignore in previous operations
-                    var removeOperation = currentList._memoizedOperation.Operation as RemoveOperation;
-                    if (removeOperation != null)
+                    if (currentList._memoizedOperation.Operation is RemoveOperation removeOperation)
                     {
-                        if (globsToIgnoreStack == null)
-                        {
-                            globsToIgnoreStack = new Stack<ImmutableHashSet<string>>();
-                        }
+                        globsToIgnoreStack ??= new Stack<ImmutableHashSet<string>>();
 
                         var globsToIgnoreForPreviousOperations = removeOperation.GetRemovedGlobs();
                         foreach (var globToRemove in globsToIgnoreFromFutureOperations)
@@ -342,15 +346,65 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte
 
                 ImmutableHashSet<string> currentGlobsToIgnore = globsToIgnoreStack == null ? globsToIgnore : globsToIgnoreStack.Peek();
 
+                Dictionary<string, UpdateOperation> itemsWithNoWildcards = new Dictionary<string, UpdateOperation>(StringComparer.OrdinalIgnoreCase);
+                bool addedToBatch = false;
+
                 //  Walk back down the stack of item lists applying operations
                 while (itemListStack.Count > 0)
                 {
                     var currentList = itemListStack.Pop();
 
+                    if (currentList._memoizedOperation.Operation is UpdateOperation op)
+                    {
+                        bool addToBatch = true;
+                        int i;
+                        // The TextFragments are things like abc.def or x*y.*z.
+                        for (i = 0; i < op.Spec.Fragments.Count; i++)
+                        {
+                            ItemSpecFragment frag = op.Spec.Fragments[i];
+                            if (MSBuildConstants.CharactersForExpansion.Any(frag.TextFragment.Contains))
+                            {
+                                // Fragment contains wild cards, items, or properties. Cannot batch over it using a dictionary.
+                                addToBatch = false;
+                                break;
+                            }
+
+                            string fullPath = FileUtilities.GetFullPath(frag.TextFragment, frag.ProjectDirectory);
+                            if (itemsWithNoWildcards.ContainsKey(fullPath))
+                            {
+                                // Another update will already happen on this path. Make that happen before evaluating this one.
+                                addToBatch = false;
+                                break;
+                            }
+                            else
+                            {
+                                itemsWithNoWildcards.Add(fullPath, op);
+                            }
+                        }
+                        if (!addToBatch)
+                        {
+                            // We found a wildcard. Remove any fragments associated with the current operation and process them later.
+                            for (int j = 0; j < i; j++)
+                            {
+                                itemsWithNoWildcards.Remove(currentList._memoizedOperation.Operation.Spec.Fragments[j].TextFragment);
+                            }
+                        }
+                        else
+                        {
+                            addedToBatch = true;
+                            continue;
+                        }
+                    }
+
+                    if (addedToBatch)
+                    {
+                        addedToBatch = false;
+                        ProcessNonWildCardItemUpdates(itemsWithNoWildcards, items);
+                    }
+
                     //  If this is a remove operation, then it could modify the globs to ignore, so pop the potentially
                     //  modified entry off the stack of globs to ignore
-                    var removeOperation = currentList._memoizedOperation.Operation as RemoveOperation;
-                    if (removeOperation != null)
+                    if (currentList._memoizedOperation.Operation is RemoveOperation)
                     {
                         globsToIgnoreStack.Pop();
                         currentGlobsToIgnore = globsToIgnoreStack.Count == 0 ? globsToIgnore : globsToIgnoreStack.Peek();
@@ -359,9 +413,30 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte
                     currentList._memoizedOperation.Apply(items, currentGlobsToIgnore);
                 }
 
+                // We finished looping through the operations. Now process the final batch if necessary.
+                ProcessNonWildCardItemUpdates(itemsWithNoWildcards, items);
+
                 return items;
             }
 
+            private static void ProcessNonWildCardItemUpdates(Dictionary<string, UpdateOperation> itemsWithNoWildcards, ImmutableList<ItemData>.Builder items)
+            {
+#if DEBUG
+                ErrorUtilities.VerifyThrow(itemsWithNoWildcards.All(fragment => !MSBuildConstants.CharactersForExpansion.Any(fragment.Key.Contains)), $"{nameof(itemsWithNoWildcards)} should not contain any text fragments with wildcards.");
+#endif
+                if (itemsWithNoWildcards.Count > 0)
+                {
+                    for (int i = 0; i < items.Count; i++)
+                    {
+                        if (itemsWithNoWildcards.TryGetValue(FileUtilities.GetFullPath(items[i].Item.EvaluatedInclude, items[i].Item.ProjectDirectory), out UpdateOperation op))
+                        {
+                            items[i] = op.UpdateItem(items[i]);
+                        }
+                    }
+                    itemsWithNoWildcards.Clear();
+                }
+            }
+
             public void MarkAsReferenced()
             {
                 _memoizedOperation.MarkAsReferenced();
diff --git a/src/Build/Evaluation/SemiColonTokenizer.cs b/src/Build/Evaluation/SemiColonTokenizer.cs
index 3d3c0791baa..625f2ae0487 100644
--- a/src/Build/Evaluation/SemiColonTokenizer.cs
+++ b/src/Build/Evaluation/SemiColonTokenizer.cs
@@ -1,9 +1,12 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
 using System.Collections;
 using System.Collections.Generic;
 
+using Microsoft.NET.StringTools;
+
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
@@ -145,8 +148,7 @@ private string GetExpressionSubstring(int startIndex, int length)
                 }
                 if (startIndex < endIndex)
                 {
-                    var target = new SubstringInternTarget(_expression, startIndex, endIndex - startIndex);
-                    return OpportunisticIntern.InternableToString(target);
+                    return Strings.WeakIntern(_expression.AsSpan(startIndex, endIndex - startIndex));
                 }
                 return null;
             }
diff --git a/src/Build/FileSystem/IFileSystemAdapter.cs b/src/Build/FileSystem/IFileSystemAdapter.cs
new file mode 100644
index 00000000000..dce1574702c
--- /dev/null
+++ b/src/Build/FileSystem/IFileSystemAdapter.cs
@@ -0,0 +1,97 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using Microsoft.Build.Shared.FileSystem;
+
+namespace Microsoft.Build.FileSystem
+{
+    internal class IFileSystemAdapter : MSBuildFileSystemBase
+    {
+        private readonly IFileSystem _wrappedFileSystem;
+
+        public IFileSystemAdapter(IFileSystem wrappedFileSystem)
+        {
+            _wrappedFileSystem = wrappedFileSystem;
+        }
+
+        public override TextReader ReadFile(string path)
+        {
+            return _wrappedFileSystem.ReadFile(path);
+        }
+
+        public override Stream GetFileStream(
+            string path,
+            FileMode mode,
+            FileAccess access,
+            FileShare share)
+        {
+            return _wrappedFileSystem.GetFileStream(
+                path,
+                mode,
+                access,
+                share);
+        }
+
+        public override string ReadFileAllText(string path)
+        {
+            return _wrappedFileSystem.ReadFileAllText(path);
+        }
+
+        public override byte[] ReadFileAllBytes(string path)
+        {
+            return _wrappedFileSystem.ReadFileAllBytes(path);
+        }
+
+        public override IEnumerable<string> EnumerateFiles(
+            string path,
+            string searchPattern = "*",
+            SearchOption searchOption = SearchOption.TopDirectoryOnly)
+        {
+            return _wrappedFileSystem.EnumerateFiles(path, searchPattern, searchOption);
+        }
+
+        public override IEnumerable<string> EnumerateDirectories(
+            string path,
+            string searchPattern = "*",
+            SearchOption searchOption = SearchOption.TopDirectoryOnly)
+        {
+            return _wrappedFileSystem.EnumerateDirectories(path, searchPattern, searchOption);
+        }
+
+        public override IEnumerable<string> EnumerateFileSystemEntries(
+            string path,
+            string searchPattern = "*",
+            SearchOption searchOption = SearchOption.TopDirectoryOnly)
+        {
+            return _wrappedFileSystem.EnumerateFileSystemEntries(path, searchPattern, searchOption);
+        }
+
+        public override FileAttributes GetAttributes(string path)
+        {
+            return _wrappedFileSystem.GetAttributes(path);
+        }
+
+        public override DateTime GetLastWriteTimeUtc(string path)
+        {
+            return _wrappedFileSystem.GetLastWriteTimeUtc(path);
+        }
+
+        public override bool DirectoryExists(string path)
+        {
+            return _wrappedFileSystem.DirectoryExists(path);
+        }
+
+        public override bool FileExists(string path)
+        {
+            return _wrappedFileSystem.FileExists(path);
+        }
+
+        public override bool FileOrDirectoryExists(string path)
+        {
+            return _wrappedFileSystem.DirectoryEntryExists(path);
+        }
+    }
+}
diff --git a/src/Build/Globbing/MSBuildGlob.cs b/src/Build/Globbing/MSBuildGlob.cs
index 6eb35e81b52..4b03541b3df 100644
--- a/src/Build/Globbing/MSBuildGlob.cs
+++ b/src/Build/Globbing/MSBuildGlob.cs
@@ -7,6 +7,7 @@
 using System.Text.RegularExpressions;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Shared;
+using Microsoft.NET.StringTools;
 
 namespace Microsoft.Build.Globbing
 {
@@ -176,7 +177,7 @@ public static MSBuildGlob Parse(string globRoot, string fileSpec)
                 globRoot = Directory.GetCurrentDirectory();
             }
 
-            globRoot = OpportunisticIntern.InternStringIfPossible(FileUtilities.NormalizePath(globRoot).WithTrailingSlash());
+            globRoot = Strings.WeakIntern(FileUtilities.NormalizePath(globRoot).WithTrailingSlash());
 
             var lazyState = new Lazy<GlobState>(() =>
             {
diff --git a/src/Build/Graph/GraphBuildRequestData.cs b/src/Build/Graph/GraphBuildRequestData.cs
index 86a2231551b..0a1e008820b 100644
--- a/src/Build/Graph/GraphBuildRequestData.cs
+++ b/src/Build/Graph/GraphBuildRequestData.cs
@@ -7,6 +7,14 @@
 
 namespace Microsoft.Build.Graph
 {
+    public record GraphBuildOptions
+    {
+        /// <summary>
+        /// If false, the graph is constructed but the nodes are not built.
+        /// </summary>
+        public bool Build { get; init; } = true;
+    }
+
     /// <summary>
     /// GraphBuildRequestData encapsulates all of the data needed to submit a graph build request.
     /// </summary>
@@ -142,10 +150,18 @@ public GraphBuildRequestData(IEnumerable<ProjectGraphEntryPoint> projectGraphEnt
             ProjectGraphEntryPoints = projectGraphEntryPoints;
         }
 
+        public GraphBuildRequestData(IEnumerable<ProjectGraphEntryPoint> projectGraphEntryPoints, ICollection<string> targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags, GraphBuildOptions graphBuildOptions)
+            : this(targetsToBuild, hostServices, flags, graphBuildOptions)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(projectGraphEntryPoints, nameof(projectGraphEntryPoints));
+
+            ProjectGraphEntryPoints = projectGraphEntryPoints;
+        }
+
         /// <summary>
         /// Common constructor.
         /// </summary>
-        private GraphBuildRequestData(ICollection<string> targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags)
+        private GraphBuildRequestData(ICollection<string> targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags, GraphBuildOptions graphBuildOptions = null)
         {
             ErrorUtilities.VerifyThrowArgumentNull(targetsToBuild, nameof(targetsToBuild));
             foreach (string targetName in targetsToBuild)
@@ -156,6 +172,7 @@ private GraphBuildRequestData(ICollection<string> targetsToBuild, HostServices h
             HostServices = hostServices;
             TargetNames = new List<string>(targetsToBuild);
             Flags = flags;
+            GraphBuildOptions = graphBuildOptions ?? new GraphBuildOptions();
         }
 
         /// <summary>
@@ -183,6 +200,11 @@ private GraphBuildRequestData(ICollection<string> targetsToBuild, HostServices h
         /// </summary>
         public BuildRequestDataFlags Flags { get; }
 
+        /// <summary>
+        /// Options for how the graph should be built.
+        /// </summary>
+        public GraphBuildOptions GraphBuildOptions { get; }
+
         /// <summary>
         /// Gets the HostServices object for this request.
         /// </summary>
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 69bb676cedc..856e514719a 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -291,7 +291,7 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
                 {
                     newEntryPoints.Add(
                         new ProjectGraphEntryPoint(
-                            FileUtilities.NormalizePath(project.AbsolutePath),
+                            project.AbsolutePath,
                             solutionGlobalProperties
                                 .SetItem("Configuration", projectConfiguration.ConfigurationName)
                                 .SetItem("Platform", projectConfiguration.PlatformName)
@@ -344,7 +344,7 @@ IReadOnlyDictionary<string, IReadOnlyCollection<string>> GetSolutionDependencies
 
                 foreach (var projectWithDependencies in solutionFile.ProjectsInOrder.Where(p => p.Dependencies.Count != 0))
                 {
-                    solutionDependencies[FileUtilities.NormalizePath(projectWithDependencies.AbsolutePath)] = projectWithDependencies.Dependencies.Select(
+                    solutionDependencies[projectWithDependencies.AbsolutePath] = projectWithDependencies.Dependencies.Select(
                         dependencyGuid =>
                         {
                             // code snippet cloned from SolutionProjectGenerator.AddPropertyGroupForSolutionConfiguration
@@ -365,7 +365,7 @@ IReadOnlyDictionary<string, IReadOnlyCollection<string>> GetSolutionDependencies
                             // (If a project is not selected for build in the solution configuration, it won't build even if it's depended on by something that IS selected for build)
                             // .. and only if it's known to be MSBuild format, as projects can't use the information otherwise 
                             return dependencyProject?.ProjectType == SolutionProjectType.KnownToBeMSBuildFormat
-                                ? FileUtilities.NormalizePath(dependencyProject.AbsolutePath)
+                                ? dependencyProject.AbsolutePath
                                 : null;
                         })
                         .Where(p => p != null)
diff --git a/src/Build/Graph/ProjectGraph.cs b/src/Build/Graph/ProjectGraph.cs
index 74939362600..b445f72d83d 100644
--- a/src/Build/Graph/ProjectGraph.cs
+++ b/src/Build/Graph/ProjectGraph.cs
@@ -330,7 +330,7 @@ public ProjectGraph(
                 entryPoints,
                 projectCollection,
                 projectInstanceFactory,
-                Environment.ProcessorCount,
+                NativeMethodsShared.GetLogicalCoreCount(),
                 CancellationToken.None)
         {
         }
@@ -371,7 +371,7 @@ public ProjectGraph(
                 entryPoints,
                 projectCollection,
                 projectInstanceFactory,
-                Environment.ProcessorCount,
+                NativeMethodsShared.GetLogicalCoreCount(),
                 cancellationToken)
         {
         }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 2f372f2bf35..bd160b2f66c 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -61,7 +61,7 @@ public enum ProjectInstanceSettings
     /// and call it several times to build it.
     /// </summary>
     /// <comments>
-    /// Neither this class nor none of its constituents are allowed to have
+    /// Neither this class nor any of its constituents are allowed to have
     /// references to any of the Construction or Evaluation objects.
     /// This class is immutable except for adding instance items and setting instance properties.
     /// It only exposes items and properties: targets, host services, and the task registry are not exposed as they are only the concern of build.
@@ -2103,7 +2103,17 @@ private void TranslateItems(ITranslator translator)
         /// <summary>
         /// Creates a set of project instances which represent the project dependency graph for a solution build.
         /// </summary>
-        internal static ProjectInstance[] LoadSolutionForBuild(string projectFile, PropertyDictionary<ProjectPropertyInstance> globalPropertiesInstances, string toolsVersion, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext projectBuildEventContext, bool isExplicitlyLoaded, IReadOnlyCollection<string> targetNames, ISdkResolverService sdkResolverService, int submissionId)
+        internal static ProjectInstance[] LoadSolutionForBuild(
+            string projectFile,
+            PropertyDictionary<ProjectPropertyInstance> globalPropertiesInstances,
+            string toolsVersion,
+            BuildParameters buildParameters,
+            ILoggingService loggingService,
+            BuildEventContext projectBuildEventContext,
+            bool isExplicitlyLoaded,
+            IReadOnlyCollection<string> targetNames,
+            ISdkResolverService sdkResolverService,
+            int submissionId)
         {
             ErrorUtilities.VerifyThrowArgumentLength(projectFile, nameof(projectFile));
             ErrorUtilities.VerifyThrowArgumentNull(globalPropertiesInstances, nameof(globalPropertiesInstances));
diff --git a/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs b/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
index 77ef8bbf6c8..62f79e2d8a0 100644
--- a/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
+++ b/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
@@ -74,47 +74,47 @@ public class ProjectItemGroupTaskItemInstance: ITranslatable
         private ElementLocation _location;
 
         /// <summary>
-        /// Location of the include, if any
+        /// Location of the include, if any.
         /// </summary>
         private ElementLocation _includeLocation;
 
         /// <summary>
-        /// Location of the exclude, if any
+        /// Location of the exclude, if any.
         /// </summary>
         private ElementLocation _excludeLocation;
 
         /// <summary>
-        /// Location of the remove, if any
+        /// Location of the remove, if any.
         /// </summary>
         private ElementLocation _removeLocation;
 
         /// <summary>
-        /// Location of matchOnMetadata, if any
+        /// Location of matchOnMetadata, if any.
         /// </summary>
         private ElementLocation _matchOnMetadataLocation;
 
         /// <summary>
-        /// Location of metadataMatchingSchema, if any
+        /// Location of metadataMatchingSchema, if any.
         /// </summary>
         private ElementLocation _matchOnMetadataOptionsLocation;
 
         /// <summary>
-        /// Location of keepMetadata, if any
+        /// Location of keepMetadata, if any.
         /// </summary>
         private ElementLocation _keepMetadataLocation;
 
         /// <summary>
-        /// Location of removeMetadata, if any
+        /// Location of removeMetadata, if any.
         /// </summary>
         private ElementLocation _removeMetadataLocation;
 
         /// <summary>
-        /// Location of keepDuplicates, if any
+        /// Location of keepDuplicates, if any.
         /// </summary>
         private ElementLocation _keepDuplicatesLocation;
 
         /// <summary>
-        /// Location of the condition, if any
+        /// Location of the condition, if any.
         /// </summary>
         private ElementLocation _conditionLocation;
 
@@ -258,7 +258,7 @@ public string Remove
         }
 
         /// <summary>
-        /// Unevaluated MatchOnMetadata value
+        /// Unevaluated MatchOnMetadata value.
         /// </summary>
         public string MatchOnMetadata
         {
@@ -268,7 +268,7 @@ public string MatchOnMetadata
         }
 
         /// <summary>
-        /// Unevaluated MatchOnMetadataOptions value
+        /// Unevaluated MatchOnMetadataOptions value.
         /// </summary>
         public string MatchOnMetadataOptions
         {
@@ -278,7 +278,7 @@ public string MatchOnMetadataOptions
         }
 
         /// <summary>
-        /// Unevaluated keepMetadata value
+        /// Unevaluated keepMetadata value.
         /// </summary>
         public string KeepMetadata
         {
@@ -288,7 +288,7 @@ public string KeepMetadata
         }
 
         /// <summary>
-        /// Unevaluated removeMetadata value
+        /// Unevaluated removeMetadata value.
         /// </summary>
         public string RemoveMetadata
         {
@@ -298,7 +298,7 @@ public string RemoveMetadata
         }
 
         /// <summary>
-        /// Unevaluated keepDuplicates value
+        /// Unevaluated keepDuplicates value.
         /// </summary>
         public string KeepDuplicates
         {
@@ -308,7 +308,7 @@ public string KeepDuplicates
         }
 
         /// <summary>
-        /// Unevaluated condition value
+        /// Unevaluated condition value.
         /// </summary>
         public string Condition
         {
@@ -333,7 +333,7 @@ public ICollection<ProjectItemGroupTaskMetadataInstance> Metadata
         }
 
         /// <summary>
-        /// Location of the element
+        /// Location of the element.
         /// </summary>
         public ElementLocation Location
         {
@@ -343,7 +343,7 @@ public ElementLocation Location
         }
 
         /// <summary>
-        /// Location of the include attribute, if any
+        /// Location of the include attribute, if any.
         /// </summary>
         public ElementLocation IncludeLocation
         {
@@ -353,7 +353,7 @@ public ElementLocation IncludeLocation
         }
 
         /// <summary>
-        /// Location of the exclude attribute, if any
+        /// Location of the exclude attribute, if any.
         /// </summary>
         public ElementLocation ExcludeLocation
         {
@@ -363,7 +363,7 @@ public ElementLocation ExcludeLocation
         }
 
         /// <summary>
-        /// Location of the remove attribute, if any
+        /// Location of the remove attribute, if any.
         /// </summary>
         public ElementLocation RemoveLocation
         {
@@ -373,7 +373,7 @@ public ElementLocation RemoveLocation
         }
 
         /// <summary>
-        /// Location of the matchOnMetadata attribute, if any
+        /// Location of the matchOnMetadata attribute, if any.
         /// </summary>
         public ElementLocation MatchOnMetadataLocation
         {
@@ -383,7 +383,7 @@ public ElementLocation MatchOnMetadataLocation
         }
 
         /// <summary>
-        /// Location of the matchOnMetadataOptions attribute, if any
+        /// Location of the matchOnMetadataOptions attribute, if any.
         /// </summary>
         public ElementLocation MatchOnMetadataOptionsLocation
         {
@@ -393,7 +393,7 @@ public ElementLocation MatchOnMetadataOptionsLocation
         }
 
         /// <summary>
-        /// Location of the keepMetadata attribute, if any
+        /// Location of the keepMetadata attribute, if any.
         /// </summary>
         public ElementLocation KeepMetadataLocation
         {
@@ -403,7 +403,7 @@ public ElementLocation KeepMetadataLocation
         }
 
         /// <summary>
-        /// Location of the removeMetadata attribute, if any
+        /// Location of the removeMetadata attribute, if any.
         /// </summary>
         public ElementLocation RemoveMetadataLocation
         {
@@ -413,7 +413,7 @@ public ElementLocation RemoveMetadataLocation
         }
 
         /// <summary>
-        /// Location of the keepDuplicates attribute, if any
+        /// Location of the keepDuplicates attribute, if any.
         /// </summary>
         public ElementLocation KeepDuplicatesLocation
         {
@@ -423,7 +423,7 @@ public ElementLocation KeepDuplicatesLocation
         }
 
         /// <summary>
-        /// Location of the condition attribute if any
+        /// Location of the condition attribute if any.
         /// </summary>
         public ElementLocation ConditionLocation
         {
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index d91f248d264..6200da27e43 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -28,7 +28,7 @@ namespace Microsoft.Build.Execution
     /// and evaluation has already been performed, so it is unnecessary bulk.
     /// </remarks>
     [DebuggerDisplay("{ItemType}={EvaluatedInclude} #DirectMetadata={DirectMetadataCount})")]
-    public class ProjectItemInstance : IKeyed, IItem<ProjectMetadataInstance>, ITaskItem, ITaskItem2, IMetadataTable, ITranslatable, IDeepCloneable<ProjectItemInstance>
+    public class ProjectItemInstance : IItem<ProjectMetadataInstance>, ITaskItem2, IMetadataTable, ITranslatable, IDeepCloneable<ProjectItemInstance>
     {
         /// <summary>
         /// The project instance to which this item belongs.
@@ -723,7 +723,7 @@ internal sealed class TaskItem :
 #if FEATURE_APPDOMAIN
             MarshalByRefObject,
 #endif
-            ITaskItem, ITaskItem2, IItem<ProjectMetadataInstance>, ITranslatable, IEquatable<TaskItem>
+            ITaskItem2, IItem<ProjectMetadataInstance>, ITranslatable, IEquatable<TaskItem>
         {
             /// <summary>
             /// The source file that defined this item.
@@ -1108,6 +1108,8 @@ internal CopyOnWritePropertyDictionary<ProjectMetadataInstance> MetadataCollecti
                 }
             }
 
+            IEnumerable<ProjectMetadataInstance> IItem<ProjectMetadataInstance>.Metadata => MetadataCollection;
+
             #region Operators
 
             /// <summary>
diff --git a/src/Build/Instance/ProjectMetadataInstance.cs b/src/Build/Instance/ProjectMetadataInstance.cs
index 3e02154592c..6f9367bed45 100644
--- a/src/Build/Instance/ProjectMetadataInstance.cs
+++ b/src/Build/Instance/ProjectMetadataInstance.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.Execution
     /// IMMUTABLE OBJECT.
     /// </summary>
     [DebuggerDisplay("{_name}={EvaluatedValue}")]
-    public class ProjectMetadataInstance : IKeyed, IValued, IEquatable<ProjectMetadataInstance>, ITranslatable, IMetadatum, IDeepCloneable<ProjectMetadataInstance>, IImmutable
+    public class ProjectMetadataInstance : IEquatable<ProjectMetadataInstance>, ITranslatable, IMetadatum, IDeepCloneable<ProjectMetadataInstance>, IImmutable
     {
         /// <summary>
         /// Name of the metadatum
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index ef40362e4eb..a44626cccae 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -21,6 +21,8 @@
 using System.Collections.ObjectModel;
 using Microsoft.Build.Shared.FileSystem;
 
+using Microsoft.NET.StringTools;
+
 namespace Microsoft.Build.Execution
 {
     /// <summary>
@@ -308,7 +310,7 @@ IFileSystem fileSystem
 
                 if (assemblyFile != null && !Path.IsPathRooted(assemblyFile))
                 {
-                    assemblyFile = OpportunisticIntern.InternStringIfPossible(Path.Combine(directoryOfImportingFile, assemblyFile));
+                    assemblyFile = Strings.WeakIntern(Path.Combine(directoryOfImportingFile, assemblyFile));
                 }
 
                 if (String.Equals(taskFactory, RegisteredTaskRecord.CodeTaskFactory, StringComparison.OrdinalIgnoreCase) || String.Equals(taskFactory, RegisteredTaskRecord.XamlTaskFactory, StringComparison.OrdinalIgnoreCase))
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
index 61ad2576bb6..d8c90800210 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
@@ -25,5 +25,7 @@ internal enum BinaryLogRecordKind
         UninitializedPropertyRead,
         EnvironmentVariableRead,
         PropertyInitialValueSet,
+        NameValueList,
+        String,
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
index 264eba384ca..c6456c1a759 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
@@ -33,7 +33,12 @@ public void Replay(string sourceFilePath, CancellationToken cancellationToken)
             using (var stream = new FileStream(sourceFilePath, FileMode.Open, FileAccess.Read, FileShare.Read))
             {
                 var gzipStream = new GZipStream(stream, CompressionMode.Decompress, leaveOpen: true);
-                var binaryReader = new BinaryReader(gzipStream);
+
+                // wrapping the GZipStream in a buffered stream significantly improves performance
+                // and the max throughput is reached with a 32K buffer. See details here:
+                // https://github.com/dotnet/runtime/issues/39233#issuecomment-745598847
+                var bufferedStream = new BufferedStream(gzipStream, 32768);
+                var binaryReader = new BinaryReader(bufferedStream);
 
                 int fileFormatVersion = binaryReader.ReadInt32();
 
@@ -45,7 +50,7 @@ public void Replay(string sourceFilePath, CancellationToken cancellationToken)
                     throw new NotSupportedException(text);
                 }
 
-                var reader = new BuildEventArgsReader(binaryReader, fileFormatVersion);
+                using var reader = new BuildEventArgsReader(binaryReader, fileFormatVersion);
                 while (true)
                 {
                     if (cancellationToken.IsCancellationRequested)
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 8af5b386041..f9e9cb0b295 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -35,7 +35,13 @@ public sealed class BinaryLogger : ILogger
         //   - This was used in a now-reverted change but is the same as 9.
         // version 9:
         //   - new record kinds: EnvironmentVariableRead, PropertyReassignment, UninitializedPropertyRead
-        internal const int FileFormatVersion = 9;
+        // version 10:
+        //   - new record kinds:
+        //      * String - deduplicate strings by hashing and write a string record before it's used
+        //      * NameValueList - deduplicate arrays of name-value pairs such as properties, items and metadata
+        //                        in a separate record and refer to those records from regular records
+        //                        where a list used to be written in-place
+        internal const int FileFormatVersion = 10;
 
         private Stream stream;
         private BinaryWriter binaryWriter;
@@ -137,6 +143,11 @@ public void Initialize(IEventSource eventSource)
             }
 
             stream = new GZipStream(stream, CompressionLevel.Optimal);
+
+            // wrapping the GZipStream in a buffered stream significantly improves performance
+            // and the max throughput is reached with a 32K buffer. See details here:
+            // https://github.com/dotnet/runtime/issues/39233#issuecomment-745598847
+            stream = new BufferedStream(stream, bufferSize: 32768);
             binaryWriter = new BinaryWriter(stream);
             eventArgsWriter = new BuildEventArgsWriter(binaryWriter);
 
@@ -175,8 +186,8 @@ public void Shutdown()
                 {
                     eventArgsWriter.WriteBlob(BinaryLogRecordKind.ProjectImportArchive, projectImportsCollector.GetAllBytes());
                 }
-                projectImportsCollector.Close();
 
+                projectImportsCollector.Close();
                 projectImportsCollector = null;
             }
 
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 5ee2af9780c..bd9ae6e9481 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -3,6 +3,7 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Reflection;
+using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 
@@ -11,10 +12,30 @@ namespace Microsoft.Build.Logging
     /// <summary>
     /// Deserializes and returns BuildEventArgs-derived objects from a BinaryReader
     /// </summary>
-    public class BuildEventArgsReader
+    public class BuildEventArgsReader : IDisposable
     {
         private readonly BinaryReader binaryReader;
         private readonly int fileFormatVersion;
+        private long recordNumber = 0;
+
+        /// <summary>
+        /// A list of string records we've encountered so far. If it's a small string, it will be the string directly.
+        /// If it's a large string, it will be a pointer into a temporary page file where the string content will be
+        /// written out to. This is necessary so we don't keep all the strings in memory when reading large binlogs.
+        /// We will OOM otherwise.
+        /// </summary>
+        private readonly List<object> stringRecords = new List<object>();
+
+        /// <summary>
+        /// A list of dictionaries we've encountered so far. Dictionaries are referred to by their order in this list.
+        /// </summary>
+        private readonly List<(int keyIndex, int valueIndex)[]> nameValueListRecords = new List<(int, int)[]>();
+
+        /// <summary>
+        /// A "page-file" for storing strings we've read so far. Keeping them in memory would OOM the 32-bit MSBuild
+        /// when reading large binlogs. This is a no-op in a 64-bit process.
+        /// </summary>
+        private StringStorage stringStorage = new StringStorage();
 
         // reflection is needed to set these three fields because public constructors don't provide
         // a way to set these from the outside
@@ -36,6 +57,15 @@ public BuildEventArgsReader(BinaryReader binaryReader, int fileFormatVersion)
             this.fileFormatVersion = fileFormatVersion;
         }
 
+        public void Dispose()
+        {
+            if (stringStorage != null)
+            {
+                stringStorage.Dispose();
+                stringStorage = null;
+            }
+        }
+
         /// <summary>
         /// Raised when the log reader encounters a binary blob embedded in the stream.
         /// The arguments include the blob kind and the byte buffer with the contents.
@@ -49,9 +79,25 @@ public BuildEventArgs Read()
         {
             BinaryLogRecordKind recordKind = (BinaryLogRecordKind)ReadInt32();
 
-            while (IsBlob(recordKind))
+            // Skip over data storage records since they don't result in a BuildEventArgs.
+            // just ingest their data and continue.
+            while (IsAuxiliaryRecord(recordKind))
             {
-                ReadBlob(recordKind);
+                // these are ordered by commonality
+                if (recordKind == BinaryLogRecordKind.String)
+                {
+                    ReadStringRecord();
+                }
+                else if (recordKind == BinaryLogRecordKind.NameValueList)
+                {
+                    ReadNameValueList();
+                }
+                else if (recordKind == BinaryLogRecordKind.ProjectImportArchive)
+                {
+                    ReadBlob(recordKind);
+                }
+
+                recordNumber += 1;
 
                 recordKind = (BinaryLogRecordKind)ReadInt32();
             }
@@ -128,15 +174,16 @@ public BuildEventArgs Read()
                     break;
             }
 
+            recordNumber += 1;
+
             return result;
         }
 
-        /// <summary>
-        /// For now it's just the ProjectImportArchive.
-        /// </summary>
-        private static bool IsBlob(BinaryLogRecordKind recordKind)
+        private static bool IsAuxiliaryRecord(BinaryLogRecordKind recordKind)
         {
-            return recordKind == BinaryLogRecordKind.ProjectImportArchive;
+            return recordKind == BinaryLogRecordKind.String
+                || recordKind == BinaryLogRecordKind.NameValueList
+                || recordKind == BinaryLogRecordKind.ProjectImportArchive;
         }
 
         private void ReadBlob(BinaryLogRecordKind kind)
@@ -146,6 +193,54 @@ private void ReadBlob(BinaryLogRecordKind kind)
             OnBlobRead?.Invoke(kind, bytes);
         }
 
+        private void ReadNameValueList()
+        {
+            int count = ReadInt32();
+
+            var list = new (int, int)[count];
+            for (int i = 0; i < count; i++)
+            {
+                int key = ReadInt32();
+                int value = ReadInt32();
+                list[i] = (key, value);
+            }
+
+            nameValueListRecords.Add(list);
+        }
+
+        private IDictionary<string, string> GetNameValueList(int id)
+        {
+            id -= BuildEventArgsWriter.NameValueRecordStartIndex;
+            if (id >= 0 && id < nameValueListRecords.Count)
+            {
+                var list = nameValueListRecords[id];
+
+                var dictionary = new Dictionary<string, string>(list.Length);
+                for (int i = 0; i < list.Length; i++)
+                {
+                    string key = GetStringFromRecord(list[i].keyIndex);
+                    string value = GetStringFromRecord(list[i].valueIndex);
+                    if (key != null)
+                    {
+                        dictionary[key] = value;
+                    }
+                }
+
+                return dictionary;
+            }
+
+            // this should never happen for valid binlogs
+            throw new InvalidDataException(
+                $"NameValueList record number {recordNumber} is invalid: index {id} is not within {stringRecords.Count}.");
+        }
+
+        private void ReadStringRecord()
+        {
+            string text = ReadString();
+            object storedString = stringStorage.Add(text);
+            stringRecords.Add(storedString);
+        }
+
         private BuildEventArgs ReadProjectImportedEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
@@ -232,7 +327,7 @@ private BuildEventArgs ReadBuildFinishedEventArgs()
         private BuildEventArgs ReadProjectEvaluationStartedEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
-            var projectFile = ReadString();
+            var projectFile = ReadDeduplicatedString();
 
             var e = new ProjectEvaluationStartedEventArgs(fields.Message)
             {
@@ -245,7 +340,7 @@ private BuildEventArgs ReadProjectEvaluationStartedEventArgs()
         private BuildEventArgs ReadProjectEvaluationFinishedEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
-            var projectFile = ReadString();
+            var projectFile = ReadDeduplicatedString();
 
             var e = new ProjectEvaluationFinishedEventArgs(fields.Message)
             {
@@ -264,8 +359,11 @@ private BuildEventArgs ReadProjectEvaluationFinishedEventArgs()
                     var d = new Dictionary<EvaluationLocation, ProfiledLocation>(count);
                     for (int i = 0; i < count; i++)
                     {
-                        d.Add(ReadEvaluationLocation(), ReadProfiledLocation());
+                        var evaluationLocation = ReadEvaluationLocation();
+                        var profiledLocation = ReadProfiledLocation();
+                        d[evaluationLocation] = profiledLocation;
                     }
+
                     e.ProfilerResult = new ProfilerResult(d);
                 }
             }
@@ -284,10 +382,10 @@ private BuildEventArgs ReadProjectStartedEventArgs()
 
             var projectFile = ReadOptionalString();
             var projectId = ReadInt32();
-            var targetNames = ReadString();
+            var targetNames = ReadDeduplicatedString();
             var toolsVersion = ReadOptionalString();
 
-            Dictionary<string, string> globalProperties = null;
+            IDictionary<string, string> globalProperties = null;
 
             if (fileFormatVersion > 6)
             {
@@ -298,7 +396,7 @@ private BuildEventArgs ReadProjectStartedEventArgs()
             }
 
             var propertyList = ReadPropertyList();
-            var itemList = ReadItems();
+            var itemList = ReadProjectItems();
 
             var e = new ProjectStartedEventArgs(
                 projectId,
@@ -361,7 +459,7 @@ private BuildEventArgs ReadTargetFinishedEventArgs()
             var projectFile = ReadOptionalString();
             var targetFile = ReadOptionalString();
             var targetName = ReadOptionalString();
-            var targetOutputItemList = ReadItemList();
+            var targetOutputItemList = ReadTaskItemList();
 
             var e = new TargetFinishedEventArgs(
                 fields.Message,
@@ -525,7 +623,7 @@ private BuildEventArgs ReadEnvironmentVariableReadEventArgs()
             var fields = ReadBuildEventArgsFields();
             var importance = (MessageImportance)ReadInt32();
 
-            var environmentVariableName = ReadString();
+            var environmentVariableName = ReadDeduplicatedString();
 
             var e = new EnvironmentVariableReadEventArgs(
                 environmentVariableName,
@@ -542,10 +640,10 @@ private BuildEventArgs ReadPropertyReassignmentEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
             var importance = (MessageImportance)ReadInt32();
-            string propertyName = ReadString();
-            string previousValue = ReadString();
-            string newValue = ReadString();
-            string location = ReadString();
+            string propertyName = ReadDeduplicatedString();
+            string previousValue = ReadDeduplicatedString();
+            string newValue = ReadDeduplicatedString();
+            string location = ReadDeduplicatedString();
 
             var e = new PropertyReassignmentEventArgs(
                 propertyName,
@@ -565,7 +663,7 @@ private BuildEventArgs ReadUninitializedPropertyReadEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
             var importance = (MessageImportance)ReadInt32();
-            string propertyName = ReadString();
+            string propertyName = ReadDeduplicatedString();
 
             var e = new UninitializedPropertyReadEventArgs(
                 propertyName,
@@ -582,9 +680,9 @@ private BuildEventArgs ReadPropertyInitialValueSetEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
             var importance = (MessageImportance)ReadInt32();
-            string propertyName = ReadString();
-            string propertyValue = ReadString();
-            string propertySource = ReadString();
+            string propertyName = ReadDeduplicatedString();
+            string propertyValue = ReadDeduplicatedString();
+            string propertySource = ReadDeduplicatedString();
 
             var e = new PropertyInitialValueSetEventArgs(
                 propertyName,
@@ -625,7 +723,7 @@ private BuildEventArgsFields ReadBuildEventArgsFields()
 
             if ((flags & BuildEventArgsFieldFlags.Message) != 0)
             {
-                result.Message = ReadString();
+                result.Message = ReadDeduplicatedString();
             }
 
             if ((flags & BuildEventArgsFieldFlags.BuildEventContext) != 0)
@@ -640,12 +738,12 @@ private BuildEventArgsFields ReadBuildEventArgsFields()
 
             if ((flags & BuildEventArgsFieldFlags.HelpHeyword) != 0)
             {
-                result.HelpKeyword = ReadString();
+                result.HelpKeyword = ReadDeduplicatedString();
             }
 
             if ((flags & BuildEventArgsFieldFlags.SenderName) != 0)
             {
-                result.SenderName = ReadString();
+                result.SenderName = ReadDeduplicatedString();
             }
 
             if ((flags & BuildEventArgsFieldFlags.Timestamp) != 0)
@@ -655,22 +753,22 @@ private BuildEventArgsFields ReadBuildEventArgsFields()
 
             if ((flags & BuildEventArgsFieldFlags.Subcategory) != 0)
             {
-                result.Subcategory = ReadString();
+                result.Subcategory = ReadDeduplicatedString();
             }
 
             if ((flags & BuildEventArgsFieldFlags.Code) != 0)
             {
-                result.Code = ReadString();
+                result.Code = ReadDeduplicatedString();
             }
 
             if ((flags & BuildEventArgsFieldFlags.File) != 0)
             {
-                result.File = ReadString();
+                result.File = ReadDeduplicatedString();
             }
 
             if ((flags & BuildEventArgsFieldFlags.ProjectFile) != 0)
             {
-                result.ProjectFile = ReadString();
+                result.ProjectFile = ReadDeduplicatedString();
             }
 
             if ((flags & BuildEventArgsFieldFlags.LineNumber) != 0)
@@ -761,16 +859,33 @@ private BuildEventContext ReadBuildEventContext()
             return result;
         }
 
-        private Dictionary<string, string> ReadStringDictionary()
+        private IDictionary<string, string> ReadStringDictionary()
         {
-            int count = ReadInt32();
+            if (fileFormatVersion < 10)
+            {
+                return ReadLegacyStringDictionary();
+            }
+
+            int index = ReadInt32();
+            if (index == 0)
+            {
+                return null;
+            }
+
+            var record = GetNameValueList(index);
+            return record;
+        }
 
+        private IDictionary<string, string> ReadLegacyStringDictionary()
+        {
+            int count = ReadInt32();
             if (count == 0)
             {
                 return null;
             }
 
-            Dictionary<string, string> result = new Dictionary<string, string>(count);
+            var result = new Dictionary<string, string>(count);
+
             for (int i = 0; i < count; i++)
             {
                 string key = ReadString();
@@ -783,16 +898,29 @@ private Dictionary<string, string> ReadStringDictionary()
 
         private class TaskItem : ITaskItem
         {
+            private static readonly Dictionary<string, string> emptyMetadata = new Dictionary<string, string>();
+
             public string ItemSpec { get; set; }
-            public Dictionary<string, string> Metadata { get; } = new Dictionary<string, string>();
+            public IDictionary<string, string> Metadata { get; }
+
+            public TaskItem()
+            {
+                Metadata = new Dictionary<string, string>();
+            }
+
+            public TaskItem(string itemSpec, IDictionary<string, string> metadata)
+            {
+                ItemSpec = itemSpec;
+                Metadata = metadata ?? emptyMetadata;
+            }
 
             public int MetadataCount => Metadata.Count;
 
-            public ICollection MetadataNames => Metadata.Keys;
+            public ICollection MetadataNames => (ICollection)Metadata.Keys;
 
             public IDictionary CloneCustomMetadata()
             {
-                return Metadata;
+                return (IDictionary)Metadata;
             }
 
             public void CopyMetadataTo(ITaskItem destinationItem)
@@ -814,25 +942,23 @@ public void SetMetadata(string metadataName, string metadataValue)
             {
                 throw new NotImplementedException();
             }
-        }
-
-        private ITaskItem ReadItem()
-        {
-            var item = new TaskItem();
-            item.ItemSpec = ReadString();
 
-            int count = ReadInt32();
-            for (int i = 0; i < count; i++)
+            public override string ToString()
             {
-                string name = ReadString();
-                string value = ReadString();
-                item.Metadata[name] = value;
+                return $"{ItemSpec} Metadata: {MetadataCount}";
             }
+        }
 
-            return item;
+        private ITaskItem ReadTaskItem()
+        {
+            string itemSpec = ReadDeduplicatedString();
+            var metadata = ReadStringDictionary();
+
+            var taskItem = new TaskItem(itemSpec, metadata);
+            return taskItem;
         }
 
-        private IEnumerable ReadItems()
+        private IEnumerable ReadProjectItems()
         {
             int count = ReadInt32();
             if (count == 0)
@@ -840,19 +966,40 @@ private IEnumerable ReadItems()
                 return null;
             }
 
-            var list = new List<DictionaryEntry>(count);
+            List<DictionaryEntry> list;
 
-            for (int i = 0; i < count; i++)
+            // starting with format version 10 project items are grouped by name
+            // so we only have to write the name once, and then the count of items
+            // with that name. When reading a legacy binlog we need to read the
+            // old style flat list where the name is duplicated for each item.
+            if (fileFormatVersion < 10)
             {
-                string key = ReadString();
-                ITaskItem item = ReadItem();
-                list.Add(new DictionaryEntry(key, item));
+                list = new List<DictionaryEntry>(count);
+                for (int i = 0; i < count; i++)
+                {
+                    string itemName = ReadString();
+                    ITaskItem item = ReadTaskItem();
+                    list.Add(new DictionaryEntry(itemName, item));
+                }
+            }
+            else
+            {
+                list = new List<DictionaryEntry>();
+                for (int i = 0; i < count; i++)
+                {
+                    string itemName = ReadDeduplicatedString();
+                    var items = ReadTaskItemList();
+                    foreach (var item in items)
+                    {
+                        list.Add(new DictionaryEntry(itemName, item));
+                    }
+                }
             }
 
             return list;
         }
 
-        private IEnumerable ReadItemList()
+        private IEnumerable ReadTaskItemList()
         {
             int count = ReadInt32();
             if (count == 0)
@@ -864,28 +1011,70 @@ private IEnumerable ReadItemList()
 
             for (int i = 0; i < count; i++)
             {
-                ITaskItem item = ReadItem();
+                ITaskItem item = ReadTaskItem();
                 list.Add(item);
             }
 
             return list;
         }
 
+        private string ReadString()
+        {
+            return binaryReader.ReadString();
+        }
+
         private string ReadOptionalString()
         {
-            if (ReadBoolean())
+            if (fileFormatVersion < 10)
             {
-                return ReadString();
+                if (ReadBoolean())
+                {
+                    return ReadString();
+                }
+                else
+                {
+                    return null;
+                }
             }
-            else
+
+            return ReadDeduplicatedString();
+        }
+
+        private string ReadDeduplicatedString()
+        {
+            if (fileFormatVersion < 10)
             {
-                return null;
+                return ReadString();
             }
+
+            int index = ReadInt32();
+            return GetStringFromRecord(index);
         }
 
-        private string ReadString()
+        private string GetStringFromRecord(int index)
         {
-            return binaryReader.ReadString();
+            if (index == 0)
+            {
+                return null;
+            }
+            else if (index == 1)
+            {
+                return string.Empty;
+            }
+
+            // we reserve numbers 2-9 for future use.
+            // the writer assigns 10 as the index of the first string
+            index -= BuildEventArgsWriter.StringStartIndex;
+            if (index >= 0 && index < this.stringRecords.Count)
+            {
+                object storedString = stringRecords[index];
+                string result = stringStorage.Get(storedString);
+                return result;
+            }
+
+            // this should never happen for valid binlogs
+            throw new InvalidDataException(
+                $"String record number {recordNumber} is invalid: string index {index} is not within {stringRecords.Count}.");
         }
 
         private int ReadInt32()
@@ -972,10 +1161,150 @@ private EvaluationLocation ReadEvaluationLocation()
                 {
                     parentId = ReadInt64();
                 }
+
                 return new EvaluationLocation(id, parentId, evaluationPass, evaluationDescription, file, line, elementName, description, kind);
             }
 
             return new EvaluationLocation(0, null, evaluationPass, evaluationDescription, file, line, elementName, description, kind);
         }
+
+        /// <summary>
+        /// Locates the string in the page file.
+        /// </summary>
+        internal class StringPosition
+        {
+            /// <summary>
+            /// Offset in the file.
+            /// </summary>
+            public long FilePosition;
+
+            /// <summary>
+            /// The length of the string in chars (not bytes).
+            /// </summary>
+            public int StringLength;
+        }
+
+        /// <summary>
+        /// Stores large strings in a temp file on disk, to avoid keeping all strings in memory.
+        /// Only creates a file for 32-bit MSBuild.exe, just returns the string directly on 64-bit.
+        /// </summary>
+        internal class StringStorage : IDisposable
+        {
+            private readonly string filePath;
+            private FileStream stream;
+            private StreamWriter streamWriter;
+            private readonly StreamReader streamReader;
+            private readonly StringBuilder stringBuilder;
+
+            public const int StringSizeThreshold = 1024;
+
+            public StringStorage()
+            {
+                if (!Environment.Is64BitProcess)
+                {
+                    filePath = Path.GetTempFileName();
+                    var utf8noBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
+                    stream = new FileStream(
+                        filePath,
+                        FileMode.OpenOrCreate,
+                        FileAccess.ReadWrite,
+                        FileShare.None,
+                        bufferSize: 4096, // 4096 seems to have the best performance on SSD
+                        FileOptions.RandomAccess | FileOptions.DeleteOnClose);
+
+                    // 65536 has no particular significance, and maybe could be tuned
+                    // but 65536 performs well enough and isn't a lot of memory for a singleton
+                    streamWriter = new StreamWriter(stream, utf8noBom, 65536);
+                    streamWriter.AutoFlush = true;
+                    streamReader = new StreamReader(stream, utf8noBom);
+                    stringBuilder = new StringBuilder();
+                }
+            }
+
+            private long totalAllocatedShortStrings = 0;
+
+            public object Add(string text)
+            {
+                if (filePath == null)
+                {
+                    // on 64-bit, we have as much memory as we want
+                    // so no need to write to the file at all
+                    return text;
+                }
+
+                // Tradeoff between not crashing with OOM on large binlogs and
+                // keeping the playback of smaller binlogs relatively fast.
+                // It is slow to store all small strings in the file and constantly
+                // seek to retrieve them. Instead we'll keep storing small strings
+                // in memory until we allocate 2 GB. After that, all strings go to
+                // the file.
+                // Win-win: small binlog playback is fast and large binlog playback
+                // doesn't OOM.
+                if (text.Length <= StringSizeThreshold && totalAllocatedShortStrings < 1_000_000_000)
+                {
+                    totalAllocatedShortStrings += text.Length;
+                    return text;
+                }
+
+                var stringPosition = new StringPosition();
+
+                stringPosition.FilePosition = stream.Position;
+
+                streamWriter.Write(text);
+
+                stringPosition.StringLength = text.Length;
+                return stringPosition;
+            }
+
+            public string Get(object storedString)
+            {
+                if (storedString is string text)
+                {
+                    return text;
+                }
+
+                var position = (StringPosition)storedString;
+
+                stream.Position = position.FilePosition;
+                stringBuilder.Length = position.StringLength;
+                for (int i = 0; i < position.StringLength; i++)
+                {
+                    char ch = (char)streamReader.Read();
+                    stringBuilder[i] = ch;
+                }
+
+                stream.Position = stream.Length;
+                streamReader.DiscardBufferedData();
+
+                string result = stringBuilder.ToString();
+                stringBuilder.Clear();
+                return result;
+            }
+
+            public void Dispose()
+            {
+                try
+                {
+                    if (streamWriter != null)
+                    {
+                        streamWriter.Dispose();
+                        streamWriter = null;
+                    }
+
+                    if (stream != null)
+                    {
+                        stream.Dispose();
+                        stream = null;
+                    }
+                }
+                catch
+                {
+                    // The StringStorage class is not crucial for other functionality and if 
+                    // there are exceptions when closing the temp file, it's too late to do anything about it.
+                    // Since we don't want to disrupt anything and the file is in the TEMP directory, it will
+                    // get cleaned up at some point anyway.
+                }
+            }
+        }
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index bc8f203903e..3b37d1404cf 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
+using Microsoft.Build.Internal;
 
 namespace Microsoft.Build.Logging
 {
@@ -15,7 +16,85 @@ namespace Microsoft.Build.Logging
     /// </summary>
     internal class BuildEventArgsWriter
     {
-        private readonly BinaryWriter binaryWriter;
+        private readonly Stream originalStream;
+
+        /// <summary>
+        /// When writing the current record, first write it to a memory stream,
+        /// then flush to the originalStream. This is needed so that if we discover
+        /// that we need to write a string record in the middle of writing the
+        /// current record, we will write the string record to the original stream
+        /// and the current record will end up after the string record.
+        /// </summary>
+        private readonly MemoryStream currentRecordStream;
+
+        /// <summary>
+        /// The binary writer around the originalStream.
+        /// </summary>
+        private readonly BinaryWriter originalBinaryWriter;
+
+        /// <summary>
+        /// The binary writer around the currentRecordStream.
+        /// </summary>
+        private readonly BinaryWriter currentRecordWriter;
+
+        /// <summary>
+        /// The binary writer we're currently using. Is pointing at the currentRecordWriter usually,
+        /// but sometimes we repoint it to the originalBinaryWriter temporarily, when writing string
+        /// and name-value records.
+        /// </summary>
+        private BinaryWriter binaryWriter;
+
+        /// <summary>
+        /// Hashtable used for deduplicating strings. When we need to write a string,
+        /// we check in this hashtable first, and if we've seen the string before,
+        /// just write out its index. Otherwise write out a string record, and then
+        /// write the string index. A string record is guaranteed to precede its first
+        /// usage.
+        /// The reader will read the string records first and then be able to retrieve
+        /// a string by its index. This allows us to keep the format streaming instead
+        /// of writing one giant string table at the end. If a binlog is interrupted
+        /// we'll be able to use all the information we've discovered thus far.
+        /// </summary>
+        private readonly Dictionary<HashKey, int> stringHashes = new Dictionary<HashKey, int>();
+
+        /// <summary>
+        /// Hashtable used for deduplicating name-value lists. Same as strings.
+        /// </summary>
+        private readonly Dictionary<HashKey, int> nameValueListHashes = new Dictionary<HashKey, int>();
+
+        /// <summary>
+        /// Index 0 is null, Index 1 is the empty string.
+        /// Reserve indices 2-9 for future use. Start indexing actual strings at 10.
+        /// </summary>
+        internal const int StringStartIndex = 10;
+
+        /// <summary>
+        /// Let's reserve a few indices for future use.
+        /// </summary>
+        internal const int NameValueRecordStartIndex = 10;
+
+        /// <summary>
+        /// 0 is null, 1 is empty string
+        /// 2-9 are reserved for future use.
+        /// Start indexing at 10.
+        /// </summary>
+        private int stringRecordId = StringStartIndex;
+
+        /// <summary>
+        /// The index of the next record to be written.
+        /// </summary>
+        private int nameValueRecordId = NameValueRecordStartIndex;
+
+        /// <summary>
+        /// A temporary buffer we use when writing a NameValueList record. Avoids allocating a list each time.
+        /// </summary>
+        private readonly List<KeyValuePair<string, string>> nameValueListBuffer = new List<KeyValuePair<string, string>>(1024);
+
+        /// <summary>
+        /// A temporary buffer we use when hashing a NameValueList record. Stores the indices of hashed strings
+        /// instead of the actual names and values.
+        /// </summary>
+        private readonly List<KeyValuePair<int, int>> nameValueIndexListBuffer = new List<KeyValuePair<int, int>>(1024);
 
         /// <summary>
         /// Initializes a new instance of BuildEventArgsWriter with a BinaryWriter
@@ -23,13 +102,31 @@ internal class BuildEventArgsWriter
         /// <param name="binaryWriter">A BinaryWriter to write the BuildEventArgs instances to</param>
         public BuildEventArgsWriter(BinaryWriter binaryWriter)
         {
-            this.binaryWriter = binaryWriter;
+            this.originalStream = binaryWriter.BaseStream;
+
+            // this doesn't exceed 30K for smaller binlogs so seems like a reasonable
+            // starting point to avoid reallocations in the common case
+            this.currentRecordStream = new MemoryStream(65536);
+
+            this.originalBinaryWriter = binaryWriter;
+            this.currentRecordWriter = new BinaryWriter(currentRecordStream);
+
+            this.binaryWriter = currentRecordWriter;
         }
 
         /// <summary>
         /// Write a provided instance of BuildEventArgs to the BinaryWriter
         /// </summary>
         public void Write(BuildEventArgs e)
+        {
+            WriteCore(e);
+
+            // flush the current record and clear the MemoryStream to prepare for next use
+            currentRecordStream.WriteTo(originalStream);
+            currentRecordStream.SetLength(0);
+        }
+
+        private void WriteCore(BuildEventArgs e)
         {
             // the cases are ordered by most used first for performance
             if (e is BuildMessageEventArgs)
@@ -101,11 +198,41 @@ public void Write(BuildEventArgs e)
 
         public void WriteBlob(BinaryLogRecordKind kind, byte[] bytes)
         {
+            // write the blob directly to the underlying writer,
+            // bypassing the memory stream
+            using var redirection = RedirectWritesToOriginalWriter();
+
             Write(kind);
             Write(bytes.Length);
             Write(bytes);
         }
 
+        /// <summary>
+        /// Switches the binaryWriter used by the Write* methods to the direct underlying stream writer
+        /// until the disposable is disposed. Useful to bypass the currentRecordWriter to write a string,
+        /// blob or NameValueRecord that should precede the record being currently written.
+        /// </summary>
+        private IDisposable RedirectWritesToOriginalWriter()
+        {
+            binaryWriter = originalBinaryWriter;
+            return new RedirectionScope(this);
+        }
+
+        private struct RedirectionScope : IDisposable
+        {
+            private readonly BuildEventArgsWriter _writer;
+
+            public RedirectionScope(BuildEventArgsWriter buildEventArgsWriter)
+            {
+                _writer = buildEventArgsWriter;
+            }
+
+            public void Dispose()
+            {
+                _writer.binaryWriter = _writer.currentRecordWriter;
+            }
+        }
+
         private void Write(BuildStartedEventArgs e)
         {
             Write(BinaryLogRecordKind.BuildStarted);
@@ -124,15 +251,15 @@ private void Write(ProjectEvaluationStartedEventArgs e)
         {
             Write(BinaryLogRecordKind.ProjectEvaluationStarted);
             WriteBuildEventArgsFields(e);
-            Write(e.ProjectFile);
+            WriteDeduplicatedString(e.ProjectFile);
         }
 
         private void Write(ProjectEvaluationFinishedEventArgs e)
         {
             Write(BinaryLogRecordKind.ProjectEvaluationFinished);
-            
+
             WriteBuildEventArgsFields(e);
-            Write(e.ProjectFile);
+            WriteDeduplicatedString(e.ProjectFile);
 
             Write(e.ProfilerResult.HasValue);
             if (e.ProfilerResult.HasValue)
@@ -162,11 +289,11 @@ private void Write(ProjectStartedEventArgs e)
                 Write(e.ParentProjectBuildEventContext);
             }
 
-            WriteOptionalString(e.ProjectFile);
+            WriteDeduplicatedString(e.ProjectFile);
 
             Write(e.ProjectId);
-            Write(e.TargetNames);
-            WriteOptionalString(e.ToolsVersion);
+            WriteDeduplicatedString(e.TargetNames);
+            WriteDeduplicatedString(e.ToolsVersion);
 
             if (e.GlobalProperties == null)
             {
@@ -180,14 +307,14 @@ private void Write(ProjectStartedEventArgs e)
 
             WriteProperties(e.Properties);
 
-            WriteItems(e.Items);
+            WriteProjectItems(e.Items);
         }
 
         private void Write(ProjectFinishedEventArgs e)
         {
             Write(BinaryLogRecordKind.ProjectFinished);
             WriteBuildEventArgsFields(e);
-            WriteOptionalString(e.ProjectFile);
+            WriteDeduplicatedString(e.ProjectFile);
             Write(e.Succeeded);
         }
 
@@ -195,11 +322,11 @@ private void Write(TargetStartedEventArgs e)
         {
             Write(BinaryLogRecordKind.TargetStarted);
             WriteBuildEventArgsFields(e);
-            WriteOptionalString(e.TargetName);
-            WriteOptionalString(e.ProjectFile);
-            WriteOptionalString(e.TargetFile);
-            WriteOptionalString(e.ParentTarget);
-            Write((int) e.BuildReason);
+            WriteDeduplicatedString(e.TargetName);
+            WriteDeduplicatedString(e.ProjectFile);
+            WriteDeduplicatedString(e.TargetFile);
+            WriteDeduplicatedString(e.ParentTarget);
+            Write((int)e.BuildReason);
         }
 
         private void Write(TargetFinishedEventArgs e)
@@ -207,19 +334,19 @@ private void Write(TargetFinishedEventArgs e)
             Write(BinaryLogRecordKind.TargetFinished);
             WriteBuildEventArgsFields(e);
             Write(e.Succeeded);
-            WriteOptionalString(e.ProjectFile);
-            WriteOptionalString(e.TargetFile);
-            WriteOptionalString(e.TargetName);
-            WriteItemList(e.TargetOutputs);
+            WriteDeduplicatedString(e.ProjectFile);
+            WriteDeduplicatedString(e.TargetFile);
+            WriteDeduplicatedString(e.TargetName);
+            WriteTaskItemList(e.TargetOutputs);
         }
 
         private void Write(TaskStartedEventArgs e)
         {
             Write(BinaryLogRecordKind.TaskStarted);
             WriteBuildEventArgsFields(e);
-            WriteOptionalString(e.TaskName);
-            WriteOptionalString(e.ProjectFile);
-            WriteOptionalString(e.TaskFile);
+            WriteDeduplicatedString(e.TaskName);
+            WriteDeduplicatedString(e.ProjectFile);
+            WriteDeduplicatedString(e.TaskFile);
         }
 
         private void Write(TaskFinishedEventArgs e)
@@ -227,19 +354,19 @@ private void Write(TaskFinishedEventArgs e)
             Write(BinaryLogRecordKind.TaskFinished);
             WriteBuildEventArgsFields(e);
             Write(e.Succeeded);
-            WriteOptionalString(e.TaskName);
-            WriteOptionalString(e.ProjectFile);
-            WriteOptionalString(e.TaskFile);
+            WriteDeduplicatedString(e.TaskName);
+            WriteDeduplicatedString(e.ProjectFile);
+            WriteDeduplicatedString(e.TaskFile);
         }
 
         private void Write(BuildErrorEventArgs e)
         {
             Write(BinaryLogRecordKind.Error);
             WriteBuildEventArgsFields(e);
-            WriteOptionalString(e.Subcategory);
-            WriteOptionalString(e.Code);
-            WriteOptionalString(e.File);
-            WriteOptionalString(e.ProjectFile);
+            WriteDeduplicatedString(e.Subcategory);
+            WriteDeduplicatedString(e.Code);
+            WriteDeduplicatedString(e.File);
+            WriteDeduplicatedString(e.ProjectFile);
             Write(e.LineNumber);
             Write(e.ColumnNumber);
             Write(e.EndLineNumber);
@@ -250,10 +377,10 @@ private void Write(BuildWarningEventArgs e)
         {
             Write(BinaryLogRecordKind.Warning);
             WriteBuildEventArgsFields(e);
-            WriteOptionalString(e.Subcategory);
-            WriteOptionalString(e.Code);
-            WriteOptionalString(e.File);
-            WriteOptionalString(e.ProjectFile);
+            WriteDeduplicatedString(e.Subcategory);
+            WriteDeduplicatedString(e.Code);
+            WriteDeduplicatedString(e.File);
+            WriteDeduplicatedString(e.ProjectFile);
             Write(e.LineNumber);
             Write(e.ColumnNumber);
             Write(e.EndLineNumber);
@@ -319,17 +446,17 @@ private void Write(ProjectImportedEventArgs e)
             Write(BinaryLogRecordKind.ProjectImported);
             WriteMessageFields(e);
             Write(e.ImportIgnored);
-            WriteOptionalString(e.ImportedProjectFile);
-            WriteOptionalString(e.UnexpandedProject);
+            WriteDeduplicatedString(e.ImportedProjectFile);
+            WriteDeduplicatedString(e.UnexpandedProject);
         }
 
         private void Write(TargetSkippedEventArgs e)
         {
             Write(BinaryLogRecordKind.TargetSkipped);
             WriteMessageFields(e);
-            WriteOptionalString(e.TargetFile);
-            WriteOptionalString(e.TargetName);
-            WriteOptionalString(e.ParentTarget);
+            WriteDeduplicatedString(e.TargetFile);
+            WriteDeduplicatedString(e.TargetName);
+            WriteDeduplicatedString(e.ParentTarget);
             Write((int)e.BuildReason);
         }
 
@@ -343,41 +470,41 @@ private void Write(PropertyReassignmentEventArgs e)
         {
             Write(BinaryLogRecordKind.PropertyReassignment);
             WriteMessageFields(e);
-            Write(e.PropertyName);
-            Write(e.PreviousValue);
-            Write(e.NewValue);
-            Write(e.Location);
+            WriteDeduplicatedString(e.PropertyName);
+            WriteDeduplicatedString(e.PreviousValue);
+            WriteDeduplicatedString(e.NewValue);
+            WriteDeduplicatedString(e.Location);
         }
 
         private void Write(UninitializedPropertyReadEventArgs e)
         {
             Write(BinaryLogRecordKind.UninitializedPropertyRead);
             WriteMessageFields(e);
-            Write(e.PropertyName);
+            WriteDeduplicatedString(e.PropertyName);
         }
 
         private void Write(PropertyInitialValueSetEventArgs e)
         {
             Write(BinaryLogRecordKind.PropertyInitialValueSet);
             WriteMessageFields(e);
-            Write(e.PropertyName);
-            Write(e.PropertyValue);
-            Write(e.PropertySource);
+            WriteDeduplicatedString(e.PropertyName);
+            WriteDeduplicatedString(e.PropertyValue);
+            WriteDeduplicatedString(e.PropertySource);
         }
 
         private void Write(EnvironmentVariableReadEventArgs e)
         {
             Write(BinaryLogRecordKind.EnvironmentVariableRead);
             WriteMessageFields(e);
-            Write(e.EnvironmentVariableName);
+            WriteDeduplicatedString(e.EnvironmentVariableName);
         }
 
         private void Write(TaskCommandLineEventArgs e)
         {
             Write(BinaryLogRecordKind.TaskCommandLine);
             WriteMessageFields(e);
-            WriteOptionalString(e.CommandLine);
-            WriteOptionalString(e.TaskName);
+            WriteDeduplicatedString(e.CommandLine);
+            WriteDeduplicatedString(e.TaskName);
         }
 
         private void WriteBuildEventArgsFields(BuildEventArgs e)
@@ -391,7 +518,7 @@ private void WriteBaseFields(BuildEventArgs e, BuildEventArgsFieldFlags flags)
         {
             if ((flags & BuildEventArgsFieldFlags.Message) != 0)
             {
-                Write(e.Message);
+                WriteDeduplicatedString(e.Message);
             }
 
             if ((flags & BuildEventArgsFieldFlags.BuildEventContext) != 0)
@@ -406,12 +533,12 @@ private void WriteBaseFields(BuildEventArgs e, BuildEventArgsFieldFlags flags)
 
             if ((flags & BuildEventArgsFieldFlags.HelpHeyword) != 0)
             {
-                Write(e.HelpKeyword);
+                WriteDeduplicatedString(e.HelpKeyword);
             }
 
             if ((flags & BuildEventArgsFieldFlags.SenderName) != 0)
             {
-                Write(e.SenderName);
+                WriteDeduplicatedString(e.SenderName);
             }
 
             if ((flags & BuildEventArgsFieldFlags.Timestamp) != 0)
@@ -431,22 +558,22 @@ private void WriteMessageFields(BuildMessageEventArgs e)
 
             if ((flags & BuildEventArgsFieldFlags.Subcategory) != 0)
             {
-                Write(e.Subcategory);
+                WriteDeduplicatedString(e.Subcategory);
             }
 
             if ((flags & BuildEventArgsFieldFlags.Code) != 0)
             {
-                Write(e.Code);
+                WriteDeduplicatedString(e.Code);
             }
 
             if ((flags & BuildEventArgsFieldFlags.File) != 0)
             {
-                Write(e.File);
+                WriteDeduplicatedString(e.File);
             }
 
             if ((flags & BuildEventArgsFieldFlags.ProjectFile) != 0)
             {
-                Write(e.ProjectFile);
+                WriteDeduplicatedString(e.ProjectFile);
             }
 
             if ((flags & BuildEventArgsFieldFlags.LineNumber) != 0)
@@ -554,25 +681,24 @@ private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventAr
             return flags;
         }
 
-        private void WriteItemList(IEnumerable items)
+        private void WriteTaskItemList(IEnumerable items)
         {
             var taskItems = items as IEnumerable<ITaskItem>;
-            if (taskItems != null)
+            if (taskItems == null)
             {
-                Write(taskItems.Count());
-
-                foreach (var item in taskItems)
-                {
-                    Write(item);
-                }
-
+                Write(false);
                 return;
             }
 
-            Write(0);
+            Write(taskItems.Count());
+
+            foreach (var item in taskItems)
+            {
+                Write(item);
+            }
         }
 
-        private void WriteItems(IEnumerable items)
+        private void WriteProjectItems(IEnumerable items)
         {
             if (items == null)
             {
@@ -580,29 +706,31 @@ private void WriteItems(IEnumerable items)
                 return;
             }
 
-            var entries = items.OfType<DictionaryEntry>()
-                .Where(e => e.Key is string && e.Value is ITaskItem)
+            var groups = items
+                .OfType<DictionaryEntry>()
+                .GroupBy(entry => entry.Key as string, entry => entry.Value as ITaskItem)
+                .Where(group => !string.IsNullOrEmpty(group.Key))
                 .ToArray();
-            Write(entries.Length);
 
-            foreach (DictionaryEntry entry in entries)
+            Write(groups.Length);
+
+            foreach (var group in groups)
             {
-                string key = entry.Key as string;
-                ITaskItem item = entry.Value as ITaskItem;
-                Write(key);
-                Write(item);
+                WriteDeduplicatedString(group.Key);
+                WriteTaskItemList(group);
             }
         }
 
         private void Write(ITaskItem item)
         {
-            Write(item.ItemSpec);
+            WriteDeduplicatedString(item.ItemSpec);
+
+            nameValueListBuffer.Clear();
+
             IDictionary customMetadata = item.CloneCustomMetadata();
-            Write(customMetadata.Count);
 
             foreach (string metadataName in customMetadata.Keys)
             {
-                Write(metadataName);
                 string valueOrError;
 
                 try
@@ -623,8 +751,10 @@ private void Write(ITaskItem item)
                     Debug.Fail(e.ToString());
                 }
 
-                Write(valueOrError);
+                nameValueListBuffer.Add(new KeyValuePair<string, string>(metadataName, valueOrError));
             }
+
+            WriteNameValueList();
         }
 
         private void WriteProperties(IEnumerable properties)
@@ -635,26 +765,26 @@ private void WriteProperties(IEnumerable properties)
                 return;
             }
 
+            nameValueListBuffer.Clear();
+
             // there are no guarantees that the properties iterator won't change, so 
             // take a snapshot and work with the readonly copy
             var propertiesArray = properties.OfType<DictionaryEntry>().ToArray();
 
-            Write(propertiesArray.Length);
-
-            foreach (DictionaryEntry entry in propertiesArray)
+            for (int i = 0; i < propertiesArray.Length; i++)
             {
-                if (entry.Key is string && entry.Value is string)
+                DictionaryEntry entry = propertiesArray[i];
+                if (entry.Key is string key && entry.Value is string value)
                 {
-                    Write((string)entry.Key);
-                    Write((string)entry.Value);
+                    nameValueListBuffer.Add(new KeyValuePair<string, string>(key, value));
                 }
                 else
                 {
-                    // to keep the count accurate
-                    Write("");
-                    Write("");
+                    nameValueListBuffer.Add(new KeyValuePair<string, string>(string.Empty, string.Empty));
                 }
             }
+
+            WriteNameValueList();
         }
 
         private void Write(BuildEventContext buildEventContext)
@@ -668,23 +798,94 @@ private void Write(BuildEventContext buildEventContext)
             Write(buildEventContext.EvaluationId);
         }
 
-        private void Write<TKey, TValue>(IEnumerable<KeyValuePair<TKey, TValue>> keyValuePairs)
+        private void Write(IEnumerable<KeyValuePair<string, string>> keyValuePairs)
         {
-            if (keyValuePairs?.Any() == true)
+            nameValueListBuffer.Clear();
+
+            if (keyValuePairs != null)
             {
-                Write(keyValuePairs.Count());
                 foreach (var kvp in keyValuePairs)
                 {
-                    Write(kvp.Key.ToString());
-                    Write(kvp.Value.ToString());
+                    nameValueListBuffer.Add(kvp);
                 }
             }
-            else
+
+            WriteNameValueList();
+        }
+
+        private void WriteNameValueList()
+        {
+            if (nameValueListBuffer.Count == 0)
             {
-                Write(false);
+                Write((byte)0);
+                return;
+            }
+
+            HashKey hash = HashAllStrings(nameValueListBuffer);
+            if (!nameValueListHashes.TryGetValue(hash, out var recordId))
+            {
+                recordId = nameValueRecordId;
+                nameValueListHashes[hash] = nameValueRecordId;
+
+                WriteNameValueListRecord();
+
+                nameValueRecordId += 1;
+            }
+
+            Write(recordId);
+        }
+
+        /// <summary>
+        /// In the middle of writing the current record we may discover that we want to write another record
+        /// preceding the current one, specifically the list of names and values we want to reuse in the
+        /// future. As we are writing the current record to a MemoryStream first, it's OK to temporarily
+        /// switch to the direct underlying stream and write the NameValueList record first.
+        /// When the current record is done writing, the MemoryStream will flush to the underlying stream
+        /// and the current record will end up after the NameValueList record, as desired.
+        /// </summary>
+        private void WriteNameValueListRecord()
+        {
+            // Switch the binaryWriter used by the Write* methods to the direct underlying stream writer.
+            // We want this record to precede the record we're currently writing to currentRecordWriter
+            // which is backed by a MemoryStream buffer
+            using var redirectionScope = RedirectWritesToOriginalWriter();
+
+            Write(BinaryLogRecordKind.NameValueList);
+            Write(nameValueIndexListBuffer.Count);
+            for (int i = 0; i < nameValueListBuffer.Count; i++)
+            {
+                var kvp = nameValueIndexListBuffer[i];
+                Write(kvp.Key);
+                Write(kvp.Value);
             }
         }
 
+        /// <summary>
+        /// Compute the total hash of all items in the nameValueList
+        /// while simultaneously filling the nameValueIndexListBuffer with the individual
+        /// hashes of the strings, mirroring the strings in the original nameValueList.
+        /// This helps us avoid hashing strings twice (once to hash the string individually
+        /// and the second time when hashing it as part of the nameValueList)
+        /// </summary>
+        private HashKey HashAllStrings(List<KeyValuePair<string, string>> nameValueList)
+        {
+            HashKey hash = new HashKey();
+
+            nameValueIndexListBuffer.Clear();
+
+            for (int i = 0; i < nameValueList.Count; i++)
+            {
+                var kvp = nameValueList[i];
+                var (keyIndex, keyHash) = HashString(kvp.Key);
+                var (valueIndex, valueHash) = HashString(kvp.Value);
+                hash = hash.Add(keyHash);
+                hash = hash.Add(valueHash);
+                nameValueIndexListBuffer.Add(new KeyValuePair<int, int>(keyIndex, valueIndex));
+            }
+
+            return hash;
+        }
+
         private void Write(BinaryLogRecordKind kind)
         {
             Write((int)kind);
@@ -718,34 +919,57 @@ private void Write(byte[] bytes)
             binaryWriter.Write(bytes);
         }
 
+        private void Write(byte b)
+        {
+            binaryWriter.Write(b);
+        }
+
         private void Write(bool boolean)
         {
             binaryWriter.Write(boolean);
         }
 
-        private void Write(string text)
+        private void WriteDeduplicatedString(string text)
         {
-            if (text != null)
-            {
-                binaryWriter.Write(text);
-            }
-            else
-            {
-                binaryWriter.Write(false);
-            }
+            var (recordId, _) = HashString(text);
+            Write(recordId);
         }
 
-        private void WriteOptionalString(string text)
+        /// <summary>
+        /// Hash the string and write a String record if not already hashed.
+        /// </summary>
+        /// <returns>Returns the string record index as well as the hash.</returns>
+        private (int index, HashKey hash) HashString(string text)
         {
             if (text == null)
             {
-                Write(false);
+                return (0, default);
             }
-            else
+            else if (text.Length == 0)
             {
-                Write(true);
-                Write(text);
+                return (1, default);
+            }
+
+            var hash = new HashKey(text);
+            if (!stringHashes.TryGetValue(hash, out var recordId))
+            {
+                recordId = stringRecordId;
+                stringHashes[hash] = stringRecordId;
+
+                WriteStringRecord(text);
+
+                stringRecordId += 1;
             }
+
+            return (recordId, hash);
+        }
+
+        private void WriteStringRecord(string text)
+        {
+            using var redirectionScope = RedirectWritesToOriginalWriter();
+
+            Write(BinaryLogRecordKind.String);
+            binaryWriter.Write(text);
         }
 
         private void Write(DateTime timestamp)
@@ -761,10 +985,10 @@ private void Write(TimeSpan timeSpan)
 
         private void Write(EvaluationLocation item)
         {
-            WriteOptionalString(item.ElementName);
-            WriteOptionalString(item.ElementDescription);
-            WriteOptionalString(item.EvaluationPassDescription);
-            WriteOptionalString(item.File);
+            WriteDeduplicatedString(item.ElementName);
+            WriteDeduplicatedString(item.ElementDescription);
+            WriteDeduplicatedString(item.EvaluationPassDescription);
+            WriteDeduplicatedString(item.File);
             Write((int)item.Kind);
             Write((int)item.EvaluationPass);
 
@@ -788,5 +1012,89 @@ private void Write(ProfiledLocation e)
             Write(e.ExclusiveTime);
             Write(e.InclusiveTime);
         }
+
+        internal readonly struct HashKey : IEquatable<HashKey>
+        {
+            private readonly ulong value;
+
+            private HashKey(ulong i)
+            {
+                value = i;
+            }
+
+            public HashKey(string text)
+            {
+                if (text == null)
+                {
+                    value = 0;
+                }
+                else
+                {
+                    value = FnvHash64.GetHashCode(text);
+                }
+            }
+
+            public static HashKey Combine(HashKey left, HashKey right)
+            {
+                return new HashKey(FnvHash64.Combine(left.value, right.value));
+            }
+
+            public HashKey Add(HashKey other) => Combine(this, other);
+
+            public bool Equals(HashKey other)
+            {
+                return value == other.value;
+            }
+
+            public override bool Equals(object obj)
+            {
+                if (obj is HashKey other)
+                {
+                    return Equals(other);
+                }
+
+                return false;
+            }
+
+            public override int GetHashCode()
+            {
+                return unchecked((int)value);
+            }
+
+            public override string ToString()
+            {
+                return value.ToString();
+            }
+        }
+
+        internal static class FnvHash64
+        {
+            public const ulong Offset = 14695981039346656037;
+            public const ulong Prime = 1099511628211;
+
+            public static ulong GetHashCode(string text)
+            {
+                ulong hash = Offset;
+
+                unchecked
+                {
+                    for (int i = 0; i < text.Length; i++)
+                    {
+                        char ch = text[i];
+                        hash = (hash ^ ch) * Prime;
+                    }
+                }
+
+                return hash;
+            }
+
+            public static ulong Combine(ulong left, ulong right)
+            {
+                unchecked
+                {
+                    return (left ^ right) * Prime;
+                }
+            }
+        }
     }
 }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 9f7c9251739..e60efa1a52d 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -1,13 +1,11 @@
-<Project Sdk="Microsoft.NET.Sdk">
+﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
 
   <PropertyGroup>
-    <!-- Node reuse requires an API new to .NET Core 2.1 not yet available
-         in .NETStandard. -->
-    <TargetFrameworks>netcoreapp2.1</TargetFrameworks>
-    <TargetFrameworks Condition="'$(OsEnvironment)'=='windows'">$(FullFrameworkTFM);netcoreapp2.1</TargetFrameworks>
+    <TargetFrameworks>net5.0</TargetFrameworks>
+    <TargetFrameworks Condition="$([MSBuild]::IsOSPlatform('windows'))">$(FullFrameworkTFM);net5.0</TargetFrameworks>
     <TargetFrameworks Condition="'$(MonoBuild)'=='true'">$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <RootNamespace>Microsoft.Build</RootNamespace>
     <AssemblyName>Microsoft.Build</AssemblyName>
@@ -30,10 +28,10 @@
 
   <ItemGroup>
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
+    <ProjectReference Include="..\StringTools\StringTools.csproj" />
 
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
-    <PackageReference Include="System.Memory" />
     <PackageReference Include="System.Text.Json" />
 
     <PackageReference Include="System.Reflection.Metadata" Condition="'$(MonoBuild)' == 'true'" />
@@ -43,6 +41,7 @@
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" />
     <Reference Include="System.Configuration" />
     <Reference Include="System.IO.Compression" />
+    <PackageReference Include="System.Memory" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
@@ -54,9 +53,6 @@
   </ItemGroup>
 
   <ItemGroup>
-    <Compile Include="..\Shared\ChangeWaves.cs">
-      <Link>SharedUtilities\ChangeWaves.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\EncodingUtilities.cs">
       <Link>SharedUtilities\EncodingUtilities.cs</Link>
     </Compile>
@@ -160,8 +156,9 @@
     <Compile Include="BackEnd\Components\Caching\ConfigCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\Caching\ResultsCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\ResourceManager\ResourceManagerService.cs" />
+    <Compile Include="BackEnd\Components\ProjectCache\*.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
-    <Compile Include="FileSystem\MSBuildFileSystemBase.cs" />
+    <Compile Include="FileSystem\*.cs" />
     <Compile Include="Utilities\NuGetFrameworkWrapper.cs" />
     <Compile Include="ObjectModelRemoting\ConstructionObjectLinks\ProjectUsingTaskParameterElementLink.cs" />
     <Compile Include="ObjectModelRemoting\ExternalProjectsProvider.cs" />
@@ -268,7 +265,6 @@
     <Compile Include="Evaluation\LazyItemEvaluator.ItemFactoryWrapper.cs" />
     <Compile Include="Evaluation\LazyItemEvaluator.RemoveOperation.cs" />
     <Compile Include="Evaluation\MetadataReference.cs" />
-    <Compile Include="FileSystem\MSBuildFileSystemAdapter.cs" />
     <Compile Include="Graph\ProjectGraphEntryPoint.cs" />
     <Compile Include="Graph\ProjectGraph.cs" />
     <Compile Include="Graph\ProjectGraphNode.cs" />
@@ -361,10 +357,6 @@
     <Compile Include="..\Shared\CollectionHelpers.cs" />
     <Compile Include="Collections\ConvertingEnumerable.cs" />
     <Compile Include="Collections\CopyOnReadEnumerable.cs" />
-    <Compile Include="..\Shared\IInternable.cs" />
-    <Compile Include="..\Shared\WeakStringCache.cs" />
-    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs" />
-    <Compile Include="..\Shared\OpportunisticIntern.cs" />
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs">
       <Link>Collections\CopyOnWriteDictionary.cs</Link>
     </Compile>
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 936f36495c1..d1a4edd4a9d 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1,17 +1,17 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <root>
-  <!-- 
-    Microsoft ResX Schema 
-    
+  <!--
+    Microsoft ResX Schema
+
     Version 2.0
-    
-    The primary goals of this format is to allow a simple XML format 
-    that is mostly human readable. The generation and parsing of the 
-    various data types are done through the TypeConverter classes 
+
+    The primary goals of this format is to allow a simple XML format
+    that is mostly human readable. The generation and parsing of the
+    various data types are done through the TypeConverter classes
     associated with the data types.
-    
+
     Example:
-    
+
     ... ado.net/XML headers & schema ...
     <resheader name="resmimetype">text/microsoft-resx</resheader>
     <resheader name="version">2.0</resheader>
@@ -26,36 +26,36 @@
         <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
         <comment>This is a comment</comment>
     </data>
-                
-    There are any number of "resheader" rows that contain simple 
+
+    There are any number of "resheader" rows that contain simple
     name/value pairs.
-    
-    Each data row contains a name, and value. The row also contains a 
-    type or mimetype. Type corresponds to a .NET class that support 
-    text/value conversion through the TypeConverter architecture. 
-    Classes that don't support this are serialized and stored with the 
+
+    Each data row contains a name, and value. The row also contains a
+    type or mimetype. Type corresponds to a .NET class that support
+    text/value conversion through the TypeConverter architecture.
+    Classes that don't support this are serialized and stored with the
     mimetype set.
-    
-    The mimetype is used for serialized objects, and tells the 
-    ResXResourceReader how to depersist the object. This is currently not 
+
+    The mimetype is used for serialized objects, and tells the
+    ResXResourceReader how to depersist the object. This is currently not
     extensible. For a given mimetype the value must be set accordingly:
-    
-    Note - application/x-microsoft.net.object.binary.base64 is the format 
-    that the ResXResourceWriter will generate, however the reader can 
+
+    Note - application/x-microsoft.net.object.binary.base64 is the format
+    that the ResXResourceWriter will generate, however the reader can
     read any of the formats listed below.
-    
+
     mimetype: application/x-microsoft.net.object.binary.base64
-    value   : The object must be serialized with 
+    value   : The object must be serialized with
             : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
             : and then encoded with base64 encoding.
-    
+
     mimetype: application/x-microsoft.net.object.soap.base64
-    value   : The object must be serialized with 
+    value   : The object must be serialized with
             : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
             : and then encoded with base64 encoding.
 
     mimetype: application/x-microsoft.net.object.bytearray.base64
-    value   : The object must be serialized into a byte array 
+    value   : The object must be serialized into a byte array
             : using a System.ComponentModel.TypeConverter
             : and then encoded with base64 encoding.
     -->
@@ -319,16 +319,12 @@
     </comment>
   </data>
   <data name="ChangeWave_InvalidFormat" xml:space="preserve">
-    <value>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</value>
-    <comment>
-       Value should be of the format: xx.yy
-    </comment>
+    <value>MSB4271: Environment variable MSBuildDisableFeaturesFromVersion is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</value>
+    <comment>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</comment>
   </data>
   <data name="ChangeWave_OutOfRotation" xml:space="preserve">
-    <value>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</value>
-    <comment>
-       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
-    </comment>
+    <value>MSB4272: Environment variable MSBuildDisableFeaturesFromVersion is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</value>
+    <comment>{StrBegin="MSB4272: "}</comment>
   </data>
   <data name="SearchPathsForMSBuildExtensionsPath" xml:space="preserve">
     <value>Search paths being used for {0} are {1}</value>
@@ -1229,7 +1225,7 @@
     <comment>{StrBegin="MSB4091: "}</comment>
   </data>
   <data name="UnexpectedTaskAttribute" xml:space="preserve">
-    <value>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</value>
+    <value>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</value>
     <comment>{StrBegin="MSB4064: "}</comment>
   </data>
   <data name="UnexpectedTaskOutputAttribute" xml:space="preserve">
@@ -1850,10 +1846,35 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>A required NuGet assembly was not found. Expected Path: {0}</value>
   </data>
   <data name="StaticGraphConstructionMetrics" xml:space="preserve">
-    <value>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</value>
+    <value>Static graph loaded in {0} seconds: {1} nodes, {2} edges</value>
   </data>
   <data name="IsolatedContextDoesNotSupportFileSystem" xml:space="preserve">
-    <value>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</value>
+    <value>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</value>
+  </data>
+  <data name="LoadingProjectCachePlugin" xml:space="preserve">
+    <value>"Loading the following project cache plugin:
+    {0}"</value>
+  </data>
+  <data name="SolutionPathPropertyMustBeSetOnVSSubmissions" xml:space="preserve">
+    <value>"MSB4264: Invalid $(SolutionPath) property: {0}"</value>
+  </data>
+  <data name="OnlyOneCachePluginMustBeSpecified" xml:space="preserve">
+    <value>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</value>
+  </data>
+  <data name="ProjectCacheInitializationFailed" xml:space="preserve">
+    <value>MSB4266: Failed to initialize the project cache.</value>
+  </data>
+  <data name="ProjectCacheQueryFailed" xml:space="preserve">
+    <value>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</value>
+  </data>
+  <data name="ProjectCacheShutdownFailed" xml:space="preserve">
+    <value>MSB4268: The project cache failed to shut down properly.</value>
+  </data>
+  <data name="NotAllNodesDefineACacheItem" xml:space="preserve">
+    <value>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</value>
+  </data>
+  <data name="NoProjectCachePluginFoundInAssembly" xml:space="preserve">
+    <value>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</value>
   </data>
   <data name="ResourceManagerReleasedCores" xml:space="preserve">
     <value>Task released {0} cores and now holds {1}.</value>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index eeaf84c6d97..083cb8733c7 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -63,18 +63,14 @@
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
-        <target state="translated">Proměnná prostředí MSBUILDDISABLEFEATURESFROMVERSION je nastavená na neplatný formát. Povolují se všechny verze vlny změn. Zadaná hodnota: {0}</target>
-        <note>
-       Value should be of the format: xx.yy
-    </note>
+        <source>MSB4271: Environment variable MSBuildDisableFeaturesFromVersion is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
+        <target state="translated">MSB4271: Proměnná prostředí MSBuildDisableFeaturesFromVersion je nastavená na neplatný formát. Povolují se všechny verze vlny změn. Zadaná hodnota: {0}. Aktuální vlny změn: {1}</target>
+        <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
-        <target state="translated">Proměnná prostředí MSBUILDDISABLEFEATURESFROMVERSION je nastavená na verzi, která je mimo rotaci. Nastavuje se výchozí verze vlny změn: {0}. Zadaná hodnota: {1}</target>
-        <note>
-       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
-    </note>
+        <source>MSB4272: Environment variable MSBuildDisableFeaturesFromVersion is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
+        <target state="translated">MSB4272: Proměnná prostředí MSBuildDisableFeaturesFromVersion je nastavená na verzi, která je mimo rotaci. Nastavuje se výchozí verze vlny změn: {0}. Zadaná hodnota: {1}. Aktuální vlny změn: {2}</target>
+        <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}".</source>
@@ -92,7 +88,7 @@
       </trans-unit>
       <trans-unit id="CircularDependencyInTargetGraph">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</source>
-        <target state="new">MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</target>
+        <target state="translated">MSB4006: V cílovém grafu závislostí, který zahrnuje cíl {0}, je cyklická závislost. Vzhledem k tomu, že {1} má závislost {2} na {3}, cyklická závislost je {4}.</target>
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
@@ -132,8 +128,15 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">Objekty EvaluationContext vytvořené pomocí SharingPolicy.Isolated nepodporují předávání souborového systému MSBuildFileSystemBase.</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">Objekty EvaluationContext vytvořené pomocí SharingPolicy.Isolated nepodporují předávání souborového systému MSBuildFileSystemBase.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="translated">Načítá se následující modul plug-in mezipaměti projektu:
+    {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -158,6 +161,16 @@
         <target state="translated">Operaci nelze dokončit, protože funkce BeginBuild ještě nebyla zavolána.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="translated">MSB4270: V sestavení {0} se nenašly žádné moduly plug-in mezipaměti projektu. Modul plug-in se očekával.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="translated">MSB4269: Pokud jakýkoli uzel statického grafu definuje mezipaměť projektu, musí všechny uzly definovat stejnou mezipaměť projektu. Následující projekty neobsahují deklaraci položky {0}: {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Požadované sestavení NuGet se nenašlo. Očekávaná cesta: {0}</target>
@@ -196,6 +209,26 @@
         <target state="translated">Metoda {0} se nedá zavolat s kolekcí, která obsahuje prázdné cílové názvy nebo názvy null.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="translated">MSB4265: Musí se zadat jeden modul plug-in mezipaměti projektu, ale našlo se jich více: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="translated">MSB4266: Nepovedlo se inicializovat mezipaměť projektu.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="translated">MSB4267: Při dotazování na následující projekt selhala jeho mezipaměť: {0}. Na mezipaměť se dotazy posílají paralelně pro několik projektů, takže tento konkrétní projekt nemusí být příčinou.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="translated">MSB4268: Mezipaměť projektu se nepovedlo správně vypnout.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph nepodporuje položky ProjectReference s nastavenými metadaty ToolsVersion. V souboru {1} byla nalezena položka ProjectReference {0} s metadaty ToolsVersion.</target>
@@ -231,6 +264,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="translated">MSB4264: Neplatná vlastnost $(SolutionPath): {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: Bylo zjištěno více vstupních bodů s řešeními: {0}. Pokud se z řešení načte statický graf, musí být toto řešení jediným vstupním bodem.</target>
@@ -239,8 +277,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">Statický graf se načetl za {0} s: počet uzlů: {1}, počet hraničních uzlů: {2}</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">Statický graf se načetl za {0} s: počet uzlů: {1}, počet hraničních uzlů: {2}</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1647,8 +1685,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: Parametr {0} není podporován úlohou {1}. Zkontrolujte, zda parametr úlohy existuje a zda se jedná o nastavitelnou vlastnost veřejné instance.</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index d8847d8365e..ed15a96496e 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -63,18 +63,14 @@
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
-        <target state="translated">Die Umgebungsvariable MSBUILDDISABLEFEATURESFROMVERSION ist auf ein ungültiges Format festgelegt. Alle Änderungszyklusversionen werden aktiviert. Eingegebener Wert: {0}.</target>
-        <note>
-       Value should be of the format: xx.yy
-    </note>
+        <source>MSB4271: Environment variable MSBuildDisableFeaturesFromVersion is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
+        <target state="translated">MSB4271: Die Umgebungsvariable "MSBuildDisableFeaturesFromVersion" ist auf ein ungültiges Format festgelegt. Alle Änderungszyklusversionen werden aktiviert. Eingegebener Wert: {0}. Aktuelle Änderungszyklen: {1}.</target>
+        <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
-        <target state="translated">Die Umgebungsvariable MSBUILDDISABLEFEATURESFROMVERSION ist auf eine nicht rotierende Version festgelegt und wird standardmäßig auf die Änderungszyklusversion gesetzt: {0}. Eingegebener Wert: {1}.</target>
-        <note>
-       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
-    </note>
+        <source>MSB4272: Environment variable MSBuildDisableFeaturesFromVersion is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
+        <target state="translated">MSB4272: Die Umgebungsvariable "MSBuildDisableFeaturesFromVersion" ist auf eine nicht rotierende Version festgelegt und wird auf die Standard-Änderungszyklusversion gesetzt: {0}. Eingegebener Wert: {1}. Aktuelle Änderungszyklen: {2}.</target>
+        <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}".</source>
@@ -92,7 +88,7 @@
       </trans-unit>
       <trans-unit id="CircularDependencyInTargetGraph">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</source>
-        <target state="new">MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</target>
+        <target state="translated">MSB4006: Es besteht eine Ringabhängigkeit im Zielabhängigkeitsdiagramm mit dem Ziel "{0}". Da "{1}" die Abhängigkeit "{2}" von "{3}" aufweist, ist die Ringabhängigkeit "{4}".</target>
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
@@ -132,8 +128,15 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">"Die Übergabe eines MSBuildFileSystemBase-Dateisystems wird von EvaluationContext-Objekten, die mit SharingPolicy.Isolated erstellt wurden, nicht unterstützt."</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">"Die Übergabe eines MSBuildFileSystemBase-Dateisystems wird von EvaluationContext-Objekten, die mit SharingPolicy.Isolated erstellt wurden, nicht unterstützt."</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="translated">"Folgendes Projektcache-Plug-In wird geladen:
+    {0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -158,6 +161,16 @@
         <target state="translated">Der Vorgang kann nicht abgeschlossen werden, da BeginBuild noch nicht aufgerufen wurde.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="translated">MSB4270: In der Assembly "{0}" wurde ein Projektcache-Plug-In erwartet, aber keines gefunden.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="translated">MSB4269: Wenn ein statischer Graphknoten einen Projektcache definiert, müssen alle Knoten denselben Projektcache definieren. Die folgenden Projekte enthalten keine Deklaration des Elements "{0}": {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Eine erforderliche NuGet-Assembly wurde nicht gefunden. Erwarteter Pfad: {0}</target>
@@ -196,6 +209,26 @@
         <target state="translated">Die Methode "{0}" kann nicht mit einer Sammlung aufgerufen werden, die NULL oder leere Zielnamen enthält.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="translated">MSB4265: Ein einzelnes Projektcache-Plug-In muss angegeben werden, es wurden jedoch mehrere gefunden: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="translated">MSB4266: Fehler beim Initialisieren des Projektcache.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="translated">MSB4267: Fehler beim Abfragen des Projektcache für das folgende Projekt: {0}. Der Cache wird für mehrere Projekte parallel abgefragt, sodass dieses spezifische Projekt möglicherweise nicht die Ursache darstellt.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="translated">MSB4268: Der Projektcache konnte nicht ordnungsgemäß heruntergefahren werden.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph bietet keine Unterstützung für ProjectReference-Elemente mit dem ToolsVersion-Metadatensatz. In der Datei "{1}" wurde ProjectReference "{0}" mit "ToolsVersion" gefunden.</target>
@@ -231,6 +264,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="translated">"MSB4264: Ungültige $(SolutionPath)-Eigenschaft: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: Es wurden mehrere Einstiegspunkte mit Projektmappen gefunden: {0}. Wenn ein statischer Graph aus einer Projektmappe geladen wird, muss diese Projektmappe der einzige Einstiegspunkt sein.</target>
@@ -239,8 +277,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">"Statisches Diagramm in {0} Sekunden geladen: {1} Knoten, {2} Edges"</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">"Statisches Diagramm in {0} Sekunden geladen: {1} Knoten, {2} Edges"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1647,8 +1685,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: Der "{0}"-Parameter wird von der "{1}"-Aufgabe nicht unterstützt. Vergewissern Sie sich, dass der Parameter in der Aufgabe vorhanden ist und es sich um eine festlegbare öffentliche Instanzeigenschaft handelt.</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.en.xlf b/src/Build/Resources/xlf/Strings.en.xlf
index 28b71b13643..6304414cb46 100644
--- a/src/Build/Resources/xlf/Strings.en.xlf
+++ b/src/Build/Resources/xlf/Strings.en.xlf
@@ -63,18 +63,14 @@
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
-        <target state="new">Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</target>
-        <note>
-       Value should be of the format: xx.yy
-    </note>
+        <source>MSB4271: Environment variable MSBuildDisableFeaturesFromVersion is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
+        <target state="new">MSB4271: Environment variable MSBuildDisableFeaturesFromVersion is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
-        <target state="new">Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</target>
-        <note>
-       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
-    </note>
+        <source>MSB4272: Environment variable MSBuildDisableFeaturesFromVersion is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
+        <target state="new">MSB4272: Environment variable MSBuildDisableFeaturesFromVersion is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}".</source>
@@ -132,8 +128,15 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="new">"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="new">EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="new">"Loading the following project cache plugin:
+    {0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -158,6 +161,16 @@
         <target state="new">The operation cannot be completed because BeginBuild has not yet been called.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
@@ -196,6 +209,26 @@
         <target state="new">Method {0} cannot be called with a collection containing null or empty target names.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="new">MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</target>
@@ -231,6 +264,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="new">MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</target>
@@ -239,8 +277,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="new">"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="new">Static graph loaded in {0} seconds: {1} nodes, {2} edges</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1692,8 +1730,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 6be1295361a..f6b77218a8f 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -63,18 +63,14 @@
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
-        <target state="translated">La variable de entorno MSBUILDDISABLEFEATURESFROMVERSION está establecida en un formato no válido. Habilitando todas las versiones de lanzamiento de cambios. Valor especificado: {0}.</target>
-        <note>
-       Value should be of the format: xx.yy
-    </note>
+        <source>MSB4271: Environment variable MSBuildDisableFeaturesFromVersion is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
+        <target state="translated">MSB4271: La variable de entorno MSBuildDisableFeaturesFromVersion está establecida en un formato no válido. Habilitando todas las versiones de oleadas de cambios. Valor especificado: {0}. Oleadas de cambios actuales: {1}.</target>
+        <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
-        <target state="translated">La variable de entorno MSBUILDDISABLEFEATURESFROMVERSION está establecida en una versión no incluida en la rotación. Se va a cambiar a la versión de lanzamiento de cambios de forma predeterminada: {0}. Valor especificado: {1}.</target>
-        <note>
-       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
-    </note>
+        <source>MSB4272: Environment variable MSBuildDisableFeaturesFromVersion is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
+        <target state="translated">MSB4272: La variable de entorno MSBuildDisableFeaturesFromVersion está establecida en una versión no incluida en la rotación. Se va a cambiar a la versión de oleada de cambios de forma predeterminada: {0}. Valor especificado: {1}. Oleadas de cambios actuales: {2}.</target>
+        <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}".</source>
@@ -92,7 +88,7 @@
       </trans-unit>
       <trans-unit id="CircularDependencyInTargetGraph">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</source>
-        <target state="new">MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</target>
+        <target state="translated">MSB4006: Existe una dependencia circular en el gráfico de dependencias de destino que implica el destino "{0}". Dado que "{1}" tiene una dependencia "{2}" en "{3}", la opción circular es "{4}".</target>
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
@@ -132,8 +128,15 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">"Los objetos EvaluationContext creados con SharingPolicy.Isolated no admiten que se les pase un sistema de archivos MSBuildFileSystemBase".</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">"Los objetos EvaluationContext creados con SharingPolicy.Isolated no admiten que se les pase un sistema de archivos MSBuildFileSystemBase".</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="translated">"Cargando el complemento de caché de proyectos siguiente:
+    {0} "</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -158,6 +161,16 @@
         <target state="translated">La operación no se puede completar porque todavía no se llamó a BeginBuild.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="translated">MSB4270: No se encontró ningún complemento de caché de proyectos en el ensamblado "{0}". Se esperaba uno.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="translated">MSB4269: Cuando un nodo de gráfico estático define una memoria caché de proyectos, todos los nodos deben definir la misma caché de proyectos. Los proyectos siguientes no contienen ninguna declaración de elemento "{0}": {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">No se encontró un ensamblado de NuGet necesario. Ruta de acceso esperada: {0}</target>
@@ -196,6 +209,26 @@
         <target state="translated">No se puede llamar al método {0} con una colección que contiene nombres de destino nulos o vacíos.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="translated">MSB4265: Debe especificarse un solo complemento de caché de proyectos, pero se encontraron varios: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="translated">MSB4266: No se pudo inicializar la caché de proyectos.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="translated">MSB4267: Error de la memoria caché de proyectos al consultar el proyecto siguiente: {0}. La memoria caché se consulta en paralelo para varios proyectos, por lo que puede que este proyecto específico no sea la causa.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="translated">MSB4268: La memoria caché de proyectos no se cerró correctamente.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph no admite elementos de ProjectReference con los metadatos de ToolsVersion establecidos. Se encontró ProjectReference "{0}" con ToolsVersion en el archivo "{1}"</target>
@@ -231,6 +264,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="translated">"MSB4264: Propiedad $(SolutionPath) no válida: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: Se detectaron varios puntos de entrada con soluciones: {0}. Si el gráfico estático se carga a partir de una solución, esa solución debe ser el único punto de entrada.</target>
@@ -239,8 +277,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">"Grafo estático cargado en {0} segundos: {1} nodos, {2} bordes"</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">"Grafo estático cargado en {0} segundos: {1} nodos, {2} bordes"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1647,8 +1685,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: El parámetro "{0}" no es compatible con la tarea "{1}". Compruebe que el parámetro existe en la tarea y que es una propiedad de instancia Public que se puede establecer.</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 4c6a9ec6afd..2a624815a72 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -63,18 +63,14 @@
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
-        <target state="translated">La variable d'environnement MSBUILDDISABLEFEATURESFROMVERSION a un format non valide. Activation de toutes les versions des vagues de changements. Valeur entrée : {0}.</target>
-        <note>
-       Value should be of the format: xx.yy
-    </note>
+        <source>MSB4271: Environment variable MSBuildDisableFeaturesFromVersion is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
+        <target state="translated">MSB4271: la variable d'environnement MSBuildDisableFeaturesFromVersion a un format non valide. Activation de toutes les versions des vagues de changements. Valeur entrée : {0}. Vagues de changements actuelles : {1}.</target>
+        <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
-        <target state="translated">La variable d'environnement MSBUILDDISABLEFEATURESFROMVERSION a une valeur correspondant à une version hors rotation. Utilisation par défaut de la vague de changements version {0}. Valeur entrée : {1}.</target>
-        <note>
-       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
-    </note>
+        <source>MSB4272: Environment variable MSBuildDisableFeaturesFromVersion is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
+        <target state="translated">MSB4272: la variable d'environnement MSBuildDisableFeaturesFromVersion a une valeur correspondant à une version hors rotation. Utilisation par défaut de la vague de changements version {0}. Valeur entrée : {1}. Vagues de changements actuelles : {2}.</target>
+        <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}".</source>
@@ -92,7 +88,7 @@
       </trans-unit>
       <trans-unit id="CircularDependencyInTargetGraph">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</source>
-        <target state="new">MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</target>
+        <target state="translated">MSB4006: Il existe une dépendance circulaire dans le graphe des dépendances cibles impliquant la cible "{0}". Dans la mesure où "{1}" a une dépendance "{2}" par rapport à "{3}", la dépendance circulaire est "{4}".</target>
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
@@ -132,8 +128,15 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">"Les objets EvaluationContext créés avec SharingPolicy.Isolated ne prennent pas en charge le passage d'un système de fichiers MSBuildFileSystemBase."</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">"Les objets EvaluationContext créés avec SharingPolicy.Isolated ne prennent pas en charge le passage d'un système de fichiers MSBuildFileSystemBase."</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="translated">"Chargement du plug-in de cache de projet suivant :
+    {0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -158,6 +161,16 @@
         <target state="translated">Impossible d'effectuer l'opération car la méthode BeginBuild n'a pas encore été appelée.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="translated">MSB4270: plug-ins de cache de projet introuvables dans l'assembly "{0}". Un plug-in est attendu.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="translated">MSB4269: quand un nœud de graphe statique définit un cache de projet, tous les nœuds doivent définir le même cache de projet. Le ou les projets suivants ne contiennent pas de déclaration d'élément "{0}" : {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Un assembly NuGet obligatoire est introuvable. Chemin attendu : {0}</target>
@@ -196,6 +209,26 @@
         <target state="translated">Impossible d'appeler la méthode {0} avec une collection contenant des noms de cibles qui ont une valeur null ou qui sont vides.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="translated">MSB4265: un seul plug-in de cache de projet doit être spécifié, mais plusieurs plug-ins ont été trouvés : {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="translated">MSB4266: échec de l'initialisation du cache de projet.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="translated">MSB4267: échec du cache de projet au moment où il a été interrogé pour le projet suivant : {0}. Dans la mesure où le cache est interrogé en parallèle pour plusieurs projets, ce projet spécifique n'est peut-être pas à l'origine du problème.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="translated">MSB4268: le cache de projet ne s'est pas arrêté correctement.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph ne prend pas en charge les éléments ProjectReference avec l'ensemble de métadonnées ToolsVersion. ProjectReference "{0}" trouvé avec ToolsVersion dans le fichier "{1}"</target>
@@ -231,6 +264,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="translated">"MSB4264: propriété $(SolutionPath) non valide : {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: détection de plusieurs points d'entrée avec des solutions : {0}. Si un graphe statique est chargé à partir d'une solution, cette solution doit être le seul point d'entrée.</target>
@@ -239,8 +277,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">"Graphe statique chargé en {0} secondes : {1} nœuds, {2} arêtes"</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">"Graphe statique chargé en {0} secondes : {1} nœuds, {2} arêtes"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1647,8 +1685,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: Le paramètre "{0}" n'est pas pris en charge par la tâche "{1}". Vérifiez que le paramètre existe pour la tâche et qu'il représente une propriété d'instance publique définissable.</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 741c04835e7..a4b32ad2d12 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -63,18 +63,14 @@
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
-        <target state="translated">La variabile di ambiente MSBUILDDISABLEFEATURESFROMVERSION è impostata su un formato non valido. Verranno abilitate tutte le versioni con flussi di modifiche. Valore immesso: {0}.</target>
-        <note>
-       Value should be of the format: xx.yy
-    </note>
+        <source>MSB4271: Environment variable MSBuildDisableFeaturesFromVersion is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
+        <target state="translated">MSB4271: la variabile di ambiente MSBuildDisableFeaturesFromVersion è impostata su un formato non valido. Verranno abilitate tutte le versioni con flussi di modifiche. Valore immesso: {0}. Flussi di modifiche correnti: {1}.</target>
+        <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
-        <target state="translated">La variabile di ambiente MSBUILDDISABLEFEATURESFROMVERSION è impostata su una versione esclusa dalla rotazione. Per impostazione predefinita, verrà usata la versione con flussi di modifiche: {0}. Valore immesso: {1}.</target>
-        <note>
-       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
-    </note>
+        <source>MSB4272: Environment variable MSBuildDisableFeaturesFromVersion is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
+        <target state="translated">MSB4272: la variabile di ambiente MSBuildDisableFeaturesFromVersion è impostata su una versione esclusa dalla rotazione. Per impostazione predefinita, verrà usata la versione con flussi di modifiche: {0}. Valore immesso: {1}. Flussi di modifiche correnti: {2}.</target>
+        <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}".</source>
@@ -92,7 +88,7 @@
       </trans-unit>
       <trans-unit id="CircularDependencyInTargetGraph">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</source>
-        <target state="new">MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</target>
+        <target state="translated">MSB4006: è presente una dipendenza circolare nel grafico di dipendenze che usa la destinazione "{0}". Dal momento che "{1}" ha la dipendenza di "{2}" da "{3}", la dipendenza circolare è "{4}".</target>
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
@@ -132,8 +128,15 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">"Agli oggetti EvaluationContext creati con SharingPolicy.Isolated non è possibile passare un file system MSBuildFileSystemBase."</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">"Agli oggetti EvaluationContext creati con SharingPolicy.Isolated non è possibile passare un file system MSBuildFileSystemBase."</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="translated">"Caricamento del plug-in seguente della cache del progetto:
+    {0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -158,6 +161,16 @@
         <target state="translated">Non è possibile completare l'operazione perché BeginBuild non è stato ancora chiamato.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="translated">MSB4270: non sono stati trovati plug-in della cache del progetto nell'assembly "{0}". Ne è previsto uno.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="translated">MSB4269: quando un nodo di grafo statico definisce una cache del progetto, tutti i nodi devono definire la stessa cache del progetto. Il progetto o i progetti seguenti non contengono una dichiarazione di elemento "{0}": {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Un assembly NuGet obbligatorio non è stato trovato. Percorso previsto: {0}</target>
@@ -196,6 +209,26 @@
         <target state="translated">Non è possibile chiamare il metodo {0} con una raccolta contenente nomi di destinazione Null o vuoti.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="translated">MSB4265: è necessario specificare un singolo plug-in della cache del progetto, ma ne sono trovati più di uno: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="translated">MSB4266: non è stato possibile inizializzare la cache del progetto.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="translated">MSB4267: si è verificato un errore nella cache del progetto durante l'esecuzione della query relativa al progetto seguente: {0}. La query sulla cache viene eseguita in parallelo per più progetti, di conseguenza l'errore potrebbe non dipendere dal progetto specifico.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="translated">MSB4268: non è stato possibile arrestare correttamente la cache del progetto.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph non supporta elementi ProjectReference con metadati ToolsVersion impostati. L'elemento ProjectReference "{0}" con ToolsVersion è stato trovato nel file "{1}"</target>
@@ -231,6 +264,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="translated">"MSB4264: la proprietà $(SolutionPath) non è valida: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: Sono stati rilevati più punti di ingresso con le soluzioni: {0}. Se il grafo statico viene caricato da una soluzione, tale soluzione deve essere l'unico punto di ingresso.</target>
@@ -239,8 +277,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">"Il grafo statico è stato caricato in {0} secondi: {1} nodi, {2} vertici"</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">"Il grafo statico è stato caricato in {0} secondi: {1} nodi, {2} vertici"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1647,8 +1685,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: il parametro "{0}" non è supportato dall'attività "{1}". Verificare che il parametro sia presente per l'attività e che si tratti di un'istanza pubblica e impostabile della proprietà.</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 7a2b150fdba..3f8df7ddd05 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -63,18 +63,14 @@
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
-        <target state="translated">環境変数 MSBUILDDISABLEFEATURESFROMVERSION が無効な形式に設定されています。すべての変更ウェーブ バージョンを有効にしています。入力された値: {0}。</target>
-        <note>
-       Value should be of the format: xx.yy
-    </note>
+        <source>MSB4271: Environment variable MSBuildDisableFeaturesFromVersion is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
+        <target state="translated">MSB4271: 環境変数 MSBuildDisableFeaturesFromVersion が無効な形式に設定されています。すべての変更ウェーブ バージョンを有効にしています。入力された値: {0}。現在の変更ウェーブ: {1}。</target>
+        <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
-        <target state="translated">環境変数 MSBUILDDISABLEFEATURESFROMVERSION が、ローテーションから外れているバージョンに設定されています。Change Wave バージョンを既定値にしています: {0}。入力された値: {1}。</target>
-        <note>
-       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
-    </note>
+        <source>MSB4272: Environment variable MSBuildDisableFeaturesFromVersion is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
+        <target state="translated">MSB4272: 環境変数 MSBuildDisableFeaturesFromVersion が、ローテーションから外れているバージョンに設定されています。変更ウェーブ バージョンを既定値にしています: {0}。入力された値: {1}。現在の変更ウェーブ: {2}。</target>
+        <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}".</source>
@@ -92,7 +88,7 @@
       </trans-unit>
       <trans-unit id="CircularDependencyInTargetGraph">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</source>
-        <target state="new">MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</target>
+        <target state="translated">MSB4006: ターゲット "{0}" を含むターゲット依存関係グラフに循環依存の関係があります。"{1}" には "{3}" に対する "{2}" の依存関係があるため、循環は "{4}" です。</target>
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
@@ -132,8 +128,15 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">"SharingPolicy.Isolated を指定して作成された EvaluationContext オブジェクトに MSBuildFileSystemBase ファイル システムを渡すことはサポートされていません。"</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">"SharingPolicy.Isolated を指定して作成された EvaluationContext オブジェクトに MSBuildFileSystemBase ファイル システムを渡すことはサポートされていません。"</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="translated">"次のプロジェクト キャッシュ プラグインを読み込んでいます。
+    {0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -158,6 +161,16 @@
         <target state="translated">BeginBuild がまだ呼び出されていないため、操作を完了できません。</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="translated">MSB4270: プロジェクト キャッシュのプラグインがアセンブリ "{0}" に見つかりませんでした。プラグインが 1 つ必要です。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="translated">MSB4269: 静的グラフ ノードでプロジェクト キャッシュが定義されている場合、すべてのノードで同じプロジェクト キャッシュを定義する必要があります。プロジェクト {1} には、"{0}" 項目宣言が含まれていません</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">必要な NuGet アセンブリが見つかりませんでした。想定されるパス: {0}</target>
@@ -196,6 +209,26 @@
         <target state="translated">Null または空のターゲット名を含むコレクションを指定してメソッド {0} を呼び出すことはできません。</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="translated">MSB4265: 単一のプロジェクト キャッシュ プラグインを指定する必要がありますが、複数指定されています。{0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="translated">MSB4266: プロジェクト キャッシュを初期化できませんでした。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="translated">MSB4267: プロジェクト キャッシュは、プロジェクト {0} に対してクエリを実行しているときに失敗しました。このキャッシュでは複数のプロジェクトについて並列でクエリが実行されるため、この特定のプロジェクトが原因ではない可能性があります。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="translated">MSB4268: プロジェクト キャッシュは正常にシャットダウンできませんでした。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph では、ToolsVersion メタデータが設定された ProjectReference 項目はサポートしていません。ToolsVersion が含まれる ProjectReference "{0}" がファイル "{1}" で見つかりました</target>
@@ -231,6 +264,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="translated">"MSB4264: 無効な $(SolutionPath) プロパティ: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: ソリューションが検出されたエントリ ポイントが複数あります: {0}。静的グラフがソリューションから読み込まれる場合、そのソリューションが唯一のエントリ ポイントである必要があります。</target>
@@ -239,8 +277,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">"{0} 秒で読み込まれた静的グラフ: {1} ノード、{2} エッジ"</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">"{0} 秒で読み込まれた静的グラフ: {1} ノード、{2} エッジ"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1647,8 +1685,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: "{0}" パラメーターは "{1}" タスクではサポートされていません。タスク上にパラメーターが存在し、設定可能なパブリック インスタンス プロパティであることを確認してください。</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 0dc75066e80..3ce470cd544 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -63,18 +63,14 @@
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
-        <target state="translated">환경 변수 MSBUILDDISABLEFEATURESFROMVERSION이 잘못된 형식으로 설정되어 있습니다. 변경 웨이브(위험한 기능 세트) 버전을 모두 사용하도록 설정합니다. 입력한 값: {0}.</target>
-        <note>
-       Value should be of the format: xx.yy
-    </note>
+        <source>MSB4271: Environment variable MSBuildDisableFeaturesFromVersion is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
+        <target state="translated">MSB4271: 환경 변수 MSBuildDisableFeaturesFromVersion이 잘못된 형식으로 설정되어 있습니다. 변경 웨이브 버전을 모두 사용하도록 설정합니다. 입력한 값: {0}. 현재 변경 웨이브: {1}.</target>
+        <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
-        <target state="translated">환경 변수 MSBUILDDISABLEFEATURESFROMVERSION이 순환되지 않는 버전으로 설정되어 있습니다. 변경 웨이브 버전으로 기본값 설정: {0}. 입력한 값: {1}.</target>
-        <note>
-       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
-    </note>
+        <source>MSB4272: Environment variable MSBuildDisableFeaturesFromVersion is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
+        <target state="translated">MSB4272: 환경 변수 MSBuildDisableFeaturesFromVersion이 순환되지 않는 버전으로 설정되어 있습니다. 기본값인 변경 웨이브 버전 {0}(으)로 설정합니다. 입력한 값: {1}. 현재 변경 웨이브: {2}.</target>
+        <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}".</source>
@@ -92,7 +88,7 @@
       </trans-unit>
       <trans-unit id="CircularDependencyInTargetGraph">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</source>
-        <target state="new">MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</target>
+        <target state="translated">MSB4006: 대상 종속성 그래프에 "{0}" 대상과 관련된 순환 종속성이 있습니다. "{1}"에 "{3}"에 대한 "{2}" 종속이 있으므로 순환은 "{4}"입니다.</target>
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
@@ -132,8 +128,15 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">"SharingPolicy.Isolated로 만든 EvaluationContext 개체는 MSBuildFileSystemBase 파일 시스템 전달을 지원하지 않습니다."</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">"SharingPolicy.Isolated로 만든 EvaluationContext 개체는 MSBuildFileSystemBase 파일 시스템 전달을 지원하지 않습니다."</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="translated">"다음 프로젝트 캐시 플러그 인을 로드하는 중:
+    {0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -158,6 +161,16 @@
         <target state="translated">BeginBuild가 아직 호출되지 않았으므로 작업을 완료할 수 없습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="translated">MSB4270: "{0}" 어셈블리에서 프로젝트 캐시 플러그 인을 찾을 수 없습니다. 1개가 필요합니다.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="translated">MSB4269: 정적 그래프 노드에서 프로젝트 캐시를 정의할 때 모든 노드는 같은 프로젝트 캐시를 정의해야 합니다. {1} 프로젝트에는 "{0}" 항목 선언이 포함되어 있지 않습니다.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">필요한 NuGet 어셈블리를 찾을 수 없습니다. 예상 경로: {0}</target>
@@ -196,6 +209,26 @@
         <target state="translated">null 또는 빈 대상 이름을 포함하는 컬렉션을 사용하여 {0} 메서드를 호출할 수 없습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="translated">MSB4265: 단일 프로젝트 캐시 플러그 인이 지정되어야 하지만, {0}에서 여러 개를 찾았습니다.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="translated">MSB4266: 프로젝트 캐시를 초기화하지 못했습니다.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="translated">MSB4267: {0} 프로젝트에 대해 쿼리되는 동안 프로젝트 캐시가 실패했습니다. 캐시는 여러 프로젝트에 대해 병렬로 쿼리되므로 이 특정 프로젝트가 원인이 아닐 수 있습니다.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="translated">MSB4268: 프로젝트 캐시가 제대로 종료되지 않았습니다.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph는 ToolsVersion 메타데이터가 설정된 ProjectReference 항목을 지원하지 않습니다. "{1}" 파일에 ToolsVersion이 포함된 ProjectReference "{0}"이(가) 있습니다.</target>
@@ -231,6 +264,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="translated">"MSB4264: 잘못된 $(SolutionPath) 속성: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: 솔루션에서 여러 진입점이 검색되었습니다. {0}. 솔루션에서 정적 그래프가 로드되는 경우 해당 솔루션이 유일한 진입점이어야 합니다.</target>
@@ -239,8 +277,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">"정적 그래프가 {0}초 안에 로드됨: {1}개 노드, {2}개 에지"</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">"정적 그래프가 {0}초 안에 로드됨: {1}개 노드, {2}개 에지"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1647,8 +1685,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: "{1}" 작업에서 "{0}" 매개 변수를 지원하지 않습니다. 해당 매개 변수가 작업에 있는지 그리고 설정 가능한 public 인스턴스 속성인지 확인하세요.</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
@@ -2283,7 +2321,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</source>
       </trans-unit>
       <trans-unit id="ProjectImportSkippedFalseCondition">
         <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to false condition; ({4}) was evaluated as ({5}).</source>
-        <target state="translated">false 조건으로 인해 ({2},{3})의 "{1}”이(가) "{0}" 프로젝트를 가져오지 않았습니다. ({4})은(는) ({5})(으)로 확인되었습니다.</target>
+        <target state="translated">false 조건으로 인해 ({2},{3})의 "{1}"이(가) "{0}" 프로젝트를 가져오지 않았습니다. ({4})은(는) ({5})(으)로 확인되었습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectImportSkippedNoMatches">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 183f0fa7021..f6456f6bbdb 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -63,18 +63,14 @@
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
-        <target state="translated">Zmienna środowiskowa MSBUILDDISABLEFEATURESFROMVERSION ma nieprawidłowy format. Zostaną włączone wszystkie wersje fali zmian. Wprowadzona wartość: {0}.</target>
-        <note>
-       Value should be of the format: xx.yy
-    </note>
+        <source>MSB4271: Environment variable MSBuildDisableFeaturesFromVersion is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
+        <target state="translated">MSB4271: Zmienna środowiskowa MSBuildDisableFeaturesFromVersion ma nieprawidłowy format. Zostaną włączone wszystkie wersje fali zmian. Wprowadzona wartość: {0}. Bieżące fale zmian: {1}.</target>
+        <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
-        <target state="translated">Zmienna środowiskowa MSBUILDDISABLEFEATURESFROMVERSION ma ustawioną wersję, która została wycofana z użycia. Domyślnie zostanie użyta fala zmian w wersji: {0}. Wprowadzona wartość: {1}.</target>
-        <note>
-       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
-    </note>
+        <source>MSB4272: Environment variable MSBuildDisableFeaturesFromVersion is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
+        <target state="translated">MSB4272: Zmienna środowiskowa MSBuildDisableFeaturesFromVersion ma ustawioną wersję, która została wycofana z użycia. Domyślnie zostanie użyta fala zmian w wersji: {0}. Wprowadzona wartość: {1}. Bieżące fale zmian: {2}.</target>
+        <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}".</source>
@@ -92,7 +88,7 @@
       </trans-unit>
       <trans-unit id="CircularDependencyInTargetGraph">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</source>
-        <target state="new">MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</target>
+        <target state="translated">MSB4006: Istnieje zależność cykliczna w docelowym grafie zależności obejmująca element docelowy „{0}”. Ponieważ element „{1}” ma zależność „{2}” od elementu „{3}”, zależność cykliczna to „{4}”.</target>
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
@@ -132,8 +128,15 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">„Obiekty EvaluationContext utworzone za pomocą elementu SharingPolicy.Isolated nie obsługują przekazywania za pomocą systemu plików MSBuildFileSystemBase.”</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">„Obiekty EvaluationContext utworzone za pomocą elementu SharingPolicy.Isolated nie obsługują przekazywania za pomocą systemu plików MSBuildFileSystemBase.”</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="translated">„Ładowanie następującej wtyczki pamięci podręcznej projektu:
+    {0}”</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -158,6 +161,16 @@
         <target state="translated">Nie można zakończyć operacji, ponieważ metoda BeginBuild nie została jeszcze wywołana.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="translated">MSB4270: nie znaleziono wtyczek pamięci podręcznej projektu w zestawie „{0}”. Oczekiwano jednej.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="translated">MSB4269: gdy dowolny węzeł wykresu statycznego definiuje pamięć podręczną projektu, wszystkie węzły muszą definiować tę samą pamięć podręczną projektu. Następujące projekty nie zawierają deklaracji elementu „{0}”: {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Nie znaleziono wymaganego zestawu NuGet. Oczekiwano ścieżki {0}.</target>
@@ -196,6 +209,26 @@
         <target state="translated">Metody {0} nie można wywołać przy użyciu kolekcji zawierającej nazwy docelowe o wartości null lub puste.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="translated">MSB4265: należy określić jedną wtyczkę pamięci podręcznej projektu, ale znaleziono ich wiele: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="translated">MSB4266: nie można zainicjować pamięci podręcznej projektu.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="translated">MSB4267: w pamięci podręcznej projektu wystąpił błąd podczas wykonywania zapytania dotyczącego następującego projektu: {0}. Względem pamięci podręcznej równolegle są wykonywane zapytania o wiele projektów, dlatego ten konkretny projekt może nie być przyczyną.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="translated">MSB4268: nie można poprawnie zamknąć pamięci podręcznej projektu.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: Element ProjectGraph nie obsługuje elementów ProjectReference z ustawionymi metadanymi atrybutu ToolsVersion. W pliku „{1}” odnaleziono element ProjectReference „{0}” z atrybutem ToolsVersion</target>
@@ -231,6 +264,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="translated">„MSB4264: nieprawidłowa właściwość $(SolutionPath): {0}”</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: Wykryto wiele punktów wejścia z rozwiązaniami: {0}. Jeśli graf statyczny jest ładowany z rozwiązania, musi ono być jedynym punktem wejścia.</target>
@@ -239,8 +277,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">„Wykres statyczny załadowany w {0} s, węzły: {1}, krawędzie: {2}”</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">„Wykres statyczny załadowany w {0} s, węzły: {1}, krawędzie: {2}”</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1647,8 +1685,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: Parametr „{0}” nie jest obsługiwany przez zadanie „{1}”. Sprawdź, czy parametr istnieje w zadaniu i czy jest właściwością wystąpienia publicznego, którą można ustawić.</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
@@ -2067,7 +2105,7 @@ Wykorzystanie:          Średnie wykorzystanie {0}: {1:###.0}</target>
       </trans-unit>
       <trans-unit id="OM_ProjectXmlCannotBeUnloadedDueToLoadedProjects">
         <source>The project XML file "{0}" cannot be unloaded because at least one project "{1}" is still loaded which references that project XML.</source>
-        <target state="translated">Nie można zwolnić pliku XML „{0}” projektu, ponieważ jest nadal załadowany co najmniej jeden projekt „{1}", który odwołuje się do kodu XML tego projektu.</target>
+        <target state="translated">Nie można zwolnić pliku XML „{0}” projektu, ponieważ jest nadal załadowany co najmniej jeden projekt „{1}”, który odwołuje się do kodu XML tego projektu.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_ProjectInstanceImmutable">
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 7fda4bff876..1f226cce84d 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -63,18 +63,14 @@
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
-        <target state="translated">A variável de ambiente MSBUILDDISABLEFEATURESFROMVERSION está definida com um formato inválido. Habilitando todas as versões do ciclo de alterações. Valor inserido: {0}.</target>
-        <note>
-       Value should be of the format: xx.yy
-    </note>
+        <source>MSB4271: Environment variable MSBuildDisableFeaturesFromVersion is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
+        <target state="translated">MSB4271: A variável de ambiente MSBuildDisableFeaturesFromVersion está definida com um formato inválido. Habilitando todas as versões do ciclo de alterações. Valor inserido: {0}. Ciclos de Alterações Atuais: {1}.</target>
+        <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
-        <target state="translated">A variável de ambiente MSBUILDDISABLEFEATURESFROMVERSION está definida como uma versão fora de rotação. Usando como padrão a versão do Ciclo de Alterações: {0}. Valor inserido: {1}.</target>
-        <note>
-       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
-    </note>
+        <source>MSB4272: Environment variable MSBuildDisableFeaturesFromVersion is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
+        <target state="translated">MSB4272: A variável de ambiente MSBuildDisableFeaturesFromVersion está definida como uma versão fora de rotação. Usando como padrão a versão do Ciclo de Alterações: {0}. Valor inserido: {1}. Ciclos de Alterações Atuais: {2}.</target>
+        <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}".</source>
@@ -92,7 +88,7 @@
       </trans-unit>
       <trans-unit id="CircularDependencyInTargetGraph">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</source>
-        <target state="new">MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</target>
+        <target state="translated">MSB4006: há uma dependência circular no grafo de dependência de destino envolvendo o destino "{0}". Como "{1}" tem a dependência "{2}" em "{3}", a circular é "{4}".</target>
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
@@ -132,8 +128,15 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">"Os objetos EvaluationContext criados com SharingPolicy.Isolable não são compatíveis com o recebimento de um sistema de arquivos MSBuildFileSystemBase."</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">"Os objetos EvaluationContext criados com SharingPolicy.Isolable não são compatíveis com o recebimento de um sistema de arquivos MSBuildFileSystemBase."</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="translated">"Carregando o seguinte plug-in de cache do projeto:
+    {0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -158,6 +161,16 @@
         <target state="translated">A operação não pode ser concluída porque BeginBuild ainda não foi chamado.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="translated">MSB4270: não foi encontrado nenhum plug-in de cache do projeto no assembly "{0}". Era esperado um plug-in.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="translated">MSB4269: quando algum nó de grafo estático define um cache do projeto, todos os nós precisam definir o mesmo cache do projeto. Os seguintes projetos não contêm uma declaração de item "{0}": {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Um assembly NuGet necessário não foi encontrado. Caminho Esperado: {0}</target>
@@ -196,6 +209,26 @@
         <target state="translated">O método {0} não pode ser chamado com uma coleção que contém nomes de destino nulos ou vazios.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="translated">MSB4265: é necessário especificar só um plug-in de cache do projeto, mas foram encontrados vários: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="translated">MSB4266: falha ao inicializar o cache do projeto.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="translated">MSB4267: falha no cache do projeto durante a consulta do seguinte projeto: {0}. O cache é consultado em paralelo quanto a vários projetos, portanto, esse projeto específico pode não ser a causa.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="translated">MSB4268: falha ao desligar o cache do projeto corretamente.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: O ProjectGraph não tem suporte para os itens ProjectReference com o conjunto de metadados ToolsVersion. O ProjectReference "{0}" foi encontrado com ToolsVersion no arquivo "{1}"</target>
@@ -231,6 +264,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="translated">"MSB4264: propriedade $(SolutionPath) inválida: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: Vários pontos de entrada com soluções detectados: {0}. Se o grafo estático for carregado de uma solução, ela precisará ser o único ponto de entrada.</target>
@@ -239,8 +277,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">"Grafo estático carregado em {0} segundos: {1} nós, {2} bordas"</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">"Grafo estático carregado em {0} segundos: {1} nós, {2} bordas"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1647,8 +1685,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: O parâmetro "{0}" não tem suporte na tarefa "{1}". Verifique se o parâmetro existe na tarefa e se ele é uma propriedade de instância pública que pode ser definida.</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 269022c1f5e..3e01ca84662 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -63,18 +63,14 @@
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
-        <target state="translated">Для переменной среды MSBUILDDISABLEFEATURESFROMVERSION задан недопустимый формат. Все версии наборов рискованных изменений будут включены. Введенное значение: {0}.</target>
-        <note>
-       Value should be of the format: xx.yy
-    </note>
+        <source>MSB4271: Environment variable MSBuildDisableFeaturesFromVersion is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
+        <target state="translated">MSB4271: для переменной среды MSBuildDisableFeaturesFromVersion задан недопустимый формат. Идет включение всех версий волн изменений. Введенное значение: {0}. Текущие волны изменений: {1}.</target>
+        <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
-        <target state="translated">Для переменной среды MSBUILDDISABLEFEATURESFROMVERSION задана версия, которая исключена из ротации. Будет использована версия набора рискованных изменений по умолчанию: {0}. Введенное значение: {1}.</target>
-        <note>
-       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
-    </note>
+        <source>MSB4272: Environment variable MSBuildDisableFeaturesFromVersion is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
+        <target state="translated">MSB4272: для переменной среды MSBuildDisableFeaturesFromVersion задана версия, которая больше не используется. Идет возвращение к версии волны изменений по умолчанию: {0}. Введенное значение: {1}. Текущие волны изменений: {2}.</target>
+        <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}".</source>
@@ -92,7 +88,7 @@
       </trans-unit>
       <trans-unit id="CircularDependencyInTargetGraph">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</source>
-        <target state="new">MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</target>
+        <target state="translated">MSB4006: циклическая зависимость в целевой схеме зависимостей, включающей цель "{0}". Так как "{1}" имеет зависимость "{2}" в "{3}", циклическим является "{4}".</target>
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
@@ -132,8 +128,15 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">"Объекты EvaluationContext, созданные с помощью SharingPolicy.Isolated, не поддерживают передачу в файловую систему MSBuildFileSystemBase."</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">"Объекты EvaluationContext, созданные с помощью SharingPolicy.Isolated, не поддерживают передачу в файловую систему MSBuildFileSystemBase."</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="translated">"Идет загрузка следующего подключаемого модуля кэша проектов:
+    {0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -158,6 +161,16 @@
         <target state="translated">Не удается завершить операцию, так как ещё не был вызван BeginBuild.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="translated">MSB4270: не найдены подключаемые модули кэша проектов в сборке "{0}". Должен быть указан один модуль.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="translated">MSB4269: если для какого-либо узла статического графа определен кэш проектов, этот кэш должен быть указан для всех узлов. Следующие проекты не содержат объявление элемента "{0}": {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Не найдена обязательная сборка NuGet. Ожидаемый путь: {0}</target>
@@ -196,6 +209,26 @@
         <target state="translated">Метод {0} не может быть вызван с коллекцией, содержащей целевые имена, которые пусты или равны NULL.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="translated">MSB4265: должен быть указан один подключаемый модуль кэша проектов, но найдено несколько: {0}.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="translated">MSB4266: не удалось инициализировать кэш проектов.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="translated">MSB4267: произошел сбой кэша при выполнении запроса к следующему проекту: {0}. К кэшу выполнены параллельные запросы к нескольким проектам, поэтому, возможно, причина не в указанном проекте.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="translated">MSB4268: не удалось правильно завершить работу кэша проектов.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph не поддерживает элементы ProjectReference с набором метаданных ToolsVersion. Обнаружен ProjectReference "{0}" с ToolsVersion в файле "{1}"</target>
@@ -231,6 +264,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="translated">"MSB4264: недопустимое свойство $(SolutionPath) — {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: обнаружено несколько точек входа с решениями: {0}. Если статический граф загружен из решения, то это решение должно быть единственной точкой входа.</target>
@@ -239,8 +277,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">"Статический граф загружен за {0} с: узлов — {1}, ребер — {2}."</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">"Статический граф загружен за {0} с: узлов — {1}, ребер — {2}."</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -655,7 +693,7 @@
       </trans-unit>
       <trans-unit id="FatalTaskError">
         <source>MSB4018: The "{0}" task failed unexpectedly.</source>
-        <target state="translated">MSB4018: непредвиденная ошибка при выполнении задачи {0}".</target>
+        <target state="translated">MSB4018: непредвиденная ошибка при выполнении задачи "{0}".</target>
         <note>{StrBegin="MSB4018: "}UE: This message is shown when a task terminates because of an unhandled exception. The cause is most likely a
     programming error in the task; however, it is also possible that the unhandled exception originated in the engine, and was
     surfaced through the task when the task called into the engine.</note>
@@ -1647,8 +1685,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: параметр "{0}" не поддерживается задачей "{1}". Убедитесь, что параметр существует в задаче и является открытым задаваемым свойством экземпляра.</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 77675485fcc..8e05e78699b 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -63,18 +63,14 @@
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
-        <target state="translated">MSBUILDDISABLEFEATURESFROMVERSION adlı ortam değişkeni geçersiz bir biçime ayarlandı. Tüm değişiklik dalgası sürümleri etkinleştiriliyor. Girilen değer: {0}.</target>
-        <note>
-       Value should be of the format: xx.yy
-    </note>
+        <source>MSB4271: Environment variable MSBuildDisableFeaturesFromVersion is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
+        <target state="translated">MSB4271: MSBuildDisableFeaturesFromVersion ortam değişkeni geçersiz bir biçime ayarlandı. Tüm değişiklik dalgası sürümleri etkinleştiriliyor. Girilen değer: {0}. Geçerli Değişiklik Dalgaları: {1}.</target>
+        <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
-        <target state="translated">MSBUILDDISABLEFEATURESFROMVERSION ortam değişkeni, dönüş dışı bir sürüme ayarlandı. Varsayılan Değişiklik Dalgası sürümüne dönülüyor: {0}. Girilen değer: {1}.</target>
-        <note>
-       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
-    </note>
+        <source>MSB4272: Environment variable MSBuildDisableFeaturesFromVersion is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
+        <target state="translated">MSB4272: MSBuildDisableFeaturesFromVersion ortam değişkeni, düzenli değişiklik dışı bir sürüme ayarlandı. Varsayılan Değişiklik Dalgası sürümüne dönülüyor: {0}. Girilen değer: {1}. Geçerli Değişiklik Dalgaları: {2}.</target>
+        <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}".</source>
@@ -92,7 +88,7 @@
       </trans-unit>
       <trans-unit id="CircularDependencyInTargetGraph">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</source>
-        <target state="new">MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</target>
+        <target state="translated">MSB4006: Hedef bağımlılık grafında "{0}" hedefi ile ilgili bir döngüsel bağımlılık var. "{1}", "{3}" üzerinde "{2}" bağımlılığına sahip olduğundan "{4}" daireseldir.</target>
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
@@ -132,8 +128,15 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">"SharingPolicy.Isolated ile oluşturulan EvaluationContext nesneleri bir MSBuildFileSystemBase dosya sisteminin geçirilmesini desteklemez."</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">"SharingPolicy.Isolated ile oluşturulan EvaluationContext nesneleri bir MSBuildFileSystemBase dosya sisteminin geçirilmesini desteklemez."</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="translated">"Şu proje önbelleği eklentisi yükleniyor:
+    {0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -158,6 +161,16 @@
         <target state="translated">BeginBuild henüz çağrılmadığı için işlem tamamlanamıyor.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="translated">MSB4270: "{0}" bütünleştirilmiş kodunda proje önbelleği eklentisi bulunamadı. Bir eklenti bekleniyordu.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="translated">MSB4269: Herhangi bir statik graf düğümünde proje önbelleği tanımlandığında tüm düğümler aynı proje önbelleğini tanımlamalıdır. Şu projeler "{0}" öğe bildirimini içermiyor: {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Gereken NuGet derlemesi bulunamadı. Beklenen Yol: {0}</target>
@@ -196,6 +209,26 @@
         <target state="translated">{0} metosu null veya boş hedef adları içeren bir koleksiyonla çağrılamaz.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="translated">MSB4265: Tek bir proje önbellek eklentisi belirtilmelidir ancak birden çok eklenti bulundu: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="translated">MSB4266: Proje önbelleği başlatılamadı.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="translated">MSB4267: Proje önbelleği, {0} projesi için sorgulanırken başarısız oldu. Önbellek birden çok proje için paralel olarak sorgulandığından sorunun nedeni bu proje olmayabilir.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="translated">MSB4268: Proje önbelleği düzgün bir şekilde kapatılamadı.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph, ToolsVersion meta veri kümesine sahip ProjectReference öğelerini desteklemez. "{1}" dosyasında ToolsVersion içeren ProjectReference "{0}" bulundu</target>
@@ -231,6 +264,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="translated">"MSB4264: $(SolutionPath) özelliği geçersiz: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: Çözümlerde birden fazla giriş noktası algılandı: {0}. Statik graf bir çözümden yükleniyorsa bu çözüm tek giriş noktası olmalıdır.</target>
@@ -239,8 +277,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">"Statik graf {0} saniye içinde yüklendi: {1} düğüm, {2} uç"</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">"Statik graf {0} saniye içinde yüklendi: {1} düğüm, {2} uç"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1647,8 +1685,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: "{0}" parametresi "{1}" görevi tarafından desteklenmiyor. Parametrenin görevde bulunduğunu ve ayarlanabilir bir genel örnek özelliği olduğunu doğrulayın.</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index f8f06668656..e8d2249d056 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -63,18 +63,14 @@
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
-        <target state="translated">设置的环境变量 MSBUILDDISABLEFEATURESFROMVERSION 格式无效。正在启用所有更改批次版本。输入的值: {0}。</target>
-        <note>
-       Value should be of the format: xx.yy
-    </note>
+        <source>MSB4271: Environment variable MSBuildDisableFeaturesFromVersion is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
+        <target state="translated">MSB4271: 设置的环境变量 MSBuildDisableFeaturesFromVersion 格式无效。正在启用所有更改批次版本。输入的值: {0}。当前更改批次:{1}。</target>
+        <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
-        <target state="translated">设置的环境变量 MSBUILDDISABLEFEATURESFROMVERSION 版本不在轮换范围内。默认为“更改批次”版本: {0}。输入的值: {1}。</target>
-        <note>
-       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
-    </note>
+        <source>MSB4272: Environment variable MSBuildDisableFeaturesFromVersion is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
+        <target state="translated">MSB4272: 设置的环境变量 MSBuildDisableFeaturesFromVersion 版本不在轮换范围内。默认为“更改批次”版本: {0}。输入的值: {1}。当前更改批次: {2}。</target>
+        <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}".</source>
@@ -92,7 +88,7 @@
       </trans-unit>
       <trans-unit id="CircularDependencyInTargetGraph">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</source>
-        <target state="new">MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</target>
+        <target state="translated">MSB4006: 涉及目标“{0}”的目标依赖项关系图中存在循环依赖。由于“{1}”对“{3}”具有“{2}”依赖项，因此此循环为“{4}”。</target>
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
@@ -132,8 +128,15 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">“使用 SharingPolicy.Isolated 创建的 EvaluationContext 对象不支持通过 MSBuildFileSystemBase 文件系统传递。”</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">“使用 SharingPolicy.Isolated 创建的 EvaluationContext 对象不支持通过 MSBuildFileSystemBase 文件系统传递。”</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="translated">“正在加载以下项目缓存插件:
+    {0}”</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -158,6 +161,16 @@
         <target state="translated">无法完成该操作，因为尚未调用 BeginBuild。</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="translated">MSB4270: 在程序集 "{0}" 中未找到项目缓存插件。应有一个插件。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="translated">MSB4269: 当任何静态关系图节点定义项目缓存时，所有节点必须定义相同的项目缓存。以下项目不包含 "{0}" 项声明: {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">未找到所需的 NuGet 程序集。所需路径: {0}</target>
@@ -196,6 +209,26 @@
         <target state="translated">无法使用包含 null 或空目标名称的集合调用方法 {0}。</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="translated">MSB4265: 必须指定单个项目缓存插件，但找到多个位置: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="translated">MSB4266: 未能初始化项目缓存。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="translated">MSB4267: 查询以下项目时，项目缓存失败: {0}。并行查询了多个项目的缓存，因此这一项目可能不是导致此问题的原因。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="translated">MSB4268: 项目缓存未能正确关闭。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph 不支持具有 ToolsVersion 元数据集的 ProjectReference 项。在“{1}”文件中发现了带有 ToolsVersion 的 ProjectReference“{0}”</target>
@@ -231,6 +264,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="translated">“MSB4264: $(SolutionPath) 属性无效: {0}”</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: 检测到多个具有解决方案的入口点: {0}。如果静态图表是从解决方案中加载的，则该解决方案必须是唯一的入口点。</target>
@@ -239,8 +277,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">“静态图形已在 {0} 秒内加载: {1} 个节点、{2} 个边”</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">“静态图形已在 {0} 秒内加载: {1} 个节点、{2} 个边”</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1647,8 +1685,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: “{1}”任务不支持“{0}”参数。请确认该参数存在于此任务中，并且是可设置的公共实例属性。</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 0e73193be75..6d977855c58 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -63,18 +63,14 @@
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
-        <target state="translated">環境變數 MSBUILDDISABLEFEATURESFROMVERSION 設定的格式無效。正在啟用所有變更波浪版本。輸入的值: {0}。</target>
-        <note>
-       Value should be of the format: xx.yy
-    </note>
+        <source>MSB4271: Environment variable MSBuildDisableFeaturesFromVersion is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
+        <target state="translated">MSB4271: 環境變數 MSBuildDisableFeaturesFromVersion 設定的格式無效。正在啟用所有變更波版本。輸入的值: {0}。目前的變更波: {1}。</target>
+        <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
-        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
-        <target state="translated">環境變數 MSBUILDDISABLEFEATURESFROMVERSION 已設為無法旋轉的版本。預設為變更波浪版本: {0}。輸入的值: {1}。</target>
-        <note>
-       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
-    </note>
+        <source>MSB4272: Environment variable MSBuildDisableFeaturesFromVersion is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
+        <target state="translated">MSB4272: 環境變數 MSBuildDisableFeaturesFromVersion 已設定為無法輪替的版本。預設為變更波版本: {0}。輸入的值: {1}。目前的變更波: {2}。</target>
+        <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}".</source>
@@ -92,7 +88,7 @@
       </trans-unit>
       <trans-unit id="CircularDependencyInTargetGraph">
         <source>MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</source>
-        <target state="new">MSB4006: There is a circular dependency in the target dependency graph involving target "{0}". Since "{1}" has "{2}" dependence on "{3}", the circular is "{4}".</target>
+        <target state="translated">MSB4006: 目標 "{0}" 相關的目標相依性關係圖中包含循環相依性。因為 "{1}" 與 "{3}" 上的 "{2}" 相依，所以循環為 "{4}"。</target>
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
@@ -132,8 +128,15 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">"使用 SharingPolicy.Isolated 建立的 EvaluationContext 物件不支援以 MSBuildFileSystemBase 檔案系統傳遞。"</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">"使用 SharingPolicy.Isolated 建立的 EvaluationContext 物件不支援以 MSBuildFileSystemBase 檔案系統傳遞。"</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="translated">"正在載入下列專案快取外掛程式:
+    {0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -158,6 +161,16 @@
         <target state="translated">無法完成作業，因為尚未呼叫 BeginBuild。</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="translated">MSB4270: 在組件 "{0}" 中找不到任何專案快取外掛程式，但應該要有一個外掛程式。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="translated">MSB4269: 當任何靜態圖表節點定義了專案快取時，所有節點都必須定義相同的專案快取。下列專案不包含 "{0}" 項目宣告: {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">找不到必要的 NuGet 元件。預期的路徑: {0}</target>
@@ -196,6 +209,26 @@
         <target state="translated">無法使用內含 null 或空白目標名稱的集合呼叫方法 {0}。</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="translated">MSB4265: 只可指定單一專案快取外掛程式，但發現多個指定項目: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="translated">MSB4266: 無法將專案快取初始化。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="translated">MSB4267: 查詢下列專案時，專案快取失敗: {0}。查詢多個專案時，會平行查詢快取，因此這個特定專案可能不是失敗原因。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="translated">MSB4268: 無法正確關閉專案快取。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph 不支援設有 ToolsVersion 中繼資料的 ProjectReference 項目。在檔案 "{1}" 中找到具有 ToolsVersion 的 ProjectReference "{0}"</target>
@@ -231,6 +264,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="translated">"MSB4264: $(SolutionPath) 屬性無效: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: 偵測到解決方案有多個進入點: {0}。若是從解決方案載入靜態圖表，則該解決方案只可有一個進入點。</target>
@@ -239,8 +277,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">"在 {0} 秒內載入的靜態圖形: {1} 個節點、{2} 個邊緣"</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">"在 {0} 秒內載入的靜態圖形: {1} 個節點、{2} 個邊緣"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1647,8 +1685,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: "{1}" 工作不支援 "{0}" 參數。請驗證參數位於工作上，且為可設定的公用執行個體屬性。</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
@@ -2365,7 +2403,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</source>
       </trans-unit>
       <trans-unit id="SdkResultVersionDifferentThanReference">
         <source>MSB4241: The SDK reference "{0}" version "{1}" was resolved to version "{2}" instead.  You could be using a different version than expected if you do not update the referenced version to match.</source>
-        <target state="translated">MSB4241: SDK 參考 "{0}" 版本 "{1}" 已改為解析成版本 {2}"。若您未將參考的版本更新為符合的版本，您可能使用了與預期不同的版本。</target>
+        <target state="translated">MSB4241: SDK 參考 "{0}" 版本 "{1}" 已改為解析成版本 "{2}"。若您未將參考的版本更新為符合的版本，您可能使用了與預期不同的版本。</target>
         <note>{StrBegin="MSB4241: "}
       LOCALIZATION:  Do not localize the word SDK.
     </note>
diff --git a/src/Build/Utilities/FileSpecMatchTester.cs b/src/Build/Utilities/FileSpecMatchTester.cs
index bdca578f85a..e48fca39e77 100644
--- a/src/Build/Utilities/FileSpecMatchTester.cs
+++ b/src/Build/Utilities/FileSpecMatchTester.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Shared;
-using System;
 using System.Diagnostics;
 using System.IO;
 using System.Text.RegularExpressions;
diff --git a/src/Build/Utilities/NuGetFrameworkWrapper.cs b/src/Build/Utilities/NuGetFrameworkWrapper.cs
index 3bb52fd3d73..e60c3a07af2 100644
--- a/src/Build/Utilities/NuGetFrameworkWrapper.cs
+++ b/src/Build/Utilities/NuGetFrameworkWrapper.cs
@@ -32,7 +32,7 @@ public NuGetFrameworkWrapper()
                 BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
             try
             {
-                var NuGetAssembly = Assembly.LoadFile(Path.Combine(assemblyDirectory, "NuGet.Frameworks.dll"));
+                var NuGetAssembly = Assembly.LoadFrom(Path.Combine(assemblyDirectory, "NuGet.Frameworks.dll"));
                 var NuGetFramework = NuGetAssembly.GetType("NuGet.Frameworks.NuGetFramework");
                 var NuGetFrameworkCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.CompatibilityProvider");
                 var NuGetFrameworkDefaultCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.DefaultCompatibilityProvider");
diff --git a/src/Deprecated/Conversion.UnitTests/XMakeConversionUnitTests.csproj b/src/Deprecated/Conversion.UnitTests/XMakeConversionUnitTests.csproj
index 762d88b132b..3f67674e3f2 100644
--- a/src/Deprecated/Conversion.UnitTests/XMakeConversionUnitTests.csproj
+++ b/src/Deprecated/Conversion.UnitTests/XMakeConversionUnitTests.csproj
@@ -96,5 +96,5 @@
     <Folder Include="Properties\" />
   </ItemGroup>
 
-  <Import Project="$(RepoRoot)eng\ProducesNoOutput.Settings.props" Condition="'$(OsEnvironment)'!='windows'" />
-</Project>
\ No newline at end of file
+  <Import Project="$(RepoRoot)eng\ProducesNoOutput.Settings.props" Condition="! $([MSBuild]::IsOSPlatform('windows'))" />
+</Project>
diff --git a/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj b/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
index af98c8f06b8..1fa50bc5c3d 100644
--- a/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
+++ b/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
@@ -20,7 +20,7 @@
     <Compile Include="ProjectFileConverter.cs" />
 
     <!-- Resource Files -->
-    
+
     <EmbeddedResource Include="Resources\Strings.resx">
       <LogicalName>$(AssemblyName).Strings.resources</LogicalName>
       <SubType>Designer</SubType>
@@ -31,12 +31,12 @@
       <LogicalName>$(AssemblyName).Strings.shared.resources</LogicalName>
       <SubType>Designer</SubType>
     </EmbeddedResource>
-    
+
     <!-- Assemblies Files we depend on -->
     <Reference Include="System.Configuration" />
     <ProjectReference Include="..\..\Build\Microsoft.Build.csproj" />
     <ProjectReference Include="..\Engine\Microsoft.Build.Engine.csproj" />
   </ItemGroup>
 
-  <Import Project="$(RepoRoot)eng\ProducesNoOutput.Settings.props" Condition="'$(OsEnvironment)'!='windows'" />
+  <Import Project="$(RepoRoot)eng\ProducesNoOutput.Settings.props" Condition="! $([MSBuild]::IsOSPlatform('windows'))" />
 </Project>
diff --git a/src/Deprecated/Engine.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Deprecated/Engine.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index c615fe9bdbb..7360b075b1d 100644
--- a/src/Deprecated/Engine.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Deprecated/Engine.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -200,5 +200,5 @@
     <Folder Include="Properties\" />
   </ItemGroup>
 
-  <Import Project="$(RepoRoot)eng\ProducesNoOutput.Settings.props" Condition="'$(OsEnvironment)'!='windows'" />
-</Project>
\ No newline at end of file
+  <Import Project="$(RepoRoot)eng\ProducesNoOutput.Settings.props" Condition="! $([MSBuild]::IsOSPlatform('windows'))" />
+</Project>
diff --git a/src/Deprecated/Engine/Errors/InternalLoggerException.cs b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
index 22f730e348c..3926d8504db 100644
--- a/src/Deprecated/Engine/Errors/InternalLoggerException.cs
+++ b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
@@ -14,12 +14,10 @@ namespace Microsoft.Build.BuildEngine
     /// This exception is used to wrap an unhandled exception from a logger. This exception aborts the build, and it can only be
     /// thrown by the MSBuild engine.
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both forward and backward compatibility
-    /// </remarks>
     /// <owner>SumedhK</owner>
+    // WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
     public sealed class InternalLoggerException : Exception
     {
diff --git a/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs b/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
index 63d3c34a620..2f08d3348e9 100644
--- a/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
+++ b/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
@@ -14,12 +14,11 @@ namespace Microsoft.Build.BuildEngine
     /// This exception is thrown whenever there is a problem with the user's XML project file. The problem might be semantic or
     /// syntactical. The latter would be of a type typically caught by XSD validation (if it was performed by the project writer).
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both forward and backward compatibility
-    /// </remarks>
     /// <owner>RGoel</owner>
+    // WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both forward and backward compatibility
+
     [Serializable]
     public sealed class InvalidProjectFileException : Exception
     {
diff --git a/src/Deprecated/Engine/Microsoft.Build.Engine.csproj b/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
index 1626f53236d..99f763a29b4 100644
--- a/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
+++ b/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
@@ -15,7 +15,7 @@
     <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
     <NoWarn>$(NoWarn);1570;1572;1573;1587</NoWarn>
   </PropertyGroup>
-  
+
   <ItemGroup>
     <Reference Include="System.Configuration" />
 
@@ -217,5 +217,5 @@
     </EmbeddedResource>
   </ItemGroup>
 
-  <Import Project="$(RepoRoot)eng\ProducesNoOutput.Settings.props" Condition="'$(OsEnvironment)'!='windows'" />
+  <Import Project="$(RepoRoot)eng\ProducesNoOutput.Settings.props" Condition="! $([MSBuild]::IsOSPlatform('windows'))" />
 </Project>
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index 8e63a94f93d..93836bc46aa 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -42,7 +42,6 @@
     <DefineConstants Condition="'$(MonoBuild)' != 'true' and '$(MachineIndependentBuild)' != 'true'">$(DefineConstants);FEATURE_ENCODING_DEFAULT</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_ENVIRONMENT_SYSTEMDIRECTORY</DefineConstants>
     <DefineConstants Condition="'$(MonoBuild)' != 'true'">$(DefineConstants);FEATURE_FILE_TRACKER</DefineConstants>
-    <DefineConstants>$(DefineConstants);FEATURE_FUSION_COMPAREASSEMBLYIDENTITY</DefineConstants>
     <DefineConstants Condition="'$(MachineIndependentBuild)' != 'true'">$(DefineConstants);FEATURE_GAC</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_GET_COMMANDLINE</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_HANDLE_SAFEWAITHANDLE</DefineConstants>
@@ -108,10 +107,10 @@
     <DefineConstants Condition="'$(MonoBuild)'=='true'">$(DefineConstants);MONO</DefineConstants>
 
     <!-- Useful for tests that need OS information as a constant -->
-    <DefineConstants Condition="'$(OsEnvironment)'=='windows'">$(DefineConstants);TEST_ISWINDOWS</DefineConstants>
+    <DefineConstants Condition="$([MSBuild]::IsOSPlatform('windows'))">$(DefineConstants);TEST_ISWINDOWS</DefineConstants>
   </PropertyGroup>
 
-  <PropertyGroup Condition="$(TargetFramework.StartsWith('netstandard')) or $(TargetFramework.StartsWith('netcore'))">
+  <PropertyGroup Condition="'$(MonoBuild)' != 'true' and ($([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'netcoreapp1.0')) or $(TargetFramework.StartsWith('netstandard')))">
     <NetCoreBuild>true</NetCoreBuild>
     <DefineConstants>$(DefineConstants);RUNTIME_TYPE_NETCORE</DefineConstants>
   </PropertyGroup>
@@ -125,10 +124,9 @@
     <DefineConstants>$(DefineConstants);WORKAROUND_COREFX_19110</DefineConstants>
   </PropertyGroup>
 
-  <PropertyGroup Condition="'$(TargetFramework)' == 'netcoreapp2.1'">
+  <PropertyGroup Condition="'$(TargetFramework)' == 'netcoreapp2.1' or '$(TargetFramework)' == 'net5.0'">
     <DefineConstants>$(DefineConstants);FEATURE_PIPEOPTIONS_CURRENTUSERONLY</DefineConstants>
     <DefineConstants Condition="'$(MachineIndependentBuild)' != 'true'">$(DefineConstants);FEATURE_NODE_REUSE</DefineConstants>
-    <DefineConstants>$(DefineConstants);FEATURE_SPAN</DefineConstants>
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(GenerateReferenceAssemblySources)' != 'true'">
diff --git a/src/Directory.Build.props b/src/Directory.Build.props
index 54b620c6013..e957eaa9db1 100644
--- a/src/Directory.Build.props
+++ b/src/Directory.Build.props
@@ -24,7 +24,7 @@
     <CustomBeforeMicrosoftCommonTargets>$(MSBuildThisFileDirectory)Directory.BeforeCommon.targets</CustomBeforeMicrosoftCommonTargets>
 
     <Platforms>AnyCPU;x64</Platforms>
-    
+
     <!-- Defaults for target frameworks and architecture -->
     <LibraryTargetFrameworks>$(FullFrameworkTFM);netstandard2.0</LibraryTargetFrameworks>
     <LibraryTargetFrameworks Condition="'$(DotNetBuildFromSource)' == 'true'">netstandard2.0</LibraryTargetFrameworks>
@@ -32,8 +32,8 @@
     <PlatformTarget>AnyCPU</PlatformTarget>
 
     <!-- Target frameworks for Exe and unit test projects (ie projects with runtime output) -->
-    <RuntimeOutputTargetFrameworks>netcoreapp2.1</RuntimeOutputTargetFrameworks>
-    <RuntimeOutputTargetFrameworks Condition="'$(OsEnvironment)'=='windows' and '$(DotNetBuildFromSource)' != 'true'">$(FullFrameworkTFM);$(RuntimeOutputTargetFrameworks)</RuntimeOutputTargetFrameworks>
+    <RuntimeOutputTargetFrameworks>net5.0</RuntimeOutputTargetFrameworks>
+    <RuntimeOutputTargetFrameworks Condition="$([MSBuild]::IsOSPlatform('windows')) and '$(DotNetBuildFromSource)' != 'true'">$(FullFrameworkTFM);$(RuntimeOutputTargetFrameworks)</RuntimeOutputTargetFrameworks>
     <RuntimeOutputTargetFrameworks Condition="'$(MonoBuild)' == 'true'">$(FullFrameworkTFM)</RuntimeOutputTargetFrameworks>
 
     <!-- Don't automatically append target framework to output path, since we want to put the Platform Target beforehand, if it's not AnyCPU -->
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index 7d4b6537997..ab0983d1760 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -17,21 +17,22 @@
     <!-- Set output type of test projects to EXE.  This will allow us to run tests on .NET Core via F5 or "dotnet run" -->
     <OutputType>Exe</OutputType>
     <GenerateProgramFile>false</GenerateProgramFile>
-    
+
     <!-- Makes xunit print all test names in stdout -->
     <XunitOptions>$(XunitOptions) -diagnostics</XunitOptions>
-    
+
     <!-- Respect the traits set up by PlatformSpecific attribute. -->
-    <XunitOptions Condition="'$(OsEnvironment)'=='windows'">$(XunitOptions) -notrait category=nonwindowstests</XunitOptions>
-    <XunitOptions Condition="'$(OsEnvironment)'=='linux'">$(XunitOptions) -notrait category=nonlinuxtests</XunitOptions>
-    <XunitOptions Condition="'$(OsEnvironment)'=='linux' and '$(NetCoreBuild)'=='true'">-notrait category=nonlinuxtests -notrait category=netcore-linux-failing</XunitOptions>
-    <XunitOptions Condition="'$(OsEnvironment)'=='osx'">$(XunitOptions) -notrait category=nonosxtests</XunitOptions>
-    <XunitOptions Condition="'$(OsEnvironment)'=='osx' and '$(NetCoreBuild)'=='true'">-notrait category=nonosxtests -notrait category=netcore-osx-failing</XunitOptions>
-    <XunitOptions Condition="'$(OsEnvironment)'=='bsd'">$(XunitOptions) -notrait category=nonfreebsdtests</XunitOptions>
+    <XunitOptions Condition="$([MSBuild]::IsOSPlatform('windows'))">$(XunitOptions) -notrait category=nonwindowstests</XunitOptions>
+    <XunitOptions Condition="$([MSBuild]::IsOSPlatform('linux'))">$(XunitOptions) -notrait category=nonlinuxtests</XunitOptions>
+    <XunitOptions Condition="$([MSBuild]::IsOSPlatform('linux')) and '$(NetCoreBuild)'=='true'">-notrait category=nonlinuxtests -notrait category=netcore-linux-failing</XunitOptions>
+    <XunitOptions Condition="$([MSBuild]::IsOSPlatform('osx'))">$(XunitOptions) -notrait category=nonosxtests</XunitOptions>
+    <XunitOptions Condition="$([MSBuild]::IsOSPlatform('osx')) and '$(NetCoreBuild)'=='true'">-notrait category=nonosxtests -notrait category=netcore-osx-failing</XunitOptions>
+    <!-- Replace with MSBuild::IsBsdLike once the initial msbuild knows about it -->
+    <XunitOptions Condition="$([MSBuild]::IsOSPlatform('FREEBSD')) Or $([MSBuild]::IsOSPlatform('NETBSD')) Or $([MSBuild]::IsOSPlatform('OPENBSD'))">$(XunitOptions) -notrait category=nonfreebsdtests</XunitOptions>
 
     <XunitOptions Condition="'$(MonoBuild)' == 'true'">$(XunitOptions) -notrait category=non-mono-tests -notrait category=nonmonotests</XunitOptions>
-    <XunitOptions Condition="'$(OsEnvironment)'=='osx' and '$(MonoBuild)' == 'true'">$(XunitOptions) -notrait category=mono-osx-failing</XunitOptions>
-    <XunitOptions Condition="'$(OsEnvironment)'=='windows' and '$(MonoBuild)' == 'true'">$(XunitOptions) -notrait category=mono-windows-failing</XunitOptions>
+    <XunitOptions Condition="$([MSBuild]::IsOSPlatform('osx')) and '$(MonoBuild)' == 'true'">$(XunitOptions) -notrait category=mono-osx-failing</XunitOptions>
+    <XunitOptions Condition="$([MSBuild]::IsOSPlatform('windows')) and '$(MonoBuild)' == 'true'">$(XunitOptions) -notrait category=mono-windows-failing</XunitOptions>
 
     <XunitOptions Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'">$(XunitOptions) -notrait category=nonnetcoreapptests</XunitOptions>
     <XunitOptions Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">$(XunitOptions) -notrait category=nonnetfxtests</XunitOptions>
@@ -39,7 +40,7 @@
     <XunitOptions>$(XunitOptions) -notrait category=failing</XunitOptions>
 
     <TestRunnerAdditionalArguments>$(XunitOptions)</TestRunnerAdditionalArguments>
-    
+
     <PackageOutputPath Condition="'$(IsVisualStudioInsertionPackage)' == 'true'">$(DevDivPackagesDir)</PackageOutputPath>
 
     <!-- Arcade sdk also carries an xunit.runner.json which sometimes overrides the one in this repo. Assign a value to the arcade properties XUnitDesktopSettingsFile and XUnitCoreSettingsFile to prevent the arcade version of the file being added. -->
@@ -57,7 +58,7 @@
     <!-- Don't localize unit test projects -->
     <PackageReference Remove="XliffTasks" />
 
-    <Compile Include="$(RepoRoot)src\Shared\UnitTests\TestAssemblyInfo.cs" />
+    <Compile Include="$(RepoRoot)src\Shared\UnitTests\TestAssemblyInfo.cs" Condition="'$(IsLibraryTestProject)' != 'true'" />
     <Compile Include="$(RepoRoot)src\Shared\UnitTests\TestProgram.cs" />
   </ItemGroup>
 
@@ -73,18 +74,19 @@
     <!-- Disable reference assembly source when building for Mono, as some APIs are excluded when compiling for Mono -->
     <GenerateReferenceAssemblySources>false</GenerateReferenceAssemblySources>
   </PropertyGroup>
-  
-  <PropertyGroup Condition="'$(GenerateReferenceAssemblySources)' == 'true' and '$(OsEnvironment)'=='windows'">
+
+  <PropertyGroup Condition="'$(GenerateReferenceAssemblySources)' == 'true' and $([MSBuild]::IsOSPlatform('windows'))">
     <GenAPIAssemblyName>$(AssemblyName)</GenAPIAssemblyName>
     <GenAPIAssemblyName Condition="'$(GenAPIAssemblyName)' == ''">$(MSBuildProjectName)</GenAPIAssemblyName>
     <GenAPIShortFrameworkIdentifier Condition="$(TargetFramework.StartsWith('net4'))">net</GenAPIShortFrameworkIdentifier>
     <GenAPIShortFrameworkIdentifier Condition="$(TargetFramework.StartsWith('netstandard'))">netstandard</GenAPIShortFrameworkIdentifier>
     <GenAPIShortFrameworkIdentifier Condition="$(TargetFramework.StartsWith('netcoreapp'))">netstandard</GenAPIShortFrameworkIdentifier>
+    <GenAPIShortFrameworkIdentifier Condition="$(TargetFramework.StartsWith('net5'))">netstandard</GenAPIShortFrameworkIdentifier>
     <GenAPITargetPath>$(RepoRoot)ref\$(GenAPIAssemblyName)\$(GenAPIShortFrameworkIdentifier)\$(GenAPIAssemblyName).cs</GenAPITargetPath>
   </PropertyGroup>
-  
-  <ItemGroup Condition="'$(GenerateReferenceAssemblySources)' == 'true' and '$(OsEnvironment)'=='windows'">
-    <PackageReference Include="Microsoft.DotNet.BuildTools.GenAPI" PrivateAssets="All" />
+
+  <ItemGroup Condition="'$(GenerateReferenceAssemblySources)' == 'true' and $([MSBuild]::IsOSPlatform('windows'))">
+    <PackageReference Include="Microsoft.DotNet.GenAPI" PrivateAssets="All" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(IsUnitTestProject)' == 'true' And '$(TargetFrameworkIdentifier)' != '.NETFramework' ">
@@ -115,7 +117,7 @@
     </ItemGroup>
   </Target>
 
-  <Target Name="CreateTypeLib" BeforeTargets="AfterBuild" Condition="'$(BuildingInsideVisualStudio)' != 'true' and '$(CreateTlb)' == 'true' and '$(OsEnvironment)' == 'windows' and '$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MSBuildRuntimeType)' != 'Core'">
+  <Target Name="CreateTypeLib" BeforeTargets="AfterBuild" Condition="'$(BuildingInsideVisualStudio)' != 'true' and '$(CreateTlb)' == 'true' and $([MSBuild]::IsOSPlatform('windows')) and '$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MSBuildRuntimeType)' != 'Core'">
     <PropertyGroup>
       <TlbExpPath>$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPathToDotNetFrameworkSdkFile('tlbexp.exe'))</TlbExpPath>
       <!-- Provide a mechanism for turning on verbose TlbExp output for diagnosing issues -->
diff --git a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
index 96af6943e1f..b73c360d59d 100644
--- a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
+++ b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
@@ -18,6 +18,7 @@
   <ItemGroup>
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
     <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
+    <ProjectReference Include="..\StringTools\StringTools.csproj" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
@@ -30,9 +31,6 @@
   </ItemGroup>
 
   <ItemGroup>
-    <Compile Include="..\Shared\ChangeWaves.cs">
-      <Link>SharedUtilities\ChangeWaves.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\UnitTests\TestEnvironment.cs" />
     <Compile Include="..\Shared\FileUtilities.cs" />
     <Compile Include="..\Shared\TempFileUtilities.cs" />
@@ -46,10 +44,6 @@
     <Compile Include="..\Shared\ExceptionHandling.cs" />
     <Compile Include="..\Shared\VisualStudioLocationHelper.cs" />
     <Compile Include="..\Shared\StringBuilderCache.cs" />
-    <Compile Include="..\Shared\IInternable.cs" />
-    <Compile Include="..\Shared\WeakStringCache.cs" />
-    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs" />
-    <Compile Include="..\Shared\OpportunisticIntern.cs" />
     <Compile Include="..\Shared\FileUtilitiesRegex.cs" />
     <Compile Include="..\Shared\UnitTests\AssemblyResources.cs" />
     <Compile Include="..\Shared\Traits.cs" />
diff --git a/src/Framework/BuildErrorEventArgs.cs b/src/Framework/BuildErrorEventArgs.cs
index 5d086d1850e..4cbbb4106d6 100644
--- a/src/Framework/BuildErrorEventArgs.cs
+++ b/src/Framework/BuildErrorEventArgs.cs
@@ -10,14 +10,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for error events
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class BuildErrorEventArgs : LazyFormattedBuildEventArgs
     {
diff --git a/src/Framework/BuildEventArgs.cs b/src/Framework/BuildEventArgs.cs
index 5e56b0c79aa..1592e8fd480 100644
--- a/src/Framework/BuildEventArgs.cs
+++ b/src/Framework/BuildEventArgs.cs
@@ -12,14 +12,12 @@ namespace Microsoft.Build.Framework
     /// This class encapsulates the default data associated with build events. 
     /// It is intended to be extended/sub-classed.
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public abstract class BuildEventArgs : EventArgs
     {
diff --git a/src/Framework/BuildFinishedEventArgs.cs b/src/Framework/BuildFinishedEventArgs.cs
index 34083b46ebe..198b7df2034 100644
--- a/src/Framework/BuildFinishedEventArgs.cs
+++ b/src/Framework/BuildFinishedEventArgs.cs
@@ -9,14 +9,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// This class represents the event arguments for build finished events.
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class BuildFinishedEventArgs : BuildStatusEventArgs
     {
diff --git a/src/Framework/BuildMessageEventArgs.cs b/src/Framework/BuildMessageEventArgs.cs
index c31672b68a5..7a73a533151 100644
--- a/src/Framework/BuildMessageEventArgs.cs
+++ b/src/Framework/BuildMessageEventArgs.cs
@@ -33,14 +33,12 @@ public enum MessageImportance
     /// <summary>
     /// Arguments for message events
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class BuildMessageEventArgs : LazyFormattedBuildEventArgs
     {
diff --git a/src/Framework/BuildStartedEventArgs.cs b/src/Framework/BuildStartedEventArgs.cs
index a177576f7e2..8297879a12c 100644
--- a/src/Framework/BuildStartedEventArgs.cs
+++ b/src/Framework/BuildStartedEventArgs.cs
@@ -9,14 +9,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for build started events.
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class BuildStartedEventArgs : BuildStatusEventArgs
     {
diff --git a/src/Framework/BuildWarningEventArgs.cs b/src/Framework/BuildWarningEventArgs.cs
index 5b37aa338c1..f78f7716bff 100644
--- a/src/Framework/BuildWarningEventArgs.cs
+++ b/src/Framework/BuildWarningEventArgs.cs
@@ -10,14 +10,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for warning events
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class BuildWarningEventArgs : LazyFormattedBuildEventArgs
     {
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
new file mode 100644
index 00000000000..7761c468d44
--- /dev/null
+++ b/src/Framework/ChangeWaves.cs
@@ -0,0 +1,175 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Linq;
+
+namespace Microsoft.Build.Utilities
+{
+    internal enum ChangeWaveConversionState
+    {
+        NotConvertedYet,
+        Valid,
+        InvalidFormat,
+        OutOfRotation
+    }
+
+    /// <summary>
+    /// Coupled together with the MSBUILDDISABLEFEATURESFROMVERSION environment variable,
+    /// this class acts as a way to make risky changes while giving customers an opt-out.
+    /// </summary>
+    /// See docs here: https://github.com/dotnet/msbuild/blob/master/documentation/wiki/ChangeWaves.md
+    /// For dev docs: https://github.com/dotnet/msbuild/blob/master/documentation/wiki/ChangeWaves-Dev.md
+    internal class ChangeWaves
+    {
+        internal static readonly Version Wave16_8 = new Version(16, 8);
+        internal static readonly Version Wave16_10 = new Version(16, 10);
+        internal static readonly Version Wave17_0 = new Version(17, 0);
+        internal static readonly Version[] AllWaves = { Wave16_8, Wave16_10, Wave17_0 };
+
+        /// <summary>
+        /// Special value indicating that all features behind all Change Waves should be enabled.
+        /// </summary>
+        internal static readonly Version EnableAllFeatures = new Version(999, 999);
+
+        /// <summary>
+        /// The lowest wave in the current rotation of Change Waves.
+        /// </summary>
+        internal static Version LowestWave
+        {
+            get
+            {
+                return AllWaves[0];
+            }
+        }
+
+        /// <summary>
+        /// The highest wave in the current rotation of Change Waves.
+        /// </summary>
+        internal static Version HighestWave
+        {
+            get
+            {
+                return AllWaves[AllWaves.Length - 1];
+            }
+        }
+
+        /// <summary>
+        /// Checks the conditions for whether or not we want ApplyChangeWave to be called again.
+        /// </summary>
+        private static bool ShouldApplyChangeWave
+        {
+            get
+            {
+                return ConversionState == ChangeWaveConversionState.NotConvertedYet || _cachedWave == null;
+            }
+        }
+
+        private static Version _cachedWave;
+
+        /// <summary>
+        /// The current disabled wave.
+        /// </summary>
+        internal static Version DisabledWave
+        {
+            get
+            {
+                if (ShouldApplyChangeWave)
+                {
+                    ApplyChangeWave();
+                }
+
+                return _cachedWave;
+            }
+        }
+
+        private static ChangeWaveConversionState _state;
+
+        /// <summary>
+        /// The status of how the disabled wave was set.
+        /// </summary>
+        internal static ChangeWaveConversionState ConversionState
+        {
+            get
+            {
+                return _state;
+            }
+            set
+            {
+                // Keep state persistent.
+                if (_state == ChangeWaveConversionState.NotConvertedYet)
+                {
+                    _state = value;
+                }
+            }
+        }
+
+        /// <summary>
+        /// Read from environment variable `MSBuildDisableFeaturesFromVersion`, correct it if required, cache it and its ConversionState.
+        /// </summary>
+        internal static void ApplyChangeWave()
+        {
+            // Once set, change wave should not need to be set again.
+            if (!ShouldApplyChangeWave)
+            {
+                return;
+            }
+
+            string msbuildDisableFeaturesFromVersion = Environment.GetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION");
+
+            // Most common case, `MSBuildDisableFeaturesFromVersion` unset
+            if (string.IsNullOrEmpty(msbuildDisableFeaturesFromVersion))
+            {
+                ConversionState = ChangeWaveConversionState.Valid;
+                _cachedWave = ChangeWaves.EnableAllFeatures;
+            }
+            else if (!Version.TryParse(msbuildDisableFeaturesFromVersion, out _cachedWave))
+            {
+                ConversionState = ChangeWaveConversionState.InvalidFormat;
+                _cachedWave = ChangeWaves.EnableAllFeatures;
+            }
+            else if (_cachedWave == EnableAllFeatures || AllWaves.Contains(_cachedWave))
+            {
+                ConversionState = ChangeWaveConversionState.Valid;
+            }
+            else if (_cachedWave < LowestWave)
+            {
+                ConversionState = ChangeWaveConversionState.OutOfRotation;
+                _cachedWave = LowestWave;
+            }
+            else if (_cachedWave > HighestWave)
+            {
+                ConversionState = ChangeWaveConversionState.OutOfRotation;
+                _cachedWave = HighestWave;
+            }
+            // _cachedWave is somewhere between valid waves, find the next valid version.
+            else
+            {
+                _cachedWave = AllWaves.First((x) => x > _cachedWave);
+                ConversionState = ChangeWaveConversionState.Valid;
+            }
+        }
+
+        /// <summary>
+        /// Determines whether features behind the given wave are enabled.
+        /// </summary>
+        /// <param name="wave">The version to compare.</param>
+        /// <returns>A bool indicating whether the change wave is enabled.</returns>
+        internal static bool AreFeaturesEnabled(Version wave)
+        {
+            ApplyChangeWave();
+
+            return wave < _cachedWave;
+        }
+
+        /// <summary>
+        /// Resets the state and value of the currently disabled version.
+        /// Used for testing only.
+        /// </summary>
+        internal static void ResetStateForTests()
+        {
+            _cachedWave = null;
+            _state = ChangeWaveConversionState.NotConvertedYet;
+        }
+    }
+}
diff --git a/src/Framework/CriticalBuildMessageEventArgs.cs b/src/Framework/CriticalBuildMessageEventArgs.cs
index 2bc8853a295..0aad4046ada 100644
--- a/src/Framework/CriticalBuildMessageEventArgs.cs
+++ b/src/Framework/CriticalBuildMessageEventArgs.cs
@@ -8,14 +8,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for critical message events. These always have High importance.
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class CriticalBuildMessageEventArgs : BuildMessageEventArgs
     {
diff --git a/src/Framework/CustomBuildEventArgs.cs b/src/Framework/CustomBuildEventArgs.cs
index c676c75f8f1..cba045ebb3e 100644
--- a/src/Framework/CustomBuildEventArgs.cs
+++ b/src/Framework/CustomBuildEventArgs.cs
@@ -8,14 +8,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for custom build events.
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public abstract class CustomBuildEventArgs : LazyFormattedBuildEventArgs
     {
diff --git a/src/Framework/ExternalProjectFinishedEventArgs.cs b/src/Framework/ExternalProjectFinishedEventArgs.cs
index ab5a72406dc..d09c6f56df1 100644
--- a/src/Framework/ExternalProjectFinishedEventArgs.cs
+++ b/src/Framework/ExternalProjectFinishedEventArgs.cs
@@ -8,14 +8,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for external project finished events
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class ExternalProjectFinishedEventArgs : CustomBuildEventArgs
     {
diff --git a/src/Framework/ExternalProjectStartedEventArgs.cs b/src/Framework/ExternalProjectStartedEventArgs.cs
index d086130dfab..2073ee505d6 100644
--- a/src/Framework/ExternalProjectStartedEventArgs.cs
+++ b/src/Framework/ExternalProjectStartedEventArgs.cs
@@ -8,14 +8,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for external project started events
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class ExternalProjectStartedEventArgs : CustomBuildEventArgs
     {
diff --git a/src/Framework/ILogger.cs b/src/Framework/ILogger.cs
index 9dd6e9f675d..938ea0bd890 100644
--- a/src/Framework/ILogger.cs
+++ b/src/Framework/ILogger.cs
@@ -19,11 +19,12 @@ namespace Microsoft.Build.Framework
     /// 3) Normal -- display all errors, warnings, high importance events, some status events, and a build summary
     /// 4) Detailed -- display all errors, warnings, high and normal importance events, all status events, and a build summary
     /// 5) Diagnostic -- display all events, and a build summary
-    /// 
-    /// WARNING: VS Automation code for the Tools/Options MSBuild build verbosity setting will be broken
-    /// by changes to this enum (not to mention existing MSBuild clients and vsproject code). 
-    /// Please make sure to talk to automation devs before changing it.
     /// </remarks>
+    // 
+    // WARNING: VS Automation code for the Tools/Options MSBuild build verbosity setting will be broken
+    // by changes to this enum (not to mention existing MSBuild clients and vsproject code). 
+    // Please make sure to talk to automation devs before changing it.
+
     [ComVisible(true)]
     public enum LoggerVerbosity
     {
diff --git a/src/Framework/LoggerException.cs b/src/Framework/LoggerException.cs
index f30bf2452f3..63ed9ea7606 100644
--- a/src/Framework/LoggerException.cs
+++ b/src/Framework/LoggerException.cs
@@ -14,11 +14,9 @@ namespace Microsoft.Build.Framework
     /// Allows a logger to force the build to stop in an explicit way, when, for example, it 
     /// receives invalid parameters, or cannot write to disk.
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
     public class LoggerException : Exception
     {
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index abc5fd12d93..5ba9fa07883 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -132,10 +132,12 @@ public void EvaluatePass1Start(string projectFile)
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="numberOfProperties">Number of Properties getting evaluated.</param>
+        /// <param name="numberOfImports">Number of Imports getting evaluated.</param>
         [Event(15, Keywords = Keywords.All)]
-        public void EvaluatePass1Stop(string projectFile)
+        public void EvaluatePass1Stop(string projectFile, int numberOfProperties, int numberOfImports)
         {
-            WriteEvent(15, projectFile);
+            WriteEvent(15, projectFile, numberOfProperties, numberOfImports);
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
@@ -146,10 +148,11 @@ public void EvaluatePass2Start(string projectFile)
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="numberOfItemDefinitionGroupElements">Number of ItemDefinitionGroupElements getting evaluated.</param>
         [Event(17, Keywords = Keywords.All)]
-        public void EvaluatePass2Stop(string projectFile)
+        public void EvaluatePass2Stop(string projectFile, int numberOfItemDefinitionGroupElements)
         {
-            WriteEvent(17, projectFile);
+            WriteEvent(17, projectFile, numberOfItemDefinitionGroupElements);
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
@@ -160,10 +163,11 @@ public void EvaluatePass3Start(string projectFile)
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="numberOfItemGroupElements">Number of project items evaluated.</param>
         [Event(19, Keywords = Keywords.All)]
-        public void EvaluatePass3Stop(string projectFile)
+        public void EvaluatePass3Stop(string projectFile, int numberOfItemGroupElements)
         {
-            WriteEvent(19, projectFile);
+            WriteEvent(19, projectFile, numberOfItemGroupElements);
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
@@ -174,10 +178,11 @@ public void EvaluatePass4Start(string projectFile)
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="numberOfUsingTaskElements">Number of using tasks elements evaluated.</param>
         [Event(21, Keywords = Keywords.All)]
-        public void EvaluatePass4Stop(string projectFile)
+        public void EvaluatePass4Stop(string projectFile, int numberOfUsingTaskElements)
         {
-            WriteEvent(21, projectFile);
+            WriteEvent(21, projectFile, numberOfUsingTaskElements);
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
@@ -188,10 +193,11 @@ public void EvaluatePass5Start(string projectFile)
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="targetElementsCount">Number of targets read.</param>
         [Event(23, Keywords = Keywords.All)]
-        public void EvaluatePass5Stop(string projectFile)
+        public void EvaluatePass5Stop(string projectFile, int targetElementsCount)
         {
-            WriteEvent(23, projectFile);
+            WriteEvent(23, projectFile, targetElementsCount);
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
diff --git a/src/Framework/ProjectFinishedEventArgs.cs b/src/Framework/ProjectFinishedEventArgs.cs
index 7ae29c7215f..5c0cee0f259 100644
--- a/src/Framework/ProjectFinishedEventArgs.cs
+++ b/src/Framework/ProjectFinishedEventArgs.cs
@@ -10,14 +10,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for project finished events
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class ProjectFinishedEventArgs : BuildStatusEventArgs
     {
diff --git a/src/Framework/ProjectStartedEventArgs.cs b/src/Framework/ProjectStartedEventArgs.cs
index b1bd90f8076..2de82ffe9cb 100644
--- a/src/Framework/ProjectStartedEventArgs.cs
+++ b/src/Framework/ProjectStartedEventArgs.cs
@@ -14,14 +14,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for project started events
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class ProjectStartedEventArgs : BuildStatusEventArgs
     {
diff --git a/src/Framework/TargetFinishedEventArgs.cs b/src/Framework/TargetFinishedEventArgs.cs
index c4951de6c61..fae6bbd1c9b 100644
--- a/src/Framework/TargetFinishedEventArgs.cs
+++ b/src/Framework/TargetFinishedEventArgs.cs
@@ -11,14 +11,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for target finished events
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class TargetFinishedEventArgs : BuildStatusEventArgs
     {
diff --git a/src/Framework/TargetStartedEventArgs.cs b/src/Framework/TargetStartedEventArgs.cs
index 69b2ae7a1db..5d2b3b11dbd 100644
--- a/src/Framework/TargetStartedEventArgs.cs
+++ b/src/Framework/TargetStartedEventArgs.cs
@@ -10,14 +10,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for target started events
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>    
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility    
     [Serializable]
     public class TargetStartedEventArgs : BuildStatusEventArgs
     {
diff --git a/src/Framework/TaskFinishedEventArgs.cs b/src/Framework/TaskFinishedEventArgs.cs
index f8a8e1ef918..ca969f10712 100644
--- a/src/Framework/TaskFinishedEventArgs.cs
+++ b/src/Framework/TaskFinishedEventArgs.cs
@@ -10,14 +10,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for task finished events
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class TaskFinishedEventArgs : BuildStatusEventArgs
     {
diff --git a/src/Framework/TaskStartedEventArgs.cs b/src/Framework/TaskStartedEventArgs.cs
index 7f9c63b3338..039ef4b2b81 100644
--- a/src/Framework/TaskStartedEventArgs.cs
+++ b/src/Framework/TaskStartedEventArgs.cs
@@ -10,14 +10,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for task started events
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class TaskStartedEventArgs : BuildStatusEventArgs
     {
diff --git a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
index 3001ac1018d..dd786dfbed2 100644
--- a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
+++ b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
@@ -45,10 +45,10 @@
   </ItemGroup>
 
   <!-- Use deps file from this project with additional dependencies listed instead of the one generated in the MSBuild project -->
-  <Target Name="UpdateMSBuildDepsFile" AfterTargets="Build" Condition="'$(TargetFramework)' == 'netcoreapp2.1' or '$(TargetFramework)' == 'netstandard2.0'">
+  <Target Name="UpdateMSBuildDepsFile" AfterTargets="Build" Condition="'$(MonoBuild)' != 'true' and ($([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'netcoreapp2.1')) or '$(TargetFramework)' == 'netstandard2.0')">
     <Copy SourceFiles="$(OutputPath)$(AssemblyName).deps.json" DestinationFiles="$(OutputPath)MSBuild.deps.json" />
   </Target>
-  <Target Name="UpdatePublishedMSBuildDepsFile" AfterTargets="Publish" Condition="'$(TargetFramework)' == 'netcoreapp2.1'">
+  <Target Name="UpdatePublishedMSBuildDepsFile" AfterTargets="Publish" Condition="'$(TargetFramework)' == 'net5.0'">
     <Copy SourceFiles="$(PublishDir)$(AssemblyName).deps.json" DestinationFiles="$(PublishDir)MSBuild.deps.json" />
   </Target>
 
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index 5fee06a9d1e..c0d09628fe3 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -11,6 +11,7 @@
 using Microsoft.Build.CommandLine;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Graph;
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
@@ -448,7 +449,7 @@ public void TargetsSwitchIdentificationTests(string @switch)
         public void TargetsSwitchParameter()
         {
             CommandLineSwitches switches = new CommandLineSwitches();
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList() { "/targets:targets.txt" }, switches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string>() { "/targets:targets.txt" }, switches);
 
             switches.HaveErrors().ShouldBeFalse();
             switches[CommandLineSwitches.ParameterizedSwitch.Targets].ShouldBe(new[] { "targets.txt" });
@@ -458,7 +459,7 @@ public void TargetsSwitchParameter()
         public void TargetsSwitchDoesNotSupportMultipleOccurrences()
         {
             CommandLineSwitches switches = new CommandLineSwitches();
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList() { "/targets /targets" }, switches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string>() { "/targets /targets" }, switches);
 
             switches.HaveErrors().ShouldBeTrue();
         }
@@ -503,7 +504,7 @@ public void GraphBuildSwitchIdentificationTests(string graph)
             CommandLineSwitches.IsParameterizedSwitch(graph, out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed).ShouldBeTrue();
             parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.GraphBuild);
             duplicateSwitchErrorMessage.ShouldBeNull();
-            multipleParametersAllowed.ShouldBeFalse();
+            multipleParametersAllowed.ShouldBeTrue();
             missingParametersErrorMessage.ShouldBeNull();
             unquoteParameters.ShouldBeTrue();
             emptyParametersAllowed.ShouldBeFalse();
@@ -531,13 +532,36 @@ public void LowPrioritySwitchIdentificationTests(string lowpriority)
             emptyParametersAllowed.ShouldBeFalse();
         }
 
+        [Fact]
+        public void GraphBuildSwitchCanHaveParameters()
+        {
+            CommandLineSwitches switches = new CommandLineSwitches();
+
+            MSBuildApp.GatherCommandLineSwitches(new List<string>{ "/graph", "/graph:true;  NoBuild  ;;  ;", "/graph:foo"}, switches);
+
+            switches[CommandLineSwitches.ParameterizedSwitch.GraphBuild].ShouldBe(new[] {"true", "  NoBuild  ", "  ", "foo"});
+
+            switches.HaveErrors().ShouldBeFalse();
+        }
+
+        [Fact]
+        public void GraphBuildSwitchCanBeParameterless()
+        {
+            CommandLineSwitches switches = new CommandLineSwitches();
+
+            MSBuildApp.GatherCommandLineSwitches(new List<string>{ "/graph" }, switches);
+
+            switches[CommandLineSwitches.ParameterizedSwitch.GraphBuild].ShouldBe(new string[0]);
+
+            switches.HaveErrors().ShouldBeFalse();
+        }
 
         [Fact]
         public void InputResultsCachesSupportsMultipleOccurrence()
         {
             CommandLineSwitches switches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList(){"/irc", "/irc:a;b", "/irc:c;d"}, switches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(){"/irc", "/irc:a;b", "/irc:c;d"}, switches);
 
             switches[CommandLineSwitches.ParameterizedSwitch.InputResultsCaches].ShouldBe(new []{null, "a", "b", "c", "d"});
 
@@ -549,7 +573,7 @@ public void OutputResultsCache()
         {
             CommandLineSwitches switches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList(){"/orc:a"}, switches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(){"/orc:a"}, switches);
 
             switches[CommandLineSwitches.ParameterizedSwitch.OutputResultsCache].ShouldBe(new []{"a"});
 
@@ -561,7 +585,7 @@ public void OutputResultsCachesDoesNotSupportMultipleOccurrences()
         {
             CommandLineSwitches switches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList(){"/orc:a", "/orc:b"}, switches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(){"/orc:a", "/orc:b"}, switches);
 
             switches.HaveErrors().ShouldBeTrue();
         }
@@ -967,7 +991,7 @@ public void InvalidToolsVersionErrors()
                                         enableProfiler: false,
                                         interactive: false,
                                         isolateProjects: false,
-                                        graphBuild: false,
+                                        graphBuildOptions: null,
                                         lowPriority: false,
                                         inputResultsCaches: null,
                                         outputResultsCache: null
@@ -1041,7 +1065,7 @@ public void ProcessWarnAsErrorSwitchNotSpecified()
         {
             CommandLineSwitches commandLineSwitches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList(new[] { "" }), commandLineSwitches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(new[] { "" }), commandLineSwitches);
 
             Assert.Null(MSBuildApp.ProcessWarnAsErrorSwitch(commandLineSwitches));
         }
@@ -1056,7 +1080,7 @@ public void ProcessWarnAsErrorSwitchWithCodes()
 
             CommandLineSwitches commandLineSwitches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList(new[]
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(new[]
             {
                 "\"/warnaserror: a,B ; c \"", // Leading, trailing, leading and trailing whitespace
                 "/warnaserror:A,b,C",         // Repeats of different case
@@ -1081,7 +1105,7 @@ public void ProcessWarnAsErrorSwitchEmptySwitchClearsSet()
         {
             CommandLineSwitches commandLineSwitches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList(new[]
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(new[]
             {
                 "/warnaserror:a;b;c",
                 "/warnaserror",
@@ -1104,7 +1128,7 @@ public void ProcessWarnAsErrorSwitchValuesAfterEmptyAddOn()
 
             CommandLineSwitches commandLineSwitches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList(new[]
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(new[]
             {
                 "/warnaserror:a;b;c",
                 "/warnaserror",
@@ -1126,7 +1150,7 @@ public void ProcessWarnAsErrorSwitchEmpty()
         {
             CommandLineSwitches commandLineSwitches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList(new [] { "/warnaserror" }), commandLineSwitches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(new [] { "/warnaserror" }), commandLineSwitches);
 
             ISet<string> actualWarningsAsErrors = MSBuildApp.ProcessWarnAsErrorSwitch(commandLineSwitches);
 
@@ -1143,7 +1167,7 @@ public void ProcessWarnAsMessageSwitchEmpty()
         {
             CommandLineSwitches commandLineSwitches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList(new[] { "/warnasmessage" }), commandLineSwitches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(new[] { "/warnasmessage" }), commandLineSwitches);
 
             VerifySwitchError(commandLineSwitches, "/warnasmessage", AssemblyResources.GetString("MissingWarnAsMessageParameterError"));
         }
@@ -1158,7 +1182,7 @@ public void ProcessWarnAsMessageSwitchWithCodes()
 
             CommandLineSwitches commandLineSwitches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList(new[]
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(new[]
             {
                 "\"/warnasmessage: a,B ; c \"", // Leading, trailing, leading and trailing whitespace
                 "/warnasmessage:A,b,C",         // Repeats of different case
@@ -1183,7 +1207,7 @@ public void ProcessProfileEvaluationEmpty()
         {
             CommandLineSwitches commandLineSwitches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList(new[] { "/profileevaluation" }), commandLineSwitches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(new[] { "/profileevaluation" }), commandLineSwitches);
             commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ProfileEvaluation][0].ShouldBe("no-file");
         }
 
@@ -1201,6 +1225,67 @@ public void ProcessBooleanSwitchTest()
             Should.Throw<CommandLineSwitchException>(() => MSBuildApp.ProcessBooleanSwitch(new[] { "invalid" }, defaultValue: true, resourceName: "InvalidRestoreValue"));
         }
 
+        public static IEnumerable<object[]> ProcessGraphBuildSwitchData()
+        {
+            var emptyOptions = new GraphBuildOptions();
+            var noBuildOptions = new GraphBuildOptions {Build = false};
+
+            yield return new object[] {new string[0], emptyOptions, null};
+
+            yield return new object[] {new[] {"true"}, emptyOptions, null};
+
+            yield return new object[] {new[] {"false"}, null, null};
+
+            yield return new object[] {new[] {"  ", "  "}, emptyOptions, null};
+
+            yield return new object[] {new[] {"NoBuild"}, noBuildOptions, null};
+
+            yield return new object[] {new[] {"noBUILD"}, noBuildOptions, null};
+
+            yield return new object[] {new[] {"noBUILD     "}, noBuildOptions, null};
+
+            yield return new object[] {new[] {"false", "true"}, null, new[] {"false"}};
+
+            yield return new object[] {new[] {"nobuild", "true"}, noBuildOptions, new[] {"true"}};
+
+            yield return new object[] {new[] { "false", "nobuild" }, null, new[] {"false"}};
+
+            yield return new object[] {new[] {"nobuild", "invalid"}, null, new[] {"invalid"}};
+        }
+
+        [Theory]
+        [MemberData(nameof(ProcessGraphBuildSwitchData))]
+        public void ProcessGraphBuildSwitch(string[] parameters, GraphBuildOptions expectedOptions, string[] expectedWordsInException)
+        {
+            CommandLineSwitchException exception = null;
+
+            try
+            {
+                var graphBuildOptions = MSBuildApp.ProcessGraphBuildSwitch(parameters);
+                graphBuildOptions.ShouldBe(expectedOptions);
+            }
+            catch (CommandLineSwitchException e)
+            {
+                exception = e;
+            }
+
+            if (expectedWordsInException != null)
+            {
+                exception.ShouldNotBeNull();
+
+                exception.Message.ShouldContain("Graph build value is not valid");
+
+                foreach (var expectedWord in expectedWordsInException)
+                {
+                    exception.Message.ShouldContain(expectedWord);
+                }
+            }
+            else
+            {
+                exception.ShouldBeNull();
+            }
+        }
+
         /// <summary>
         /// Verifies that when the /profileevaluation switch is used with invalid filenames an error is shown.
         /// </summary>
@@ -1211,7 +1296,7 @@ public void ProcessProfileEvaluationInvalidFilename(string filename)
         {
             bool enableProfiler = false;
             Should.Throw(
-                () => MSBuildApp.ProcessProfileEvaluationSwitch(new[] {filename}, new ArrayList(), out enableProfiler),
+                () => MSBuildApp.ProcessProfileEvaluationSwitch(new[] {filename}, new List<ILogger>(), out enableProfiler),
                 typeof(CommandLineSwitchException));
         }
 
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 06997104d73..630890e9085 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -44,7 +44,7 @@ public void GatherCommandLineSwitchesTwoProperties()
         {
             CommandLineSwitches switches = new CommandLineSwitches();
 
-            ArrayList arguments = new ArrayList();
+            var arguments = new List<string>();
             arguments.AddRange(new string[] { "/p:a=b", "/p:c=d" });
 
             MSBuildApp.GatherCommandLineSwitches(arguments, switches);
@@ -59,7 +59,7 @@ public void GatherCommandLineSwitchesMaxCpuCountWithArgument()
         {
             CommandLineSwitches switches = new CommandLineSwitches();
 
-            ArrayList arguments = new ArrayList();
+            var arguments = new List<string>();
             arguments.AddRange(new string[] { "/m:2" });
 
             MSBuildApp.GatherCommandLineSwitches(arguments, switches);
@@ -76,13 +76,13 @@ public void GatherCommandLineSwitchesMaxCpuCountWithoutArgument()
         {
             CommandLineSwitches switches = new CommandLineSwitches();
 
-            ArrayList arguments = new ArrayList();
+            var arguments = new List<string>();
             arguments.AddRange(new string[] { "/m:3", "/m" });
 
             MSBuildApp.GatherCommandLineSwitches(arguments, switches);
 
             string[] parameters = switches[CommandLineSwitches.ParameterizedSwitch.MaxCPUCount];
-            parameters[1].ShouldBe(Convert.ToString(Environment.ProcessorCount));
+            parameters[1].ShouldBe(Convert.ToString(NativeMethodsShared.GetLogicalCoreCount()));
             parameters.Length.ShouldBe(2);
 
             switches.HaveErrors().ShouldBeFalse();
@@ -96,7 +96,7 @@ public void GatherCommandLineSwitchesMaxCpuCountWithoutArgumentButWithColon()
         {
             CommandLineSwitches switches = new CommandLineSwitches();
 
-            ArrayList arguments = new ArrayList();
+            var arguments = new List<string>();
             arguments.AddRange(new string[] { "/m:" });
 
             MSBuildApp.GatherCommandLineSwitches(arguments, switches);
@@ -137,7 +137,7 @@ public void GatherCommandLineSwitchesMaxCpuCountWithoutArgumentButWithColon()
         [Fact]
         public void SplitUnquotedTest()
         {
-            ArrayList sa;
+            List<string> sa;
             int emptySplits;
 
             // nothing quoted
@@ -586,7 +586,7 @@ public void SetConsoleUICulture()
             MSBuildApp.SetConsoleUI();
 
             // Make sure this doesn't throw an exception.
-            string bar = String.Format(CultureInfo.CurrentUICulture, "{0}", (int)1);
+            string bar = String.Format(CultureInfo.CurrentUICulture, "{0}", 1);
 
             // Restore the current UI culture back to the way it was at the beginning of this unit test.
             thisThread.CurrentUICulture = originalUICulture;
@@ -1329,7 +1329,7 @@ public void TestTwoIdenticalExtensionsToIgnore()
         public void TestProcessProjectSwitchNullandEmptyProjectsToIgnore()
         {
             string[] projects = new string[] { "my.proj" };
-            string[] extensionsToIgnore = (string[])null;
+            string[] extensionsToIgnore = null;
             IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
             MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
 
@@ -1697,7 +1697,7 @@ public void TestProcessFileLoggerSwitch1()
             string[] fileLoggerParameters = null;
             List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
-            ArrayList loggers = new ArrayList();
+            var loggers = new List<ILogger>();
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1720,7 +1720,7 @@ public void TestProcessFileLoggerSwitch2()
             string[] fileLoggerParameters = null;
             List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
-            ArrayList loggers = new ArrayList();
+            var loggers = new List<ILogger>();
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1743,7 +1743,7 @@ public void TestProcessFileLoggerSwitch3()
             string[] fileLoggerParameters = null;
             List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
-            ArrayList loggers = new ArrayList();
+            var loggers = new List<ILogger>();
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1758,7 +1758,7 @@ public void TestProcessFileLoggerSwitch3()
             // add a set of parameters and make sure the logger has those parameters
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
-            loggers = new ArrayList();
+            loggers = new List<ILogger>();
             fileLoggerParameters = new string[1] { "Parameter" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
@@ -1773,7 +1773,7 @@ public void TestProcessFileLoggerSwitch3()
 
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
-            loggers = new ArrayList();
+            loggers = new List<ILogger>();
             fileLoggerParameters = new string[2] { "Parameter1", "Parameter" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
@@ -1797,7 +1797,7 @@ public void TestProcessFileLoggerSwitch4()
             string[] fileLoggerParameters = null;
             List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
-            ArrayList loggers = new ArrayList();
+            var loggers = new List<ILogger>();
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1813,7 +1813,7 @@ public void TestProcessFileLoggerSwitch4()
             // Not add a set of parameters and make sure the logger has those parameters
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
-            loggers = new ArrayList();
+            loggers = new List<ILogger>();
             fileLoggerParameters = new string[1] { "verbosity=Normal;" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
@@ -1830,7 +1830,7 @@ public void TestProcessFileLoggerSwitch4()
             // Not add a set of parameters and make sure the logger has those parameters
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
-            loggers = new ArrayList();
+            loggers = new List<ILogger>();
             fileLoggerParameters = new string[2] { "verbosity=Normal", "" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
@@ -1847,7 +1847,7 @@ public void TestProcessFileLoggerSwitch4()
             // Not add a set of parameters and make sure the logger has those parameters
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
-            loggers = new ArrayList();
+            loggers = new List<ILogger>();
             fileLoggerParameters = new string[2] { "", "Parameter1" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
@@ -1864,7 +1864,7 @@ public void TestProcessFileLoggerSwitch4()
             // Not add a set of parameters and make sure the logger has those parameters
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
-            loggers = new ArrayList();
+            loggers = new List<ILogger>();
             fileLoggerParameters = new string[2] { "Parameter1", "verbosity=Normal;logfile=" + (NativeMethodsShared.IsWindows ? "c:\\temp\\cat.log" : "/tmp/cat.log") };
             MSBuildApp.ProcessDistributedFileLogger
                        (
@@ -1879,7 +1879,7 @@ public void TestProcessFileLoggerSwitch4()
             distributedLoggerRecords[0].ForwardingLoggerDescription.LoggerSwitchParameters.ShouldBe(fileLoggerParameters[0] + ";" + fileLoggerParameters[1], StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameter passed in"
 
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
-            loggers = new ArrayList();
+            loggers = new List<ILogger>();
             fileLoggerParameters = new string[2] { "Parameter1", "verbosity=Normal;logfile=" + Path.Combine("..", "cat.log") + ";Parameter1" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
@@ -1893,7 +1893,7 @@ public void TestProcessFileLoggerSwitch4()
             distributedLoggerRecords.Count.ShouldBe(1); // "Expected a distributed logger to be attached"
             distributedLoggerRecords[0].ForwardingLoggerDescription.LoggerSwitchParameters.ShouldBe($"Parameter1;verbosity=Normal;logFile={Path.Combine(Directory.GetCurrentDirectory(), "..", "cat.log")};Parameter1", StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameter passed in"
 
-            loggers = new ArrayList();
+            loggers = new List<ILogger>();
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
             fileLoggerParameters = new string[6] { "Parameter1", ";Parameter;", "", ";", ";Parameter", "Parameter;" };
             MSBuildApp.ProcessDistributedFileLogger
@@ -1917,7 +1917,7 @@ public void TestProcessFileLoggerSwitch5()
             string[] fileLoggerParameters = null;
             List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
-            ArrayList loggers = new ArrayList();
+            var loggers = new List<ILogger>();
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1935,7 +1935,7 @@ public void TestProcessFileLoggerSwitch5()
         [Fact]
         public void ProcessConsoleLoggerSwitches()
         {
-            ArrayList loggers = new ArrayList();
+            var loggers = new List<ILogger>();
             LoggerVerbosity verbosity = LoggerVerbosity.Normal;
             List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>(); 
             string[] consoleLoggerParameters = new string[6] { "Parameter1", ";Parameter;", "", ";", ";Parameter", "Parameter;" };
@@ -1962,7 +1962,7 @@ public void ProcessConsoleLoggerSwitches()
                            loggers
                        );
             loggers.Count.ShouldBe(1); // "Expected a central loggers to be attached"
-            ((ILogger)loggers[0]).Parameters.ShouldBe("EnableMPLogging;SHOWPROJECTFILE=TRUE;Parameter1;Parameter;;;parameter;Parameter", StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameters passed in"
+            loggers[0].Parameters.ShouldBe("EnableMPLogging;SHOWPROJECTFILE=TRUE;Parameter1;Parameter;;;parameter;Parameter", StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameters passed in"
 
             MSBuildApp.ProcessConsoleLoggerSwitch
                        (
@@ -1975,7 +1975,7 @@ public void ProcessConsoleLoggerSwitches()
                       );
             loggers.Count.ShouldBe(1); // "Expected a central loggers to be attached"
             distributedLoggerRecords.Count.ShouldBe(1); // "Expected a distributed logger to be attached"
-            DistributedLoggerRecord distributedLogger = ((DistributedLoggerRecord)distributedLoggerRecords[0]);
+            DistributedLoggerRecord distributedLogger = distributedLoggerRecords[0];
             distributedLogger.CentralLogger.Parameters.ShouldBe("SHOWPROJECTFILE=TRUE;Parameter1;Parameter;;;parameter;Parameter", StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameters passed in"
             distributedLogger.ForwardingLoggerDescription.LoggerSwitchParameters.ShouldBe("SHOWPROJECTFILE=TRUE;Parameter1;Parameter;;;Parameter;Parameter", StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameter passed in"
         }
@@ -2215,6 +2215,26 @@ public void BinaryLogContainsImportedFiles()
             }
         }
 
+        [Fact]
+        public void EndToEndWarnAsErrors()
+        {
+            using TestEnvironment testEnvironment = UnitTests.TestEnvironment.Create();
+
+            string projectContents = ObjectModelHelpers.CleanupFileContents(@"<Project>
+
+  <Target Name=""IssueWarning"">
+    <Warning Text=""Warning!"" />
+  </Target>
+  
+</Project>");
+
+            TransientTestProjectWithFiles testProject = testEnvironment.CreateTestProjectWithFiles(projectContents);
+
+            RunnerUtilities.ExecMSBuild($"\"{testProject.ProjectFile}\" -warnaserror", out bool success, _output);
+
+            success.ShouldBeFalse();
+        }
+
 #if FEATURE_ASSEMBLYLOADCONTEXT
         /// <summary>
         /// Ensure that tasks get loaded into their own <see cref="System.Runtime.Loader.AssemblyLoadContext"/>.
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index c8b2ed78726..9e6eb9fd49c 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -269,7 +269,7 @@ bool emptyParametersAllowed
             new ParameterizedSwitchInfo(  new string[] { "restoreproperty", "rp" },             ParameterizedSwitch.RestoreProperty,            null,                           true,           "MissingRestorePropertyError",         true,   false  ),
             new ParameterizedSwitchInfo(  new string[] { "interactive" },                       ParameterizedSwitch.Interactive,                null,                           false,          null,                                  true,   false  ),
             new ParameterizedSwitchInfo(  new string[] { "isolateprojects", "isolate" },        ParameterizedSwitch.IsolateProjects,            null,                           false,          null,                                  true,   false  ),
-            new ParameterizedSwitchInfo(  new string[] { "graphbuild", "graph" },               ParameterizedSwitch.GraphBuild,                 null,                           false,          null,                                  true,   false  ),
+            new ParameterizedSwitchInfo(  new string[] { "graphbuild", "graph" },               ParameterizedSwitch.GraphBuild,                 null,                           true,          null,                                  true,   false  ),
             new ParameterizedSwitchInfo(  new string[] { "inputResultsCaches", "irc" },         ParameterizedSwitch.InputResultsCaches,         null,                           true,           null,                                  true,   true   ),
             new ParameterizedSwitchInfo(  new string[] { "outputResultsCache", "orc" },         ParameterizedSwitch.OutputResultsCache,         "DuplicateOutputResultsCache",  false,          null,                                  true,   true   ),
             new ParameterizedSwitchInfo(  new string[] { "lowpriority", "low" },                ParameterizedSwitch.LowPriority,                null,                           false,          null,                                  true,   false  ),
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index a6f0873dac4..7d990720a96 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -7,6 +7,9 @@
     <OutputType>Exe</OutputType>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
+    <!-- MSBuild.csproj no longer uses apphost. This fixes an issue where certain tests would find
+         MSBuild.exe AND MSBuild.dll when they should only find MSBuild.dll. -->
+    <UseAppHost>false</UseAppHost>
 
     <!-- Set RuntimeIdentifiers so that NuGet will restore for both AnyCPU as well as x86 and x64.
          This is important for the MSBuild.VSSetup project, which "references" both the x86 and x64
@@ -130,10 +133,6 @@
     <Compile Include="..\Shared\BinaryTranslator.cs" />
     <Compile Include="..\Shared\CommunicationsUtilities.cs" />
     <Compile Include="..\Shared\InterningBinaryReader.cs" />
-    <Compile Include="..\Shared\IInternable.cs" />
-    <Compile Include="..\Shared\WeakStringCache.cs" />
-    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs" />
-    <Compile Include="..\Shared\OpportunisticIntern.cs" />
     <Compile Include="..\Shared\TaskHostConfiguration.cs" />
     <Compile Include="..\Shared\TaskHostTaskComplete.cs" />
     <Compile Include="..\Shared\OutOfProcTaskHostTaskResult.cs" />
@@ -198,7 +197,6 @@
     <Compile Include="XMake.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <None Include="project.json" />
     <!-- This is to enable CodeMarkers in MSBuild.exe -->
     <!-- Win32 RC Files -->
     <RCResourceFile Include="native.rc" />
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 3484f2cacaa..5f2b1ab2330 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -1172,7 +1172,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </comment>
   </data>
   <data name="InvalidGraphBuildValue" UESanitized="true" Visibility="Public">
-    <value>MSBUILD : error MSB1057: Graph build value is not valid. {0}</value>
+    <value>MSBUILD : error MSB1057: Graph build value is not valid.</value>
     <comment>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index d3242d73401..ea203edd619 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -963,8 +963,8 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: Hodnota sestavení grafu není platná. {0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index b12875ea503..dfbf6409b2d 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -955,8 +955,8 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: Der Wert für die Diagrammerstellung ist nicht gültig. {0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.en.xlf b/src/MSBuild/Resources/xlf/Strings.en.xlf
index a866ad64681..813d56eb252 100644
--- a/src/MSBuild/Resources/xlf/Strings.en.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.en.xlf
@@ -1144,8 +1144,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid. {0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 84dfcc76473..be5821b7ddb 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -964,8 +964,8 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: El valor de compilación del grafo no es válido. {0}.</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index bc5d0cab144..1e9052ab0ec 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -956,8 +956,8 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: La valeur de build du graphe n'est pas valide. {0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 792c30f845e..3576dee6f26 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -976,8 +976,8 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: il valore di graphBuild non è valido. {0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index c4340920b51..d64a16c977d 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -955,8 +955,8 @@ Copyright (C) Microsoft Corporation.All rights reserved.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: Graph build 値が無効です。{0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 54603d31f2f..b627ff1eef4 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -955,8 +955,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: 그래프 빌드 값이 유효하지 않습니다. {0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index aff42990b9e..8f1ee8b37b8 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -968,8 +968,8 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: Wartość kompilacji grafu jest nieprawidłowa. {0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index e406782e4b3..5d4dd910080 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -956,8 +956,8 @@ isoladamente.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: O valor de build do gráfico não é válido. {0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index f735d35d2be..b04ff45fb56 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -955,8 +955,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: значение сборки графа является недопустимым. {0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index aac67729919..73a7f281be0 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -959,8 +959,8 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: Grafik derleme değeri geçerli değil. {0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index e44b94a0e59..dcc8024c787 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -955,8 +955,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: 关系图生成值无效。{0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 0d183976b13..0e54b0e7198 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -955,8 +955,8 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: 圖形組建值無效。{0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index d9d4839ebcb..7891c7923dd 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.ComponentModel;
 #if FEATURE_SYSTEM_CONFIGURATION
@@ -48,7 +47,7 @@ namespace Microsoft.Build.CommandLine
     /// This class implements the MSBuild.exe command-line application. It processes
     /// command-line arguments and invokes the build engine.
     /// </summary>
-    static public class MSBuildApp
+    public static class MSBuildApp
     {
         /// <summary>
         /// Enumeration of the various ways in which the MSBuild.exe application can exit.
@@ -95,7 +94,7 @@ public enum ExitType
         /// <summary>
         /// The object used to synchronize access to shared build state
         /// </summary>
-        private static Object s_buildLock = new Object();
+        private static readonly object s_buildLock = new object();
 
         /// <summary>
         /// Whether a build has started.
@@ -103,19 +102,19 @@ public enum ExitType
         private static bool s_hasBuildStarted;
 
         /// <summary>
-        /// Event signalled when the build is complete.
+        /// Event signaled when the build is complete.
         /// </summary>
-        private static ManualResetEvent s_buildComplete = new ManualResetEvent(false);
+        private static readonly ManualResetEvent s_buildComplete = new ManualResetEvent(false);
 
         /// <summary>
-        /// Event signalled when the cancel method is complete.
+        /// Event signaled when the cancel method is complete.
         /// </summary>
-        private static ManualResetEvent s_cancelComplete = new ManualResetEvent(true);
+        private static readonly ManualResetEvent s_cancelComplete = new ManualResetEvent(true);
 
         /// <summary>
         /// Cancel when handling Ctrl-C
         /// </summary>
-        private static CancellationTokenSource s_buildCancellationSource = new CancellationTokenSource();
+        private static readonly CancellationTokenSource s_buildCancellationSource = new CancellationTokenSource();
 
         private static readonly char[] s_commaSemicolon = { ',', ';' };
 
@@ -212,29 +211,28 @@ string [] args
 #endif
             )
         {
-            using (PerformanceLogEventListener eventListener = PerformanceLogEventListener.Create())
+            using PerformanceLogEventListener eventListener = PerformanceLogEventListener.Create();
+
+            if (Environment.GetEnvironmentVariable("MSBUILDDUMPPROCESSCOUNTERS") == "1")
             {
-                if (Environment.GetEnvironmentVariable("MSBUILDDUMPPROCESSCOUNTERS") == "1")
-                {
-                    DumpCounters(true /* initialize only */);
-                }
+                DumpCounters(true /* initialize only */);
+            }
 
-                // return 0 on success, non-zero on failure
-                int exitCode = ((s_initialized && Execute(
+            // return 0 on success, non-zero on failure
+            int exitCode = ((s_initialized && Execute(
 #if FEATURE_GET_COMMANDLINE
                 Environment.CommandLine
 #else
                 ConstructArrayArg(args)
 #endif
-                ) == ExitType.Success) ? 0 : 1);
-
-                if (Environment.GetEnvironmentVariable("MSBUILDDUMPPROCESSCOUNTERS") == "1")
-                {
-                    DumpCounters(false /* log to console */);
-                }
+            ) == ExitType.Success) ? 0 : 1);
 
-                return exitCode;
+            if (Environment.GetEnvironmentVariable("MSBUILDDUMPPROCESSCOUNTERS") == "1")
+            {
+                DumpCounters(false /* log to console */);
             }
+
+            return exitCode;
         }
 
 #if !FEATURE_GET_COMMANDLINE
@@ -260,21 +258,17 @@ private static string[] ConstructArrayArg(string[] args)
         /// <comments>
         /// This is a non-supported feature to facilitate timing multiple runs
         /// </comments>
-        static private void AppendOutputFile(string path, Int64 elapsedTime)
+        private static void AppendOutputFile(string path, long elapsedTime)
         {
             if (!FileSystems.Default.FileExists(path))
             {
-                using (StreamWriter sw = File.CreateText(path))
-                {
-                    sw.WriteLine(elapsedTime);
-                }
+                using StreamWriter sw = File.CreateText(path);
+                sw.WriteLine(elapsedTime);
             }
             else
             {
-                using (StreamWriter sw = File.AppendText(path))
-                {
-                    sw.WriteLine(elapsedTime);
-                }
+                using StreamWriter sw = File.AppendText(path);
+                sw.WriteLine(elapsedTime);
             }
         }
 
@@ -296,7 +290,7 @@ private static void DumpCounters(bool initializeOnly)
 
             if (!initializeOnly)
             {
-                Console.WriteLine("\n{0}{1}{0}", new String('=', 41 - ("Process".Length / 2)), "Process");
+                Console.WriteLine("\n{0}{1}{0}", new string('=', 41 - ("Process".Length / 2)), "Process");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Peak Working Set", currentProcess.PeakWorkingSet64, "bytes");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Peak Paged Memory", currentProcess.PeakPagedMemorySize64, "bytes"); // Not very useful one
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Peak Virtual Memory", currentProcess.PeakVirtualMemorySize64, "bytes"); // Not very useful one
@@ -304,7 +298,7 @@ private static void DumpCounters(bool initializeOnly)
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Peak User Processor Time", currentProcess.UserProcessorTime.TotalMilliseconds, "ms");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Peak Total Processor Time", currentProcess.TotalProcessorTime.TotalMilliseconds, "ms");
 
-                Console.WriteLine("{0}{0}", new String('=', 41));
+                Console.WriteLine("{0}{0}", new string('=', 41));
             }
 
 #if FEATURE_PERFORMANCE_COUNTERS
@@ -319,20 +313,18 @@ private static void DumpCounters(bool initializeOnly)
             PerformanceCounterCategory processCategory = new PerformanceCounterCategory("Process");
             foreach (string instance in processCategory.GetInstanceNames())
             {
-                using (PerformanceCounter counter = new PerformanceCounter(".NET CLR Memory", "Process ID", instance, true))
+                using PerformanceCounter counter = new PerformanceCounter(".NET CLR Memory", "Process ID", instance, true);
+                try
                 {
-                    try
-                    {
-                        if ((int)counter.RawValue == currentProcess.Id)
-                        {
-                            currentInstance = instance;
-                            break;
-                        }
-                    }
-                    catch (InvalidOperationException) // Instance 'WmiApSrv' does not exist in the specified Category. (??)
+                    if ((int)counter.RawValue == currentProcess.Id)
                     {
+                        currentInstance = instance;
+                        break;
                     }
                 }
+                catch (InvalidOperationException) // Instance 'WmiApSrv' does not exist in the specified Category. (??)
+                {
+                }
             }
 
             foreach (PerformanceCounterCategory category in PerformanceCounterCategory.GetCategories())
@@ -366,7 +358,7 @@ private static void DumpAllInCategory(string currentInstance, PerformanceCounter
 
             if (!initializeOnly)
             {
-                Console.WriteLine("\n{0}{1}{0}", new String('=', 41 - (category.CategoryName.Length / 2)), category.CategoryName);
+                Console.WriteLine("\n{0}{1}{0}", new string('=', 41 - (category.CategoryName.Length / 2)), category.CategoryName);
             }
 
             foreach (PerformanceCounter counter in counters)
@@ -376,7 +368,7 @@ private static void DumpAllInCategory(string currentInstance, PerformanceCounter
 
             if (!initializeOnly)
             {
-                Console.WriteLine("{0}{0}", new String('=', 41));
+                Console.WriteLine("{0}{0}", new string('=', 41));
             }
         }
 
@@ -403,7 +395,7 @@ private static void DumpCounter(PerformanceCounter counter, bool initializeOnly)
                     // Show decimal places if meaningful
                     string valueFormat = value < 10 ? "{0,20:N2}" : "{0,20:N0}";
 
-                    string valueString = String.Format(CultureInfo.CurrentCulture, valueFormat, value);
+                    string valueString = string.Format(CultureInfo.CurrentCulture, valueFormat, value);
 
                     Console.WriteLine("||{0,50}|{1}|{2,8}|", counter.CounterName, valueString, friendlyCounterType);
                 }
@@ -571,14 +563,12 @@ string [] commandLine
                 bool enableProfiler = false;
                 bool interactive = false;
                 bool isolateProjects = false;
-                bool graphBuild = false;
+                GraphBuildOptions graphBuildOptions = null;
                 bool lowPriority = false;
                 string[] inputResultsCaches = null;
                 string outputResultsCache = null;
 
-                CommandLineSwitches switchesFromAutoResponseFile;
-                CommandLineSwitches switchesNotFromAutoResponseFile;
-                GatherAllSwitches(commandLine, out switchesFromAutoResponseFile, out switchesNotFromAutoResponseFile);
+                GatherAllSwitches(commandLine, out var switchesFromAutoResponseFile, out var switchesNotFromAutoResponseFile);
 
                 if (ProcessCommandLineSwitches(
                         switchesFromAutoResponseFile,
@@ -607,7 +597,7 @@ string [] commandLine
                         ref enableProfiler,
                         ref restoreProperties,
                         ref isolateProjects,
-                        ref graphBuild,
+                        ref graphBuildOptions,
                         ref inputResultsCaches,
                         ref outputResultsCache,
                         ref lowPriority,
@@ -685,7 +675,7 @@ string [] commandLine
                                     enableProfiler,
                                     interactive,
                                     isolateProjects,
-                                    graphBuild,
+                                    graphBuildOptions,
                                     lowPriority,
                                     inputResultsCaches,
                                     outputResultsCache))
@@ -707,7 +697,7 @@ string [] commandLine
 
                     string timerOutputFilename = Environment.GetEnvironmentVariable("MSBUILDTIMEROUTPUTS");
 
-                    if (!String.IsNullOrEmpty(timerOutputFilename))
+                    if (!string.IsNullOrEmpty(timerOutputFilename))
                     {
                         AppendOutputFile(timerOutputFilename, (long)elapsedTime.TotalMilliseconds);
                     }
@@ -781,7 +771,7 @@ string [] commandLine
                 if (!e.InitializationException)
                 {
                     // display the localized message from the outer exception in canonical format
-                    Console.WriteLine("MSBUILD : error " + e.ErrorCode + ": " + e.Message);
+                    Console.WriteLine($"MSBUILD : error {e.ErrorCode}: {e.Message}");
 #if DEBUG
                     Console.WriteLine("This is an unhandled exception from a logger -- PLEASE OPEN A BUG AGAINST THE LOGGER OWNER.");
 #endif
@@ -793,15 +783,15 @@ string [] commandLine
                 }
                 else
                 {
-                    Console.WriteLine("MSBUILD : error " + e.ErrorCode + ": " + e.Message +
-                        (e.InnerException != null ? " " + e.InnerException.Message : ""));
+                    Console.WriteLine(
+                        $"MSBUILD : error {e.ErrorCode}: {e.Message}{(e.InnerException != null ? $" {e.InnerException.Message}" : "")}");
                     exitType = ExitType.InitializationError;
                 }
             }
             catch (BuildAbortedException e)
             {
-                Console.WriteLine("MSBUILD : error " + e.ErrorCode + ": " + e.Message +
-                                (e.InnerException != null ? " " + e.InnerException.Message : String.Empty));
+                Console.WriteLine(
+                    $"MSBUILD : error {e.ErrorCode}: {e.Message}{(e.InnerException != null ? $" {e.InnerException.Message}" : string.Empty)}");
 
                 exitType = ExitType.Unexpected;
             }
@@ -903,8 +893,7 @@ private static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs
             // by calling Microsoft.Win32.SystemEvents.Initialize.
             // So do our work asynchronously so we can return immediately.
             // We're already on a threadpool thread anyway.
-            WaitCallback callback = new WaitCallback(
-            delegate (Object state)
+            WaitCallback callback = delegate
             {
                 s_cancelComplete.Reset();
 
@@ -918,7 +907,7 @@ private static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs
                 // If the build has already started (or already finished), we will cancel it
                 // If the build has not yet started, it will cancel itself, because
                 // we set alreadyCalled=1
-                bool hasBuildStarted = false;
+                bool hasBuildStarted;
                 lock (s_buildLock)
                 {
                     hasBuildStarted = s_hasBuildStarted;
@@ -931,7 +920,7 @@ private static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs
                 }
 
                 s_cancelComplete.Set(); // This will release our main Execute method so we can finally exit.
-            });
+            };
 
             ThreadPoolExtensions.QueueThreadPoolWorkItemWithCulture(callback, CultureInfo.CurrentCulture, CultureInfo.CurrentUICulture);
         }
@@ -942,7 +931,7 @@ private static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs
         /// </summary>
         private static void ResetBuildState()
         {
-            s_includedResponseFiles = new ArrayList();
+            s_includedResponseFiles = new List<string>();
             usingSwitchesFromAutoResponseFile = false;
         }
 
@@ -995,7 +984,7 @@ internal static bool BuildProject
             bool enableProfiler,
             bool interactive,
             bool isolateProjects,
-            bool graphBuild,
+            GraphBuildOptions graphBuildOptions,
             bool lowPriority,
             string[] inputResultsCaches,
             string outputResultsCache
@@ -1068,16 +1057,13 @@ string outputResultsCache
                 {
                     foreach (var logger in distributedLoggerRecords)
                     {
-                        if (logger.CentralLogger != null)
+                        if (logger.CentralLogger?.Parameters != null &&
+                            (logger.CentralLogger.Parameters.IndexOf("V=DIAG", StringComparison.OrdinalIgnoreCase) != -1 ||
+                             logger.CentralLogger.Parameters.IndexOf("VERBOSITY=DIAG", StringComparison.OrdinalIgnoreCase) != -1)
+                        )
                         {
-                            if (logger.CentralLogger.Parameters != null &&
-                                (logger.CentralLogger.Parameters.IndexOf("V=DIAG", StringComparison.OrdinalIgnoreCase) != -1 ||
-                                 logger.CentralLogger.Parameters.IndexOf("VERBOSITY=DIAG", StringComparison.OrdinalIgnoreCase) != -1)
-                               )
-                            {
-                                logTaskInputs = true;
-                                break;
-                            }
+                            logTaskInputs = true;
+                            break;
                         }
                     }
                 }
@@ -1144,7 +1130,7 @@ string outputResultsCache
 
                     // By default we log synchronously to the console for compatibility with previous versions,
                     // but it is slightly slower
-                    if (!String.Equals(Environment.GetEnvironmentVariable("MSBUILDLOGASYNC"), "1", StringComparison.Ordinal))
+                    if (!string.Equals(Environment.GetEnvironmentVariable("MSBUILDLOGASYNC"), "1", StringComparison.Ordinal))
                     {
                         parameters.UseSynchronousLogging = true;
                     }
@@ -1176,13 +1162,13 @@ string outputResultsCache
                         parameters.ProjectLoadSettings |= ProjectLoadSettings.ProfileEvaluation;
                     }
 
-                    if (!String.IsNullOrEmpty(toolsVersion))
+                    if (!string.IsNullOrEmpty(toolsVersion))
                     {
                         parameters.DefaultToolsVersion = toolsVersion;
                     }
 
                     string memoryUseLimit = Environment.GetEnvironmentVariable("MSBUILDMEMORYUSELIMIT");
-                    if (!String.IsNullOrEmpty(memoryUseLimit))
+                    if (!string.IsNullOrEmpty(memoryUseLimit))
                     {
                         parameters.MemoryUseLimit = Convert.ToInt32(memoryUseLimit, CultureInfo.InvariantCulture);
 
@@ -1214,7 +1200,7 @@ string outputResultsCache
                         try
                         {
                             // Determine if the user specified /Target:Restore which means we should only execute a restore in the fancy way that /restore is executed
-                            bool restoreOnly = targets.Length == 1 && String.Equals(targets[0], MSBuildConstants.RestoreTargetName, StringComparison.OrdinalIgnoreCase);
+                            bool restoreOnly = targets.Length == 1 && string.Equals(targets[0], MSBuildConstants.RestoreTargetName, StringComparison.OrdinalIgnoreCase);
 
                             // ExecuteRestore below changes the current working directory and does not change back. Therefore, if we try to create the request after
                             // the restore call we end up with incorrectly normalized paths to the project. To avoid that, we are preparing the request before the first
@@ -1225,9 +1211,9 @@ string outputResultsCache
                             BuildRequestData buildRequest = null;
                             if (!restoreOnly)
                             {
-                                if (graphBuild)
+                                if (graphBuildOptions != null)
                                 {
-                                    graphBuildRequest = new GraphBuildRequestData(new ProjectGraphEntryPoint(projectFile, globalProperties), targets, null);
+                                    graphBuildRequest = new GraphBuildRequestData(new[]{ new ProjectGraphEntryPoint(projectFile, globalProperties) }, targets, null, BuildRequestDataFlags.None, graphBuildOptions);
                                 }
                                 else
                                 {
@@ -1247,7 +1233,7 @@ string outputResultsCache
 
                             if (!restoreOnly)
                             {
-                                if (graphBuild)
+                                if (graphBuildOptions != null)
                                 {
                                     (result, exception) = ExecuteGraphBuild(buildManager, graphBuildRequest);
                                 }
@@ -1616,11 +1602,11 @@ private static void GatherAllSwitches(
         {
 #if FEATURE_GET_COMMANDLINE
             // split the command line on (unquoted) whitespace
-            ArrayList commandLineArgs = QuotingUtilities.SplitUnquoted(commandLine);
+            var commandLineArgs = QuotingUtilities.SplitUnquoted(commandLine);
 
-            s_exeName = FileUtilities.FixFilePath(QuotingUtilities.Unquote((string)commandLineArgs[0]));
+            s_exeName = FileUtilities.FixFilePath(QuotingUtilities.Unquote(commandLineArgs[0]));
 #else
-            ArrayList commandLineArgs = new ArrayList(commandLine);
+            var commandLineArgs = new List<string>(commandLine);
 
             s_exeName = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
 #endif
@@ -1658,12 +1644,11 @@ private static void GatherAllSwitches(
         /// <remarks>
         /// Internal for unit testing only.
         /// </remarks>
-        internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, CommandLineSwitches commandLineSwitches)
+        internal static void GatherCommandLineSwitches(List<string> commandLineArgs, CommandLineSwitches commandLineSwitches)
         {
             foreach (string commandLineArg in commandLineArgs)
             {
-                int doubleQuotesRemovedFromArg;
-                string unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
+                string unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out var doubleQuotesRemovedFromArg);
 
                 if (unquotedCommandLineArg.Length > 0)
                 {
@@ -1682,7 +1667,7 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman
                         {
                             switchName = null;
                             // add a (fake) parameter indicator for later parsing
-                            switchParameters = ":" + commandLineArg;
+                            switchParameters = $":{commandLineArg}";
                         }
                         else
                         {
@@ -1698,7 +1683,7 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman
                             if (switchParameterIndicator == -1)
                             {
                                 switchName = unquotedCommandLineArg.Substring(switchIndicatorsLength);
-                                switchParameters = String.Empty;
+                                switchParameters = string.Empty;
                             }
                             else
                             {
@@ -1707,63 +1692,38 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman
                             }
                         }
 
-                        CommandLineSwitches.ParameterlessSwitch parameterlessSwitch;
-                        CommandLineSwitches.ParameterizedSwitch parameterizedSwitch;
-                        string duplicateSwitchErrorMessage;
-                        bool multipleParametersAllowed;
-                        string missingParametersErrorMessage;
-                        bool unquoteParameters;
-                        bool allowEmptyParameters;
-
                         // Special case: for the switches "/m" (or "/maxCpuCount") and "/bl" (or "/binarylogger") we wish to pretend we saw a default argument
                         // This allows a subsequent /m:n on the command line to override it.
                         // We could create a new kind of switch with optional parameters, but it's a great deal of churn for this single case. 
                         // Note that if no "/m" or "/maxCpuCount" switch -- either with or without parameters -- is present, then we still default to 1 cpu
                         // for backwards compatibility.
-                        if (String.IsNullOrEmpty(switchParameters))
+                        if (string.IsNullOrEmpty(switchParameters))
                         {
-                            if (String.Equals(switchName, "m", StringComparison.OrdinalIgnoreCase) ||
-                                String.Equals(switchName, "maxcpucount", StringComparison.OrdinalIgnoreCase))
+                            if (string.Equals(switchName, "m", StringComparison.OrdinalIgnoreCase) ||
+                                string.Equals(switchName, "maxcpucount", StringComparison.OrdinalIgnoreCase))
                             {
-                                int numberOfCpus = Environment.ProcessorCount;
-#if !MONO
-                                // .NET Core on Windows returns a core count limited to the current NUMA node
-                                //     https://github.com/dotnet/runtime/issues/29686
-                                // so always double-check it.
-                                if (NativeMethodsShared.IsWindows && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_8)
-#if NETFRAMEWORK
-                                     // .NET Framework calls Windows APIs that have a core count limit (32/64 depending on process bitness).
-                                     // So if we get a high core count on full framework, double-check it.
-                                     && (numberOfCpus >= 32)
-#endif
-                                    )
-                                {
-                                    var result = NativeMethodsShared.GetLogicalCoreCount();
-                                    if(result != -1)
-                                        numberOfCpus = result;
-                                }
-#endif
-                                switchParameters = ":" + numberOfCpus;
+                                int numberOfCpus = NativeMethodsShared.GetLogicalCoreCount();
+                                switchParameters = $":{numberOfCpus}";
                             }
-                            else if (String.Equals(switchName, "bl", StringComparison.OrdinalIgnoreCase) ||
-                                String.Equals(switchName, "binarylogger", StringComparison.OrdinalIgnoreCase))
+                            else if (string.Equals(switchName, "bl", StringComparison.OrdinalIgnoreCase) ||
+                                string.Equals(switchName, "binarylogger", StringComparison.OrdinalIgnoreCase))
                             {
                                 // we have to specify at least one parameter otherwise it's impossible to distinguish the situation
                                 // where /bl is not specified at all vs. where /bl is specified without the file name.
                                 switchParameters = ":msbuild.binlog";
                             }
-                            else if (String.Equals(switchName, "prof", StringComparison.OrdinalIgnoreCase) ||
-                                     String.Equals(switchName, "profileevaluation", StringComparison.OrdinalIgnoreCase))
+                            else if (string.Equals(switchName, "prof", StringComparison.OrdinalIgnoreCase) ||
+                                     string.Equals(switchName, "profileevaluation", StringComparison.OrdinalIgnoreCase))
                             {
                                 switchParameters = ":no-file";
                             }
                         }
 
-                        if (CommandLineSwitches.IsParameterlessSwitch(switchName, out parameterlessSwitch, out duplicateSwitchErrorMessage))
+                        if (CommandLineSwitches.IsParameterlessSwitch(switchName, out var parameterlessSwitch, out var duplicateSwitchErrorMessage))
                         {
                             GatherParameterlessCommandLineSwitch(commandLineSwitches, parameterlessSwitch, switchParameters, duplicateSwitchErrorMessage, unquotedCommandLineArg);
                         }
-                        else if (CommandLineSwitches.IsParameterizedSwitch(switchName, out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out allowEmptyParameters))
+                        else if (CommandLineSwitches.IsParameterizedSwitch(switchName, out var parameterizedSwitch, out duplicateSwitchErrorMessage, out var multipleParametersAllowed, out var missingParametersErrorMessage, out var unquoteParameters, out var allowEmptyParameters))
                         {
                             GatherParameterizedCommandLineSwitch(commandLineSwitches, parameterizedSwitch, switchParameters, duplicateSwitchErrorMessage, multipleParametersAllowed, missingParametersErrorMessage, unquoteParameters, unquotedCommandLineArg, allowEmptyParameters);
                         }
@@ -1804,8 +1764,7 @@ int switchParameterIndicator
             int quotedSwitchParameterIndicator = commandLineArg.IndexOf(':');
 
             // check if there is any quoting in the name portion of the switch
-            int doubleQuotesRemovedFromSwitchIndicatorAndName;
-            string unquotedSwitchIndicatorAndName = QuotingUtilities.Unquote(commandLineArg.Substring(0, quotedSwitchParameterIndicator), out doubleQuotesRemovedFromSwitchIndicatorAndName);
+            string unquotedSwitchIndicatorAndName = QuotingUtilities.Unquote(commandLineArg.Substring(0, quotedSwitchParameterIndicator), out var doubleQuotesRemovedFromSwitchIndicatorAndName);
 
             ErrorUtilities.VerifyThrow(switchName == unquotedSwitchIndicatorAndName.Substring(1),
                 "The switch name extracted from either the partially or completely unquoted arg should be the same.");
@@ -1835,7 +1794,7 @@ int switchParameterIndicator
                 {
                     // otherwise, use the quoted parameters, after compensating for the quoting that was started in the name
                     // portion of the switch
-                    switchParameters = ":\"" + commandLineArg.Substring(quotedSwitchParameterIndicator + 1);
+                    switchParameters = $":\"{commandLineArg.Substring(quotedSwitchParameterIndicator + 1)}";
                 }
             }
 
@@ -1848,7 +1807,7 @@ int switchParameterIndicator
         /// Used to keep track of response files to prevent them from
         /// being included multiple times (or even recursively).
         /// </summary>
-        private static ArrayList s_includedResponseFiles;
+        private static List<string> s_includedResponseFiles;
 
         /// <summary>
         /// Called when a response file switch is detected on the command line. It loads the specified response file, and parses
@@ -1880,7 +1839,7 @@ private static void GatherResponseFileSwitch(string unquotedCommandLineArg, Comm
 
                     foreach (string includedResponseFile in s_includedResponseFiles)
                     {
-                        if (String.Equals(responseFile, includedResponseFile, StringComparison.OrdinalIgnoreCase))
+                        if (string.Equals(responseFile, includedResponseFile, StringComparison.OrdinalIgnoreCase))
                         {
                             commandLineSwitches.SetParameterError("RepeatedResponseFileError", unquotedCommandLineArg);
                             isRepeatedResponseFile = true;
@@ -1893,7 +1852,7 @@ private static void GatherResponseFileSwitch(string unquotedCommandLineArg, Comm
                         var responseFileDirectory = FileUtilities.EnsureTrailingSlash(Path.GetDirectoryName(responseFile));
                         s_includedResponseFiles.Add(responseFile);
 
-                        ArrayList argsFromResponseFile;
+                        List<string> argsFromResponseFile;
 
 #if FEATURE_ENCODING_DEFAULT
                         using (StreamReader responseFileContents = new StreamReader(responseFile, Encoding.Default)) // HIGHCHAR: If response files have no byte-order marks, then assume ANSI rather than ASCII.
@@ -1901,7 +1860,7 @@ private static void GatherResponseFileSwitch(string unquotedCommandLineArg, Comm
                         using (StreamReader responseFileContents = FileUtilities.OpenRead(responseFile)) // HIGHCHAR: If response files have no byte-order marks, then assume ANSI rather than ASCII.
 #endif
                         {
-                            argsFromResponseFile = new ArrayList();
+                            argsFromResponseFile = new List<string>();
 
                             while (responseFileContents.Peek() != -1)
                             {
@@ -2080,7 +2039,7 @@ private static bool GatherAutoResponseFileSwitchesFromFullPath(string autoRespon
             if (FileSystems.Default.FileExists(autoResponseFile))
             {
                 found = true;
-                GatherResponseFileSwitch("@" + autoResponseFile, switchesFromAutoResponseFile);
+                GatherResponseFileSwitch($"@{autoResponseFile}", switchesFromAutoResponseFile);
 
                 // if the "/noautoresponse" switch was set in the auto-response file, flag an error
                 if (switchesFromAutoResponseFile[CommandLineSwitches.ParameterlessSwitch.NoAutoResponse])
@@ -2135,7 +2094,7 @@ private static bool ProcessCommandLineSwitches
             ref bool enableProfiler,
             ref Dictionary<string, string> restoreProperties,
             ref bool isolateProjects,
-            ref bool graphBuild,
+            ref GraphBuildOptions graphBuild,
             ref string[] inputResultsCaches,
             ref string outputResultsCache,
             ref bool lowPriority,
@@ -2209,10 +2168,10 @@ bool recursing
                         // gather any switches from the first Directory.Build.rsp found in the project directory or above
                         string directoryResponseFile = FileUtilities.GetPathOfFileAbove(directoryResponseFileName, projectDirectory);
 
-                        bool found = !String.IsNullOrWhiteSpace(directoryResponseFile) && GatherAutoResponseFileSwitchesFromFullPath(directoryResponseFile, switchesFromAutoResponseFile);
+                        bool found = !string.IsNullOrWhiteSpace(directoryResponseFile) && GatherAutoResponseFileSwitchesFromFullPath(directoryResponseFile, switchesFromAutoResponseFile);
 
                         // Don't look for more response files if it's only in the same place we already looked (next to the exe)
-                        if (!String.Equals(projectDirectory, s_exePath, StringComparison.OrdinalIgnoreCase))
+                        if (!string.Equals(projectDirectory, s_exePath, StringComparison.OrdinalIgnoreCase))
                         {
                             // this combines any found, with higher precedence, with the switches from the original auto response file switches
                             found |= GatherAutoResponseFileSwitches(projectDirectory, switchesFromAutoResponseFile);
@@ -2276,7 +2235,7 @@ bool recursing
                     // figure out if there was a max cpu count provided
                     cpuCount = ProcessMaxCPUCountSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.MaxCPUCount]);
 
-                    // figure out if we shold reuse nodes
+                    // figure out if we should reuse nodes
                     // If FEATURE_NODE_REUSE is OFF, just validates that the switch is OK, and always returns False
                     enableNodeReuse = ProcessNodeReuseSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeReuse]);
 
@@ -2317,7 +2276,7 @@ bool recursing
 
                     if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.GraphBuild))
                     {
-                        graphBuild = ProcessBooleanSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GraphBuild], defaultValue: true, resourceName: "InvalidGraphBuildValue");
+                        graphBuild = ProcessGraphBuildSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GraphBuild]);
                     }
 
                     if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.LowPriority))
@@ -2364,7 +2323,7 @@ out enableProfiler
                     if (verbosity == LoggerVerbosity.Diagnostic)
                     {
                         string equivalentCommandLine = commandLineSwitches.GetEquivalentCommandLineExceptProjectFile();
-                        Console.WriteLine(Path.Combine(s_exePath, s_exeName) + " " + equivalentCommandLine + " " + projectFile);
+                        Console.WriteLine($"{Path.Combine(s_exePath, s_exeName)} {equivalentCommandLine} {projectFile}");
                     }
 
 #if FEATURE_XML_SCHEMA_VALIDATION
@@ -2376,11 +2335,42 @@ out enableProfiler
                 }
             }
 
-            ErrorUtilities.VerifyThrow(!invokeBuild || !String.IsNullOrEmpty(projectFile), "We should have a project file if we're going to build.");
+            ErrorUtilities.VerifyThrow(!invokeBuild || !string.IsNullOrEmpty(projectFile), "We should have a project file if we're going to build.");
 
             return invokeBuild;
         }
 
+        internal static GraphBuildOptions ProcessGraphBuildSwitch(string[] parameters)
+        {
+            var options = new GraphBuildOptions();
+
+            // Before /graph had parameters, it was treated as a boolean switch.
+            // Preserve that in case anyone is using /graph:{false|true}
+            if (parameters.Length == 1 && bool.TryParse(parameters[0], out var boolValue))
+            {
+                return boolValue ? options : null;
+            }
+
+            foreach (var parameter in parameters)
+            {
+                if (string.IsNullOrWhiteSpace(parameter))
+                {
+                    continue;
+                }
+
+                if (parameter.Trim().Equals("NoBuild", StringComparison.OrdinalIgnoreCase))
+                {
+                    options = options with {Build = false};
+                }
+                else
+                {
+                    CommandLineSwitchException.Throw("InvalidGraphBuildValue", parameter);
+                }
+            }
+
+            return options;
+        }
+
         private static string ProcessOutputResultsCache(CommandLineSwitches commandLineSwitches)
         {
             return commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.OutputResultsCache)
@@ -2503,7 +2493,7 @@ internal static ISet<string> ProcessWarnAsErrorSwitch(CommandLineSwitches comman
                     // so that all warnings are treated errors
                     warningsAsErrors.Clear();
                 }
-                else if (!String.IsNullOrWhiteSpace(code))
+                else if (!string.IsNullOrWhiteSpace(code))
                 {
                     warningsAsErrors.Add(code.Trim());
                 }
@@ -2525,7 +2515,7 @@ internal static ISet<string> ProcessWarnAsMessageSwitch(CommandLineSwitches comm
 
             foreach (string code in parameters
                 .SelectMany(parameter => parameter?.Split(s_commaSemicolon, StringSplitOptions.RemoveEmptyEntries))
-                .Where(i => !String.IsNullOrWhiteSpace(i))
+                .Where(i => !string.IsNullOrWhiteSpace(i))
                 .Select(i => i.Trim()))
             {
                 warningsAsMessages.Add(code);
@@ -2565,7 +2555,7 @@ internal static bool ProcessBooleanSwitch(string[] parameters, bool defaultValue
         /// and also returns the created logger. Otherwise, the collection of loggers is not affected and null
         /// is returned
         /// </remarks>
-        internal static ProfilerLogger ProcessProfileEvaluationSwitch(string[] parameters, ArrayList loggers, out bool enableProfiler)
+        internal static ProfilerLogger ProcessProfileEvaluationSwitch(string[] parameters, List<ILogger> loggers, out bool enableProfiler)
         {
             if (parameters == null || parameters.Length == 0)
             {
@@ -2653,7 +2643,7 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches)
                         // If FEATURE_NODE_REUSE is OFF, just validates that the switch is OK, and always returns False
                         bool nodeReuse = ProcessNodeReuseSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeReuse]);
                         string[] lowPriorityInput = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.LowPriority];
-                        bool lowpriority = lowPriorityInput.Length > 0 ? lowPriorityInput[0].Equals("true") : false;
+                        bool lowpriority = lowPriorityInput.Length > 0 && lowPriorityInput[0].Equals("true");
 
                         shutdownReason = node.Run(nodeReuse, lowpriority, out nodeException);
 
@@ -2822,7 +2812,7 @@ DirectoryGetFiles getFiles
                     string solutionName = Path.GetFileNameWithoutExtension(actualSolutionFiles[0]);
                     string projectName = Path.GetFileNameWithoutExtension(actualProjectFiles[0]);
                     // Compare the names and error if they are not identical
-                    InitializationException.VerifyThrow(String.Equals(solutionName, projectName, StringComparison.OrdinalIgnoreCase), projectDirectory == null ? "AmbiguousProjectError" : "AmbiguousProjectDirectoryError", null, projectDirectory);
+                    InitializationException.VerifyThrow(string.Equals(solutionName, projectName, StringComparison.OrdinalIgnoreCase), projectDirectory == null ? "AmbiguousProjectError" : "AmbiguousProjectDirectoryError", null, projectDirectory);
                     projectFile = actualSolutionFiles[0];
                 }
                 // If there is more than one solution file in the current directory we have no idea which one to use
@@ -2843,17 +2833,17 @@ DirectoryGetFiles getFiles
                         string secondPotentialProjectExtension = Path.GetExtension(actualProjectFiles[1]);
 
                         // If the two projects have the same extension we can't decide which one to pick
-                        if (!String.Equals(firstPotentialProjectExtension, secondPotentialProjectExtension, StringComparison.OrdinalIgnoreCase))
+                        if (!string.Equals(firstPotentialProjectExtension, secondPotentialProjectExtension, StringComparison.OrdinalIgnoreCase))
                         {
                             // Check to see if the first project is the proj, if it is use it
-                            if (String.Equals(firstPotentialProjectExtension, ".proj", StringComparison.OrdinalIgnoreCase))
+                            if (string.Equals(firstPotentialProjectExtension, ".proj", StringComparison.OrdinalIgnoreCase))
                             {
                                 projectFile = actualProjectFiles[0];
                                 // We have made a decision
                                 isAmbiguousProject = false;
                             }
                             // If the first project is not the proj check to see if the second one is the proj, if so use it
-                            else if (String.Equals(secondPotentialProjectExtension, ".proj", StringComparison.OrdinalIgnoreCase))
+                            else if (string.Equals(secondPotentialProjectExtension, ".proj", StringComparison.OrdinalIgnoreCase))
                             {
                                 projectFile = actualProjectFiles[1];
                                 // We have made a decision
@@ -2895,9 +2885,9 @@ private static void ValidateExtensions(string[] projectExtensionsToIgnore)
                     InitializationException.VerifyThrow(extension.IndexOfAny(Path.GetInvalidPathChars()) == -1, "InvalidExtensionToIgnore", extension, null, false);
 
                     // There were characters before the extension.
-                    InitializationException.VerifyThrow(String.Equals(extension, Path.GetExtension(extension), StringComparison.OrdinalIgnoreCase), "InvalidExtensionToIgnore", extension, null, false);
+                    InitializationException.VerifyThrow(string.Equals(extension, Path.GetExtension(extension), StringComparison.OrdinalIgnoreCase), "InvalidExtensionToIgnore", extension, null, false);
 
-                    // Make sure that no wild cards are in the string because for now we dont allow wild card extensions.
+                    // Make sure that no wild cards are in the string because for now we don't allow wild card extensions.
                     InitializationException.VerifyThrow(extension.IndexOfAny(s_wildcards) == -1, "InvalidExtensionToIgnore", extension, null, false);
                 }
             }
@@ -3044,7 +3034,7 @@ out bool enableProfiler
                 verbosity = ProcessVerbositySwitch(verbositySwitchParameters[verbositySwitchParameters.Length - 1]);
             }
 
-            ArrayList loggers = ProcessLoggerSwitch(loggerSwitchParameters, verbosity);
+            var loggers = ProcessLoggerSwitch(loggerSwitchParameters, verbosity);
 
             // Add any loggers which have been specified on the commandline
             distributedLoggerRecords = ProcessDistributedLoggerSwitch(distributedLoggerSwitchParameters, verbosity);
@@ -3064,7 +3054,7 @@ out bool enableProfiler
                 detailedSummary = true;
             }
 
-            return (ILogger[])loggers.ToArray(typeof(ILogger));
+            return loggers.ToArray();
         }
 
         /// <summary>
@@ -3082,10 +3072,10 @@ internal static string AggregateParameters(string anyPrefixingParameter, string[
                 parametersToAggregate[i] = parametersToAggregate[i].Trim(MSBuildConstants.SemicolonChar);
             }
 
-            // Join the logger parameters into one string seperated by semicolons
-            string result = anyPrefixingParameter ?? String.Empty;
+            // Join the logger parameters into one string separated by semicolons
+            string result = anyPrefixingParameter ?? string.Empty;
 
-            result += String.Join(";", parametersToAggregate);
+            result += string.Join(";", parametersToAggregate);
 
             return result;
         }
@@ -3094,7 +3084,7 @@ internal static string AggregateParameters(string anyPrefixingParameter, string[
         /// Add a file logger with the appropriate parameters to the loggers list for each
         /// non-empty set of file logger parameters provided.
         /// </summary>
-        private static void ProcessFileLoggers(string[][] groupedFileLoggerParameters, List<DistributedLoggerRecord> distributedLoggerRecords, LoggerVerbosity verbosity, int cpuCount, ArrayList loggers)
+        private static void ProcessFileLoggers(string[][] groupedFileLoggerParameters, List<DistributedLoggerRecord> distributedLoggerRecords, LoggerVerbosity verbosity, int cpuCount, List<ILogger> loggers)
         {
             for (int i = 0; i < groupedFileLoggerParameters.Length; i++)
             {
@@ -3110,12 +3100,12 @@ private static void ProcessFileLoggers(string[][] groupedFileLoggerParameters, L
                 }
                 else
                 {
-                    fileParameters += "logfile=msbuild" + i + ".log;";
+                    fileParameters += $"logfile=msbuild{i}.log;";
                 }
 
                 if (groupedFileLoggerParameters[i].Length > 0)
                 {
-                    // Join the file logger parameters into one string seperated by semicolons
+                    // Join the file logger parameters into one string separated by semicolons
                     fileParameters = AggregateParameters(fileParameters, groupedFileLoggerParameters[i]);
                 }
 
@@ -3129,7 +3119,7 @@ private static void ProcessFileLoggers(string[][] groupedFileLoggerParameters, L
                     // We've decided to use the MP logger even in single proc mode.
                     // Switch it on here, rather than in the logger, so that other hosts that use
                     // the existing ConsoleLogger don't see the behavior change in single proc.
-                    fileLogger.Parameters = "ENABLEMPLOGGING;" + fileParameters;
+                    fileLogger.Parameters = $"ENABLEMPLOGGING;{fileParameters}";
                     loggers.Add(fileLogger);
                 }
                 else
@@ -3144,7 +3134,7 @@ private static void ProcessFileLoggers(string[][] groupedFileLoggerParameters, L
             }
         }
 
-        private static void ProcessBinaryLogger(string[] binaryLoggerParameters, ArrayList loggers, ref LoggerVerbosity verbosity)
+        private static void ProcessBinaryLogger(string[] binaryLoggerParameters, List<ILogger> loggers, ref LoggerVerbosity verbosity)
         {
             if (binaryLoggerParameters == null || binaryLoggerParameters.Length == 0)
             {
@@ -3153,8 +3143,7 @@ private static void ProcessBinaryLogger(string[] binaryLoggerParameters, ArrayLi
 
             string arguments = binaryLoggerParameters[binaryLoggerParameters.Length - 1];
 
-            BinaryLogger logger = new BinaryLogger();
-            logger.Parameters = arguments;
+            BinaryLogger logger = new BinaryLogger {Parameters = arguments};
 
             // If we have a binary logger, force verbosity to diagnostic.
             // The only place where verbosity is used downstream is to determine whether to log task inputs.
@@ -3174,7 +3163,7 @@ internal static void ProcessConsoleLoggerSwitch
             List<DistributedLoggerRecord> distributedLoggerRecords,
             LoggerVerbosity verbosity,
             int cpuCount,
-            ArrayList loggers
+            List<ILogger> loggers
         )
         {
             // the console logger is always active, unless specifically disabled
@@ -3194,7 +3183,7 @@ ArrayList loggers
                     // We've decided to use the MP logger even in single proc mode.
                     // Switch it on here, rather than in the logger, so that other hosts that use
                     // the existing ConsoleLogger don't see the behavior change in single proc.
-                    logger.Parameters = "ENABLEMPLOGGING;" + consoleParameters;
+                    logger.Parameters = $"ENABLEMPLOGGING;{consoleParameters}";
                     loggers.Add(logger);
                 }
                 else
@@ -3221,7 +3210,7 @@ private static DistributedLoggerRecord CreateForwardingLoggerRecord(ILogger logg
             string verbosityValue = ExtractAnyParameterValue(verbosityParameter);
 
             LoggerVerbosity effectiveVerbosity = defaultVerbosity;
-            if (!String.IsNullOrEmpty(verbosityValue))
+            if (!string.IsNullOrEmpty(verbosityValue))
             {
                 effectiveVerbosity = ProcessVerbositySwitch(verbosityValue);
             }
@@ -3244,7 +3233,7 @@ internal static void ProcessDistributedFileLogger
             bool distributedFileLogger,
             string[] fileLoggerParameters,
             List<DistributedLoggerRecord> distributedLoggerRecords,
-            ArrayList loggers,
+            List<ILogger> loggers,
             int cpuCount
         )
         {
@@ -3253,7 +3242,7 @@ int cpuCount
                 string fileParameters = string.Empty;
                 if ((fileLoggerParameters?.Length > 0))
                 {
-                    // Join the file logger parameters into one string seperated by semicolons
+                    // Join the file logger parameters into one string separated by semicolons
                     fileParameters = AggregateParameters(null, fileLoggerParameters);
                 }
 
@@ -3266,9 +3255,10 @@ int cpuCount
                 {
                     // If the path is not an absolute path set the path to the current directory of the exe combined with the relative path
                     // If the string is empty then send it through as the distributed file logger WILL deal with EMPTY logfile paths
-                    if (!String.IsNullOrEmpty(logFileName) && !Path.IsPathRooted(logFileName))
+                    if (!string.IsNullOrEmpty(logFileName) && !Path.IsPathRooted(logFileName))
                     {
-                        fileParameters = fileParameters.Replace(logFileParameter, "logFile=" + Path.Combine(Directory.GetCurrentDirectory(), logFileName));
+                        fileParameters = fileParameters.Replace(logFileParameter,
+                            $"logFile={Path.Combine(Directory.GetCurrentDirectory(), logFileName)}");
                     }
                 }
                 catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
@@ -3276,16 +3266,16 @@ int cpuCount
                     throw new LoggerException(e.Message, e);
                 }
 
-                if (String.IsNullOrEmpty(logFileName))
+                if (string.IsNullOrEmpty(logFileName))
                 {
-                    // If the string is not empty and it does not end in a ;, we need to add a ; to seperate what is in the parameter from the logfile
+                    // If the string is not empty and it does not end in a ;, we need to add a ; to separate what is in the parameter from the logfile
                     // if the string is empty, no ; is needed because logfile is the only parameter which will be passed in
-                    if (!String.IsNullOrEmpty(fileParameters) && !fileParameters.EndsWith(";", StringComparison.OrdinalIgnoreCase))
+                    if (!string.IsNullOrEmpty(fileParameters) && !fileParameters.EndsWith(";", StringComparison.OrdinalIgnoreCase))
                     {
                         fileParameters += ";";
                     }
 
-                    fileParameters += "logFile=" + Path.Combine(Directory.GetCurrentDirectory(), msbuildLogFileName);
+                    fileParameters += $"logFile={Path.Combine(Directory.GetCurrentDirectory(), msbuildLogFileName)}";
                 }
 
                 //Gets the currently loaded assembly in which the specified class is defined
@@ -3313,8 +3303,8 @@ internal static string ExtractAnyLoggerParameter(string parameters, params strin
             {
                 foreach (string name in parameterNames)
                 {
-                    bool found = nameValue.StartsWith(name + "=", StringComparison.OrdinalIgnoreCase) ||   // Parameters with value, such as "logfile=foo.txt"
-                                 String.Equals(name, nameValue, StringComparison.OrdinalIgnoreCase);       // Parameters without value, such as "append"
+                    bool found = nameValue.StartsWith($"{name}=", StringComparison.OrdinalIgnoreCase) ||   // Parameters with value, such as "logfile=foo.txt"
+                                 string.Equals(name, nameValue, StringComparison.OrdinalIgnoreCase);       // Parameters without value, such as "append"
 
                     if (found)
                     {
@@ -3334,7 +3324,7 @@ private static string ExtractAnyParameterValue(string parameter)
         {
             string value = null;
 
-            if (!String.IsNullOrEmpty(parameter))
+            if (!string.IsNullOrEmpty(parameter))
             {
                 string[] nameValuePair = parameter.Split(MSBuildConstants.EqualsChar);
 
@@ -3356,28 +3346,28 @@ internal static LoggerVerbosity ProcessVerbositySwitch(string value)
         {
             LoggerVerbosity verbosity = LoggerVerbosity.Normal;
 
-            if (String.Equals(value, "q", StringComparison.OrdinalIgnoreCase) ||
-                String.Equals(value, "quiet", StringComparison.OrdinalIgnoreCase))
+            if (string.Equals(value, "q", StringComparison.OrdinalIgnoreCase) ||
+                string.Equals(value, "quiet", StringComparison.OrdinalIgnoreCase))
             {
                 verbosity = LoggerVerbosity.Quiet;
             }
-            else if (String.Equals(value, "m", StringComparison.OrdinalIgnoreCase) ||
-                     String.Equals(value, "minimal", StringComparison.OrdinalIgnoreCase))
+            else if (string.Equals(value, "m", StringComparison.OrdinalIgnoreCase) ||
+                     string.Equals(value, "minimal", StringComparison.OrdinalIgnoreCase))
             {
                 verbosity = LoggerVerbosity.Minimal;
             }
-            else if (String.Equals(value, "n", StringComparison.OrdinalIgnoreCase) ||
-                     String.Equals(value, "normal", StringComparison.OrdinalIgnoreCase))
+            else if (string.Equals(value, "n", StringComparison.OrdinalIgnoreCase) ||
+                     string.Equals(value, "normal", StringComparison.OrdinalIgnoreCase))
             {
                 verbosity = LoggerVerbosity.Normal;
             }
-            else if (String.Equals(value, "d", StringComparison.OrdinalIgnoreCase) ||
-                     String.Equals(value, "detailed", StringComparison.OrdinalIgnoreCase))
+            else if (string.Equals(value, "d", StringComparison.OrdinalIgnoreCase) ||
+                     string.Equals(value, "detailed", StringComparison.OrdinalIgnoreCase))
             {
                 verbosity = LoggerVerbosity.Detailed;
             }
-            else if (String.Equals(value, "diag", StringComparison.OrdinalIgnoreCase) ||
-                     String.Equals(value, "diagnostic", StringComparison.OrdinalIgnoreCase))
+            else if (string.Equals(value, "diag", StringComparison.OrdinalIgnoreCase) ||
+                     string.Equals(value, "diagnostic", StringComparison.OrdinalIgnoreCase))
             {
                 verbosity = LoggerVerbosity.Diagnostic;
             }
@@ -3393,9 +3383,9 @@ internal static LoggerVerbosity ProcessVerbositySwitch(string value)
         /// Figures out which additional loggers are going to listen to build events.
         /// </summary>
         /// <returns>List of loggers.</returns>
-        private static ArrayList ProcessLoggerSwitch(string[] parameters, LoggerVerbosity verbosity)
+        private static List<ILogger> ProcessLoggerSwitch(string[] parameters, LoggerVerbosity verbosity)
         {
-            ArrayList loggers = new ArrayList();
+            var loggers = new List<ILogger>();
 
             foreach (string parameter in parameters)
             {
@@ -3423,15 +3413,14 @@ private static List<DistributedLoggerRecord> ProcessDistributedLoggerSwitch(stri
             foreach (string parameter in parameters)
             {
                 // split each <central logger>|<node logger> string into two pieces, breaking on the first | that is found
-                int emptySplits; // ignored
-                ArrayList loggerSpec = QuotingUtilities.SplitUnquoted(parameter, 2, true /* keep empty splits */, false /* keep quotes */, out emptySplits, '*');
+                var loggerSpec = QuotingUtilities.SplitUnquoted(parameter, 2, true /* keep empty splits */, false /* keep quotes */, out _, '*');
 
                 ErrorUtilities.VerifyThrow((loggerSpec.Count >= 1) && (loggerSpec.Count <= 2),
                     "SplitUnquoted() must return at least one string, and no more than two.");
 
-                string unquotedParameter = QuotingUtilities.Unquote((string)loggerSpec[0]);
+                string unquotedParameter = QuotingUtilities.Unquote(loggerSpec[0]);
                 LoggerDescription centralLoggerDescription =
-                    ParseLoggingParameter((string)loggerSpec[0], unquotedParameter, verbosity);
+                    ParseLoggingParameter(loggerSpec[0], unquotedParameter, verbosity);
 
                 if (!CreateAndConfigureLogger(centralLoggerDescription, verbosity, unquotedParameter, out ILogger centralLogger))
                 {
@@ -3443,8 +3432,8 @@ private static List<DistributedLoggerRecord> ProcessDistributedLoggerSwitch(stri
 
                 if (loggerSpec.Count > 1)
                 {
-                    unquotedParameter = QuotingUtilities.Unquote((string)loggerSpec[1]);
-                    forwardingLoggerDescription = ParseLoggingParameter((string)loggerSpec[1], unquotedParameter, verbosity);
+                    unquotedParameter = QuotingUtilities.Unquote(loggerSpec[1]);
+                    forwardingLoggerDescription = ParseLoggingParameter(loggerSpec[1], unquotedParameter, verbosity);
                 }
 
                 DistributedLoggerRecord distributedLoggerRecord =
@@ -3465,31 +3454,28 @@ private static List<DistributedLoggerRecord> ProcessDistributedLoggerSwitch(stri
         /// <returns></returns>
         private static LoggerDescription ParseLoggingParameter(string parameter, string unquotedParameter, LoggerVerbosity verbosity)
         {
-            ArrayList loggerSpec;
             string loggerClassName;
-            string loggerAssemblyName;
-            string loggerAssemblyFile;
             string loggerParameters = null;
             bool isOptional = false;
 
             // split each <logger type>;<logger parameters> string into two pieces, breaking on the first ; that is found
-            loggerSpec = QuotingUtilities.SplitUnquoted(parameter, 2, true /* keep empty splits */, false /* keep quotes */, out _, ';');
+            var loggerSpec = QuotingUtilities.SplitUnquoted(parameter, 2, true /* keep empty splits */, false /* keep quotes */, out _, ';');
 
             ErrorUtilities.VerifyThrow((loggerSpec.Count >= 1) && (loggerSpec.Count <= 2),
                 "SplitUnquoted() must return at least one string, and no more than two.");
 
             // check that the logger is specified
-            CommandLineSwitchException.VerifyThrow(((string)loggerSpec[0]).Length > 0,
+            CommandLineSwitchException.VerifyThrow(loggerSpec[0].Length > 0,
                 "InvalidLoggerError", unquotedParameter);
 
             // extract logger parameters if present
             if (loggerSpec.Count == 2)
             {
-                loggerParameters = QuotingUtilities.Unquote((string)loggerSpec[1]);
+                loggerParameters = QuotingUtilities.Unquote(loggerSpec[1]);
             }
 
             // split each <logger class>,<logger assembly>[,<option1>][,option2] parameters string into pieces
-            ArrayList loggerTypeSpec = QuotingUtilities.SplitUnquoted((string)loggerSpec[0], int.MaxValue, true /* keep empty splits */, false /* keep quotes */, out _, ',');
+            var loggerTypeSpec = QuotingUtilities.SplitUnquoted(loggerSpec[0], int.MaxValue, true /* keep empty splits */, false /* keep quotes */, out _, ',');
 
             ErrorUtilities.VerifyThrow(loggerTypeSpec.Count >= 1, "SplitUnquoted() must return at least one string");
 
@@ -3498,13 +3484,13 @@ private static LoggerDescription ParseLoggingParameter(string parameter, string
             // if the logger class and assembly are both specified
             if (loggerTypeSpec.Count >= 2)
             {
-                loggerClassName = QuotingUtilities.Unquote((string)loggerTypeSpec[0]);
-                loggerAssemblySpec = QuotingUtilities.Unquote((string)loggerTypeSpec[1]);
+                loggerClassName = QuotingUtilities.Unquote(loggerTypeSpec[0]);
+                loggerAssemblySpec = QuotingUtilities.Unquote(loggerTypeSpec[1]);
             }
             else
             {
-                loggerClassName = String.Empty;
-                loggerAssemblySpec = QuotingUtilities.Unquote((string)loggerTypeSpec[0]);
+                loggerClassName = string.Empty;
+                loggerAssemblySpec = QuotingUtilities.Unquote(loggerTypeSpec[0]);
             }
 
             // Loop through the remaining items as options
@@ -3519,13 +3505,13 @@ private static LoggerDescription ParseLoggingParameter(string parameter, string
             CommandLineSwitchException.VerifyThrow(loggerAssemblySpec.Length > 0,
                 "InvalidLoggerError", unquotedParameter);
 
-            loggerAssemblyName = null;
-            loggerAssemblyFile = null;
+            string loggerAssemblyName = null;
+            string loggerAssemblyFile = null;
 
             // DDB Bug msbuild.exe -Logger:FileLogger,Microsoft.Build.Engine fails due to moved engine file.
             // Only add strong naming if the assembly is a non-strong named 'Microsoft.Build.Engine' (i.e, no additional characteristics)
             // Concat full Strong Assembly to match v4.0
-            if (String.Equals(loggerAssemblySpec, "Microsoft.Build.Engine", StringComparison.OrdinalIgnoreCase))
+            if (string.Equals(loggerAssemblySpec, "Microsoft.Build.Engine", StringComparison.OrdinalIgnoreCase))
             {
                 loggerAssemblySpec = "Microsoft.Build.Engine,Version=4.0.0.0,Culture=neutral,PublicKeyToken=b03f5f7f11d50a3a";
             }
@@ -3635,9 +3621,9 @@ private static void ReplayBinaryLog
                 {
                     nodeLogger.Initialize(replayEventSource, cpuCount);
                 }
-                else if (centralLogger != null)
+                else
                 {
-                    centralLogger.Initialize(replayEventSource);
+                    centralLogger?.Initialize(replayEventSource);
                 }
             }
 
@@ -3701,10 +3687,10 @@ private static string ProcessValidateSwitch(string[] parameters)
         /// </summary>
         private static void ThrowInvalidToolsVersionInitializationException(IEnumerable<Toolset> toolsets, string toolsVersion)
         {
-            string toolsVersionList = String.Empty;
+            string toolsVersionList = string.Empty;
             foreach (Toolset toolset in toolsets)
             {
-                toolsVersionList += "\"" + toolset.ToolsVersion + "\", ";
+                toolsVersionList += $"\"{toolset.ToolsVersion}\", ";
             }
 
             // Remove trailing comma and space
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 44d367d12ca..5e1dee0ffee 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -48,8 +48,8 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Build.CPPTasks.Common" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <bindingRedirect oldVersion="16.0.0.0-16.9.0.0" newVersion="16.9.0.0" />
-          <codeBase version="16.9.0.0" href="..\..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
+          <bindingRedirect oldVersion="16.0.0.0-16.10.0.0" newVersion="16.10.0.0" />
+          <codeBase version="16.10.0.0" href="..\..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
         </dependentAssembly>
 
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 7a2af88853e..4dc44912a1d 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -60,8 +60,8 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Build.CPPTasks.Common" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <bindingRedirect oldVersion="16.0.0.0-16.9.0.0" newVersion="16.9.0.0" />
-          <codeBase version="16.9.0.0" href="..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
+          <bindingRedirect oldVersion="16.0.0.0-16.10.0.0" newVersion="16.10.0.0" />
+          <codeBase version="16.10.0.0" href="..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
         </dependentAssembly>
 
         <!-- Workaround for crash in C++ CodeAnalysis scenarios due to https://github.com/Microsoft/msbuild/issues/1675 -->
diff --git a/src/MSBuildTaskHost/Concurrent/ConcurrentDictionary.cs b/src/MSBuildTaskHost/Concurrent/ConcurrentDictionary.cs
index e83adf88dce..76a126450a7 100644
--- a/src/MSBuildTaskHost/Concurrent/ConcurrentDictionary.cs
+++ b/src/MSBuildTaskHost/Concurrent/ConcurrentDictionary.cs
@@ -93,7 +93,7 @@ private static bool IsValueWriteAtomic()
         /// </summary>
         public ConcurrentDictionary(IEqualityComparer<TKey> comparer = null)
         {
-            int concurrencyLevel = Environment.ProcessorCount;
+            int concurrencyLevel = NativeMethodsShared.GetLogicalCoreCount();
             int capacity = DefaultCapacity;
 
             // The capacity should be at least as large as the concurrency level. Otherwise, we would have locks that don't guard
diff --git a/src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs b/src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs
index c540a86288e..6ed1e6755d5 100644
--- a/src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs
+++ b/src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs
@@ -138,6 +138,17 @@ internal ImmutableDictionary<K, V> SetItem(K key, V value)
             return clone;
         }
 
+        internal ImmutableDictionary<K, V> SetItems(IEnumerable<KeyValuePair<K, V>> items)
+        {
+            var clone = new ImmutableDictionary<K, V>(_backing);
+            foreach (KeyValuePair<K, V> item in items)
+            {
+                clone._backing[item.Key] = item.Value;
+            }
+
+            return clone;
+        }
+
         internal ImmutableDictionary<K, V> Remove(K key)
         {
             if (!ContainsKey(key))
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 615488880be..0437fdcbb36 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -129,15 +129,6 @@
     <Compile Include="..\Shared\NodeShutdown.cs">
       <Link>NodeShutdown.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\IInternable.cs">
-      <Link>IInternable.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\WeakStringCache.cs">
-      <Link>WeakStringCache.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\OpportunisticIntern.cs">
-      <Link>OpportunisticIntern.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\ReadOnlyEmptyCollection.cs">
       <Link>ReadOnlyEmptyCollection.cs</Link>
     </Compile>
@@ -169,7 +160,6 @@
     <Compile Include="Immutable\ImmutableDictionary.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
     <Compile Include="TypeLoader.cs" />
-    <Compile Include="WeakStringCache.Locking.cs" />
     <Compile Include="..\MSBuild\LogMessagePacket.cs">
       <Link>LogMessagePacket.cs</Link>
     </Compile>
@@ -210,6 +200,9 @@
   <ItemGroup>
     <Content Include="..\MSBuild.ico" />
   </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\StringTools\StringTools.csproj" />
+  </ItemGroup>
   <ItemGroup>
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" />
     <!-- Disabled PdbGit because of warnings; it could/should be brought back.
diff --git a/src/Package/DevDivPackage/DevDivPackage.csproj b/src/Package/DevDivPackage/DevDivPackage.csproj
index 8236fd58d12..41cbda82dc7 100644
--- a/src/Package/DevDivPackage/DevDivPackage.csproj
+++ b/src/Package/DevDivPackage/DevDivPackage.csproj
@@ -18,7 +18,7 @@
 
   <Import Project="..\NuspecProject.targets" />
 
-  <Import Project="$(RepoRoot)eng\ProducesNoOutput.Settings.props" Condition="'$(OsEnvironment)'!='windows'" />
+  <Import Project="$(RepoRoot)eng\ProducesNoOutput.Settings.props" Condition="! $([MSBuild]::IsOSPlatform('windows'))" />
 
   <Import Project="Sdk.targets" Sdk="Microsoft.NET.Sdk" />
 
diff --git a/src/Package/DevDivPackage/VS.ExternalAPIs.MSBuild.nuspec b/src/Package/DevDivPackage/VS.ExternalAPIs.MSBuild.nuspec
index 14bfd426aff..338a4620c27 100644
--- a/src/Package/DevDivPackage/VS.ExternalAPIs.MSBuild.nuspec
+++ b/src/Package/DevDivPackage/VS.ExternalAPIs.MSBuild.nuspec
@@ -18,6 +18,7 @@
     <file src="Microsoft.Build.Framework.dll" target="lib\net472" />
     <file src="Microsoft.Build.Tasks.Core.dll" target="lib\net472" />
     <file src="Microsoft.Build.Utilities.Core.dll" target="lib\net472" />
+    <file src="Microsoft.NET.StringTools.dll" target="lib\net472" />
 
     <!-- Obsolete but still referenced in the VS repo -->
     <file src="Microsoft.Build.Engine.dll" target="lib\net472" />
diff --git a/src/Package/Localization/Localization.csproj b/src/Package/Localization/Localization.csproj
index 6a169173b1c..0326009105b 100644
--- a/src/Package/Localization/Localization.csproj
+++ b/src/Package/Localization/Localization.csproj
@@ -1,6 +1,6 @@
 ﻿<Project Sdk="Microsoft.NET.Sdk">
   <PropertyGroup>
-    <TargetFramework Condition="$(MonoBuild) != 'true'">netcoreapp2.1</TargetFramework>
+    <TargetFramework Condition="$(MonoBuild) != 'true'">net5.0</TargetFramework>
     <TargetFramework Condition="$(MonoBuild) == 'true'">net472</TargetFramework>
     <NuspecFile>Microsoft.Build.Localization.nuspec</NuspecFile>
     <IsShipping>false</IsShipping>
diff --git a/src/Package/MSBuild.Engine.Corext/MSBuild.Engine.Corext.csproj b/src/Package/MSBuild.Engine.Corext/MSBuild.Engine.Corext.csproj
index d754aeecdff..5e0ca03263a 100644
--- a/src/Package/MSBuild.Engine.Corext/MSBuild.Engine.Corext.csproj
+++ b/src/Package/MSBuild.Engine.Corext/MSBuild.Engine.Corext.csproj
@@ -3,7 +3,7 @@
   <PropertyGroup>
     <DisableProject Condition="'$(MonoBuild)' == 'true'">true</DisableProject>
     <DisableProject Condition="'$(MSBuildRuntimeType)' == 'Core'">true</DisableProject>
-    <DisableProject Condition="'$(OsEnvironment)'!='windows'">true</DisableProject>
+    <DisableProject Condition="! $([MSBuild]::IsOSPlatform('windows'))">true</DisableProject>
   </PropertyGroup>
   <Import Project="$(RepoRoot)eng\ProducesNoOutput.Settings.props" Condition="'$(DisableProject)' == 'true'" />
 
diff --git a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
index 9482f3faf5d..2918e172a5c 100644
--- a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
+++ b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
@@ -43,6 +43,8 @@
     <file src="$X86BinPath$/System.Resources.Extensions.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Runtime.CompilerServices.Unsafe.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Threading.Tasks.Dataflow.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/Microsoft.NET.StringTools.dll" target="v15.0/bin" />
+    <file src="$TaskHostBinPath$/Microsoft.NET.StringTools.net35.dll" target="v15.0/bin" />
 
     <file src="$X86BinPath$/MSBuild/Microsoft.Build.Core.xsd" target="v15.0/bin/MSBuild" />
     <file src="$X86BinPath$/MSBuild/Microsoft.Build.CommonTypes.xsd" target="v15.0/bin/MSBuild" />
@@ -97,6 +99,8 @@
     <file src="$X86BinPath$/System.Resources.Extensions.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Runtime.CompilerServices.Unsafe.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Threading.Tasks.Dataflow.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/Microsoft.NET.StringTools.dll" target="v15.0/bin/amd64" />
+    <file src="$TaskHostBinPath$/Microsoft.NET.StringTools.net35.dll" target="v15.0/bin/amd64" />
 
     <file src="$X86BinPath$/MSBuild/Microsoft.Build.Core.xsd" target="v15.0/bin/amd64/MSBuild" />
     <file src="$X86BinPath$/MSBuild/Microsoft.Build.CommonTypes.xsd" target="v15.0/bin/amd64/MSBuild" />
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 2f87ef174f2..9e82ee87cae 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -8,7 +8,6 @@ package name=Microsoft.Build
 vs.dependencies
   vs.dependency id=Microsoft.Build.UnGAC
   vs.dependency id=Microsoft.VisualStudio.PackageGroup.NuGet
-                version=[15.0,17.0)
 
 vs.relatedProcessFiles
   vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\Microsoft.Build.dll"
@@ -48,6 +47,8 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)System.Resources.Extensions.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Threading.Tasks.Dataflow.dll vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.NET.StringTools.dll vs.file.ngenArchitecture=all
+  file source=$(TaskHostBinPath)Microsoft.NET.StringTools.net35.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Collections.Immutable.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)Microsoft.Common.CurrentVersion.targets
   file source=$(X86BinPath)Microsoft.Common.CrossTargeting.targets
@@ -198,6 +199,8 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Threading.Tasks.Dataflow.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Collections.Immutable.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Microsoft.NET.StringTools.dll vs.file.ngenArchitecture=all
+  file source=$(TaskHostBinPath)Microsoft.NET.StringTools.net35.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Common.CurrentVersion.targets
   file source=$(X86BinPath)Microsoft.Common.CrossTargeting.targets
   file source=$(X86BinPath)Microsoft.Common.overridetasks
@@ -321,6 +324,7 @@ folder InstallDir:\Common7\IDE\CommonExtensions\MSBuild
   file source=$(SourceDir)Build\Microsoft.Build.pkgdef
   file source=$(SourceDir)Build\System.Text.Encodings.Web.pkgdef
   file source=$(SourceDir)Build\System.Text.Json.pkgdef
+  file source=$(SourceDir)StringTools\StringTools.pkgdef
   file source=$(SourceDir)Tasks\Microsoft.Build.Tasks.Core.pkgdef
   file source=$(SourceDir)Tasks\System.Resources.Extensions.pkgdef
   file source=$(SourceDir)Utilities\Microsoft.Build.Utilities.Core.pkgdef
diff --git a/src/Samples/ProjectCachePlugin/AssemblyMockCache.cs b/src/Samples/ProjectCachePlugin/AssemblyMockCache.cs
new file mode 100644
index 00000000000..8b0a83ecc8b
--- /dev/null
+++ b/src/Samples/ProjectCachePlugin/AssemblyMockCache.cs
@@ -0,0 +1,58 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.ProjectCache;
+using Microsoft.Build.Framework;
+
+namespace MockCacheFromAssembly
+{
+    public class AssemblyMockCache : ProjectCachePluginBase
+    {
+        public AssemblyMockCache()
+        {
+            ThrowFrom("Constructor");
+        }
+
+        public override Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken)
+        {
+            logger.LogMessage($"{nameof(AssemblyMockCache)}: BeginBuildAsync", MessageImportance.High);
+
+            ThrowFrom(nameof(BeginBuildAsync));
+
+            return Task.CompletedTask;
+        }
+
+        public override Task<CacheResult> GetCacheResultAsync(
+            BuildRequestData buildRequest,
+            PluginLoggerBase logger,
+            CancellationToken cancellationToken)
+        {
+            logger.LogMessage($"{nameof(AssemblyMockCache)}: GetCacheResultAsync for {buildRequest.ProjectFullPath}", MessageImportance.High);
+
+            ThrowFrom(nameof(GetCacheResultAsync));
+
+            return Task.FromResult(CacheResult.IndicateNonCacheHit(CacheResultType.CacheNotApplicable));
+        }
+
+        public override Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken)
+        {
+            logger.LogMessage($"{nameof(AssemblyMockCache)}: EndBuildAsync", MessageImportance.High);
+
+            ThrowFrom(nameof(EndBuildAsync));
+
+            return Task.CompletedTask;
+        }
+
+        private static void ThrowFrom(string throwFrom)
+        {
+            if (Environment.GetEnvironmentVariable(throwFrom) != null)
+            {
+                throw new Exception($"Cache plugin exception from {throwFrom}");
+            }
+        }
+    }
+}
diff --git a/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj b/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
new file mode 100644
index 00000000000..df35ae1ca6b
--- /dev/null
+++ b/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
@@ -0,0 +1,15 @@
+﻿<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <UseProductOutputPath>true</UseProductOutputPath>
+    <CopyNuGetImplementations>false</CopyNuGetImplementations>
+    <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
+
+    <TargetFrameworks>net5.0</TargetFrameworks>
+    <TargetFrameworks Condition="$([MSBuild]::IsOSPlatform('windows'))">$(FullFrameworkTFM);net5.0</TargetFrameworks>
+    <TargetFrameworks Condition="'$(MonoBuild)'=='true'">$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
+  </PropertyGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\Build\Microsoft.Build.csproj" />
+    <ProjectReference Include="..\..\Framework\Microsoft.Build.Framework.csproj" />
+  </ItemGroup>
+</Project>
diff --git a/src/Shared/AssemblyUtilities.cs b/src/Shared/AssemblyUtilities.cs
index f4194346f88..46d679293c5 100644
--- a/src/Shared/AssemblyUtilities.cs
+++ b/src/Shared/AssemblyUtilities.cs
@@ -6,6 +6,12 @@
 using System.Linq;
 using System.Reflection;
 
+// Declare this to get init properties. See https://github.com/dotnet/roslyn/issues/45510#issuecomment-694977239
+namespace System.Runtime.CompilerServices
+{
+    internal static class IsExternalInit { }
+}
+
 namespace Microsoft.Build.Shared
 {
     /// <summary>
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index 9d211bc1148..3785175e7fd 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -440,6 +440,14 @@ internal static void ResetInstance_ForUnitTestsOnly(Func<string> getProcessFromR
             BuildEnvironmentHelperSingleton.s_instance = Initialize();
         }
 
+        /// <summary>
+        /// Resets the current singleton instance (for testing).
+        /// </summary>
+        internal static void ResetInstance_ForUnitTestsOnly(BuildEnvironment buildEnvironment)
+        {
+            BuildEnvironmentHelperSingleton.s_instance = buildEnvironment;
+        }
+
         private static Func<string> s_getProcessFromRunningProcess = GetProcessFromRunningProcess;
         private static Func<string> s_getExecutingAssemblyPath = GetExecutingAssemblyPath;
         private static Func<string> s_getAppContextBaseDirectory = GetAppContextBaseDirectory;
diff --git a/src/Shared/ChangeWaves.cs b/src/Shared/ChangeWaves.cs
deleted file mode 100644
index 29487ea8b78..00000000000
--- a/src/Shared/ChangeWaves.cs
+++ /dev/null
@@ -1,208 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using Microsoft.Build.Shared;
-using System;
-using System.Linq;
-
-namespace Microsoft.Build.Utilities
-{
-    internal enum ChangeWaveConversionState
-    {
-        NotConvertedYet,
-        Valid,
-        InvalidFormat,
-        OutOfRotation
-    }
-
-    /// <summary>
-    /// All waves are enabled by default, meaning all features behind change wave versions are enabled.
-    /// </summary>
-    public class ChangeWaves
-    {
-        public static readonly string[] AllWaves = { Wave16_8, Wave16_10, Wave17_0 };
-        public static readonly Version[] AllWavesAsVersion = Array.ConvertAll<string, Version>(AllWaves, Version.Parse);
-        public const string Wave16_8 = "16.8";
-        public const string Wave16_10 = "16.10";
-        public const string Wave17_0 = "17.0";
-
-        /// <summary>
-        /// Special value indicating that all features behind change-waves should be enabled.
-        /// </summary>
-        public const string EnableAllFeatures = "999.999";
-
-        internal static readonly Version LowestWaveAsVersion = new Version(AllWaves[0]);
-        internal static readonly Version HighestWaveAsVersion = new Version(AllWaves[AllWaves.Length - 1]);
-        internal static readonly Version EnableAllFeaturesAsVersion = new Version(EnableAllFeatures);
-
-        internal static string LowestWave
-        {
-            get
-            {
-                return AllWaves[0];
-            }
-        }
-
-        internal static string HighestWave
-        {
-            get
-            {
-                return AllWaves[AllWaves.Length - 1];
-            }
-        }
-
-        private static string cachedWave = null;
-
-        public static string DisabledWave
-        {
-            get
-            {
-                if (cachedWave == null)
-                {
-                    cachedWave = Traits.Instance.MSBuildDisableFeaturesFromVersion ?? "";
-                }
-
-                return cachedWave;
-            }
-            set
-            {
-                cachedWave = value;
-            }
-        }
-
-        private static ChangeWaveConversionState _state;
-        internal static ChangeWaveConversionState ConversionState
-        {
-            get
-            {
-                return _state;
-            }
-            set
-            {
-                // Keep state persistent.
-                if (_state == ChangeWaveConversionState.NotConvertedYet)
-                {
-                    _state = value;
-                }
-            }
-        }
-
-        /// <summary>
-        /// Ensure the the environment variable MSBuildDisableFeaturesFromWave is set to a proper value.
-        /// </summary>
-        /// <returns> String representation of the set change wave. "999.999" if unset or invalid, and clamped if out of bounds. </returns>
-        internal static void ApplyChangeWave()
-        {
-            Version changeWave;
-
-            // If unset, enable all features.
-            if (DisabledWave.Length == 0 || DisabledWave.Equals(EnableAllFeatures, StringComparison.OrdinalIgnoreCase))
-            {
-                ConversionState = ChangeWaveConversionState.Valid;
-                DisabledWave = ChangeWaves.EnableAllFeatures;
-                return;
-            }
-
-            // If the version is of invalid format, log a warning and enable all features.
-            if (!Version.TryParse(DisabledWave, out changeWave))
-            {
-                ConversionState = ChangeWaveConversionState.InvalidFormat;
-                DisabledWave = ChangeWaves.EnableAllFeatures;
-                return;
-            }
-            // If the version is 999.999, we're done.
-            else if (changeWave == EnableAllFeaturesAsVersion)
-            {
-                ConversionState = ChangeWaveConversionState.Valid;
-                DisabledWave = changeWave.ToString();
-                return;
-            }
-            // If the version is out of rotation, log a warning and clamp the value.
-            else if (changeWave < LowestWaveAsVersion)
-            {
-                ConversionState = ChangeWaveConversionState.OutOfRotation;
-                DisabledWave = LowestWave;
-                return;
-            }
-            else if (changeWave > HighestWaveAsVersion)
-            {
-                ConversionState = ChangeWaveConversionState.OutOfRotation;
-                DisabledWave = HighestWave;
-                return;
-            }
-
-            // Ensure it's set to an existing version within the current rotation
-            if (!AllWavesAsVersion.Contains(changeWave))
-            {
-                foreach (Version wave in AllWavesAsVersion)
-                {
-                    if (wave > changeWave)
-                    {
-                        ConversionState = ChangeWaveConversionState.Valid;
-                        DisabledWave = wave.ToString();
-                        return;
-                    }
-                }
-            }
-
-            ConversionState = ChangeWaveConversionState.Valid;
-            DisabledWave = changeWave.ToString();
-        }
-
-        /// <summary>
-        /// Compares the passed wave to the MSBuildDisableFeaturesFromVersion environment variable.
-        /// Version MUST be of the format: "xx.yy".
-        /// </summary>
-        /// <param name="wave">The version to compare.</param>
-        /// <returns>A bool indicating whether the feature behind a version is enabled.</returns>
-        public static bool AreFeaturesEnabled(string wave)
-        {
-            Version waveToCheck;
-
-            // When a caller passes an invalid wave, fail the build.
-            ErrorUtilities.VerifyThrow(Version.TryParse(wave.ToString(), out waveToCheck),
-                                       $"Argument 'wave' passed with invalid format." +
-                                       $"Please use pre-existing const strings or define one with format 'xx.yy");
-
-            return AreFeaturesEnabled(waveToCheck);
-        }
-
-        /// <summary>
-        /// Compares the passed wave to the MSBuildDisableFeaturesFromVersion environment variable.
-        /// </summary>
-        /// <param name="wave">The version to compare.</param>
-        /// <returns>A bool indicating whether the version is enabled.</returns>
-        public static bool AreFeaturesEnabled(Version wave)
-        {
-            if (_state == ChangeWaveConversionState.NotConvertedYet)
-            {
-                ApplyChangeWave();
-            }
-
-            // This is opt out behavior, all waves are enabled by default.
-            if (DisabledWave.Length == 0 || DisabledWave.Equals(EnableAllFeatures, StringComparison.OrdinalIgnoreCase))
-            {
-                return true;
-            }
-
-            Version currentSetWave;
-
-            // If we can't parse the environment variable, default to enabling features.
-            if (!Version.TryParse(DisabledWave, out currentSetWave))
-            {
-                return true;
-            }
-
-            return wave < currentSetWave;
-        }
-
-        /// <summary>
-        /// Resets the state and value of the currently disabled version.
-        /// </summary>
-        public static void ResetStateForTests()
-        {
-            DisabledWave = null;
-            _state = ChangeWaveConversionState.NotConvertedYet;
-        }
-    }
-}
diff --git a/src/Shared/CollectionHelpers.cs b/src/Shared/CollectionHelpers.cs
index 07ba40bad1d..8d66f374154 100644
--- a/src/Shared/CollectionHelpers.cs
+++ b/src/Shared/CollectionHelpers.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Linq;
 
 namespace Microsoft.Build.Shared
 {
@@ -45,5 +46,35 @@ internal static bool ContainsValueAndIsEqual(this Dictionary<string, string> dic
 
             return false;
         }
+
+#if !CLR2COMPATIBILITY
+        internal static bool SetEquivalent<T>(IEnumerable<T> a, IEnumerable<T> b)
+        {
+            return a.ToHashSet().SetEquals(b);
+        }
+
+        internal static bool DictionaryEquals<K, V>(IReadOnlyDictionary<K, V> a, IReadOnlyDictionary<K, V> b)
+        {
+            if (a.Count != b.Count)
+            {
+                return false;
+            }
+
+            foreach (var aKvp in a)
+            {
+                if (!b.TryGetValue(aKvp.Key, out var bValue))
+                {
+                    return false;
+                }
+
+                if (!Equals(aKvp.Value, bValue))
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+#endif
     }
 }
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index d2f3da6b887..d8b2c66c98d 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -60,8 +60,6 @@ internal static class MSBuildConstants
         /// </summary>
         internal const string CurrentToolsVersion = "Current";
 
-        // if you change the key also change the following clones
-        // Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.TryIntern
         internal const string MSBuildDummyGlobalPropertyHeader = "MSBuildProjectInstance";
 
         /// <summary>
@@ -97,6 +95,7 @@ internal static class MSBuildConstants
         internal static readonly char[] ForwardSlash = { '/' };
         internal static readonly char[] ForwardSlashBackslash = { '/', '\\' };
         internal static readonly char[] WildcardChars = { '*', '?' };
+        internal static readonly string[] CharactersForExpansion = { "*", "?", "$(", "@(", "%" };
         internal static readonly char[] CommaChar = { ',' };
         internal static readonly char[] HyphenChar = { '-' };
         internal static readonly char[] DirectorySeparatorChar = { Path.DirectorySeparatorChar };
@@ -117,6 +116,13 @@ internal static class PropertyNames
         internal const string InnerBuildPropertyValues = nameof(InnerBuildPropertyValues);
     }
 
+    // TODO: Remove these when VS gets updated to setup project cache plugins.
+    internal static class DesignTimeProperties
+    {
+        internal const string DesignTimeBuild = nameof(DesignTimeBuild);
+        internal const string BuildingProject = nameof(BuildingProject);
+    }
+
     internal static class ItemTypeNames
     {
         /// <summary>
@@ -130,6 +136,11 @@ internal static class ItemTypeNames
         internal const string ProjectReferenceTargets = nameof(ProjectReferenceTargets);
 
         internal const string GraphIsolationExemptReference = nameof(GraphIsolationExemptReference);
+
+        /// <summary>
+        /// Declares a project cache plugin and its configuration.
+        /// </summary>
+        internal const string ProjectCachePlugin = nameof(ProjectCachePlugin);
     }
 
     /// <summary>
diff --git a/src/Shared/ConversionUtilities.cs b/src/Shared/ConversionUtilities.cs
index b2d1c705bae..351b3b04e46 100644
--- a/src/Shared/ConversionUtilities.cs
+++ b/src/Shared/ConversionUtilities.cs
@@ -158,7 +158,7 @@ private static bool ValidHexNumber(string number)
         private static bool ValidDecimalNumber(string number)
         {
             double value;
-            return Double.TryParse(number, NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture.NumberFormat, out value);
+            return Double.TryParse(number, NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture.NumberFormat, out value) && !double.IsInfinity(value);
         }
 
         /// <summary>
diff --git a/src/Shared/CopyOnWriteDictionary.cs b/src/Shared/CopyOnWriteDictionary.cs
index 6b1820bc5d5..7059463de3b 100644
--- a/src/Shared/CopyOnWriteDictionary.cs
+++ b/src/Shared/CopyOnWriteDictionary.cs
@@ -1,4 +1,4 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
@@ -91,11 +91,11 @@ internal CopyOnWriteDictionary(int capacity, IEqualityComparer<string>? keyCompa
         [SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "context", Justification = "Not needed")]
         protected CopyOnWriteDictionary(SerializationInfo info, StreamingContext context)
         {
-            object v = info.GetValue(nameof(_backing), typeof(KeyValuePair<string, V>[]));
+            object v = info.GetValue(nameof(_backing), typeof(KeyValuePair<string, V>[]))!;
 
-            object comparer = info.GetValue(nameof(Comparer), typeof(IEqualityComparer<string>));
+            object comparer = info.GetValue(nameof(Comparer), typeof(IEqualityComparer<string>))!;
 
-            var b = GetInitialDictionary((IEqualityComparer<string>)comparer);
+            var b = GetInitialDictionary((IEqualityComparer<string>?)comparer);
 
             _backing = b.AddRange((KeyValuePair<string, V>[])v);
         }
@@ -227,6 +227,18 @@ public void Add(string key, V value)
             _backing = _backing.SetItem(key, value);
         }
 
+        /// <summary>
+        /// Adds several value to the dictionary.
+        /// </summary>
+        public void SetItems(IEnumerable<KeyValuePair<string, V>> items)
+        {
+            _backing = _backing.SetItems(items);
+        }
+
+        public IEnumerable<KeyValuePair<string, V>> Where(Func<KeyValuePair<string, V>, bool> predicate)
+        {
+            return _backing.Where(predicate);
+        }
         /// <summary>
         /// Returns true if the dictionary contains the specified key.
         /// </summary>
diff --git a/src/Shared/ErrorUtilities.cs b/src/Shared/ErrorUtilities.cs
index b1332593d52..be59150401f 100644
--- a/src/Shared/ErrorUtilities.cs
+++ b/src/Shared/ErrorUtilities.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections.Generic;
 using System.IO;
 using System.Diagnostics;
 using System.Globalization;
@@ -743,6 +744,37 @@ internal static void VerifyThrowArgumentLength(string parameter, string paramete
                 throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Shared.ParameterCannotHaveZeroLength", parameterName));
             }
         }
+
+#if !CLR2COMPATIBILITY
+        /// <summary>
+        /// Throws an ArgumentNullException if the given collection is null
+        /// and ArgumentException if it has zero length.
+        /// </summary>
+        /// <param name="parameter"></param>
+        /// <param name="parameterName"></param>
+        internal static void VerifyThrowArgumentLength<T>(IReadOnlyCollection<T> parameter, string parameterName)
+        {
+            VerifyThrowArgumentNull(parameter, parameterName);
+
+            if (parameter.Count == 0 && s_throwExceptions)
+            {
+                throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Shared.ParameterCannotHaveZeroLength", parameterName));
+            }
+        }
+
+        /// <summary>
+        /// Throws an ArgumentException if the given collection is not null but of zero length.
+        /// </summary>
+        /// <param name="parameter"></param>
+        /// <param name="parameterName"></param>
+        internal static void VerifyThrowArgumentLengthIfNotNull<T>(IReadOnlyCollection<T> parameter, string parameterName)
+        {
+            if (parameter?.Count == 0 && s_throwExceptions)
+            {
+                throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Shared.ParameterCannotHaveZeroLength", parameterName));
+            }
+        }
+#endif
         
         /// <summary>
         /// Throws an ArgumentNullException if the given string parameter is null
diff --git a/src/Shared/EscapingUtilities.cs b/src/Shared/EscapingUtilities.cs
index a8d86f06c31..2f0082459b3 100644
--- a/src/Shared/EscapingUtilities.cs
+++ b/src/Shared/EscapingUtilities.cs
@@ -6,6 +6,8 @@
 using System.Globalization;
 using System.Text;
 
+using Microsoft.NET.StringTools;
+
 namespace Microsoft.Build.Shared
 {
     /// <summary>
@@ -181,7 +183,7 @@ private static string EscapeWithOptionalCaching(string unescapedString, bool cac
                 return StringBuilderCache.GetStringAndRelease(escapedStringBuilder);
             }
 
-            string escapedString = OpportunisticIntern.StringBuilderToString(escapedStringBuilder);
+            string escapedString = Strings.WeakIntern(escapedStringBuilder.ToString());
             StringBuilderCache.Release(escapedStringBuilder);
 
             lock (s_unescapedToEscapedStrings)
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index a9c8fa2b2f3..ba1fbfd01d3 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -31,6 +31,8 @@ internal class FileMatcher
         private static readonly char[] s_wildcardCharacters = { '*', '?' };
         private static readonly char[] s_wildcardAndSemicolonCharacters = { '*', '?', ';' };
 
+        private static readonly string[] s_propertyAndItemReferences = { "$(", "@(" };
+
         // on OSX both System.IO.Path separators are '/', so we have to use the literals
         internal static readonly char[] directorySeparatorCharacters = { '/', '\\' };
         internal static readonly string[] directorySeparatorStrings = directorySeparatorCharacters.Select(c => c.ToString()).ToArray();
@@ -166,8 +168,6 @@ internal static void ClearFileEnumerationsCache()
         /// <summary>
         /// Determines whether the given path has any wild card characters.
         /// </summary>
-        /// <param name="filespec"></param>
-        /// <returns></returns>
         internal static bool HasWildcards(string filespec)
         {
             // Perf Note: Doing a [Last]IndexOfAny(...) is much faster than compiling a
@@ -180,18 +180,33 @@ internal static bool HasWildcards(string filespec)
         }
 
         /// <summary>
-        /// Determines whether the given path has any wild card characters or any semicolons.
+        /// Determines whether the given path has any wild card characters or semicolons.
+        /// </summary>
+        internal static bool HasWildcardsOrSemicolon(string filespec)
+        {
+            return -1 != filespec.LastIndexOfAny(s_wildcardAndSemicolonCharacters);
+        }
+
+        /// <summary>
+        /// Determines whether the given path has any wild card characters, any semicolons or any property references.
         /// </summary>
         internal static bool HasWildcardsSemicolonItemOrPropertyReferences(string filespec)
         {
             return
 
                 (-1 != filespec.IndexOfAny(s_wildcardAndSemicolonCharacters)) ||
-                filespec.Contains("$(") ||
-                filespec.Contains("@(")
+                HasPropertyOrItemReferences(filespec)
                 ;
         }
 
+        /// <summary>
+        /// Determines whether the given path has any property references.
+        /// </summary>
+        internal static bool HasPropertyOrItemReferences(string filespec)
+        {
+            return s_propertyAndItemReferences.Any(filespec.Contains);
+        }
+
         /// <summary>
         /// Get the files and\or folders specified by the given path and pattern.
         /// </summary>
@@ -2390,7 +2405,7 @@ private string[] GetFilesImplementation(
                 // Set to use only half processors when we have 4 or more of them, in order to not be too aggresive
                 // By setting MaxTasksPerIteration to the maximum amount of tasks, which means that only one
                 // Parallel.ForEach will run at once, we get a stable number of threads being created.
-                var maxTasks = Math.Max(1, Environment.ProcessorCount / 2);
+                var maxTasks = Math.Max(1, NativeMethodsShared.GetLogicalCoreCount() / 2);
                 var taskOptions = new TaskOptions(maxTasks)
                 {
                     AvailableTasks = maxTasks,
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index f942b9da01b..f35269ebf38 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -4,6 +4,8 @@
 using System;
 #if !CLR2COMPATIBILITY
 using System.Collections.Concurrent;
+#else
+using Microsoft.Build.Shared.Concurrent;
 #endif
 using System.Collections.Generic;
 using System.Diagnostics;
@@ -107,11 +109,8 @@ public static bool GetIsFileSystemCaseSensitive()
 
         internal static readonly string DirectorySeparatorString = Path.DirectorySeparatorChar.ToString();
 
-#if !CLR2COMPATIBILITY
         private static readonly ConcurrentDictionary<string, bool> FileExistenceCache = new ConcurrentDictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
-#else
-        private static readonly Microsoft.Build.Shared.Concurrent.ConcurrentDictionary<string, bool> FileExistenceCache = new Microsoft.Build.Shared.Concurrent.ConcurrentDictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
-#endif
+
         private static readonly IFileSystem DefaultFileSystem = FileSystems.Default;
 
         /// <summary>
@@ -451,6 +450,7 @@ internal static string FixFilePath(string path)
             return string.IsNullOrEmpty(path) || Path.DirectorySeparatorChar == '\\' ? path : path.Replace('\\', '/');//.Replace("//", "/");
         }
 
+#if !CLR2COMPATIBILITY
         /// <summary>
         /// If on Unix, convert backslashes to slashes for strings that resemble paths.
         /// The heuristic is if something resembles paths (contains slashes) check if the
@@ -474,60 +474,13 @@ internal static string MaybeAdjustFilePath(string value, string baseDirectory =
             }
 
             // For Unix-like systems, we may want to convert backslashes to slashes
-#if FEATURE_SPAN
             Span<char> newValue = ConvertToUnixSlashes(value.ToCharArray());
-#else
-            string newValue = ConvertToUnixSlashes(value);
-#endif
 
             // Find the part of the name we want to check, that is remove quotes, if present
             bool shouldAdjust = newValue.IndexOf('/') != -1 && LooksLikeUnixFilePath(RemoveQuotes(newValue), baseDirectory);
             return shouldAdjust ? newValue.ToString() : value;
         }
 
-#if !FEATURE_SPAN
-        private static string ConvertToUnixSlashes(string path)
-        {
-            if (path.IndexOf('\\') == -1)
-            {
-                return path;
-            }
-            StringBuilder unixPath = StringBuilderCache.Acquire(path.Length);
-            CopyAndCollapseSlashes(path, unixPath);
-            return StringBuilderCache.GetStringAndRelease(unixPath);
-        }
-
-#if !CLR2COMPATIBILITY && !FEATURE_SPAN
-        [MethodImpl(MethodImplOptions.AggressiveInlining)]
-#endif
-        private static void CopyAndCollapseSlashes(string str, StringBuilder copy)
-        {
-            // Performs Regex.Replace(str, @"[\\/]+", "/")
-            for (int i = 0; i < str.Length; i++)
-            {
-                bool isCurSlash = IsAnySlash(str[i]);
-                bool isPrevSlash = i > 0 && IsAnySlash(str[i - 1]);
-
-                if (!isCurSlash || !isPrevSlash)
-                {
-                    copy.Append(str[i] == '\\' ? '/' : str[i]);
-                }
-            }
-        }
-
-        private static string RemoveQuotes(string path)
-        {
-            int endId = path.Length - 1;
-            char singleQuote = '\'';
-            char doubleQuote = '\"';
-
-            bool hasQuotes = path.Length > 2
-                && ((path[0] == singleQuote && path[endId] == singleQuote)
-                || (path[0] == doubleQuote && path[endId] == doubleQuote));
-
-            return hasQuotes ? path.Substring(1, endId - 1) : path;
-        }
-#else
         private static Span<char> ConvertToUnixSlashes(Span<char> path)
         {
             return path.IndexOf('\\') == -1 ? path : CollapseSlashes(path);
@@ -573,6 +526,7 @@ private static Span<char> RemoveQuotes(Span<char> path)
 #endif
         internal static bool IsAnySlash(char c) => c == '/' || c == '\\';
 
+#if !CLR2COMPATIBILITY
         /// <summary>
         /// If on Unix, check if the string looks like a file path.
         /// The heuristic is if something resembles paths (contains slashes) check if the
@@ -582,24 +536,8 @@ private static Span<char> RemoveQuotes(Span<char> path)
         /// that
         /// </summary>
         internal static bool LooksLikeUnixFilePath(string value, string baseDirectory = "")
-        {
-            if (NativeMethodsShared.IsWindows)
-            {
-                return false;
-            }
-
-            // The first slash will either be at the beginning of the string or after the first directory name
-            int directoryLength = value.IndexOf('/', 1) + 1;
-            bool shouldCheckDirectory = directoryLength != 0;
-
-            // Check for actual files or directories under / that get missed by the above logic
-            bool shouldCheckFileOrDirectory = !shouldCheckDirectory && value.Length > 0 && value[0] == '/';
-
-            return (shouldCheckDirectory && DefaultFileSystem.DirectoryExists(Path.Combine(baseDirectory, value.Substring(0, directoryLength))))
-                || (shouldCheckFileOrDirectory && DefaultFileSystem.DirectoryEntryExists(value));
-        }
+            => LooksLikeUnixFilePath(value.AsSpan(), baseDirectory);
 
-#if FEATURE_SPAN
         internal static bool LooksLikeUnixFilePath(ReadOnlySpan<char> value, string baseDirectory = "")
         {
             if (NativeMethodsShared.IsWindows)
diff --git a/src/Shared/IInternable.cs b/src/Shared/IInternable.cs
deleted file mode 100644
index 9bfa741e097..00000000000
--- a/src/Shared/IInternable.cs
+++ /dev/null
@@ -1,341 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-using System.Text;
-using Microsoft.Build.Shared;
-
-namespace Microsoft.Build
-{
-    #region IInternable
-    /// <summary>
-    /// Define the methods needed to intern something.
-    /// </summary>
-    internal interface IInternable
-    {
-        /// <summary>
-        /// The length of the target.
-        /// </summary>
-        int Length { get; }
-
-        /// <summary>
-        /// Indexer into the target. Presumed to be fast.
-        /// </summary>
-        char this[int index] { get; }
-
-        /// <summary>
-        /// Convert target to string. Presumed to be slow (and will be called just once).
-        /// </summary>
-        string ExpensiveConvertToString();
-
-        /// <summary>
-        /// Compare target to string. Assumes string is of equal or smaller length than target.
-        /// </summary>
-        bool StartsWithStringByOrdinalComparison(string other);
-
-        /// <summary>
-        /// Reference compare target to string. If target is non-string this should return false.
-        /// </summary>
-        bool ReferenceEquals(string other);
-    }
-    #endregion
-
-
-    #region IInternable Implementations
-    /// <summary>
-    /// A wrapper over StringBuilder.
-    /// </summary>
-    internal readonly struct StringBuilderInternTarget : IInternable
-    {
-        /// <summary>
-        /// The held StringBuilder
-        /// </summary>
-        private readonly StringBuilder _target;
-
-        /// <summary>
-        /// Pointless comment about constructor.
-        /// </summary>
-        internal StringBuilderInternTarget(StringBuilder target)
-        {
-            _target = target;
-        }
-
-        /// <summary>
-        /// The length of the target.
-        /// </summary>
-        public int Length => _target.Length;
-
-        /// <summary>
-        /// Indexer into the target. Presumed to be fast.
-        /// </summary>
-        public char this[int index] => _target[index];
-
-        /// <summary>
-        /// Never reference equals to string.
-        /// </summary>
-        public bool ReferenceEquals(string other) => false;
-
-        /// <summary>
-        /// Convert target to string. Presumed to be slow (and will be called just once).
-        /// </summary>
-        public string ExpensiveConvertToString()
-        {
-            // PERF NOTE: This will be an allocation hot-spot because the StringBuilder is finally determined to
-            // not be internable. There is still only one conversion of StringBuilder into string it has just
-            // moved into this single spot.
-            return _target.ToString();
-        }
-
-        /// <summary>
-        /// Compare target to string. Assumes string is of equal or smaller length than target.
-        /// </summary>
-        public bool StartsWithStringByOrdinalComparison(string other)
-        {
-#if DEBUG
-            ErrorUtilities.VerifyThrow(other.Length <= _target.Length, "should be at most as long as target");
-#endif
-            int length = other.Length;
-
-            // Backwards because the end of the string is more likely to be different earlier in the loop.
-            // For example, C:\project1, C:\project2
-            for (int i = length - 1; i >= 0; --i)
-            {
-                if (_target[i] != other[i])
-                {
-                    return false;
-                }
-            }
-
-            return true;
-        }
-
-        /// <summary>
-        /// Don't use this function. Use ExpensiveConvertToString
-        /// </summary>
-        public override string ToString() => throw new InvalidOperationException();
-    }
-
-    /// <summary>
-    /// A wrapper over char[].
-    /// </summary>
-    internal readonly struct CharArrayInternTarget : IInternable
-    {
-        /// <summary>
-        /// Start index for the string
-        /// </summary>
-        private readonly int _startIndex;
-
-        /// <summary>
-        /// The held array
-        /// </summary>
-        private readonly char[] _target;
-
-        /// <summary>
-        /// Pointless comment about constructor.
-        /// </summary>
-        internal CharArrayInternTarget(char[] target, int count)
-            : this(target, 0, count)
-        {
-        }
-
-        /// <summary>
-        /// Pointless comment about constructor.
-        /// </summary>
-        internal CharArrayInternTarget(char[] target, int startIndex, int count)
-        {
-#if DEBUG
-            if (startIndex + count > target.Length)
-            {
-                ErrorUtilities.ThrowInternalError("wrong length");
-            }
-#endif
-            _target = target;
-            _startIndex = startIndex;
-            Length = count;
-        }
-
-        /// <summary>
-        /// The length of the target.
-        /// </summary>
-        public int Length { get; }
-
-        /// <summary>
-        /// Indexer into the target. Presumed to be fast.
-        /// </summary>
-        public char this[int index]
-        {
-            get
-            {
-                return _target[index + _startIndex];
-            }
-        }
-
-        /// <summary>
-        /// Convert target to string. Presumed to be slow (and will be called just once).
-        /// </summary>
-        public bool ReferenceEquals(string other)
-        {
-            return false;
-        }
-
-        /// <summary>
-        /// Convert target to string. Presumed to be slow (and will be called just once).
-        /// </summary>
-        public string ExpensiveConvertToString()
-        {
-            // PERF NOTE: This will be an allocation hot-spot because the char[] is finally determined to
-            // not be internable. There is still only one conversion of char[] into string it has just
-            // moved into this single spot.
-            return new string(_target, _startIndex, Length);
-        }
-
-        /// <summary>
-        /// Compare target to string. Assumes string is of equal or smaller length than target.
-        /// </summary>
-        public bool StartsWithStringByOrdinalComparison(string other)
-        {
-#if DEBUG
-            ErrorUtilities.VerifyThrow(other.Length <= Length, "should be at most as long as target");
-#endif
-            // Backwards because the end of the string is (by observation of Australian Government build) more likely to be different earlier in the loop.
-            // For example, C:\project1, C:\project2
-            for (int i = other.Length - 1; i >= 0; --i)
-            {
-                if (_target[i + _startIndex] != other[i])
-                {
-                    return false;
-                }
-            }
-
-            return true;
-        }
-
-        /// <summary>
-        /// Don't use this function. Use ExpensiveConvertToString
-        /// </summary>
-        public override string ToString()
-        {
-            throw new InvalidOperationException();
-        }
-    }
-
-    /// <summary>
-    /// Wrapper over a string.
-    /// </summary>
-    internal readonly struct StringInternTarget : IInternable
-    {
-        /// <summary>
-        /// Stores the wrapped string.
-        /// </summary>
-        private readonly string _target;
-
-        /// <summary>
-        /// Constructor of the class
-        /// </summary>
-        /// <param name="target">The string to wrap</param>
-        internal StringInternTarget(string target)
-        {
-            ErrorUtilities.VerifyThrowArgumentLength(target, nameof(target));
-            _target = target;
-        }
-
-        /// <summary>
-        /// Gets the length of the target string.
-        /// </summary>
-        public int Length => _target.Length;
-
-        /// <summary>
-        /// Gets the n character in the target string.
-        /// </summary>
-        /// <param name="index">Index of the character to gather.</param>
-        /// <returns>The character in the position marked by index.</returns>
-        public char this[int index] => _target[index];
-
-        /// <summary>
-        /// Returns the target which is already a string.
-        /// </summary>
-        /// <returns>The target string.</returns>
-        public string ExpensiveConvertToString() => _target;
-
-        /// <summary>
-        /// Compare target to string. Assumes string is of equal or smaller length than target.
-        /// </summary>
-        /// <param name="other">The string to compare with the target.</param>
-        /// <returns>True if target starts with <paramref name="other"/>, false otherwise.</returns>
-        public bool StartsWithStringByOrdinalComparison(string other) => _target.StartsWith(other, StringComparison.Ordinal);
-
-        /// <summary>
-        /// Verifies if the reference of the target string is the same of the given string.
-        /// </summary>
-        /// <param name="other">The string reference to compare to.</param>
-        /// <returns>True if both references are equal, false otherwise.</returns>
-        public bool ReferenceEquals(string other) => ReferenceEquals(_target, other);
-    }
-
-    /// <summary>
-    /// Wrapper over a substring of a string.
-    /// </summary>
-    internal readonly struct SubstringInternTarget : IInternable
-    {
-        /// <summary>
-        /// Stores the wrapped string.
-        /// </summary>
-        private readonly string _target;
-
-        /// <summary>
-        /// Start index of the substring within the wrapped string.
-        /// </summary>
-        private readonly int _startIndex;
-
-        /// <summary>
-        /// Constructor of the class
-        /// </summary>
-        /// <param name="target">The string to wrap.</param>
-        /// <param name="startIndex">Start index of the substring within <paramref name="target"/>.</param>
-        /// <param name="length">Length of the substring.</param>
-        internal SubstringInternTarget(string target, int startIndex, int length)
-        {
-#if DEBUG
-            if (startIndex + length > target.Length)
-            {
-                ErrorUtilities.ThrowInternalError("wrong length");
-            }
-#endif
-            _target = target;
-            _startIndex = startIndex;
-            Length = length;
-        }
-
-        /// <summary>
-        /// Gets the length of the target substring.
-        /// </summary>
-        public int Length { get; }
-
-        /// <summary>
-        /// Gets the n character in the target substring.
-        /// </summary>
-        /// <param name="index">Index of the character to gather.</param>
-        /// <returns>The character in the position marked by index.</returns>
-        public char this[int index] => _target[index + _startIndex];
-
-        /// <summary>
-        /// Returns the target substring as a string.
-        /// </summary>
-        /// <returns>The substring.</returns>
-        public string ExpensiveConvertToString() => _target.Substring(_startIndex, Length);
-
-        /// <summary>
-        /// Compare target substring to a string. Assumes string is of equal or smaller length than the target substring.
-        /// </summary>
-        /// <param name="other">The string to compare with the target substring.</param>
-        /// <returns>True if target substring starts with <paramref name="other"/>, false otherwise.</returns>
-        public bool StartsWithStringByOrdinalComparison(string other) => String.CompareOrdinal(_target, _startIndex, other, 0, other.Length) == 0;
-
-        /// <summary>
-        /// Never reference equals to string.
-        /// </summary>
-        public bool ReferenceEquals(string other) => false;
-    }
-
-    #endregion
-}
diff --git a/src/Shared/InterningBinaryReader.cs b/src/Shared/InterningBinaryReader.cs
index 8eba40139be..40589a0becb 100644
--- a/src/Shared/InterningBinaryReader.cs
+++ b/src/Shared/InterningBinaryReader.cs
@@ -8,6 +8,8 @@
 
 using ErrorUtilities = Microsoft.Build.Shared.ErrorUtilities;
 
+using Microsoft.NET.StringTools;
+
 namespace Microsoft.Build
 {
     /// <summary>
@@ -38,7 +40,7 @@ internal class InterningBinaryReader : BinaryReader
         /// Comment about constructing.
         /// </summary>
         private InterningBinaryReader(Stream input, Buffer buffer)
-            : base(input, buffer.Encoding)
+            : base(input, Encoding.UTF8)
         {
             if (input == null)
             {
@@ -46,7 +48,7 @@ private InterningBinaryReader(Stream input, Buffer buffer)
             }
 
             _buffer = buffer;
-            _decoder = buffer.Encoding.GetDecoder();
+            _decoder = Encoding.UTF8.GetDecoder();
         }
 
         /// <summary>
@@ -63,7 +65,7 @@ override public String ReadString()
                 int n = 0;
                 int stringLength;
                 int readLength;
-                int charsRead;
+                int charsRead = 0;
 
                 // Length of the string in bytes, not chars
                 stringLength = Read7BitEncodedInt();
@@ -78,8 +80,7 @@ override public String ReadString()
                 }
 
                 char[] charBuffer = _buffer.CharBuffer;
-
-                StringBuilder sb = null;
+                char[] resultBuffer = null;
                 do
                 {
                     readLength = ((stringLength - currPos) > MaxCharsBuffer) ? MaxCharsBuffer : (stringLength - currPos);
@@ -104,6 +105,8 @@ override public String ReadString()
                         {
                             ErrorUtilities.ThrowInternalError("From calculating based on the memorystream, about to read n = {0}. length = {1}, rawPosition = {2}, readLength = {3}, stringLength = {4}, currPos = {5}.", n, length, rawPosition, readLength, stringLength, currPos);
                         }
+
+                        memoryStream.Seek(n, SeekOrigin.Current);
                     }
 
                     if (rawBuffer == null)
@@ -124,26 +127,20 @@ override public String ReadString()
                         throw new EndOfStreamException();
                     }
 
-                    charsRead = _decoder.GetChars(rawBuffer, rawPosition, n, charBuffer, 0);
-
-                    memoryStream?.Seek(readLength, SeekOrigin.Current);
-
                     if (currPos == 0 && n == stringLength)
                     {
-                        return OpportunisticIntern.CharArrayToString(charBuffer, charsRead);
+                        charsRead = _decoder.GetChars(rawBuffer, rawPosition, n, charBuffer, 0);
+                        return Strings.WeakIntern(charBuffer.AsSpan(0, charsRead));
                     }
 
-                    if (sb == null)
-                    {
-                        sb = new StringBuilder(stringLength); // Actual string length in chars may be smaller.
-                    }
+                    resultBuffer ??= new char[stringLength]; // Actual string length in chars may be smaller.
+                    charsRead += _decoder.GetChars(rawBuffer, rawPosition, n, resultBuffer, charsRead);
 
-                    sb.Append(charBuffer, 0, charsRead);
                     currPos += n;
                 }
                 while (currPos < stringLength);
 
-                return OpportunisticIntern.StringBuilderToString(sb);
+                return Strings.WeakIntern(resultBuffer.AsSpan(0, charsRead));
             }
             catch (Exception e)
             {
@@ -186,9 +183,8 @@ private class Buffer : SharedReadBuffer
             /// </summary>
             internal Buffer()
             {
-                this.Encoding = new UTF8Encoding();
                 this.CharBuffer = new char[MaxCharsBuffer];
-                this.ByteBuffer = new byte[Encoding.GetMaxByteCount(MaxCharsBuffer)];
+                this.ByteBuffer = new byte[Encoding.UTF8.GetMaxByteCount(MaxCharsBuffer)];
             }
 
             /// <summary>
@@ -208,15 +204,6 @@ internal byte[] ByteBuffer
                 get;
                 private set;
             }
-
-            /// <summary>
-            /// The encoding.
-            /// </summary>
-            internal UTF8Encoding Encoding
-            {
-                get;
-                private set;
-            }
         }
     }
 
diff --git a/src/Shared/MSBuildLoadContext.cs b/src/Shared/MSBuildLoadContext.cs
index df97ba927ce..d44b57480d4 100644
--- a/src/Shared/MSBuildLoadContext.cs
+++ b/src/Shared/MSBuildLoadContext.cs
@@ -1,4 +1,4 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 
@@ -25,16 +25,29 @@ internal class MSBuildLoadContext : AssemblyLoadContext
                 "MSBuild",
                 "Microsoft.Build",
                 "Microsoft.Build.Framework",
+                "Microsoft.Build.NuGetSdkResolver",
                 "Microsoft.Build.Tasks.Core",
                 "Microsoft.Build.Utilities.Core",
+                "NuGet.Build.Tasks",
+                "NuGet.Common",
+                "NuGet.Configuration",
+                "NuGet.Credentials",
+                "NuGet.DependencyResolver.Core",
+                "NuGet.Frameworks",
+                "NuGet.LibraryModel",
+                "NuGet.Packaging",
+                "NuGet.Protocol",
+                "NuGet.ProjectModel",
+                "NuGet.Versioning",
             }.ToImmutableHashSet();
 
         internal static readonly string[] Extensions = new[] { "ni.dll", "ni.exe", "dll", "exe" };
 
 
         public MSBuildLoadContext(string assemblyPath)
+            : base($"MSBuild plugin {assemblyPath}")
         {
-            _directory = Directory.GetParent(assemblyPath).FullName;
+            _directory = Directory.GetParent(assemblyPath)!.FullName;
         }
 
         protected override Assembly? Load(AssemblyName assemblyName)
@@ -82,7 +95,7 @@ public MSBuildLoadContext(string assemblyPath)
             //   into the default ALC (so it's shared with other uses).
 
             var assemblyNameInExecutableDirectory = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory,
-                assemblyName.Name);
+                assemblyName.Name!);
 
             if (FileSystems.Default.FileExists(assemblyNameInExecutableDirectory))
             {
diff --git a/src/Shared/NativeMethodsShared.cs b/src/Shared/NativeMethodsShared.cs
index 7d66b7731ce..4818d7eda9c 100644
--- a/src/Shared/NativeMethodsShared.cs
+++ b/src/Shared/NativeMethodsShared.cs
@@ -508,13 +508,42 @@ public SystemInformationData()
             }
         }
 
+        public static int GetLogicalCoreCount()
+        {
+            int numberOfCpus = Environment.ProcessorCount;
+#if !MONO
+            // .NET Core on Windows returns a core count limited to the current NUMA node
+            //     https://github.com/dotnet/runtime/issues/29686
+            // so always double-check it.
+            if (IsWindows
+#if !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
+                && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_8)
+#endif
+#if NETFRAMEWORK
+                // .NET Framework calls Windows APIs that have a core count limit (32/64 depending on process bitness).
+                // So if we get a high core count on full framework, double-check it.
+                && (numberOfCpus >= 32)
+#endif
+            )
+            {
+                var result = GetLogicalCoreCountOnWindows();
+                if (result != -1)
+                {
+                    numberOfCpus = result;
+                }
+            }
+#endif
+
+            return numberOfCpus;
+        }
+
         /// <summary>
         /// Get the exact physical core count on Windows
         /// Useful for getting the exact core count in 32 bits processes,
         /// as Environment.ProcessorCount has a 32-core limit in that case. 
         /// https://github.com/dotnet/runtime/blob/221ad5b728f93489655df290c1ea52956ad8f51c/src/libraries/System.Runtime.Extensions/src/System/Environment.Windows.cs#L171-L210
         /// </summary>
-        public unsafe static int GetLogicalCoreCount()
+        private unsafe static int GetLogicalCoreCountOnWindows()
         {
             uint len = 0;
             const int ERROR_INSUFFICIENT_BUFFER = 122;
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 462615f5505..c58bc449a1c 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -1,4 +1,4 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
@@ -99,6 +99,16 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
         /// </summary>
         private SharedReadBuffer _sharedReadBuffer;
 
+        /// <summary>
+        /// A way to cache a byte array when writing out packets
+        /// </summary>
+        private MemoryStream _packetStream;
+
+        /// <summary>
+        /// A binary writer to help write into <see cref="_packetStream"/>
+        /// </summary>
+        private BinaryWriter _binaryWriter;
+
 #endregion
 
 #region INodeEndpoint Events
@@ -189,6 +199,9 @@ internal void InternalConstruct(string pipeName)
             _asyncDataMonitor = new object();
             _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();
 
+            _packetStream = new MemoryStream();
+            _binaryWriter = new BinaryWriter(_packetStream);
+
 #if FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR
             if (!NativeMethodsShared.IsMono)
             {
@@ -472,7 +485,13 @@ private void PacketPumpProc()
             {
                 if (localPipeServer.IsConnected)
                 {
-                    localPipeServer.WaitForPipeDrain();
+#if NETCOREAPP // OperatingSystem.IsWindows() is new in .NET 5.0
+                    if (OperatingSystem.IsWindows())
+#endif
+                    {
+                        localPipeServer.WaitForPipeDrain();
+                    }
+
                     localPipeServer.Disconnect();
                 }
             }
@@ -584,22 +603,26 @@ private void RunReadLoop(Stream localReadPipe, Stream localWritePipe,
                             INodePacket packet;
                             while (localPacketQueue.TryDequeue(out packet))
                             {
-                                MemoryStream packetStream = new MemoryStream();
+                                var packetStream = _packetStream;
+                                packetStream.SetLength(0);
+
                                 ITranslator writeTranslator = BinaryTranslator.GetWriteTranslator(packetStream);
 
                                 packetStream.WriteByte((byte)packet.Type);
 
                                 // Pad for packet length
-                                packetStream.Write(BitConverter.GetBytes((int)0), 0, 4);
+                                _binaryWriter.Write(0);
 
                                 // Reset the position in the write buffer.
                                 packet.Translate(writeTranslator);
 
+                                int packetStreamLength = (int)packetStream.Position;
+
                                 // Now write in the actual packet length
                                 packetStream.Position = 1;
-                                packetStream.Write(BitConverter.GetBytes((int)packetStream.Length - 5), 0, 4);
+                                _binaryWriter.Write(packetStreamLength - 5);
 
-                                localWritePipe.Write(packetStream.GetBuffer(), 0, (int)packetStream.Length);
+                                localWritePipe.Write(packetStream.GetBuffer(), 0, packetStreamLength);
                             }
                         }
                         catch (Exception e)
diff --git a/src/Shared/OpportunisticIntern.cs b/src/Shared/OpportunisticIntern.cs
deleted file mode 100644
index 6da9e42a34c..00000000000
--- a/src/Shared/OpportunisticIntern.cs
+++ /dev/null
@@ -1,1093 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-#if !CLR2COMPATIBILITY
-using System.Collections.Concurrent;
-#endif
-using System.Text;
-using System.Linq;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Globalization;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
-
-namespace Microsoft.Build
-{
-    /// <summary>
-    /// This class is used to selectively intern strings. It should be used at the point of new string creation.
-    /// For example,
-    ///
-    ///     string interned = OpportunisticIntern.Intern(String.Join(",",someStrings));
-    ///
-    /// There are currently two underlying implementations. The new default one in WeakStringCacheInterner is based on weak GC handles.
-    /// The legacy one in BucketedPrioritizedStringList is available only as an escape hatch by setting an environment variable.
-    ///
-    /// The legacy implementation uses heuristics to decide whether it will be efficient to intern a string or not. There is no
-    /// guarantee that a string will intern.
-    ///
-    /// The thresholds and sizes were determined by experimentation to give the best number of bytes saved
-    /// at reasonable elapsed time cost.
-    ///
-    /// The new implementation interns all strings but maintains only weak references so it doesn't keep the strings alive.
-    /// </summary>
-    internal sealed class OpportunisticIntern
-    {
-        /// <summary>
-        /// Defines the interner interface as we currently implement more than one.
-        /// </summary>
-        private interface IInternerImplementation
-        {
-            /// <summary>
-            /// Converts the given internable candidate to its string representation. Efficient implementions have side-effects
-            /// of caching the results to end up with as few duplicates on the managed heap as practical.
-            /// </summary>
-            string InterningToString<T>(T candidate) where T : IInternable;
-
-            /// <summary>
-            /// Prints implementation specific interning statistics to the console.
-            /// </summary>
-            /// <param name="heading">A string identifying the interner in the output.</param>
-            void ReportStatistics(string heading);
-        }
-
-        /// <summary>
-        /// The singleton instance of OpportunisticIntern.
-        /// </summary>
-        private static OpportunisticIntern _instance = new OpportunisticIntern();
-        internal static OpportunisticIntern Instance => _instance;
-
-        private readonly bool _useLegacyInterner = Traits.Instance.UseLegacyStringInterner;
-        private readonly bool _useSimpleConcurrency = Traits.Instance.UseSimpleInternConcurrency;
-
-        /// <summary>
-        /// The size of the small mru list.
-        /// </summary>
-        private readonly int _smallMruSize;
-
-        /// <summary>
-        /// The size of the large mru list.
-        /// </summary>
-        private readonly int _largeMruSize;
-
-        /// <summary>
-        /// The size of the huge mru list.
-        /// </summary>
-        private readonly int _hugeMruSize;
-
-        /// <summary>
-        /// The smallest size a string can be to be considered small.
-        /// </summary>
-        private readonly int _smallMruThreshold;
-
-        /// <summary>
-        /// The smallest size a string can be to be considered large.
-        /// </summary>
-        private readonly int _largeMruThreshold;
-
-        /// <summary>
-        /// The smallest size a string can be to be considered huge.
-        /// </summary>
-        private readonly int _hugeMruThreshold;
-
-        /// <summary>
-        /// The smallest size a string can be to be ginormous.
-        /// 8K for large object heap.
-        /// </summary>
-        private readonly int _ginormousThreshold;
-
-        /// <summary>
-        /// The interner implementation in use.
-        /// </summary>
-        private IInternerImplementation _interner;
-
-        #region Statistics
-        /// <summary>
-        /// What if Mru lists were infinitely long?
-        /// </summary>
-        private BucketedPrioritizedStringList _whatIfInfinite;
-
-        /// <summary>
-        /// What if we doubled the size of the Mru lists?
-        /// </summary>
-        private BucketedPrioritizedStringList _whatIfDoubled;
-
-        /// <summary>
-        /// What if we halved the size of the Mru lists?
-        /// </summary>
-        private BucketedPrioritizedStringList _whatIfHalved;
-
-        /// <summary>
-        /// What if the size of Mru lists was zero? (We still intern tiny strings in this case)
-        /// </summary>
-        private BucketedPrioritizedStringList _whatIfZero;
-        #endregion
-
-        private OpportunisticIntern()
-        {
-            _smallMruSize = AssignViaEnvironment("MSBUILDSMALLINTERNSIZE", 50);
-            _largeMruSize = AssignViaEnvironment("MSBUILDLARGEINTERNSIZE", 100);
-            _hugeMruSize = AssignViaEnvironment("MSBUILDHUGEINTERNSIZE", 100);
-            _smallMruThreshold = AssignViaEnvironment("MSBUILDSMALLINTERNTHRESHOLD", 50);
-            _largeMruThreshold = AssignViaEnvironment("MSBUILDLARGEINTERNTHRESHOLD", 70);
-            _hugeMruThreshold = AssignViaEnvironment("MSBUILDHUGEINTERNTHRESHOLD", 200);
-            _ginormousThreshold = AssignViaEnvironment("MSBUILDGINORMOUSINTERNTHRESHOLD", 8000);
-
-            _interner = _useLegacyInterner
-               ? (IInternerImplementation)new BucketedPrioritizedStringList(gatherStatistics: false, _smallMruSize, _largeMruSize, _hugeMruSize,
-                    _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency)
-               : (IInternerImplementation)new WeakStringCacheInterner(gatherStatistics: false);
-        }
-
-        /// <summary>
-        /// Recreates the singleton instance based on the current environment (test only).
-        /// </summary>
-        internal static void ResetForTests()
-        {
-            Debug.Assert(BuildEnvironmentHelper.Instance.RunningTests);
-            _instance = new OpportunisticIntern();
-        }
-
-        /// <summary>
-        /// Assign an int from an environment variable. If its not present, use the default.
-        /// </summary>
-        private int AssignViaEnvironment(string env, int @default)
-        {
-            string threshold = Environment.GetEnvironmentVariable(env);
-            if (!string.IsNullOrEmpty(threshold))
-            {
-                if (int.TryParse(threshold, out int result))
-                {
-                    return result;
-                }
-            }
-
-            return @default;
-        }
-
-        /// <summary>
-        /// Turn on statistics gathering.
-        /// </summary>
-        internal void EnableStatisticsGathering()
-        {
-            if (_useLegacyInterner)
-            {
-                // Statistics include several 'what if' scenarios such as doubling the size of the MRU lists.
-                _interner = new BucketedPrioritizedStringList(gatherStatistics: true, _smallMruSize, _largeMruSize, _hugeMruSize, _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency);
-                _whatIfInfinite = new BucketedPrioritizedStringList(gatherStatistics: true, int.MaxValue, int.MaxValue, int.MaxValue, _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency);
-                _whatIfDoubled = new BucketedPrioritizedStringList(gatherStatistics: true, _smallMruSize * 2, _largeMruSize * 2, _hugeMruSize * 2, _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency);
-                _whatIfHalved = new BucketedPrioritizedStringList(gatherStatistics: true, _smallMruSize / 2, _largeMruSize / 2, _hugeMruSize / 2, _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency);
-                _whatIfZero = new BucketedPrioritizedStringList(gatherStatistics: true, 0, 0, 0, _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency);
-            }
-            else
-            {
-                _interner = new WeakStringCacheInterner(gatherStatistics: true);
-            }
-        }
-
-        /// <summary>
-        /// Intern the given internable.
-        /// </summary>
-        internal static string InternableToString<T>(T candidate) where T : IInternable
-        {
-            return Instance.InternableToStringImpl(candidate);
-        }
-
-        /// <summary>
-        /// Potentially Intern the given string builder.
-        /// </summary>
-        internal static string StringBuilderToString(StringBuilder candidate)
-        {
-            return Instance.InternableToStringImpl(new StringBuilderInternTarget(candidate));
-        }
-
-        /// <summary>
-        /// Potentially Intern the given char array.
-        /// </summary>
-        internal static string CharArrayToString(char[] candidate, int count)
-        {
-            return Instance.InternableToStringImpl(new CharArrayInternTarget(candidate, count));
-        }
-
-        /// <summary>
-        /// Potentially Intern the given char array.
-        /// </summary>
-        internal static string CharArrayToString(char[] candidate, int startIndex, int count)
-        {
-            return Instance.InternableToStringImpl(new CharArrayInternTarget(candidate, startIndex, count));
-        }
-
-        /// <summary>
-        /// Potentially Intern the given string.
-        /// </summary>
-        /// <param name="candidate">The string to intern.</param>
-        /// <returns>The interned string, or the same string if it could not be interned.</returns>
-        internal static string InternStringIfPossible(string candidate)
-        {
-            return Instance.InternableToStringImpl(new StringInternTarget(candidate));
-        }
-
-        /// <summary>
-        /// Intern the given internable.
-        /// </summary>
-        private string InternableToStringImpl<T>(T candidate) where T : IInternable
-        {
-            if (candidate.Length == 0)
-            {
-                // As in the case that a property or itemlist has evaluated to empty.
-                return string.Empty;
-            }
-
-            if (_whatIfInfinite != null)
-            {
-                _whatIfInfinite.InterningToString(candidate);
-                _whatIfDoubled.InterningToString(candidate);
-                _whatIfHalved.InterningToString(candidate);
-                _whatIfZero.InterningToString(candidate);
-            }
-
-            string result = _interner.InterningToString(candidate);
-#if DEBUG
-            string expected = candidate.ExpensiveConvertToString();
-            if (!String.Equals(result, expected))
-            {
-                ErrorUtilities.ThrowInternalError("Interned string {0} should have been {1}", result, expected);
-            }
-#endif
-            return result;
-        }
-
-        /// <summary>
-        /// Report statistics about interning. Don't call unless GatherStatistics has been called beforehand.
-        /// </summary>
-        internal void ReportStatistics()
-        {
-            _interner.ReportStatistics("Main");
-            if (_useLegacyInterner)
-            {
-                _whatIfInfinite.ReportStatistics("if Infinite");
-                _whatIfDoubled.ReportStatistics("if Doubled");
-                _whatIfHalved.ReportStatistics("if Halved");
-                _whatIfZero.ReportStatistics("if Zero");
-                Console.WriteLine(" * Even for MRU size of zero there will still be some intern hits because of the tiny ");
-                Console.WriteLine("   string matching (eg. 'true')");
-            }
-        }
-
-        private static bool TryInternHardcodedString<T>(T candidate, string str, ref string interned) where T : IInternable
-        {
-            Debug.Assert(candidate.Length == str.Length);
-
-            if (candidate.StartsWithStringByOrdinalComparison(str))
-            {
-                interned = str;
-                return true;
-            }
-            return false;
-        }
-
-        /// <summary>
-        /// Try to match the candidate with small number of hardcoded interned string literals.
-        /// The return value indicates how the string was interned (if at all).
-        /// </summary>
-        /// <returns>
-        /// True if the candidate matched a hardcoded literal, null if it matched a "do not intern" string, false otherwise.
-        /// </returns>
-        private static bool? TryMatchHardcodedStrings<T>(T candidate, out string interned) where T : IInternable
-        {
-            int length = candidate.Length;
-            interned = null;
-
-            // Each of the hard-coded small strings below showed up in a profile run with considerable duplication in memory.
-            if (length == 2)
-            {
-                if (candidate[1] == '#')
-                {
-                    if (candidate[0] == 'C')
-                    {
-                        interned = "C#";
-                        return true;
-                    }
-
-                    if (candidate[0] == 'F')
-                    {
-                        interned = "F#";
-                        return true;
-                    }
-                }
-
-                if (candidate[0] == 'V' && candidate[1] == 'B')
-                {
-                    interned = "VB";
-                    return true;
-                }
-            }
-            else if (length == 4)
-            {
-                if (TryInternHardcodedString(candidate, "TRUE", ref interned) ||
-                    TryInternHardcodedString(candidate, "True", ref interned) ||
-                    TryInternHardcodedString(candidate, "Copy", ref interned) ||
-                    TryInternHardcodedString(candidate, "true", ref interned) ||
-                    TryInternHardcodedString(candidate, "v4.0", ref interned))
-                {
-                    return true;
-                }
-            }
-            else if (length == 5)
-            {
-                if (TryInternHardcodedString(candidate, "FALSE", ref interned) ||
-                    TryInternHardcodedString(candidate, "false", ref interned) ||
-                    TryInternHardcodedString(candidate, "Debug", ref interned) ||
-                    TryInternHardcodedString(candidate, "Build", ref interned) ||
-                    TryInternHardcodedString(candidate, "Win32", ref interned))
-                {
-                    return true;
-                }
-            }
-            else if (length == 6)
-            {
-                if (TryInternHardcodedString(candidate, "''!=''", ref interned) ||
-                    TryInternHardcodedString(candidate, "AnyCPU", ref interned))
-                {
-                    return true;
-                }
-            }
-            else if (length == 7)
-            {
-                if (TryInternHardcodedString(candidate, "Library", ref interned) ||
-                    TryInternHardcodedString(candidate, "MSBuild", ref interned) ||
-                    TryInternHardcodedString(candidate, "Release", ref interned))
-                {
-                    return true;
-                }
-            }
-            // see Microsoft.Build.BackEnd.BuildRequestConfiguration.CreateUniqueGlobalProperty
-            else if (length > MSBuildConstants.MSBuildDummyGlobalPropertyHeader.Length &&
-                    candidate.StartsWithStringByOrdinalComparison(MSBuildConstants.MSBuildDummyGlobalPropertyHeader))
-            {
-                // don't want to leak unique strings into the cache
-                interned = candidate.ExpensiveConvertToString();
-                return null;
-            }
-            else if (length == 24)
-            {
-                if (TryInternHardcodedString(candidate, "ResolveAssemblyReference", ref interned))
-                {
-                    return true;
-                }
-            }
-            return false;
-        }
-
-        /// <summary>
-        /// Implements interning based on a WeakStringCache (new implementation).
-        /// </summary>
-        private class WeakStringCacheInterner : IInternerImplementation
-        {
-            /// <summary>
-            /// Enumerates the possible interning results.
-            /// </summary>
-            private enum InternResult
-            {
-                MatchedHardcodedString,
-                FoundInWeakStringCache,
-                AddedToWeakStringCache,
-                RejectedFromInterning
-            }
-
-            /// <summary>
-            /// The cache to keep strings in.
-            /// </summary>
-            private readonly WeakStringCache _weakStringCache = new WeakStringCache();
-
-#region Statistics
-            /// <summary>
-            /// Whether or not to gather statistics.
-            /// </summary>
-            private readonly bool _gatherStatistics;
-
-            /// <summary>
-            /// Number of times interning with hardcoded string literals worked.
-            /// </summary>
-            private int _hardcodedInternHits;
-
-            /// <summary>
-            /// Number of times the regular interning path found the string in the cache.
-            /// </summary>
-            private int _regularInternHits;
-
-            /// <summary>
-            /// Number of times the regular interning path added the string to the cache.
-            /// </summary>
-            private int _regularInternMisses;
-
-            /// <summary>
-            /// Number of times interning wasn't attempted.
-            /// </summary>
-            private int _rejectedStrings;
-
-            /// <summary>
-            /// Total number of strings eliminated by interning.
-            /// </summary>
-            private int _internEliminatedStrings;
-
-            /// <summary>
-            /// Total number of chars eliminated across all strings.
-            /// </summary>
-            private int _internEliminatedChars;
-
-            /// <summary>
-            /// Maps strings that went though the regular (i.e. not hardcoded) interning path to the number of times they have been
-            /// seen. The higher the number the better the payoff if the string had been hardcoded.
-            /// </summary>
-            private Dictionary<string, int> _missedHardcodedStrings;
-
-#endregion
-
-            public WeakStringCacheInterner(bool gatherStatistics)
-            {
-                if (gatherStatistics)
-                {
-                    _missedHardcodedStrings = new Dictionary<string, int>();
-                }
-                _gatherStatistics = gatherStatistics;
-            }
-
-            /// <summary>
-            /// Intern the given internable.
-            /// </summary>
-            public string InterningToString<T>(T candidate) where T : IInternable
-            {
-                if (_gatherStatistics)
-                {
-                    return InternWithStatistics(candidate);
-                }
-                else
-                {
-                    TryIntern(candidate, out string result);
-                    return result;
-                }
-            }
-
-            /// <summary>
-            /// Report statistics to the console.
-            /// </summary>
-            public void ReportStatistics(string heading)
-            {
-                string title = "Opportunistic Intern (" + heading + ")";
-                Console.WriteLine("\n{0}{1}{0}", new string('=', 41 - (title.Length / 2)), title);
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Hardcoded Hits", _hardcodedInternHits, "hits");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Hardcoded Rejects", _rejectedStrings, "rejects");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "WeakStringCache Hits", _regularInternHits, "hits");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "WeakStringCache Misses", _regularInternMisses, "misses");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Strings*", _internEliminatedStrings, "strings");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Chars", _internEliminatedChars, "chars");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Estimated Eliminated Bytes", _internEliminatedChars * 2, "bytes");
-                Console.WriteLine("Elimination assumes that strings provided were unique objects.");
-                Console.WriteLine("|---------------------------------------------------------------------------------|");
-
-                IEnumerable<string> topMissingHardcodedString =
-                    _missedHardcodedStrings
-                    .OrderByDescending(kv => kv.Value * kv.Key.Length)
-                    .Take(15)
-                    .Where(kv => kv.Value > 1)
-                    .Select(kv => string.Format(CultureInfo.InvariantCulture, "({1} instances x each {2} chars)\n{0}", kv.Key, kv.Value, kv.Key.Length));
-
-                Console.WriteLine("##########Top Missing Hardcoded Strings:  \n{0} ", string.Join("\n==============\n", topMissingHardcodedString.ToArray()));
-                Console.WriteLine();
-
-                WeakStringCache.DebugInfo debugInfo = _weakStringCache.GetDebugInfo();
-                Console.WriteLine("WeakStringCache statistics:");
-                Console.WriteLine("String count live/collected/total = {0}/{1}/{2}", debugInfo.LiveStringCount, debugInfo.CollectedStringCount, debugInfo.LiveStringCount + debugInfo.CollectedStringCount);
-            }
-
-            /// <summary>
-            /// Try to intern the string.
-            /// The return value indicates the how the string was interned (if at all).
-            /// </summary>
-            private InternResult TryIntern<T>(T candidate, out string interned) where T : IInternable
-            {
-                // First, try the hard coded intern strings.
-                bool? hardcodedMatchResult = TryMatchHardcodedStrings(candidate, out interned);
-                if (hardcodedMatchResult != false)
-                {
-                    // Either matched a hardcoded string or is explicitly not to be interned.
-                    return hardcodedMatchResult.HasValue ? InternResult.MatchedHardcodedString : InternResult.RejectedFromInterning;
-                }
-
-                interned = _weakStringCache.GetOrCreateEntry(candidate, out bool cacheHit);
-                return cacheHit ? InternResult.FoundInWeakStringCache : InternResult.AddedToWeakStringCache;
-            }
-
-            /// <summary>
-            /// Version of Intern that gathers statistics
-            /// </summary>
-            private string InternWithStatistics<T>(T candidate) where T : IInternable
-            {
-                lock (_missedHardcodedStrings)
-                {
-                    InternResult internResult = TryIntern(candidate, out string result);
-
-                    switch (internResult)
-                    {
-                        case InternResult.MatchedHardcodedString:
-                            _hardcodedInternHits++;
-                            break;
-                        case InternResult.FoundInWeakStringCache:
-                            _regularInternHits++;
-                            break;
-                        case InternResult.AddedToWeakStringCache:
-                            _regularInternMisses++;
-                            break;
-                        case InternResult.RejectedFromInterning:
-                            _rejectedStrings++;
-                            break;
-                    }
-
-                    if (internResult != InternResult.MatchedHardcodedString && internResult != InternResult.RejectedFromInterning)
-                    {
-                        _missedHardcodedStrings.TryGetValue(result, out int priorCount);
-                        _missedHardcodedStrings[result] = priorCount + 1;
-                    }
-
-                    if (!candidate.ReferenceEquals(result))
-                    {
-                        // Reference changed so 'candidate' is now released and should save memory.
-                        _internEliminatedStrings++;
-                        _internEliminatedChars += candidate.Length;
-                    }
-
-                    return result;
-                }
-            }
-        }
-
-        /// <summary>
-        /// Manages a set of mru lists that hold strings in varying size ranges (legacy implementation).
-        /// </summary>
-        private class BucketedPrioritizedStringList : IInternerImplementation
-        {
-            /// <summary>
-            /// The small string Mru list.
-            /// </summary>
-            private readonly PrioritizedStringList _smallMru;
-
-            /// <summary>
-            /// The large string Mru list.
-            /// </summary>
-            private readonly PrioritizedStringList _largeMru;
-
-            /// <summary>
-            /// The huge string Mru list.
-            /// </summary>
-            private readonly PrioritizedStringList _hugeMru;
-
-            /// <summary>
-            /// Three most recently used strings over 8K.
-            /// </summary>
-            private readonly LinkedList<WeakReference> _ginormous = new LinkedList<WeakReference>();
-
-            /// <summary>
-            /// The smallest size a string can be to be considered small.
-            /// </summary>
-            private readonly int _smallMruThreshold;
-
-            /// <summary>
-            /// The smallest size a string can be to be considered large.
-            /// </summary>
-            private readonly int _largeMruThreshold;
-
-            /// <summary>
-            /// The smallest size a string can be to be considered huge.
-            /// </summary>
-            private readonly int _hugeMruThreshold;
-
-            /// <summary>
-            /// The smallest size a string can be to be ginormous.
-            /// </summary>
-            private readonly int _ginormousThreshold;
-
-            private readonly bool _useSimpleConcurrency;
-
-#if !CLR2COMPATIBILITY
-            // ConcurrentDictionary starts with capacity 31 but we're usually adding far more than that. Make a better first capacity guess to reduce
-            // ConcurrentDictionary having to take all internal locks to upgrade its bucket list. Note that the number should be prime per the
-            // comments on the code at https://referencesource.microsoft.com/#mscorlib/system/Collections/Concurrent/ConcurrentDictionary.cs,122 
-            // Also note default lock count is Environment.ProcessorCount from the same code.
-            private const int InitialCapacity = 2053;
-            private readonly ConcurrentDictionary<string, string> _internedStrings = new ConcurrentDictionary<string, string>(Environment.ProcessorCount, InitialCapacity, StringComparer.Ordinal);
-#endif
-
-#region Statistics
-            /// <summary>
-            /// Whether or not to gather statistics
-            /// </summary>
-            private readonly bool _gatherStatistics;
-
-            /// <summary>
-            /// Number of times interning worked.
-            /// </summary>
-            private int _internHits;
-
-            /// <summary>
-            /// Number of times interning didn't work.
-            /// </summary>
-            private int _internMisses;
-
-            /// <summary>
-            /// Number of times interning wasn't attempted.
-            /// </summary>
-            private int _internRejects;
-
-            /// <summary>
-            /// Total number of strings eliminated by interning.
-            /// </summary>
-            private int _internEliminatedStrings;
-
-            /// <summary>
-            /// Total number of chars eliminated across all strings.
-            /// </summary>
-            private int _internEliminatedChars;
-
-            /// <summary>
-            /// Number of times the ginourmous string hit.
-            /// </summary>
-            private int _ginormousHits;
-
-            /// <summary>
-            /// Number of times the ginourmous string missed.
-            /// </summary>
-            private int _ginormousMisses;
-
-            /// <summary>
-            /// Chars interned for ginormous range.
-            /// </summary>
-            private int _ginormousCharsSaved;
-
-            /// <summary>
-            /// Whether or not to track ginormous strings.
-            /// </summary>
-            private readonly bool _dontTrack;
-
-            /// <summary>
-            /// The time spent interning.
-            /// </summary>
-            private readonly Stopwatch _stopwatch;
-
-            /// <summary>
-            /// Strings which did not intern
-            /// </summary>
-            private readonly Dictionary<string, int> _missedStrings;
-
-            /// <summary>
-            /// Strings which we didn't attempt to intern
-            /// </summary>
-            private readonly Dictionary<string, int> _rejectedStrings;
-
-            /// <summary>
-            /// Number of ginormous strings to keep
-            /// By observation of Auto7, there are about three variations of the huge solution config blob
-            /// There aren't really any other strings of this size, but make it 10 to be sure. (There will barely be any misses)
-            /// </summary>
-            private const int GinormousSize = 10;
-
-#endregion
-
-            /// <summary>
-            /// Construct.
-            /// </summary>
-            internal BucketedPrioritizedStringList(bool gatherStatistics, int smallMruSize, int largeMruSize, int hugeMruSize, int smallMruThreshold, int largeMruThreshold, int hugeMruThreshold, int ginormousThreshold, bool useSimpleConcurrency)
-            {
-                if (smallMruSize == 0 && largeMruSize == 0 && hugeMruSize == 0)
-                {
-                    _dontTrack = true;
-                }
-
-                _smallMru = new PrioritizedStringList(smallMruSize);
-                _largeMru = new PrioritizedStringList(largeMruSize);
-                _hugeMru = new PrioritizedStringList(hugeMruSize);
-                _smallMruThreshold = smallMruThreshold;
-                _largeMruThreshold = largeMruThreshold;
-                _hugeMruThreshold = hugeMruThreshold;
-                _ginormousThreshold = ginormousThreshold;
-                _useSimpleConcurrency = useSimpleConcurrency;
-
-                for (int i = 0; i < GinormousSize; i++)
-                {
-                    _ginormous.AddFirst(new WeakReference(string.Empty));
-                }
-
-                _gatherStatistics = gatherStatistics;
-                if (gatherStatistics)
-                {
-                    _stopwatch = new Stopwatch();
-                    _missedStrings = new Dictionary<string, int>(StringComparer.Ordinal);
-                    _rejectedStrings = new Dictionary<string, int>(StringComparer.Ordinal);
-                }
-            }
-
-            /// <summary>
-            /// Intern the given internable.
-            /// </summary>
-            public string InterningToString<T>(T candidate) where T : IInternable
-            {
-                if (_gatherStatistics)
-                {
-                    return InternWithStatistics(candidate);
-                }
-                else
-                {
-                    TryIntern(candidate, out string result);
-                    return result;
-                }
-            }
-
-            /// <summary>
-            /// Report statistics to the console.
-            /// </summary>
-            public void ReportStatistics(string heading)
-            {
-                string title = "Opportunistic Intern (" + heading + ")";
-                Console.WriteLine("\n{0}{1}{0}", new string('=', 41 - (title.Length / 2)), title);
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Intern Hits", _internHits, "hits");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Intern Misses", _internMisses, "misses");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Intern Rejects (as shorter than " + _smallMruThreshold + " bytes)", _internRejects, "rejects");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Strings*", _internEliminatedStrings, "strings");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Chars", _internEliminatedChars, "chars");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Estimated Eliminated Bytes", _internEliminatedChars * 2, "bytes");
-                Console.WriteLine("Elimination assumes that strings provided were unique objects.");
-                Console.WriteLine("|---------------------------------------------------------------------------------|");
-                KeyValuePair<int, int> held = _smallMru.Statistics();
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Small Strings MRU Size", Instance._smallMruSize, "strings");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Small Strings (>=" + _smallMruThreshold + " chars) Held", held.Key, "strings");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Small Estimated Bytes Held", held.Value * 2, "bytes");
-                Console.WriteLine("|---------------------------------------------------------------------------------|");
-                held = _largeMru.Statistics();
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Large Strings MRU Size", Instance._largeMruSize, "strings");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Large Strings  (>=" + _largeMruThreshold + " chars) Held", held.Key, "strings");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Large Estimated Bytes Held", held.Value * 2, "bytes");
-                Console.WriteLine("|---------------------------------------------------------------------------------|");
-                held = _hugeMru.Statistics();
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Huge Strings MRU Size", Instance._hugeMruSize, "strings");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Huge Strings  (>=" + _hugeMruThreshold + " chars) Held", held.Key, "strings");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Huge Estimated Bytes Held", held.Value * 2, "bytes");
-                Console.WriteLine("|---------------------------------------------------------------------------------|");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Ginormous Strings MRU Size", GinormousSize, "strings");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Ginormous (>=" + _ginormousThreshold + " chars)  Hits", _ginormousHits, "hits");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Ginormous Misses", _ginormousMisses, "misses");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Ginormous Chars Saved", _ginormousCharsSaved, "chars");
-                Console.WriteLine("|---------------------------------------------------------------------------------|");
-
-                // There's no point in reporting the ginormous string because it will have evaporated by now.
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Time Spent Interning", _stopwatch.ElapsedMilliseconds, "ms");
-                Console.WriteLine("{0}{0}", new string('=', 41));
-
-                IEnumerable<string> topMissingString =
-                    _missedStrings
-                    .OrderByDescending(kv => kv.Value * kv.Key.Length)
-                    .Take(15)
-                    .Where(kv => kv.Value > 1)
-                    .Select(kv => string.Format(CultureInfo.InvariantCulture, "({1} instances x each {2} chars = {3}KB wasted)\n{0}", kv.Key, kv.Value, kv.Key.Length, (kv.Value - 1) * kv.Key.Length * 2 / 1024));
-
-                Console.WriteLine("##########Top Missed Strings:  \n{0} ", string.Join("\n==============\n", topMissingString.ToArray()));
-                Console.WriteLine();
-
-                IEnumerable<string> topRejectedString =
-                    _rejectedStrings
-                    .OrderByDescending(kv => kv.Value * kv.Key.Length)
-                    .Take(15)
-                    .Where(kv => kv.Value > 1)
-                    .Select(kv => string.Format(CultureInfo.InvariantCulture, "({1} instances x each {2} chars = {3}KB wasted)\n{0}", kv.Key, kv.Value, kv.Key.Length, (kv.Value - 1) * kv.Key.Length * 2 / 1024));
-
-                Console.WriteLine("##########Top Rejected Strings: \n{0} ", string.Join("\n==============\n", topRejectedString.ToArray()));
-            }
-
-            /// <summary>
-            /// Try to intern the string.
-            /// Return true if an interned value could be returned.
-            /// Return false if it was added to the intern list, but wasn't there already.
-            /// Return null if it didn't meet the length criteria for any of the buckets. Interning was rejected
-            /// </summary>
-            private bool? TryIntern<T>(T candidate, out string interned) where T : IInternable
-            {
-                int length = candidate.Length;
-                interned = null;
-
-                // First, try the hard coded intern strings.
-                // Each of the hard-coded small strings below showed up in a profile run with considerable duplication in memory.
-                if (!_dontTrack)
-                {
-                    bool? hardcodedMatchResult = TryMatchHardcodedStrings(candidate, out interned);
-                    if (hardcodedMatchResult != false)
-                    {
-                        // Either matched a hardcoded string or is explicitly not to be interned.
-                        return hardcodedMatchResult;
-                    }
-
-                    if (length > _ginormousThreshold)
-                    {
-                        lock (_ginormous)
-                        {
-                            LinkedListNode<WeakReference> current = _ginormous.First;
-
-                            while (current != null)
-                            {
-                                if (current.Value.Target is string last && last.Length == candidate.Length && candidate.StartsWithStringByOrdinalComparison(last))
-                                {
-                                    interned = last;
-                                    _ginormousHits++;
-                                    _ginormousCharsSaved += last.Length;
-
-                                    _ginormous.Remove(current);
-                                    _ginormous.AddFirst(current);
-
-                                    return true;
-                                }
-
-                                current = current.Next;
-                            }
-
-                            _ginormousMisses++;
-                            interned = candidate.ExpensiveConvertToString();
-
-                            LinkedListNode<WeakReference> lastNode = _ginormous.Last;
-                            _ginormous.RemoveLast();
-                            _ginormous.AddFirst(lastNode);
-                            lastNode.Value.Target = interned;
-
-                            return false;
-                        }
-                    }
-#if !CLR2COMPATIBILITY
-                    else if (_useSimpleConcurrency)
-                    {
-                        var stringified = candidate.ExpensiveConvertToString();
-                        interned = _internedStrings.GetOrAdd(stringified, stringified);
-                        return true;
-                    }
-#endif
-                    else if (length >= _hugeMruThreshold)
-                    {
-                        lock (_hugeMru)
-                        {
-                            return _hugeMru.TryGet(candidate, out interned);
-                        }
-                    }
-                    else if (length >= _largeMruThreshold)
-                    {
-                        lock (_largeMru)
-                        {
-                            return _largeMru.TryGet(candidate, out interned);
-                        }
-                    }
-                    else if (length >= _smallMruThreshold)
-                    {
-                        lock (_smallMru)
-                        {
-                            return _smallMru.TryGet(candidate, out interned);
-                        }
-                    }
-                }
-
-                interned = candidate.ExpensiveConvertToString();
-                return null;
-            }
-
-            /// <summary>
-            /// Version of Intern that gathers statistics
-            /// </summary>
-            private string InternWithStatistics<T>(T candidate) where T : IInternable
-            {
-                lock (_missedStrings)
-                {
-                    _stopwatch.Start();
-                    bool? interned = TryIntern(candidate, out string result);
-                    _stopwatch.Stop();
-
-                    if (interned.HasValue && !interned.Value)
-                    {
-                        // Could not intern.
-                        _internMisses++;
-
-                        _missedStrings.TryGetValue(result, out int priorCount);
-                        _missedStrings[result] = priorCount + 1;
-
-                        return result;
-                    }
-                    else if (interned == null)
-                    {
-                        // Decided not to attempt interning
-                        _internRejects++;
-
-                        _rejectedStrings.TryGetValue(result, out int priorCount);
-                        _rejectedStrings[result] = priorCount + 1;
-
-                        return result;
-                    }
-
-                    _internHits++;
-                    if (!candidate.ReferenceEquals(result))
-                    {
-                        // Reference changed so 'candidate' is now released and should save memory.
-                        _internEliminatedStrings++;
-                        _internEliminatedChars += candidate.Length;
-                    }
-
-                    return result;
-                }
-            }
-
-            /// <summary>
-            /// A singly linked list of strings where the most recently accessed string is at the top.
-            /// Size expands up to a fixed number of strings.
-            /// </summary>
-            private class PrioritizedStringList
-            {
-                /// <summary>
-                /// Maximum size of the mru list.
-                /// </summary>
-                private readonly int _size;
-
-                /// <summary>
-                /// Head of the mru list.
-                /// </summary>
-                private Node _mru;
-
-                /// <summary>
-                /// Construct an Mru list with a fixed maximum size.
-                /// </summary>
-                internal PrioritizedStringList(int size)
-                {
-                    _size = size;
-                }
-
-                /// <summary>
-                /// Try to get one element from the list. Upon leaving the function 'candidate' will be at the head of the Mru list.
-                /// This function is not thread-safe.
-                /// </summary>
-                internal bool TryGet<T>(T candidate, out string interned) where T : IInternable
-                {
-                    if (_size == 0)
-                    {
-                        interned = candidate.ExpensiveConvertToString();
-                        return false;
-                    }
-
-                    int length = candidate.Length;
-                    Node secondPrior = null;
-                    Node prior = null;
-                    Node head = _mru;
-                    bool found = false;
-                    int itemCount = 0;
-
-                    while (head != null && !found)
-                    {
-                        if (head.Value.Length == length)
-                        {
-                            if (candidate.StartsWithStringByOrdinalComparison(head.Value))
-                            {
-                                found = true;
-                            }
-                        }
-
-                        if (!found)
-                        {
-                            secondPrior = prior;
-                            prior = head;
-                            head = head.Next;
-                        }
-
-                        itemCount++;
-                    }
-
-                    if (found)
-                    {
-                        // Move it to the top and return the interned version.
-                        if (prior != null)
-                        {
-                            if (!candidate.ReferenceEquals(head.Value))
-                            {
-                                // Wasn't at the top already, so move it there.
-                                prior.Next = head.Next;
-                                head.Next = _mru;
-                                _mru = head;
-                                interned = _mru.Value;
-                                return true;
-                            }
-                            else
-                            {
-                                // But don't move it up if there is reference equality so that multiple calls to Intern don't redundantly emphasize a string.
-                                interned = head.Value;
-                                return true;
-                            }
-                        }
-                        else
-                        {
-                            // Found the item in the top spot. No need to move anything.
-                            interned = _mru.Value;
-                            return true;
-                        }
-                    }
-                    else
-                    {
-                        // Not found. Create a new entry and place it at the top.
-                        Node old = _mru;
-                        _mru = new Node(candidate.ExpensiveConvertToString()) { Next = old };
-
-                        // Cache miss. Use this opportunity to discard any element over the max size.
-                        if (itemCount >= _size && secondPrior != null)
-                        {
-                            secondPrior.Next = null;
-                        }
-
-                        interned = _mru.Value;
-                        return false;
-                    }
-                }
-
-                /// <summary>
-                /// Returns the number of strings held and the total number of chars held.
-                /// </summary>
-                internal KeyValuePair<int, int> Statistics()
-                {
-                    Node head = _mru;
-                    int chars = 0;
-                    int strings = 0;
-                    while (head != null)
-                    {
-                        chars += head.Value.Length;
-                        strings++;
-                        head = head.Next;
-                    }
-
-                    return new KeyValuePair<int, int>(strings, chars);
-                }
-
-                /// <summary>
-                /// Singly linked list node.
-                /// </summary>
-                private class Node
-                {
-                    /// <summary>
-                    /// Construct a Node
-                    /// </summary>
-                    internal Node(string value)
-                    {
-                        Value = value;
-                    }
-
-                    /// <summary>
-                    /// The next node in the list.
-                    /// </summary>
-                    internal Node Next { get; set; }
-
-                    /// <summary>
-                    /// The held string.
-                    /// </summary>
-                    internal string Value { get; }
-                }
-            }
-        }
-    }
-}
diff --git a/src/Shared/PropertyParser.cs b/src/Shared/PropertyParser.cs
index 7ca92675832..e10f51efc8f 100644
--- a/src/Shared/PropertyParser.cs
+++ b/src/Shared/PropertyParser.cs
@@ -2,10 +2,10 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Text;
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.NET.StringTools;
 
 #if BUILD_ENGINE
 namespace Microsoft.Build.BackEnd
@@ -146,8 +146,7 @@ internal static bool GetTableWithEscaping(TaskLoggingHelper log, string paramete
                             // There was a property definition previous to this one.  Append the current string
                             // to that previous value, using semicolon as a separator.
                             string propertyValue = EscapingUtilities.Escape(propertyNameValueString.Trim());
-                            finalPropertiesList[finalPropertiesList.Count - 1].Value.Append(';');
-                            finalPropertiesList[finalPropertiesList.Count - 1].Value.Append(propertyValue);
+                            finalPropertiesList[finalPropertiesList.Count - 1].Value.Add(propertyValue);
                         }
                         else
                         {
@@ -163,9 +162,22 @@ internal static bool GetTableWithEscaping(TaskLoggingHelper log, string paramete
                 // needs to pass onto the engine.
                 log?.LogMessageFromText(parameterName, MessageImportance.Low);
 
+                using SpanBasedStringBuilder stringBuilder = Strings.GetSpanBasedStringBuilder();
                 foreach (PropertyNameValuePair propertyNameValuePair in finalPropertiesList)
                 {
-                    string propertyValue = OpportunisticIntern.StringBuilderToString(propertyNameValuePair.Value);
+                    stringBuilder.Clear();
+                    bool needsSemicolon = false;
+                    foreach (string valueFragment in propertyNameValuePair.Value)
+                    {
+                        if (needsSemicolon)
+                        {
+                            stringBuilder.Append(";");
+                        }
+                        needsSemicolon = true;
+                        stringBuilder.Append(valueFragment);
+                    }
+
+                    string propertyValue = stringBuilder.ToString();
                     finalPropertiesTable[propertyNameValuePair.Name] = propertyValue;
                     log?.LogMessageFromText(
                         $"  {propertyNameValuePair.Name}={propertyValue}",
@@ -187,14 +199,17 @@ private class PropertyNameValuePair
             internal string Name { get; }
 
             /// <summary>
-            /// Property value
+            /// Property value fragments. Join with semicolon to get the final value.
             /// </summary>
-            internal StringBuilder Value { get; }
+            internal List<string> Value { get; }
 
             internal PropertyNameValuePair(string propertyName, string propertyValue)
             {
                 Name = propertyName;
-                Value = new StringBuilder(propertyValue);
+                Value = new List<string>
+                {
+                    propertyValue
+                };
             }
         }
     }
diff --git a/src/Shared/QuotingUtilities.cs b/src/Shared/QuotingUtilities.cs
index 186fb087fa1..1e63c841cf9 100644
--- a/src/Shared/QuotingUtilities.cs
+++ b/src/Shared/QuotingUtilities.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Collections;
+using System.Collections.Generic;
 using System.Diagnostics;
 using System.Text;
 
@@ -58,7 +59,7 @@ internal static class QuotingUtilities
         /// <param name="emptySplits">[out] a count of all pieces that were empty, and thus discarded, per remark (1) above</param>
         /// <param name="separator"></param>
         /// <returns>ArrayList of all the pieces the string was split into.</returns>
-        internal static ArrayList SplitUnquoted
+        internal static List<string> SplitUnquoted
         (
             string input,
             int maxSplits,
@@ -131,7 +132,7 @@ params char[] separator
                 }
             }
 
-            ArrayList pieces = new ArrayList();
+            var pieces = new List<string>();
             emptySplits = 0;
 
             foreach (string splitPiece in splitString.ToString().Split(s_splitMarker, maxSplits))
@@ -163,7 +164,7 @@ params char[] separator
         /// <param name="input"></param>
         /// <param name="separator"></param>
         /// <returns>ArrayList of all the pieces the string was split into.</returns>
-        internal static ArrayList SplitUnquoted(string input, params char[] separator)
+        internal static List<string> SplitUnquoted(string input, params char[] separator)
         {
             int emptySplits;
             return SplitUnquoted(input, int.MaxValue, false /* discard empty splits */, false /* don't unquote the split pieces */, out emptySplits, separator);
diff --git a/src/Shared/ReuseableStringBuilder.cs b/src/Shared/ReuseableStringBuilder.cs
index fbcaabe7e11..8abf89a0093 100644
--- a/src/Shared/ReuseableStringBuilder.cs
+++ b/src/Shared/ReuseableStringBuilder.cs
@@ -15,21 +15,15 @@ namespace Microsoft.Build.Shared
     /// A StringBuilder lookalike that reuses its internal storage.
     /// </summary>
     /// <remarks>
-    /// You can add any properties or methods on the real StringBuilder that are needed.
+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.
     /// </remarks>
-    internal sealed class ReuseableStringBuilder : IDisposable, IInternable
+    internal sealed class ReuseableStringBuilder : IDisposable
     {
         /// <summary>
         /// Captured string builder.
         /// </summary>
         private StringBuilder _borrowedBuilder;
 
-        /// <summary>
-        /// Profiling showed that the hot code path for large string builder calls first IsOrdinalEqualToStringOfSameLength followed by ExpensiveConvertToString
-        /// when IsOrdinalEqualToStringOfSameLength did return true. We can therefore reduce the costs for large strings by over a factor two. 
-        /// </summary>
-        private string _cachedString;
-
         /// <summary>
         /// Capacity to initialize the builder with.
         /// </summary>
@@ -58,71 +52,6 @@ public int Length
             }
         }
 
-        /// <summary>
-        /// Indexer into the target. Presumed to be fast.
-        /// </summary>
-        char IInternable.this[int index]
-        {
-            get
-            {
-                LazyPrepare(); // Must have one to call this
-                return _borrowedBuilder[index];
-            }
-        }
-
-        /// <summary>
-        /// Convert target to string. Presumed to be slow (and will be called just once).
-        /// </summary>
-        string IInternable.ExpensiveConvertToString()
-        {
-            if( _cachedString == null)
-            {
-                _cachedString = ((ReuseableStringBuilder)this).ToString();
-            }
-            return _cachedString;
-        }
-
-        /// <summary>
-        /// The number here is arbitrary. For a StringBuilder we have a chunk length of 8000 characters which corresponds to
-        /// 5 StringBuilder chunks which need to be walked before the next character can be fetched (see MaxChunkSize of StringBuilder).
-        /// That should be a good compromise to not allocate to much but still make use of the intern cache. The actual cutoff where it is cheaper
-        /// to allocate a temp string might be well below that limit but that depends on many other factors such as GC Heap size and other allocating threads. 
-        /// </summary>
-        const int MaxByCharCompareLength = 40 * 1000;
-
-        /// <summary>
-        /// Compare target to string. 
-        /// </summary>
-        bool IInternable.StartsWithStringByOrdinalComparison(string other)
-        {
-#if DEBUG
-            ErrorUtilities.VerifyThrow(other.Length <= _borrowedBuilder.Length, "should be at most as long as target");
-#endif
-            if (other.Length > MaxByCharCompareLength)
-            {
-                return ((IInternable) this).ExpensiveConvertToString().StartsWith(other, StringComparison.Ordinal);
-            }
-            // Backwards because the end of the string is (by observation of Australian Government build) more likely to be different earlier in the loop.
-            // For example, C:\project1, C:\project2
-            for (int i = other.Length - 1; i >= 0; --i)
-            {
-                if (_borrowedBuilder[i] != other[i])
-                {
-                    return false;
-                }
-            }
-
-            return true;
-        }
-
-        /// <summary>
-        /// Never reference equals to string.
-        /// </summary>
-        bool IInternable.ReferenceEquals(string other)
-        {
-            return false;
-        }
-
         /// <summary>
         /// Convert to a string.
         /// </summary>
@@ -144,7 +73,6 @@ void IDisposable.Dispose()
             if (_borrowedBuilder != null)
             {
                 ReuseableStringBuilderFactory.Release(_borrowedBuilder);
-                _cachedString = null;
                 _borrowedBuilder = null;
                 _capacity = -1;
             }
@@ -156,7 +84,6 @@ void IDisposable.Dispose()
         internal ReuseableStringBuilder Append(char value)
         {
             LazyPrepare();
-            _cachedString = null;
             _borrowedBuilder.Append(value);
             return this;
         }
@@ -167,7 +94,6 @@ internal ReuseableStringBuilder Append(char value)
         internal ReuseableStringBuilder Append(string value)
         {
             LazyPrepare();
-            _cachedString = null;
             _borrowedBuilder.Append(value);
             return this;
         }
@@ -178,7 +104,6 @@ internal ReuseableStringBuilder Append(string value)
         internal ReuseableStringBuilder Append(string value, int startIndex, int count)
         {
             LazyPrepare();
-            _cachedString = null;
             _borrowedBuilder.Append(value, startIndex, count);
             return this;
         }
@@ -186,7 +111,6 @@ internal ReuseableStringBuilder Append(string value, int startIndex, int count)
         public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)
         {
             LazyPrepare();
-            _cachedString = null;
 
             var separatorsRemaining = strings.Count - 1;
 
@@ -208,7 +132,6 @@ public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string
         public ReuseableStringBuilder Clear()
         {
             LazyPrepare();
-            _cachedString = null;
             _borrowedBuilder.Clear();
             return this;
         }
@@ -219,7 +142,6 @@ public ReuseableStringBuilder Clear()
         internal ReuseableStringBuilder Remove(int startIndex, int length)
         {
             LazyPrepare();
-            _cachedString = null;
             _borrowedBuilder.Remove(startIndex, length);
             return this;
         }
diff --git a/src/Shared/Traits.cs b/src/Shared/Traits.cs
index 6a4e3add7f3..f23c02fa72f 100644
--- a/src/Shared/Traits.cs
+++ b/src/Shared/Traits.cs
@@ -44,16 +44,6 @@ public Traits()
         /// </summary>
         public readonly bool CacheFileExistence = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MsBuildCacheFileExistence"));
 
-        /// <summary>
-        /// Use the legacy string interning implementation based on MRU lists.
-        /// </summary>
-        public readonly bool UseLegacyStringInterner = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildUseLegacyStringInterner"));
-
-        /// <summary>
-        /// Eliminate locking in OpportunisticIntern at the expense of memory (in effect only if UseLegacyStringInterner is set).
-        /// </summary>
-        public readonly bool UseSimpleInternConcurrency = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildUseSimpleInternConcurrency"));
-
         public readonly bool UseSimpleProjectRootElementCacheConcurrency = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MsBuildUseSimpleProjectRootElementCacheConcurrency"));
 
         /// <summary>
diff --git a/src/Shared/UnitTests/MockLogger.cs b/src/Shared/UnitTests/MockLogger.cs
index 07af5356dc7..f8a094bb442 100644
--- a/src/Shared/UnitTests/MockLogger.cs
+++ b/src/Shared/UnitTests/MockLogger.cs
@@ -81,6 +81,16 @@ internal sealed class MockLogger : ILogger
         /// </summary>
         internal List<ExternalProjectFinishedEventArgs> ExternalProjectFinishedEvents { get; } = new List<ExternalProjectFinishedEventArgs>();
 
+        /// <summary>
+        /// List of ProjectStarted events
+        /// </summary>
+        internal List<ProjectEvaluationStartedEventArgs> EvaluationStartedEvents { get; } = new List<ProjectEvaluationStartedEventArgs>();
+
+        /// <summary>
+        /// List of ProjectFinished events
+        /// </summary>
+        internal List<ProjectEvaluationFinishedEventArgs> EvaluationFinishedEvents { get; } = new List<ProjectEvaluationFinishedEventArgs>();
+
         /// <summary>
         /// List of ProjectStarted events
         /// </summary>
@@ -293,6 +303,16 @@ internal void LoggerEventHandler(object sender, BuildEventArgs eventArgs)
                         ExternalProjectFinishedEvents.Add(finishedEventArgs);
                         break;
                     }
+                    case ProjectEvaluationStartedEventArgs evaluationStartedEventArgs:
+                    {
+                        EvaluationStartedEvents.Add(evaluationStartedEventArgs);
+                        break;
+                    }
+                    case ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs:
+                    {
+                        EvaluationFinishedEvents.Add(evaluationFinishedEventArgs);
+                        break;
+                    }
                     case ProjectStartedEventArgs startedEventArgs:
                     {
                         ProjectStartedEvents.Add(startedEventArgs);
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 6c62d8044f4..5c721b50c7e 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -424,6 +424,12 @@ internal static void AssertItemHasMetadata(Dictionary<string, string> expected,
             AssertItemHasMetadata(expected, new ProjectItemTestItemAdapter(item));
         }
 
+        internal static void AssertItemHasMetadata(string key, string value, ProjectItem item)
+        {
+            item.DirectMetadataCount.ShouldBe(1, () => $"Expected 1 metadata, ({key}), got {item.DirectMetadataCount}");
+            item.GetMetadataValue(key).ShouldBe(value);
+        }
+
         internal static void AssertItemHasMetadata(Dictionary<string, string> expected, TestItem item)
         {
             expected ??= new Dictionary<string, string>();
@@ -1896,14 +1902,14 @@ internal class BuildManagerSession : IDisposable
         {
             private readonly TestEnvironment _env;
             private readonly BuildManager _buildManager;
+            private bool _disposed;
 
             public MockLogger Logger { get; set; }
 
             public BuildManagerSession(
                 TestEnvironment env,
-                BuildParameters buildParametersPrototype = null,
+                BuildParameters buildParameters = null,
                 bool enableNodeReuse = false,
-                bool shutdownInProcNode = true,
                 IEnumerable<BuildManager.DeferredBuildMessage> deferredMessages = null)
             {
                 _env = env;
@@ -1911,36 +1917,56 @@ public BuildManagerSession(
                 Logger = new MockLogger(_env.Output);
                 var loggers = new[] {Logger};
 
-                var actualBuildParameters = buildParametersPrototype?.Clone() ?? new BuildParameters();
+                var actualBuildParameters = buildParameters ?? new BuildParameters();
 
                 actualBuildParameters.Loggers = actualBuildParameters.Loggers == null
                     ? loggers
                     : actualBuildParameters.Loggers.Concat(loggers).ToArray();
 
-                actualBuildParameters.ShutdownInProcNodeOnBuildFinish = shutdownInProcNode;
+                actualBuildParameters.ShutdownInProcNodeOnBuildFinish = true;
                 actualBuildParameters.EnableNodeReuse = enableNodeReuse;
 
                 _buildManager = new BuildManager();
                 _buildManager.BeginBuild(actualBuildParameters, deferredMessages);
             }
 
-            public BuildResult BuildProjectFile(string projectFile, string[] entryTargets = null)
+            public BuildResult BuildProjectFile(
+                string projectFile,
+                string[] entryTargets = null,
+                Dictionary<string, string> globalProperties = null)
             {
                 var buildResult = _buildManager.BuildRequest(
                     new BuildRequestData(projectFile,
-                        new Dictionary<string, string>(),
+                        globalProperties ?? new Dictionary<string, string>(),
                         MSBuildConstants.CurrentToolsVersion,
                         entryTargets ?? new string[0],
                         null));
 
                 return buildResult;
             }
+			
+			public GraphBuildResult BuildGraphSubmission(GraphBuildRequestData requestData)
+            {
+                return _buildManager.BuildRequest(requestData);
+            }
 
             public void Dispose()
             {
+                if (_disposed)
+                {
+                    return;
+                }
+
+                _disposed = true;
+
                 _buildManager.EndBuild();
                 _buildManager.Dispose();
             }
+
+            public GraphBuildResult BuildGraph(ProjectGraph graph, string[] entryTargets = null)
+            {
+                return _buildManager.BuildRequest(new GraphBuildRequestData(graph, entryTargets ?? new string[0]));
+            }
         }
 
         internal class LoggingFileSystem : MSBuildFileSystemBase
diff --git a/src/Shared/UnitTests/TestEnvironment.cs b/src/Shared/UnitTests/TestEnvironment.cs
index 8f05e3b94b5..569bd92a66e 100644
--- a/src/Shared/UnitTests/TestEnvironment.cs
+++ b/src/Shared/UnitTests/TestEnvironment.cs
@@ -89,18 +89,11 @@ private void Cleanup()
                 foreach (var item in _invariants)
                     item.AssertInvariant(Output);
 
-                // Reset change waves
-                SetChangeWave(string.Empty);
+                SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", "");
                 BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
             }
         }
 
-        public void SetChangeWave(string wave)
-        {
-            ChangeWaves.ResetStateForTests();
-            SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", wave);
-        }
-
         /// <summary>
         ///     Evaluate the test with the given invariant.
         /// </summary>
@@ -474,6 +467,21 @@ public override void AssertInvariant(ITestOutputHelper output)
         }
     }
 
+    public class CustomConditionInvariant : TestInvariant
+    {
+        private readonly Func<bool> _condition;
+
+        public CustomConditionInvariant(Func<bool> condition)
+        {
+            _condition = condition;
+        }
+
+        public override void AssertInvariant(ITestOutputHelper output)
+        {
+            _condition().ShouldBeTrue();
+        }
+    }
+
     public class TransientTempPath : TransientTestState
     {
         private const string TMP = "TMP";
diff --git a/src/Shared/WeakStringCache.Concurrent.cs b/src/Shared/WeakStringCache.Concurrent.cs
deleted file mode 100644
index bd30282b614..00000000000
--- a/src/Shared/WeakStringCache.Concurrent.cs
+++ /dev/null
@@ -1,136 +0,0 @@
-﻿
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-using System.Collections.Concurrent;
-using System.Collections.Generic;
-
-namespace Microsoft.Build
-{
-    /// <summary>
-    /// Implements the WeakStringCache functionality on modern .NET versions where ConcurrentDictionary is available.
-    /// </summary>
-    internal sealed partial class WeakStringCache : IDisposable
-    {
-        private readonly ConcurrentDictionary<int, StringWeakHandle> _stringsByHashCode;
-
-        public WeakStringCache()
-        {
-            _stringsByHashCode = new ConcurrentDictionary<int, StringWeakHandle>(Environment.ProcessorCount, _initialCapacity);
-        }
-
-        /// <summary>
-        /// Main entrypoint of this cache. Tries to look up a string that matches the given internable. If it succeeds, returns
-        /// the string and sets cacheHit to true. If the string is not found, calls ExpensiveConvertToString on the internable,
-        /// adds the resulting string to the cache, and returns it, setting cacheHit to false.
-        /// </summary>
-        /// <param name="internable">The internable describing the string we're looking for.</param>
-        /// <param name="cacheHit">true if match found in cache, false otherwise.</param>
-        /// <returns>A string matching the given internable.</returns>
-        /// <remarks>
-        /// This method performs two operations on the underlying ConcurrentDictionary on both cache hit and cache miss.
-        /// 1. It checks whether the dictionary has a matching entry. The entry is temporarily removed from the cache so it doesn't
-        ///    race with Scavenge() freeing GC handles. This is the first operation.
-        /// 2a. If there is a matching entry, we extract the string out of it and put it back in the cache (the second operation).
-        /// 2b. If there is an entry but it doesn't match, or there is no entry for the given hash code, we extract the string from
-        ///     the internable, set it on the entry, and add the entry (back) in the cache.
-        /// </remarks>
-        public string GetOrCreateEntry<T>(T internable, out bool cacheHit) where T : IInternable
-        {
-            int hashCode = GetInternableHashCode(internable);
-
-            StringWeakHandle handle;
-            string result;
-            bool addingNewHandle = false;
-
-            // Get the existing handle from the cache and assume ownership by removing it. We can't use the simple TryGetValue() here because
-            // the Scavenge method running on another thread could free the handle from underneath us.
-            if (_stringsByHashCode.TryRemove(hashCode, out handle))
-            {
-                result = handle.GetString(internable);
-                if (result != null)
-                {
-                    // We have a hit, put the handle back in the cache.
-                    if (!_stringsByHashCode.TryAdd(hashCode, handle))
-                    {
-                        // Another thread has managed to add a handle for the same hash code, so the one we got can be freed.
-                        handle.Free();
-                    }
-                    cacheHit = true;
-                    return result;
-                }
-            }
-            else
-            {
-                handle = new StringWeakHandle();
-                addingNewHandle = true;
-            }
-
-            // We don't have the string in the cache - create it.
-            result = internable.ExpensiveConvertToString();
-
-            // Set the handle to reference the new string and put it in the cache.
-            handle.SetString(result);
-            if (!_stringsByHashCode.TryAdd(hashCode, handle))
-            {
-                // Another thread has managed to add a handle for the same hash code, so the one we got can be freed.
-                handle.Free();
-            }
-
-            // Remove unused handles if our heuristic indicates that it would be productive. Note that the _scavengeThreshold field
-            // accesses are not protected from races. Being atomic (as guaranteed by the 32-bit data type) is enough here.
-            if (addingNewHandle)
-            {
-                // Prevent the dictionary from growing forever with GC handles that don't reference live strings anymore.
-                if (_stringsByHashCode.Count >= _scavengeThreshold)
-                {
-                    // Before we start scavenging set _scavengeThreshold to a high value to effectively lock other threads from
-                    // running Scavenge at the same time (minus rare races).
-                    _scavengeThreshold = int.MaxValue;
-                    try
-                    {
-                        // Get rid of unused handles.
-                        Scavenge();
-                    }
-                    finally
-                    {
-                        // And do this again when the number of handles reaches double the current after-scavenge number.
-                        _scavengeThreshold = _stringsByHashCode.Count * 2;
-                    }
-                }
-            }
-
-            cacheHit = false;
-            return result;
-        }
-
-        /// <summary>
-        /// Iterates over the cache and removes unused GC handles, i.e. handles that don't reference live strings.
-        /// This is expensive so try to call such that the cost is amortized to O(1) per GetOrCreateEntry() invocation.
-        /// </summary>
-        public void Scavenge()
-        {
-            foreach (KeyValuePair<int, StringWeakHandle> entry in _stringsByHashCode)
-            {
-                if (!entry.Value.IsUsed && _stringsByHashCode.TryRemove(entry.Key, out StringWeakHandle removedHandle))
-                {
-                    // Note that the removed handle may be different from the one we got from the enumerator so check again
-                    // and try to put it back if it's still in use.
-                    if (!removedHandle.IsUsed || !_stringsByHashCode.TryAdd(entry.Key, removedHandle))
-                    {
-                        removedHandle.Free();
-                    }
-                }
-            }
-        }
-
-        /// <summary>
-        /// Returns internal debug counters calculated based on the current state of the cache.
-        /// </summary>
-        public DebugInfo GetDebugInfo()
-        {
-            return GetDebugInfoImpl();
-        }
-    }
-}
diff --git a/src/StringTools.Benchmark/Program.cs b/src/StringTools.Benchmark/Program.cs
new file mode 100644
index 00000000000..7bdd21ed36a
--- /dev/null
+++ b/src/StringTools.Benchmark/Program.cs
@@ -0,0 +1,15 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using BenchmarkDotNet.Running;
+
+namespace Microsoft.NET.StringTools.Benchmark
+{
+    public class Program
+    {
+        public static void Main(string[] args)
+        {
+            BenchmarkRunner.Run<SpanBasedStringBuilder_Benchmark>();
+        }
+    }
+}
diff --git a/src/StringTools.Benchmark/SpanBasedStringBuilder_Benchmark.cs b/src/StringTools.Benchmark/SpanBasedStringBuilder_Benchmark.cs
new file mode 100644
index 00000000000..03fa15ccfc5
--- /dev/null
+++ b/src/StringTools.Benchmark/SpanBasedStringBuilder_Benchmark.cs
@@ -0,0 +1,85 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using BenchmarkDotNet.Attributes;
+using System.Text;
+
+namespace Microsoft.NET.StringTools.Benchmark
+{
+    [MemoryDiagnoser]
+    public class SpanBasedStringBuilder_Benchmark
+    {
+        [Params(1, 2, 4, 8, 16, 256)]
+        public int NumSubstrings { get; set; }
+
+        [Params(1, 8, 32, 128, 512)]
+        public int SubstringLengths { get; set; }
+
+        private string[] _subStrings;
+
+        private static SpanBasedStringBuilder _pooledSpanBasedStringBuilder = new SpanBasedStringBuilder();
+        private static StringBuilder _pooledStringBuilder = new StringBuilder();
+
+        private static int _uniqueStringCounter = 0;
+
+        [GlobalSetup]
+        public void GlobalSetup()
+        {
+            _subStrings = new string[NumSubstrings];
+            for (int i = 0; i < _subStrings.Length; i++)
+            {
+                _subStrings[i] = new string('a', SubstringLengths);
+            }
+        }
+
+        [Benchmark]
+        public void SpanBasedOperations_CacheHit()
+        {
+            SpanBasedStringBuilder sbsb = _pooledSpanBasedStringBuilder;
+            sbsb.Clear();
+            foreach (string subString in _subStrings)
+            {
+                sbsb.Append(subString);
+            }
+            sbsb.ToString();
+        }
+
+        [Benchmark]
+        public void RegularOperations_CacheHit()
+        {
+            StringBuilder sb = _pooledStringBuilder;
+            sb.Clear();
+            foreach (string subString in _subStrings)
+            {
+                sb.Append(subString);
+            }
+            Strings.WeakIntern(sb.ToString());
+        }
+
+        [Benchmark]
+        public void SpanBasedOperations_CacheMiss()
+        {
+            SpanBasedStringBuilder sbsb = _pooledSpanBasedStringBuilder;
+            sbsb.Clear();
+            foreach (string subString in _subStrings)
+            {
+                sbsb.Append(subString);
+            }
+            sbsb.Append(_uniqueStringCounter++.ToString("X8"));
+            sbsb.ToString();
+        }
+
+        [Benchmark]
+        public void RegularOperations_CacheMiss()
+        {
+            StringBuilder sb = _pooledStringBuilder;
+            sb.Clear();
+            foreach (string subString in _subStrings)
+            {
+                sb.Append(subString);
+            }
+            sb.Append(_uniqueStringCounter++.ToString("X8"));
+            Strings.WeakIntern(sb.ToString());
+        }
+    }
+}
diff --git a/src/StringTools.Benchmark/StringTools.Benchmark.csproj b/src/StringTools.Benchmark/StringTools.Benchmark.csproj
new file mode 100644
index 00000000000..eb1bf1347f3
--- /dev/null
+++ b/src/StringTools.Benchmark/StringTools.Benchmark.csproj
@@ -0,0 +1,22 @@
+﻿<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <OutputType>Exe</OutputType>
+    <UseAppHost>false</UseAppHost>
+    <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
+    <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
+    
+    <IsPackable>false</IsPackable>
+    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
+
+    <AssemblyName>StringTools.Benchmark</AssemblyName>
+    <StartupObject>Microsoft.NET.StringTools.Benchmark.Program</StartupObject>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <PackageReference Include="BenchmarkDotNet" />
+  </ItemGroup>
+
+  <ItemGroup>
+    <ProjectReference Include="..\StringTools\StringTools.csproj" />
+  </ItemGroup>
+</Project>
diff --git a/src/StringTools.UnitTests/InterningTestData.cs b/src/StringTools.UnitTests/InterningTestData.cs
new file mode 100644
index 00000000000..857e9032850
--- /dev/null
+++ b/src/StringTools.UnitTests/InterningTestData.cs
@@ -0,0 +1,68 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System.Collections.Generic;
+
+namespace Microsoft.NET.StringTools.Tests
+{
+    public static class InterningTestData
+    {
+        /// <summary>
+        /// Represents an array of string fragments to initialize an InternableString with.
+        /// </summary>
+        public class TestDatum
+        {
+            private string _string;
+            public string[] Fragments { get; }
+
+            public int Length => _string.Length;
+
+            public TestDatum(params string[] fragments)
+            {
+                Fragments = fragments;
+                _string = string.Join(string.Empty, Fragments);
+            }
+
+            public char this[int index] => _string[index];
+
+            public override string ToString()
+            {
+                return _string;
+            }
+        }
+
+        public static IEnumerable<object[]> TestData
+        {
+            get
+            {
+                yield return new object[] { new TestDatum((string)null) };
+                yield return new object[] { new TestDatum("") };
+                yield return new object[] { new TestDatum("Test") };
+                yield return new object[] { new TestDatum(null, "All") };
+                yield return new object[] { new TestDatum("", "All") };
+                yield return new object[] { new TestDatum("", "All", "") };
+                yield return new object[] { new TestDatum("Test", "All", "The", "Things") };
+            }
+        }
+
+        public static IEnumerable<object[]> TestDataForTrim
+        {
+            get
+            {
+                yield return new object[] { new TestDatum((string)null) };
+                yield return new object[] { new TestDatum("") };
+                yield return new object[] { new TestDatum(" ") };
+                yield return new object[] { new TestDatum("  ") };
+                yield return new object[] { new TestDatum(null, "") };
+                yield return new object[] { new TestDatum(null, " ") };
+                yield return new object[] { new TestDatum(" T ") };
+                yield return new object[] { new TestDatum("  Test  ") };
+                yield return new object[] { new TestDatum(null, " Test ") };
+                yield return new object[] { new TestDatum(null, "  Test All  ") };
+                yield return new object[] { new TestDatum(" ", "  Test", "", "All  ", " ") };
+                yield return new object[] { new TestDatum("Test", "  ", "", "  ", " ") };
+                yield return new object[] { new TestDatum("Test", " All ", " The ", "Things") };
+            }
+        }
+    }
+}
diff --git a/src/StringTools.UnitTests/SpanBasedStringBuilder_Tests.cs b/src/StringTools.UnitTests/SpanBasedStringBuilder_Tests.cs
new file mode 100644
index 00000000000..9be63b4b714
--- /dev/null
+++ b/src/StringTools.UnitTests/SpanBasedStringBuilder_Tests.cs
@@ -0,0 +1,154 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#if NET35_UNITTEST
+extern alias StringToolsNet35;
+#endif
+
+using System.Collections.Generic;
+
+using Shouldly;
+using Xunit;
+
+#if NET35_UNITTEST
+using StringToolsNet35::Microsoft.NET.StringTools;
+#endif
+
+namespace Microsoft.NET.StringTools.Tests
+{
+    public class SpanBasedStringBuilder_Tests
+    {
+        private SpanBasedStringBuilder MakeSpanBasedStringBuilder(InterningTestData.TestDatum datum, bool appendSubStrings = false)
+        {
+            bool wrapFirstFragment = datum.Fragments.Length > 0 && datum.Fragments[0] != null;
+
+            SpanBasedStringBuilder stringBuilder = wrapFirstFragment
+                ? new SpanBasedStringBuilder(datum.Fragments[0])
+                : new SpanBasedStringBuilder();
+
+            for (int i = 1; i < datum.Fragments.Length; i++)
+            {
+                if (appendSubStrings)
+                {
+                    int index = datum.Fragments[i].Length / 2;
+                    stringBuilder.Append(datum.Fragments[i], 0, index);
+                    stringBuilder.Append(datum.Fragments[i], index, datum.Fragments[i].Length - index);
+                }
+                else
+                {
+                    stringBuilder.Append(datum.Fragments[i]);
+                }
+            }
+            return stringBuilder;
+        }
+
+        public static IEnumerable<object[]> TestData => InterningTestData.TestData;
+        public static IEnumerable<object[]> TestDataForTrim => InterningTestData.TestDataForTrim;
+
+        [Theory]
+        [MemberData(nameof(TestData))]
+        public void LengthReturnsLength(InterningTestData.TestDatum datum)
+        {
+            MakeSpanBasedStringBuilder(datum).Length.ShouldBe(datum.Length);
+        }
+
+        [Theory]
+        [MemberData(nameof(TestData))]
+        public void EnumeratorEnumeratesCharacters(InterningTestData.TestDatum datum)
+        {
+            SpanBasedStringBuilder stringBuilder = MakeSpanBasedStringBuilder(datum);
+            int index = 0;
+            foreach (char ch in stringBuilder)
+            {
+                ch.ShouldBe(datum[index]);
+                index++;
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(TestData))]
+        public void EqualsReturnsExpectedValue(InterningTestData.TestDatum datum)
+        {
+            InternableString internableString = new InternableString(MakeSpanBasedStringBuilder(datum));
+            internableString.Equals(string.Empty).ShouldBe(internableString.Length == 0);
+
+            string substr = datum.Fragments[0] ?? string.Empty;
+            internableString.Equals(substr).ShouldBe(substr.Length == internableString.Length);
+
+            if (datum.Fragments.Length > 1)
+            {
+                substr += datum.Fragments[1];
+                internableString.Equals(substr).ShouldBe(substr.Length == internableString.Length);
+
+                internableString.Equals(datum.ToString()).ShouldBeTrue();
+            }
+
+            internableString.Equals("Things").ShouldBeFalse();
+        }
+
+        [Fact]
+        public void ReferenceEqualsReturnsExpectedValue()
+        {
+            string str = "Test";
+            InternableString internableString = new InternableString(str);
+            internableString.ReferenceEquals(str).ShouldBeTrue();
+            internableString = new InternableString(new string(str.ToCharArray()));
+            internableString.ReferenceEquals(str).ShouldBeFalse();
+        }
+
+        [Theory]
+        [MemberData(nameof(TestData))]
+        public void AppendAppendsString(InterningTestData.TestDatum datum)
+        {
+            SpanBasedStringBuilder stringBuilder = MakeSpanBasedStringBuilder(datum, false);
+            new InternableString(stringBuilder).ExpensiveConvertToString().ShouldBe(datum.ToString());
+        }
+
+        [Theory]
+        [MemberData(nameof(TestData))]
+        public void AppendAppendsSubstring(InterningTestData.TestDatum datum)
+        {
+            SpanBasedStringBuilder stringBuilder = MakeSpanBasedStringBuilder(datum, true);
+            new InternableString(stringBuilder).ExpensiveConvertToString().ShouldBe(datum.ToString());
+        }
+
+#if !NET35_UNITTEST
+        [Theory]
+        [MemberData(nameof(TestDataForTrim))]
+        public void TrimStartRemovesLeadingWhiteSpace(InterningTestData.TestDatum datum)
+        {
+            SpanBasedStringBuilder stringBuilder = MakeSpanBasedStringBuilder(datum);
+            stringBuilder.TrimStart();
+            new InternableString(stringBuilder).ExpensiveConvertToString().ShouldBe(datum.ToString().TrimStart());
+        }
+
+        [Theory]
+        [MemberData(nameof(TestDataForTrim))]
+        public void TrimEndRemovesTrailingWhiteSpace(InterningTestData.TestDatum datum)
+        {
+            SpanBasedStringBuilder stringBuilder = MakeSpanBasedStringBuilder(datum);
+            stringBuilder.TrimEnd();
+            new InternableString(stringBuilder).ExpensiveConvertToString().ShouldBe(datum.ToString().TrimEnd());
+        }
+
+        [Theory]
+        [MemberData(nameof(TestDataForTrim))]
+        public void TrimRemovesLeadingAndTrailingWhiteSpace(InterningTestData.TestDatum datum)
+        {
+            SpanBasedStringBuilder stringBuilder = MakeSpanBasedStringBuilder(datum);
+            stringBuilder.Trim();
+            new InternableString(stringBuilder).ExpensiveConvertToString().ShouldBe(datum.ToString().Trim());
+        }
+#endif
+
+        [Theory]
+        [MemberData(nameof(TestData))]
+        public void ClearRemovesAllCharacters(InterningTestData.TestDatum datum)
+        {
+            SpanBasedStringBuilder stringBuilder = MakeSpanBasedStringBuilder(datum);
+            stringBuilder.Clear();
+            stringBuilder.Length.ShouldBe(0);
+            stringBuilder.GetEnumerator().MoveNext().ShouldBeFalse();
+        }
+    }
+}
diff --git a/src/StringTools.UnitTests/StringTools.UnitTests.csproj b/src/StringTools.UnitTests/StringTools.UnitTests.csproj
new file mode 100644
index 00000000000..e11fc1d60ce
--- /dev/null
+++ b/src/StringTools.UnitTests/StringTools.UnitTests.csproj
@@ -0,0 +1,30 @@
+﻿<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
+    <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
+
+    <IsPackable>false</IsPackable>
+
+    <AssemblyName>Microsoft.NET.StringTools.UnitTests</AssemblyName>
+    <IsTestProject>true</IsTestProject>
+    <IsLibraryTestProject>true</IsLibraryTestProject>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <PackageReference Include="Shouldly" />
+  </ItemGroup>
+
+  <ItemGroup>
+    <ProjectReference Include="..\StringTools\StringTools.csproj" />
+  </ItemGroup>
+
+  <ItemGroup>
+    <None Include="..\Shared\UnitTests\App.config">
+      <Link>App.config</Link>
+      <SubType>Designer</SubType>
+    </None>
+    <None Include="..\Shared\UnitTests\xunit.runner.json">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </None>
+  </ItemGroup>
+</Project>
diff --git a/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj b/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
new file mode 100644
index 00000000000..0c10b4d1f04
--- /dev/null
+++ b/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
@@ -0,0 +1,40 @@
+﻿<Project Sdk="Microsoft.NET.Sdk">
+
+  <!-- The .NET Core version of MSBuild doesn't support targeting .NET Framework 3.5.  So in that case, we import
+       a .props file that prevents building the project from doing much of anything. -->
+  <Import Project="$(RepoRoot)eng\ProducesNoOutput.Settings.props" Condition="'$(MSBuildRuntimeType)' == 'Core' or '$(MonoBuild)' == 'true'" />
+
+  <PropertyGroup>
+    <TargetFrameworks>$(FullFrameworkTFM)</TargetFrameworks>
+    <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
+
+    <IsPackable>false</IsPackable>
+
+    <AssemblyName>Microsoft.NET.StringTools.net35.UnitTests</AssemblyName>
+    <IsTestProject>true</IsTestProject>
+    <IsLibraryTestProject>true</IsLibraryTestProject>
+    <DefineConstants>$(DefineConstants);NET35_UNITTEST</DefineConstants>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <PackageReference Include="Shouldly" />
+    <PackageReference Include="xunit.core" />
+    <PackageReference Include="xunit.assert" />
+  </ItemGroup>
+
+  <ItemGroup>
+    <ProjectReference Include="..\StringTools\StringTools.csproj" Aliases="StringToolsNet35">
+      <SetTargetFramework>TargetFramework=net35</SetTargetFramework>
+    </ProjectReference>
+  </ItemGroup>
+
+  <ItemGroup>
+    <None Include="..\Shared\UnitTests\App.config">
+      <Link>App.config</Link>
+      <SubType>Designer</SubType>
+    </None>
+    <None Include="..\Shared\UnitTests\xunit.runner.json">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </None>
+  </ItemGroup>
+</Project>
diff --git a/src/StringTools.UnitTests/StringTools_Tests.cs b/src/StringTools.UnitTests/StringTools_Tests.cs
new file mode 100644
index 00000000000..7f396ab32b6
--- /dev/null
+++ b/src/StringTools.UnitTests/StringTools_Tests.cs
@@ -0,0 +1,61 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#if NET35_UNITTEST
+extern alias StringToolsNet35;
+#endif
+
+using System;
+
+using Shouldly;
+using Xunit;
+
+#if NET35_UNITTEST
+using StringToolsNet35::Microsoft.NET.StringTools;
+using Shouldly.Configuration;
+#else
+using Microsoft.NET.StringTools;
+#endif
+
+namespace Microsoft.NET.StringTools.Tests
+{
+    public class StringTools_Tests
+    {
+        [Theory]
+        [InlineData("")]
+        [InlineData("A")]
+        [InlineData("Hello")]
+        [InlineData("HelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHello")]
+        public void InternsStrings(string str)
+        {
+            string internedString1 = Strings.WeakIntern(str);
+            internedString1.Equals(str).ShouldBeTrue();
+            string internedString2 = Strings.WeakIntern(str);
+            internedString1.Equals(str).ShouldBeTrue();
+            Object.ReferenceEquals(internedString1, internedString2).ShouldBeTrue();
+
+#if !NET35_UNITTEST
+            ReadOnlySpan<char> span = str.AsSpan();
+            internedString1 = Strings.WeakIntern(span);
+            internedString1.Equals(str).ShouldBeTrue();
+            internedString2 = Strings.WeakIntern(span);
+            internedString1.Equals(str).ShouldBeTrue();
+            Object.ReferenceEquals(internedString1, internedString2).ShouldBeTrue();
+#endif
+        }
+
+        [Fact]
+        public void CreatesDiagnosticReport()
+        {
+            string statisticsNotEnabledString = "EnableStatisticsGathering() has not been called";
+
+            Strings.CreateDiagnosticReport().ShouldContain(statisticsNotEnabledString);
+
+            Strings.EnableDiagnostics();
+            string report = Strings.CreateDiagnosticReport();
+
+            report.ShouldNotContain(statisticsNotEnabledString);
+            report.ShouldContain("Eliminated Strings");
+        }
+    }
+}
diff --git a/src/Build.UnitTests/WeakStringCache_Tests.cs b/src/StringTools.UnitTests/WeakStringCache_Tests.cs
similarity index 87%
rename from src/Build.UnitTests/WeakStringCache_Tests.cs
rename to src/StringTools.UnitTests/WeakStringCache_Tests.cs
index ece79899fd0..bddfc60917b 100644
--- a/src/Build.UnitTests/WeakStringCache_Tests.cs
+++ b/src/StringTools.UnitTests/WeakStringCache_Tests.cs
@@ -1,6 +1,10 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if NET35_UNITTEST
+extern alias StringToolsNet35;
+#endif
+
 using System;
 using System.Linq;
 using System.Runtime.CompilerServices;
@@ -9,7 +13,11 @@
 using Shouldly;
 using Xunit;
 
-namespace Microsoft.Build.UnitTests
+#if NET35_UNITTEST
+using StringToolsNet35::Microsoft.NET.StringTools;
+#endif
+
+namespace Microsoft.NET.StringTools.Tests
 {
     public class WeakStringCache_Tests : IDisposable
     {
@@ -35,11 +43,11 @@ private int AddString(string strPart1, string strPart2, Action<string> callbackT
         {
             // Compose the string with SB so it doesn't get interned by the runtime.
             string testString = new StringBuilder(strPart1).Append(strPart2).ToString();
-            StringInternTarget testStringTarget = new StringInternTarget(testString);
+            InternableString testStringTarget = new InternableString(testString);
 
-            int hashCode = WeakStringCache.GetInternableHashCode(testStringTarget);
+            int hashCode = testStringTarget.GetHashCode();
 
-            string cachedString = _cache.GetOrCreateEntry(testStringTarget, out bool cacheHit);
+            string cachedString = _cache.GetOrCreateEntry(ref testStringTarget, out bool cacheHit);
             cacheHit.ShouldBeFalse();
             cachedString.ShouldBeSameAs(testString);
 
@@ -47,7 +55,8 @@ private int AddString(string strPart1, string strPart2, Action<string> callbackT
 
             // Verify that the string is really in the cache and the cache returns the interned instance.
             string testStringCopy = new StringBuilder(strPart1).Append(strPart2).ToString();
-            cachedString = _cache.GetOrCreateEntry(new StringInternTarget(testStringCopy), out cacheHit);
+            InternableString testStringCopyTarget = new InternableString(testStringCopy);
+            cachedString = _cache.GetOrCreateEntry(ref testStringCopyTarget, out cacheHit);
             cacheHit.ShouldBeTrue();
             cachedString.ShouldBeSameAs(testString);
 
@@ -56,7 +65,8 @@ private int AddString(string strPart1, string strPart2, Action<string> callbackT
 
             callbackToRunWithTheStringAlive(cachedString);
 
-            cachedString = _cache.GetOrCreateEntry(new StringInternTarget(testStringCopy), out cacheHit);
+            testStringCopyTarget = new InternableString(testStringCopy);
+            cachedString = _cache.GetOrCreateEntry(ref testStringCopyTarget, out cacheHit);
             cacheHit.ShouldBeTrue();
             cachedString.ShouldBeSameAs(testString);
 
@@ -95,8 +105,8 @@ private void AddStringsWithSameHashCode(int numberOfStrings)
             // There are no cache hits when iterating over our strings again because the last one always wins and steals the slot.
             for (int i = 0; i < numberOfStrings; i++)
             {
-                StringBuilder sb = new StringBuilder(cachedStrings[i]);
-                string cachedStringFromCache =_cache.GetOrCreateEntry(new StringBuilderInternTarget(sb), out bool cacheHit);
+                InternableString stringCopy = new InternableString(new string(cachedStrings[i].ToCharArray()));
+                string cachedStringFromCache =_cache.GetOrCreateEntry(ref stringCopy, out bool cacheHit);
                 cacheHit.ShouldBeFalse();
                 cachedStringFromCache.ShouldNotBeSameAs(cachedStrings[i]);
             }
@@ -113,7 +123,7 @@ private void AddStringsWithSameHashCode(int numberOfStrings)
         /// https://www.mono-project.com/docs/advanced/garbage-collector/sgen/#precise-stack-marking
         /// </remarks>
         [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Mono, "doesn't play well with conservative GC scanning")]
+        [Trait("Category", "mono-osx-failing")]
         public void RetainsStringUntilCollected()
         {
             // Add a string to the cache using a non-inlinable method to make sure it's not reachable from a GC root.
diff --git a/src/StringTools/AssemblyInfo.cs b/src/StringTools/AssemblyInfo.cs
new file mode 100644
index 00000000000..0a8c0ee0a72
--- /dev/null
+++ b/src/StringTools/AssemblyInfo.cs
@@ -0,0 +1,13 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+[assembly: InternalsVisibleTo("Microsoft.NET.StringTools.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
+[assembly: InternalsVisibleTo("Microsoft.NET.StringTools.net35.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
+[assembly: InternalsVisibleTo("Microsoft.NET.StringTools.Benchmark, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
+
+[assembly: ComVisible(false)]
+[assembly: CLSCompliant(true)]
diff --git a/src/StringTools/InternableString.Simple.cs b/src/StringTools/InternableString.Simple.cs
new file mode 100644
index 00000000000..88126da5c6f
--- /dev/null
+++ b/src/StringTools/InternableString.Simple.cs
@@ -0,0 +1,231 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq.Expressions;
+using System.Text;
+
+namespace System
+{
+    /// <summary>
+    /// A bare minimum and inefficient version of MemoryExtensions as provided in System.Memory on .NET 4.5.
+    /// </summary>
+    public static class MemoryExtensions
+    {
+        public static string AsSpan<T>(this T[] array, int start, int length)
+        {
+            if (array is char[] charArray)
+            {
+                return new string(charArray, start, length);
+            }
+            throw new ArgumentException(nameof(array));
+        }
+    }
+}
+
+namespace Microsoft.NET.StringTools
+{
+    /// <summary>
+    /// Represents a string that can be converted to System.String with interning, i.e. by returning an existing string if it has been seen before
+    /// and is still tracked in the intern table.
+    /// </summary>
+    /// <remarks>
+    /// This is a simple and inefficient implementation compatible with .NET Framework 3.5.
+    /// </remarks>
+    internal ref struct InternableString
+    {
+        /// <summary>
+        /// Enumerator for the top-level struct. Enumerates characters of the string.
+        /// </summary>
+        public ref struct Enumerator
+        {
+            /// <summary>
+            /// The InternableString being enumerated.
+            /// </summary>
+            private InternableString _string;
+
+            /// <summary>
+            /// Index of the current character, -1 if MoveNext has not been called yet.
+            /// </summary>
+            private int _charIndex;
+
+            public Enumerator(ref InternableString spanBuilder)
+            {
+                _string = spanBuilder;
+                _charIndex = -1;
+            }
+
+            /// <summary>
+            /// Returns the current character.
+            /// </summary>
+            public char Current => (_string._builder == null ? _string.FirstString[_charIndex] : _string._builder[_charIndex]);
+
+            /// <summary>
+            /// Moves to the next character.
+            /// </summary>
+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>
+            public bool MoveNext()
+            {
+                int newIndex = _charIndex + 1;
+                if (newIndex < _string.Length)
+                {
+                    _charIndex = newIndex;
+                    return true;
+                }
+                return false;
+            }
+        }
+
+        /// <summary>
+        /// If this instance wraps a StringBuilder, it uses this backing field.
+        /// </summary>
+        private StringBuilder? _builder;
+
+        /// <summary>
+        /// If this instance represents one contiguous string, it may be held in this field.
+        /// </summary>
+        private string? _firstString;
+
+        /// <summary>
+        /// A convenience getter to ensure that we always operate on a non-null string.
+        /// </summary>
+        private string FirstString => _firstString ?? string.Empty;
+
+        /// <summary>
+        /// Constructs a new InternableString wrapping the given string.
+        /// </summary>
+        /// <param name="str">The string to wrap, must be non-null.</param>
+        internal InternableString(string str)
+        {
+            if (str == null)
+            {
+                throw new ArgumentNullException(nameof(str));
+            }
+            _builder = null;
+            _firstString = str;
+        }
+
+        /// <summary>
+        /// Constructs a new InternableString wrapping the given SpanBasedStringBuilder.
+        /// </summary>
+        internal InternableString(SpanBasedStringBuilder builder)
+        {
+            _builder = builder.Builder;
+            _firstString = null;
+        }
+
+        /// <summary>
+        /// Gets the length of the string.
+        /// </summary>
+        public int Length => (_builder == null ? FirstString.Length : _builder.Length);
+
+        /// <summary>
+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.
+        /// </summary>
+        /// <returns>The enumerator.</returns>
+        public Enumerator GetEnumerator()
+        {
+            return new Enumerator(ref this);
+        }
+
+        /// <summary>
+        /// Returns true if the string is equal to another string by ordinal comparison.
+        /// </summary>
+        /// <param name="other">Another string.</param>
+        /// <returns>True if this string is equal to <paramref name="other"/>.</returns>
+        public bool Equals(string other)
+        {
+            if (other.Length != Length)
+            {
+                return false;
+            }
+
+            if (_firstString != null)
+            {
+                return _firstString.Equals(other);
+            }
+            if (_builder != null)
+            {
+                for (int i = 0; i < other.Length; i++)
+                {
+                    // Note: This indexing into the StringBuilder could be O(N). We prefer it over allocating
+                    // a new string with ToString().
+                    if (other[i] != _builder[i])
+                    {
+                        return false;
+                    }
+                }
+            }
+            return true;
+        }
+
+        /// <summary>
+        /// Returns a System.String representing this string. Allocates memory unless this InternableString was created by wrapping a
+        /// System.String in which case the original string is returned.
+        /// </summary>
+        /// <returns>The string.</returns>
+        public string ExpensiveConvertToString()
+        {
+            // Special case: if we hold just one string, we can directly return it.
+            if (_firstString != null)
+            {
+                return _firstString;
+            }
+            return _builder?.ToString() ?? string.Empty;
+        }
+
+        /// <summary>
+        /// Returns true if this InternableString wraps a System.String and the same System.String is passed as the argument.
+        /// </summary>
+        /// <param name="str">The string to compare to.</param>
+        /// <returns>True is this instance wraps the given string.</returns>
+        public bool ReferenceEquals(string str)
+        {
+            return Object.ReferenceEquals(str, _firstString);
+        }
+
+        /// <summary>
+        /// Converts this instance to a System.String while first searching for a match in the intern table.
+        /// </summary>
+        /// <remarks>
+        /// May allocate depending on whether the string has already been interned.
+        /// </remarks>
+        public override unsafe string ToString()
+        {
+            return WeakStringCacheInterner.Instance.InternableToString(ref this);
+        }
+
+        /// <summary>
+        /// Implements the simple yet very decently performing djb2 hash function (xor version).
+        /// </summary>
+        /// <returns>A stable hashcode of the string represented by this instance.</returns>
+        public override int GetHashCode()
+        {
+            int hashCode = 5381;
+
+            if (_firstString != null)
+            {
+                foreach (char ch in _firstString)
+                {
+                    unchecked
+                    {
+                        hashCode = hashCode * 33 ^ ch;
+                    }
+                }
+            }
+            else if (_builder != null)
+            {
+                for (int i = 0; i < _builder.Length; i++)
+                {
+                    unchecked
+                    {
+                        hashCode = hashCode * 33 ^ _builder[i];
+                    }
+                }
+            }
+            return hashCode;
+        }
+    }
+}
diff --git a/src/StringTools/InternableString.cs b/src/StringTools/InternableString.cs
new file mode 100644
index 00000000000..ca8fa75ef48
--- /dev/null
+++ b/src/StringTools/InternableString.cs
@@ -0,0 +1,331 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Runtime.CompilerServices;
+
+namespace Microsoft.NET.StringTools
+{
+    /// <summary>
+    /// Represents a string that can be converted to System.String with interning, i.e. by returning an existing string if it has been seen before
+    /// and is still tracked in the intern table.
+    /// </summary>
+    internal ref struct InternableString
+    {
+        /// <summary>
+        /// Enumerator for the top-level struct. Enumerates characters of the string.
+        /// </summary>
+        public ref struct Enumerator
+        {
+            /// <summary>
+            /// The InternableString being enumerated.
+            /// </summary>
+            private InternableString _string;
+
+            /// <summary>
+            /// Index of the current span, -1 represents the inline span.
+            /// </summary>
+            private int _spanIndex;
+
+            /// <summary>
+            /// Index of the current character in the current span, -1 if MoveNext has not been called yet.
+            /// </summary>
+            private int _charIndex;
+
+            internal Enumerator(ref InternableString str)
+            {
+                _string = str;
+                _spanIndex = -1;
+                _charIndex = -1;
+            }
+
+            /// <summary>
+            /// Returns the current character.
+            /// </summary>
+            public ref readonly char Current
+            {
+                get
+                {
+                    if (_spanIndex == -1)
+                    {
+                        return ref _string._inlineSpan[_charIndex];
+                    }
+                    ReadOnlyMemory<char> span = _string._spans![_spanIndex];
+                    return ref span.Span[_charIndex];
+                }
+            }
+
+            /// <summary>
+            /// Moves to the next character.
+            /// </summary>
+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>
+            public bool MoveNext()
+            {
+                int newCharIndex = _charIndex + 1;
+                if (_spanIndex == -1)
+                {
+                    if (newCharIndex < _string._inlineSpan.Length)
+                    {
+                        _charIndex = newCharIndex;
+                        return true;
+                    }
+                    _spanIndex = 0;
+                    newCharIndex = 0;
+                }
+
+                if (_string._spans != null)
+                {
+                    while (_spanIndex < _string._spans.Count)
+                    {
+                        if (newCharIndex < _string._spans[_spanIndex].Length)
+                        {
+                            _charIndex = newCharIndex;
+                            return true;
+                        }
+                        _spanIndex++;
+                        newCharIndex = 0;
+                    }
+                }
+                return false;
+            }
+        }
+
+        /// <summary>
+        /// The span held by this struct, inline to be able to represent <see cref="ReadOnlySpan{char}"/>. May be empty.
+        /// </summary>
+        private readonly ReadOnlySpan<char> _inlineSpan;
+
+#if NETSTANDARD
+        /// <summary>
+        /// .NET Core does not keep a reference to the containing object in <see cref="ReadOnlySpan{char}"/>. In particular,
+        /// it cannot recover the string if the span represents one. We have to hold the reference separately to be able to
+        /// roundtrip String-&gt;InternableString-&gt;String without allocating a new String.
+        /// </summary>
+        private string? _inlineSpanString;
+#endif
+
+        /// <summary>
+        /// Additional spans held by this struct. May be null.
+        /// </summary>
+        private List<ReadOnlyMemory<char>>? _spans;
+
+        /// <summary>
+        /// Constructs a new InternableString wrapping the given <see cref="ReadOnlySpan{char}"/>.
+        /// </summary>
+        /// <param name="span">The span to wrap.</param>
+        /// <remarks>
+        /// When wrapping a span representing an entire System.String, use Internable(string) for optimum performance.
+        /// </remarks>
+        internal InternableString(ReadOnlySpan<char> span)
+        {
+            _inlineSpan = span;
+            _spans = null;
+            Length = span.Length;
+#if NETSTANDARD
+            _inlineSpanString = null;
+#endif
+        }
+
+        /// <summary>
+        /// Constructs a new InternableString wrapping the given string.
+        /// </summary>
+        /// <param name="str">The string to wrap, must be non-null.</param>
+        internal InternableString(string str)
+        {
+            if (str == null)
+            {
+                throw new ArgumentNullException(nameof(str));
+            }
+
+            _inlineSpan = str.AsSpan();
+            _spans = null;
+            Length = str.Length;
+#if NETSTANDARD
+            _inlineSpanString = str;
+#endif
+        }
+
+        /// <summary>
+        /// Constructs a new InternableString wrapping the given SpanBasedStringBuilder.
+        /// </summary>
+        internal InternableString(SpanBasedStringBuilder stringBuilder)
+        {
+            _inlineSpan = default(ReadOnlySpan<char>);
+            _spans = stringBuilder.Spans;
+            Length = stringBuilder.Length;
+#if NETSTANDARD
+            _inlineSpanString = null;
+#endif
+        }
+
+        /// <summary>
+        /// Gets the length of the string.
+        /// </summary>
+        public int Length { get; private set; }
+
+        /// <summary>
+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.
+        /// </summary>
+        /// <returns>The enumerator.</returns>
+        public Enumerator GetEnumerator()
+        {
+            return new Enumerator(ref this);
+        }
+
+        /// <summary>
+        /// Returns true if the string is equal to another string by ordinal comparison.
+        /// </summary>
+        /// <param name="other">Another string.</param>
+        /// <returns>True if this string is equal to <paramref name="other"/>.</returns>
+        public bool Equals(string other)
+        {
+            if (other.Length != Length)
+            {
+                return false;
+            }
+
+            if (_inlineSpan.SequenceCompareTo(other.AsSpan(0, _inlineSpan.Length)) != 0)
+            {
+                return false;
+            }
+
+            if (_spans != null)
+            {
+                int otherStart = _inlineSpan.Length;
+                foreach (ReadOnlyMemory<char> span in _spans)
+                {
+                    if (span.Span.SequenceCompareTo(other.AsSpan(otherStart, span.Length)) != 0)
+                    {
+                        return false;
+                    }
+                    otherStart += span.Length;
+                }
+            }
+            return true;
+        }
+
+        /// <summary>
+        /// Returns a System.String representing this string. Allocates memory unless this InternableString was created by wrapping a
+        /// System.String in which case the original string is returned.
+        /// </summary>
+        /// <returns>The string.</returns>
+        public unsafe string ExpensiveConvertToString()
+        {
+            if (Length == 0)
+            {
+                return string.Empty;
+            }
+
+            // Special case: if we hold just one string, we can directly return it.
+            if (_inlineSpan.Length == Length)
+            {
+#if NETSTANDARD
+                if (_inlineSpanString != null)
+                {
+                    return _inlineSpanString;
+                }
+#else
+                return _inlineSpan.ToString();
+#endif
+            }
+            if (_inlineSpan.IsEmpty && _spans?[0].Length == Length)
+            {
+                return _spans[0].ToString();
+            }
+
+            // In all other cases we create a new string instance and concatenate all spans into it. Note that while technically mutating
+            // the System.String, the technique is generally considered safe as we are the sole owners of the new object. It is important
+            // to initialize the string with the '\0' characters as this hits an optimized code path in the runtime.
+            string result = new string((char)0, Length);
+
+            fixed (char* resultPtr = result)
+            {
+                char* destPtr = resultPtr;
+                if (!_inlineSpan.IsEmpty)
+                {
+                    fixed (char* sourcePtr = _inlineSpan)
+                    {
+                        Unsafe.CopyBlockUnaligned(destPtr, sourcePtr, 2 * (uint)_inlineSpan.Length);
+                    }
+                    destPtr += _inlineSpan.Length;
+                }
+
+                if (_spans != null)
+                {
+                    foreach (ReadOnlyMemory<char> span in _spans)
+                    {
+                        if (!span.IsEmpty)
+                        {
+                            fixed (char* sourcePtr = span.Span)
+                            {
+                                Unsafe.CopyBlockUnaligned(destPtr, sourcePtr, 2 * (uint)span.Length);
+                            }
+                            destPtr += span.Length;
+                        }
+                    }
+                }
+            }
+            return result;
+        }
+
+        /// <summary>
+        /// Returns true if this InternableString wraps a System.String and the same System.String is passed as the argument.
+        /// </summary>
+        /// <param name="str">The string to compare to.</param>
+        /// <returns>True is this instance wraps the given string.</returns>
+        public bool ReferenceEquals(string str)
+        {
+            if (_inlineSpan.Length == Length)
+            {
+                return _inlineSpan == str.AsSpan();
+            }
+            if (_inlineSpan.IsEmpty && _spans?.Count == 1 && _spans[0].Length == Length)
+            {
+                return _spans[0].Span == str.AsSpan();
+            }
+            return false;
+        }
+
+        /// <summary>
+        /// Converts this instance to a System.String while first searching for a match in the intern table.
+        /// </summary>
+        /// <remarks>
+        /// May allocate depending on whether the string has already been interned.
+        /// </remarks>
+        public override string ToString()
+        {
+            return WeakStringCacheInterner.Instance.InternableToString(ref this);
+        }
+
+        /// <summary>
+        /// Implements the simple yet very decently performing djb2 hash function (xor version).
+        /// </summary>
+        /// <returns>A stable hashcode of the string represented by this instance.</returns>
+        public override unsafe int GetHashCode()
+        {
+            int hashCode = 5381;
+            fixed (char* charPtr = _inlineSpan)
+            {
+                for (int i = 0; i < _inlineSpan.Length; i++)
+                {
+                    hashCode = unchecked(hashCode * 33 ^ charPtr[i]);
+                }
+            }
+            if (_spans != null)
+            {
+                foreach (ReadOnlyMemory<char> span in _spans)
+                {
+                    fixed (char* charPtr = span.Span)
+                    {
+                        for (int i = 0; i < span.Length; i++)
+                        {
+                            hashCode = unchecked(hashCode * 33 ^ charPtr[i]);
+                        }
+                    }
+                }
+            }
+            return hashCode;
+        }
+    }
+}
diff --git a/src/StringTools/SpanBasedStringBuilder.Simple.cs b/src/StringTools/SpanBasedStringBuilder.Simple.cs
new file mode 100644
index 00000000000..86e38c2907f
--- /dev/null
+++ b/src/StringTools/SpanBasedStringBuilder.Simple.cs
@@ -0,0 +1,153 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Text;
+
+namespace Microsoft.NET.StringTools
+{
+    /// <summary>
+    /// A simple version of SpanBasedStringBuilder to be used on .NET Framework 3.5. Wraps a <see cref="StringBuilder"/>.
+    /// </summary>
+    public class SpanBasedStringBuilder : IDisposable
+    {
+        /// <summary>
+        /// Enumerator for the top-level struct. Enumerates characters of the string.
+        /// </summary>
+        public struct Enumerator
+        {
+            /// <summary>
+            /// The StringBuilder being enumerated.
+            /// </summary>
+            private StringBuilder _builder;
+
+            /// <summary>
+            /// Index of the current character, -1 if MoveNext has not been called yet.
+            /// </summary>
+            private int _charIndex;
+
+            public Enumerator(StringBuilder builder)
+            {
+                _builder = builder;
+                _charIndex = -1;
+            }
+
+            /// <summary>
+            /// Returns the current character.
+            /// </summary>
+            public char Current => _builder[_charIndex];
+
+            /// <summary>
+            /// Moves to the next character.
+            /// </summary>
+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>
+            public bool MoveNext()
+            {
+                int newIndex = _charIndex + 1;
+                if (newIndex < _builder.Length)
+                {
+                    _charIndex = newIndex;
+                    return true;
+                }
+                return false;
+            }
+        }
+
+        /// <summary>
+        /// The backing StringBuilder.
+        /// </summary>
+        private StringBuilder _builder;
+
+        internal StringBuilder Builder => _builder;
+
+        /// <summary>
+        /// Constructs a new SpanBasedStringBuilder containing the given string.
+        /// </summary>
+        /// <param name="str">The string to wrap, must be non-null.</param>
+        public SpanBasedStringBuilder(string str)
+            : this()
+        {
+            if (str == null)
+            {
+                throw new ArgumentNullException(nameof(str));
+            }
+            Append(str);
+        }
+
+        /// <summary>
+        /// Constructs a new empty SpanBasedStringBuilder with the given expected number of spans.
+        /// </summary>
+        public SpanBasedStringBuilder(int capacity = 4)
+        {
+            // Since we're using StringBuilder as the backing store in this implementation, our capacity is expressed
+            // in number of characters rather than number of spans. We use 128 as a reasonable expected multiplier to
+            // go from one to the other, i.e. by default we'll preallocate a 512-character StringBuilder.
+            _builder = new StringBuilder(capacity * 128);
+        }
+
+        /// <summary>
+        /// Gets the length of the string.
+        /// </summary>
+        public int Length => _builder.Length;
+
+        /// <summary>
+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.
+        /// </summary>
+        /// <returns>The enumerator.</returns>
+        public Enumerator GetEnumerator()
+        {
+            return new Enumerator(_builder);
+        }
+
+        /// <summary>
+        /// Converts this instance to a System.String while first searching for a match in the intern table.
+        /// </summary>
+        /// <remarks>
+        /// May allocate depending on whether the string has already been interned.
+        /// </remarks>
+        public override string ToString()
+        {
+            return new InternableString(this).ToString();
+        }
+
+        /// <summary>
+        /// Releases this instance.
+        /// </summary>
+        public void Dispose()
+        {
+            Strings.ReturnSpanBasedStringBuilder(this);
+        }
+
+        #region Public mutating methods
+
+        /// <summary>
+        /// Appends a string.
+        /// </summary>
+        /// <param name="value">The string to append.</param>
+        internal void Append(string value)
+        {
+            _builder.Append(value);
+        }
+
+        /// <summary>
+        /// Appends a substring.
+        /// </summary>
+        /// <param name="value">The string to append.</param>
+        /// <param name="startIndex">The start index of the substring within <paramref name="value"/> to append.</param>
+        /// <param name="count">The length of the substring to append.</param>
+        internal void Append(string value, int startIndex, int count)
+        {
+            _builder.Append(value, startIndex, count);
+        }
+
+        /// <summary>
+        /// Clears this instance making it represent an empty string.
+        /// </summary>
+        public void Clear()
+        {
+            _builder.Length = 0;
+        }
+
+        #endregion
+    }
+}
diff --git a/src/StringTools/SpanBasedStringBuilder.cs b/src/StringTools/SpanBasedStringBuilder.cs
new file mode 100644
index 00000000000..2d388641f85
--- /dev/null
+++ b/src/StringTools/SpanBasedStringBuilder.cs
@@ -0,0 +1,261 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+
+namespace Microsoft.NET.StringTools
+{
+    /// <summary>
+    /// A StringBuilder replacement that keeps a list of <see cref="ReadOnlyMemory{T}"/> spans making up the intermediate string rather
+    /// than a copy of its characters. This has positive impact on both memory (no need to allocate space for the intermediate string)
+    /// and time (no need to copy characters to the intermediate string).
+    /// </summary>
+    /// <remarks>
+    /// The <see cref="ToString"/> method tries to intern the resulting string without even allocating it if it's already interned.
+    /// Use <see cref="Strings.GetSpanBasedStringBuilder"/> to take advantage of pooling to eliminate allocation overhead of this class.
+    /// </remarks>
+    public class SpanBasedStringBuilder : IDisposable
+    {
+        /// <summary>
+        /// Enumerator for the top-level class. Enumerates characters of the string.
+        /// </summary>
+        public struct Enumerator
+        {
+            /// <summary>
+            /// The spans being enumerated.
+            /// </summary>
+            private readonly List<ReadOnlyMemory<char>> _spans;
+
+            /// <summary>
+            /// Index of the current span.
+            /// </summary>
+            private int _spanIndex;
+
+            /// <summary>
+            /// Index of the current character in the current span, -1 if MoveNext has not been called yet.
+            /// </summary>
+            private int _charIndex;
+
+            internal Enumerator(List<ReadOnlyMemory<char>> spans)
+            {
+                _spans = spans;
+                _spanIndex = 0;
+                _charIndex = -1;
+            }
+
+            /// <summary>
+            /// Returns the current character.
+            /// </summary>
+            public readonly char Current
+            {
+                get
+                {
+                    ReadOnlyMemory<char> span = _spans[_spanIndex];
+                    return span.Span[_charIndex];
+                }
+            }
+
+            /// <summary>
+            /// Moves to the next character.
+            /// </summary>
+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>
+            public bool MoveNext()
+            {
+                int newCharIndex = _charIndex + 1;
+                while (_spanIndex < _spans.Count)
+                {
+                    if (newCharIndex < _spans[_spanIndex].Length)
+                    {
+                        _charIndex = newCharIndex;
+                        return true;
+                    }
+                    _spanIndex++;
+                    newCharIndex = 0;
+                }
+                return false;
+            }
+        }
+
+        /// <summary>
+        /// Spans making up the rope.
+        /// </summary>
+        private readonly List<ReadOnlyMemory<char>> _spans;
+
+        /// <summary>
+        /// Internal getter to get the list of spans out of the SpanBasedStringBuilder.
+        /// </summary>
+        internal List<ReadOnlyMemory<char>> Spans => _spans;
+
+        /// <summary>
+        /// Constructs a new SpanBasedStringBuilder containing the given string.
+        /// </summary>
+        /// <param name="str">The string to wrap, must be non-null.</param>
+        public SpanBasedStringBuilder(string str)
+            : this()
+        {
+            if (str == null)
+            {
+                throw new ArgumentNullException(nameof(str));
+            }
+            Append(str);
+        }
+
+        /// <summary>
+        /// Constructs a new empty SpanBasedStringBuilder with the given expected number of spans.
+        /// </summary>
+        public SpanBasedStringBuilder(int capacity = 4)
+        {
+            _spans = new List<ReadOnlyMemory<char>>(capacity);
+            Length = 0;
+        }
+
+        /// <summary>
+        /// Gets the length of the string.
+        /// </summary>
+        public int Length { get; private set; }
+
+        /// <summary>
+        /// Gets the capacity of the SpanBasedStringBuilder in terms of number of spans it can hold without allocating.
+        /// </summary>
+        public int Capacity => _spans.Capacity;
+
+        /// <summary>
+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.
+        /// </summary>
+        /// <returns>The enumerator.</returns>
+        public Enumerator GetEnumerator()
+        {
+            return new Enumerator(_spans);
+        }
+
+        /// <summary>
+        /// Converts this instance to a System.String while first searching for a match in the intern table.
+        /// </summary>
+        /// <remarks>
+        /// May allocate depending on whether the string has already been interned.
+        /// </remarks>
+        public override string ToString()
+        {
+            return new InternableString(this).ToString();
+        }
+
+        /// <summary>
+        /// Releases this instance.
+        /// </summary>
+        public void Dispose()
+        {
+            Strings.ReturnSpanBasedStringBuilder(this);
+        }
+
+        #region Public mutating methods
+
+        /// <summary>
+        /// Appends a string.
+        /// </summary>
+        /// <param name="value">The string to append.</param>
+        public void Append(string value)
+        {
+            if (!string.IsNullOrEmpty(value))
+            {
+                _spans.Add(value.AsMemory());
+                Length += value.Length;
+            }
+        }
+
+        /// <summary>
+        /// Appends a substring.
+        /// </summary>
+        /// <param name="value">The string to append.</param>
+        /// <param name="startIndex">The start index of the substring within <paramref name="value"/> to append.</param>
+        /// <param name="count">The length of the substring to append.</param>
+        public void Append(string value, int startIndex, int count)
+        {
+            if (value != null)
+            {
+                if (count > 0)
+                {
+                    _spans.Add(value.AsMemory(startIndex, count));
+                    Length += count;
+                }
+            }
+            else
+            {
+                if (startIndex != 0 || count != 0)
+                {
+                    throw new ArgumentNullException(nameof(value));
+                }
+            }
+        }
+
+        /// <summary>
+        /// Removes leading white-space characters from the string.
+        /// </summary>
+        public void TrimStart()
+        {
+            for (int spanIdx = 0; spanIdx < _spans.Count; spanIdx++)
+            {
+                ReadOnlySpan<char> span = _spans[spanIdx].Span;
+                int i = 0;
+                while (i < span.Length && char.IsWhiteSpace(span[i]))
+                {
+                    i++;
+                }
+                if (i > 0)
+                {
+                    _spans[spanIdx] = _spans[spanIdx].Slice(i);
+                    Length -= i;
+                }
+                if (!_spans[spanIdx].IsEmpty)
+                {
+                    return;
+                }
+            }
+        }
+
+        /// <summary>
+        /// Removes trailing white-space characters from the string.
+        /// </summary>
+        public void TrimEnd()
+        {
+            for (int spanIdx = _spans.Count - 1; spanIdx >= 0; spanIdx--)
+            {
+                ReadOnlySpan<char> span = _spans[spanIdx].Span;
+                int i = span.Length - 1;
+                while (i >= 0 && char.IsWhiteSpace(span[i]))
+                {
+                    i--;
+                }
+                if (i + 1 < span.Length)
+                {
+                    _spans[spanIdx] = _spans[spanIdx].Slice(0, i + 1);
+                    Length -= span.Length - (i + 1);
+                }
+                if (!_spans[spanIdx].IsEmpty)
+                {
+                    return;
+                }
+            }
+        }
+
+        /// <summary>
+        /// Removes leading and trailing white-space characters from the string.
+        /// </summary>
+        public void Trim()
+        {
+            TrimStart();
+            TrimEnd();
+        }
+
+        /// <summary>
+        /// Clears this instance making it represent an empty string.
+        /// </summary>
+        public void Clear()
+        {
+            _spans.Clear();
+            Length = 0;
+        }
+
+        #endregion
+    }
+}
diff --git a/src/StringTools/StringTools.cs b/src/StringTools/StringTools.cs
new file mode 100644
index 00000000000..fbe794342b9
--- /dev/null
+++ b/src/StringTools/StringTools.cs
@@ -0,0 +1,108 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+
+namespace Microsoft.NET.StringTools
+{
+    public static class Strings
+
+    {
+        #region Fields
+
+        /// <summary>
+        /// Per-thread instance of the SpanBasedStringBuilder, created lazily.
+        /// </summary>
+        /// <remarks>
+        /// This field serves as a per-thread one-item object pool, which is adequate for most use
+        /// cases as the builder is not expected to be held for extended periods of time.
+        /// </remarks>
+        [ThreadStatic]
+        private static SpanBasedStringBuilder? _spanBasedStringBuilder;
+
+        #endregion
+
+        #region Public methods
+
+        /// <summary>
+        /// Interns the given string, keeping only a weak reference to the returned value.
+        /// </summary>
+        /// <param name="str">The string to intern.</param>
+        /// <returns>A string equal to <paramref name="str"/>, could be the same object as <paramref name="str"/>.</returns>
+        /// <remarks>
+        /// The intern pool does not retain strong references to the strings it's holding so strings are automatically evicted
+        /// after they become unrooted. This is in contrast to <c>System.String.Intern</c> which holds strings forever.
+        /// </remarks>
+        public static string WeakIntern(string str)
+        {
+            InternableString internableString = new InternableString(str);
+            return WeakStringCacheInterner.Instance.InternableToString(ref internableString);
+        }
+
+#if !NET35
+        /// <summary>
+        /// Interns the given readonly span of characters, keeping only a weak reference to the returned value.
+        /// </summary>
+        /// <param name="str">The character span to intern.</param>
+        /// <returns>A string equal to <paramref name="str"/>, could be the result of calling ToString() on <paramref name="str"/>.</returns>
+        /// <remarks>
+        /// The intern pool does not retain strong references to the strings it's holding so strings are automatically evicted
+        /// after they become unrooted. This is in contrast to <c>System.String.Intern</c> which holds strings forever.
+        /// </remarks>
+        public static string WeakIntern(ReadOnlySpan<char> str)
+        {
+            InternableString internableString = new InternableString(str);
+            return WeakStringCacheInterner.Instance.InternableToString(ref internableString);
+        }
+#endif
+
+        /// <summary>
+        /// Returns a new or recycled <see cref="SpanBasedStringBuilder"/>.
+        /// </summary>
+        /// <returns>The SpanBasedStringBuilder.</returns>
+        /// <remarks>
+        /// Call <see cref="IDisposable.Dispose"/> on the returned instance to recycle it.
+        /// </remarks>
+        public static SpanBasedStringBuilder GetSpanBasedStringBuilder()
+        {
+            SpanBasedStringBuilder? stringBuilder = _spanBasedStringBuilder;
+            if (stringBuilder == null)
+            {
+                return new SpanBasedStringBuilder();
+            }
+            else
+            {
+                _spanBasedStringBuilder = null;
+                return stringBuilder;
+            }
+        }
+
+        /// <summary>
+        /// Enables diagnostics in the interner. Call <see cref="CreateDiagnosticReport"/> to retrieve the diagnostic data.
+        /// </summary>
+        public static void EnableDiagnostics()
+        {
+            WeakStringCacheInterner.Instance.EnableStatistics();
+        }
+
+        /// <summary>
+        /// Retrieves the diagnostic data describing the current state of the interner. Make sure to call <see cref="EnableDiagnostics"/> beforehand.
+        /// </summary>
+        public static string CreateDiagnosticReport()
+        {
+            return WeakStringCacheInterner.Instance.FormatStatistics();
+        }
+
+        #endregion
+
+        /// <summary>
+        /// Returns a <see cref="SpanBasedStringBuilder"/> instance back to the pool if possible.
+        /// </summary>
+        /// <param name="stringBuilder">The instance to return.</param>
+        internal static void ReturnSpanBasedStringBuilder(SpanBasedStringBuilder stringBuilder)
+        {
+            stringBuilder.Clear();
+            _spanBasedStringBuilder = stringBuilder;
+        }
+    }
+}
diff --git a/src/StringTools/StringTools.csproj b/src/StringTools/StringTools.csproj
new file mode 100644
index 00000000000..1bead8c7ed9
--- /dev/null
+++ b/src/StringTools/StringTools.csproj
@@ -0,0 +1,44 @@
+﻿<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <TargetFrameworks>$(LibraryTargetFrameworks)</TargetFrameworks>
+    <TargetFrameworks Condition="'$(MSBuildRuntimeType)' != 'Core' and '$(MonoBuild)' != 'true'">$(LibraryTargetFrameworks);net35</TargetFrameworks>
+    <PlatformTarget>AnyCPU</PlatformTarget>
+    <WarningsAsErrors>true</WarningsAsErrors>
+    <IsPackable>true</IsPackable>
+    <LangVersion>8.0</LangVersion>
+    <PackageId>Microsoft.NET.StringTools</PackageId>
+    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
+    <Nullable>enable</Nullable>
+
+    <VersionPrefix>1.0.0</VersionPrefix>
+    <AssemblyVersion></AssemblyVersion>
+    <SemanticVersioningV1>true</SemanticVersioningV1>
+
+    <AssemblyName>Microsoft.NET.StringTools</AssemblyName>
+  </PropertyGroup>
+
+  <PropertyGroup Condition="'$(TargetFramework)' == 'net35'">
+    <AssemblyName>Microsoft.NET.StringTools.net35</AssemblyName>
+    <!-- Disable Fx install checks as we're building against jnm2's 3.5 reference assemblies -->
+    <BypassFrameworkInstallChecks>true</BypassFrameworkInstallChecks>
+  </PropertyGroup>
+
+  <ItemGroup Condition="'$(TargetFramework)' != 'net35'">
+    <PackageReference Include="System.Memory" />
+    <PackageReference Include="System.Runtime.CompilerServices.Unsafe" />
+  </ItemGroup>
+  <ItemGroup>
+    <PackageReference Include="jnm2.ReferenceAssemblies.net35" />
+  </ItemGroup>
+
+  <ItemGroup Condition="'$(TargetFramework)' == 'net35'">
+    <Compile Remove="SpanBasedStringBuilder.cs" />
+    <Compile Remove="InternableString.cs" />
+    <Compile Remove="WeakStringCache.Concurrent.cs" />
+  </ItemGroup>
+  <ItemGroup Condition="'$(TargetFramework)' != 'net35'">
+    <Compile Remove="SpanBasedStringBuilder.Simple.cs" />
+    <Compile Remove="InternableString.Simple.cs" />
+    <Compile Remove="WeakStringCache.Locking.cs" />
+  </ItemGroup>
+</Project>
diff --git a/src/StringTools/StringTools.pkgdef b/src/StringTools/StringTools.pkgdef
new file mode 100644
index 00000000000..0c31a20f877
--- /dev/null
+++ b/src/StringTools/StringTools.pkgdef
@@ -0,0 +1,7 @@
+[$RootKey$\RuntimeConfiguration\dependentAssembly\bindingRedirection\{7FBCE0AF-48AC-46AC-8841-F00D17C63A22}]
+"name"="Microsoft.NET.StringTools"
+"codeBase"="$BaseInstallDir$\MSBuild\Current\Bin\Microsoft.NET.StringTools.dll"
+"publicKeyToken"="b03f5f7f11d50a3a"
+"culture"="neutral"
+"oldVersion"="0.0.0.0-1.0.0.0"
+"newVersion"="1.0.0.0"
diff --git a/src/StringTools/WeakStringCache.Concurrent.cs b/src/StringTools/WeakStringCache.Concurrent.cs
new file mode 100644
index 00000000000..6110475e946
--- /dev/null
+++ b/src/StringTools/WeakStringCache.Concurrent.cs
@@ -0,0 +1,124 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Concurrent;
+using System.Collections.Generic;
+using System.Threading;
+
+namespace Microsoft.NET.StringTools
+{
+    /// <summary>
+    /// Implements the WeakStringCache functionality on modern .NET versions where ConcurrentDictionary is available.
+    /// </summary>
+    internal sealed partial class WeakStringCache : IDisposable
+    {
+        private readonly ConcurrentDictionary<int, StringWeakHandle> _stringsByHashCode;
+
+        public WeakStringCache()
+        {
+            _stringsByHashCode = new ConcurrentDictionary<int, StringWeakHandle>(Environment.ProcessorCount, _initialCapacity);
+        }
+
+        /// <summary>
+        /// Main entrypoint of this cache. Tries to look up a string that matches the given internable. If it succeeds, returns
+        /// the string and sets cacheHit to true. If the string is not found, calls ExpensiveConvertToString on the internable,
+        /// adds the resulting string to the cache, and returns it, setting cacheHit to false.
+        /// </summary>
+        /// <param name="internable">The internable describing the string we're looking for.</param>
+        /// <param name="cacheHit">true if match found in cache, false otherwise.</param>
+        /// <returns>A string matching the given internable.</returns>
+        public string GetOrCreateEntry(ref InternableString internable, out bool cacheHit)
+        {
+            int hashCode = internable.GetHashCode();
+
+            StringWeakHandle handle;
+            string? result;
+
+            // Get the existing handle from the cache and lock it while we're dereferencing it to prevent a race with the Scavenge
+            // method running on another thread and freeing the handle from underneath us.
+            if (_stringsByHashCode.TryGetValue(hashCode, out handle))
+            {
+                lock (handle)
+                {
+                    result = handle.GetString(ref internable);
+                    if (result != null)
+                    {
+                        cacheHit = true;
+                        return result;
+                    }
+
+                    // We have the handle but it's not referencing the right string - create the right string and store it in the handle.
+                    result = internable.ExpensiveConvertToString();
+                    handle.SetString(result);
+
+                    cacheHit = false;
+                    return result;
+                }
+            }
+
+            // We don't have the handle in the cache - create the right string, store it in the handle, and add the handle to the cache.
+            result = internable.ExpensiveConvertToString();
+
+            handle = new StringWeakHandle();
+            handle.SetString(result);
+            _stringsByHashCode.TryAdd(hashCode, handle);
+
+            // Remove unused handles if our heuristic indicates that it would be productive.
+            int scavengeThreshold = _scavengeThreshold;
+            if (_stringsByHashCode.Count >= scavengeThreshold)
+            {
+                // Before we start scavenging set _scavengeThreshold to a high value to effectively lock other threads from
+                // running Scavenge at the same time.
+                if (Interlocked.CompareExchange(ref _scavengeThreshold, int.MaxValue, scavengeThreshold) == scavengeThreshold)
+                {
+                    try
+                    {
+                        // Get rid of unused handles.
+                        Scavenge();
+                    }
+                    finally
+                    {
+                        // And do this again when the number of handles reaches double the current after-scavenge number.
+                        _scavengeThreshold = _stringsByHashCode.Count * 2;
+                    }
+                }
+            }
+
+            cacheHit = false;
+            return result;
+        }
+
+        /// <summary>
+        /// Iterates over the cache and removes unused GC handles, i.e. handles that don't reference live strings.
+        /// This is expensive so try to call such that the cost is amortized to O(1) per GetOrCreateEntry() invocation.
+        /// </summary>
+        public void Scavenge()
+        {
+            foreach (KeyValuePair<int, StringWeakHandle> entry in _stringsByHashCode)
+            {
+                // We can safely dereference entry.Value as the caller guarantees that Scavenge runs only on one thread.
+                if (!entry.Value.IsUsed && _stringsByHashCode.TryRemove(entry.Key, out StringWeakHandle removedHandle))
+                {
+                    lock (removedHandle)
+                    {
+                        // Note that the removed handle may be different from the one we got from the enumerator so check again
+                        // and try to put it back if it's still in use.
+                        if (!removedHandle.IsUsed || !_stringsByHashCode.TryAdd(entry.Key, removedHandle))
+                        {
+                            removedHandle.Free();
+                        }
+                    }
+                }
+            }
+        }
+
+        /// <summary>
+        /// Returns internal debug counters calculated based on the current state of the cache.
+        /// </summary>
+        public DebugInfo GetDebugInfo()
+        {
+            return GetDebugInfoImpl();
+        }
+    }
+}
diff --git a/src/MSBuildTaskHost/WeakStringCache.Locking.cs b/src/StringTools/WeakStringCache.Locking.cs
similarity index 93%
rename from src/MSBuildTaskHost/WeakStringCache.Locking.cs
rename to src/StringTools/WeakStringCache.Locking.cs
index d26dd984963..47daf7ee824 100644
--- a/src/MSBuildTaskHost/WeakStringCache.Locking.cs
+++ b/src/StringTools/WeakStringCache.Locking.cs
@@ -4,7 +4,7 @@
 using System;
 using System.Collections.Generic;
 
-namespace Microsoft.Build
+namespace Microsoft.NET.StringTools
 {
     /// <summary>
     /// Implements the WeakStringCache functionality on .NET Framework 3.5 where ConcurrentDictionary is not available.
@@ -25,19 +25,19 @@ public WeakStringCache()
         /// </summary>
         /// <param name="internable">The internable describing the string we're looking for.</param>
         /// <returns>A string matching the given internable.</returns>
-        public string GetOrCreateEntry<T>(T internable, out bool cacheHit) where T : IInternable
+        public string GetOrCreateEntry(ref InternableString internable, out bool cacheHit)
         {
-            int hashCode = GetInternableHashCode(internable);
+            int hashCode = internable.GetHashCode();
 
             StringWeakHandle handle;
-            string result;
+            string? result;
             bool addingNewHandle = false;
 
             lock (_stringsByHashCode)
             {
                 if (_stringsByHashCode.TryGetValue(hashCode, out handle))
                 {
-                    result = handle.GetString(internable);
+                    result = handle.GetString(ref internable);
                     if (result != null)
                     {
                         cacheHit = true;
@@ -81,7 +81,7 @@ public string GetOrCreateEntry<T>(T internable, out bool cacheHit) where T : IIn
         /// </summary>
         private void ScavengeNoLock()
         {
-            List<int> keysToRemove = null;
+            List<int>? keysToRemove = null;
             foreach (KeyValuePair<int, StringWeakHandle> entry in _stringsByHashCode)
             {
                 if (!entry.Value.IsUsed)
diff --git a/src/Shared/WeakStringCache.cs b/src/StringTools/WeakStringCache.cs
similarity index 83%
rename from src/Shared/WeakStringCache.cs
rename to src/StringTools/WeakStringCache.cs
index 22021e1a08a..cedde724390 100644
--- a/src/Shared/WeakStringCache.cs
+++ b/src/StringTools/WeakStringCache.cs
@@ -5,7 +5,7 @@
 using System.Collections.Generic;
 using System.Runtime.InteropServices;
 
-namespace Microsoft.Build
+namespace Microsoft.NET.StringTools
 {
     /// <summary>
     /// A cache of weak GC handles pointing to strings. Weak GC handles are functionally equivalent to WeakReference's but have less overhead
@@ -28,7 +28,7 @@ public struct DebugInfo
         /// <summary>
         /// Holds a weak GC handle to a string. Shared by all strings with the same hash code and referencing the last such string we've seen.
         /// </summary>
-        private struct StringWeakHandle
+        private class StringWeakHandle
         {
             /// <summary>
             /// Weak GC handle to the last string of the given hashcode we've seen.
@@ -45,12 +45,11 @@ private struct StringWeakHandle
             /// </summary>
             /// <param name="internable">The internable describing the string we're looking for.</param>
             /// <returns>The string matching the internable or null if the handle is referencing a collected string or the string is different.</returns>
-            public string GetString<T>(T internable) where T : IInternable
+            public string? GetString(ref InternableString internable)
             {
                 if (WeakHandle.IsAllocated && WeakHandle.Target is string str)
                 {
-                    if (internable.Length == str.Length &&
-                        internable.StartsWithStringByOrdinalComparison(str))
+                    if (internable.Equals(str))
                     {
                         return str;
                     }
@@ -94,28 +93,10 @@ public void Free()
         /// </summary>
         private int _scavengeThreshold = _initialCapacity;
 
-        /// <summary>
-        /// Implements the simple yet very decently performing djb2 hash function (xor version).
-        /// </summary>
-        /// <param name="internable">The internable to compute the hash code for.</param>
-        /// <returns>The 32-bit hash code.</returns>
-        internal static int GetInternableHashCode<T>(T internable) where T : IInternable
-        {
-            int hashCode = 5381;
-            for (int i = 0; i < internable.Length; i++)
-            {
-                unchecked
-                {
-                    hashCode = hashCode * 33 ^ internable[i];
-                }
-            }
-            return hashCode;
-        }
-
         /// <summary>
         /// Frees all GC handles and clears the cache.
         /// </summary>
-        public void Dispose()
+        private void DisposeImpl()
         {
             foreach (KeyValuePair<int, StringWeakHandle> entry in _stringsByHashCode)
             {
@@ -124,6 +105,17 @@ public void Dispose()
             _stringsByHashCode.Clear();
         }
 
+        public void Dispose()
+        {
+            DisposeImpl();
+            GC.SuppressFinalize(this);
+        }
+
+        ~WeakStringCache()
+        {
+            DisposeImpl();
+        }
+
         /// <summary>
         /// Returns internal debug counters calculated based on the current state of the cache.
         /// </summary>
diff --git a/src/StringTools/WeakStringCacheInterner.cs b/src/StringTools/WeakStringCacheInterner.cs
new file mode 100644
index 00000000000..34366af3cfc
--- /dev/null
+++ b/src/StringTools/WeakStringCacheInterner.cs
@@ -0,0 +1,180 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Linq;
+using System.Text;
+
+namespace Microsoft.NET.StringTools
+{
+    /// <summary>
+    /// Implements interning based on a WeakStringCache.
+    /// </summary>
+    internal class WeakStringCacheInterner : IDisposable
+    {
+        /// <summary>
+        /// Enumerates the possible interning results.
+        /// </summary>
+        private enum InternResult
+        {
+            FoundInWeakStringCache,
+            AddedToWeakStringCache,
+        }
+
+        internal static WeakStringCacheInterner Instance = new WeakStringCacheInterner();
+
+        /// <summary>
+        /// The cache to keep strings in.
+        /// </summary>
+        private readonly WeakStringCache _weakStringCache = new WeakStringCache();
+
+#region Statistics
+        /// <summary>
+        /// Number of times the regular interning path found the string in the cache.
+        /// </summary>
+        private int _regularInternHits;
+
+        /// <summary>
+        /// Number of times the regular interning path added the string to the cache.
+        /// </summary>
+        private int _regularInternMisses;
+
+        /// <summary>
+        /// Total number of strings eliminated by interning.
+        /// </summary>
+        private int _internEliminatedStrings;
+
+        /// <summary>
+        /// Total number of chars eliminated across all strings.
+        /// </summary>
+        private int _internEliminatedChars;
+
+        /// <summary>
+        /// Maps strings that went though the interning path to the number of times they have been
+        /// seen. The higher the number the better the payoff of interning. Null if statistics
+        /// gathering has not been enabled.
+        /// </summary>
+        private Dictionary<string, int>? _internCallCountsByString;
+
+#endregion
+
+        /// <summary>
+        /// Try to intern the string.
+        /// The return value indicates the how the string was interned.
+        /// </summary>
+        private InternResult Intern(ref InternableString candidate, out string interned)
+        {
+            interned = _weakStringCache.GetOrCreateEntry(ref candidate, out bool cacheHit);
+            return cacheHit ? InternResult.FoundInWeakStringCache : InternResult.AddedToWeakStringCache;
+        }
+
+        /// <summary>
+        /// WeakIntern the given InternableString.
+        /// </summary>
+        public string InternableToString(ref InternableString candidate)
+        {
+            if (candidate.Length == 0)
+            {
+                return string.Empty;
+            }
+
+            InternResult resultForStatistics = Intern(ref candidate, out string internedString);
+#if DEBUG
+            string expectedString = candidate.ExpensiveConvertToString();
+            if (!String.Equals(internedString, expectedString))
+            {
+                throw new InvalidOperationException(String.Format("Interned string {0} should have been {1}", internedString, expectedString));
+            }
+#endif
+
+            if (_internCallCountsByString != null)
+            {
+                lock (_internCallCountsByString)
+                {
+                    switch (resultForStatistics)
+                    {
+                        case InternResult.FoundInWeakStringCache:
+                            _regularInternHits++;
+                            break;
+                        case InternResult.AddedToWeakStringCache:
+                            _regularInternMisses++;
+                            break;
+                    }
+
+                    _internCallCountsByString.TryGetValue(internedString, out int priorCount);
+                    _internCallCountsByString[internedString] = priorCount + 1;
+
+                    if (!candidate.ReferenceEquals(internedString))
+                    {
+                        // Reference changed so 'candidate' is now released and should save memory.
+                        _internEliminatedStrings++;
+                        _internEliminatedChars += candidate.Length;
+                    }
+                }
+            }
+
+            return internedString;
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        public void EnableStatistics()
+        {
+            _internCallCountsByString = new Dictionary<string, int>();
+        }
+
+        /// <summary>
+        /// Returns a string with human-readable statistics.
+        /// </summary>
+        public string FormatStatistics()
+        {
+            StringBuilder result = new StringBuilder(1024);
+
+            string title = "Opportunistic Intern";
+
+            if (_internCallCountsByString != null)
+            {
+                result.AppendLine(string.Format("\n{0}{1}{0}", new string('=', 41 - (title.Length / 2)), title));
+                result.AppendLine(string.Format("||{0,50}|{1,20:N0}|{2,8}|", "WeakStringCache Hits", _regularInternHits, "hits"));
+                result.AppendLine(string.Format("||{0,50}|{1,20:N0}|{2,8}|", "WeakStringCache Misses", _regularInternMisses, "misses"));
+                result.AppendLine(string.Format("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Strings*", _internEliminatedStrings, "strings"));
+                result.AppendLine(string.Format("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Chars", _internEliminatedChars, "chars"));
+                result.AppendLine(string.Format("||{0,50}|{1,20:N0}|{2,8}|", "Estimated Eliminated Bytes", _internEliminatedChars * 2, "bytes"));
+                result.AppendLine("Elimination assumes that strings provided were unique objects.");
+                result.AppendLine("|---------------------------------------------------------------------------------|");
+
+                IEnumerable<string> topInternedStrings =
+                    _internCallCountsByString
+                    .OrderByDescending(kv => kv.Value * kv.Key.Length)
+                    .Where(kv => kv.Value > 1)
+                    .Take(15)
+                    .Select(kv => string.Format(CultureInfo.InvariantCulture, "({1} instances x each {2} chars)\n{0}", kv.Key, kv.Value, kv.Key.Length));
+
+                result.AppendLine(string.Format("##########Top Top Interned Strings:  \n{0} ", string.Join("\n==============\n", topInternedStrings.ToArray())));
+                result.AppendLine();
+
+                WeakStringCache.DebugInfo debugInfo = _weakStringCache.GetDebugInfo();
+                result.AppendLine("WeakStringCache statistics:");
+                result.AppendLine(string.Format("String count live/collected/total = {0}/{1}/{2}", debugInfo.LiveStringCount, debugInfo.CollectedStringCount, debugInfo.LiveStringCount + debugInfo.CollectedStringCount));
+            }
+            else
+            {
+                result.Append(title);
+                result.AppendLine(" - EnableStatisticsGathering() has not been called");
+            }
+
+            return result.ToString();
+        }
+
+        /// <summary>
+        /// Releases all strings from the underlying intern table.
+        /// </summary>
+        public void Dispose()
+        {
+            _weakStringCache.Dispose();
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index 2d0f453a127..2d0aaec17b3 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -3686,6 +3686,37 @@ public void ConflictGeneratesMessageReferencingAssemblyName()
             warningMessage.ShouldContain(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.FourSpaceIndent", ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.ReferenceDependsOn", "D, Version=1.0.0.0, CulTUre=neutral, PublicKeyToken=aaaaaaaaaaaaaaaa", Path.Combine(s_myLibraries_V1Path, "D.dll"))));
         }
 
+        [Fact]
+        public void ConflictOutputsExtraInformationOnDemand()
+        {
+            ResolveAssemblyReference t = new ResolveAssemblyReference();
+
+            MockEngine e = new MockEngine(_output);
+            t.BuildEngine = e;
+
+            t.Assemblies = new ITaskItem[]
+            {
+                new TaskItem("B"),
+                new TaskItem("D, Version=1.0.0.0, Culture=neutral, PublicKeyToken=aaaaaaaaaaaaaaaa")
+            };
+
+            t.SearchPaths = new string[]
+            {
+                s_myLibrariesRootPath, s_myLibraries_V2Path, s_myLibraries_V1Path
+            };
+
+            t.TargetFrameworkDirectories = new string[] { s_myVersion20Path };
+            t.OutputUnresolvedAssemblyConflicts = true;
+
+            Execute(t);
+
+            ITaskItem[] conflicts = t.UnresolvedAssemblyConflicts;
+            conflicts.Length.ShouldBe(1);
+            conflicts[0].ItemSpec.ShouldBe("D");
+            conflicts[0].GetMetadata("victorVersionNumber").ShouldBe("1.0.0.0");
+            conflicts[0].GetMetadata("victimVersionNumber").ShouldBe("2.0.0.0");
+        }
+
         /// <summary>
         /// Consider this dependency chain:
         ///
diff --git a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
index fab60ae6143..286126baf37 100644
--- a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
+++ b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
@@ -1101,6 +1101,36 @@ public void BuildTaskSimpleCodeFactoryTempDirectoryDoesntExist()
                 FileUtilities.DeleteDirectoryNoThrow(newTempPath, true);
             }
         }
+
+        /// <summary>
+        /// Test the simple case where we have a string parameter and we want to log that.
+        /// </summary>
+        [Fact]
+        public void RedundantMSBuildReferences()
+        {
+            string projectFileContents = @"
+                    <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003' ToolsVersion='msbuilddefaulttoolsversion'>
+                        <UsingTask TaskName=`CustomTaskFromCodeFactory_RedundantMSBuildReferences` TaskFactory=`CodeTaskFactory` AssemblyFile=`$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll` >
+                         <ParameterGroup>     
+                             <Text/>
+                          </ParameterGroup>
+                            <Task>
+                              <Reference Include='$(MSBuildToolsPath)\Microsoft.Build.Framework.dll' />
+                              <Reference Include='$(MSBuildToolsPath)\Microsoft.Build.Utilities.Core.dll' />
+
+                                <Code>
+                                     Log.LogMessage(MessageImportance.High, Text);
+                                </Code>
+                            </Task>
+                        </UsingTask>
+                        <Target Name=`Build`>
+                            <CustomTaskFromCodeFactory_RedundantMSBuildReferences Text=`Hello, World!` />
+                        </Target>
+                    </Project>";
+
+            MockLogger mockLogger = Helpers.BuildProjectWithNewOMExpectSuccess(projectFileContents);
+            mockLogger.AssertLogContains("Hello, World!");
+        }
     }
 #else
     public sealed class CodeTaskFactoryTests
diff --git a/src/Tasks.UnitTests/CommandLine_Support.cs b/src/Tasks.UnitTests/CommandLine_Support.cs
index 4319bce40fa..3698bc32d69 100644
--- a/src/Tasks.UnitTests/CommandLine_Support.cs
+++ b/src/Tasks.UnitTests/CommandLine_Support.cs
@@ -38,7 +38,7 @@ static internal bool CallValidateParameters(ToolTask task)
         private static string[] Parse(string cl)
         {
             int emptySplits;
-            string[] pieces = (string[])QuotingUtilities.SplitUnquoted(cl, int.MaxValue, false, true, out emptySplits, ' ', '\n').ToArray(typeof(string));
+            string[] pieces = QuotingUtilities.SplitUnquoted(cl, int.MaxValue, false, true, out emptySplits, ' ', '\n').ToArray();
             return pieces;
         }
 
diff --git a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
index b764f4d7869..22e3eb6a34c 100644
--- a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
+++ b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
@@ -13,7 +13,7 @@
 using Xunit;
 using Xunit.Abstractions;
 
-namespace Microsoft.Build.Tasks.Unittest
+namespace Microsoft.Build.Tasks.UnitTests
 {
     public class GenerateBindingRedirectsTests : IDisposable
     {
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index 99a093212d9..cd00af8329e 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -1,9 +1,9 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
-    
+
     <IsPackable>false</IsPackable>
 
     <AssemblyName>Microsoft.Build.Tasks.UnitTests</AssemblyName>
@@ -13,7 +13,6 @@
 
   <ItemGroup>
     <PackageReference Include="System.Security.Principal.Windows" />
-    <PackageReference Include="System.Xml.XPath" />
     <PackageReference Include="Shouldly" />
 
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
@@ -32,7 +31,7 @@
     <Reference Include="System.Net.Http" />
     <Reference Include="System.Xaml" />
     <Reference Include="System.Xml" />
-    <Reference Include="PresentationFramework" Condition="'$(OsEnvironment)' == 'windows'" />
+    <Reference Include="PresentationFramework" Condition="$([MSBuild]::IsOSPlatform('windows'))" />
     <Reference Include="System.Xml.Linq" />
   </ItemGroup>
 
@@ -61,7 +60,7 @@
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
 
     <EmbeddedResource Include="SampleResx" />
-    
+
     <None Include="..\Shared\UnitTests\App.config">
       <Link>App.config</Link>
       <SubType>Designer</SubType>
diff --git a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
index cdedaeeca88..eb5225d098d 100644
--- a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
@@ -17,6 +17,77 @@ public class RoslynCodeTaskFactory_Tests
     {
         private const string TaskName = "MyInlineTask";
 
+        [Fact]
+        public void RoslynCodeTaskFactory_ReuseCompilation()
+        {
+            string text1 = $@"
+<Project>
+
+  <UsingTask
+    TaskName=""Custom1""
+    TaskFactory=""RoslynCodeTaskFactory""
+    AssemblyFile=""$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll"" >
+    <ParameterGroup>
+      <SayHi ParameterType=""System.String"" Required=""true"" />
+    </ParameterGroup>
+    <Task>
+      <Reference Include=""{typeof(Enumerable).Assembly.Location}"" />
+      <Code Type=""Fragment"" Language=""cs"">
+        Log.LogMessage(SayHi);
+      </Code>
+    </Task>
+  </UsingTask>
+
+    <Target Name=""Build"">
+        <MSBuild Projects=""p2.proj"" Targets=""Build"" />
+        <Custom1 SayHi=""hello1"" />
+        <Custom1 SayHi=""hello2"" />
+    </Target>
+
+</Project>";
+
+            var text2 = $@"
+<Project>
+
+  <UsingTask
+    TaskName=""Custom1""
+    TaskFactory=""RoslynCodeTaskFactory""
+    AssemblyFile=""$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll"" >
+    <ParameterGroup>
+      <SayHi ParameterType=""System.String"" Required=""true"" />
+    </ParameterGroup>
+    <Task>
+      <Reference Include=""{typeof(Enumerable).Assembly.Location}"" />
+      <Code Type=""Fragment"" Language=""cs"">
+        Log.LogMessage(SayHi);
+      </Code>
+    </Task>
+  </UsingTask>
+
+    <Target Name=""Build"">
+        <Custom1 SayHi=""hello1"" />
+        <Custom1 SayHi=""hello2"" />
+    </Target>
+
+</Project>";
+
+            using var env = TestEnvironment.Create();
+
+            var p2 = env.CreateTestProjectWithFiles("p2.proj", text2);
+            text1 = text1.Replace("p2.proj", p2.ProjectFile);
+            var p1 = env.CreateTestProjectWithFiles("p1.proj", text1);
+
+            var logger = p1.BuildProjectExpectSuccess();
+            var messages = logger
+                .BuildMessageEvents
+                .Where(m => m.Message == "Compiling task source code")
+                .ToArray();
+
+            // with broken cache we get two Compiling messages
+            // as we fail to reuse the first assembly
+            messages.Count().ShouldBe(1);
+        }
+
         [Fact]
         public void VisualBasicFragment()
         {
diff --git a/src/Tasks.UnitTests/Unzip_Tests.cs b/src/Tasks.UnitTests/Unzip_Tests.cs
index 4ccb35c6a2d..8b48e6ccaf8 100644
--- a/src/Tasks.UnitTests/Unzip_Tests.cs
+++ b/src/Tasks.UnitTests/Unzip_Tests.cs
@@ -214,5 +214,212 @@ public void LogsErrorIfSourceFileDoesNotExist()
                 _mockEngine.Log.ShouldContain("MSB3932", () => _mockEngine.Log);
             }
         }
+
+        [Fact]
+        public void CanUnzip_WithIncludeFilter()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);
+                testEnvironment.CreateFile(source, "BE78A17D30144B549D21F71D5C633F7D.txt", "file1");
+                testEnvironment.CreateFile(source, "A04FF4B88DF14860B7C73A8E75A4FB76.txt", "file2");
+
+                TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
+
+                Unzip unzip = new Unzip
+                                  {
+                                      BuildEngine = _mockEngine,
+                                      DestinationFolder = new TaskItem(destination.Path),
+                                      OverwriteReadOnlyFiles = true,
+                                      SkipUnchangedFiles = false,
+                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                                      Include = "BE78A17D30144B549D21F71D5C633F7D.txt"
+                                  };
+
+                unzip.Execute().ShouldBeTrue(() => _mockEngine.Log);
+
+                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "BE78A17D30144B549D21F71D5C633F7D.txt"), () => _mockEngine.Log);
+                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, "A04FF4B88DF14860B7C73A8E75A4FB76.txt"), () => _mockEngine.Log);
+            }
+        }
+
+        [Fact]
+        public void CanUnzip_WithExcludeFilter()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);
+                testEnvironment.CreateFile(source, "BE78A17D30144B549D21F71D5C633F7D.txt", "file1");
+                testEnvironment.CreateFile(source, "A04FF4B88DF14860B7C73A8E75A4FB76.txt", "file2");
+
+                TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
+
+                Unzip unzip = new Unzip
+                                  {
+                                      BuildEngine = _mockEngine,
+                                      DestinationFolder = new TaskItem(destination.Path),
+                                      OverwriteReadOnlyFiles = true,
+                                      SkipUnchangedFiles = false,
+                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                                      Exclude = "BE78A17D30144B549D21F71D5C633F7D.txt"
+                                  };
+
+                unzip.Execute().ShouldBeTrue(() => _mockEngine.Log);
+
+                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, "BE78A17D30144B549D21F71D5C633F7D.txt"), () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "A04FF4B88DF14860B7C73A8E75A4FB76.txt"), () => _mockEngine.Log);
+            }
+        }
+
+        [Fact]
+        public void CanUnzip_WithIncludeAndExcludeFilter()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);
+                TransientTestFolder sub = source.CreateDirectory("sub");
+                testEnvironment.CreateFile(source, "file1.js", "file1");
+                testEnvironment.CreateFile(source, "file1.js.map", "file2");
+                testEnvironment.CreateFile(source, "file2.js", "file3");
+                testEnvironment.CreateFile(source, "readme.txt", "file4");
+                testEnvironment.CreateFile(sub, "subfile.js", "File5");
+
+                TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
+
+                Unzip unzip = new Unzip
+                                  {
+                                      BuildEngine = _mockEngine,
+                                      DestinationFolder = new TaskItem(destination.Path),
+                                      OverwriteReadOnlyFiles = true,
+                                      SkipUnchangedFiles = false,
+                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                                      Include = "*.js",
+                                      Exclude = "*.js.map;sub\\*.js"
+                                  };
+
+                unzip.Execute().ShouldBeTrue(() => _mockEngine.Log);
+
+                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "file1.js"), () => _mockEngine.Log);
+                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, "file1.js.map"), () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "file2.js"), () => _mockEngine.Log);
+                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, "readme.txt"), () => _mockEngine.Log);
+                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, "sub", "subfile.js"), () => _mockEngine.Log);
+            }
+        }
+
+        [Fact]
+        public void LogsErrorIfIncludeContainsInvalidPathCharacters()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);
+                testEnvironment.CreateFile(source, "BE78A17D30144B549D21F71D5C633F7D.txt", "file1");
+                testEnvironment.CreateFile(source, "A04FF4B88DF14860B7C73A8E75A4FB76.txt", "file2");
+
+                TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
+
+                Unzip unzip = new Unzip
+                                  {
+                                      BuildEngine = _mockEngine,
+                                      DestinationFolder = new TaskItem(destination.Path),
+                                      OverwriteReadOnlyFiles = true,
+                                      SkipUnchangedFiles = false,
+                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                                      Include = "<BE78A17D30144B|549D21F71D5C633F7D/.txt"
+                                  };
+
+                unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
+
+                _mockEngine.Log.ShouldContain("MSB3937", () => _mockEngine.Log);
+            }
+        }
+
+        [Fact]
+        public void LogsErrorIfIncludeContainsPropertyReferences()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);
+                testEnvironment.CreateFile(source, "BE78A17D30144B549D21F71D5C633F7D.txt", "file1");
+                testEnvironment.CreateFile(source, "A04FF4B88DF14860B7C73A8E75A4FB76.txt", "file2");
+
+                TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
+
+                Unzip unzip = new Unzip
+                                  {
+                                      BuildEngine = _mockEngine,
+                                      DestinationFolder = new TaskItem(destination.Path),
+                                      OverwriteReadOnlyFiles = true,
+                                      SkipUnchangedFiles = false,
+                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                                      Include = "$(Include)"
+                                  };
+
+                unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
+
+                _mockEngine.Log.ShouldContain("MSB3938", () => _mockEngine.Log);
+            }
+        }
+
+        [Fact]
+        public void LogsErrorIfExcludeContainsInvalidPathCharacters()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);
+                testEnvironment.CreateFile(source, "BE78A17D30144B549D21F71D5C633F7D.txt", "file1");
+                testEnvironment.CreateFile(source, "A04FF4B88DF14860B7C73A8E75A4FB76.txt", "file2");
+
+                TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
+
+                Unzip unzip = new Unzip
+                                  {
+                                      BuildEngine = _mockEngine,
+                                      DestinationFolder = new TaskItem(destination.Path),
+                                      OverwriteReadOnlyFiles = true,
+                                      SkipUnchangedFiles = false,
+                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                                      Exclude = "<BE78A17D30144B|549D21F71D5C633F7D/.txt"
+                                  };
+
+                unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
+
+                _mockEngine.Log.ShouldContain("MSB3937", () => _mockEngine.Log);
+            }
+        }
+
+        [Fact]
+        public void LogsErrorIfExcludeContainsPropertyReferences()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);
+                testEnvironment.CreateFile(source, "BE78A17D30144B549D21F71D5C633F7D.txt", "file1");
+                testEnvironment.CreateFile(source, "A04FF4B88DF14860B7C73A8E75A4FB76.txt", "file2");
+
+                TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
+
+                Unzip unzip = new Unzip
+                                  {
+                                      BuildEngine = _mockEngine,
+                                      DestinationFolder = new TaskItem(destination.Path),
+                                      OverwriteReadOnlyFiles = true,
+                                      SkipUnchangedFiles = false,
+                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                                      Exclude = "$(Include)"
+                                  };
+
+                unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
+
+                _mockEngine.Log.ShouldContain("MSB3938", () => _mockEngine.Log);
+            }
+        }
     }
 }
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index a842843a021..dcc38343d3c 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -2236,6 +2236,118 @@ Dictionary<string, List<AssemblyNameReference>> baseNameToReferences
             }
         }
 
+        // TODO: Verify correctness of this implementation and extend to more cases.
+        // Should be consistent with CompareAssemblyIdentity from Fusion API:
+        // The result should be TRUE if one (or more) of the following conditions is true:
+        // a) The assembly identities are equivalent. For strongly-named assemblies this means full match on (name, version, pkt, culture); for simply-named assemblies this means a match on (name, culture)
+        // b) The assemblies being compared are FX assemblies (even if the version numbers are not the same, these will compare as equivalent by way of unification)
+        // c) The assemblies are not FX assemblies but are equivalent because fUnified1 and/or fUnified2 were set.
+        // The fUnified flag is used to indicate that all versions up to the version number of the strongly-named assembly are considered equivalent to itself.
+        // For example, if assemblyIdentity1 is "foo, version=5.0.0.0, culture=neutral, publicKeyToken=...." and fUnified1==TRUE, then this means to treat all versions of the assembly in the range 0.0.0.0-5.0.0.0 to be equivalent to "foo, version=5.0.0.0, culture=neutral, publicKeyToken=...".
+        // If assemblyIdentity2 is the same as assemblyIdentity1, except has a lower version number (e.g.version range 0.0.0.0-5.0.0.0), then the function will return that the identities are equivalent.
+        // If assemblyIdentity2 is the same as assemblyIdentity1, but has a greater version number than 5.0.0.0 then the two identities will only be equivalent if fUnified2 is set.
+        /// <summary>
+        /// Compares two assembly identities to determine whether or not they are equivalent.
+        /// </summary>
+        /// <param name="assemblyIdentity1"> Textual identity of the first assembly to be compared.</param>
+        /// <param name="fUnified1">Flag to indicate user-specified unification for assemblyIdentity1.</param>
+        /// <param name="assemblyIdentity2">Textual identity of the second assembly to be compared.</param>
+        /// <param name="fUnified2">Flag to indicate user-specified unification for assemblyIdentity2.</param>
+        /// <returns>
+        /// Boolean indicating whether the identities are equivalent.
+        /// </returns>
+        private static bool AreAssembliesEquivalent(
+            string assemblyIdentity1,
+            bool fUnified1,
+            string assemblyIdentity2,
+            bool fUnified2)
+        {
+            AssemblyName an1 = new AssemblyName(assemblyIdentity1);
+            AssemblyName an2 = new AssemblyName(assemblyIdentity2);
+
+            if (RefMatchesDef(an1, an2))
+            {
+                return true;
+            }
+
+            if (!an1.Name.Equals(an2.Name, StringComparison.OrdinalIgnoreCase))
+            {
+                return false;
+            }
+
+            var versionCompare = an1.Version.CompareTo(an2.Version);
+
+            if ((versionCompare < 0 && fUnified2) || (versionCompare > 0 && fUnified1))
+            {
+                return true;
+            }
+
+            if (versionCompare == 0)
+            {
+                return true;
+            }
+
+            return false;
+        }
+
+        //  Based on coreclr baseassemblyspec.cpp (https://github.com/dotnet/coreclr/blob/4cf8a6b082d9bb1789facd996d8265d3908757b2/src/vm/baseassemblyspec.cpp#L330)
+        private static bool RefMatchesDef(AssemblyName @ref, AssemblyName def)
+        {
+            if (IsStrongNamed(@ref))
+            {
+                return IsStrongNamed(def) && CompareRefToDef(@ref, def);
+            }
+            else
+            {
+                return @ref.Name.Equals(def.Name, StringComparison.OrdinalIgnoreCase);
+            }
+        }
+
+        // Based on coreclr baseassemblyspec.inl (https://github.com/dotnet/coreclr/blob/32f0f9721afb584b4a14d69135bea7ddc129f755/src/vm/baseassemblyspec.inl#L679-L683)
+        private static bool IsStrongNamed(AssemblyName assembly)
+        {
+            var refPkt = assembly.GetPublicKeyToken();
+            return refPkt != null && refPkt.Length != 0;
+        }
+
+        //  Based on https://github.com/dotnet/coreclr/blob/4cf8a6b082d9bb1789facd996d8265d3908757b2/src/vm/baseassemblyspec.cpp#L241
+        private static bool CompareRefToDef(AssemblyName @ref, AssemblyName def)
+        {
+            if (!@ref.Name.Equals(def.Name, StringComparison.OrdinalIgnoreCase))
+            {
+                return false;
+            }
+
+            byte[] rpkt = @ref.GetPublicKeyToken();
+            byte[] dpkt = def.GetPublicKeyToken();
+
+            if (rpkt.Length != dpkt.Length)
+            {
+                return false;
+            }
+
+            for (int i = 0; i < rpkt.Length; i++)
+            {
+                if (rpkt[i] != dpkt[i])
+                {
+                    return false;
+                }
+            }
+
+            if (@ref.Version != def.Version)
+            {
+                return false;
+            }
+
+            if (@ref.CultureName != null &&
+                @ref.CultureName != def.CultureName)
+            {
+                return false;
+            }
+
+            return true;
+        }
+
         /// <summary>
         /// Given two references along with their fusion names, resolve the filename conflict that they
         /// would have if both assemblies need to be copied to the same directory.
@@ -2279,14 +2391,12 @@ private static int ResolveAssemblyNameConflict(AssemblyNameReference assemblyRef
                 bool rightConflictLegacyUnified = !isNonUnified && assemblyReference1.reference.IsPrimary;
 
                 // This is ok here because even if the method says two versions are equivalent the algorithm below will still pick the highest version.
-                NativeMethods.CompareAssemblyIdentity
+                bool equivalent = AreAssembliesEquivalent
                 (
                     leftConflictFusionName,
                     leftConflictLegacyUnified,
                     rightConflictFusionName,
-                    rightConflictLegacyUnified,
-                    out bool equivalent,
-                    out _
+                    rightConflictLegacyUnified
                 );
 
                 Version leftConflictVersion = assemblyReference0.assemblyName.Version;
@@ -2506,14 +2616,6 @@ internal void GetReferenceItems
             out ITaskItem[] copyLocalFiles
         )
         {
-            primaryFiles = Array.Empty<ITaskItem>();
-            dependencyFiles = Array.Empty<ITaskItem>();
-            relatedFiles = Array.Empty<ITaskItem>();
-            satelliteFiles = Array.Empty<ITaskItem>();
-            serializationAssemblyFiles = Array.Empty<ITaskItem>();
-            scatterFiles = Array.Empty<ITaskItem>();
-            copyLocalFiles = Array.Empty<ITaskItem>();
-
             var primaryItems = new List<ITaskItem>();
             var dependencyItems = new List<ITaskItem>();
             var relatedItems = new List<ITaskItem>();
@@ -2522,10 +2624,10 @@ out ITaskItem[] copyLocalFiles
             var scatterItems = new List<ITaskItem>();
             var copyLocalItems = new List<ITaskItem>();
 
-            foreach (AssemblyNameExtension assemblyName in References.Keys)
+            foreach (KeyValuePair<AssemblyNameExtension, Reference> kvp in References)
             {
-                string fusionName = assemblyName.FullName;
-                Reference reference = GetReference(assemblyName);
+                AssemblyNameExtension assemblyName = kvp.Key;
+                Reference reference = kvp.Value;
 
                 // Conflict victims and badimages are filtered out.
                 if (!reference.IsBadImage)
@@ -2554,7 +2656,7 @@ out ITaskItem[] copyLocalFiles
 
                     if (reference.IsResolved)
                     {
-                        ITaskItem referenceItem = SetItemMetadata(relatedItems, satelliteItems, serializationAssemblyItems, scatterItems, fusionName, reference, assemblyName);
+                        ITaskItem referenceItem = SetItemMetadata(relatedItems, satelliteItems, serializationAssemblyItems, scatterItems, assemblyName.FullName, reference, assemblyName);
 
                         if (reference.IsPrimary)
                         {
@@ -2573,9 +2675,7 @@ out ITaskItem[] copyLocalFiles
                 }
             }
 
-            primaryFiles = new ITaskItem[primaryItems.Count];
-            primaryItems.CopyTo(primaryFiles, 0);
-
+            primaryFiles = primaryItems.ToArray();
             dependencyFiles = dependencyItems.ToArray();
             relatedFiles = relatedItems.ToArray();
             satelliteFiles = satelliteItems.ToArray();
@@ -2601,22 +2701,12 @@ out ITaskItem[] copyLocalFiles
         private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem> satelliteItems, List<ITaskItem> serializationAssemblyItems, List<ITaskItem> scatterItems, string fusionName, Reference reference, AssemblyNameExtension assemblyName)
         {
             // Set up the main item.
-            ITaskItem referenceItem = new TaskItem();
+            TaskItem referenceItem = new TaskItem();
             referenceItem.ItemSpec = reference.FullPath;
             referenceItem.SetMetadata(ItemMetadataNames.resolvedFrom, reference.ResolvedSearchPath);
 
             // Set the CopyLocal metadata.
-            if (reference.IsCopyLocal)
-            {
-                referenceItem.SetMetadata(ItemMetadataNames.copyLocal, "true");
-            }
-            else
-            {
-                referenceItem.SetMetadata(ItemMetadataNames.copyLocal, "false");
-            }
-
-            // Set the FusionName metadata.
-            referenceItem.SetMetadata(ItemMetadataNames.fusionName, fusionName);
+            referenceItem.SetMetadata(ItemMetadataNames.copyLocal, reference.IsCopyLocal ? "true" : "false");
 
             // Set the Redist name metadata.
             if (!String.IsNullOrEmpty(reference.RedistName))
@@ -2637,57 +2727,11 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>
                 referenceItem.SetMetadata(ItemMetadataNames.imageRuntime, reference.ImageRuntime);
             }
 
-            if (reference.IsWinMDFile)
-            {
-                referenceItem.SetMetadata(ItemMetadataNames.winMDFile, "true");
-
-                // The ImplementationAssembly is only set if the implementation file exits on disk
-                if (reference.ImplementationAssembly != null)
-                {
-                    if (VerifyArchitectureOfImplementationDll(reference.ImplementationAssembly, reference.FullPath))
-                    {
-                        if (string.IsNullOrEmpty(referenceItem.GetMetadata(ItemMetadataNames.winmdImplmentationFile)))
-                        {
-                            referenceItem.SetMetadata(ItemMetadataNames.winmdImplmentationFile, Path.GetFileName(reference.ImplementationAssembly));
-                        }
-
-                        // Add the implementation item as a related file
-                        ITaskItem item = new TaskItem(reference.ImplementationAssembly);
-                        // Clone metadata.
-                        referenceItem.CopyMetadataTo(item);
-                        // Related files don't have a fusion name.
-                        item.SetMetadata(ItemMetadataNames.fusionName, "");
-                        RemoveNonForwardableMetadata(item);
-
-                        // Add the related item.
-                        relatedItems.Add(item);
-                    }
-                }
-
-                if (reference.IsManagedWinMDFile)
-                {
-                    referenceItem.SetMetadata(ItemMetadataNames.winMDFileType, "Managed");
-                }
-                else
-                {
-                    referenceItem.SetMetadata(ItemMetadataNames.winMDFileType, "Native");
-                }
-            }
-
-            // Set the IsRedistRoot metadata
-            if (reference.IsRedistRoot == true)
-            {
-                referenceItem.SetMetadata(ItemMetadataNames.isRedistRoot, "true");
-            }
-            else if (reference.IsRedistRoot == false)
-            {
-                referenceItem.SetMetadata(ItemMetadataNames.isRedistRoot, "false");
-            }
-            else
+            // The redist root is "null" when there was no IsRedistRoot flag in the Redist XML
+            // (or there was no redist XML at all for this item).
+            if (reference.IsRedistRoot != null)
             {
-                // This happens when the redist root is "null". This means there
-                // was no IsRedistRoot flag in the Redist XML (or there was no 
-                // redist XML at all for this item).
+                referenceItem.SetMetadata(ItemMetadataNames.isRedistRoot, (bool)reference.IsRedistRoot ? "true" : "false");
             }
 
             // If there was a primary source item, then forward metadata from it.
@@ -2716,14 +2760,14 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>
                 }
 
                 // If the item originally did not have the implementation file metadata then we do not want to get it from the set of primary source items
-                // since the implementation file is something specific to the source item and not supposed to be propigated.
+                // since the implementation file is something specific to the source item and not supposed to be propagated.
                 if (!hasImplementationFile)
                 {
                     referenceItem.RemoveMetadata(ItemMetadataNames.winmdImplmentationFile);
                 }
 
                 // If the item originally did not have the ImageRuntime metadata then we do not want to get it from the set of primary source items
-                // since the ImageRuntime is something specific to the source item and not supposed to be propigated.
+                // since the ImageRuntime is something specific to the source item and not supposed to be propagated.
                 if (!hasImageRuntime)
                 {
                     referenceItem.RemoveMetadata(ItemMetadataNames.imageRuntime);
@@ -2737,68 +2781,63 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>
                 }
             }
 
-            if (reference.ReferenceVersion != null)
-            {
-                referenceItem.SetMetadata(ItemMetadataNames.version, reference.ReferenceVersion.ToString());
-            }
-            else
+            referenceItem.SetMetadata(ItemMetadataNames.version, reference.ReferenceVersion == null ? string.Empty : reference.ReferenceVersion.ToString());
+
+            // Unset fusionName so we don't have to unset it later.
+            referenceItem.RemoveMetadata(ItemMetadataNames.fusionName);
+
+            List<string> relatedFileExtensions = reference.GetRelatedFileExtensions();
+            List<string> satellites = reference.GetSatelliteFiles();
+            List<string> serializationAssemblyFiles = reference.GetSerializationAssemblyFiles();
+            string[] scatterFiles = reference.GetScatterFiles();
+            Dictionary<string, string> nonForwardableMetadata = null;
+            if (relatedFileExtensions.Count > 0 || satellites.Count > 0 || serializationAssemblyFiles.Count > 0 || scatterFiles.Length > 0)
             {
-                referenceItem.SetMetadata(ItemMetadataNames.version, String.Empty);
+                // Unset non-forwardable metadata now so we don't have to do it for individual items.
+                nonForwardableMetadata = RemoveNonForwardableMetadata(referenceItem);
             }
 
             // Now clone all properties onto the related files.
-            foreach (string relatedFileExtension in reference.GetRelatedFileExtensions())
+            foreach (string relatedFileExtension in relatedFileExtensions)
             {
                 ITaskItem item = new TaskItem(reference.FullPathWithoutExtension + relatedFileExtension);
                 // Clone metadata.
                 referenceItem.CopyMetadataTo(item);
-                // Related files don't have a fusion name.
-                item.SetMetadata(ItemMetadataNames.fusionName, "");
-                RemoveNonForwardableMetadata(item);
 
                 // Add the related item.
                 relatedItems.Add(item);
             }
 
             // Set up the satellites.
-            foreach (string satelliteFile in reference.GetSatelliteFiles())
+            foreach (string satelliteFile in satellites)
             {
                 ITaskItem item = new TaskItem(Path.Combine(reference.DirectoryName, satelliteFile));
                 // Clone metadata.
                 referenceItem.CopyMetadataTo(item);
                 // Set the destination directory.
                 item.SetMetadata(ItemMetadataNames.destinationSubDirectory, FileUtilities.EnsureTrailingSlash(Path.GetDirectoryName(satelliteFile)));
-                // Satellite files don't have a fusion name.
-                item.SetMetadata(ItemMetadataNames.fusionName, "");
-                RemoveNonForwardableMetadata(item);
 
                 // Add the satellite item.
                 satelliteItems.Add(item);
             }
 
             // Set up the serialization assemblies
-            foreach (string serializationAssemblyFile in reference.GetSerializationAssemblyFiles())
+            foreach (string serializationAssemblyFile in serializationAssemblyFiles)
             {
                 ITaskItem item = new TaskItem(Path.Combine(reference.DirectoryName, serializationAssemblyFile));
                 // Clone metadata.
                 referenceItem.CopyMetadataTo(item);
-                // serialization assemblies files don't have a fusion name.
-                item.SetMetadata(ItemMetadataNames.fusionName, "");
-                RemoveNonForwardableMetadata(item);
 
                 // Add the serialization assembly item.
                 serializationAssemblyItems.Add(item);
             }
 
             // Set up the scatter files.
-            foreach (string scatterFile in reference.GetScatterFiles())
+            foreach (string scatterFile in scatterFiles)
             {
                 ITaskItem item = new TaskItem(Path.Combine(reference.DirectoryName, scatterFile));
                 // Clone metadata.
                 referenceItem.CopyMetadataTo(item);
-                // We don't have a fusion name for scatter files.
-                item.SetMetadata(ItemMetadataNames.fusionName, "");
-                RemoveNonForwardableMetadata(item);
 
                 // Add the satellite item.
                 scatterItems.Add(item);
@@ -2818,6 +2857,61 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>
                 }
             }
 
+            if (reference.IsWinMDFile)
+            {
+                // The ImplementationAssembly is only set if the implementation file exits on disk
+                if (reference.ImplementationAssembly != null)
+                {
+                    if (VerifyArchitectureOfImplementationDll(reference.ImplementationAssembly, reference.FullPath))
+                    {
+                        // Add the implementation item as a related file
+                        ITaskItem item = new TaskItem(reference.ImplementationAssembly);
+                        // Clone metadata.
+                        referenceItem.CopyMetadataTo(item);
+
+                        // Add the related item.
+                        relatedItems.Add(item);
+
+                        referenceItem.SetMetadata(ItemMetadataNames.winmdImplmentationFile, Path.GetFileName(reference.ImplementationAssembly));
+                        // This may have been set previously (before it was removed so we could more efficiently set metadata on the various related files).
+                        // This version should take priority, so we remove it from nonForwardableMetadata if it's there to prevent the correct value from
+                        // being overwritten.
+                        nonForwardableMetadata?.Remove(ItemMetadataNames.winmdImplmentationFile);
+                    }
+                }
+
+                // This may have been set previously (before it was removed so we could more efficiently set metadata on the various related files).
+                // This version should take priority, so we remove it from nonForwardableMetadata if it's there to prevent the correct value from
+                // being overwritten.
+                nonForwardableMetadata?.Remove(ItemMetadataNames.winMDFileType);
+                if (reference.IsManagedWinMDFile)
+                {
+                    referenceItem.SetMetadata(ItemMetadataNames.winMDFileType, "Managed");
+                }
+                else
+                {
+                    referenceItem.SetMetadata(ItemMetadataNames.winMDFileType, "Native");
+                }
+
+                // This may have been set previously (before it was removed so we could more efficiently set metadata on the various related files).
+                // This version should take priority, so we remove it from nonForwardableMetadata if it's there to prevent the correct value from
+                // being overwritten.
+                nonForwardableMetadata?.Remove(ItemMetadataNames.winMDFile);
+                referenceItem.SetMetadata(ItemMetadataNames.winMDFile, "true");
+            }
+
+            // Set the FusionName late, so we don't copy it to the derived items, but it's still available on referenceItem.
+            referenceItem.SetMetadata(ItemMetadataNames.fusionName, fusionName);
+
+            // nonForwardableMetadata should be null here if relatedFileExtensions, satellites, serializationAssemblyFiles, and scatterFiles were all empty.
+            if (nonForwardableMetadata != null)
+            {
+                foreach (KeyValuePair<string, string> kvp in nonForwardableMetadata)
+                {
+                    referenceItem.SetMetadata(kvp.Key, kvp.Value);
+                }
+            }
+
             return referenceItem;
         }
 
@@ -2951,15 +3045,28 @@ IMAGE_FILE_MACHINE_IA64	0x200	Intel Itanium processor family
         /// <summary>
         /// Some metadata should not be forwarded between the parent and child items.
         /// </summary>
-        private static void RemoveNonForwardableMetadata(ITaskItem item)
+        /// <returns>The metadata that were removed.</returns>
+        private static Dictionary<string, string> RemoveNonForwardableMetadata(ITaskItem item)
         {
-            item.RemoveMetadata(ItemMetadataNames.winmdImplmentationFile);
-            item.RemoveMetadata(ItemMetadataNames.imageRuntime);
-            item.RemoveMetadata(ItemMetadataNames.winMDFile);
+            Dictionary<string, string> removedMetadata = new Dictionary<string, string>();
+            RemoveMetadatum(ItemMetadataNames.winmdImplmentationFile, item, removedMetadata);
+            RemoveMetadatum(ItemMetadataNames.imageRuntime, item, removedMetadata);
+            RemoveMetadatum(ItemMetadataNames.winMDFile, item, removedMetadata);
             if (!Traits.Instance.EscapeHatches.TargetPathForRelatedFiles)
             {
-                item.RemoveMetadata(ItemMetadataNames.targetPath);
+                RemoveMetadatum(ItemMetadataNames.targetPath, item, removedMetadata);
+            }
+            return removedMetadata;
+        }
+
+        private static void RemoveMetadatum(string key, ITaskItem item, Dictionary<string, string> removedMetadata)
+        {
+            string meta = item.GetMetadata(key);
+            if (!String.IsNullOrEmpty(meta))
+            {
+                removedMetadata.Add(key, meta);
             }
+            item.RemoveMetadata(key);
         }
 
         /// <summary>
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 90af55781f5..d03366aa29a 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -86,6 +86,7 @@ public ResolveAssemblyReference()
         private ITaskItem[] _scatterFiles = Array.Empty<TaskItem>();
         private ITaskItem[] _copyLocalFiles = Array.Empty<TaskItem>();
         private ITaskItem[] _suggestedRedirects = Array.Empty<TaskItem>();
+        private List<ITaskItem> _unresolvedConflicts = new List<ITaskItem>();
         private string[] _targetFrameworkSubsets = Array.Empty<string>();
         private string[] _fullTargetFrameworkSubsetNames = Array.Empty<string>();
         private string _targetedFrameworkMoniker = String.Empty;
@@ -214,6 +215,11 @@ public bool IgnoreTargetFrameworkAttributeVersionMismatch
         /// </remarks>
         public bool FindDependenciesOfExternallyResolvedReferences { get; set; }
 
+        /// <summary>
+        /// If true, outputs any unresolved assembly conflicts (MSB3277) in UnresolvedAssemblyConflicts.
+        /// </summary>
+        public bool OutputUnresolvedAssemblyConflicts { get; set; }
+
         /// <summary>
         /// List of target framework subset names which will be searched for in the target framework directories
         /// </summary>
@@ -915,6 +921,13 @@ public String DependsOnNETStandard
             private set;
         }
 
+        /// <summary>
+        /// If OutputUnresolvedAssemblyConflicts then a list of information about unresolved conflicts that normally would have
+        /// been outputted in MSB3277. Otherwise empty.
+        /// </summary>
+        [Output]
+        public ITaskItem[] UnresolvedAssemblyConflicts => _unresolvedConflicts.ToArray();
+
         #endregion
         #region Logging
 
@@ -990,16 +1003,30 @@ quiet at the engine level.
                             // Log the reference which lost the conflict and the dependencies and source items which caused it.
                             LogReferenceDependenciesAndSourceItemsToStringBuilder(fusionName, conflictCandidate, logDependencies.AppendLine());
 
+                            string output = StringBuilderCache.GetStringAndRelease(logConflict);
+                            string details = string.Empty;
                             if (logWarning)
                             {
                                 // This warning is logged regardless of AutoUnify since it means a conflict existed where the reference	
                                 // chosen was not the conflict victor in a version comparison. In other words, the victor was older.
-                                Log.LogWarningWithCodeFromResources("ResolveAssemblyReference.FoundConflicts", assemblyName.Name, StringBuilderCache.GetStringAndRelease(logConflict));
+                                Log.LogWarningWithCodeFromResources("ResolveAssemblyReference.FoundConflicts", assemblyName.Name, output);
                             }
                             else
                             {
-                                Log.LogMessage(ChooseReferenceLoggingImportance(conflictCandidate), StringBuilderCache.GetStringAndRelease(logConflict));
-                                Log.LogMessage(MessageImportance.Low, StringBuilderCache.GetStringAndRelease(logDependencies));
+                                details = StringBuilderCache.GetStringAndRelease(logDependencies);
+                                Log.LogMessage(ChooseReferenceLoggingImportance(conflictCandidate), output);
+                                Log.LogMessage(MessageImportance.Low, details);
+                            }
+
+                            if (OutputUnresolvedAssemblyConflicts)
+                            {
+                                _unresolvedConflicts.Add(new TaskItem(assemblyName.Name, new Dictionary<string, string>()
+                                {
+                                    { "logMessage", output },
+                                    { "logMessageDetails", details },
+                                    { "victorVersionNumber", victor.ReferenceVersion?.ToString() },
+                                    { "victimVersionNumber", conflictCandidate.ReferenceVersion?.ToString() }
+                                }));
                             }
                         }
                     }
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index 990ee217fee..7f62a79b57a 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -39,6 +39,15 @@ public class CodeTaskFactory : ITaskFactory
 
         static CodeTaskFactory()
         {
+            // Populate default-reference-assembly information
+            Assembly frameworkAssembly = Assembly.GetAssembly(typeof(ITask));
+            _msbuildFrameworkName = frameworkAssembly.FullName;
+            _msbuildFrameworkPath = frameworkAssembly.Location;
+
+            Assembly utilitiesAssembly = Assembly.GetAssembly(typeof(Task));
+            _msbuildUtilitiesName = utilitiesAssembly.FullName;
+            _msbuildUtilitiesPath = utilitiesAssembly.Location;
+
             // The handler is not detached because it only returns assemblies for custom references that cannot be found in the normal Load context
             AppDomain.CurrentDomain.AssemblyResolve += CurrentDomainOnAssemblyResolve;
         }
@@ -54,6 +63,11 @@ private static Assembly CurrentDomainOnAssemblyResolve(object sender, ResolveEve
             return assembly;
         }
 
+        private static readonly string _msbuildFrameworkName;
+        private static readonly string _msbuildFrameworkPath;
+        private static readonly string _msbuildUtilitiesName;
+        private static readonly string _msbuildUtilitiesPath;
+
         /// <summary>
         /// Default assemblies names to reference during inline code compilation - from the .NET Framework
         /// </summary>
@@ -70,11 +84,6 @@ private static Assembly CurrentDomainOnAssemblyResolve(object sender, ResolveEve
         /// </summary>
         private static readonly ConcurrentDictionary<FullTaskSpecification, Assembly> s_compiledTaskCache = new ConcurrentDictionary<FullTaskSpecification, Assembly>();
 
-        /// <summary>
-        /// The default assemblies to reference when compiling inline code.
-        /// </summary>
-        private static List<string> s_defaultReferencedAssemblies;
-
         /// <summary>
         /// Merged set of assembly reference paths (default + specified)
         /// </summary>
@@ -150,42 +159,6 @@ private static Assembly CurrentDomainOnAssemblyResolve(object sender, ResolveEve
         /// </summary>
         public Type TaskType { get; private set; }
 
-        /// <summary>
-        /// The assemblies that the codetaskfactory should reference by default.
-        /// </summary>
-        private static List<string> DefaultReferencedAssemblies
-        {
-            get
-            {
-                if (s_defaultReferencedAssemblies == null)
-                {
-                    s_defaultReferencedAssemblies = new List<string>();
-
-                    // Loading with the partial name is fine for framework assemblies -- we'll always get the correct one 
-                    // through the magic of unification
-                    foreach (string frameworkAssembly in s_defaultReferencedFrameworkAssemblyNames)
-                    {
-                        s_defaultReferencedAssemblies.Add(frameworkAssembly);
-                    }
-
-                    // We also want to add references to two MSBuild assemblies: Microsoft.Build.Framework.dll and 
-                    // Microsoft.Build.Utilities.Core.dll.  If we just let the CLR unify the simple name, it will 
-                    // pick the highest version on the machine, which means that in hosts with restrictive binding 
-                    // redirects, or no binding redirects, we'd end up creating an inline task that could not be 
-                    // run.  Instead, to make sure that we can actually use what we're building, just use the Framework
-                    // and Utilities currently loaded into this process -- Since we're in Microsoft.Build.Tasks.Core.dll
-                    // right now, by definition both of them are always already loaded. 
-                    string msbuildFrameworkPath = Assembly.GetAssembly(typeof(ITask)).Location;
-                    string msbuildUtilitiesPath = Assembly.GetAssembly(typeof(Task)).Location;
-
-                    s_defaultReferencedAssemblies.Add(msbuildFrameworkPath);
-                    s_defaultReferencedAssemblies.Add(msbuildUtilitiesPath);
-                }
-
-                return s_defaultReferencedAssemblies;
-            }
-        }
-
         /// <summary>
         /// Get the type information for all task parameters
         /// </summary>
@@ -467,7 +440,7 @@ private List<string> ExtractReferencedAssemblies()
                     return null;
                 }
 
-                references.Add(attribute.Value);
+                references.Add(FileUtilities.MaybeAdjustFilePath(attribute.Value));
             }
 
             return references;
@@ -638,67 +611,24 @@ private void AddReferenceAssemblyToReferenceList(List<string> referenceAssemblyL
                 {
                     try
                     {
-                        bool fileExists = FileSystems.Default.FileExists(referenceAssembly);
-                        if (!fileExists)
+                        if (!FileSystems.Default.FileExists(referenceAssembly))
                         {
                             if (!referenceAssembly.EndsWith(".dll", StringComparison.OrdinalIgnoreCase) || !referenceAssembly.EndsWith(".exe", StringComparison.OrdinalIgnoreCase))
                             {
-#pragma warning disable 618, 612
-                                // Unfortunately Assembly.Load is not an alternative to LoadWithPartialName, since
-                                // Assembly.Load requires the full assembly name to be passed to it.
-                                // Therefore we must ignore the deprecated warning.
-                                Assembly candidateAssembly = Assembly.LoadWithPartialName(referenceAssembly);
-                                if (candidateAssembly != null)
-                                {
-                                    candidateAssemblyLocation = candidateAssembly.Location;
-                                }
-                                else if (NativeMethodsShared.IsMono)
-                                {
-                                    string path = Path.Combine(
-                                        NativeMethodsShared.FrameworkCurrentPath,
-                                        "Facades",
-                                        Path.GetFileName(referenceAssembly));
-                                    if (!FileSystems.Default.FileExists(path))
-                                    {
-                                        var newPath = path + ".dll";
-                                        path = !FileSystems.Default.FileExists(newPath) ? path + ".exe" : newPath;
-                                    }
-                                    candidateAssembly = Assembly.UnsafeLoadFrom(path);
-                                    if (candidateAssembly != null)
-                                    {
-                                        candidateAssemblyLocation = candidateAssembly.Location;
-                                    }
-                                }
-#pragma warning restore 618, 612
+                                candidateAssemblyLocation = GetPathFromPartialAssemblyName(referenceAssembly);
                             }
                         }
                         else
                         {
-                            try
+                            if (!TryCacheAssemblyIdentityFromPath(referenceAssembly, out candidateAssemblyLocation))
                             {
-                                Assembly candidateAssembly = Assembly.UnsafeLoadFrom(referenceAssembly);
-                                if (candidateAssembly != null)
-                                {
-                                    candidateAssemblyLocation = candidateAssembly.Location;
-                                    s_knownReferenceAssemblies[candidateAssembly.FullName] = candidateAssembly;
-                                }
-                            }
-                            catch (BadImageFormatException e)
-                            {
-                                Debug.Assert(e.Message.Contains("0x80131058"), "Expected Message to contain 0x80131058");
-                                AssemblyName.GetAssemblyName(referenceAssembly);
-                                candidateAssemblyLocation = referenceAssembly;
-                                _log.LogMessageFromResources(MessageImportance.Low, "CodeTaskFactory.HaveReflectionOnlyAssembly", referenceAssembly);
+                                // Assembly should be skipped; return
+                                return;
                             }
                         }
                     }
-                    catch (Exception e)
+                    catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
                     {
-                        if (ExceptionHandling.IsCriticalException(e))
-                        {
-                            throw;
-                        }
-
                         _log.LogErrorWithCodeFromResources("CodeTaskFactory.ReferenceAssemblyIsInvalid", referenceAssembly, e.Message);
                     }
                 }
@@ -712,6 +642,73 @@ private void AddReferenceAssemblyToReferenceList(List<string> referenceAssemblyL
                     _log.LogErrorWithCodeFromResources("CodeTaskFactory.CouldNotFindReferenceAssembly", referenceAssembly);
                 }
             }
+
+            static string GetPathFromPartialAssemblyName(string partialName)
+            {
+                string candidateAssemblyLocation = null;
+
+#pragma warning disable 618, 612
+                // Unfortunately Assembly.Load is not an alternative to LoadWithPartialName, since
+                // Assembly.Load requires the full assembly name to be passed to it.
+                // Therefore we must ignore the deprecated warning.
+                Assembly candidateAssembly = Assembly.LoadWithPartialName(partialName);
+                if (candidateAssembly != null)
+                {
+                    candidateAssemblyLocation = candidateAssembly.Location;
+                }
+                else if (NativeMethodsShared.IsMono)
+                {
+                    string path = Path.Combine(
+                        NativeMethodsShared.FrameworkCurrentPath,
+                        "Facades",
+                        Path.GetFileName(partialName));
+                    if (!FileSystems.Default.FileExists(path))
+                    {
+                        var newPath = path + ".dll";
+                        path = !FileSystems.Default.FileExists(newPath) ? path + ".exe" : newPath;
+                    }
+                    candidateAssembly = Assembly.UnsafeLoadFrom(path);
+                    if (candidateAssembly != null)
+                    {
+                        candidateAssemblyLocation = candidateAssembly.Location;
+                    }
+                }
+#pragma warning restore 618, 612
+                return candidateAssemblyLocation;
+            }
+
+            bool TryCacheAssemblyIdentityFromPath(string assemblyFile, out string candidateAssemblyLocation)
+            {
+                candidateAssemblyLocation = null;
+
+                try
+                {
+                    Assembly candidateAssembly = Assembly.UnsafeLoadFrom(assemblyFile);
+                    if (candidateAssembly != null)
+                    {
+                        string name = candidateAssembly.FullName;
+                        if (name == _msbuildFrameworkName ||
+                            name == _msbuildUtilitiesName)
+                        {
+                            // Framework and Utilities are default references but are often
+                            // specified in the UsingTask anyway; if so just ignore them.
+                            return false;
+                        }
+
+                        candidateAssemblyLocation = candidateAssembly.Location;
+                        s_knownReferenceAssemblies[candidateAssembly.FullName] = candidateAssembly;
+                    }
+                }
+                catch (BadImageFormatException e)
+                {
+                    Debug.Assert(e.Message.Contains("0x80131058"), "Expected Message to contain 0x80131058");
+                    AssemblyName.GetAssemblyName(assemblyFile);
+                    candidateAssemblyLocation = assemblyFile;
+                    _log.LogMessageFromResources(MessageImportance.Low, "CodeTaskFactory.HaveReflectionOnlyAssembly", assemblyFile);
+                }
+
+                return true;
+            }
         }
 
         /// <summary>
@@ -721,8 +718,7 @@ private void AddReferenceAssemblyToReferenceList(List<string> referenceAssemblyL
         private Assembly CompileInMemoryAssembly()
         {
             // Combine our default assembly references with those specified
-            var finalReferencedAssemblies = new List<string>();
-            CombineReferencedAssemblies(finalReferencedAssemblies);
+            var finalReferencedAssemblies = CombineReferencedAssemblies();
 
             // Combine our default using's with those specified
             string[] finalUsingNamespaces = CombineUsingNamespaces();
@@ -851,13 +847,35 @@ private Assembly CompileInMemoryAssembly()
         /// <summary>
         /// Combine our default referenced assemblies with those explicitly specified
         /// </summary>
-        private void CombineReferencedAssemblies(List<string> finalReferenceList)
+        private List<string> CombineReferencedAssemblies()
         {
-            foreach (string defaultReference in DefaultReferencedAssemblies)
+            List<string> finalReferenceList = new List<string>(s_defaultReferencedFrameworkAssemblyNames.Length + 2 + _referencedAssemblies.Count);
+
+            // Set some default references:
+
+            // Loading with the partial name is fine for framework assemblies -- we'll always get the correct one 
+            // through the magic of unification
+            foreach (string defaultReference in s_defaultReferencedFrameworkAssemblyNames)
             {
                 AddReferenceAssemblyToReferenceList(finalReferenceList, defaultReference);
             }
 
+            // We also want to add references to two MSBuild assemblies: Microsoft.Build.Framework.dll and 
+            // Microsoft.Build.Utilities.Core.dll.  If we just let the CLR unify the simple name, it will 
+            // pick the highest version on the machine, which means that in hosts with restrictive binding 
+            // redirects, or no binding redirects, we'd end up creating an inline task that could not be 
+            // run.  Instead, to make sure that we can actually use what we're building, just use the Framework
+            // and Utilities currently loaded into this process -- Since we're in Microsoft.Build.Tasks.Core.dll
+            // right now, by definition both of them are always already loaded.
+            //
+            // NOTE Dec 2020: I don't think the above really applies given the eternally-15.1.0.0 version policy
+            // we are currently using. But loading these from an explicit path seems fine so I'm not changing
+            // that.
+
+            finalReferenceList.Add(_msbuildFrameworkPath);
+            finalReferenceList.Add(_msbuildUtilitiesPath);
+
+            // Now for the explicitly-specified references:
             if (_referencedAssemblies != null)
             {
                 foreach (string referenceAssembly in _referencedAssemblies)
@@ -865,6 +883,8 @@ private void CombineReferencedAssemblies(List<string> finalReferenceList)
                     AddReferenceAssemblyToReferenceList(finalReferenceList, referenceAssembly);
                 }
             }
+
+            return finalReferenceList;
         }
 
         /// <summary>
diff --git a/src/Tasks/ComReferenceResolutionException.cs b/src/Tasks/ComReferenceResolutionException.cs
index cbfe1b1efca..48f2f0f0231 100644
--- a/src/Tasks/ComReferenceResolutionException.cs
+++ b/src/Tasks/ComReferenceResolutionException.cs
@@ -10,11 +10,9 @@ namespace Microsoft.Build.Tasks
     /// Internal exception thrown when there's an unrecoverable failure resolving a COM reference and we should 
     /// move on to the next one, if it makes sense.
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
     internal class ComReferenceResolutionException : Exception
     {
diff --git a/src/Tasks/CombineTargetFrameworkInfoProperties.cs b/src/Tasks/CombineTargetFrameworkInfoProperties.cs
new file mode 100644
index 00000000000..612f27d3b88
--- /dev/null
+++ b/src/Tasks/CombineTargetFrameworkInfoProperties.cs
@@ -0,0 +1,51 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Framework;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Xml.Linq;
+
+namespace Microsoft.Build.Tasks
+{
+    /// <summary>
+    /// Combines items that represent properties and values into an XML representation.
+    /// </summary>
+    public class CombineTargetFrameworkInfoProperties : TaskExtension
+    {
+        /// <summary>
+        /// The root element name to use for the generated XML string
+        /// </summary>
+        public string RootElementName { get; set; }
+
+        /// <summary>
+        /// Items to include in the XML.  The ItemSpec should be the property name, and it should have Value metadata for its value.
+        /// </summary>
+        public ITaskItem[] PropertiesAndValues { get; set; }
+
+        /// <summary>
+        /// The generated XML representation of the properties and values.
+        /// </summary>
+        [Output]
+        public string Result { get; set; }
+
+        public override bool Execute()
+        {
+            if (PropertiesAndValues != null)
+            {
+                XElement root = new XElement(RootElementName);
+
+                foreach (var item in PropertiesAndValues)
+                {
+                    root.Add(new XElement(item.ItemSpec, item.GetMetadata("Value")));
+                }
+
+                Result = root.ToString();
+            }
+            return !Log.HasLoggedErrors;
+        }
+    }
+}
diff --git a/src/Tasks/CombineXmlElements.cs b/src/Tasks/CombineXmlElements.cs
new file mode 100644
index 00000000000..c42aed7f1bd
--- /dev/null
+++ b/src/Tasks/CombineXmlElements.cs
@@ -0,0 +1,52 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Framework;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Xml.Linq;
+
+namespace Microsoft.Build.Tasks
+{
+    /// <summary>
+    /// Combines multiple XML elements
+    /// </summary>
+    public class CombineXmlElements : TaskExtension
+    {
+        /// <summary>
+        /// The root element name to use for the generated XML string
+        /// </summary>
+        public string RootElementName { get; set; }
+
+        /// <summary>
+        /// The XML elements to include as children of the root element
+        /// </summary>
+        public ITaskItem [] XmlElements { get; set; }
+
+        /// <summary>
+        /// The generated XML
+        /// </summary>
+        [Output]
+        public string Result { get; set; }
+
+        public override bool Execute()
+        {
+            if (XmlElements != null)
+            {
+                XElement root = new XElement(RootElementName);
+
+                foreach (var item in XmlElements)
+                {
+                    root.Add(XElement.Parse(item.ItemSpec));
+                }
+
+                Result = root.ToString();
+            }
+
+            return !Log.HasLoggedErrors;
+        }
+    }
+}
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index 013176c94be..67d779798e7 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -39,7 +39,7 @@ public class Copy : TaskExtension, ICancelableTask
         // threads at the advantage of performing file copies more quickly in the kernel - we must avoid
         // taking up the whole threadpool esp. when hosted in Visual Studio. IOW we use a specific number
         // instead of int.MaxValue.
-        private static readonly int DefaultCopyParallelism = Environment.ProcessorCount > 4 ? 6 : 4;
+        private static readonly int DefaultCopyParallelism = NativeMethodsShared.GetLogicalCoreCount() > 4 ? 6 : 4;
 
         /// <summary>
         /// Constructor.
diff --git a/src/Tasks/Exec.cs b/src/Tasks/Exec.cs
index df817422bfd..0cf22b566c5 100644
--- a/src/Tasks/Exec.cs
+++ b/src/Tasks/Exec.cs
@@ -17,9 +17,7 @@ namespace Microsoft.Build.Tasks
     /// This class defines an "Exec" MSBuild task, which simply invokes the specified process with the specified arguments, waits
     /// for it to complete, and then returns True if the process completed successfully, and False if an error occurred.
     /// </summary>
-    /// <comments>
-    /// UNDONE: ToolTask has a "UseCommandProcessor" flag that duplicates much of the code in this class. Remove the duplication.
-    /// </comments>
+    // UNDONE: ToolTask has a "UseCommandProcessor" flag that duplicates much of the code in this class. Remove the duplication.
     public class Exec : ToolTaskExtension
     {
         #region Constructors
@@ -336,17 +334,23 @@ protected override bool HandleTaskExecutionErrors()
         {
             if (IgnoreExitCode)
             {
-                Log.LogMessageFromResources(MessageImportance.Normal, "Exec.CommandFailedNoErrorCode", Command, ExitCode);
+                // Don't log when EchoOff and IgnoreExitCode.
+                if (!EchoOff)
+                {
+                    Log.LogMessageFromResources(MessageImportance.Normal, "Exec.CommandFailedNoErrorCode", Command, ExitCode);
+                }
                 return true;
             }
 
+            // Don't emit expanded form of Command when EchoOff is set.
+            string commandForLog = EchoOff ? "..." : Command;
             if (ExitCode == NativeMethods.SE_ERR_ACCESSDENIED)
             {
-                Log.LogErrorWithCodeFromResources("Exec.CommandFailedAccessDenied", Command, ExitCode);
+                Log.LogErrorWithCodeFromResources("Exec.CommandFailedAccessDenied", commandForLog, ExitCode);
             }
             else
             {
-                Log.LogErrorWithCodeFromResources("Exec.CommandFailed", Command, ExitCode);
+                Log.LogErrorWithCodeFromResources("Exec.CommandFailed", commandForLog, ExitCode);
             }
             return false;
         }
diff --git a/src/Tasks/ListOperators/FindUnderPath.cs b/src/Tasks/ListOperators/FindUnderPath.cs
index 876f06a6c9a..46acb04aad8 100644
--- a/src/Tasks/ListOperators/FindUnderPath.cs
+++ b/src/Tasks/ListOperators/FindUnderPath.cs
@@ -6,6 +6,8 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
+using Microsoft.NET.StringTools;
+
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
@@ -54,7 +56,7 @@ public override bool Execute()
             try
             {
                 conePath =
-                    OpportunisticIntern.InternStringIfPossible(
+                    Strings.WeakIntern(
                         System.IO.Path.GetFullPath(FileUtilities.FixFilePath(Path.ItemSpec)));
                 conePath = FileUtilities.EnsureTrailingSlash(conePath);
             }
@@ -75,7 +77,7 @@ public override bool Execute()
                 try
                 {
                     fullPath =
-                        OpportunisticIntern.InternStringIfPossible(
+                        Strings.WeakIntern(
                             System.IO.Path.GetFullPath(FileUtilities.FixFilePath(item.ItemSpec)));
                 }
                 catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index f34423f982a..988843a2973 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -61,6 +61,8 @@
       <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="AssemblyDependency\AssemblyMetadata.cs" />
+    <Compile Include="CombineTargetFrameworkInfoProperties.cs" />
+    <Compile Include="CombineXmlElements.cs" />
     <Compile Include="ConvertToAbsolutePath.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -81,19 +83,7 @@
     <Compile Include="..\Shared\NGen.cs">
       <Link>NGen.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\IConstrainedEqualityComparer.cs" />
-    <Compile Include="..\Shared\IInternable.cs">
-      <Link>IInternable.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\WeakStringCache.cs">
-      <Link>WeakStringCache.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs">
-      <Link>WeakStringCache.Concurrent.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\OpportunisticIntern.cs">
-      <Link>OpportunisticIntern.cs</Link>
-    </Compile>
+    <Compile Include="..\Shared\IConstrainedEqualityComparer.cs"/>
     <Compile Include="..\Shared\PropertyParser.cs">
       <Link>PropertyParser.cs</Link>
       <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
@@ -983,6 +973,7 @@
   <ItemGroup>
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
+    <ProjectReference Include="..\StringTools\StringTools.csproj" />
   </ItemGroup>
   <ItemGroup>
     <PackageReference Include="System.Collections.Immutable" />
@@ -1005,8 +996,6 @@
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
     <PackageReference Include="System.CodeDom" />
     <PackageReference Include="System.Reflection.Metadata" />
-    <PackageReference Include="System.Reflection.TypeExtensions" />
-    <PackageReference Include="System.Runtime.InteropServices" />
     <PackageReference Include="System.Security.Cryptography.Pkcs" />
     <PackageReference Include="System.Security.Cryptography.Xml" />
     <PackageReference Include="System.Security.Permissions" />
@@ -1015,7 +1004,7 @@
     <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
     <PackageReference Include="Microsoft.Win32.Registry" />
 
-    <Content Include="$(NuGetPackageRoot)microsoft.net.compilers.toolset\$(MicrosoftNetCompilersToolsetVersion)\tasks\netcoreapp2.1\**\*" CopyToOutputDirectory="PreserveNewest" LinkBase="Roslyn" />
+    <Content Include="$(NuGetPackageRoot)microsoft.net.compilers.toolset\$(MicrosoftNetCompilersToolsetVersion)\tasks\netcoreapp3.1\**\*" CopyToOutputDirectory="PreserveNewest" LinkBase="Roslyn" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(MonoBuild)' == 'true'">
diff --git a/src/Tasks/Microsoft.CSharp.CurrentVersion.targets b/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
index f48855ce32f..a14d5b42df4 100644
--- a/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
@@ -237,9 +237,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
           <AdditionalFiles Include="@(%(AdditionalFileItems.Identity))" />
         </ItemGroup>
         
-       <!-- Don't run analyzers for Csc task on XamlPrecompile pass, we only want to run them on core compile. -->
-       <!-- Analyzers="@(Analyzer)" -->
-
        <PropertyGroup Condition="'$(UseSharedCompilation)' == ''">
          <UseSharedCompilation>true</UseSharedCompilation>
        </PropertyGroup>
@@ -250,6 +247,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
               AddModules="@(AddModules)"
               AdditionalFiles="@(AdditionalFiles)"
               AllowUnsafeBlocks="$(AllowUnsafeBlocks)"
+              Analyzers="@(Analyzer)"
               ApplicationConfiguration="$(AppConfigForCompiler)"
               BaseAddress="$(BaseAddress)"
               CheckForOverflowUnderflow="$(CheckForOverflowUnderflow)"
@@ -278,6 +276,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
               NoLogo="$(NoLogo)"
               NoStandardLib="$(NoCompilerStandardLib)"
               NoWin32Manifest="$(NoWin32Manifest)"
+              Nullable="$(Nullable)"
               Optimize="$(Optimize)"
               OutputAssembly="@(XamlIntermediateAssembly)"
               PdbFile="$(PdbFile)" 
@@ -288,6 +287,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
               ReportAnalyzer="$(ReportAnalyzer)"
               Resources="@(_CoreCompileResourceInputs);@(CompiledLicenseFile)"
               ResponseFiles="$(CompilerResponseFile)"
+              SkipAnalyzers="$(_SkipAnalyzers)"
               Sources="@(Compile)"
               SubsystemVersion="$(SubsystemVersion)"
               TargetType="$(OutputType)"
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index c7023d3cca6..c5ce7a2d79e 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -26,12 +26,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <Error Condition="'$(IsCrossTargetingBuild)' != 'true'"
            Text="Internal MSBuild error: CrossTargeting GetTargetFrameworks target should only be used in cross targeting (outer) build" />
+
+    <CombineXmlElements
+      RootElementName="AdditionalProjectProperties"
+      XmlElements="@(_TargetFrameworkInfo->'%(AdditionalPropertiesFromProject)')">
+      <Output TaskParameter="Result"
+        PropertyName="_AdditionalPropertiesFromProject"/>
+    </CombineXmlElements>
     
     <ItemGroup>
       <_ThisProjectBuildMetadata Include="$(MSBuildProjectFullPath)">
         <TargetFrameworks>@(_TargetFrameworkInfo)</TargetFrameworks>
         <TargetFrameworkMonikers>@(_TargetFrameworkInfo->'%(TargetFrameworkMonikers)')</TargetFrameworkMonikers>
         <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>
+        <AdditionalPropertiesFromProject>$(_AdditionalPropertiesFromProject)</AdditionalPropertiesFromProject>
 
         <HasSingleTargetFramework>false</HasSingleTargetFramework>
 
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index cacc0e712a8..18d7712ad5c 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1778,11 +1778,19 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <Error Condition="'$(IsCrossTargetingBuild)' == 'true'"
            Text="Internal MSBuild error: Non-CrossTargeting GetTargetFrameworks target should not be used in cross targeting (outer) build" />
 
+    <CombineXmlElements
+      RootElementName="AdditionalProjectProperties"
+      XmlElements="@(_TargetFrameworkInfo->'%(AdditionalPropertiesFromProject)')">
+      <Output TaskParameter="Result"
+        PropertyName="_AdditionalPropertiesFromProject"/>
+    </CombineXmlElements>
+    
     <ItemGroup>
       <_ThisProjectBuildMetadata Include="$(MSBuildProjectFullPath)">
         <TargetFrameworks>@(_TargetFrameworkInfo)</TargetFrameworks>
         <TargetFrameworkMonikers>@(_TargetFrameworkInfo->'%(TargetFrameworkMonikers)')</TargetFrameworkMonikers>
         <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>
+        <AdditionalPropertiesFromProject>$(_AdditionalPropertiesFromProject)</AdditionalPropertiesFromProject>
 
         <HasSingleTargetFramework>true</HasSingleTargetFramework>
 
@@ -1796,12 +1804,26 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <Target Name="GetTargetFrameworksWithPlatformForSingleTargetFramework"
         Returns="@(_TargetFrameworkInfo)">
 
+    <ItemGroup>
+      <_AdditionalTargetFrameworkInfoPropertyWithValue Include="@(AdditionalTargetFrameworkInfoProperty)">
+        <Value>$(%(AdditionalTargetFrameworkInfoProperty.Identity))</Value>
+      </_AdditionalTargetFrameworkInfoPropertyWithValue>
+    </ItemGroup>
+
+    <CombineTargetFrameworkInfoProperties
+        RootElementName="$(TargetFramework)"
+        PropertiesAndValues="@(_AdditionalTargetFrameworkInfoPropertyWithValue)">
+      <Output TaskParameter="Result"
+              PropertyName="_AdditionalTargetFrameworkInfoProperties"/>
+    </CombineTargetFrameworkInfoProperties>
+
     <ItemGroup>
       <_TargetFrameworkInfo Include="$(TargetFramework)">
         <TargetFrameworks>$(TargetFramework)</TargetFrameworks>
         <TargetFrameworkMonikers>$(TargetFrameworkMoniker)</TargetFrameworkMonikers>
         <TargetPlatformMonikers>$(TargetPlatformMoniker)</TargetPlatformMonikers>
         <TargetPlatformMonikers Condition="'$(TargetPlatformMoniker)' == ''">None</TargetPlatformMonikers>
+        <AdditionalPropertiesFromProject>$(_AdditionalTargetFrameworkInfoProperties)</AdditionalPropertiesFromProject>
       </_TargetFrameworkInfo>
     </ItemGroup>
 
@@ -2156,6 +2178,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <ResolveAssemblyReferencesFindRelatedSatellites Condition="'$(ResolveAssemblyReferencesFindRelatedSatellites)' == ''">$(BuildingProject)</ResolveAssemblyReferencesFindRelatedSatellites>
       <ResolveAssemblyReferencesFindSerializationAssemblies Condition="'$(ResolveAssemblyReferencesFindSerializationAssemblies)' == ''">$(BuildingProject)</ResolveAssemblyReferencesFindSerializationAssemblies>
       <ResolveAssemblyReferencesFindRelatedFiles Condition="'$(ResolveAssemblyReferencesFindRelatedFiles)' == ''">$(BuildingProject)</ResolveAssemblyReferencesFindRelatedFiles>
+      <ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts Condition="'$(ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts)' == ''">false</ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts>
     </PropertyGroup>
 
     <ItemGroup>
@@ -2218,6 +2241,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         IgnoreTargetFrameworkAttributeVersionMismatch ="$(ResolveAssemblyReferenceIgnoreTargetFrameworkAttributeVersionMismatch)"
         FindDependenciesOfExternallyResolvedReferences="$(FindDependenciesOfExternallyResolvedReferences)"
         ContinueOnError="$(ContinueOnError)"
+        OutputUnresolvedAssemblyConflicts="$(ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts)"
         Condition="'@(Reference)'!='' or '@(_ResolvedProjectReferencePaths)'!='' or '@(_ExplicitReference)' != ''"
         >
 
@@ -2233,6 +2257,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <Output TaskParameter="FilesWritten" ItemName="FileWrites"/>
       <Output TaskParameter="DependsOnSystemRuntime" PropertyName="DependsOnSystemRuntime"/>
       <Output TaskParameter="DependsOnNETStandard" PropertyName="_DependsOnNETStandard"/>
+      <Output TaskParameter="UnresolvedAssemblyConflicts" ItemName="ResolveAssemblyReferenceUnresolvedAssemblyConflicts"/>
     </ResolveAssemblyReference>
   </Target>
 
@@ -4169,10 +4194,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ItemGroup>
       <_SatelliteAssemblies Include="@(IntermediateSatelliteAssembliesWithTargetPath);@(ReferenceSatellitePaths)" />
       <_DeploymentReferencePaths Include="@(ReferenceCopyLocalPaths)"
-                                 Condition="'%(Extension)' == '.dll' Or '%(Extension)' == '.exe' Or '%(Extension)' == '.md'">
+                                 Condition="('%(Extension)' == '.dll' Or '%(Extension)' == '.exe' Or '%(Extension)' == '.md') and ('%(ReferenceCopyLocalPaths.CopyToPublishDirectory)' != 'false')">
         <IsPrimary>true</IsPrimary>
       </_DeploymentReferencePaths>
-      <_DeploymentReferencePaths Include="@(_DeploymentReferencePaths);@(_CopyLocalFalseRefPathsWithExclusion)" />
+      <_DeploymentReferencePaths Include="@(_CopyLocalFalseRefPathsWithExclusion)" />
     </ItemGroup>
 
     <!-- Include managed references in clickonce manifest only if single file publish is false -->
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index 9f7f4620cd2..a1eb793d5ee 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -95,6 +95,8 @@
     <UsingTask TaskName="Microsoft.Build.Tasks.CallTarget"                            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.CombinePath"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.ConvertToAbsolutePath"                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties"  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.CombineXmlElements"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.Copy"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.CreateCSharpManifestResourceName"      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.CreateItem"                            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index a4e4fd164a2..174dfe25f83 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -1052,200 +1052,6 @@ internal static extern int CreateAssemblyNameObject(
         internal static extern int GetCachePath(AssemblyCacheFlags cacheFlags, StringBuilder cachePath, ref int pcchPath);
 #endif
 
-        /*------------------------------------------------------------------------------
-        CompareAssemblyIdentity
-        The Fusion API to compare two assembly identities to determine whether or not they are equivalent is now available. This new API is exported from mscorwks.dll, which you can access via mscoree's GetRealProcAddress. The function prototype is defined in fusion.h as follows:
-
-        STDAPI CompareAssemblyIdentity(LPCWSTR pwzAssemblyIdentity1,
-                                    BOOL fUnified1,
-                                    LPCWSTR pwzAssemblyIdentity2,
-                                    BOOL fUnified2,
-                                    BOOL *pfEquivalent,
-                                    AssemblyComparisonResult *pResult);
-
-typedef enum _tagAssemblyComparisonResult 
-{
-    ACR_Unknown,                    // Unknown 
-    ACR_EquivalentFullMatch,        // all fields match
-    ACR_EquivalentWeakNamed,        // match based on weak-name, version numbers ignored
-    ACR_EquivalentFXUnified,        // match based on FX-unification of version numbers
-    ACR_EquivalentUnified,          // match based on legacy-unification of version numbers
-    ACR_NonEquivalentVersion,       // all fields match except version field
-    ACR_NonEquivalent,              // no match
-
-    ACR_EquivalentPartialMatch,
-    ACR_EquivalentPartialWeakNamed,  
-    ACR_EquivalentPartialUnified,
-    ACR_EquivalentPartialFXUnified,
-    ACR_NonEquivalentPartialVersion     
-} AssemblyComparisonResult;
-
-        Parameters:
-            [in] LPCWSTR pwzAssemblyIdentity1 : Textual identity of the first assembly to be compared
-            [in] BOOL fUnified1               : Flag to indicate user-specified unification for pwzAssemblyIdentity1 (see below)
-            [in] LPCWSTR pwzAssemblyIdentity2 : Textual identity of the second assembly to be compared
-            [in] BOOL fUnified2               : Flag to inidcate user-specified unification for pwzAssemblyIdentity2 (see below)
-            [out] BOOL *pfEquivalent          : Boolean indicating whether the identities are equivalent
-            [out] AssemblyComparisonResult *pResult : Contains detailed information about the comparison result
-
-        This API will check whether or not pwzAssemblyIdentity1 and pwzAssemblyIdentity2 are equivalent. Both of these identities must be full-specified (name, version, pkt, culture). The pfEquivalent parameter will be set to TRUE if one (or more) of the following conditions is true:
-
-        a) The assembly identities are equivalent. For strongly-named assemblies this means full match on (name, version, pkt, culture); for simply-named assemblies this means a match on (name, culture)
-
-        b) The assemblies being compared are FX assemblies (even if the version numbers are not the same, these will compare as equivalent by way of unification)
-
-        c) The assemblies are not FX assemblies but are equivalent because fUnified1 and/or fUnified2 were set.
-
-        The fUnified flag is used to indicate that all versions up to the version number of the strongly-named assembly are considered equivalent to itself. For example, if pwzAssemblyIdentity1 is "foo, version=5.0.0.0, culture=neutral, publicKeyToken=...." and fUnified1==TRUE, then this means to treat all versions of the assembly in the range 0.0.0.0-5.0.0.0 to be equivalent to "foo, version=5.0.0.0, culture=neutral, publicKeyToken=...". If pwzAssemblyIdentity2 is the same as pwzAssemblyIdentity1, except has a lower version number (e.g. version range 0.0.0.0-5.0.0.0), then the API will return that the identities are equivalent. If pwzAssemblyIdentity2 is the same as pwzAssemblyIdentity1, but has a greater version number than 5.0.0.0 then the two identities will only be equivalent if fUnified2 is set.
-
-        The AssemblyComparisonResult gives you information about why the identities compared as equal or not equal. The description of the meaning of each ACR_* return value is described in the declaration above.
-        ------------------------------------------------------------------------------*/
-        [DllImport("fusion.dll", CharSet = CharSet.Unicode, EntryPoint = "CompareAssemblyIdentity")]
-        internal static extern int CompareAssemblyIdentityWindows
-            (
-                string pwzAssemblyIdentity1,
-                [MarshalAs(UnmanagedType.Bool)] bool fUnified1,
-                string pwzAssemblyIdentity2,
-                [MarshalAs(UnmanagedType.Bool)] bool fUnified2,
-                [MarshalAs(UnmanagedType.Bool)] out bool pfEquivalent,
-                out AssemblyComparisonResult pResult
-            );
-
-        // TODO: Verify correctness of this implementation and
-        // extend to more cases.
-        internal static void CompareAssemblyIdentity(
-            string assemblyIdentity1,
-            bool fUnified1,
-            string assemblyIdentity2,
-            bool fUnified2,
-            out bool pfEquivalent,
-            out AssemblyComparisonResult pResult)
-        {
-#if FEATURE_FUSION_COMPAREASSEMBLYIDENTITY
-            if (NativeMethodsShared.IsWindows)
-            {
-                CompareAssemblyIdentityWindows(
-                    assemblyIdentity1,
-                    fUnified1,
-                    assemblyIdentity2,
-                    fUnified2,
-                    out pfEquivalent,
-                    out pResult);
-            }
-#endif
-
-            AssemblyName an1 = new AssemblyName(assemblyIdentity1);
-            AssemblyName an2 = new AssemblyName(assemblyIdentity2);
-
-            //pfEquivalent = AssemblyName.ReferenceMatchesDefinition(an1, an2);
-            pfEquivalent = RefMatchesDef(an1, an2);
-            if (pfEquivalent)
-            {
-                pResult = AssemblyComparisonResult.ACR_EquivalentFullMatch;
-                return;
-            }
-
-            if (!an1.Name.Equals(an2.Name, StringComparison.OrdinalIgnoreCase))
-            {
-                pResult = AssemblyComparisonResult.ACR_NonEquivalent;
-                pfEquivalent = false;
-                return;
-            }
-
-            var versionCompare = an1.Version.CompareTo(an2.Version);
-
-            if ((versionCompare < 0 && fUnified2) || (versionCompare > 0 && fUnified1))
-            {
-                pResult = AssemblyComparisonResult.ACR_NonEquivalentVersion;
-                pfEquivalent = true;
-                return;
-            }
-
-            if (versionCompare == 0)
-            {
-                pResult = AssemblyComparisonResult.ACR_EquivalentFullMatch;
-                pfEquivalent = true;
-                return;
-            }
-
-            pResult = pfEquivalent ? AssemblyComparisonResult.ACR_EquivalentFullMatch : AssemblyComparisonResult.ACR_NonEquivalent;
-        }
-
-        //  Based on coreclr baseassemblyspec.cpp (https://github.com/dotnet/coreclr/blob/4cf8a6b082d9bb1789facd996d8265d3908757b2/src/vm/baseassemblyspec.cpp#L330)
-        private static bool RefMatchesDef(AssemblyName @ref, AssemblyName def)
-        {
-            if (IsStrongNamed(@ref))
-            {
-                return IsStrongNamed(def) && CompareRefToDef(@ref, def);
-            }
-            else
-            {
-                return @ref.Name.Equals(def.Name, StringComparison.OrdinalIgnoreCase);
-            }
-        }
-
-        // Based on coreclr baseassemblyspec.inl (https://github.com/dotnet/coreclr/blob/32f0f9721afb584b4a14d69135bea7ddc129f755/src/vm/baseassemblyspec.inl#L679-L683)
-        private static bool IsStrongNamed(AssemblyName assembly)
-        {
-            var refPkt = assembly.GetPublicKeyToken();
-            return refPkt != null && refPkt.Length != 0;
-        }
-
-        //  Based on https://github.com/dotnet/coreclr/blob/4cf8a6b082d9bb1789facd996d8265d3908757b2/src/vm/baseassemblyspec.cpp#L241
-        private static bool CompareRefToDef(AssemblyName @ref, AssemblyName def)
-        {
-            if (!@ref.Name.Equals(def.Name, StringComparison.OrdinalIgnoreCase))
-            {
-                return false;
-            }
-
-            byte[] rpkt = @ref.GetPublicKeyToken();
-            byte[] dpkt = def.GetPublicKeyToken();
-
-            if (rpkt.Length != dpkt.Length)
-            {
-                return false;
-            }
-
-            for (int i = 0; i < rpkt.Length; i++)
-            {
-                if (rpkt[i] != dpkt[i])
-                {
-                    return false;
-                }
-            }
-
-            if (@ref.Version != def.Version)
-            {
-                return false;
-            }
-
-            if (@ref.CultureName != null &&
-                @ref.CultureName != def.CultureName)
-            {
-                return false;
-            }
-
-            return true;
-        }
-
-        internal enum AssemblyComparisonResult
-        {
-            ACR_Unknown,                    // Unknown 
-            ACR_EquivalentFullMatch,        // all fields match
-            ACR_EquivalentWeakNamed,        // match based on weak-name, version numbers ignored
-            ACR_EquivalentFXUnified,        // match based on FX-unification of version numbers
-            ACR_EquivalentUnified,          // match based on legacy-unification of version numbers
-            ACR_NonEquivalentVersion,       // all fields match except version field
-            ACR_NonEquivalent,              // no match
-
-            ACR_EquivalentPartialMatch,
-            ACR_EquivalentPartialWeakNamed,
-            ACR_EquivalentPartialUnified,
-            ACR_EquivalentPartialFXUnified,
-            ACR_NonEquivalentPartialVersion
-        }
-
         //------------------------------------------------------------------------------
         // PFXImportCertStore
         //------------------------------------------------------------------------------
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index fcf321c1beb..ee59ffb9b5e 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -732,7 +732,7 @@ private bool IsFiltered(ITaskItem item)
             {
                 if (identity?.IsInFramework(Constants.DotNetCoreIdentifier, null) == true)
                 {
-                    return true;
+                    return !GetItemCopyLocal(item);
                 }
             }
             else if (identity?.IsInFramework(Constants.DotNetFrameworkIdentifier, TargetFrameworkVersion) == true)
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index b465dd10789..a054ea6c65a 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -2789,9 +2789,20 @@
     <value>MSB3936: Failed to open unzip file "{0}" to "{1}".  {2}</value>
     <comment>{StrBegin="MSB3936: "}</comment>
   </data>
+  <data name="Unzip.ErrorParsingPatternInvalidPath">
+    <value>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</value>
+    <comment>{StrBegin="MSB3937: "}</comment>
+  </data>
+  <data name="Unzip.ErrorParsingPatternPropertyReferences">
+    <value>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</value>
+    <comment>{StrBegin="MSB3938: "}</comment>
+  </data>
   <data name="Unzip.DidNotUnzipBecauseOfFileMatch">
     <value>Did not unzip from file "{0}" to file "{1}" because the "{2}" parameter was set to "{3}" in the project and the files' sizes and timestamps match.</value>
   </data>
+  <data name="Unzip.DidNotUnzipBecauseOfFilter">
+    <value>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</value>
+  </data>
   <data name="Unzip.FileComment">
     <value>Unzipping file "{0}" to "{1}".</value>
   </data>
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index d63041a77a8..c6ebbc2bf98 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">Rozzipování ze souboru {0} do souboru {1} neproběhlo, protože parametr {2} byl v projektu nastaven na hodnotu {3} a velikosti souborů a časová razítka se shodují.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: Rozzipování do adresáře {0} se nepodařilo, protože ho nebylo možné vytvořit. {1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: Soubor {0} se nepodařilo rozzipovat, protože neexistuje nebo není přístupný.</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">Soubor {0} se rozzipovává do {1}.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 6f55e8ffb7d..9d261b2b46f 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">Die Datei "{0}" wurde nicht in die Datei "{1}" entzippt, weil der Parameter "{2}" im Projekt auf "{3}" festgelegt war und die Größen und Zeitstempel der Dateien übereinstimmen.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: Fehler beim Entzippen in das Verzeichnis "{0}", weil dieses nicht erstellt werden konnte.  {1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: Die Datei "{0}" konnte nicht entzippt werden, weil sie nicht vorhanden ist oder nicht darauf zugegriffen werden kann.</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">Die Datei "{0}" wird in "{1}" entzippt.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.en.xlf b/src/Tasks/Resources/xlf/Strings.en.xlf
index 0c447b05ab3..df627557c4a 100644
--- a/src/Tasks/Resources/xlf/Strings.en.xlf
+++ b/src/Tasks/Resources/xlf/Strings.en.xlf
@@ -2530,6 +2530,11 @@
         <target state="new">Did not unzip from file "{0}" to file "{1}" because the "{2}" parameter was set to "{3}" in the project and the files' sizes and timestamps match.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="new">MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</target>
@@ -2560,6 +2565,16 @@
         <target state="new">MSB3932: Failed to unzip file "{0}" because the file does not exist or is inaccessible.</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="new">Unzipping file "{0}" to "{1}".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 620929ddfe8..8a28657818f 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">No se descomprimió del archivo "{0}" en el archivo "{1}" porque el parámetro "{2}" se estableció como "{3}" en el proyecto y los tamaños y las marcas de tiempo de los archivos coinciden.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: No se pudo descomprimir en el directorio "{0}" porque no se pudo crear.  {1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: No se pudo descomprimir el archivo "{0}" porque no existe o no se puede tener acceso a él.</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">Descomprimiendo el archivo "{0}" en "{1}".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 11359a59620..3854fcf0c19 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">Impossible de décompresser le fichier "{0}" vers le fichier "{1}", car le paramètre "{2}" a la valeur "{3}" dans le projet, et les tailles et horodatages des fichiers correspondent.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: Échec de la décompression dans le répertoire "{0}", car il n'a pas pu être créé. {1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: Échec de la décompression du fichier "{0}", car le fichier n'existe pas ou est inaccessible.</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">Décompression du fichier "{0}" dans "{1}".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 39b30cfbacb..14bdb0e8baf 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">Non è stato possibile decomprimere il file "{0}" nel file "{1}". Il parametro "{2}" è stato impostato su "{3}" nel progetto e le dimensioni e il timestamp dei file corrispondono.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: non è stato possibile decomprimere nella directory "{0}" perché non è stato possibile crearla. {1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: non è stato possibile decomprimere il file "{0}" perché non esiste oppure è inaccessibile.</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">Decompressione del file "{0}" in "{1}".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index 8166fd4d2dd..a4b07fadb16 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">"{2}" パラメーターがプロジェクトで "{3}" に設定されているため、またファイルのサイズとタイムスタンプが一致するため、ファイル "{0}" からファイル "{1}" に解凍しませんでした。</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: ディレクトリ "{0}" への解凍は、そのディレクトリを作成できなかったため、失敗しました。{1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: ファイルが存在しないか、アクセスできないため、ファイル "{0}" を解凍できませんでした。</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">ファイル "{0}" を "{1}" に解凍しています。</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index dd566fd77b2..e801bdd91a6 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">"{2}" 매개 변수가 프로젝트에 "{3}"(으)로 설정되었고 파일 크기와 타임스탬프가 일치하기 때문에 "{0}" 파일에서 "{1}" 파일로 압축을 풀 수 없습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: "{0}" 디렉터리를 생성할 수 없기 때문에 이 디렉터리에 압축을 풀지 못했습니다.  {1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: 파일이 존재하지 않거나 액세스할 수 없기 때문에 파일 "{0}"의 압축을 풀지 못했습니다.</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">파일 "{0}"의 압축을 "{1}"에 푸는 중입니다.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index bf99b39d5ea..4251be9ff36 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">Nie wykonano rozpakowywania z pliku „{0}” do pliku „{1}”, ponieważ parametr „{2}” w projekcie został ustawiony na wartość „{3}”, a rozmiary plików i sygnatury czasowe pasują do siebie.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: Nie można rozpakować do katalogu „{0}”, ponieważ nie można go utworzyć. {1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: Nie można rozpakować pliku „{0}”, ponieważ plik nie istnieje lub jest niedostępny.</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">Rozpakowywanie pliku „{0}” do pliku „{1}”.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index dc823788e5c..1dfff7329b4 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">Não foi possível descompactar o arquivo "{0}" para o arquivo "{1}", pois o parâmetro "{2}" foi definido como "{3}" no projeto, e os tamanhos de arquivos e os carimbos de data/hora não correspondem.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: Falha ao descompactar no diretório "{0}" porque ele não pôde ser criado. {1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: Falha ao descompactar o arquivo "{0}" porque ele não existe ou está inacessível.</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">Descompactando o arquivo "{0}" em "{1}".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 9e7588f33eb..9e883f29af7 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">Не удалось выполнить распаковку из файла "{0}" в файл "{1}", так как для параметра "{2}" в проекте было задано значение "{3}", а размеры файлов и отметки времени совпадают.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: не удалось выполнить распаковку в каталог "{0}", так как создать его не удалось. {1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: не удалось распаковать файл "{0}", так как он не существует или недоступен.</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">Распаковка файла "{0}" в"{1}".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index f4e09678061..194e8b3f3e1 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">Projede "{2}" parametresi "{3}" olarak ayarlandığından ve dosya boyutlarıyla zaman damgaları eşleştiğinden "{0}" dosyasını "{1}" dosyasına çıkarma işlemi gerçekleştirilmedi.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: "{0}" dizini oluşturulamadığından bu dizine çıkarılamadı. {1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: Dosya mevcut olmadığından veya erişilebilir olmadığından "{0}" dosyasının sıkıştırması açılamadı.</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">"{0}" dosyasının sıkıştırması "{1}" hedefine açılıyor.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 37aa968f49b..44e2fce72d4 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">未从文件“{0}”解压缩到文件“{1}”，因为“{2}”参数在项目中设置为“{3}”，而两个文件的大小及时间戳一致。</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: 未能解压缩到目录“{0}”，因为无法创建它。{1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: 未能解压缩文件“{0}”，因为该文件不存在或无法访问。</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">将文件“{0}”解压缩到“{1}”。</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 2fa9517589f..a70ec8fb257 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">並未從檔案 "{0}" 解壓縮到檔案 "{1}"，因為在專案中的 "{2}" 參數原先設定為 "{3}"，且檔案的大小與時間戳記相符。</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: 因為無法建立目錄 "{0}"，所以無法解壓縮至該目錄。{1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: 因為檔案不存在或無法存取，所以無法解壓縮檔案 "{0}"。</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">正在將檔案 "{0}" 解壓縮到 "{1}"。</target>
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryTaskInfo.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryTaskInfo.cs
index 90237fd0920..dcc9f893f81 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryTaskInfo.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryTaskInfo.cs
@@ -51,7 +51,7 @@ public bool Equals(RoslynCodeTaskFactoryTaskInfo other)
                 return true;
             }
 
-            return References.Equals(other.References) && String.Equals(SourceCode, other.SourceCode, StringComparison.OrdinalIgnoreCase);
+            return String.Equals(SourceCode, other.SourceCode, StringComparison.OrdinalIgnoreCase) && References.SetEquals(other.References);
         }
 
         public override bool Equals(object obj)
@@ -66,7 +66,8 @@ public override bool Equals(object obj)
 
         public override int GetHashCode()
         {
-            return 0;
+            // This is good enough to avoid most collisions, no need to hash References
+            return SourceCode.GetHashCode();
         }
     }
 }
diff --git a/src/Tasks/StrongNameException.cs b/src/Tasks/StrongNameException.cs
index 040d841c0a4..2a533772616 100644
--- a/src/Tasks/StrongNameException.cs
+++ b/src/Tasks/StrongNameException.cs
@@ -9,11 +9,9 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Internal exception thrown when there's an unrecoverable failure extracting public/private keys.
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
     internal class StrongNameException : Exception
     {
diff --git a/src/Tasks/Unzip.cs b/src/Tasks/Unzip.cs
index 401829e2f65..4e00a677831 100644
--- a/src/Tasks/Unzip.cs
+++ b/src/Tasks/Unzip.cs
@@ -1,14 +1,16 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 using System;
 using System.IO;
 using System.IO.Compression;
 using System.Linq;
 using System.Threading;
+
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
 {
@@ -27,6 +29,16 @@ public sealed class Unzip : TaskExtension, ICancelableTask
         /// </summary>
         private readonly CancellationTokenSource _cancellationToken = new CancellationTokenSource();
 
+        /// <summary>
+        /// Stores the include patterns after parsing.
+        /// </summary>
+        private string[] _includePatterns;
+
+        /// <summary>
+        /// Stores the exclude patterns after parsing.
+        /// </summary>
+        private string[] _excludePatterns;
+
         /// <summary>
         /// Gets or sets a <see cref="ITaskItem"/> with a destination folder path to unzip the files to.
         /// </summary>
@@ -49,6 +61,16 @@ public sealed class Unzip : TaskExtension, ICancelableTask
         [Required]
         public ITaskItem[] SourceFiles { get; set; }
 
+        /// <summary>
+        /// Gets or sets an MSBuild glob expression that will be used to determine which files to include being unzipped from the archive.
+        /// </summary>
+        public string Include { get; set; }
+
+        /// <summary>
+        /// Gets or sets an MSBuild glob expression that will be used to determine which files to exclude from being unzipped from the archive.
+        /// </summary>
+        public string Exclude { get; set; }
+
         /// <inheritdoc cref="ICancelableTask.Cancel"/>
         public void Cancel()
         {
@@ -74,41 +96,46 @@ public override bool Execute()
 
             try
             {
-                foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_cancellationToken.IsCancellationRequested))
+                ParseIncludeExclude();
+
+                if (!Log.HasLoggedErrors)
                 {
-                    if (!FileSystems.Default.FileExists(sourceFile.ItemSpec))
+                    foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_cancellationToken.IsCancellationRequested))
                     {
-                        Log.LogErrorWithCodeFromResources("Unzip.ErrorFileDoesNotExist", sourceFile.ItemSpec);
-                        continue;
-                    }
+                        if (!FileSystems.Default.FileExists(sourceFile.ItemSpec))
+                        {
+                            Log.LogErrorWithCodeFromResources("Unzip.ErrorFileDoesNotExist", sourceFile.ItemSpec);
+                            continue;
+                        }
 
-                    try
-                    {
-                        using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))
+                        try
                         {
-                            using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))
+                            using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))
                             {
-                                try
-                                {
-                                    Extract(zipArchive, destinationDirectory);
-                                }
-                                catch (Exception e)
+                                using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))
                                 {
-                                    // Unhandled exception in Extract() is a bug!
-                                    Log.LogErrorFromException(e, showStackTrace: true);
-                                    return false;
+                                    try
+                                    {
+                                        Extract(zipArchive, destinationDirectory);
+                                    }
+                                    catch (Exception e)
+                                    {
+                                        // Unhandled exception in Extract() is a bug!
+                                        Log.LogErrorFromException(e, showStackTrace: true);
+                                        return false;
+                                    }
                                 }
                             }
                         }
-                    }
-                    catch (OperationCanceledException)
-                    {
-                        break;
-                    }
-                    catch (Exception e)
-                    {
-                        // Should only be thrown if the archive could not be opened (Access denied, corrupt file, etc)
-                        Log.LogErrorWithCodeFromResources("Unzip.ErrorCouldNotOpenFile", sourceFile.ItemSpec, e.Message);
+                        catch (OperationCanceledException)
+                        {
+                            break;
+                        }
+                        catch (Exception e)
+                        {
+                            // Should only be thrown if the archive could not be opened (Access denied, corrupt file, etc)
+                            Log.LogErrorWithCodeFromResources("Unzip.ErrorCouldNotOpenFile", sourceFile.ItemSpec, e.Message);
+                        }
                     }
                 }
             }
@@ -129,6 +156,12 @@ private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirector
         {
             foreach (ZipArchiveEntry zipArchiveEntry in sourceArchive.Entries.TakeWhile(i => !_cancellationToken.IsCancellationRequested))
             {
+                if (ShouldSkipEntry(zipArchiveEntry))
+                {
+                    Log.LogMessageFromResources(MessageImportance.Low, "Unzip.DidNotUnzipBecauseOfFilter", zipArchiveEntry.FullName);
+                    continue;
+                }
+
                 FileInfo destinationPath = new FileInfo(Path.Combine(destinationDirectory.FullName, zipArchiveEntry.FullName));
 
                 // Zip archives can have directory entries listed explicitly.
@@ -199,6 +232,28 @@ private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirector
             }
         }
 
+        /// <summary>
+        /// Determines whether or not a file should be skipped when unzipping by filtering.
+        /// </summary>
+        /// <param name="zipArchiveEntry">The <see cref="ZipArchiveEntry"/> object containing information about the file in the zip archive.</param>
+        /// <returns><code>true</code> if the file should be skipped, otherwise <code>false</code>.</returns>
+        private bool ShouldSkipEntry(ZipArchiveEntry zipArchiveEntry)
+        {
+            bool result = false;
+
+            if (_includePatterns.Length > 0)
+            {
+                result = _includePatterns.All(pattern => !FileMatcher.IsMatch(FileMatcher.Normalize(zipArchiveEntry.FullName), pattern, true));
+            }
+
+            if (_excludePatterns.Length > 0)
+            {
+                result |= _excludePatterns.Any(pattern => FileMatcher.IsMatch(FileMatcher.Normalize(zipArchiveEntry.FullName), pattern, true));
+            }
+
+            return result;
+        }
+
         /// <summary>
         /// Determines whether or not a file should be skipped when unzipping.
         /// </summary>
@@ -212,5 +267,34 @@ private bool ShouldSkipEntry(ZipArchiveEntry zipArchiveEntry, FileInfo fileInfo)
                    && zipArchiveEntry.LastWriteTime == fileInfo.LastWriteTimeUtc
                    && zipArchiveEntry.Length == fileInfo.Length;
         }
+
+        private void ParseIncludeExclude()
+        {
+            ParsePattern(Include, out _includePatterns);
+            ParsePattern(Exclude, out _excludePatterns);
+        }
+
+        private void ParsePattern(string pattern, out string[] patterns)
+        {
+            patterns = Array.Empty<string>();
+            if (!string.IsNullOrWhiteSpace(pattern))
+            {
+                if (FileMatcher.HasPropertyOrItemReferences(pattern))
+                {
+                    // Supporting property references would require access to Expander which is unavailable in Microsoft.Build.Tasks
+                    Log.LogErrorWithCodeFromResources("Unzip.ErrorParsingPatternPropertyReferences", pattern);
+                }
+                else if (pattern.IndexOfAny(FileUtilities.InvalidPathChars) != -1)
+                {
+                    Log.LogErrorWithCodeFromResources("Unzip.ErrorParsingPatternInvalidPath", pattern);
+                }
+                else
+                {
+                    patterns = pattern.Contains(';')
+                                   ? pattern.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries).Select(FileMatcher.Normalize).ToArray()
+                                   : new[] { pattern };
+                }
+            }
+        }
     }
 }
diff --git a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
index 30db3703d9b..209e21d4d1e 100644
--- a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
+++ b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
@@ -63,18 +63,6 @@
     <Compile Include="..\Shared\NativeMethodsShared.cs">
       <Link>NativeMethodsShared.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\IInternable.cs">
-      <Link>IInternable.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\WeakStringCache.cs">
-      <Link>WeakStringCache.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs">
-      <Link>WeakStringCache.Concurrent.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\OpportunisticIntern.cs">
-      <Link>OpportunisticIntern.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\ResourceUtilities.cs">
       <Link>ResourceUtilities.cs</Link>
     </Compile>
diff --git a/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj b/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
index b560f1b1455..2f3dd9cba5a 100644
--- a/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
+++ b/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
@@ -11,7 +11,6 @@
 
   <ItemGroup>
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.IO.FileSystem.Primitives" />
     <PackageReference Include="Microsoft.CodeAnalysis.Build.Tasks" />
 
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index d8c69b18f9e..f683c61ca7d 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -679,22 +679,22 @@ public void ToolPathIsFoundWhenDirectoryExistsWithNameOfTool()
         [Fact]
         public void FindOnPathSucceeds()
         {
-            string expectedCmdPath;
+            string[] expectedCmdPath;
             string shellName;
             if (NativeMethodsShared.IsWindows)
             {
-                expectedCmdPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.System), "cmd.exe");
+                expectedCmdPath = new[] { Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.System), "cmd.exe") };
                 shellName = "cmd.exe";
             }
             else
             {
-                expectedCmdPath = "/bin/sh";
+                expectedCmdPath = new[] { "/bin/sh", "/usr/bin/sh" };
                 shellName = "sh";
             }
 
             string cmdPath = ToolTask.FindOnPath(shellName);
 
-            cmdPath.ShouldBe(expectedCmdPath, StringCompareShould.IgnoreCase);
+            cmdPath.ShouldBeOneOf(expectedCmdPath);
         }
 
         /// <summary>
diff --git a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
index 9558f9098ea..79db28ce138 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
@@ -1,6 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_FILE_TRACKER
+
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
@@ -17,7 +19,6 @@
 using BackEndNativeMethods = Microsoft.Build.BackEnd.NativeMethods;
 
 // PLEASE NOTE: This is a UNICODE file as it contains UNICODE characters!
-#if FEATURE_FILE_TRACKER
 
 namespace Microsoft.Build.UnitTests.FileTracking
 {
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index 840d2bcc37e..2fdd06afdd6 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -19,7 +19,8 @@
 
   <ItemGroup>
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
-    
+    <ProjectReference Include="..\StringTools\StringTools.csproj" />
+
     <PackageReference Include="System.Collections.Immutable" />
   </ItemGroup>
 
@@ -124,18 +125,6 @@
     <Compile Include="..\Shared\InprocTrackingNativeMethods.cs">
       <Link>Shared\InprocTrackingNativeMethods.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\IInternable.cs">
-      <Link>Shared\IInternable.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\WeakStringCache.cs">
-      <Link>Shared\WeakStringCache.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs">
-      <Link>Shared\WeakStringCache.Concurrent.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\OpportunisticIntern.cs">
-      <Link>Shared\OpportunisticIntern.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\ReadOnlyEmptyCollection.cs">
       <Link>Shared\ReadOnlyEmptyCollection.cs</Link>
     </Compile>
diff --git a/src/Utilities/MuxLogger.cs b/src/Utilities/MuxLogger.cs
index 6fc1777dcad..fd31a3cf970 100644
--- a/src/Utilities/MuxLogger.cs
+++ b/src/Utilities/MuxLogger.cs
@@ -43,10 +43,10 @@ namespace Microsoft.Build.Utilities
     ///     At this point we will look up the success state of the project finished event for the submission ID and log a build finished event to the logger.
     ///     The event source will be cleaned up.  This may be interesting because the unregister will come from a thread other than what is doing the logging.
     ///     This may create a Synchronization issue, if unregister is called while events are being logged.
-    ///     
-    /// UNDONE: If we can use ErrorUtilities, replace all InvalidOperation and Argument exceptions with the appropriate calls.
-    /// 
     /// </summary>
+    //     
+    // UNDONE: If we can use ErrorUtilities, replace all InvalidOperation and Argument exceptions with the appropriate calls.
+    // 
     public class MuxLogger : INodeLogger
     {
         /// <summary>
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index 0a361a8cd7a..a2bb6693c41 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -30,7 +30,7 @@ public sealed class TaskItem :
 #if FEATURE_APPDOMAIN
         MarshalByRefObject,
 #endif
-        ITaskItem, ITaskItem2
+        ITaskItem2
     {
         #region Member Data
 
@@ -297,10 +297,25 @@ public void CopyMetadataTo(ITaskItem destinationItem)
 
             if (_metadata != null)
             {
-                // Avoid a copy if we can
-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)
+                if (destinationItem is TaskItem destinationAsTaskItem)
                 {
-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!
+                    CopyOnWriteDictionary<string> copiedMetadata;
+                    // Avoid a copy if we can, and if not, minimize the number of items we have to set.
+                    if (destinationAsTaskItem.Metadata == null)
+                    {
+                        copiedMetadata = _metadata.Clone(); // Copy on write!
+                    }
+                    else if (destinationAsTaskItem.Metadata.Count < _metadata.Count)
+                    {
+                        copiedMetadata = _metadata.Clone(); // Copy on write!
+                        copiedMetadata.SetItems(destinationAsTaskItem.Metadata.Where(entry => !String.IsNullOrEmpty(entry.Value)));
+                    }
+                    else
+                    {
+                        copiedMetadata = destinationAsTaskItem.Metadata.Clone();
+                        copiedMetadata.SetItems(_metadata.Where(entry => !destinationAsTaskItem.Metadata.TryGetValue(entry.Key, out string val) || String.IsNullOrEmpty(val)));
+                    }
+                    destinationAsTaskItem.Metadata = copiedMetadata;
                 }
                 else
                 {
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 93ec1767db9..23f7abc7e67 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -54,10 +54,8 @@ public enum HostObjectInitializationStatus
     /// Base class used for tasks that spawn an executable. This class implements the ToolPath property which can be used to
     /// override the default path.
     /// </summary>
-    /// <remarks>
-    /// INTERNAL WARNING: DO NOT USE the Log property in this class! Log points to resources in the task assembly itself, and 
-    /// we want to use resources from Utilities. Use LogPrivate (for private Utilities resources) and LogShared (for shared MSBuild resources)
-    /// </remarks>
+    // INTERNAL WARNING: DO NOT USE the Log property in this class! Log points to resources in the task assembly itself, and 
+    // we want to use resources from Utilities. Use LogPrivate (for private Utilities resources) and LogShared (for shared MSBuild resources)
     public abstract class ToolTask : Task, ICancelableTask
     {
         private static readonly bool s_preserveTempFiles = string.Equals(Environment.GetEnvironmentVariable("MSBUILDPRESERVETOOLTEMPFILES"), "1", StringComparison.Ordinal);
diff --git a/src/Xunit.NetCore.Extensions/SkippedTestCase.cs b/src/Xunit.NetCore.Extensions/SkippedTestCase.cs
index d094c882519..518f4ffa77a 100644
--- a/src/Xunit.NetCore.Extensions/SkippedTestCase.cs
+++ b/src/Xunit.NetCore.Extensions/SkippedTestCase.cs
@@ -17,6 +17,11 @@ internal sealed class SkippedTestCase : LongLivedMarshalByRefObject, IXunitTestC
         private readonly IXunitTestCase _testCase;
         private readonly string _skippedReason;
 
+        public SkippedTestCase()
+        {
+
+        }
+
         internal SkippedTestCase(IXunitTestCase testCase, string skippedReason)
         {
             _testCase = testCase;
