diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index e340aaacdc6..e4606f13fe1 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -319,8 +319,6 @@ public void VerifyEnvironmentSavedBetweenCalls()
         /// </summary>
 #if RUNTIME_TYPE_NETCORE
         [Theory(Skip = "https://github.com/dotnet/msbuild/issues/1975")]
-#elif MONO
-        [Theory(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
 #else
         [Theory(Skip = "https://github.com/dotnet/msbuild/issues/2057")]
 #endif
@@ -397,11 +395,7 @@ public void ShutdownNodesAfterParallelBuild(int numberOfParallelProjectsToBuild,
         /// <summary>
         /// A simple successful build, out of process only.
         /// </summary>
-#if MONO
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
-#else
         [Fact]
-#endif
         public void SimpleBuildOutOfProcess()
         {
             RunOutOfProcBuild(_ => _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1"));
@@ -410,11 +404,7 @@ public void SimpleBuildOutOfProcess()
         /// <summary>
         /// A simple successful build, out of process only. Triggered by setting build parameters' DisableInProcNode to true.
         /// </summary>
-#if MONO
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
-#else
         [Fact]
-#endif
         public void DisableInProcNode()
         {
             RunOutOfProcBuild(buildParameters => buildParameters.DisableInProcNode = true);
@@ -460,11 +450,7 @@ private void RunOutOfProcBuild(Action<BuildParameters> buildParametersModifier)
             Assert.NotEqual(Process.GetCurrentProcess().Id, processId); // "Build is expected to be out-of-proc. In fact it was in-proc."
         }
 
-#if MONO
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
-#else
         [Fact]
-#endif
         public void RequestedResultsAreSatisfied()
         {
             const string contents = @"
@@ -683,8 +669,6 @@ public void MsBuildForwardAllPropertiesFromChildLaunchChildNode()
         /// </summary>
 #if RUNTIME_TYPE_NETCORE
         [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1976")]
-#elif MONO
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
 #else
         [Fact]
 #endif
@@ -736,8 +720,6 @@ public void OutOfProcNodeForwardCertainproperties()
         /// </summary>
 #if RUNTIME_TYPE_NETCORE
         [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1976")]
-#elif MONO
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
 #else
         [Fact]
 #endif
@@ -805,11 +787,7 @@ public void OutOfProcNodeForwardCertainpropertiesAlsoGetResultsFromCache()
         /// Make sure when if the environment variable MsBuildForwardPropertiesFromChild is set to empty and
         /// we launch a child node that we get no properties
         /// </summary>
-#if MONO
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
-#else
         [Fact]
-#endif
         public void ForwardNoPropertiesLaunchChildNode()
         {
             string contents = CleanupFileContents(@"
@@ -849,8 +827,6 @@ public void ForwardNoPropertiesLaunchChildNode()
         /// </summary>
 #if RUNTIME_TYPE_NETCORE
         [Fact(Skip = "https://github.com/dotnet/msbuild/issues/933")]
-#elif MONO
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
 #else
         [Fact]
 #endif
@@ -910,11 +886,7 @@ public override bool Execute()
         /// When a child node is launched by default we should not send any properties.
         /// we launch a child node that we get no properties
         /// </summary>
-#if MONO
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
-#else
         [Fact]
-#endif
         public void ForwardNoPropertiesLaunchChildNodeDefault()
         {
             string contents = CleanupFileContents(@"
@@ -2133,11 +2105,7 @@ public void Regress251333()
         /// <summary>
         /// Verify that disabling the in-proc node doesn't cause projects which don't require it to fail.
         /// </summary>
-#if MONO
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
-#else
         [Fact]
-#endif
         public void Regress239661()
         {
             string contents = CleanupFileContents(@"
@@ -2195,11 +2163,7 @@ public void ExplicitInprocAffinityGetsOverruledByDisableInprocNode()
         /// <summary>
         /// Ensures that properties and items are transferred to the out-of-proc node when an instance is used to start the build.
         /// </summary>
-#if MONO
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
-#else
         [Fact]
-#endif
         public void ProjectInstanceTransfersToOOPNode()
         {
             string contents = CleanupFileContents(@"
@@ -2260,11 +2224,7 @@ public void ProjectInstanceTransfersToOOPNode()
         /// <summary>
         /// Ensures that a limited set of properties are transferred from a project instance to an OOP node.
         /// </summary>
-#if MONO
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
-#else
         [Fact]
-#endif
         public void ProjectInstanceLimitedTransferToOOPNode()
         {
             string contents = CleanupFileContents(@"
@@ -2560,8 +2520,6 @@ public void NonOverlappingEnusingTrypointTargetsShouldNotInfluenceEachOthersResu
         /// </summary>
 #if RUNTIME_TYPE_NETCORE
         [Fact(Skip = "https://github.com/dotnet/msbuild/issues/933")]
-#elif MONO
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
 #else
         [Fact]
 #endif
@@ -2659,11 +2617,7 @@ public void Regress473114()
         /// second request will bail out where the first request did, as though it had
         /// executed the target, rather than skipping and continuing.
         /// </summary>
-#if MONO
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
-#else
         [Fact]
-#endif
         public void VerifyMultipleRequestForSameProjectWithErrors_Simple()
         {
             var projA = _env.CreateFile(".proj").Path;
@@ -2742,11 +2696,7 @@ public void VerifyMultipleRequestForSameProjectWithErrors_Simple()
         /// expected in the first request, but be skipped by the second (since if it's "skipping
         /// unsuccessful", it can assume that all other OnError targets have also already been run)
         /// </summary>
-#if MONO
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
-#else
         [Fact]
-#endif
         public void VerifyMultipleRequestForSameProjectWithErrors_OnErrorChain()
         {
             var projA = _env.CreateFile(".proj").Path;
@@ -2861,11 +2811,7 @@ public void VerifyMultipleRequestForSameProjectWithErrors_OnErrorChain()
         /// they're marked as ContinueOnError=ErrorAndContinue, then we won't bail, but
         /// will continue executing (on the first request) or skipping (on the second)
         /// </summary>
-#if MONO
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
-#else
         [Fact]
-#endif
         public void VerifyMultipleRequestForSameProjectWithErrors_ErrorAndContinue()
         {
             var projA = _env.CreateFile(".proj").Path;
@@ -2951,11 +2897,7 @@ public void VerifyMultipleRequestForSameProjectWithErrors_ErrorAndContinue()
         /// This test verifies that if the errors are in AfterTargets, we still
         /// exit as though the target that those targets run after has already run.
         /// </summary>
-#if MONO
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
-#else
         [Fact]
-#endif
         public void VerifyMultipleRequestForSameProjectWithErrors_AfterTargets()
         {
             var projA = _env.CreateFile(".proj").Path;
@@ -3238,11 +3180,7 @@ public void TestSimultaneousSubmissionsWithLegacyThreadingData_P2P()
         /// submissions aren't restricted to running strictly serially by the single in-proc
         /// node.
         /// </summary>
-#if MONO
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1245")]
-#else
         [Fact]
-#endif
         public void TestSimultaneousSubmissionsWithLegacyThreadingData_P2P_MP()
         {
             string projectContent1 = @"<Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index c91df2ca317..9bd74e422d5 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -714,7 +714,6 @@ public void NullMetadataOnLegacyOutputItems_InlineTask()
         /// If an item being output from a task has null metadata, we shouldn't crash.
         /// </summary>
         [Fact(Skip = "This test fails when diagnostic logging is available, as deprecated EscapingUtilities.UnescapeAll method cannot handle null value. This is not relevant to non-deprecated version of this method.")]
-        [Trait("Category", "non-mono-tests")]
         public void NullMetadataOnLegacyOutputItems_InlineTask_Diagnostic()
         {
             string projectContents = @"
diff --git a/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
index 1d30e7f6067..2bea6c64692 100644
--- a/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
@@ -79,7 +79,7 @@ public void AddEntry()
         /// <summary>
         /// Tests that a strong reference is held to a single item
         /// </summary>
-        [WindowsFullFrameworkOnlyFact(additionalMessage: "This test fails on .NET Core and Mono: https://github.com/dotnet/msbuild/issues/282")]
+        [Fact]
         public void AddEntryStrongReference()
         {
             string projectPath = NativeMethodsShared.IsUnixLike ? "/foo" : "c:\\foo";
diff --git a/src/Build.UnitTests/EvaluationProfiler_Tests.cs b/src/Build.UnitTests/EvaluationProfiler_Tests.cs
index 27438bec72e..691d674dfb2 100644
--- a/src/Build.UnitTests/EvaluationProfiler_Tests.cs
+++ b/src/Build.UnitTests/EvaluationProfiler_Tests.cs
@@ -89,11 +89,7 @@ public void Dispose()
 <ItemGroup>
     <CSFile Include='file.cs'/>
 </ItemGroup>")]
-#if MONO
-        [Theory(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
-#else
         [Theory]
-#endif
         public void VerifySimpleProfiledData(string elementName, string body)
         {
             string contents = $@"
@@ -125,11 +121,7 @@ public void VerifySimpleProfiledData(string elementName, string body)
 <ItemGroup>
     <CSFile Include='file.cs'/>
 </ItemGroup>")]
-#if MONO
-        [Theory(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
-#else
         [Theory]
-#endif
         public void VerifySimpleProfiledDataWithoutProjectLoadSetting(string elementName, string body)
         {
             string contents = $@"
@@ -143,11 +135,7 @@ public void VerifySimpleProfiledDataWithoutProjectLoadSetting(string elementName
             Assert.Contains(profiledElements, location => location.ElementName == elementName);
         }
 
-#if MONO
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
-#else
         [Fact]
-#endif
         public void VerifyProfiledData()
         {
             var result = BuildAndGetProfilerResult(SpecData);
@@ -180,11 +168,7 @@ public void VerifyProfiledData()
             Assert.Single(profiledElements.Where(location => location.ElementName == "Target"));
         }
 
-#if MONO
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
-#else
         [Fact]
-#endif
         public void VerifyProfiledGlobData()
         {
             string contents = @"
@@ -214,11 +198,7 @@ public void VerifyProfiledGlobData()
             Assert.Equal(2, totalGlobLocation.NumberOfHits);
         }
 
-#if MONO
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
-#else
         [Fact]
-#endif
         public void VerifyParentIdData()
         {
             string contents = @"
@@ -258,11 +238,7 @@ public void VerifyParentIdData()
             Assert.Equal(target.Id, messageTarget.ParentId);
         }
 
-#if MONO
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1240")]
-#else
         [Fact]
-#endif
         public void VerifyIdsSanity()
         {
             var result = BuildAndGetProfilerResult(SpecData);
diff --git a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
index 72abe497317..b32c0a08dd0 100644
--- a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
+++ b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
@@ -558,9 +558,7 @@ private void AssertBuild(
 
             TransientTestFile CreateTmpFile(TestEnvironment env)
             {
-                return NativeMethodsShared.IsMono && NativeMethodsShared.IsOSX
-                                                ? env.CreateFile(new TransientTestFolder(Path.Combine(Directory.GetCurrentDirectory(), Guid.NewGuid().ToString("N"))))
-                                                : env.CreateFile();
+                return env.CreateFile();
             }
         }
 
diff --git a/src/Build.UnitTests/Instance/TaskItem_Tests.cs b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
index da4fd47acd2..fd6eef36b6a 100644
--- a/src/Build.UnitTests/Instance/TaskItem_Tests.cs
+++ b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
@@ -289,7 +289,7 @@ public void Escaping1()
         /// <summary>
         /// Flushing an item through a task run in the task host also should not mess up special characters on the metadata. 
         /// </summary>
-#if RUNTIME_TYPE_NETCORE || MONO
+#if RUNTIME_TYPE_NETCORE
         [Fact(Skip = "FEATURE: TASKHOST")]
 #else
         [Fact]
@@ -346,7 +346,7 @@ public void Escaping2()
         /// <summary>
         /// Flushing an item through a task run in the task host also should not mess up the escaping of the itemspec either. 
         /// </summary>
-#if RUNTIME_TYPE_NETCORE || MONO
+#if RUNTIME_TYPE_NETCORE
         [Fact(Skip = "FEATURE: TASKHOST")]
 #else
         [Fact]
diff --git a/src/Build/BackEnd/Components/Communications/CurrentHost.cs b/src/Build/BackEnd/Components/Communications/CurrentHost.cs
index 97855dfd97f..37bc10fc28e 100644
--- a/src/Build/BackEnd/Components/Communications/CurrentHost.cs
+++ b/src/Build/BackEnd/Components/Communications/CurrentHost.cs
@@ -1,7 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-#if RUNTIME_TYPE_NETCORE || MONO
+#if RUNTIME_TYPE_NETCORE
 using System.Diagnostics;
 using System.IO;
 using Microsoft.Build.Shared;
@@ -14,7 +14,7 @@ namespace Microsoft.Build.BackEnd
     internal static class CurrentHost
     {
 
-#if RUNTIME_TYPE_NETCORE || MONO
+#if RUNTIME_TYPE_NETCORE
         private static string s_currentHost;
 #endif
 
@@ -24,7 +24,7 @@ internal static class CurrentHost
         /// <returns>The full path to the executable hosting the current process, or null if running on Full Framework on Windows.</returns>
         public static string GetCurrentHost()
         {
-#if RUNTIME_TYPE_NETCORE || MONO
+#if RUNTIME_TYPE_NETCORE
             if (s_currentHost == null)
             {
                 string dotnetExe = Path.Combine(FileUtilities.GetFolderAbove(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, 2),
diff --git a/src/Build/BackEnd/Components/Communications/NodeLauncher.cs b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
index 611c4ca68c9..553eff4121f 100644
--- a/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
@@ -79,13 +79,9 @@ private Process StartInternal(string msbuildLocation, string commandLineArgs)
 
             string exeName = msbuildLocation;
 
-#if RUNTIME_TYPE_NETCORE || MONO
-            // Mono automagically uses the current mono, to execute a managed assembly
-            if (!NativeMethodsShared.IsMono)
-            {
-                // Run the child process with the same host as the currently-running process.
-                exeName = CurrentHost.GetCurrentHost();
-            }
+#if RUNTIME_TYPE_NETCORE
+            // Run the child process with the same host as the currently-running process.
+            exeName = CurrentHost.GetCurrentHost();
 #endif
 
             if (!NativeMethodsShared.IsWindows)
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 7346954557d..7c1fc7f08a2 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -490,7 +490,7 @@ internal static void ConnectToPipeStream(NamedPipeClientStream nodeStream, strin
             nodeStream.Connect(timeout);
 
 #if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-            if (NativeMethodsShared.IsWindows && !NativeMethodsShared.IsMono)
+            if (NativeMethodsShared.IsWindows)
             {
                 // Verify that the owner of the pipe is us.  This prevents a security hole where a remote node has
                 // been faked up with ACLs that would let us attach to it.  It could then issue fake build requests back to
@@ -514,7 +514,7 @@ internal static void ConnectToPipeStream(NamedPipeClientStream nodeStream, strin
 
             CommunicationsUtilities.Trace("Reading handshake from pipe {0}", pipeName);
 
-#if NETCOREAPP2_1_OR_GREATER || MONO
+#if NETCOREAPP2_1_OR_GREATER
             nodeStream.ReadEndOfHandshakeSignal(true, timeout);
 #else
             nodeStream.ReadEndOfHandshakeSignal(true);
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index 6fe5e032d8d..80afd910c9b 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -8,7 +8,7 @@
 using System.Security;
 using System.Text;
 using System.Xml;
-#if !NETFRAMEWORK || MONO
+#if !NETFRAMEWORK
 using Microsoft.Build.Shared;
 #endif
 
@@ -157,7 +157,7 @@ public string RelativePath
 
             internal set
             {
-#if NETFRAMEWORK && !MONO
+#if NETFRAMEWORK
                 // Avoid loading System.Runtime.InteropServices.RuntimeInformation in full-framework
                 // cases. It caused https://github.com/NuGet/Home/issues/6918.
                 _relativePath = value;
@@ -184,7 +184,7 @@ public string AbsolutePath
                     {
                         try
                         {
-#if NETFRAMEWORK && !MONO
+#if NETFRAMEWORK
                             _absolutePath = Path.GetFullPath(_absolutePath);
 #else
                             _absolutePath = FileUtilities.NormalizePath(_absolutePath);
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index ec59aaff465..2c363e55777 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -917,8 +917,6 @@ private void InitializeProperties(ILoggingService loggingServices, BuildEventCon
                     reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.msbuildRuntimeType,
 #if RUNTIME_TYPE_NETCORE
                         Traits.Instance.ForceEvaluateAsFullFramework ? "Full" : "Core",
-#elif MONO
-                        NativeMethodsShared.IsMono ? "Mono" : "Full");
 #else
                         "Full",
 #endif
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index 9c064f5e68f..7a3978bed09 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -179,21 +179,17 @@ void ReadConfigToolset()
                             FrameworkLocationHelper.GetPathToDotNetFrameworkV40(DotNetFrameworkArchitecture.Current);
                         if (v4Dir != null && !toolsets.ContainsKey("4.0"))
                         {
-                            // Create standard properties. On Mono they are well known
-                            var buildProperties =
-                                CreateStandardProperties(globalProperties, "4.0", libraryPath, v4Dir);
-
                             toolsets.Add(
                                 "4.0",
                                 new Toolset(
                                     "4.0",
                                     v4Dir,
-                                    buildProperties,
+                                    buildProperties: null,
                                     environmentProperties,
                                     globalProperties,
-                                    null,
-                                    currentDir,
-                                    string.Empty));
+                                    subToolsets: null,
+                                    msbuildOverrideTasksPath: currentDir,
+                                    defaultOverrideToolsVersion: string.Empty));
                         }
 
                         // Other toolsets are installed in the xbuild directory
@@ -210,26 +206,17 @@ void ReadConfigToolset()
                                     continue;
                                 }
 
-                                if (NativeMethodsShared.IsMono && Version.TryParse(version, out Version parsedVersion) && parsedVersion.Major > 14)
-                                {
-                                    continue;
-                                }
-
-                                // Create standard properties. On Mono they are well known
-                                var buildProperties =
-                                    CreateStandardProperties(globalProperties, version, xbuildToolsetsDir, binPath);
-
                                 toolsets.Add(
                                     version,
                                     new Toolset(
                                         version,
                                         binPath,
-                                        buildProperties,
+                                        buildProperties: null,
                                         environmentProperties,
                                         globalProperties,
-                                        null,
-                                        currentDir,
-                                        string.Empty));
+                                        subToolsets: null,
+                                        msbuildOverrideTasksPath: currentDir,
+                                        defaultOverrideToolsVersion: string.Empty));
                             }
                         }
                     }
@@ -535,7 +522,6 @@ private Toolset ReadToolset(
                 InvalidToolsetDefinitionException.Throw("ConflictingValuesOfMSBuildToolsPath", toolsVersion.Name, toolsVersion.Source.LocationString);
             }
 
-            AppendStandardProperties(properties, globalProperties, toolsVersion.Name, null, toolsPath);
             Toolset toolset = null;
 
             try
@@ -551,100 +537,6 @@ private Toolset ReadToolset(
             return toolset;
         }
 
-        /// <summary>
-        /// Create a dictionary with standard properties.
-        /// </summary>
-        private static PropertyDictionary<ProjectPropertyInstance> CreateStandardProperties(
-            PropertyDictionary<ProjectPropertyInstance> globalProperties,
-            string version,
-            string root,
-            string toolsPath)
-        {
-            // Create standard properties. On Mono they are well known
-            if (!NativeMethodsShared.IsMono)
-            {
-                return null;
-            }
-            PropertyDictionary<ProjectPropertyInstance> buildProperties =
-                new PropertyDictionary<ProjectPropertyInstance>();
-            AppendStandardProperties(buildProperties, globalProperties, version, root, toolsPath);
-            return buildProperties;
-        }
-
-        /// <summary>
-        /// Appends standard properties to a dictionary. These properties are read from
-        /// the registry under Windows (they are a part of a toolset definition).
-        /// </summary>
-        private static void AppendStandardProperties(
-            PropertyDictionary<ProjectPropertyInstance> properties,
-            PropertyDictionary<ProjectPropertyInstance> globalProperties,
-            string version,
-            string root,
-            string toolsPath)
-        {
-            if (NativeMethodsShared.IsMono)
-            {
-                var v4Dir = FrameworkLocationHelper.GetPathToDotNetFrameworkV40(DotNetFrameworkArchitecture.Current)
-                            + Path.DirectorySeparatorChar;
-                var v35Dir = FrameworkLocationHelper.GetPathToDotNetFrameworkV35(DotNetFrameworkArchitecture.Current)
-                             + Path.DirectorySeparatorChar;
-
-                if (root == null)
-                {
-                    var libraryPath = NativeMethodsShared.FrameworkBasePath;
-                    if (toolsPath.StartsWith(libraryPath))
-                    {
-                        root = Path.GetDirectoryName(toolsPath);
-                        if (toolsPath.EndsWith("bin"))
-                        {
-                            root = Path.GetDirectoryName(root);
-                        }
-                    }
-                    else
-                    {
-                        root = libraryPath;
-                    }
-                }
-
-                root += Path.DirectorySeparatorChar;
-
-                // Global properties cannot be overwritten
-                if (globalProperties["FrameworkSDKRoot"] == null && properties["FrameworkSDKRoot"] == null)
-                {
-                    properties.Set(ProjectPropertyInstance.Create("FrameworkSDKRoot", root, true, false));
-                }
-                if (globalProperties["MSBuildToolsRoot"] == null && properties["MSBuildToolsRoot"] == null)
-                {
-                    properties.Set(ProjectPropertyInstance.Create("MSBuildToolsRoot", root, true, false));
-                }
-                if (globalProperties["MSBuildFrameworkToolsPath"] == null
-                    && properties["MSBuildFrameworkToolsPath"] == null)
-                {
-                    properties.Set(ProjectPropertyInstance.Create("MSBuildFrameworkToolsPath", toolsPath, true, false));
-                }
-                if (globalProperties["MSBuildFrameworkToolsPath32"] == null
-                    && properties["MSBuildFrameworkToolsPath32"] == null)
-                {
-                    properties.Set(
-                        ProjectPropertyInstance.Create("MSBuildFrameworkToolsPath32", toolsPath, true, false));
-                }
-                if (globalProperties["MSBuildRuntimeVersion"] == null && properties["MSBuildRuntimeVersion"] == null)
-                {
-                    properties.Set(ProjectPropertyInstance.Create("MSBuildRuntimeVersion", version, true, false));
-                }
-                if (!string.IsNullOrEmpty(v35Dir) && globalProperties["SDK35ToolsPath"] == null
-                    && properties["SDK35ToolsPath"] == null)
-                {
-                    properties.Set(ProjectPropertyInstance.Create("SDK35ToolsPath", v35Dir, true, false));
-                }
-                if (!string.IsNullOrEmpty(v4Dir) && globalProperties["SDK40ToolsPath"] == null
-                    && properties["SDK40ToolsPath"] == null)
-                {
-                    properties.Set(ProjectPropertyInstance.Create("SDK40ToolsPath", v4Dir, true, false));
-                }
-            }
-        }
-
         /// <summary>
         /// Processes a particular ToolsetPropertyDefinition into the correct value and location in the initial and/or final property set. 
         /// </summary>
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 35097b0aeda..978c00274cc 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -1158,9 +1158,6 @@ private void AddBuiltInProperties()
 #if RUNTIME_TYPE_NETCORE
             SetBuiltInProperty(ReservedPropertyNames.msbuildRuntimeType,
                 Traits.Instance.ForceEvaluateAsFullFramework ? "Full" : "Core");
-#elif MONO
-            SetBuiltInProperty(ReservedPropertyNames.msbuildRuntimeType,
-                                                        NativeMethodsShared.IsMono ? "Mono" : "Full");
 #else
             SetBuiltInProperty(ReservedPropertyNames.msbuildRuntimeType, "Full");
 #endif
diff --git a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
index 15bb1ebc0cc..806d5b676b9 100644
--- a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
+++ b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
@@ -332,9 +332,7 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
                 VerifyThrowIdentityParametersValid(taskIdentityParameters, taskLocation, _taskName, "MSBuildRuntime", "MSBuildArchitecture");
 
                 mergedParameters = MergeTaskFactoryParameterSets(_factoryIdentityParameters, taskIdentityParameters);
-                useTaskFactory = !NativeMethodsShared.IsMono
-                                 && (_taskHostFactoryExplicitlyRequested
-                                     || !TaskHostParametersMatchCurrentProcess(mergedParameters));
+                useTaskFactory = _taskHostFactoryExplicitlyRequested || !TaskHostParametersMatchCurrentProcess(mergedParameters);
             }
             else
             {
diff --git a/src/Framework/AssemblyUtilities.cs b/src/Framework/AssemblyUtilities.cs
index dcb013b3a0d..eea490775a7 100644
--- a/src/Framework/AssemblyUtilities.cs
+++ b/src/Framework/AssemblyUtilities.cs
@@ -99,9 +99,8 @@ public static AssemblyName CloneIfPossible(this AssemblyName assemblyNameToClone
             name.CodeBase = assemblyNameToClone.CodeBase;
             name.KeyPair = assemblyNameToClone.KeyPair;
             name.VersionCompatibility = assemblyNameToClone.VersionCompatibility;
-#elif !MONO
+#else
             // Setting the culture name creates a new CultureInfo, leading to many allocations. Only set CultureName when the CultureInfo member is not available.
-            // CultureName not available on Mono
             name.CultureName = assemblyNameToClone.CultureName;
 #endif
 
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index 85fbdddd446..83429abc3e4 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -483,7 +483,7 @@ public SystemInformationData()
     public static int GetLogicalCoreCount()
     {
         int numberOfCpus = Environment.ProcessorCount;
-#if !MONO
+
         // .NET on Windows returns a core count limited to the current NUMA node
         //     https://github.com/dotnet/runtime/issues/29686
         // so always double-check it.
@@ -495,7 +495,6 @@ public static int GetLogicalCoreCount()
                 numberOfCpus = result;
             }
         }
-#endif
 
         return numberOfCpus;
     }
@@ -654,37 +653,6 @@ internal static bool IsBSD
 #endif
     }
 
-    private static readonly object IsMonoLock = new object();
-
-    private static bool? _isMono;
-
-    /// <summary>
-    /// Gets a flag indicating if we are running under MONO
-    /// </summary>
-    internal static bool IsMono
-    {
-        get
-        {
-            if (_isMono != null)
-            {
-                return _isMono.Value;
-            }
-
-            lock (IsMonoLock)
-            {
-                if (_isMono == null)
-                {
-                    // There could be potentially expensive TypeResolve events, so cache IsMono.
-                    // Also, VS does not host Mono runtimes, so turn IsMono off when msbuild is running under VS
-                    _isMono = !BuildEnvironmentState.s_runningInVisualStudio &&
-                              Type.GetType("Mono.Runtime") != null;
-                }
-            }
-
-            return _isMono.Value;
-        }
-    }
-
 #if !CLR2COMPATIBILITY
     private static bool? _isWindows;
 #endif
@@ -743,8 +711,6 @@ internal static string FrameworkName
         {
 #if RUNTIME_TYPE_NETCORE
             const string frameworkName = ".NET";
-#elif MONO
-            const string frameworkName = "Mono";
 #else
             const string frameworkName = ".NET Framework";
 #endif
@@ -767,7 +733,7 @@ internal static bool OSUsesCaseSensitivePaths
     }
 
     /// <summary>
-    /// The base directory for all framework paths in Mono
+    /// The base directory for all framework paths
     /// </summary>
     private static string s_frameworkBasePath;
 
@@ -797,7 +763,7 @@ internal static string FrameworkCurrentPath
     }
 
     /// <summary>
-    /// Gets the base directory of all Mono frameworks
+    /// Gets the base directory of all frameworks
     /// </summary>
     internal static string FrameworkBasePath
     {
diff --git a/src/MSBuild/MSBuildClientApp.cs b/src/MSBuild/MSBuildClientApp.cs
index de7895a6259..e7467cb2a91 100644
--- a/src/MSBuild/MSBuildClientApp.cs
+++ b/src/MSBuild/MSBuildClientApp.cs
@@ -7,7 +7,7 @@
 using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Shared;
 
-#if RUNTIME_TYPE_NETCORE || MONO
+#if RUNTIME_TYPE_NETCORE
 using System.IO;
 using System.Diagnostics;
 #endif
@@ -99,7 +99,7 @@ public static MSBuildApp.ExitType Execute(
         }
 
         // Copied from NodeProviderOutOfProcBase.cs
-#if RUNTIME_TYPE_NETCORE || MONO
+#if RUNTIME_TYPE_NETCORE
         private static string? CurrentHost;
         private static string GetCurrentHost()
         {
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 3cea4a096b1..ef55bf58799 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -88,7 +88,7 @@
   </data>
   <data name="MSBuildVersionMessage" UESanitized="true" Visibility="Public">
     <value>MSBuild version {0} for {1}</value>
-    <comment>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</comment>
+    <comment>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework" or ".NET Core"</comment>
   </data>
   <data name="DuplicateProjectSwitchError" UESanitized="true" Visibility="Public">
     <value>MSBUILD : error MSB1008: Only one project can be specified.</value>
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 827a5cd91a3..cfbe5b2c135 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -31,7 +31,7 @@
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
-        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
+        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework" or ".NET Core"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
         <source>Current directory = "{0}"</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index a48f6fd867d..db1eb3fb404 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -31,7 +31,7 @@
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
-        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
+        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework" or ".NET Core"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
         <source>Current directory = "{0}"</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index bf8d89e1c84..84bdcf8a6e2 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -31,7 +31,7 @@
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
-        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
+        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework" or ".NET Core"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
         <source>Current directory = "{0}"</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 572e704317d..69186dc6806 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -31,7 +31,7 @@
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
-        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
+        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework" or ".NET Core"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
         <source>Current directory = "{0}"</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index d97eee21a68..ceabdf8cb9d 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -31,7 +31,7 @@
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
-        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
+        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework" or ".NET Core"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
         <source>Current directory = "{0}"</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index c590ae60203..99b2afca4c0 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -31,7 +31,7 @@
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
-        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
+        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework" or ".NET Core"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
         <source>Current directory = "{0}"</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index e136d34da21..020e421fef4 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -31,7 +31,7 @@
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
-        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
+        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework" or ".NET Core"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
         <source>Current directory = "{0}"</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index acd8432703f..621a850ad48 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -31,7 +31,7 @@
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
-        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
+        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework" or ".NET Core"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
         <source>Current directory = "{0}"</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 8ef4d8c30d2..eecbfcf5a1f 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -31,7 +31,7 @@
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
-        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
+        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework" or ".NET Core"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
         <source>Current directory = "{0}"</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 252b68b4885..356ffc8a9fa 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -31,7 +31,7 @@
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
-        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
+        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework" or ".NET Core"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
         <source>Current directory = "{0}"</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 4ff9206f999..b002dca1974 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -31,7 +31,7 @@
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
-        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
+        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework" or ".NET Core"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
         <source>Current directory = "{0}"</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index a5ec18908f5..0ce3fc1258c 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -31,7 +31,7 @@
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
-        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
+        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework" or ".NET Core"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
         <source>Current directory = "{0}"</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 521bc7fb13b..fa2179bcf7f 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -31,7 +31,7 @@
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
-        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
+        <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework" or ".NET Core"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
         <source>Current directory = "{0}"</source>
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index b10887f23c3..4165d5fb896 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -426,7 +426,7 @@ internal static void WriteIntForHandshake(this PipeStream stream, int value)
         internal static void ReadEndOfHandshakeSignal(
             this PipeStream stream,
             bool isProvider
-#if NETCOREAPP2_1_OR_GREATER || MONO
+#if NETCOREAPP2_1_OR_GREATER
             , int timeout
 #endif
             )
@@ -436,7 +436,7 @@ bool isProvider
 #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
             int valueRead = stream.ReadIntForHandshake(
                 byteToAccept: null
-#if NETCOREAPP2_1_OR_GREATER || MONO
+#if NETCOREAPP2_1_OR_GREATER
             , timeout
 #endif
                 );
@@ -462,7 +462,7 @@ bool isProvider
         /// If specified, leading byte matches one in the supplied array if any, returns rejection byte and throws IOException.
         /// </summary>
         internal static int ReadIntForHandshake(this PipeStream stream, byte? byteToAccept
-#if NETCOREAPP2_1_OR_GREATER || MONO
+#if NETCOREAPP2_1_OR_GREATER
             , int timeout
 #endif
             )
@@ -470,7 +470,7 @@ internal static int ReadIntForHandshake(this PipeStream stream, byte? byteToAcce
         {
             byte[] bytes = new byte[4];
 
-#if NETCOREAPP2_1_OR_GREATER || MONO
+#if NETCOREAPP2_1_OR_GREATER
             if (!NativeMethodsShared.IsWindows)
             {
                 // Enforce a minimum timeout because the Windows code can pass
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 36613d4cd52..28ed7356deb 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -1697,9 +1697,6 @@ internal static bool IsMatch(ReadOnlySpan<char> input, string pattern)
             // Store the information whether the tail was checked when a pattern "*?" occurred
             bool tailChecked = false;
 
-#if MONO    // MONO doesn't support local functions
-            Func<char, char, int, int, bool> CompareIgnoreCase = (inputChar, patternChar, iIndex, pIndex) =>
-#else
             // Function for comparing two characters, ignoring case
             // PERF NOTE:
             // Having a local function instead of a variable increases the speed by approx. 2 times.
@@ -1708,7 +1705,6 @@ internal static bool IsMatch(ReadOnlySpan<char> input, string pattern)
             // when we have to compare two non ASCII characters. Using just string.Compare for
             // character comparison, would reduce the speed by approx. 5 times.
             bool CompareIgnoreCase(ref ReadOnlySpan<char> input, int iIndex, int pIndex)
-#endif
             {
                 char inputChar = input[iIndex];
                 char patternChar = pattern[pIndex];
@@ -1728,9 +1724,6 @@ bool CompareIgnoreCase(ref ReadOnlySpan<char> input, int iIndex, int pIndex)
                 }
                 return MemoryExtensions.Equals(input.Slice(iIndex, 1), pattern.AsSpan(pIndex, 1), StringComparison.OrdinalIgnoreCase);
             }
-#if MONO
-            ; // The end of the CompareIgnoreCase anonymous function
-#endif
 
             while (inputIndex < inputLength)
             {
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 3ff6eb90662..51d551eef38 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -873,12 +873,6 @@ internal static string FindDotNetFrameworkPath(
         /// </summary>
         internal static string GenerateProgramFiles32()
         {
-            // With Mono, all we look for in Files32 should be found in the below location
-            if (!NativeMethodsShared.IsWindows && NativeMethodsShared.IsMono)
-            {
-                return Path.Combine(NativeMethodsShared.FrameworkBasePath, "xbuild");
-            }
-
             // On a 64 bit machine we always want to use the program files x86.  If we are running as a 64 bit process then this variable will be set correctly
             // If we are on a 32 bit machine or running as a 32 bit process then this variable will be null and the programFiles variable will be correct.
             string programFilesX86 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86);
@@ -897,12 +891,6 @@ internal static string GenerateProgramFiles32()
         /// </summary>
         internal static string GenerateProgramFiles64()
         {
-            // With Mono, all we look for in Files32 should be found in the below location
-            if (!NativeMethodsShared.IsWindows && NativeMethodsShared.IsMono)
-            {
-                return Path.Combine(NativeMethodsShared.FrameworkBasePath, "xbuild");
-            }
-
             string programFilesX64;
             if (string.Equals(programFiles, programFiles32))
             {
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index ac7f5509236..54c11d443c5 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -33,12 +33,12 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
     {
         #region Private Data
 
-#if NETCOREAPP2_1_OR_GREATER || MONO
+#if NETCOREAPP2_1_OR_GREATER
         /// <summary>
         /// The amount of time to wait for the client to connect to the host.
         /// </summary>
         private const int ClientConnectTimeout = 60000;
-#endif // NETCOREAPP2_1 || MONO
+#endif // NETCOREAPP2_1
 
         /// <summary>
         /// The size of the buffers to use for named pipes
@@ -212,51 +212,46 @@ internal void InternalConstruct(string pipeName = null)
             pipeName ??= NamedPipeUtil.GetPlatformSpecificPipeName();
 
 #if FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR
-            if (!NativeMethodsShared.IsMono)
-            {
-                SecurityIdentifier identifier = WindowsIdentity.GetCurrent().Owner;
-                PipeSecurity security = new PipeSecurity();
-
-                // Restrict access to just this account.  We set the owner specifically here, and on the
-                // pipe client side they will check the owner against this one - they must have identical
-                // SIDs or the client will reject this server.  This is used to avoid attacks where a
-                // hacked server creates a less restricted pipe in an attempt to lure us into using it and 
-                // then sending build requests to the real pipe client (which is the MSBuild Build Manager.)
-                PipeAccessRule rule = new PipeAccessRule(identifier, PipeAccessRights.ReadWrite, AccessControlType.Allow);
-                security.AddAccessRule(rule);
-                security.SetOwner(identifier);
-
-                _pipeServer = new NamedPipeServerStream(
-                    pipeName,
-                    PipeDirection.InOut,
-                    1, // Only allow one connection at a time.
-                    PipeTransmissionMode.Byte,
-                    PipeOptions.Asynchronous | PipeOptions.WriteThrough
+            SecurityIdentifier identifier = WindowsIdentity.GetCurrent().Owner;
+            PipeSecurity security = new PipeSecurity();
+
+            // Restrict access to just this account.  We set the owner specifically here, and on the
+            // pipe client side they will check the owner against this one - they must have identical
+            // SIDs or the client will reject this server.  This is used to avoid attacks where a
+            // hacked server creates a less restricted pipe in an attempt to lure us into using it and 
+            // then sending build requests to the real pipe client (which is the MSBuild Build Manager.)
+            PipeAccessRule rule = new PipeAccessRule(identifier, PipeAccessRights.ReadWrite, AccessControlType.Allow);
+            security.AddAccessRule(rule);
+            security.SetOwner(identifier);
+
+            _pipeServer = new NamedPipeServerStream(
+                pipeName,
+                PipeDirection.InOut,
+                1, // Only allow one connection at a time.
+                PipeTransmissionMode.Byte,
+                PipeOptions.Asynchronous | PipeOptions.WriteThrough
 #if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-                    | PipeOptions.CurrentUserOnly
-#endif
-                    ,
-                    PipeBufferSize, // Default input buffer
-                    PipeBufferSize,  // Default output buffer
-                    security,
-                    HandleInheritability.None);
-            }
-            else
+                | PipeOptions.CurrentUserOnly
 #endif
-            {
-                _pipeServer = new NamedPipeServerStream(
-                    pipeName,
-                    PipeDirection.InOut,
-                    1, // Only allow one connection at a time.
-                    PipeTransmissionMode.Byte,
-                    PipeOptions.Asynchronous | PipeOptions.WriteThrough
+                ,
+                PipeBufferSize, // Default input buffer
+                PipeBufferSize,  // Default output buffer
+                security,
+                HandleInheritability.None);
+#else
+            _pipeServer = new NamedPipeServerStream(
+                pipeName,
+                PipeDirection.InOut,
+                1, // Only allow one connection at a time.
+                PipeTransmissionMode.Byte,
+                PipeOptions.Asynchronous | PipeOptions.WriteThrough
 #if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-                    | PipeOptions.CurrentUserOnly
+                | PipeOptions.CurrentUserOnly
 #endif
-                    ,
-                    PipeBufferSize, // Default input buffer
-                    PipeBufferSize);  // Default output buffer
-            }
+                ,
+                PipeBufferSize, // Default input buffer
+                PipeBufferSize);  // Default output buffer
+#endif // FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR
         }
 
         #endregion
@@ -402,7 +397,7 @@ private void PacketPumpProc()
 #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
                             int handshakePart = _pipeServer.ReadIntForHandshake(
                                 byteToAccept: i == 0 ? (byte?)CommunicationsUtilities.handshakeVersion : null /* this will disconnect a < 16.8 host; it expects leading 00 or F5 or 06. 0x00 is a wildcard */
-#if NETCOREAPP2_1_OR_GREATER || MONO
+#if NETCOREAPP2_1_OR_GREATER
                             , ClientConnectTimeout /* wait a long time for the handshake from this side */
 #endif
                             );
@@ -420,7 +415,7 @@ private void PacketPumpProc()
                         if (gotValidConnection)
                         {
                             // To ensure that our handshake and theirs have the same number of bytes, receive and send a magic number indicating EOS.
-#if NETCOREAPP2_1_OR_GREATER || MONO
+#if NETCOREAPP2_1_OR_GREATER
                             _pipeServer.ReadEndOfHandshakeSignal(false, ClientConnectTimeout); /* wait a long time for the handshake from this side */
 #else
                             _pipeServer.ReadEndOfHandshakeSignal(false);
diff --git a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
index 12ef8396ae8..a2bbfbec9fc 100644
--- a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
+++ b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
@@ -324,14 +324,10 @@ public void CompareBaseNameRealCase1()
         [Fact]
         public void CreateAssemblyNameExtensionWithNoSimpleName()
         {
-            // Mono does not throw on this string
-            if (!NativeMethodsShared.IsMono)
+            Assert.Throws<FileLoadException>(() =>
             {
-                Assert.Throws<FileLoadException>(() =>
-                {
-                    AssemblyNameExtension extension = new AssemblyNameExtension("Version=2.0.0.0, Culture=en, PublicKeyToken=b03f5f7f11d50a3a", true);
-                });
-            }
+                AssemblyNameExtension extension = new AssemblyNameExtension("Version=2.0.0.0, Culture=en, PublicKeyToken=b03f5f7f11d50a3a", true);
+            });
         }
 
         /// <summary>
@@ -340,16 +336,12 @@ public void CreateAssemblyNameExtensionWithNoSimpleName()
         [Fact]
         public void CreateAssemblyNameExtensionWithNoSimpleName2()
         {
-            // Mono does not throw on this string
-            if (!NativeMethodsShared.IsMono)
+            Assert.Throws<FileLoadException>(() =>
             {
-                Assert.Throws<FileLoadException>(() =>
-                {
-                    AssemblyNameExtension extension = new AssemblyNameExtension("Version=2.0.0.0, Culture=en, PublicKeyToken=b03f5f7f11d50a3a");
-                    AssemblyNameExtension extension2 = new AssemblyNameExtension("A, Version=2.0.0.0, Culture=en, PublicKeyToken=b03f5f7f11d50a3a");
-                    extension2.PartialNameCompare(extension);
-                });
-            }
+                AssemblyNameExtension extension = new AssemblyNameExtension("Version=2.0.0.0, Culture=en, PublicKeyToken=b03f5f7f11d50a3a");
+                AssemblyNameExtension extension2 = new AssemblyNameExtension("A, Version=2.0.0.0, Culture=en, PublicKeyToken=b03f5f7f11d50a3a");
+                extension2.PartialNameCompare(extension);
+            });
         }
 
         /// <summary>
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index 26e8d9bd848..f65d10d305b 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -322,7 +322,6 @@ public static IEnumerable<object[]> GetTestData()
                     }
                 };
 
-#if !MONO // https://github.com/mono/mono/issues/8441
                 yield return new object[]
                 {
                     new GetFilesComplexGlobbingMatchingInfo
@@ -358,7 +357,6 @@ public static IEnumerable<object[]> GetTestData()
                         ExpectNoMatches = NativeMethodsShared.IsLinux,
                     }
                 };
-#endif
 
                 yield return new object[]
                 {
diff --git a/src/StringTools.UnitTests/WeakStringCache_Tests.cs b/src/StringTools.UnitTests/WeakStringCache_Tests.cs
index 41990c59396..95c769a5fa7 100644
--- a/src/StringTools.UnitTests/WeakStringCache_Tests.cs
+++ b/src/StringTools.UnitTests/WeakStringCache_Tests.cs
@@ -120,10 +120,6 @@ private void AddStringsWithSameHashCode(int numberOfStrings)
         /// 2. The string is no longer retrievable after all strong GC refs are gone.
         /// 3. The cache completely removes the handle after calling Scavenge on it.
         /// </summary>
-        /// <remarks>
-        /// Disabled on MacOS Mono because it doesn't play well with conservative GC scanning.
-        /// https://www.mono-project.com/docs/advanced/garbage-collector/sgen/#precise-stack-marking
-        /// </remarks>
         [Fact]
         public void RetainsStringUntilCollected()
         {
@@ -161,10 +157,6 @@ public void RetainsStringUntilCollected()
         /// <summary>
         /// Same as RetainsStringUntilCollected but with multiple strings sharing the same hash code.
         /// </summary>
-        /// <remarks>
-        /// Disabled on MacOS Mono because it doesn't play well with conservative GC scanning.
-        /// https://www.mono-project.com/docs/advanced/garbage-collector/sgen/#precise-stack-marking
-        /// </remarks>
         [Fact]
         public void RetainsLastStringWithGivenHashCode()
         {
diff --git a/src/Tasks.UnitTests/AxImp_Tests.cs b/src/Tasks.UnitTests/AxImp_Tests.cs
index 932661cdbbd..52d433c32f9 100644
--- a/src/Tasks.UnitTests/AxImp_Tests.cs
+++ b/src/Tasks.UnitTests/AxImp_Tests.cs
@@ -70,7 +70,7 @@ public void GenerateSource()
         /// <summary>
         /// Tests the /nologo switch
         /// </summary>
-        [WindowsOnlyFact("The /nologo switch is not available on Mono.")]
+        [Fact]
         public void NoLogo()
         {
             var t = new ResolveComReference.AxImp();
diff --git a/src/Tasks.UnitTests/CommandLineGenerator_Tests.cs b/src/Tasks.UnitTests/CommandLineGenerator_Tests.cs
index 22c89a4872d..30f45e8d9fc 100644
--- a/src/Tasks.UnitTests/CommandLineGenerator_Tests.cs
+++ b/src/Tasks.UnitTests/CommandLineGenerator_Tests.cs
@@ -131,7 +131,6 @@ public void TemplateParametersAreCaseInsensitive()
 
         private CommandLineGenerator CreateGenerator()
         {
-#if !MONO
             Rule rule = XamlReader.Parse(testXamlFile) as Rule;
 
             Dictionary<string, Object> switchValues = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
@@ -154,9 +153,6 @@ private CommandLineGenerator CreateGenerator()
 
             CommandLineGenerator generator = new CommandLineGenerator(rule, switchValues);
             return generator;
-#else
-            return new CommandLineGenerator(new Rule(), new Dictionary<string, object>());
-#endif
         }
 
         private sealed class TaskItem : ITaskItem
diff --git a/src/Tasks.UnitTests/Exec_Tests.cs b/src/Tasks.UnitTests/Exec_Tests.cs
index cb468a6ccea..258b0a6b7df 100644
--- a/src/Tasks.UnitTests/Exec_Tests.cs
+++ b/src/Tasks.UnitTests/Exec_Tests.cs
@@ -155,16 +155,8 @@ public void TimeoutFailsEvenWhenExitCodeIsIgnored()
             // ToolTask does not log an error on timeout.
             mockEngine.Errors.ShouldBe(0);
 
-            if (NativeMethodsShared.IsMono)
-            {
-                const int STILL_ACTIVE = 259; // When Process.WaitForExit times out.
-                exec.ExitCode.ShouldBeOneOf(137, STILL_ACTIVE);
-            }
-            else
-            {
-                // On non-Windows the exit code of a killed process is 128 + SIGKILL = 137
-                exec.ExitCode.ShouldBe(NativeMethodsShared.IsWindows ? -1 : 137);
-            }
+            // On non-Windows the exit code of a killed process is 128 + SIGKILL = 137
+            exec.ExitCode.ShouldBe(NativeMethodsShared.IsWindows ? -1 : 137);
         }
 
         [UnixOnlyFact]
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
index 4172d013c78..472d732a973 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
@@ -2567,8 +2567,6 @@ public References(ITestOutputHelper output)
         }
 
         [Fact]
-        // FIXME: mono: looks for csc.exe
-        // https://github.com/dotnet/msbuild/issues/677
         public void DontLockP2PReferenceWhenResolvingSystemTypes()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -2744,8 +2742,6 @@ public class Class1
         /// absolute path).  The fix was to use Assembly.LoadFrom instead.
         /// </summary>
         [Fact]
-        // FIXME: mono: looks for csc.exe
-        // https://github.com/dotnet/msbuild/issues/677
         public void ReferencedAssemblySpecifiedUsingRelativePath()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
diff --git a/src/Tasks.UnitTests/Unzip_Tests.cs b/src/Tasks.UnitTests/Unzip_Tests.cs
index 26de13ddc87..824e0315b11 100644
--- a/src/Tasks.UnitTests/Unzip_Tests.cs
+++ b/src/Tasks.UnitTests/Unzip_Tests.cs
@@ -171,7 +171,7 @@ public void LogsErrorIfReadOnlyFileCannotBeOverwitten()
 
                 unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
 
-                _mockEngine.Log.ShouldContain($"D6DFD219DACE48F8B86EFCDF98433333.txt{(NativeMethodsShared.IsMono ? "\"" : "'")} is denied", () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain($"D6DFD219DACE48F8B86EFCDF98433333.txt' is denied", () => _mockEngine.Log);
             }
         }
 
diff --git a/src/Tasks.UnitTests/XslTransformation_Tests.cs b/src/Tasks.UnitTests/XslTransformation_Tests.cs
index 10a4e43738a..9aff7e93381 100644
--- a/src/Tasks.UnitTests/XslTransformation_Tests.cs
+++ b/src/Tasks.UnitTests/XslTransformation_Tests.cs
@@ -20,7 +20,6 @@
 
 namespace Microsoft.Build.UnitTests
 {
-#if !MONO
     /// <summary>
     /// These tests run. The temporary output folder for this test is Path.Combine(Path.GetTempPath(), DateTime.Now.Ticks.ToString())
     /// 1. When combination of (xml, xmlfile) x (xsl, xslfile).
@@ -1263,5 +1262,4 @@ private void CompileDoubleType(string outputFile)
 #endif
         #endregion
     }
-#endif
 }
diff --git a/src/Tasks/AssemblyDependency/AssemblyInformation.cs b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
index a77c9b03360..f31b8d50f4c 100644
--- a/src/Tasks/AssemblyDependency/AssemblyInformation.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
@@ -16,7 +16,7 @@
 
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-#if FEATURE_ASSEMBLYLOADCONTEXT || MONO
+#if FEATURE_ASSEMBLYLOADCONTEXT
 using System.Reflection.PortableExecutable;
 using System.Reflection.Metadata;
 #endif
@@ -43,14 +43,11 @@ internal class AssemblyInformation : DisposableBase
         private readonly string _sourceFile;
         private FrameworkName _frameworkName;
 
-#if FEATURE_ASSEMBLYLOADCONTEXT || MONO
+#if FEATURE_ASSEMBLYLOADCONTEXT
         private bool _metadataRead;
-#endif
-
-#if !FEATURE_ASSEMBLYLOADCONTEXT && !MONO
+#else
         private static string s_targetFrameworkAttribute = "System.Runtime.Versioning.TargetFrameworkAttribute";
-#endif
-#if !FEATURE_ASSEMBLYLOADCONTEXT
+
         // Borrowed from genman.
         private const int GENMAN_STRING_BUF_SIZE = 1024;
         private const int GENMAN_LOCALE_BUF_SIZE = 64;
@@ -60,7 +57,7 @@ static AssemblyInformation()
         {
             AppDomain.CurrentDomain.ReflectionOnlyAssemblyResolve += ReflectionOnlyAssemblyResolve;
         }
-#endif // FEATURE_ASSEMBLY_LOADFROM
+#endif // !FEATURE_ASSEMBLYLOADCONTEXT
 
         /// <summary>
         /// Construct an instance for a source file.
@@ -272,45 +269,7 @@ internal static bool IsWinMDFile(
         /// </summary>
         private FrameworkName GetFrameworkName()
         {
-            // Disabling use of System.Reflection in case of MONO, because
-            // Assembly.GetCustomAttributes* for an attribute which belongs
-            // to an assembly that mono cannot find, causes a crash!
-            // Instead, opt for using PEReader and friends to get that info
-#if !FEATURE_ASSEMBLYLOADCONTEXT && !MONO
-            if (!NativeMethodsShared.IsWindows)
-            {
-                if (String.Equals(Environment.GetEnvironmentVariable("MONO29679"), "1", StringComparison.OrdinalIgnoreCase))
-                {
-                    // Getting custom attributes in CoreFx contract assemblies is busted
-                    // https://bugzilla.xamarin.com/show_bug.cgi?id=29679
-                    return null;
-                }
-
-                CustomAttributeData attr = null;
-
-                foreach (CustomAttributeData a in _assembly.GetCustomAttributesData())
-                {
-                    try
-                    {
-                        if (a.AttributeType == typeof(TargetFrameworkAttribute))
-                        {
-                            attr = a;
-                            break;
-                        }
-                    }
-                    catch
-                    {
-                    }
-                }
-
-                string name = null;
-                if (attr != null)
-                {
-                    name = (string)attr.ConstructorArguments[0].Value;
-                }
-                return name == null ? null : new FrameworkName(name);
-            }
-
+#if !FEATURE_ASSEMBLYLOADCONTEXT
             FrameworkName frameworkAttribute = null;
             try
             {
@@ -343,7 +302,7 @@ private FrameworkName GetFrameworkName()
 #endif
         }
 
-#if FEATURE_ASSEMBLYLOADCONTEXT || MONO
+#if FEATURE_ASSEMBLYLOADCONTEXT
         /// <summary>
         /// Read everything from the assembly in a single stream.
         /// </summary>
@@ -480,9 +439,7 @@ private static AssemblyName GetAssemblyName(MetadataReader metadataReader, Assem
         }
 #endif
 
-        // Enabling this for MONO, because it's required by GetFrameworkName.
-        // More details are in the comment for that method
-#if FEATURE_ASSEMBLYLOADCONTEXT || MONO
+#if FEATURE_ASSEMBLYLOADCONTEXT
         // This method copied from DNX source: https://github.com/aspnet/dnx/blob/e0726f769aead073af2d8cd9db47b89e1745d574/src/Microsoft.Dnx.Tooling/Utils/LockFileUtils.cs#L385
         //  System.Reflection.Metadata 1.1 is expected to have an API that helps with this.
         /// <summary>
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index 522b4de5c81..56cb5d3a81b 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -658,23 +658,6 @@ static string GetPathFromPartialAssemblyName(string partialName)
                 {
                     candidateAssemblyLocation = candidateAssembly.Location;
                 }
-                else if (NativeMethodsShared.IsMono)
-                {
-                    string path = Path.Combine(
-                        NativeMethodsShared.FrameworkCurrentPath,
-                        "Facades",
-                        Path.GetFileName(partialName));
-                    if (!FileSystems.Default.FileExists(path))
-                    {
-                        var newPath = path + ".dll";
-                        path = !FileSystems.Default.FileExists(newPath) ? path + ".exe" : newPath;
-                    }
-                    candidateAssembly = Assembly.UnsafeLoadFrom(path);
-                    if (candidateAssembly != null)
-                    {
-                        candidateAssemblyLocation = candidateAssembly.Location;
-                    }
-                }
 #pragma warning restore 618, 612
                 return candidateAssemblyLocation;
             }
diff --git a/src/Tasks/Exec.cs b/src/Tasks/Exec.cs
index dbf4be1fc51..5a1efb3d871 100644
--- a/src/Tasks/Exec.cs
+++ b/src/Tasks/Exec.cs
@@ -250,29 +250,6 @@ private void CreateTemporaryBatchFile()
                     sw.WriteLine("#!/bin/sh");
                 }
 
-                if (NativeMethodsShared.IsUnixLike && NativeMethodsShared.IsMono)
-                {
-                    // Extract the command we are going to run. Note that the command name may
-                    // be preceded by whitespace
-                    var m = Regex.Match(Command, @"^\s*((?:(?:(?<!\\)[^\0 !$`&*()+])|(?:(?<=\\)[^\0]))+)(.*)");
-                    if (m.Success && m.Groups.Count > 1 && m.Groups[1].Captures.Count > 0)
-                    {
-                        string exe = m.Groups[1].Captures[0].ToString();
-                        string commandLine = (m.Groups.Count > 2 && m.Groups[2].Captures.Count > 0) ?
-                            m.Groups[2].Captures[0].Value : "";
-
-
-                        // If we are trying to run a .exe file, prepend mono as the file may
-                        // not be runnable
-                        if (exe.EndsWith(".exe", StringComparison.OrdinalIgnoreCase)
-                            || exe.EndsWith(".exe\"", StringComparison.OrdinalIgnoreCase)
-                            || exe.EndsWith(".exe'", StringComparison.OrdinalIgnoreCase))
-                        {
-                            Command = "mono " + FileUtilities.FixFilePath(exe) + commandLine;
-                        }
-                    }
-                }
-
                 sw.WriteLine(Command);
 
                 if (!NativeMethodsShared.IsUnixLike)
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
index 43dd3c3ed10..db8765e8e01 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
@@ -80,12 +80,6 @@ public sealed class RoslynCodeTaskFactory : ITaskFactory
         /// </summary>
         private const string ReferenceAssemblyDirectoryName = "ref";
 
-
-        /// <summary>
-        /// Array of mono lib directories used to resolve references
-        /// </summary>
-        private static readonly string[] MonoLibDirs = GetMonoLibDirs();
-
         /// <summary>
         /// A cache of <see cref="RoslynCodeTaskFactoryTaskInfo"/> objects and their corresponding compiled assembly.  This cache ensures that two of the exact same code task
         /// declarations are not compiled multiple times.
@@ -567,7 +561,6 @@ internal bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynCodeTask
                     Path.Combine(ThisAssemblyDirectoryLazy.Value, ReferenceAssemblyDirectoryName),
                     ThisAssemblyDirectoryLazy.Value,
                 }
-                .Concat(MonoLibDirs)
                 .FirstOrDefault(p => File.Exists(Path.Combine(p, assemblyFileName)));
 
                 if (resolvedDir != null)
@@ -782,20 +775,5 @@ private bool TryCompileInMemoryAssembly(IBuildEngine buildEngine, RoslynCodeTask
                 }
             }
         }
-
-        private static string[] GetMonoLibDirs()
-        {
-            if (NativeMethodsShared.IsMono)
-            {
-                string monoLibDir = Path.GetDirectoryName(typeof(object).Assembly.Location);
-                string monoLibFacadesDir = Path.Combine(monoLibDir, "Facades");
-
-                return new[] { monoLibDir, monoLibFacadesDir };
-            }
-            else
-            {
-                return Array.Empty<string>();
-            }
-        }
     }
 }
diff --git a/src/Tasks/TlbReference.cs b/src/Tasks/TlbReference.cs
index 12a00027180..b402f317ad9 100644
--- a/src/Tasks/TlbReference.cs
+++ b/src/Tasks/TlbReference.cs
@@ -254,11 +254,9 @@ internal bool GenerateWrapper(out ComReferenceWrapperInfo wrapperInfo)
                         case UtilitiesProcessorArchitecture.X86:
                             flags |= TypeLibImporterFlags.ImportAsX86;
                             break;
-#if !MONO
                         case UtilitiesProcessorArchitecture.ARM:
                             flags |= TypeLibImporterFlags.ImportAsArm;
                             break;
-#endif
                         default:
                             // Let the type importer decide.
                             break;
diff --git a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
index bb98a4a196f..96055a44d10 100644
--- a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
+++ b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
@@ -2683,17 +2683,8 @@ private void CheckGetPathToReferenceAssemblies(TestEnvironment env, string custo
             string asmPath = CreateNewFrameworkAndGetAssembliesPath(env, frameworkName, frameworkVersionWithV, customFrameworkDir);
 
             var stdLibPaths = getPathToReferenceAssemblies(frameworkName, frameworkVersion, frameworkProfile, customFrameworkDir, fallbackSearchPaths);
-            if (NativeMethodsShared.IsMono)
-            {
-                stdLibPaths.Count.ShouldBe(2);
-                stdLibPaths[0].ShouldBe(Path.Combine(customFrameworkDir, frameworkName, frameworkVersionWithV) + Path.DirectorySeparatorChar, stdLibPaths[0]);
-                stdLibPaths[1].ShouldBe(asmPath + Path.DirectorySeparatorChar);
-            }
-            else
-            {
-                stdLibPaths.Count.ShouldBe(1);
-                stdLibPaths[0].ShouldBe(Path.Combine(customFrameworkDir, frameworkName, frameworkVersionWithV) + Path.DirectorySeparatorChar, stdLibPaths[0]);
-            }
+            stdLibPaths.Count.ShouldBe(1);
+            stdLibPaths[0].ShouldBe(Path.Combine(customFrameworkDir, frameworkName, frameworkVersionWithV) + Path.DirectorySeparatorChar, stdLibPaths[0]);
         }
 
         [Fact]
@@ -2726,22 +2717,11 @@ public void GetPathToReferenceAssembliesWithNullTargetFrameworkFallbackSearchPat
 
         private static string CreateNewFrameworkAndGetAssembliesPath(TestEnvironment env, string frameworkName, string frameworkVersion, string rootDir)
         {
-            string frameworkListXml;
-            if (NativeMethodsShared.IsMono)
-            {
-                // Mono uses an extra attribute to point to the location of the corresponding
-                // assemblies
-                frameworkListXml = @"<?xml version=""1.0"" encoding=""utf-8""?>
-                    <FileList  Name=""{0}"" TargetFrameworkDirectory=""..\assemblies"" />";
-            }
-            else
-            {
-                frameworkListXml = @"<?xml version=""1.0"" encoding=""utf-8""?>
+            string frameworkListXml = @"<?xml version=""1.0"" encoding=""utf-8""?>
                     <FileList  Name=""{0}""/>";
-            }
 
             string redistPath = Path.Combine(rootDir, frameworkName, frameworkVersion, "RedistList");
-            string asmPath = Path.Combine(rootDir, frameworkName, frameworkVersion, NativeMethodsShared.IsMono ? "assemblies" : string.Empty);
+            string asmPath = Path.Combine(rootDir, frameworkName, frameworkVersion);
 
             env.CreateFolder(redistPath);
             env.CreateFolder(asmPath);
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 0f344499164..6efc4fbbd3b 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -2346,15 +2346,6 @@ private static IList<string> GetPathAndChainReferenceAssemblyLocations(string ta
                                 break;
                             }
                             referencePaths.Add(path);
-                            if (NativeMethodsShared.IsMono)
-                            {
-                                // On Mono, some directories contain Facades subdirectory with valid assemblies
-                                var facades = Path.Combine(path, "Facades");
-                                if (FileSystems.Default.DirectoryExists(Path.Combine(path, "Facades")))
-                                {
-                                    referencePaths.Add(facades);
-                                }
-                            }
                         }
                         else if (path == null)
                         {
@@ -3121,15 +3112,13 @@ internal static string ChainReferenceAssemblyPath(string targetFrameworkDirector
             // If the redist list does not exist then the entire chain is incorrect.
             if (!FileSystems.Default.FileExists(redistFile))
             {
-                // Under MONO a directory may chain to one that has no redist list
-                var chainReference = NativeMethodsShared.IsMono ? string.Empty : null;
                 lock (s_locker)
                 {
-                    s_chainedReferenceAssemblyPath[path] = chainReference;
-                    s_cachedTargetFrameworkDisplayNames[path] = chainReference;
+                    s_chainedReferenceAssemblyPath[path] = null;
+                    s_cachedTargetFrameworkDisplayNames[path] = null;
                 }
 
-                return chainReference;
+                return null;
             }
 
             string includeFramework = null;
@@ -3164,13 +3153,6 @@ internal static string ChainReferenceAssemblyPath(string targetFrameworkDirector
                                         displayName = reader.Value;
                                         continue;
                                     }
-
-                                    // Mono may redirect this to another place
-                                    if (NativeMethodsShared.IsMono && string.Equals(reader.Name, "TargetFrameworkDirectory", StringComparison.OrdinalIgnoreCase))
-                                    {
-                                        // The new folder is relative to the place where the FrameworkList.
-                                        redirectPath = Path.GetFullPath(Path.Combine(redistListFolder, FileUtilities.FixFilePath(reader.Value)));
-                                    }
                                 }
                                 while (reader.MoveToNextAttribute());
                                 reader.MoveToElement();
