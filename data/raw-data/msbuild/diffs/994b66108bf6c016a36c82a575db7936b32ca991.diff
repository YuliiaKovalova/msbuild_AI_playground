diff --git a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
index 5a1eb10715b..85d8d866984 100644
--- a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
@@ -173,11 +173,11 @@ public void ConstructionWithValidHost()
         {
             NodeEndpointInProc.EndpointPair endpoints =
                 NodeEndpointInProc.CreateInProcEndpoints(
-                    NodeEndpointInProc.EndpointMode.Synchronous, _host);
+                    NodeEndpointInProc.EndpointMode.Synchronous, _host, 1);
 
             endpoints =
                 NodeEndpointInProc.CreateInProcEndpoints(
-                    NodeEndpointInProc.EndpointMode.Asynchronous, _host);
+                    NodeEndpointInProc.EndpointMode.Asynchronous, _host, 1);
         }
 
         [Fact]
@@ -186,7 +186,7 @@ public void ConstructionSynchronousWithInvalidHost()
             Assert.Throws<ArgumentNullException>(() =>
             {
                 NodeEndpointInProc.CreateInProcEndpoints(
-                    NodeEndpointInProc.EndpointMode.Synchronous, null);
+                    NodeEndpointInProc.EndpointMode.Synchronous, null, 1);
             });
         }
 
@@ -196,7 +196,7 @@ public void ConstructionAsynchronousWithInvalidHost()
             Assert.Throws<ArgumentNullException>(() =>
             {
                 NodeEndpointInProc.CreateInProcEndpoints(
-                    NodeEndpointInProc.EndpointMode.Asynchronous, null);
+                    NodeEndpointInProc.EndpointMode.Asynchronous, null, 1);
             });
         }
         /// <summary>
@@ -210,7 +210,7 @@ public void InactiveLinkTestSynchronous()
         {
             NodeEndpointInProc.EndpointPair endpoints =
                 NodeEndpointInProc.CreateInProcEndpoints(
-                    NodeEndpointInProc.EndpointMode.Synchronous, _host);
+                    NodeEndpointInProc.EndpointMode.Synchronous, _host, 1);
 
             CallOpOnEndpoints(endpoints, VerifyLinkInactive);
             CallOpOnEndpoints(endpoints, VerifySendDataInvalidOperation);
@@ -230,7 +230,7 @@ public void InactiveLinkTestAsynchronous()
         {
             NodeEndpointInProc.EndpointPair endpoints =
                 NodeEndpointInProc.CreateInProcEndpoints(
-                    NodeEndpointInProc.EndpointMode.Asynchronous, _host);
+                    NodeEndpointInProc.EndpointMode.Asynchronous, _host, 1);
 
             CallOpOnEndpoints(endpoints, VerifyLinkInactive);
             CallOpOnEndpoints(endpoints, VerifySendDataInvalidOperation);
@@ -248,7 +248,7 @@ public void ConnectionTestSynchronous()
         {
             NodeEndpointInProc.EndpointPair endpoints =
                 NodeEndpointInProc.CreateInProcEndpoints(
-                    NodeEndpointInProc.EndpointMode.Synchronous, _host);
+                    NodeEndpointInProc.EndpointMode.Synchronous, _host, 1);
 
             endpoints.ManagerEndpoint.OnLinkStatusChanged += LinkStatusChanged;
             endpoints.NodeEndpoint.OnLinkStatusChanged += LinkStatusChanged;
@@ -288,7 +288,7 @@ public void SynchronousData()
             // Create the endpoints
             NodeEndpointInProc.EndpointPair endpoints =
                 NodeEndpointInProc.CreateInProcEndpoints(
-                    NodeEndpointInProc.EndpointMode.Synchronous, _host);
+                    NodeEndpointInProc.EndpointMode.Synchronous, _host, 1);
 
             // Connect the endpoints
             endpoints.ManagerEndpoint.Listen(_host);
@@ -317,7 +317,7 @@ public void AsynchronousData()
             // Create the endpoints
             NodeEndpointInProc.EndpointPair endpoints =
                 NodeEndpointInProc.CreateInProcEndpoints(
-                    NodeEndpointInProc.EndpointMode.Asynchronous, _host);
+                    NodeEndpointInProc.EndpointMode.Asynchronous, _host, 1);
 
             // Connect the endpoints
             endpoints.ManagerEndpoint.Listen(_host);
@@ -422,7 +422,7 @@ private void VerifyLinksAndCallbacksInactive(NodeEndpointInProc.EndpointPair end
         private NodeEndpointInProc.EndpointPair SetupConnection(NodeEndpointInProc.EndpointMode mode)
         {
             NodeEndpointInProc.EndpointPair endpoints =
-                NodeEndpointInProc.CreateInProcEndpoints(mode, _host);
+                NodeEndpointInProc.CreateInProcEndpoints(mode, _host, 1);
 
             endpoints.ManagerEndpoint.OnLinkStatusChanged += LinkStatusChanged;
             endpoints.NodeEndpoint.OnLinkStatusChanged += LinkStatusChanged;
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 6a60fd9ac0c..39779cb3f7c 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -289,6 +289,7 @@ internal BuildParameters(BuildParameters other, bool resetEnvironment = false)
             HostServices = other.HostServices;
             _loggers = other._loggers != null ? new List<ILogger>(other._loggers) : null;
             _maxNodeCount = other._maxNodeCount;
+            MultiThreaded = other.MultiThreaded;
             _memoryUseLimit = other._memoryUseLimit;
             _nodeExeLocation = other._nodeExeLocation;
             NodeId = other.NodeId;
@@ -534,6 +535,11 @@ public int MaxNodeCount
             }
         }
 
+        /// <summary>
+        /// Enables running build in multiple in-proc nodes.
+        /// </summary>
+        public bool MultiThreaded { get; set; }
+
         /// <summary>
         /// The amount of memory the build should limit itself to using, in megabytes.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index aa90f8d1277..7ca692e6c94 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -361,7 +361,7 @@ public void SubmitBuildRequest(BuildRequest request)
                         // On the other hand, if this is not the inproc node, we want to make sure that our copy of this configuration
                         // knows that its results are no longer on this node.  Since we don't know enough here to know where the
                         // results are going, we satisfy ourselves with marking that they are simply "not here".
-                        if (_componentHost.BuildParameters.NodeId != Scheduler.InProcNodeId)
+                        if (!_componentHost.BuildParameters.MultiThreaded && _componentHost.BuildParameters.NodeId != Scheduler.InProcNodeId)
                         {
                             config.ResultsNodeId = Scheduler.ResultsTransferredId;
                         }
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
index 6fdad8b8128..78aadd6d67c 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
@@ -91,6 +91,9 @@ internal class NodeEndpointInProc : INodeEndpoint
         /// Use a lock on the packetQueue itself.
         /// </remarks>
         private ConcurrentQueue<INodePacket> _packetQueue;
+
+        private readonly int _nodeId;
+
         #endregion
 
         #region Constructors and Factories
@@ -99,13 +102,15 @@ internal class NodeEndpointInProc : INodeEndpoint
         /// </summary>
         /// <param name="commMode">The communications mode for this endpoint.</param>
         /// <param name="host">The component host.</param>
-        private NodeEndpointInProc(EndpointMode commMode, IBuildComponentHost host)
+        /// <param name="nodeId">The node id.</param>
+        private NodeEndpointInProc(EndpointMode commMode, IBuildComponentHost host, int nodeId)
         {
             ErrorUtilities.VerifyThrowArgumentNull(host);
 
             _status = LinkStatus.Inactive;
             _mode = commMode;
             _componentHost = host;
+            _nodeId = nodeId;
 
             if (commMode == EndpointMode.Asynchronous)
             {
@@ -214,7 +219,7 @@ public void SendData(INodePacket packet)
 
             if (_mode == EndpointMode.Synchronous)
             {
-                _peerEndpoint._packetFactory.RoutePacket(0, packet);
+                _peerEndpoint._packetFactory.RoutePacket(_nodeId, packet);
             }
             else
             {
@@ -236,11 +241,12 @@ public void ClientWillDisconnect()
         /// </summary>
         /// <param name="mode">The communications mode for the endpoints.</param>
         /// <param name="host">The component host.</param>
+        /// <param name="nodeId">The node id.</param>
         /// <returns>A matched pair of endpoints.</returns>
-        internal static EndpointPair CreateInProcEndpoints(EndpointMode mode, IBuildComponentHost host)
+        internal static EndpointPair CreateInProcEndpoints(EndpointMode mode, IBuildComponentHost host, int nodeId)
         {
-            NodeEndpointInProc node = new NodeEndpointInProc(mode, host);
-            NodeEndpointInProc manager = new NodeEndpointInProc(mode, host);
+            NodeEndpointInProc node = new NodeEndpointInProc(mode, host, nodeId);
+            NodeEndpointInProc manager = new NodeEndpointInProc(mode, host, nodeId);
 
             // NOTE: This creates a circular reference which must be explicitly broken before these
             // objects can be reclaimed by the garbage collector.
@@ -436,7 +442,7 @@ private void PacketPumpProc()
                                 INodePacket packet;
                                 while (_packetQueue.TryDequeue(out packet))
                                 {
-                                    _peerEndpoint._packetFactory.RoutePacket(0, packet);
+                                    _peerEndpoint._packetFactory.RoutePacket(_nodeId, packet);
                                 }
                             }
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeManager.cs b/src/Build/BackEnd/Components/Communications/NodeManager.cs
index b0031746031..2fc4147f607 100644
--- a/src/Build/BackEnd/Components/Communications/NodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeManager.cs
@@ -318,7 +318,7 @@ private IList<NodeInfo> AttemptCreateNode(INodeProvider nodeProvider, NodeConfig
 
             // Assign a global ID to the node we are about to create.
             int fromNodeId;
-            if (nodeProvider is NodeProviderInProc)
+            if (nodeProvider is NodeProviderInProc && _componentHost is not null && !_componentHost.BuildParameters.MultiThreaded)
             {
                 fromNodeId = _inprocNodeId;
             }
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
index 15c815fb9cf..7a819c9e65b 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
@@ -23,12 +23,40 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     internal class NodeProviderInProc : INodeProvider, INodePacketFactory, IDisposable
     {
+        internal sealed class NodeContext
+        {
+            /// <summary>
+            /// The in-proc node.
+            /// </summary>
+            public INode _inProcNode;
+
+            /// <summary>
+            /// The in-proc node endpoint.
+            /// </summary>
+            public INodeEndpoint _inProcNodeEndpoint;
+
+            /// <summary>
+            /// The packet factory used to route packets from the node.
+            /// </summary>
+            public INodePacketFactory _packetFactory;
+
+            /// <summary>
+            /// The in-proc node thread.
+            /// </summary>
+            public Thread _inProcNodeThread;
+
+            /// <summary>
+            /// Event which is raised when the in-proc endpoint is connected.
+            /// </summary>
+            public AutoResetEvent _endpointConnectedEvent = new AutoResetEvent(false);
+        }
+
         #region Private Data
 
         /// <summary>
-        /// The invalid in-proc node id
+        /// A mapping of all the nodes managed by this provider.
         /// </summary>
-        private const int InvalidInProcNodeId = 0;
+        private Dictionary<int, NodeContext> _nodeContexts;
 
         /// <summary>
         /// Flag indicating we have disposed.
@@ -45,36 +73,6 @@ internal class NodeProviderInProc : INodeProvider, INodePacketFactory, IDisposab
         /// </summary>
         private IBuildComponentHost _componentHost;
 
-        /// <summary>
-        /// The in-proc node.
-        /// </summary>
-        private INode _inProcNode;
-
-        /// <summary>
-        /// The in-proc node endpoint.
-        /// </summary>
-        private INodeEndpoint _inProcNodeEndpoint;
-
-        /// <summary>
-        /// The packet factory used to route packets from the node.
-        /// </summary>
-        private INodePacketFactory _packetFactory;
-
-        /// <summary>
-        /// The in-proc node thread.
-        /// </summary>
-        private Thread _inProcNodeThread;
-
-        /// <summary>
-        /// Event which is raised when the in-proc endpoint is connected.
-        /// </summary>
-        private AutoResetEvent _endpointConnectedEvent;
-
-        /// <summary>
-        /// The ID of the in-proc node.
-        /// </summary>
-        private int _inProcNodeId = InvalidInProcNodeId;
-
         /// <summary>
         /// Check to allow the inproc node to have exclusive ownership of the operating environment
         /// </summary>
@@ -88,7 +86,6 @@ internal class NodeProviderInProc : INodeProvider, INodePacketFactory, IDisposab
         /// </summary>
         public NodeProviderInProc()
         {
-            _endpointConnectedEvent = new AutoResetEvent(false);
         }
 
         #endregion
@@ -116,12 +113,11 @@ public int AvailableNodes
         {
             get
             {
-                if (_inProcNodeId != InvalidInProcNodeId)
+                lock (_nodeContexts)
                 {
-                    return 0;
+                    int maxNodeCount = _componentHost.BuildParameters.MultiThreaded ? _componentHost.BuildParameters.MaxNodeCount : 1;
+                    return maxNodeCount - _nodeContexts.Count;
                 }
-
-                return 1;
             }
         }
 
@@ -134,6 +130,7 @@ public int AvailableNodes
         public void InitializeComponent(IBuildComponentHost host)
         {
             _componentHost = host;
+            _nodeContexts = new Dictionary<int, NodeContext>();
         }
 
         /// <summary>
@@ -141,8 +138,6 @@ public void InitializeComponent(IBuildComponentHost host)
         /// </summary>
         public void ShutdownComponent()
         {
-            _componentHost = null;
-            _inProcNode = null;
         }
 
         #endregion
@@ -156,15 +151,15 @@ public void ShutdownComponent()
         /// <param name="packet">The data to send.</param>
         public void SendData(int nodeId, INodePacket packet)
         {
-            ErrorUtilities.VerifyThrowArgumentOutOfRange(nodeId == _inProcNodeId, "node");
             ErrorUtilities.VerifyThrowArgumentNull(packet);
 
-            if (_inProcNode == null)
+            lock (_nodeContexts)
             {
-                return;
+                if (_nodeContexts.TryGetValue(nodeId, out NodeContext nodeContext))
+                {
+                    nodeContext._inProcNodeEndpoint.SendData(packet);
+                }
             }
-
-            _inProcNodeEndpoint.SendData(packet);
         }
 
         /// <summary>
@@ -173,9 +168,12 @@ public void SendData(int nodeId, INodePacket packet)
         /// <param name="enableReuse">Flag indicating if the nodes should prepare for reuse.</param>
         public void ShutdownConnectedNodes(bool enableReuse)
         {
-            if (_inProcNode != null)
+            lock (_nodeContexts)
             {
-                _inProcNodeEndpoint.SendData(new NodeBuildComplete(enableReuse));
+                foreach (NodeContext nodeContext in _nodeContexts.Values)
+                {
+                    nodeContext._inProcNodeEndpoint.SendData(new NodeBuildComplete(enableReuse));
+                }
             }
         }
 
@@ -217,8 +215,6 @@ public IList<NodeInfo> CreateNodes(int nextNodeId, INodePacketFactory factory, F
         /// <param name="configuration">The configuration for the node.</param>
         private bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration configuration)
         {
-            ErrorUtilities.VerifyThrow(nodeId != InvalidInProcNodeId, "Cannot create in-proc node.");
-
             // Attempt to get the operating environment semaphore if requested.
             if (_componentHost.BuildParameters.SaveOperatingEnvironment)
             {
@@ -245,17 +241,25 @@ private bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguratio
                 }
             }
 
+            bool nodeExists;
+            lock (_nodeContexts)
+            {
+                nodeExists = _nodeContexts.ContainsKey(nodeId);
+            }
+
             // If it doesn't already exist, create it.
-            if (_inProcNode == null)
+            if (!nodeExists)
             {
-                if (!InstantiateNode(factory))
+                if (!InstantiateNode(nodeId, factory))
                 {
                     return false;
                 }
             }
 
-            _inProcNodeEndpoint.SendData(configuration);
-            _inProcNodeId = nodeId;
+            lock (_nodeContexts)
+            {
+                _nodeContexts[nodeId]._inProcNodeEndpoint.SendData(configuration);
+            }
 
             return true;
         }
@@ -298,18 +302,20 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
         /// <param name="packet">The packet to route.</param>
         public void RoutePacket(int nodeId, INodePacket packet)
         {
-            INodePacketFactory factory = _packetFactory;
-
-            if (_inProcNodeId != InvalidInProcNodeId)
+            lock (_nodeContexts)
             {
+                if (!_nodeContexts.TryGetValue(nodeId, out NodeContext nodeContext))
+                {
+                    return;
+                }
+
+                INodePacketFactory factory = nodeContext._packetFactory;
+
                 // If this was a shutdown packet, we are done with the node.  Release all context associated with it.  Do this here, rather
                 // than after we route the packet, because otherwise callbacks to the NodeManager to determine if we have available nodes
                 // will report that the in-proc node is still in use when it has actually shut down.
-                int savedInProcNodeId = _inProcNodeId;
                 if (packet.Type == NodePacketType.NodeShutdown)
                 {
-                    _inProcNodeId = InvalidInProcNodeId;
-
                     // Release the operating environment semaphore if we were holding it.
                     if ((_componentHost.BuildParameters.SaveOperatingEnvironment) &&
                         (InProcNodeOwningOperatingEnvironment != null))
@@ -321,15 +327,12 @@ public void RoutePacket(int nodeId, INodePacket packet)
 
                     if (!_componentHost.BuildParameters.EnableNodeReuse)
                     {
-                        _inProcNode = null;
-                        _inProcNodeEndpoint = null;
-                        _inProcNodeThread = null;
-                        _packetFactory = null;
+                        _nodeContexts.Remove(nodeId);
                     }
                 }
 
                 // Route the packet back to the NodeManager.
-                factory.RoutePacket(savedInProcNodeId, packet);
+                factory.RoutePacket(nodeId, packet);
             }
         }
 
@@ -358,42 +361,47 @@ internal static IBuildComponent CreateComponent(BuildComponentType type)
         /// <summary>
         /// Creates a new in-proc node.
         /// </summary>
-        private bool InstantiateNode(INodePacketFactory factory)
+        private bool InstantiateNode(int nodeId, INodePacketFactory factory)
         {
-            ErrorUtilities.VerifyThrow(_inProcNode == null, "In Proc node already instantiated.");
-            ErrorUtilities.VerifyThrow(_inProcNodeEndpoint == null, "In Proc node endpoint already instantiated.");
+            ErrorUtilities.VerifyThrow(!_nodeContexts.ContainsKey(nodeId), "In Proc node already instantiated.");
+
+            NodeEndpointInProc.EndpointPair endpoints = NodeEndpointInProc.CreateInProcEndpoints(NodeEndpointInProc.EndpointMode.Synchronous, _componentHost, nodeId);
 
-            NodeEndpointInProc.EndpointPair endpoints = NodeEndpointInProc.CreateInProcEndpoints(NodeEndpointInProc.EndpointMode.Synchronous, _componentHost);
+            NodeContext nodeContext = new();
+            lock (_nodeContexts)
+            {
+                _nodeContexts[nodeId] = nodeContext;
+            }
 
-            _inProcNodeEndpoint = endpoints.ManagerEndpoint;
-            _inProcNodeEndpoint.OnLinkStatusChanged += new LinkStatusChangedDelegate(InProcNodeEndpoint_OnLinkStatusChanged);
+            nodeContext._inProcNodeEndpoint = endpoints.ManagerEndpoint;
+            nodeContext._inProcNodeEndpoint.OnLinkStatusChanged += new LinkStatusChangedDelegate(InProcNodeEndpoint_OnLinkStatusChanged);
 
-            _packetFactory = factory;
-            _inProcNode = new InProcNode(_componentHost, endpoints.NodeEndpoint);
+            nodeContext._packetFactory = factory;
+            nodeContext._inProcNode = new InProcNode(_componentHost, endpoints.NodeEndpoint, nodeId);
 #if FEATURE_THREAD_CULTURE
-            _inProcNodeThread = new Thread(InProcNodeThreadProc, BuildParameters.ThreadStackSize);
+            nodeContext._inProcNodeThread = new Thread(() => InProcNodeThreadProc(nodeId, nodeContext._inProcNode), BuildParameters.ThreadStackSize);
 #else
             CultureInfo culture = _componentHost.BuildParameters.Culture;
             CultureInfo uiCulture = _componentHost.BuildParameters.UICulture;
-            _inProcNodeThread = new Thread(() =>
+            nodeContext._inProcNodeThread = new Thread(() =>
             {
                 CultureInfo.CurrentCulture = culture;
                 CultureInfo.CurrentUICulture = uiCulture;
-                InProcNodeThreadProc();
+                InProcNodeThreadProc(nodeId, nodeContext._inProcNode);
             });
 #endif
-            _inProcNodeThread.Name = String.Format(CultureInfo.CurrentCulture, "In-proc Node ({0})", _componentHost.Name);
-            _inProcNodeThread.IsBackground = true;
+            nodeContext._inProcNodeThread.Name = String.Format(CultureInfo.CurrentCulture, "In-proc Node ({0})", _componentHost.Name);
+            nodeContext._inProcNodeThread.IsBackground = true;
 #if FEATURE_THREAD_CULTURE
-            _inProcNodeThread.CurrentCulture = _componentHost.BuildParameters.Culture;
-            _inProcNodeThread.CurrentUICulture = _componentHost.BuildParameters.UICulture;
+            nodeContext._inProcNodeThread.CurrentCulture = _componentHost.BuildParameters.Culture;
+            nodeContext._inProcNodeThread.CurrentUICulture = _componentHost.BuildParameters.UICulture;
 #endif
-            _inProcNodeThread.Start();
+            nodeContext._inProcNodeThread.Start();
 
-            _inProcNodeEndpoint.Connect(this);
+            nodeContext._inProcNodeEndpoint.Connect(this);
 
             int connectionTimeout = CommunicationsUtilities.NodeConnectionTimeout;
-            bool connected = _endpointConnectedEvent.WaitOne(connectionTimeout);
+            bool connected = nodeContext._endpointConnectedEvent.WaitOne(connectionTimeout);
             ErrorUtilities.VerifyThrow(connected, "In-proc node failed to start up within {0}ms", connectionTimeout);
             return true;
         }
@@ -401,10 +409,10 @@ private bool InstantiateNode(INodePacketFactory factory)
         /// <summary>
         /// Thread proc which runs the in-proc node.
         /// </summary>
-        private void InProcNodeThreadProc()
+        private void InProcNodeThreadProc(int nodeId, INode inProcNode)
         {
             Exception e;
-            NodeEngineShutdownReason reason = _inProcNode.Run(out e);
+            NodeEngineShutdownReason reason = inProcNode.Run(out e);
             InProcNodeShutdown(reason, e);
         }
 
@@ -417,10 +425,25 @@ private void InProcNodeEndpoint_OnLinkStatusChanged(INodeEndpoint endpoint, Link
         {
             if (status == LinkStatus.Active)
             {
-                // We don't verify this outside of the 'if' because we don't care about the link going down, which will occur
-                // after we have cleared the inProcNodeEndpoint due to shutting down the node.
-                ErrorUtilities.VerifyThrow(endpoint == _inProcNodeEndpoint, "Received link status event for a node other than our peer.");
-                _endpointConnectedEvent.Set();
+                bool foundEndpoint = false;
+                lock (_nodeContexts)
+                {
+                    foreach (NodeContext nodeContext in _nodeContexts.Values)
+                    {
+                        if (endpoint == nodeContext._inProcNodeEndpoint)
+                        {
+                            nodeContext._endpointConnectedEvent.Set();
+                            foundEndpoint = true;
+                        }
+                    }
+                }
+
+                if (!foundEndpoint)
+                {
+                    // We don't verify this outside of the 'if' because we don't care about the link going down, which will occur
+                    // after we have cleared the inProcNodeEndpoint due to shutting down the node.
+                    ErrorUtilities.VerifyThrow(foundEndpoint, "Received link status event for a node other than our peer.");
+                }
             }
         }
 
@@ -453,10 +476,13 @@ private void Dispose(bool disposing)
             {
                 if (disposing)
                 {
-                    if (_endpointConnectedEvent != null)
+                    foreach (NodeContext nodeContext in _nodeContexts.Values)
                     {
-                        _endpointConnectedEvent.Dispose();
-                        _endpointConnectedEvent = null;
+                        if (nodeContext._endpointConnectedEvent != null)
+                        {
+                            nodeContext._endpointConnectedEvent.Dispose();
+                            nodeContext._endpointConnectedEvent = null;
+                        }
                     }
                 }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index c45130602a1..20b71664e03 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -175,6 +175,10 @@ public async Task<WorkUnitResult> ExecuteTask(TargetLoggingContext loggingContex
 
             _targetLoggingContext = loggingContext;
 
+            // Fingers crossed
+            NativeMethodsShared.SetCurrentDirectory(requestEntry.ProjectRootDirectory);
+            NativeMethodsShared.CurrentThreadWorkingDirectory = requestEntry.ProjectRootDirectory;
+
             WorkUnitResult taskResult = new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, null);
             if ((mode & TaskExecutionMode.InferOutputsOnly) == TaskExecutionMode.InferOutputsOnly)
             {
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index e6c7331f93d..935c2eca520 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -1473,8 +1473,11 @@ private bool CanScheduleRequestToNode(SchedulableRequest request, int nodeId)
         /// </summary>
         private bool CreateNewNodeIfPossible(List<ScheduleResponse> responses, IEnumerable<SchedulableRequest> requests)
         {
-            int availableNodesWithInProcAffinity = 1 - _currentInProcNodeCount;
-            int availableNodesWithOutOfProcAffinity = _componentHost.BuildParameters.MaxNodeCount - _currentOutOfProcNodeCount;
+            // We allow up to MaxNodeCount in-proc nodes when running multi-threaded.
+            int maxInProcNodeCount = _componentHost.BuildParameters.MultiThreaded ? _componentHost.BuildParameters.MaxNodeCount : 1;
+
+            int availableNodesWithInProcAffinity = maxInProcNodeCount - _currentInProcNodeCount;
+            int availableNodesWithOutOfProcAffinity = _componentHost.BuildParameters.MultiThreaded ? 0 : _componentHost.BuildParameters.MaxNodeCount - _currentOutOfProcNodeCount;
             int requestsWithOutOfProcAffinity = 0;
             int requestsWithAnyAffinityOnInProcNodes = 0;
 
@@ -1555,7 +1558,6 @@ private bool CreateNewNodeIfPossible(List<ScheduleResponse> responses, IEnumerab
                 // If we still want to create one, go ahead
                 if (inProcNodesToCreate > 0)
                 {
-                    ErrorUtilities.VerifyThrow(inProcNodesToCreate == 1, "We should never be trying to create more than one inproc node");
                     TraceScheduler("Requesting creation of new node satisfying affinity {0}", NodeAffinity.InProc);
                     responses.Add(ScheduleResponse.CreateNewNodeResponse(NodeAffinity.InProc, 1));
 
diff --git a/src/Build/BackEnd/Node/InProcNode.cs b/src/Build/BackEnd/Node/InProcNode.cs
index 7b4049f8905..cb9ccc38eef 100644
--- a/src/Build/BackEnd/Node/InProcNode.cs
+++ b/src/Build/BackEnd/Node/InProcNode.cs
@@ -103,10 +103,15 @@ internal class InProcNode : INode, INodePacketFactory
         /// </summary>
         private readonly ResourceRequestDelegate _resourceRequestHandler;
 
+        /// <summary>
+        /// The ID of this node.
+        /// </summary>
+        private readonly int _nodeId;
+
         /// <summary>
         /// Constructor.
         /// </summary>
-        public InProcNode(IBuildComponentHost componentHost, INodeEndpoint inProcNodeEndpoint)
+        public InProcNode(IBuildComponentHost componentHost, INodeEndpoint inProcNodeEndpoint, int nodeId)
         {
             _componentHost = componentHost;
             _nodeEndpoint = inProcNodeEndpoint;
@@ -114,13 +119,18 @@ public InProcNode(IBuildComponentHost componentHost, INodeEndpoint inProcNodeEnd
             _packetReceivedEvent = new AutoResetEvent(false);
             _shutdownEvent = new AutoResetEvent(false);
 
-            _buildRequestEngine = componentHost.GetComponent(BuildComponentType.RequestEngine) as IBuildRequestEngine;
+            // _buildRequestEngine = componentHost.GetComponent(BuildComponentType.RequestEngine) as IBuildRequestEngine;
+            var buildRequestEngine = BuildRequestEngine.CreateComponent(BuildComponentType.RequestEngine);
+            buildRequestEngine.InitializeComponent(componentHost);
+            _buildRequestEngine = (IBuildRequestEngine)buildRequestEngine;
 
             _engineExceptionEventHandler = OnEngineException;
             _newConfigurationRequestEventHandler = OnNewConfigurationRequest;
             _requestBlockedEventHandler = OnNewRequest;
             _requestCompleteEventHandler = OnRequestComplete;
             _resourceRequestHandler = OnResourceRequest;
+
+            _nodeId = nodeId;
         }
 
         #region INode Members
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 2f5a26be1fc..ca0586d7022 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -266,13 +266,22 @@ public void InitializeForTask(IBuildEngine2 buildEngine, TargetLoggingContext lo
             IsOutOfProc = isOutOfProc;
         }
 
+        private object _locker = new object();
+
         /// <summary>
         /// Ask the task host to find its task in the registry and get it ready for initializing the batch
         /// </summary>
         /// <returns>The task requirements and task factory wrapper if the task is found, (null, null) otherwise.</returns>
         public (TaskRequirements? requirements, TaskFactoryWrapper taskFactoryWrapper) FindTask(IDictionary<string, string> taskIdentityParameters)
         {
-            _taskFactoryWrapper ??= FindTaskInRegistry(taskIdentityParameters);
+            lock (_locker)
+            {
+                if (_taskFactoryWrapper == null)
+                {
+                
+                    _taskFactoryWrapper = FindTaskInRegistry(taskIdentityParameters);
+                }
+            }
 
             if (_taskFactoryWrapper is null)
             {
diff --git a/src/Build/Instance/TaskFactoryWrapper.cs b/src/Build/Instance/TaskFactoryWrapper.cs
index d9bfe7d56b9..3cd013f7245 100644
--- a/src/Build/Instance/TaskFactoryWrapper.cs
+++ b/src/Build/Instance/TaskFactoryWrapper.cs
@@ -3,7 +3,9 @@
 
 using System;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.Reflection;
+using System.Threading;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -73,6 +75,8 @@ public PropertyData(
         /// </summary>
         private IDictionary<string, string> _factoryIdentityParameters;
 
+        private object _locker = new object();
+
         #endregion
 
         #region Constructors
@@ -278,12 +282,18 @@ private PropertyData PopulatePropertyInfo()
 
                 try
                 {
-                    if (propertyInfoCache == null)
+                    lock (_locker)
                     {
-                        propertyInfoCache = new Dictionary<string, TaskPropertyInfo>(StringComparer.OrdinalIgnoreCase);
+                        if (propertyInfoCache == null)
+                        {
+                            propertyInfoCache = new Dictionary<string, TaskPropertyInfo>(StringComparer.OrdinalIgnoreCase);
+                        }
+
+                        if (!propertyInfoCache.ContainsKey(propertyInfo.Name))
+                        {
+                            propertyInfoCache.Add(propertyInfo.Name, propertyInfo);
+                        }
                     }
-
-                    propertyInfoCache.Add(propertyInfo.Name, propertyInfo);
                 }
                 catch (ArgumentException)
                 {
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index bbc62463b1e..dd5b1e02306 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -23,6 +23,9 @@ namespace Microsoft.Build.Framework;
 
 internal static class NativeMethods
 {
+    [ThreadStatic]
+    internal static string CurrentThreadWorkingDirectory;
+
     #region Constants
 
     internal const uint ERROR_INSUFFICIENT_BUFFER = 0x8007007A;
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index 47e9361022d..f6135ce7a27 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -1170,6 +1170,7 @@ public void InvalidToolsVersionErrors()
                                         null,
 #endif
                                         1,
+                                        false,
                                         true,
                                         new StringWriter(),
                                         new StringWriter(),
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index 982999ec30f..f239f7dd10c 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -115,6 +115,7 @@ internal enum ParameterizedSwitch
             LowPriority,
             Question,
             DetailedSummary,
+            MultiThreaded,
             GetProperty,
             GetItem,
             GetTargetResult,
@@ -292,6 +293,7 @@ internal ParameterizedSwitchInfo(
             new ParameterizedSwitchInfo(  ["lowpriority", "low"],               ParameterizedSwitch.LowPriority,                null,                           false,          null,                                  true,   false,   "HelpMessage_39_LowPrioritySwitch"),
             new ParameterizedSwitchInfo(  ["question", "q"],                    ParameterizedSwitch.Question,                   null,                           false,          null,                                  true,   false,   "HelpMessage_41_QuestionSwitch"),
             new ParameterizedSwitchInfo(  ["detailedsummary", "ds"],            ParameterizedSwitch.DetailedSummary,            null,                           false,          null,                                  true,   false,   "HelpMessage_26_DetailedSummarySwitch"),
+            new ParameterizedSwitchInfo(  ["multithreaded", "mt"],              ParameterizedSwitch.MultiThreaded,              null,                           false,          null,                                  true,   false,   "HelpMessage_26_DetailedSummarySwitch"),
             new ParameterizedSwitchInfo(  ["getProperty"],                      ParameterizedSwitch.GetProperty,                null,                           true,           "MissingGetPropertyError",             true,   false,   "HelpMessage_43_GetPropertySwitch"),
             new ParameterizedSwitchInfo(  ["getItem"],                          ParameterizedSwitch.GetItem,                    null,                           true,           "MissingGetItemError",                 true,   false,   "HelpMessage_44_GetItemSwitch"),
             new ParameterizedSwitchInfo(  ["getTargetResult"],                  ParameterizedSwitch.GetTargetResult,            null,                           true,           "MissingGetTargetResultError",         true,   false,   "HelpMessage_45_GetTargetResultSwitch"),
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index c94490ede17..585bc79dc2c 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -708,6 +708,7 @@ public static ExitType Execute(
                 string schemaFile = null;
 #endif
                 int cpuCount = 1;
+                bool multiThreaded = false;
 #if FEATURE_NODE_REUSE
                 bool enableNodeReuse = true;
 #else
@@ -754,6 +755,7 @@ public static ExitType Execute(
                                             ref schemaFile,
 #endif
                                             ref cpuCount,
+                                            ref multiThreaded,
                                             ref enableNodeReuse,
                                             ref preprocessWriter,
                                             ref targetsWriter,
@@ -876,6 +878,7 @@ public static ExitType Execute(
                                 needToValidateProject, schemaFile,
 #endif
                                     cpuCount,
+                                    multiThreaded,
                                     enableNodeReuse,
                                     preprocessWriter,
                                     targetsWriter,
@@ -1275,6 +1278,7 @@ internal static bool BuildProject(
             string schemaFile,
 #endif
             int cpuCount,
+            bool multiThreaded,
             bool enableNodeReuse,
             TextWriter preprocessWriter,
             TextWriter targetsWriter,
@@ -1482,6 +1486,7 @@ internal static bool BuildProject(
                     parameters.NodeExeLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
 #endif
                     parameters.MaxNodeCount = cpuCount;
+                    parameters.MultiThreaded = multiThreaded;
                     parameters.Loggers = projectCollection.Loggers;
                     parameters.ForwardingLoggers = remoteLoggerRecords;
                     parameters.ToolsetDefinitionLocations = Microsoft.Build.Evaluation.ToolsetDefinitionLocations.ConfigurationFile | Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Registry;
@@ -2493,6 +2498,7 @@ private static bool ProcessCommandLineSwitches(
             ref string schemaFile,
 #endif
             ref int cpuCount,
+            ref bool multiThreaded,
             ref bool enableNodeReuse,
             ref TextWriter preprocessWriter,
             ref TextWriter targetsWriter,
@@ -2632,6 +2638,7 @@ private static bool ProcessCommandLineSwitches(
                                                            ref schemaFile,
 #endif
                                                            ref cpuCount,
+                                                           ref multiThreaded,
                                                            ref enableNodeReuse,
                                                            ref preprocessWriter,
                                                            ref targetsWriter,
@@ -2693,6 +2700,9 @@ private static bool ProcessCommandLineSwitches(
                     // figure out if there was a max cpu count provided
                     cpuCount = ProcessMaxCPUCountSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.MaxCPUCount]);
 
+                    // figure out if we should use in-proc nodes for parallel build, effectively running the build multi-threaded
+                    multiThreaded = ProcessMultiThreadedSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.MultiThreaded]);
+
                     // figure out if we should reuse nodes
                     // If FEATURE_NODE_REUSE is OFF, just validates that the switch is OK, and always returns False
                     enableNodeReuse = ProcessNodeReuseSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeReuse]);
@@ -3173,6 +3183,35 @@ private static string[] ProcessInputResultsCaches(CommandLineSwitches commandLin
                 : null;
         }
 
+        /// <summary>
+        /// Processes the node reuse switch, the user can set node reuse to true, false or not set the switch. If the switch is
+        /// not set the system will check to see if the process is being run as an administrator. This check in localnode provider
+        /// will determine the node reuse setting for that case.
+        /// </summary>
+        internal static bool ProcessMultiThreadedSwitch(string[] parameters)
+        {
+            bool enableMultiThreading = false;
+
+            if (parameters.Length > 0)
+            {
+                try
+                {
+                    // There does not seem to be a localizable function for this
+                    enableMultiThreading = bool.Parse(parameters[parameters.Length - 1]);
+                }
+                catch (FormatException ex)
+                {
+                    CommandLineSwitchException.Throw("InvalidMultiThreadedValue", parameters[parameters.Length - 1], ex.Message);
+                }
+                catch (ArgumentNullException ex)
+                {
+                    CommandLineSwitchException.Throw("InvalidMultiThreadedValue", parameters[parameters.Length - 1], ex.Message);
+                }
+            }
+
+            return enableMultiThreading;
+        }
+
         /// <summary>
         /// Processes the node reuse switch, the user can set node reuse to true, false or not set the switch. If the switch is
         /// not set the system will check to see if the process is being run as an administrator. This check in localnode provider
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index b322052e386..a9daba8240e 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -2049,7 +2049,7 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l
         /// </summary>
         internal void ReadStateFile(FileExists fileExists)
         {
-            _cache = SystemState.DeserializeCache<SystemState>(_stateFile, Log);
+            _cache = SystemState.DeserializeCache<SystemState>(MakePath(_stateFile), Log);
 
             // Construct the cache only if we can't find any caches.
             if (_cache == null && AssemblyInformationCachePaths != null && AssemblyInformationCachePaths.Length > 0)
@@ -2076,7 +2076,7 @@ internal void WriteStateFile()
             {
                 // Either the cache is dirty (we added or updated an item) or the number of items actually used is less than what
                 // we got by reading the state file prior to execution. Serialize the cache into the state file.
-                _cache.SerializeCache(_stateFile, Log);
+                _cache.SerializeCache(MakePath(_stateFile), Log);
             }
         }
         #endregion
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index e553d1765af..cad872ef905 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -74,6 +74,8 @@ public Copy()
         private static string RemovingReadOnlyAttribute;
         private static string SymbolicLinkComment;
 
+        private string _currentDirectory;
+
         #region Properties
 
         private readonly CancellationTokenSource _cancellationTokenSource = new CancellationTokenSource();
@@ -344,7 +346,7 @@ private void LogAlwaysRetryDiagnosticFromResources(string messageResourceName, p
                 // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
                 Log.LogMessage(MessageImportance.Normal, FileComment, sourceFileState.FileNameFullPath, destinationFileState.FileNameFullPath);
 
-                File.Copy(sourceFileState.Name, destinationFileState.Name, true);
+                File.Copy(MakePath(_currentDirectory, sourceFileState.Name), MakePath(_currentDirectory, destinationFileState.Name), true);
             }
 
             // If the destinationFile file exists, then make sure it's read-write.
@@ -1028,6 +1030,7 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
         /// <returns></returns>
         public override bool Execute()
         {
+            _currentDirectory = GetBasePath();
             return Execute(CopyFileWithLogging, s_parallelism);
         }
 
diff --git a/src/Tasks/FileIO/ReadLinesFromFile.cs b/src/Tasks/FileIO/ReadLinesFromFile.cs
index 86b5ca17068..506a409533c 100644
--- a/src/Tasks/FileIO/ReadLinesFromFile.cs
+++ b/src/Tasks/FileIO/ReadLinesFromFile.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
+using System.IO;
 
 #nullable disable
 
@@ -38,11 +39,11 @@ public override bool Execute()
             bool success = true;
             if (File != null)
             {
-                if (FileSystems.Default.FileExists(File.ItemSpec))
+                if (FileSystems.Default.FileExists(MakePath(File.ItemSpec)))
                 {
                     try
                     {
-                        string[] textLines = System.IO.File.ReadAllLines(File.ItemSpec);
+                        string[] textLines = System.IO.File.ReadAllLines(MakePath(File.ItemSpec));
 
                         var nonEmptyLines = new List<ITaskItem>();
                         char[] charsToTrim = { '\0', ' ', '\t' };
diff --git a/src/Tasks/FileIO/WriteLinesToFile.cs b/src/Tasks/FileIO/WriteLinesToFile.cs
index f2cbc19bb42..5d342f6b65f 100644
--- a/src/Tasks/FileIO/WriteLinesToFile.cs
+++ b/src/Tasks/FileIO/WriteLinesToFile.cs
@@ -96,7 +96,8 @@ public override bool Execute()
 
                 try
                 {
-                    var directoryPath = Path.GetDirectoryName(FileUtilities.NormalizePath(File.ItemSpec));
+                    var spec = MakePath(File.ItemSpec);
+                    var directoryPath = Path.GetDirectoryName(FileUtilities.NormalizePath(spec));
                     if (Overwrite)
                     {
                         Directory.CreateDirectory(directoryPath);
@@ -108,20 +109,20 @@ public override bool Execute()
                             MSBuildEventSource.Log.WriteLinesToFileUpToDateStart();
                             try
                             {
-                                if (FileUtilities.FileExistsNoThrow(File.ItemSpec))
+                                if (FileUtilities.FileExistsNoThrow(spec))
                                 {
-                                    string existingContents = System.IO.File.ReadAllText(File.ItemSpec);
+                                    string existingContents = System.IO.File.ReadAllText(spec);
                                     if (existingContents.Length == buffer.Length)
                                     {
                                         if (existingContents.Equals(contentsAsString))
                                         {
-                                            Log.LogMessageFromResources(MessageImportance.Low, "WriteLinesToFile.SkippingUnchangedFile", File.ItemSpec);
-                                            MSBuildEventSource.Log.WriteLinesToFileUpToDateStop(File.ItemSpec, true);
+                                            Log.LogMessageFromResources(MessageImportance.Low, "WriteLinesToFile.SkippingUnchangedFile", spec);
+                                            MSBuildEventSource.Log.WriteLinesToFileUpToDateStop(spec, true);
                                             return true;
                                         }
                                         else if (FailIfNotIncremental)
                                         {
-                                            Log.LogErrorWithCodeFromResources("WriteLinesToFile.ErrorReadingFile", File.ItemSpec);
+                                            Log.LogErrorWithCodeFromResources("WriteLinesToFile.ErrorReadingFile", spec);
                                             return false;
                                         }
                                     }
@@ -129,22 +130,22 @@ public override bool Execute()
                             }
                             catch (IOException)
                             {
-                                Log.LogMessageFromResources(MessageImportance.Low, "WriteLinesToFile.ErrorReadingFile", File.ItemSpec);
+                                Log.LogMessageFromResources(MessageImportance.Low, "WriteLinesToFile.ErrorReadingFile", spec);
                             }
-                            MSBuildEventSource.Log.WriteLinesToFileUpToDateStop(File.ItemSpec, false);
+                            MSBuildEventSource.Log.WriteLinesToFileUpToDateStop(spec, false);
                         }
 
-                        System.IO.File.WriteAllText(File.ItemSpec, contentsAsString, encoding);
+                        System.IO.File.WriteAllText(spec, contentsAsString, encoding);
                     }
                     else
                     {
                         if (WriteOnlyWhenDifferent)
                         {
-                            Log.LogMessageFromResources(MessageImportance.Normal, "WriteLinesToFile.UnusedWriteOnlyWhenDifferent", File.ItemSpec);
+                            Log.LogMessageFromResources(MessageImportance.Normal, "WriteLinesToFile.UnusedWriteOnlyWhenDifferent", spec);
                         }
 
                         Directory.CreateDirectory(directoryPath);
-                        System.IO.File.AppendAllText(File.ItemSpec, buffer.ToString(), encoding);
+                        System.IO.File.AppendAllText(spec, buffer.ToString(), encoding);
                     }
                 }
                 catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index ecfe9bad0d6..be63cb3fff4 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -115,7 +115,7 @@ public override bool Execute()
 
                 FileUtilities.EnsureDirectoryExists(Path.GetDirectoryName(OutputFile.ItemSpec));
 
-                File.WriteAllText(OutputFile.ItemSpec, code); // Overwrites file if it already exists (and can be overwritten)
+                File.WriteAllText(MakePath(OutputFile.ItemSpec), code); // Overwrites file if it already exists (and can be overwritten)
             }
             catch (Exception ex) when (ExceptionHandling.IsIoRelatedException(ex))
             {
diff --git a/src/Utilities/Task.cs b/src/Utilities/Task.cs
index 2c16effe9f1..7bf0fec3872 100644
--- a/src/Utilities/Task.cs
+++ b/src/Utilities/Task.cs
@@ -1,6 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.IO;
 using System.Resources;
 
 using Microsoft.Build.Framework;
@@ -155,6 +156,21 @@ protected string HelpKeywordPrefix
         /// <returns>true, if successful</returns>
         public abstract bool Execute();
 
+        protected string MakePath(string path)
+        {
+            return MakePath(NativeMethodsShared.CurrentThreadWorkingDirectory, path);
+        }
+
+        protected string MakePath(string baseDirectory, string path)
+        {
+            return Path.Combine(baseDirectory, path);
+        }
+
+        protected string GetBasePath()
+        {
+            return NativeMethodsShared.CurrentThreadWorkingDirectory;
+        }
+
         #endregion
     }
 }
