diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 0f80c152ba5..52b31076185 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -1639,7 +1639,7 @@ ILogger UnwrapLoggerType(ILogger log)
         /// </remarks>
         private void UpdateMinimumMessageImportance(ILogger logger)
         {
-            var innerLogger = (logger is Evaluation.ProjectCollection.ReusableLogger reusableLogger) ? reusableLogger.OriginalLogger : logger;
+            var innerLogger = (logger is ProjectCollection.ReusableLogger reusableLogger) ? reusableLogger.OriginalLogger : logger;
 
             MessageImportance? minimumImportance = innerLogger switch
             {
@@ -1653,8 +1653,11 @@ private void UpdateMinimumMessageImportance(ILogger logger)
                 // The null logger has no effect on minimum verbosity.
                 Execution.BuildManager.NullLogger => null,
 
-                // If the logger is not on our whitelist, there are no importance guarantees. Fall back to "any importance".
-                _ => MessageImportance.Low
+                // The live logger consumes only high priority messages.
+                _ => innerLogger.GetType().FullName == "Microsoft.Build.Logging.LiveLogger.LiveLogger"
+                    ? MessageImportance.High
+                    // If the logger is not on our allow list, there are no importance guarantees. Fall back to "any importance".
+                    : MessageImportance.Low,
             };
 
             if (minimumImportance != null)
diff --git a/src/MSBuild.UnitTests/LiveLogger_Tests.cs b/src/MSBuild.UnitTests/LiveLogger_Tests.cs
new file mode 100644
index 00000000000..22d3280622a
--- /dev/null
+++ b/src/MSBuild.UnitTests/LiveLogger_Tests.cs
@@ -0,0 +1,203 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Logging.LiveLogger;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.UnitTests
+{
+    public class LiveLogger_Tests : IEventSource, IDisposable
+    {
+        private const int _nodeCount = 8;
+        private const int _terminalWidth = 80;
+        private const string _eventSender = "Test";
+        private const string _projectFile = @"C:\src\project.proj";
+
+        private readonly MockTerminal _mockTerminal;
+        private readonly LiveLogger _liveLogger;
+
+        private readonly DateTime _buildStartTime = new DateTime(2023, 3, 30, 16, 30, 0);
+        private readonly DateTime _buildFinishTime = new DateTime(2023, 3, 30, 16, 30, 5);
+
+        public LiveLogger_Tests()
+        {
+            _mockTerminal = new MockTerminal(_terminalWidth);
+            _liveLogger = new LiveLogger(_mockTerminal);
+
+            _liveLogger.Initialize(this, _nodeCount);
+        }
+
+        #region IEventSource implementation
+
+#pragma warning disable CS0067
+        public event BuildMessageEventHandler? MessageRaised;
+        public event BuildErrorEventHandler? ErrorRaised;
+        public event BuildWarningEventHandler? WarningRaised;
+        public event BuildStartedEventHandler? BuildStarted;
+        public event BuildFinishedEventHandler? BuildFinished;
+        public event ProjectStartedEventHandler? ProjectStarted;
+        public event ProjectFinishedEventHandler? ProjectFinished;
+        public event TargetStartedEventHandler? TargetStarted;
+        public event TargetFinishedEventHandler? TargetFinished;
+        public event TaskStartedEventHandler? TaskStarted;
+        public event TaskFinishedEventHandler? TaskFinished;
+        public event CustomBuildEventHandler? CustomEventRaised;
+        public event BuildStatusEventHandler? StatusEventRaised;
+        public event AnyEventHandler? AnyEventRaised;
+#pragma warning restore CS0067
+
+        #endregion
+
+        #region IDisposable implementation
+
+        public void Dispose()
+        {
+            _liveLogger.Shutdown();
+        }
+
+        #endregion
+
+        #region Event args helpers
+
+        private BuildEventContext MakeBuildEventContext()
+        {
+            return new BuildEventContext(1, 1, 1, 1);
+        }
+
+        private BuildStartedEventArgs MakeBuildStartedEventArgs()
+        {
+            return new BuildStartedEventArgs(null, null, _buildStartTime);
+        }
+
+        private BuildFinishedEventArgs MakeBuildFinishedEventArgs(bool succeeded)
+        {
+            return new BuildFinishedEventArgs(null, null, succeeded, _buildFinishTime);
+        }
+
+        private ProjectStartedEventArgs MakeProjectStartedEventArgs(string projectFile, string targetNames = "Build")
+        {
+            return new ProjectStartedEventArgs("", "", projectFile, targetNames, new Dictionary<string, string>(), new List<DictionaryEntry>())
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private ProjectFinishedEventArgs MakeProjectFinishedEventArgs(string projectFile, bool succeeded)
+        {
+            return new ProjectFinishedEventArgs(null, null, projectFile, succeeded)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private TargetStartedEventArgs MakeTargetStartedEventArgs(string projectFile, string targetName)
+        {
+            return new TargetStartedEventArgs("", "", targetName, projectFile, targetFile: projectFile)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private TargetFinishedEventArgs MakeTargetFinishedEventArgs(string projectFile, string targetName, bool succeeded)
+        {
+            return new TargetFinishedEventArgs("", "", targetName, projectFile, targetFile: projectFile, succeeded)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private TaskStartedEventArgs MakeTaskStartedEventArgs(string projectFile, string taskName)
+        {
+            return new TaskStartedEventArgs("", "", projectFile, taskFile: projectFile, taskName)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private TaskFinishedEventArgs MakeTaskFinishedEventArgs(string projectFile, string taskName, bool succeeded)
+        {
+            return new TaskFinishedEventArgs("", "", projectFile, taskFile: projectFile, taskName, succeeded)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private BuildWarningEventArgs MakeWarningEventArgs(string warning)
+        {
+            return new BuildWarningEventArgs("", "", "", 0, 0, 0, 0, warning, null, null)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private BuildErrorEventArgs MakeErrorEventArgs(string error)
+        {
+            return new BuildErrorEventArgs("", "", "", 0, 0, 0, 0, error, null, null)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        #endregion
+
+        #region Build summary tests
+
+        private void InvokeLoggerCallbacksForSimpleProject(bool succeeded, Action additionalCallbacks)
+        {
+            BuildStarted?.Invoke(_eventSender, MakeBuildStartedEventArgs());
+            ProjectStarted?.Invoke(_eventSender, MakeProjectStartedEventArgs(_projectFile));
+
+            TargetStarted?.Invoke(_eventSender, MakeTargetStartedEventArgs(_projectFile, "Build"));
+            TaskStarted?.Invoke(_eventSender, MakeTaskStartedEventArgs(_projectFile, "Task"));
+
+            additionalCallbacks();
+
+            TaskFinished?.Invoke(_eventSender, MakeTaskFinishedEventArgs(_projectFile, "Task", succeeded));
+            TargetFinished?.Invoke(_eventSender, MakeTargetFinishedEventArgs(_projectFile, "Build", succeeded));
+
+            ProjectFinished?.Invoke(_eventSender, MakeProjectFinishedEventArgs(_projectFile, succeeded));
+            BuildFinished?.Invoke(_eventSender, MakeBuildFinishedEventArgs(succeeded));
+        }
+
+        [Fact]
+        public void PrintsBuildSummary_Succeeded()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: true, () => { });
+            _mockTerminal.GetLastLine().ShouldBe("Build succeeded in 5.0s");
+        }
+
+        [Fact]
+        public void PrintBuildSummary_SucceededWithWarnings()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: true, () =>
+            {
+                WarningRaised?.Invoke(_eventSender, MakeWarningEventArgs("Warning!"));
+            });
+            _mockTerminal.GetLastLine().ShouldBe("Build succeeded with warnings in 5.0s");
+        }
+
+        [Fact]
+        public void PrintBuildSummary_Failed()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: false, () => { });
+            _mockTerminal.GetLastLine().ShouldBe("Build failed in 5.0s");
+        }
+
+        [Fact]
+        public void PrintBuildSummary_FailedWithErrors()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: false, () =>
+            {
+                ErrorRaised?.Invoke(_eventSender, MakeErrorEventArgs("Error!"));
+            });
+            _mockTerminal.GetLastLine().ShouldBe("Build failed with errors in 5.0s");
+        }
+
+        #endregion
+    }
+}
diff --git a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
index 61f2c68c312..f7c8683c7af 100644
--- a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
+++ b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
@@ -45,6 +45,9 @@
     <Compile Include="..\UnitTests.Shared\EnvironmentProvider.cs" />
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
 
+    <Compile Remove="LiveLogger_Tests.cs" Condition="'$(TargetFrameworkIdentifier)' != '.NETCoreApp'" />
+    <Compile Remove="MockTerminal.cs" Condition="'$(TargetFrameworkIdentifier)' != '.NETCoreApp'" />
+
     <EmbeddedResource Include="..\MSBuild\MSBuild\Microsoft.Build.Core.xsd">
       <Link>Microsoft.Build.Core.xsd</Link>
       <SubType>
diff --git a/src/MSBuild.UnitTests/MockTerminal.cs b/src/MSBuild.UnitTests/MockTerminal.cs
new file mode 100644
index 00000000000..c4f5ee7d5d2
--- /dev/null
+++ b/src/MSBuild.UnitTests/MockTerminal.cs
@@ -0,0 +1,113 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+using Microsoft.Build.Logging.LiveLogger;
+
+namespace Microsoft.Build.UnitTests
+{
+    /// <summary>
+    /// A test implementation of <see cref="ITerminal"/>.
+    /// </summary>
+    internal sealed class MockTerminal : ITerminal
+    {
+        private readonly int _width;
+
+        /// <summary>
+        /// Contains output lines written to the terminal.
+        /// </summary>
+        private List<string> _outputLines = new();
+
+        private StringBuilder _bufferedOutput = new();
+        private bool _isBuffering = false;
+
+        public MockTerminal(int width)
+        {
+            _width = width;
+            _outputLines.Add("");
+        }
+
+        /// <summary>
+        /// Gets the last line written to the terminal.
+        /// </summary>
+        /// <remarks>
+        /// If the last character was \n, it returns characters between the second to last \n and last \n.
+        /// If the last character was not \n, it returns characters between the last \n and the end of the output.
+        /// </remarks>
+        public string GetLastLine()
+        {
+            string lastLine = _outputLines[^1];
+            if (lastLine.Length == 0 && _outputLines.Count > 1)
+            {
+                lastLine = _outputLines[^2];
+            }
+            return lastLine;
+        }
+
+        /// <summary>
+        /// Adds a string to <see cref="_outputLines"/>.
+        /// </summary>
+        private void AddOutput(string text)
+        {
+            if (_isBuffering)
+            {
+                _bufferedOutput.Append(text);
+            }
+            else
+            {
+                string[] lines = text.Split('\n');
+                _outputLines[^1] += lines[0];
+                for (int i = 1; i < lines.Length; i++)
+                {
+                    _outputLines.Add("");
+                    _outputLines[^1] += lines[i];
+                }
+            }
+        }
+
+        #region ITerminal implementation
+
+        public void BeginUpdate()
+        {
+            if (_isBuffering)
+            {
+                throw new InvalidOperationException();
+            }
+            _isBuffering = true;
+        }
+
+        public void EndUpdate()
+        {
+            if (!_isBuffering)
+            {
+                throw new InvalidOperationException();
+            }
+            _isBuffering = false;
+
+            AddOutput(_bufferedOutput.ToString());
+            _bufferedOutput.Clear();
+        }
+
+        public void Write(string text) => AddOutput(text);
+        public void WriteColor(TerminalColor color, string text) => AddOutput(text);
+        public void WriteColorLine(TerminalColor color, string text) { AddOutput(text); AddOutput("\n"); }
+        public void WriteLine(string text) { AddOutput(text); AddOutput("\n"); }
+        public void WriteLine(ReadOnlySpan<char> text) { AddOutput(text.ToString()); AddOutput("\n"); }
+        public void WriteLineFitToWidth(ReadOnlySpan<char> input)
+        {
+            AddOutput(input.Slice(0, Math.Min(input.Length, _width - 1)).ToString());
+            AddOutput("\n");
+        }
+
+        #endregion
+
+        #region IDisposable implementation
+
+        public void Dispose()
+        { }
+
+        #endregion
+    }
+}
diff --git a/src/MSBuild/LiveLogger/ITerminal.cs b/src/MSBuild/LiveLogger/ITerminal.cs
new file mode 100644
index 00000000000..63e310aff72
--- /dev/null
+++ b/src/MSBuild/LiveLogger/ITerminal.cs
@@ -0,0 +1,72 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Logging.LiveLogger;
+
+/// <summary>
+/// An abstraction of a terminal, built specifically to fit the <see cref="LiveLogger"/> needs.
+/// </summary>
+internal interface ITerminal : IDisposable
+{
+    /// <summary>
+    /// Starts buffering the text passed via the <c>Write*</c> methods.
+    /// </summary>
+    /// <remarks>
+    /// Upon calling this method, the terminal should be buffering all output internally until <see cref="EndUpdate"/> is called.
+    /// </remarks>
+    void BeginUpdate();
+
+    /// <summary>
+    /// Flushes the text buffered between <see cref="BeginUpdate"/> was called and now into the output.
+    /// </summary>
+    void EndUpdate();
+
+    /// <summary>
+    /// Writes a string to the output. Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void Write(string text);
+
+    /// <summary>
+    /// Writes a string to the output. Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void WriteLine(string text);
+
+    /// <summary>
+    /// Writes a string to the output. Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void WriteLine(ReadOnlySpan<char> text);
+
+    /// <summary>
+    /// Writes a string to the output, truncating it if it wouldn't fit on one screen line.
+    /// Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void WriteLineFitToWidth(ReadOnlySpan<char> input);
+
+    /// <summary>
+    /// Writes a string to the output using the given color. Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void WriteColor(TerminalColor color, string text);
+
+    /// <summary>
+    /// Writes a string to the output using the given color. Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void WriteColorLine(TerminalColor color, string text);
+}
+
+/// <summary>
+/// Enumerates the text colors supported by <see cref="ITerminal"/>.
+/// </summary>
+internal enum TerminalColor
+{
+    Black = 30,
+    Red = 31,
+    Green = 32,
+    Yellow = 33,
+    Blue = 34,
+    Magenta = 35,
+    Cyan = 36,
+    White = 37,
+    Default = 39
+}
diff --git a/src/MSBuild/LiveLogger/LiveLogger.cs b/src/MSBuild/LiveLogger/LiveLogger.cs
index 6d84f0150f3..d6d9a1bae97 100644
--- a/src/MSBuild/LiveLogger/LiveLogger.cs
+++ b/src/MSBuild/LiveLogger/LiveLogger.cs
@@ -12,39 +12,115 @@
 
 namespace Microsoft.Build.Logging.LiveLogger;
 
+/// <summary>
+/// A logger which updates the console output "live" during the build.
+/// </summary>
+/// <remarks>
+/// Uses ANSI/VT100 control codes to erase and overwrite lines as the build is progressing.
+/// </remarks>
 internal sealed class LiveLogger : INodeLogger
 {
+    /// <summary>
+    /// A wrapper over the project context ID passed to us in <see cref="IEventSource"/> logger events.
+    /// </summary>
+    internal record struct ProjectContext(int Id)
+    {
+        public ProjectContext(BuildEventContext context)
+            : this(context.ProjectContextId)
+        { }
+    }
+
+    /// <summary>
+    /// Encapsulates the per-node data shown in live node output.
+    /// </summary>
+    internal record NodeStatus(string Project, string? TargetFramework, string Target, Stopwatch Stopwatch)
+    {
+        public override string ToString()
+        {
+            return string.IsNullOrEmpty(TargetFramework)
+                ? $"{Indentation}{Project} {Target} ({Stopwatch.Elapsed.TotalSeconds:F1}s)"
+                : $"{Indentation}{Project} [{TargetFramework}] {Target} ({Stopwatch.Elapsed.TotalSeconds:F1}s)";
+        }
+    }
+
+    /// <summary>
+    /// The indentation to use for all build output.
+    /// </summary>
+    private const string Indentation = "  ";
+
+    /// <summary>
+    /// Protects access to state shared between the logger callbacks and the rendering thread.
+    /// </summary>
     private readonly object _lock = new();
 
+    /// <summary>
+    /// A cancellation token to signal the rendering thread that it should exit.
+    /// </summary>
     private readonly CancellationTokenSource _cts = new();
 
+    /// <summary>
+    /// Tracks the work currently being done by build nodes. Null means the node is not doing any work worth reporting.
+    /// </summary>
     private NodeStatus?[] _nodes = Array.Empty<NodeStatus>();
 
-    private readonly Dictionary<ProjectContext, Project> _notableProjects = new();
+    /// <summary>
+    /// Tracks the status of all relevant projects seen so far.
+    /// </summary>
+    /// <remarks>
+    /// Keyed by an ID that gets passed to logger callbacks, this allows us to quickly look up the corresponding project.
+    /// </remarks>
+    private readonly Dictionary<ProjectContext, Project> _projects = new();
 
-    private readonly Dictionary<ProjectContext, (bool Notable, string? Path, string? Targets)> _notabilityByContext = new();
+    /// <summary>
+    /// The timestamp of the <see cref="IEventSource.BuildStarted"/> event.
+    /// </summary>
+    private DateTime _buildStartTime;
 
-    private readonly Dictionary<ProjectInstance, ProjectContext> _relevantContextByInstance = new();
+    /// <summary>
+    /// True if the build has encountered at least one error.
+    /// </summary>
+    private bool _buildHasErrors;
 
-    private readonly Dictionary<ProjectContext, Stopwatch> _projectTimeCounter = new();
+    /// <summary>
+    /// True if the build has encountered at least one warning.
+    /// </summary>
+    private bool _buildHasWarnings;
 
+    /// <summary>
+    /// The project build context corresponding to the <c>Restore</c> initial target, or null if the build is currently
+    /// bot restoring.
+    /// </summary>
     private ProjectContext? _restoreContext;
 
+    /// <summary>
+    /// The thread that performs periodic refresh of the console output.
+    /// </summary>
     private Thread? _refresher;
 
+    /// <summary>
+    /// What is currently displaying in Nodes section as strings representing per-node console output.
+    /// </summary>
     private NodesFrame _currentFrame = new(Array.Empty<NodeStatus>());
 
-    private Encoding? _originalOutputEncoding;
+    /// <summary>
+    /// The <see cref="Terminal"/> to write console output to.
+    /// </summary>
+    private ITerminal Terminal { get; }
 
+    /// <inheritdoc/>
     public LoggerVerbosity Verbosity { get => LoggerVerbosity.Minimal; set { } }
 
+    /// <inheritdoc/>
     public string Parameters { get => ""; set { } }
 
     /// <summary>
     /// List of events the logger needs as parameters to the <see cref="ConfigurableForwardingLogger"/>.
     /// </summary>
     /// <remarks>
-    /// If LiveLogger runs as a distributed logger, MSBuild out-of-proc nodes might filter the events that will go to the main node using an instance of <see cref="ConfigurableForwardingLogger"/> with the following parameters.
+    /// If LiveLogger runs as a distributed logger, MSBuild out-of-proc nodes might filter the events that will go to the main
+    /// node using an instance of <see cref="ConfigurableForwardingLogger"/> with the following parameters.
+    /// Important: Note that LiveLogger is special-cased in <see cref="BackEnd.Logging.LoggingService.UpdateMinimumMessageImportance"/>
+    /// so changing this list may impact the minimum message importance logging optimization.
     /// </remarks>
     public static readonly string[] ConfigurableForwardingLoggerParameters =
     {
@@ -60,6 +136,23 @@ internal sealed class LiveLogger : INodeLogger
             "ERROREVENT"
     };
 
+    /// <summary>
+    /// Default constructor, used by the MSBuild logger infra.
+    /// </summary>
+    public LiveLogger()
+    {
+        Terminal = new Terminal();
+    }
+
+    /// <summary>
+    /// Internal constructor accepting a custom <see cref="ITerminal"/> for testing.
+    /// </summary>
+    internal LiveLogger(ITerminal terminal)
+    {
+        Terminal = terminal;
+    }
+
+    /// <inheritdoc/>
     public void Initialize(IEventSource eventSource, int nodeCount)
     {
         _nodes = new NodeStatus[nodeCount];
@@ -67,6 +160,7 @@ public void Initialize(IEventSource eventSource, int nodeCount)
         Initialize(eventSource);
     }
 
+    /// <inheritdoc/>
     public void Initialize(IEventSource eventSource)
     {
         eventSource.BuildStarted += new BuildStartedEventHandler(BuildStarted);
@@ -80,14 +174,11 @@ public void Initialize(IEventSource eventSource)
         eventSource.MessageRaised += new BuildMessageEventHandler(MessageRaised);
         eventSource.WarningRaised += new BuildWarningEventHandler(WarningRaised);
         eventSource.ErrorRaised += new BuildErrorEventHandler(ErrorRaised);
-
-        _originalOutputEncoding = Console.OutputEncoding;
-        Console.OutputEncoding = Encoding.UTF8;
-
-        _refresher = new Thread(ThreadProc);
-        _refresher.Start();
     }
 
+    /// <summary>
+    /// The <see cref="_refresher"/> thread proc.
+    /// </summary>
     private void ThreadProc()
     {
         while (!_cts.IsCancellationRequested)
@@ -103,14 +194,51 @@ private void ThreadProc()
         EraseNodes();
     }
 
+    /// <summary>
+    /// The <see cref="IEventSource.BuildStarted"/> callback.
+    /// </summary>
     private void BuildStarted(object sender, BuildStartedEventArgs e)
     {
+        _refresher = new Thread(ThreadProc);
+        _refresher.Start();
+
+        _buildStartTime = e.Timestamp;
     }
 
+    /// <summary>
+    /// The <see cref="IEventSource.BuildFinished"/> callback.
+    /// </summary>
     private void BuildFinished(object sender, BuildFinishedEventArgs e)
     {
+        _cts.Cancel();
+        _refresher?.Join();
+
+        _projects.Clear();
+
+        Terminal.BeginUpdate();
+        try
+        {
+
+            Terminal.WriteLine("");
+            Terminal.Write("Build ");
+
+            PrintBuildResult(e.Succeeded, _buildHasErrors, _buildHasWarnings);
+
+            double duration = (e.Timestamp - _buildStartTime).TotalSeconds;
+            Terminal.WriteLine($" in {duration:F1}s");
+        }
+        finally
+        {
+            Terminal.EndUpdate();
+        }
+
+        _buildHasErrors = false;
+        _buildHasWarnings = false;
     }
 
+    /// <summary>
+    /// The <see cref="IEventSource.ProjectStarted"/> callback.
+    /// </summary>
     private void ProjectStarted(object sender, ProjectStartedEventArgs e)
     {
         var buildEventContext = e.BuildEventContext;
@@ -119,48 +247,57 @@ private void ProjectStarted(object sender, ProjectStartedEventArgs e)
             return;
         }
 
-        bool notable = IsNotableProject(e);
-
         ProjectContext c = new ProjectContext(buildEventContext);
 
-        if (notable)
+        if (_restoreContext is null)
         {
-            _notableProjects[c] = new();
+            if (e.GlobalProperties?.TryGetValue("TargetFramework", out string? targetFramework) != true)
+            {
+                targetFramework = null;
+            }
+            _projects[c] = new(targetFramework);
         }
 
-        _projectTimeCounter[c] = Stopwatch.StartNew();
-
         if (e.TargetNames == "Restore")
         {
             _restoreContext = c;
-            Console.WriteLine("Restoring");
+            Terminal.WriteLine("Restoring");
             return;
         }
-
-        _notabilityByContext[c] = (notable, e.ProjectFile, e.TargetNames);
-
-        var key = new ProjectInstance(buildEventContext);
-        if (!_relevantContextByInstance.ContainsKey(key))
-        {
-            _relevantContextByInstance.Add(key, c);
-        }
     }
 
-    private bool IsNotableProject(ProjectStartedEventArgs e)
+    /// <summary>
+    /// Print a build result summary to the output.
+    /// </summary>
+    /// <param name="succeeded">True if the build completed with success.</param>
+    /// <param name="hasError">True if the build has logged at least one error.</param>
+    /// <param name="hasWarning">True if the build has logged at least one warning.</param>
+    private void PrintBuildResult(bool succeeded, bool hasError, bool hasWarning)
     {
-        if (_restoreContext is not null)
+        if (!succeeded)
         {
-            return false;
+            // If the build failed, we print one of three red strings.
+            string text = (hasError, hasWarning) switch
+            {
+                (true, _) => "failed with errors",
+                (false, true) => "failed with warnings",
+                _ => "failed",
+            };
+            Terminal.WriteColor(TerminalColor.Red, text);
         }
-
-        return e.TargetNames switch
+        else if (hasWarning)
         {
-            "" or "Restore" => true,
-            "GetTargetFrameworks" or "GetTargetFrameworks" or "GetNativeManifest" or "GetCopyToOutputDirectoryItems" => false,
-            _ => true,
-        };
+            Terminal.WriteColor(TerminalColor.Yellow, "succeeded with warnings");
+        }
+        else
+        {
+            Terminal.WriteColor(TerminalColor.Green, "succeeded");
+        }
     }
 
+    /// <summary>
+    /// The <see cref="IEventSource.ProjectFinished"/> callback.
+    /// </summary>
     private void ProjectFinished(object sender, ProjectFinishedEventArgs e)
     {
         var buildEventContext = e.BuildEventContext;
@@ -171,62 +308,114 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)
 
         ProjectContext c = new(buildEventContext);
 
+        // First check if we're done restoring.
         if (_restoreContext is ProjectContext restoreContext && c == restoreContext)
         {
             lock (_lock)
             {
                 _restoreContext = null;
 
-                double duration = _notableProjects[restoreContext].Stopwatch.Elapsed.TotalSeconds;
+                Stopwatch projectStopwatch = _projects[restoreContext].Stopwatch;
+                double duration = projectStopwatch.Elapsed.TotalSeconds;
+                projectStopwatch.Stop();
 
-                EraseNodes();
-                Console.WriteLine($"Restore complete ({duration:F1}s)");
-                DisplayNodes();
+                Terminal.BeginUpdate();
+                try
+                {
+                    EraseNodes();
+                    Terminal.WriteLine($"Restore complete ({duration:F1}s)");
+                    DisplayNodes();
+                }
+                finally
+                {
+                    Terminal.EndUpdate();
+                }
                 return;
             }
         }
 
-        if (_notabilityByContext[c].Notable && _relevantContextByInstance[new ProjectInstance(buildEventContext)] == c)
+        // If this was a notable project build, we print it as completed only if it's produced an output or warnings/error.
+        if (_projects.TryGetValue(c, out Project? project) && (project.OutputPath is not null || project.BuildMessages is not null))
         {
             lock (_lock)
             {
-                EraseNodes();
+                Terminal.BeginUpdate();
+                try
+                {
+                    EraseNodes();
 
-                Project project = _notableProjects[c];
-                double duration = project.Stopwatch.Elapsed.TotalSeconds;
-                ReadOnlyMemory<char>? outputPath = project.OutputPath;
+                    double duration = project.Stopwatch.Elapsed.TotalSeconds;
+                    ReadOnlyMemory<char>? outputPath = project.OutputPath;
 
-                if (outputPath is not null)
-                {
-                    ReadOnlySpan<char> url = outputPath.Value.Span;
-                    try
+                    Terminal.Write(Indentation);
+
+                    if (e.ProjectFile is not null)
                     {
-                        // If possible, make the link point to the containing directory of the output.
-                        url = Path.GetDirectoryName(url);
+                        string projectFile = Path.GetFileName(e.ProjectFile) ?? e.ProjectFile;
+                        Terminal.Write(projectFile);
+                        Terminal.Write(" ");
+                    }
+                    if (!string.IsNullOrEmpty(project.TargetFramework))
+                    {
+                        Terminal.Write($"[{project.TargetFramework}] ");
                     }
-                    catch
-                    { }
-                    Console.WriteLine($"{e.ProjectFile} \x1b[1mcompleted\x1b[22m ({duration:F1}s) → \x1b]8;;{url}\x1b\\{outputPath}\x1b]8;;\x1b\\");
-                }
-                else
-                {
-                    Console.WriteLine($"{e.ProjectFile} \x1b[1mcompleted\x1b[22m ({duration:F1}s)");
-                }
 
-                // Print diagnostic output under the Project -> Output line.
-                if (project.BuildMessages is not null)
-                {
-                    foreach (string message in project.BuildMessages)
+                    // Print 'failed', 'succeeded with warnings', or 'succeeded' depending on the build result and diagnostic messages
+                    // reported during build.
+                    bool haveErrors = project.BuildMessages?.Exists(m => m.Severity == MessageSeverity.Error) == true;
+                    bool haveWarnings = project.BuildMessages?.Exists(m => m.Severity == MessageSeverity.Warning) == true;
+                    PrintBuildResult(e.Succeeded, haveErrors, haveWarnings);
+
+                    _buildHasErrors |= haveErrors;
+                    _buildHasWarnings |= haveWarnings;
+
+                    // Print the output path as a link if we have it.
+                    if (outputPath is not null)
                     {
-                        Console.WriteLine(message);
+                        ReadOnlySpan<char> url = outputPath.Value.Span;
+                        try
+                        {
+                            // If possible, make the link point to the containing directory of the output.
+                            url = Path.GetDirectoryName(url);
+                        }
+                        catch
+                        { }
+                        Terminal.WriteLine($" ({duration:F1}s) → \x1b]8;;{url}\x1b\\{outputPath}\x1b]8;;\x1b\\");
+                    }
+                    else
+                    {
+                        Terminal.WriteLine($" ({duration:F1}s)");
                     }
-                }
 
-                DisplayNodes();
+                    // Print diagnostic output under the Project -> Output line.
+                    if (project.BuildMessages is not null)
+                    {
+                        foreach (BuildMessage buildMessage in project.BuildMessages)
+                        {
+                            TerminalColor color = buildMessage.Severity switch
+                            {
+                                MessageSeverity.Warning => TerminalColor.Yellow,
+                                MessageSeverity.Error => TerminalColor.Red,
+                                _ => TerminalColor.Default,
+                            };
+                            Terminal.WriteColorLine(color, $"{Indentation}{Indentation}{buildMessage.Message}");
+                        }
+                    }
+
+                    DisplayNodes();
+                }
+                finally
+                {
+                    Terminal.EndUpdate();
+                }
             }
         }
     }
 
+    /// <summary>
+    /// Render Nodes section.
+    /// It shows what all build nodes do.
+    /// </summary>
     private void DisplayNodes()
     {
         NodesFrame newFrame = new NodesFrame(_nodes);
@@ -239,6 +428,9 @@ private void DisplayNodes()
         _currentFrame = newFrame;
     }
 
+    /// <summary>
+    /// Erases the previously printed live node output.
+    /// </summary>
     private void EraseNodes()
     {
         if (_currentFrame.NodesCount == 0)
@@ -250,24 +442,40 @@ private void EraseNodes()
         _currentFrame.Clear();
     }
 
+    /// <summary>
+    /// The <see cref="IEventSource.TargetStarted"/> callback.
+    /// </summary>
     private void TargetStarted(object sender, TargetStartedEventArgs e)
     {
         var buildEventContext = e.BuildEventContext;
-        if (buildEventContext is not null)
+        if (buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
         {
-            _nodes[NodeIndexForContext(buildEventContext)] = new(e.ProjectFile, e.TargetName, _projectTimeCounter[new ProjectContext(buildEventContext)]);
+            project.Stopwatch.Start();
+
+            string projectFile = Path.GetFileName(e.ProjectFile) ?? e.ProjectFile;
+            _nodes[NodeIndexForContext(buildEventContext)] = new(projectFile, project.TargetFramework, e.TargetName, project.Stopwatch);
         }
     }
 
+    /// <summary>
+    /// Returns the <see cref="_nodes"/> index corresponding to the given <see cref="BuildEventContext"/>.
+    /// </summary>
     private int NodeIndexForContext(BuildEventContext context)
     {
+        // Node IDs reported by the build are 1-based.
         return context.NodeId - 1;
     }
 
+    /// <summary>
+    /// The <see cref="IEventSource.TargetFinished"/> callback. Unused.
+    /// </summary>
     private void TargetFinished(object sender, TargetFinishedEventArgs e)
     {
     }
 
+    /// <summary>
+    /// The <see cref="IEventSource.TaskStarted"/> callback.
+    /// </summary>
     private void TaskStarted(object sender, TaskStartedEventArgs e)
     {
         var buildEventContext = e.BuildEventContext;
@@ -275,9 +483,17 @@ private void TaskStarted(object sender, TaskStartedEventArgs e)
         {
             // This will yield the node, so preemptively mark it idle
             _nodes[NodeIndexForContext(buildEventContext)] = null;
+
+            if (_projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
+            {
+                project.Stopwatch.Stop();
+            }
         }
     }
 
+    /// <summary>
+    /// The <see cref="IEventSource.MessageRaised"/> callback.
+    /// </summary>
     private void MessageRaised(object sender, BuildMessageEventArgs e)
     {
         var buildEventContext = e.BuildEventContext;
@@ -297,7 +513,7 @@ private void MessageRaised(object sender, BuildMessageEventArgs e)
                 var projectFileName = Path.GetFileName(e.ProjectFile.AsSpan());
                 if (!projectFileName.IsEmpty &&
                     message.AsSpan().StartsWith(Path.GetFileNameWithoutExtension(projectFileName)) &&
-                    _notableProjects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
+                    _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
                 {
                     ReadOnlyMemory<char> outputPath = e.Message.AsMemory().Slice(index + 4);
                     project.OutputPath = outputPath;
@@ -306,35 +522,36 @@ private void MessageRaised(object sender, BuildMessageEventArgs e)
         }
     }
 
+    /// <summary>
+    /// The <see cref="IEventSource.WarningRaised"/> callback.
+    /// </summary>
     private void WarningRaised(object sender, BuildWarningEventArgs e)
     {
         var buildEventContext = e.BuildEventContext;
-        if (buildEventContext is not null && _notableProjects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
+        if (buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
         {
             string message = EventArgsFormatting.FormatEventMessage(e, false);
-            project.AddBuildMessage($"  \x1b[33;1m⚠ {message}\x1b[m");
+            project.AddBuildMessage(MessageSeverity.Warning, $"⚠ {message}");
         }
     }
 
+    /// <summary>
+    /// The <see cref="IEventSource.ErrorRaised"/> callback.
+    /// </summary>
     private void ErrorRaised(object sender, BuildErrorEventArgs e)
     {
         var buildEventContext = e.BuildEventContext;
-        if (buildEventContext is not null && _notableProjects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
+        if (buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
         {
             string message = EventArgsFormatting.FormatEventMessage(e, false);
-            project.AddBuildMessage($"  \x1b[31;1m❌ {message}\x1b[m");
+            project.AddBuildMessage(MessageSeverity.Error, $"❌ {message}");
         }
     }
 
+    /// <inheritdoc/>
     public void Shutdown()
     {
-        _cts.Cancel();
-        _refresher?.Join();
-
-        if (_originalOutputEncoding is not null)
-        {
-            Console.OutputEncoding = _originalOutputEncoding;
-        }
+        Terminal.Dispose();
     }
 
     /// <summary>
diff --git a/src/MSBuild/LiveLogger/Project.cs b/src/MSBuild/LiveLogger/Project.cs
index 3e630d41a06..cd892661cc4 100644
--- a/src/MSBuild/LiveLogger/Project.cs
+++ b/src/MSBuild/LiveLogger/Project.cs
@@ -2,32 +2,62 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.CodeDom;
 using System.Collections.Generic;
 using System.Diagnostics;
 
 namespace Microsoft.Build.Logging.LiveLogger;
 
+/// <summary>
+/// Represents a project being built.
+/// </summary>
 internal sealed class Project
 {
     /// <summary>
-    /// A stopwatch to time the build of this project.
+    /// Initialized a new <see cref="Project"/> with the given <paramref name="targetFramework"/>.
+    /// </summary>
+    /// <param name="targetFramework">The target framework of the project or null if not multi-targeting.</param>
+    public Project(string? targetFramework)
+    {
+        TargetFramework = targetFramework;
+    }
+
+    /// <summary>
+    /// A stopwatch to time the build of the project.
     /// </summary>
     public Stopwatch Stopwatch { get; } = Stopwatch.StartNew();
 
     /// <summary>
-    /// The full path to the primary output of the project, if known.
+    /// Full path to the primary output of the project, if known.
     /// </summary>
     public ReadOnlyMemory<char>? OutputPath { get; set; }
 
+    /// <summary>
+    /// The target framework of the project or null if not multi-targeting.
+    /// </summary>
+    public string? TargetFramework { get; }
+
     /// <summary>
     /// A lazily initialized list of build messages/warnings/errors raised during the build.
     /// </summary>
-    public List<string>? BuildMessages { get; private set; }
+    public List<BuildMessage>? BuildMessages { get; private set; }
 
-    public void AddBuildMessage(string message)
+    /// <summary>
+    /// Adds a build message of the given severity to <see cref="BuildMessages"/>.
+    /// </summary>
+    public void AddBuildMessage(MessageSeverity severity, string message)
     {
-        BuildMessages ??= new List<string>();
-        BuildMessages.Add(message);
+        BuildMessages ??= new List<BuildMessage>();
+        BuildMessages.Add(new BuildMessage(severity, message));
     }
 }
+
+/// <summary>
+/// Enumerates the supported message severities.
+/// </summary>
+internal enum MessageSeverity { Warning, Error }
+
+/// <summary>
+/// Represents a piece of diagnostic output (message/warning/error).
+/// </summary>
+internal record struct BuildMessage(MessageSeverity Severity, string Message)
+{ }
diff --git a/src/MSBuild/LiveLogger/Terminal.cs b/src/MSBuild/LiveLogger/Terminal.cs
new file mode 100644
index 00000000000..05909c5c94f
--- /dev/null
+++ b/src/MSBuild/LiveLogger/Terminal.cs
@@ -0,0 +1,141 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Text;
+
+namespace Microsoft.Build.Logging.LiveLogger;
+
+/// <summary>
+/// An <see cref="ITerminal"/> implementation for ANSI/VT100 terminals.
+/// </summary>
+internal sealed class Terminal : ITerminal
+{
+    /// <summary>
+    /// The encoding read from <see cref="Console.OutputEncoding"/> when the terminal is instantiated.
+    /// </summary>
+    private readonly Encoding _originalOutputEncoding;
+
+    /// <summary>
+    /// A string buffer used with <see cref="BeginUpdate"/>/<see cref="EndUpdate"/>.
+    /// </summary>
+    private readonly StringBuilder _outputBuilder = new();
+
+    /// <summary>
+    /// True if <see cref="BeginUpdate"/> was called and <c>Write*</c> methods are buffering instead of directly printing.
+    /// </summary>
+    private bool _isBuffering = false;
+
+    public Terminal()
+    {
+        _originalOutputEncoding = Console.OutputEncoding;
+        Console.OutputEncoding = Encoding.UTF8;
+    }
+
+    /// <inheritdoc/>
+    public void BeginUpdate()
+    {
+        if (_isBuffering)
+        {
+            throw new InvalidOperationException();
+        }
+        _isBuffering = true;
+    }
+
+    /// <inheritdoc/>
+    public void EndUpdate()
+    {
+        if (!_isBuffering)
+        {
+            throw new InvalidOperationException();
+        }
+        _isBuffering = false;
+
+        Console.Write(_outputBuilder.ToString());
+        _outputBuilder.Clear();
+    }
+
+    /// <inheritdoc/>
+    public void Write(string text)
+    {
+        if (_isBuffering)
+        {
+            _outputBuilder.Append(text);
+        }
+        else
+        {
+            Console.Write(text);
+        }
+    }
+
+    /// <inheritdoc/>
+    public void WriteLine(string text)
+    {
+        if (_isBuffering)
+        {
+            _outputBuilder.AppendLine(text);
+        }
+        else
+        {
+            Console.WriteLine(text);
+        }
+    }
+
+    /// <inheritdoc/>
+    public void WriteLine(ReadOnlySpan<char> text)
+    {
+        if (_isBuffering)
+        {
+            _outputBuilder.Append(text);
+            _outputBuilder.AppendLine();
+        }
+        else
+        {
+            Console.Out.WriteLine(text);
+        }
+    }
+
+    /// <inheritdoc/>
+    public void WriteLineFitToWidth(ReadOnlySpan<char> input)
+    {
+        WriteLine(input.Slice(0, Math.Min(input.Length, Console.BufferWidth - 1)));
+    }
+
+    /// <inheritdoc/>
+    public void WriteColor(TerminalColor color, string text)
+    {
+        if (_isBuffering)
+        {
+            _outputBuilder
+                .Append("\x1b[")
+                .Append((int)color)
+                .Append(";1m")
+                .Append(text)
+                .Append("\x1b[m");
+        }
+        else
+        {
+            Write($"\x1b[{(int)color};1m{text}\x1b[m");
+        }
+    }
+
+    /// <inheritdoc/>
+    public void WriteColorLine(TerminalColor color, string text)
+    {
+        if (_isBuffering)
+        {
+            WriteColor(color, text);
+            _outputBuilder.AppendLine();
+        }
+        else
+        {
+            WriteLine($"\x1b[{(int)color};1m{text}\x1b[m");
+        }
+    }
+
+    /// <inheritdoc/>
+    public void Dispose()
+    {
+        Console.OutputEncoding = _originalOutputEncoding;
+    }
+}
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index dfc4ad2021c..0afe367f2c1 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -172,7 +172,8 @@
     <Compile Include="DistributedLoggerRecord.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="LiveLogger\*.cs" />
+    <!-- LiveLogger is supported only in Core builds -->
+    <Compile Include="LiveLogger\*.cs" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'" />
     <Compile Include="InitializationException.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -189,8 +190,6 @@
     <Compile Include="XMake.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <!-- LiveLogger is supported only in Core builds -->
-    <Compile Remove="LiveLogger\**\*.*" Condition="'$(TargetFrameworkIdentifier)' != '.NETCoreApp'" />
     <!-- This is to enable CodeMarkers in MSBuild.exe -->
     <!-- Win32 RC Files -->
     <RCResourceFile Include="native.rc" />
