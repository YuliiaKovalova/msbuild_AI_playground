diff --git a/.exp-insertions.yml b/.exp-insertions.yml
index 2c8a1c06a1a..acee0786cb0 100644
--- a/.exp-insertions.yml
+++ b/.exp-insertions.yml
@@ -166,7 +166,8 @@ jobs:
       Write-Host "Detected drop.exe path: $dropExePath"
 
       Write-Host "Downloading VS msbuild"
-      & "$dropExePath" get --patAuthEnvVar 'cloudbuild-token' -u "$(MSBuildDropPath)\$(VSVersion)" -d "$(System.ArtifactsDirectory)/VSMSBuildDrop"
+      $patAuthEnvVar = "SYSTEM_ACCESSTOKEN"
+      & "$dropExePath" get --patAuthEnvVar $patAuthEnvVar -u "$(MSBuildDropPath)\$(VSVersion)" -d "$(System.ArtifactsDirectory)/VSMSBuildDrop"
       Write-Host "Download of VS msbuild finished"
 
       Write-Host "Copying VS msbuild to $(Pipeline.Workspace)/VSMSBuild"
@@ -174,7 +175,7 @@ jobs:
       Write-Host "Copy of VS msbuild finished"
     displayName: Download msbuild vs drop
     env:
-      cloudbuild-token: $(cloudbuild-token)
+      SYSTEM_ACCESSTOKEN: $(System.AccessToken)
 
   - task: DownloadBuildArtifacts@1
     inputs:
diff --git a/MSBuild.sln b/MSBuild.sln
index d1daf054f9e..258d1a5c5d7 100644
--- a/MSBuild.sln
+++ b/MSBuild.sln
@@ -82,6 +82,8 @@ Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.UnitTests.S
 EndProject
 Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.BuildCheck.UnitTests", "src\BuildCheck.UnitTests\Microsoft.Build.BuildCheck.UnitTests.csproj", "{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}"
 EndProject
+Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.Templates", "template_feed\Microsoft.Build.Templates.csproj", "{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
@@ -890,6 +892,30 @@ Global
 		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|x64.Build.0 = Release|x64
 		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|x86.ActiveCfg = Release|Any CPU
 		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|x86.Build.0 = Release|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Debug|ARM64.Build.0 = Debug|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Debug|x64.ActiveCfg = Debug|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Debug|x64.Build.0 = Debug|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Debug|x86.ActiveCfg = Debug|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Debug|x86.Build.0 = Debug|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.MachineIndependent|x64.ActiveCfg = MachineIndependent|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.MachineIndependent|x64.Build.0 = MachineIndependent|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Release|Any CPU.Build.0 = Release|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Release|ARM64.Build.0 = Release|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Release|x64.ActiveCfg = Release|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Release|x64.Build.0 = Release|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Release|x86.ActiveCfg = Release|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Release|x86.Build.0 = Release|Any CPU
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
diff --git a/documentation/release-checklist.md b/documentation/release-checklist.md
new file mode 100644
index 00000000000..4f00f360e55
--- /dev/null
+++ b/documentation/release-checklist.md
@@ -0,0 +1,78 @@
+# MSBuild Release Checklist {{THIS_RELEASE_VERSION}}
+
+## At any time
+
+- [ ] Create a new issue to track the release checklist, with this checklist copied into the issue.
+  - [ ] Replace `{{PREVIOUS_RELEASE_VERSION}}` with the previous release version, for example `17.9`
+  - [ ] Replace `{{THIS_RELEASE_VERSION}}` with the current release version, for example `17.10`
+  - [ ] Replace `{{NEXT_VERSION}}` with the next release version, for example `17.11`
+- [ ]  Create `vs{{THIS_RELEASE_VERSION}}` branch
+- [ ]  Create darc channel for `VS {{NEXT_VERSION}}` if it doesn't already exist \
+`darc add-channel --name "VS {{NEXT_VERSION}}"`
+- [ ]  Ping internal "First Responders" Teams channel to get the new channel made available as a promotion target (e.g. dotnet/arcade#12150): {{URL_OF_CHANNEL_PROMOTION_PR}}
+
+## At release time
+
+- [ ] If the release is being cut more than a few days before the VS-side snap, do these two steps. Otherwise check them off.
+  - [ ]  Modify the VS insertion so that it flows from MSBuild `vs{{THIS_RELEASE_VERSION}}` to VS `main` [in the MSBuild-release-branch release definition](https://dev.azure.com/devdiv/DevDiv/_release?definitionId=1319&view=mine&_a=releases) Edit -> Schedule set under Artifacts -> disable toggle
+AND
+  - [ ]  Disable automated run of [the MSBuild-main-branch release definition](https://dev.azure.com/devdiv/DevDiv/_release?definitionId=2153&view=mine&_a=releases) (because our {{NEXT_VERSION}} builds don't have a place to go in VS yet)
+- [ ]  Remove the `main` to old release channel ({{THIS_RELEASE_VERSION}}) default channel \
+`darc delete-default-channel --repo https://github.com/dotnet/msbuild --branch main --channel "VS {{THIS_RELEASE_VERSION}}"`
+- [ ]  Associate the `main` branch with the next release channel \
+`darc add-default-channel  --channel "VS {{THIS_RELEASE_VERSION}}" --branch main --repo https://github.com/dotnet/msbuild`
+- [ ]  Check subscriptions for the forward-looking channel `VS {{NEXT_VERSION}}` and update as necessary (for instance, SDK's `main` branch should usually be updated, whereas release branches often should not be \
+`darc get-subscriptions --exact --source-repo https://github.com/dotnet/msbuild --channel "VS {{THIS_RELEASE_VERSION}}"`
+- [ ]  Update channel VS {{THIS_RELEASE_VERSION}} to VS {{NEXT_VERSION}} for the sdk main subscription and any others from the previous step
+`darc update-subscription --id sdk_main_branch_id`
+- [ ]  Ensure that the current release channel `VS {{THIS_RELEASE_VERSION}}` is associated with the correct release branch\
+`darc get-default-channels --source-repo https://github.com/dotnet/msbuild --branch vs{{THIS_RELEASE_VERSION}}` \
+if it is not, `darc add-default-channel  --channel "VS {{THIS_RELEASE_VERSION}}" --branch vs{{THIS_RELEASE_VERSION}} --repo https://github.com/dotnet/msbuild`
+- [ ]  If the branch was created before the fork: fast-forward merge the correct commit (the one that is currently inserted to VS main) to the `vs{{THIS_RELEASE_VERSION}}` branch \
+e.g.: `git push upstream 2e6f2ff7ea311214255b6b2ca5cc0554fba1b345:refs/heads/vs17.10` \
+_(This is for the case where we create the branch too early and want it to be based actually on a different commit. If you waited until a good point in time with `main` in a clean state, just branch off and you are done. The branch should point to a good, recent spot, so the final-branding PR goes in on top of the right set of commits.)_
+- [ ]  Update the branch merge flow in `dotnet/versions` to have the currently-in-servicing branches: {{URL_OF_VERSIONS_PR}}
+- [ ]  Fix OptProf data flow for the new vs{{THIS_RELEASE_VERSION}} branch
+  - [ ] Manually run [OptProf data collection](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=17389) pipeline for vs{{THIS_RELEASE_VERSION}} ('Run pipeline' in upper right)
+  - [ ] Run the [official build](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=9434) for vs{{THIS_RELEASE_VERSION}} without OptProf (set `SkipApplyOptimizationData` variable in 'Advanced options' section of the 'Run pipeline' menu to `true`)
+  - [ ] Run the [official build](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=9434) for vs{{THIS_RELEASE_VERSION}} with no extra customization - OptProf should succeed now
+- [ ]  Create {{NEXT_VERSION}} branding PR (in main): {{URL_OF_NEXT_VERSION_BRANDING_PR}}
+- [ ]  Create {{THIS_RELEASE_VERSION}} localization ticket: https://aka.ms/ceChangeLocConfig (requesting to add localization for {{THIS_RELEASE_VERSION}}): {{URL_OF_LOCALIZATION_TICKET}}
+https://ceapex.visualstudio.com/CEINTL/_workitems/edit/957875 (DONE)
+- [ ]  Enable {{THIS_RELEASE_VERSION}} localization - by setting [`EnableReleaseOneLocBuild`](https://github.com/dotnet/msbuild/blob/vs{{THIS_RELEASE_VERSION}}/.vsts-dotnet.yml) to `true`
+- [ ]  Disable {{PREVIOUS_RELEASE_VERSION}} localization -  by setting [`EnableReleaseOneLocBuild`](https://github.com/dotnet/msbuild/blob/vs{{PREVIOUS_RELEASE_VERSION}}/.vsts-dotnet.yml) to `false` clarify with @JanKrivanek
+- [ ]  Merge {{NEXT_VERSION}} branding PR
+- [ ]  Create and merge PR including public API baseline package version change (see https://github.com/dotnet/msbuild/pull/8116#discussion_r1049386978): #8949
+- [ ]  When VS main snaps to {{THIS_RELEASE_VERSION}} and updates its version to {{NEXT_VERSION}}, modify the VS insertion so that it flows from MSBuild main to VS main.
+- [ ]  Create {{PREVIOUS_RELEASE_VERSION}} localization ticket: https://aka.ms/ceChangeLocConfig (requesting to remove localization for {{PREVIOUS_RELEASE_VERSION}})
+{{URL_OF_LOCALIZATION_DISABLE_TICKET}}
+- [ ]  Remove MSBuild main from the experimental VS insertion flow.
+- [ ]  Update the [release-branch insertion release definition](https://dev.azure.com/devdiv/DevDiv/_releaseDefinition?definitionId=2153&_a=definition-variables) to have `InsertTargetBranch` `rel/d{{THIS_RELEASE_VERSION}}`.
+- [ ]  Turn [the release pipeline](https://dev.azure.com/devdiv/DevDiv/_release?definitionId=2153&view=mine&_a=releases) back on.
+- [ ]  Prepare final branding PR for `vs{{THIS_RELEASE_VERSION}}`: {{URL_OF_FINAL_BRANDING_PR}}
+- [ ]  Merge final branding to `vs{{THIS_RELEASE_VERSION}}` branch
+- [ ]  Update perfstar MSBuild insertions configuration: [example PR](https://dev.azure.com/devdiv/DevDiv/_git/dotnet-perfstar/pullrequest/522843): {{URL_OF_PERFSTAR_PR}}
+- [ ] Note down the build (will be helpful for requesting nuget packages publishing): {{URL_OF_BUILD}}
+- [ ] Get M2 or QB approval as necessary per the VS schedule
+- [ ]  Merge to VS (babysit the automatically generated VS insertion PR https://devdiv.visualstudio.com/DevDiv/_git/VS/pullrequests for the MSBuild commit noted in above step): {{URL_OF_VS_INSERTION}}
+- [ ] Update the PackageValidationBaselineVersion to the latest released version ({{THIS_RELEASE_VERSION}}.0) - this might require temporary addition of the [build artifacts feed](https://github.com/dotnet/msbuild/blob/29397b577e3ec0fe0c7650c3ab0400909655dc88/NuGet.config#L9) as the new version is not yet added to the official feeds (this is post release). This can trigger a high severity CG error (https://eng.ms/docs/cloud-ai-platform/devdiv/one-engineering-system-1es/1es-docs/secure-supply-chain/how-to-securely-configure-package-source-files) - however it should be fine to keep this temporary feed untill the release.
+
+## ASAP On/After GA:
+
+Timing based on the [(Microsoft-internal) release schedule](https://dev.azure.com/devdiv/DevDiv/_wiki/wikis/DevDiv.wiki/10097/Dev17-Release).
+
+- [ ]  Push packages to nuget.org (not currently automated, contact dnceng - search "Publish MSBuild 17.6 to NuGet.org" email subject for template).
+- [ ]  Publish docs: submit reference request at https://aka.ms/publishondocs
+  - Click on the link labeled *Request – Reference Publishing*
+  - You can use existing [ticket](https://dev.azure.com/msft-skilling/Content/_workitems/edit/183613) as a reference
+- [ ] Remove the temporarily added [build feed from `nuget.config`](https://github.com/dotnet/msbuild/blob/29397b577e3ec0fe0c7650c3ab0400909655dc88/NuGet.config#L9) if it was added in the `Update the PackageValidationBaselineVersion` step
+- [ ]  Update `main` subscriptions to the new channel (this can be done before or after release - depending on when the source repos from our previous - VS {{THIS_RELEASE_VERSION}} - channle start to publish in the next - VS {{NEXT_VERSION}} - channel) \
+`darc get-subscriptions --exact --target-repo https://github.com/dotnet/msbuild --target-branch main`
+- [ ]  Create the {{THIS_RELEASE_VERSION}} release
+  - [ ]  Create tag (can be done upfront)
+  ```
+  git checkout <commit noted above>
+  git tag v{{THIS_RELEASE_VERSION}}.3
+  git push upstream v{{THIS_RELEASE_VERSION}}.3
+  ```
+  - [ ]  Create Release in Github with `Create Release from Tag` GH option (https://github.com/dotnet/msbuild/releases/new?tag=v17.9.3) - the release notes can be prepopulated (`Generate Release Notes`)
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 7744d96a090..c30d03cea0f 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -27,6 +27,7 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Log TaskParameterEvent for scalar parameters](https://github.com/dotnet/msbuild/pull/9908)
 - [Convert.ToString during a property evaluation uses the InvariantCulture for all types](https://github.com/dotnet/msbuild/pull/9874)
 - [Fix oversharing of build results in ResultsCache](https://github.com/dotnet/msbuild/pull/9987)
+- [Add ParameterName and PropertyName to TaskParameterEventArgs](https://github.com/dotnet/msbuild/pull/10130)
 
 ### 17.10
 - [AppDomain configuration is serialized without using BinFmt](https://github.com/dotnet/msbuild/pull/9320) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 2d939a0f9d5..e8427285650 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -67,14 +67,14 @@
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.24266.3">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.24270.4">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>e6f70c7dd528f05cd28cec2a179d58c22e91d9ac</Sha>
+      <Sha>f2b2071632d5d4c46d0f904f2b0d917b1752551b</Sha>
     </Dependency>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="8.0.0-beta.24266.3">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="8.0.0-beta.24270.4">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>e6f70c7dd528f05cd28cec2a179d58c22e91d9ac</Sha>
+      <Sha>f2b2071632d5d4c46d0f904f2b0d917b1752551b</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.23475.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
@@ -87,18 +87,18 @@
       <Sha>73f0850939d96131c28cf6ea6ee5aacb4da0083a</Sha>
       <SourceBuild RepoName="xliff-tasks" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.10.0-preview.2.97">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.11.0-preview.2.76">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>fb50d1a45ed10b39b5f335bc3a4bdcaea9b951cf</Sha>
+      <Sha>f1525fc4017aab865deb9325b5f53aac2d8c4cf4</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.10.0-3.24259.10">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.11.0-3.24301.1">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>6a0e23ee35042a881060eb97dea37dd7cc51db88</Sha>
+      <Sha>37b70f27ecf6578ad0b74d04406036b03ab90c8f</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.24266.3">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.24270.4">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>e6f70c7dd528f05cd28cec2a179d58c22e91d9ac</Sha>
+      <Sha>f2b2071632d5d4c46d0f904f2b0d917b1752551b</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 36fb2fe10bd..5ad30966449 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -48,11 +48,11 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.24266.3</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.24270.4</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.10.0-3.24259.10</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.10.0-preview.2.97</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.11.0-3.24301.1</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.11.0-preview.2.76</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
diff --git a/global.json b/global.json
index e798a223e55..a2815a8c542 100644
--- a/global.json
+++ b/global.json
@@ -10,6 +10,6 @@
     "xcopy-msbuild": "17.8.5"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.24266.3"
+    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.24270.4"
   }
 }
diff --git a/src/Build.UnitTests/BackEnd/BatchingEngine_Tests.cs b/src/Build.UnitTests/BackEnd/BatchingEngine_Tests.cs
index 8cfb2d4a575..a2a74564bb9 100644
--- a/src/Build.UnitTests/BackEnd/BatchingEngine_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BatchingEngine_Tests.cs
@@ -7,6 +7,7 @@
 using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -52,7 +53,11 @@ public void GetBuckets()
             properties.Set(ProjectPropertyInstance.Create("UnitTests", "unittests.foo"));
             properties.Set(ProjectPropertyInstance.Create("OBJ", "obj"));
 
-            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(parameters, CreateLookup(itemsByType, properties), MockElementLocation.Instance);
+            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(
+                parameters,
+                CreateLookup(itemsByType, properties),
+                MockElementLocation.Instance,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
 
             Assert.Equal(5, buckets.Count);
 
@@ -62,7 +67,14 @@ public void GetBuckets()
                 XmlAttribute tempXmlAttribute = (new XmlDocument()).CreateAttribute("attrib");
                 tempXmlAttribute.Value = "'$(Obj)'=='obj'";
 
-                Assert.True(ConditionEvaluator.EvaluateCondition(tempXmlAttribute.Value, ParserOptions.AllowAll, bucket.Expander, ExpanderOptions.ExpandAll, Directory.GetCurrentDirectory(), MockElementLocation.Instance, null, new BuildEventContext(1, 2, 3, 4), FileSystems.Default));
+                Assert.True(ConditionEvaluator.EvaluateCondition(
+                    tempXmlAttribute.Value,
+                    ParserOptions.AllowAll,
+                    bucket.Expander, ExpanderOptions.ExpandAll,
+                    Directory.GetCurrentDirectory(),
+                    MockElementLocation.Instance,
+                    FileSystems.Default,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4))));
                 Assert.Equal("a.doc;b.doc;c.doc;d.doc;e.doc", bucket.Expander.ExpandIntoStringAndUnescape("@(doc)", ExpanderOptions.ExpandItems, MockElementLocation.Instance));
                 Assert.Equal("unittests.foo", bucket.Expander.ExpandIntoStringAndUnescape("$(bogus)$(UNITTESTS)", ExpanderOptions.ExpandPropertiesAndMetadata, MockElementLocation.Instance));
             }
@@ -130,7 +142,11 @@ public void ValidUnqualifiedMetadataReference()
 
             PropertyDictionary<ProjectPropertyInstance> properties = new PropertyDictionary<ProjectPropertyInstance>();
 
-            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(parameters, CreateLookup(itemsByType, properties), null);
+            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(
+                parameters,
+                CreateLookup(itemsByType, properties),
+                null,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
             Assert.Equal(2, buckets.Count);
         }
 
@@ -164,7 +180,11 @@ public void InvalidUnqualifiedMetadataReference()
 
                 // This is expected to throw because not all items contain a value for metadata "Culture".
                 // Only a.foo has a Culture metadata.  b.foo does not.
-                BatchingEngine.PrepareBatchingBuckets(parameters, CreateLookup(itemsByType, properties), MockElementLocation.Instance);
+                BatchingEngine.PrepareBatchingBuckets(
+                    parameters,
+                    CreateLookup(itemsByType, properties),
+                    MockElementLocation.Instance,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
             });
         }
         /// <summary>
@@ -185,7 +205,11 @@ public void NoItemsConsumed()
                 PropertyDictionary<ProjectPropertyInstance> properties = new PropertyDictionary<ProjectPropertyInstance>();
 
                 // This is expected to throw because we have no idea what item list %(Culture) refers to.
-                BatchingEngine.PrepareBatchingBuckets(parameters, CreateLookup(itemsByType, properties), MockElementLocation.Instance);
+                BatchingEngine.PrepareBatchingBuckets(
+                    parameters,
+                    CreateLookup(itemsByType, properties),
+                    MockElementLocation.Instance,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
             });
         }
         /// <summary>
@@ -211,7 +235,11 @@ public void Regress_Mutation_DuplicateBatchingBucketsAreFoldedTogether()
 
             PropertyDictionary<ProjectPropertyInstance> properties = new PropertyDictionary<ProjectPropertyInstance>();
 
-            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(parameters, CreateLookup(itemsByType, properties), null);
+            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(
+                parameters,
+                CreateLookup(itemsByType, properties),
+                null,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
 
             // If duplicate buckets have been folded correctly, then there will be exactly one bucket here
             // containing both a.foo and b.foo.
@@ -463,6 +491,41 @@ public void UndefinedAndEmptyMetadataValues()
             logger.AssertLogContains("[i1;i2 ]", "[i3 m1]");
         }
 
+        /// <summary>
+        /// This is a regression test for https://github.com/dotnet/msbuild/issues/10180.
+        /// </summary>
+        [Fact]
+        public void HandlesEarlyExitFromTargetBatching()
+        {
+            string content = @"
+                <Project>
+                    <ItemGroup>
+                        <Example Include='Item1'>
+                            <Color>Blue</Color>
+                        </Example>
+                        <Example Include='Item2'>
+                            <Color>Red</Color>
+                        </Example>
+                    </ItemGroup>
+
+                    <Target Name='Build'
+                        Inputs='@(Example)'
+                        Outputs='%(Color)\MyFile.txt'>
+                        <NonExistentTask
+                            Text = '@(Example)'
+                            Output = '%(Color)\MyFile.txt'/>
+                    </Target>
+                </Project>
+                ";
+
+            Project project = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(content))));
+            MockLogger logger = new MockLogger();
+            project.Build(logger);
+
+            // Build should fail with error MSB4036: The "NonExistentTask" task was not found.
+            logger.AssertLogContains("MSB4036");
+        }
+
         private static Lookup CreateLookup(ItemDictionary<ProjectItemInstance> itemsByType, PropertyDictionary<ProjectPropertyInstance> properties)
         {
             return new Lookup(itemsByType, properties);
diff --git a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
index 66a27a4e9d6..f94ef7e8ec0 100644
--- a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
@@ -83,7 +83,7 @@ public void TestConstructorNullTarget()
                 BuildRequestConfiguration config = new BuildRequestConfiguration(1, new BuildRequestData("foo", new Dictionary<string, string>(), "foo", Array.Empty<string>(), null), "2.0");
                 BuildRequestEntry requestEntry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "foo" }), config);
                 Lookup lookup = new Lookup(new ItemDictionary<ProjectItemInstance>(project.Items), new PropertyDictionary<ProjectPropertyInstance>(project.Properties));
-                TargetEntry entry = new TargetEntry(requestEntry, this, null, lookup, null, TargetBuiltReason.None, _host, false);
+                TargetEntry entry = new TargetEntry(requestEntry, this, null, lookup, null, TargetBuiltReason.None, _host, null, false);
             });
         }
         /// <summary>
@@ -97,7 +97,7 @@ public void TestConstructorNullLookup()
                 ProjectInstance project = CreateTestProject(true /* Returns enabled */);
                 BuildRequestConfiguration config = new BuildRequestConfiguration(1, new BuildRequestData("foo", new Dictionary<string, string>(), "foo", Array.Empty<string>(), null), "2.0");
                 BuildRequestEntry requestEntry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "foo" }), config);
-                TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification("Empty", null), null, null, TargetBuiltReason.None, _host, false);
+                TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification("Empty", null), null, null, TargetBuiltReason.None, _host, null, false);
             });
         }
         /// <summary>
@@ -113,7 +113,7 @@ public void TestConstructorNullHost()
                 BuildRequestEntry requestEntry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "foo" }), config);
 
                 Lookup lookup = new Lookup(new ItemDictionary<ProjectItemInstance>(project.Items), new PropertyDictionary<ProjectPropertyInstance>(project.Properties));
-                TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification("Empty", null), lookup, null, TargetBuiltReason.None, null, false);
+                TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification("Empty", null), lookup, null, TargetBuiltReason.None, null, null, false);
             });
         }
         /// <summary>
@@ -1025,7 +1025,7 @@ private TargetEntry CreateStandardTargetEntry(ProjectInstance project, string ta
             BuildRequestEntry requestEntry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "foo" }), config);
 
             Lookup lookup = new Lookup(new ItemDictionary<ProjectItemInstance>(project.Items), new PropertyDictionary<ProjectPropertyInstance>(project.Properties));
-            TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification(targetName, project.Targets[targetName].Location), lookup, null, TargetBuiltReason.None, _host, false);
+            TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification(targetName, project.Targets[targetName].Location), lookup, null, TargetBuiltReason.None, _host, null, false);
             return entry;
         }
 
@@ -1041,7 +1041,7 @@ private TargetEntry CreateStandardTargetEntry(ProjectInstance project, string ta
             BuildRequestConfiguration config = new BuildRequestConfiguration(1, new BuildRequestData("foo", new Dictionary<string, string>(), "foo", Array.Empty<string>(), null), "2.0");
             config.Project = project;
             BuildRequestEntry requestEntry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[1] { "foo" }), config);
-            TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification(target, project.Targets[target].Location), baseEntry.Lookup, baseEntry, TargetBuiltReason.None, _host, false);
+            TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification(target, project.Targets[target].Location), baseEntry.Lookup, baseEntry, TargetBuiltReason.None, _host, null, false);
             return entry;
         }
 
diff --git a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
index cd2a93acc25..d764e74ffc5 100644
--- a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
@@ -570,6 +570,7 @@ private DependencyAnalysisResult PerformDependencyAnalysisTestHelper(
 
                 // now do the dependency analysis
                 ItemBucket itemBucket = new ItemBucket(null, null, new Lookup(itemsByName, new PropertyDictionary<ProjectPropertyInstance>()), 0);
+                itemBucket.Initialize(null);
                 TargetUpToDateChecker analyzer = new TargetUpToDateChecker(p, p.Targets["Build"], _mockHost, BuildEventContext.Invalid);
 
                 return analyzer.PerformDependencyAnalysis(itemBucket, false, out changedTargetInputs, out upToDateTargetInputs);
diff --git a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
index ba22e2beed0..cdd57796d4d 100644
--- a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
@@ -1284,6 +1284,7 @@ private void InitializeHost(bool throwOnExecute)
             _twoItems = new ITaskItem[] { new TaskItem(item), new TaskItem(item2) };
 
             _bucket = new ItemBucket(Array.Empty<string>(), new Dictionary<string, string>(), new Lookup(itemsByName, new PropertyDictionary<ProjectPropertyInstance>()), 0);
+            _bucket.Initialize(null);
             _host.FindTask(null);
             _host.InitializeForBatch(talc, _bucket, null);
             _parametersSetOnTask = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
diff --git a/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs b/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
index 1e8bcaf1f14..91d8bec792d 100644
--- a/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Engine.UnitTests.TestComparers;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -2184,8 +2185,7 @@ internal TaskRegistry CreateTaskRegistryAndRegisterTasks(List<ProjectUsingTaskEl
 
             string currentDir = Directory.GetCurrentDirectory();
             TaskRegistry.InitializeTaskRegistryFromUsingTaskElements(
-                _loggingService,
-                _loggerContext,
+                _targetLoggingContext,
                 usingTaskElements.Select(el => (el, currentDir)),
                 registry,
                 RegistryExpander,
@@ -2249,7 +2249,11 @@ internal static Expander<ProjectPropertyInstance, ProjectItemInstance> GetExpand
             secondaryItemsByName.ImportItems(thirdItemGroup);
             secondaryItemsByName.ImportItems(trueItemGroup);
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, secondaryItemsByName, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(
+                pg,
+                secondaryItemsByName,
+                FileSystems.Default,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
             return expander;
         }
 
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index cb60a9f2d42..bd03a54d29a 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -650,12 +650,14 @@ public void RoundtripTaskParameterEventArgs()
                 new TaskItemData("ItemSpec1", null),
                 new TaskItemData("ItemSpec2", Enumerable.Range(1,3).ToDictionary(i => i.ToString(), i => i.ToString() + "value"))
             };
-            var args = new TaskParameterEventArgs(TaskParameterMessageKind.TaskOutput, "ItemName", items, true, DateTime.MinValue);
+            var args = new TaskParameterEventArgs(TaskParameterMessageKind.TaskOutput, "ParameterName1", "PropertyName1", "ItemName1", items, true, DateTime.MinValue);
             args.LineNumber = 265;
             args.ColumnNumber = 6;
 
             Roundtrip(args,
                 e => e.Kind.ToString(),
+                e => e.ParameterName,
+                e => e.PropertyName,
                 e => e.ItemType,
                 e => e.LogItemMetadata.ToString(),
                 e => e.LineNumber.ToString(),
diff --git a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
index b33fd7a00ce..f9157225a69 100644
--- a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
@@ -6,8 +6,10 @@
 using System.IO;
 using System.Text.RegularExpressions;
 using System.Xml;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -34,9 +36,9 @@ public void OverrideTasksAreFoundInOverridePath()
             string overrideDir = NativeMethodsShared.IsWindows ? "c:\\msbuildoverridetasks" : "/msbuildoverridetasks";
             Toolset t = new Toolset("toolsversionname", dir, new PropertyDictionary<ProjectPropertyInstance>(), new ProjectCollection(), new DirectoryGetFiles(this.getFiles), new LoadXmlFromPath(this.loadXmlFromPath), overrideDir, new DirectoryExists(this.directoryExists));
 
-            LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
-            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
-            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
+            LoggingContext loggingContext = TestLoggingContext.CreateTestContext(new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
+            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, e.ProjectRootElementCache);
+            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(loggingContext, e.ProjectRootElementCache);
 
             string[] expectedRegisteredTasks = { "a1", "a2", "a3", "a4", "b1", "e1", "g1", "g2", "g3" };
             string[] expectedOverrideTasks = { "a1" /* special because it is in the override tasks file as well as in the tasks file*/, "oa1", "oa2", "og1", "ooo" };
@@ -79,8 +81,10 @@ public void OverrideTaskPathIsRelative()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
+
 
-            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
+            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(loggingContext, e.ProjectRootElementCache);
             Assert.NotNull(taskoverrideRegistry);
             Assert.Empty(taskoverrideRegistry.TaskRegistrations);
             string rootedPathMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OverrideTaskNotRootedPath", "msbuildoverridetasks");
@@ -96,8 +100,9 @@ public void OverrideTaskPathHasInvalidChars()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
 
-            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
+            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(loggingContext, e.ProjectRootElementCache);
             Assert.NotNull(taskoverrideRegistry);
             Assert.Empty(taskoverrideRegistry.TaskRegistrations);
             mockLogger.AssertLogContains("MSB4194");
@@ -113,8 +118,9 @@ public void OverrideTaskPathHasTooLongOfAPath()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
 
-            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
+            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(loggingContext, e.ProjectRootElementCache);
             Assert.NotNull(taskoverrideRegistry);
             Assert.Empty(taskoverrideRegistry.TaskRegistrations);
             string rootedPathMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OverrideTaskNotRootedPath", tooLong);
@@ -131,8 +137,9 @@ public void OverrideTaskPathIsNotFound()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
 
-            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
+            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(loggingContext, e.ProjectRootElementCache);
             Assert.NotNull(taskoverrideRegistry);
             Assert.Empty(taskoverrideRegistry.TaskRegistrations);
             string rootedPathMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OverrideTaskNotRootedPath", "k:\\Thecatinthehat");
@@ -153,7 +160,8 @@ public void DefaultTasksAreFoundInToolsPath()
                 null,
                 new DirectoryExists(this.directoryExists));
 
-            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(null, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
+            LoggingContext loggingContext = TestLoggingContext.CreateTestContext(new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
+            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
 
             string[] expectedRegisteredTasks = { "a1", "a2", "a3", "a4", "b1", "e1", "g1", "g2", "g3" };
             string[] unexpectedRegisteredTasks = { "c1", "d1", "f1", "11", "12", "13", "21" };
@@ -178,10 +186,11 @@ public void WarningLoggedIfNoDefaultTasksFound()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, BuildEventContext.Invalid);
 
             Toolset t = new Toolset("toolsversionname", "c:\\directory1\\directory2\\doesntexist", new PropertyDictionary<ProjectPropertyInstance>(), new ProjectCollection(), new DirectoryGetFiles(this.getFiles), new LoadXmlFromPath(this.loadXmlFromPath), null, new DirectoryExists(this.directoryExists));
 
-            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(service, BuildEventContext.Invalid, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
+            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
 
             string[] unexpectedRegisteredTasks = { "a1", "a2", "a3", "a4", "b1", "c1", "d1", "e1", "f1", "g1", "g2", "g3", "11", "12", "13", "21" };
 
@@ -201,9 +210,10 @@ public void InvalidToolPath()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, BuildEventContext.Invalid);
             Toolset t = new Toolset("toolsversionname", "invalid||path", new PropertyDictionary<ProjectPropertyInstance>(), p, new DirectoryGetFiles(this.getFiles), new LoadXmlFromPath(this.loadXmlFromPath), null, new DirectoryExists(this.directoryExists));
 
-            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(service, BuildEventContext.Invalid, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
+            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
 
             Console.WriteLine(mockLogger.FullLog);
             Assert.Equal(1, mockLogger.WarningCount); // "Expected a warning for invalid character in toolpath"
@@ -221,19 +231,18 @@ public void VerifyTasksFilesAreInSortedOrder()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, BuildEventContext.Invalid);
             string dir = NativeMethodsShared.IsWindows ? "c:\\directory1\\directory2" : "/directory1/directory2";
             string overrideDir = NativeMethodsShared.IsWindows ? "c:\\msbuildoverridetasks" : "/msbuildoverridetasks";
             string[] foundFiles = Toolset.GetTaskFiles(
                 new DirectoryGetFiles(this.getFiles),
-                service,
-                BuildEventContext.Invalid,
+                loggingContext,
                 "*.tasks",
                 dir,
                 String.Empty);
             string[] foundoverrideFiles = Toolset.GetTaskFiles(
                 new DirectoryGetFiles(this.getFiles),
-                service,
-                BuildEventContext.Invalid,
+                loggingContext,
                 "*.overridetasks",
                 overrideDir,
                 String.Empty);
@@ -894,7 +903,9 @@ public void InlineTasksInDotTasksFile()
                 null,
                 new DirectoryExists(directoryExists));
 
-            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(null, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
+            LoggingContext loggingContext = TestLoggingContext.CreateTestContext(new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
+
+            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
 
             // Did not crash due to trying to expand items without having items
         }
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 286d08a84a5..ce49dc0d6b7 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -12,6 +12,7 @@
 
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -4385,9 +4386,8 @@ public void VerifyConditionEvaluatorResetStateOnFailure()
                     ExpanderOptions.ExpandProperties,
                     Directory.GetCurrentDirectory(),
                     MockElementLocation.Instance,
-                    null,
-                    new BuildEventContext(1, 2, 3, 4),
-                    FileSystems.Default);
+                    FileSystems.Default,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
                 Assert.True(false, "Expect exception due to the value of property \"TargetOSFamily\" is not a number.");
             }
             catch (InvalidProjectFileException e)
@@ -4404,9 +4404,8 @@ public void VerifyConditionEvaluatorResetStateOnFailure()
                 ExpanderOptions.ExpandProperties,
                 Directory.GetCurrentDirectory(),
                 MockElementLocation.Instance,
-                null,
-                new BuildEventContext(1, 2, 3, 4),
-                FileSystems.Default));
+                FileSystems.Default,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4))));
         }
 
         /// <summary>
@@ -4991,7 +4990,6 @@ public void VerifyLogPropertyReassignment()
                       && r.Message.StartsWith($"{
                           ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
                               "PropertyReassignment", propertyName, propertyNewValue, propertyOldValue, string.Empty)}"));
-                logger.BuildMessageEvents.ShouldBeOfTypes(new[] { typeof(PropertyReassignmentEventArgs) });
             }
         }
 
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index f47f94fd217..25187464656 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -95,7 +95,11 @@ public void ExpandAllIntoTaskItems3()
             itemsByType.ImportItems(ig);
             itemsByType.ImportItems(ig2);
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, itemsByType, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(
+                pg,
+                itemsByType,
+                FileSystems.Default,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
 
             IList<TaskItem> itemsOut = expander.ExpandIntoTaskItemsLeaveEscaped("foo;bar;@(compile);@(resource)", ExpanderOptions.ExpandPropertiesAndItems, MockElementLocation.Instance);
 
@@ -802,7 +806,11 @@ private Expander<ProjectPropertyInstance, ProjectItemInstance> CreateExpander()
             ig.Add(i0);
             ig.Add(i1);
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, ig, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(
+                pg,
+                ig,
+                FileSystems.Default,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
 
             return expander;
         }
@@ -2271,9 +2279,8 @@ public void PropertyFunctionInCondition()
                     ExpanderOptions.ExpandProperties,
                     Directory.GetCurrentDirectory(),
                     MockElementLocation.Instance,
-                    null,
-                    new BuildEventContext(1, 2, 3, 4),
-                    FileSystems.Default));
+                    FileSystems.Default,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4))));
             Assert.True(
                 ConditionEvaluator.EvaluateCondition(
                     @"'$(PathRoot.EndsWith(" + Path.DirectorySeparatorChar + "))' == 'false'",
@@ -2282,9 +2289,8 @@ public void PropertyFunctionInCondition()
                     ExpanderOptions.ExpandProperties,
                     Directory.GetCurrentDirectory(),
                     MockElementLocation.Instance,
-                    null,
-                    new BuildEventContext(1, 2, 3, 4),
-                    FileSystems.Default));
+                    FileSystems.Default,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4))));
         }
 
         /// <summary>
@@ -5083,8 +5089,8 @@ public void PropertyFunctionRegisterBuildCheck()
                     new BuildEventContext(0, 0, BuildEventContext.InvalidProjectContextId, 0, 0));
                 var dummyAssemblyFile = env.CreateFile(env.CreateFolder(), "test.dll");
 
-                var result = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), FileSystems.Default)
-                    .ExpandIntoStringLeaveEscaped($"$([MSBuild]::RegisterBuildCheck({dummyAssemblyFile.Path}))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance, loggingContext);
+                var result = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), FileSystems.Default, loggingContext)
+                    .ExpandIntoStringLeaveEscaped($"$([MSBuild]::RegisterBuildCheck({dummyAssemblyFile.Path}))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
 
                 result.ShouldBe(Boolean.TrueString);
                 _ = logger.AllBuildEvents.Select(be => be.ShouldBeOfType<BuildCheckAcquisitionEventArgs>());
diff --git a/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs b/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
index 856de263ffe..06b32c45258 100644
--- a/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
@@ -4,7 +4,9 @@
 using System.Collections.Generic;
 using System.IO;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.UnitTests.BackEnd;
@@ -87,7 +89,11 @@ private ProjectInstanceExpander CreateExpander(Dictionary<string, string[]> item
         {
             var itemDictionary = ToItemDictionary(items);
 
-            return new ProjectInstanceExpander(new PropertyDictionary<ProjectPropertyInstance>(), itemDictionary, (IFileSystem)FileSystems.Default);
+            return new ProjectInstanceExpander(
+                new PropertyDictionary<ProjectPropertyInstance>(),
+                itemDictionary,
+                (IFileSystem)FileSystems.Default,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
         }
 
         private static ItemDictionary<ProjectItemInstance> ToItemDictionary(Dictionary<string, string[]> itemTypes)
diff --git a/src/Build.UnitTests/Evaluation/UsedUninitializedProperties_Tests.cs b/src/Build.UnitTests/Evaluation/UsedUninitializedProperties_Tests.cs
index 8ede8eec729..f9de1bc6144 100644
--- a/src/Build.UnitTests/Evaluation/UsedUninitializedProperties_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/UsedUninitializedProperties_Tests.cs
@@ -1,6 +1,8 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using Microsoft.Build.Engine.UnitTests;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 
@@ -13,7 +15,7 @@ public sealed class UsedUninitializedProperties_Tests
     [Fact]
     public void Basics()
     {
-        UsedUninitializedProperties props = new();
+        PropertiesUseTracker props = new(TestLoggingContext.CreateTestContext(new BuildEventContext(1, 2, 3, 4)));
 
         Assert.False(props.TryGetPropertyElementLocation("Hello", out IElementLocation? elementLocation));
         Assert.Null(elementLocation);
diff --git a/src/Build.UnitTests/ExpressionTree_Tests.cs b/src/Build.UnitTests/ExpressionTree_Tests.cs
index 70ce8bb76d5..1c730e8d38d 100644
--- a/src/Build.UnitTests/ExpressionTree_Tests.cs
+++ b/src/Build.UnitTests/ExpressionTree_Tests.cs
@@ -99,7 +99,7 @@ public void FunctionTests()
         {
             Parser p = new Parser();
             GenericExpressionNode tree;
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), new ItemDictionary<ProjectItemInstance>(), FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), new ItemDictionary<ProjectItemInstance>(), FileSystems.Default, null);
             expander.Metadata = new StringMetadataTable(null);
             bool value;
 
@@ -149,7 +149,7 @@ public void PropertyTests()
             propertyBag.Set(ProjectPropertyInstance.Create("x86", "x86"));
             propertyBag.Set(ProjectPropertyInstance.Create("no", "no"));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, new ItemDictionary<ProjectItemInstance>(), FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, new ItemDictionary<ProjectItemInstance>(), FileSystems.Default, null);
             AssertParseEvaluate(p, "$(foo)", expander, true);
             AssertParseEvaluate(p, "!$(foo)", expander, false);
             // Test properties with strings
@@ -187,7 +187,7 @@ public void ItemListTests()
             itemBag.Add(new ProjectItemInstance(parentProject, "Compile", "baz.cs", parentProject.FullPath));
             itemBag.Add(new ProjectItemInstance(parentProject, "Boolean", "true", parentProject.FullPath));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), itemBag, FileSystems.Default, null);
 
             AssertParseEvaluate(p, "@(Compile) == 'foo.cs;bar.cs;baz.cs'", expander, true);
             AssertParseEvaluate(p, "@(Compile,' ') == 'foo.cs bar.cs baz.cs'", expander, true);
@@ -230,7 +230,7 @@ public void StringExpansionTests()
             propertyBag.Set(ProjectPropertyInstance.Create("AnotherTestQuote", "Here's Johnny!"));
             propertyBag.Set(ProjectPropertyInstance.Create("Atsign", "Test the @ replacement"));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default, null);
 
             AssertParseEvaluate(p, "'simplestring: true foo.cs;bar.cs;baz.cs' == '$(simple): $(foo) @(compile)'", expander, true);
             AssertParseEvaluate(p, "'$(c1) $(c2)' == 'Another (complex) one. Another (complex) one.'", expander, true);
@@ -262,7 +262,7 @@ public void ComplexTests()
             propertyBag.Set(ProjectPropertyInstance.Create("c1", "Another (complex) one."));
             propertyBag.Set(ProjectPropertyInstance.Create("c2", "Another (complex) one."));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default, null);
 
             AssertParseEvaluate(p, "(($(foo) != 'two' and $(bar)) and 5 >= 1) or $(one) == 1", expander, true);
             AssertParseEvaluate(p, "(($(foo) != 'twoo' or !$(bar)) and 5 >= 1) or $(two) == 1", expander, true);
@@ -283,7 +283,7 @@ public void InvalidItemInConditionEvaluation()
 
             PropertyDictionary<ProjectPropertyInstance> propertyBag = new PropertyDictionary<ProjectPropertyInstance>();
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default, null);
 
             AssertParseEvaluateThrow(p, "@(Compile) > 0", expander, null);
         }
@@ -312,7 +312,7 @@ public void OldSyntaxTests()
             propertyBag.Set(ProjectPropertyInstance.Create("c1", "Another (complex) one."));
             propertyBag.Set(ProjectPropertyInstance.Create("c2", "Another (complex) one."));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default, null);
 
             AssertParseEvaluate(p, "(($(foo) != 'two' and $(bar)) and 5 >= 1) or $(one) == 1", expander, true);
         }
@@ -329,7 +329,7 @@ public void ConditionedPropertyUpdateTests()
             itemBag.Add(new ProjectItemInstance(parentProject, "Compile", "bar.cs", parentProject.FullPath));
             itemBag.Add(new ProjectItemInstance(parentProject, "Compile", "baz.cs", parentProject.FullPath));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), itemBag, FileSystems.Default, null);
             Dictionary<string, List<string>> conditionedProperties = new Dictionary<string, List<string>>();
             ConditionEvaluator.IConditionEvaluationState state =
                                new ConditionEvaluator.ConditionEvaluationState<ProjectPropertyInstance, ProjectItemInstance>(
@@ -416,7 +416,7 @@ public void NotTests()
             propertyBag.Set(ProjectPropertyInstance.Create("foo", "4"));
             propertyBag.Set(ProjectPropertyInstance.Create("bar", "32"));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, new ItemDictionary<ProjectItemInstance>(), FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, new ItemDictionary<ProjectItemInstance>(), FileSystems.Default, null);
 
             AssertParseEvaluate(p, "!true", expander, false);
             AssertParseEvaluate(p, "!(true)", expander, false);
diff --git a/src/Build.UnitTests/TestLoggingContext.cs b/src/Build.UnitTests/TestLoggingContext.cs
new file mode 100644
index 00000000000..756f61b8284
--- /dev/null
+++ b/src/Build.UnitTests/TestLoggingContext.cs
@@ -0,0 +1,27 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Engine.UnitTests
+{
+    internal sealed class TestLoggingContext : LoggingContext
+    {
+        public TestLoggingContext(ILoggingService? loggingService, BuildEventContext eventContext) : base(
+            loggingService ?? Build.BackEnd.Logging.LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1), eventContext)
+        {
+            IsValid = true;
+        }
+
+        public static LoggingContext CreateTestContext(BuildEventContext buildEventContext)
+        {
+            return new TestLoggingContext(null, buildEventContext);
+        }
+    }
+}
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index c30c97d672e..99acd7b5ac8 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -3019,17 +3019,9 @@ private ILoggingService CreateLoggingService(
 
                 if (loggingService.Loggers.Count == 0)
                 {
-                    // We need to register SOME logger if we don't have any. This ensures the out of proc nodes will still send us message,
-                    // ensuring we receive project started and finished events.
-                    LoggerDescription forwardingLoggerDescription = new LoggerDescription(
-                        loggerClassName: typeof(ConfigurableForwardingLogger).FullName,
-                        loggerAssemblyName: typeof(ConfigurableForwardingLogger).GetTypeInfo().Assembly.GetName().FullName,
-                        loggerAssemblyFile: null,
-                        loggerSwitchParameters: "PROJECTSTARTEDEVENT;PROJECTFINISHEDEVENT;FORWARDPROJECTCONTEXTEVENTS",
-                        verbosity: LoggerVerbosity.Quiet);
-
-                    ForwardingLoggerRecord[] forwardingLogger = { new ForwardingLoggerRecord(new NullLogger(), forwardingLoggerDescription) };
-                    forwardingLoggers = forwardingLoggers?.Concat(forwardingLogger) ?? forwardingLogger;
+                    // if no loggers have been registered - let's make sure that at least on forwarding logger
+                    //  will forward events we need (project started and finished events)
+                    forwardingLoggers = ProcessForwardingLoggers(forwardingLoggers);
                 }
 
                 if (forwardingLoggers != null)
@@ -3047,6 +3039,75 @@ private ILoggingService CreateLoggingService(
             }
 
             return loggingService;
+
+            // We need to register SOME logger if we don't have any. This ensures the out of proc nodes will still send us message,
+            // ensuring we receive project started and finished events.
+            static List<ForwardingLoggerRecord> ProcessForwardingLoggers(IEnumerable<ForwardingLoggerRecord> forwarders)
+            {
+                Type configurableLoggerType = typeof(ConfigurableForwardingLogger);
+                string engineAssemblyName = configurableLoggerType.GetTypeInfo().Assembly.GetName().FullName;
+                string configurableLoggerName = configurableLoggerType.FullName;
+
+                if (forwarders == null)
+                {
+                    return [CreateMinimalForwarder()];
+                }
+
+                List<ForwardingLoggerRecord> result = forwarders.ToList();
+
+                // The forwarding loggers that are registered are unknown to us - we cannot make any assumptions.
+                // So to be on a sure side - we need to add ours.
+                if (!result.Any(l => l.ForwardingLoggerDescription.Name.Contains(engineAssemblyName)))
+                {
+                    result.Add(CreateMinimalForwarder());
+                    return result;
+                }
+
+                // Those are the cases where we are sure that we have the forwarding setup as need.
+                if (result.Any(l =>
+                        l.ForwardingLoggerDescription.Name.Contains(typeof(CentralForwardingLogger).FullName)
+                        ||
+                        (l.ForwardingLoggerDescription.Name.Contains(configurableLoggerName)
+                         &&
+                         l.ForwardingLoggerDescription.LoggerSwitchParameters.Contains("PROJECTSTARTEDEVENT")
+                         &&
+                         l.ForwardingLoggerDescription.LoggerSwitchParameters.Contains("PROJECTFINISHEDEVENT")
+                         &&
+                         l.ForwardingLoggerDescription.LoggerSwitchParameters.Contains("FORWARDPROJECTCONTEXTEVENTS")
+                        )))
+                {
+                    return result;
+                }
+
+                // In case there is a ConfigurableForwardingLogger, that is not configured as we'd need - we can adjust the config
+                ForwardingLoggerRecord configurableLogger = result.FirstOrDefault(l =>
+                    l.ForwardingLoggerDescription.Name.Contains(configurableLoggerName));
+
+                // If there is not - we need to add our own.
+                if (configurableLogger == null)
+                {
+                    result.Add(CreateMinimalForwarder());
+                    return result;
+                }
+
+                configurableLogger.ForwardingLoggerDescription.LoggerSwitchParameters += ";PROJECTSTARTEDEVENT;PROJECTFINISHEDEVENT;FORWARDPROJECTCONTEXTEVENTS;RESPECTVERBOSITY";
+
+                return result;
+
+                ForwardingLoggerRecord CreateMinimalForwarder()
+                {
+                    // We need to register SOME logger if we don't have any. This ensures the out of proc nodes will still send us message,
+                    // ensuring we receive project started and finished events.
+                    LoggerDescription forwardingLoggerDescription = new LoggerDescription(
+                        loggerClassName: configurableLoggerName,
+                        loggerAssemblyName: engineAssemblyName,
+                        loggerAssemblyFile: null,
+                        loggerSwitchParameters: "PROJECTSTARTEDEVENT;PROJECTFINISHEDEVENT;FORWARDPROJECTCONTEXTEVENTS",
+                        verbosity: LoggerVerbosity.Quiet);
+
+                    return new ForwardingLoggerRecord(new NullLogger(), forwardingLoggerDescription);
+                }
+            }
         }
 
         private static void LogDeferredMessages(ILoggingService loggingService, IEnumerable<DeferredBuildMessage> deferredBuildMessages)
diff --git a/src/Build/BackEnd/Components/Caching/IConfigCache.cs b/src/Build/BackEnd/Components/Caching/IConfigCache.cs
index 83b13f615fe..599a86d4c1d 100644
--- a/src/Build/BackEnd/Components/Caching/IConfigCache.cs
+++ b/src/Build/BackEnd/Components/Caching/IConfigCache.cs
@@ -54,7 +54,7 @@ BuildRequestConfiguration this[int configId]
         BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata configMetadata);
 
         /// <summary>
-        /// Gets a matching configuration.  If no such configration exists, one is created and optionally loaded.
+        /// Gets a matching configuration. If no such configuration exists, one is created and optionally loaded.
         /// </summary>
         /// <param name="configMetadata">The configuration metadata to match.</param>
         /// <param name="callback">Callback to be invoked if the configuration does not exist.</param>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
index 646381478b9..40b58682006 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -80,9 +81,10 @@ internal static class BatchingEngine
         internal static List<ItemBucket> PrepareBatchingBuckets(
             List<string> batchableObjectParameters,
             Lookup lookup,
-            ElementLocation elementLocation)
+            ElementLocation elementLocation,
+            LoggingContext loggingContext)
         {
-            return PrepareBatchingBuckets(batchableObjectParameters, lookup, null, elementLocation);
+            return PrepareBatchingBuckets(batchableObjectParameters, lookup, null, elementLocation, loggingContext);
         }
 
         /// <summary>
@@ -94,12 +96,14 @@ internal static List<ItemBucket> PrepareBatchingBuckets(
         /// <param name="lookup"></param>
         /// <param name="implicitBatchableItemType">Any item type that can be considered an implicit input to this batchable object.
         /// This is useful for items inside targets, where the item name is plainly an item type that's an "input" to the object.</param>
+        /// <param name="loggingContext"></param>
         /// <returns>List containing ItemBucket objects, each one representing an execution batch.</returns>
         internal static List<ItemBucket> PrepareBatchingBuckets(
             List<string> batchableObjectParameters,
             Lookup lookup,
             string implicitBatchableItemType,
-            ElementLocation elementLocation)
+            ElementLocation elementLocation,
+            LoggingContext loggingContext)
         {
             if (batchableObjectParameters == null)
             {
@@ -160,7 +164,7 @@ internal static List<ItemBucket> PrepareBatchingBuckets(
                 {
                     // If the batchable object consumes item metadata as well as items to be batched,
                     // we need to partition the items consumed by the object.
-                    buckets = BucketConsumedItems(lookup, itemListsToBeBatched, consumedMetadataReferences, elementLocation);
+                    buckets = BucketConsumedItems(lookup, itemListsToBeBatched, consumedMetadataReferences, elementLocation, loggingContext);
                 }
             }
 
@@ -170,7 +174,12 @@ internal static List<ItemBucket> PrepareBatchingBuckets(
             {
                 // create a default bucket that references the project items and properties -- this way we always have a bucket
                 buckets = new List<ItemBucket>(1);
-                buckets.Add(new ItemBucket(null, null, lookup, buckets.Count));
+                var bucket = new ItemBucket(null, null, lookup, buckets.Count);
+                if (loggingContext != null)
+                {
+                    bucket.Initialize(loggingContext);
+                }
+                buckets.Add(bucket);
             }
 
             return buckets;
@@ -292,7 +301,8 @@ private static List<ItemBucket> BucketConsumedItems(
             Lookup lookup,
             Dictionary<string, ICollection<ProjectItemInstance>> itemListsToBeBatched,
             Dictionary<string, MetadataReference> consumedMetadataReferences,
-            ElementLocation elementLocation)
+            ElementLocation elementLocation,
+            LoggingContext loggingContext)
         {
             ErrorUtilities.VerifyThrow(itemListsToBeBatched.Count > 0, "Need item types consumed by the batchable object.");
             ErrorUtilities.VerifyThrow(consumedMetadataReferences.Count > 0, "Need item metadata consumed by the batchable object.");
@@ -330,6 +340,10 @@ private static List<ItemBucket> BucketConsumedItems(
                         if (matchingBucket == null)
                         {
                             matchingBucket = new ItemBucket(itemListsToBeBatched.Keys, itemMetadataValues, lookup, buckets.Count);
+                            if (loggingContext != null)
+                            {
+                                matchingBucket.Initialize(loggingContext);
+                            }
 
                             // make sure to put the new bucket into the appropriate location
                             // in the sorted list as indicated by the binary search
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 08cc3e9f5e0..e32f6cd94d1 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -58,7 +58,7 @@ internal override void ExecuteTask(Lookup lookup)
                 {
                     List<string> parameterValues = new List<string>();
                     GetBatchableValuesFromBuildItemGroupChild(parameterValues, child);
-                    buckets = BatchingEngine.PrepareBatchingBuckets(parameterValues, lookup, child.ItemType, _taskInstance.Location);
+                    buckets = BatchingEngine.PrepareBatchingBuckets(parameterValues, lookup, child.ItemType, _taskInstance.Location, LoggingContext);
 
                     // "Execute" each bucket
                     foreach (ItemBucket bucket in buckets)
@@ -70,9 +70,8 @@ internal override void ExecuteTask(Lookup lookup)
                             ExpanderOptions.ExpandAll,
                             Project.Directory,
                             child.ConditionLocation,
-                            LoggingContext.LoggingService,
-                            LoggingContext.BuildEventContext,
-                            FileSystems.Default);
+                            FileSystems.Default,
+                            LoggingContext);
 
                         if (condition)
                         {
@@ -83,7 +82,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.KeepMetadata))
                             {
-                                var keepMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.KeepMetadata, ExpanderOptions.ExpandAll, child.KeepMetadataLocation, LoggingContext).ToList();
+                                var keepMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.KeepMetadata, ExpanderOptions.ExpandAll, child.KeepMetadataLocation).ToList();
                                 if (keepMetadataEvaluated.Count > 0)
                                 {
                                     keepMetadata = new HashSet<string>(keepMetadataEvaluated);
@@ -92,7 +91,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.RemoveMetadata))
                             {
-                                var removeMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.RemoveMetadata, ExpanderOptions.ExpandAll, child.RemoveMetadataLocation, LoggingContext).ToList();
+                                var removeMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.RemoveMetadata, ExpanderOptions.ExpandAll, child.RemoveMetadataLocation).ToList();
                                 if (removeMetadataEvaluated.Count > 0)
                                 {
                                     removeMetadata = new HashSet<string>(removeMetadataEvaluated);
@@ -101,7 +100,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.MatchOnMetadata))
                             {
-                                var matchOnMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.MatchOnMetadata, ExpanderOptions.ExpandAll, child.MatchOnMetadataLocation, LoggingContext).ToList();
+                                var matchOnMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.MatchOnMetadata, ExpanderOptions.ExpandAll, child.MatchOnMetadataLocation).ToList();
                                 if (matchOnMetadataEvaluated.Count > 0)
                                 {
                                     matchOnMetadata = new HashSet<string>(matchOnMetadataEvaluated);
@@ -177,8 +176,6 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                     ExpanderOptions.ExpandAll,
                     Project.Directory,
                     metadataInstance.Location,
-                    LoggingContext.LoggingService,
-                    LoggingContext.BuildEventContext,
                     FileSystems.Default,
                     loggingContext: loggingContext);
 
@@ -194,7 +191,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                         expanderOptions |= ExpanderOptions.LogOnItemMetadataSelfReference;
                     }
 
-                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, expanderOptions, metadataInstance.Location, loggingContext);
+                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, expanderOptions, metadataInstance.Location);
 
                     // This both stores the metadata so we can add it to all the items we just created later, and
                     // exposes this metadata to further metadata evaluations in subsequent loop iterations.
@@ -216,15 +213,16 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                 ExpanderOptions.ExpandAll,
                 Project.Directory,
                 child.KeepDuplicatesLocation,
-                LoggingContext.LoggingService,
-                LoggingContext.BuildEventContext,
-                FileSystems.Default);
+                FileSystems.Default,
+                LoggingContext);
 
             if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents && itemsToAdd?.Count > 0)
             {
                 ItemGroupLoggingHelper.LogTaskParameter(
                     LoggingContext,
                     TaskParameterMessageKind.AddItem,
+                    parameterName: null,
+                    propertyName: null,
                     child.ItemType,
                     itemsToAdd,
                     logItemMetadata: true,
@@ -255,7 +253,7 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
             List<ProjectItemInstance> itemsToRemove;
             if (matchOnMetadata == null)
             {
-                itemsToRemove = FindItemsMatchingSpecification(group, child.Remove, child.RemoveLocation, bucket.Expander, LoggingContext);
+                itemsToRemove = FindItemsMatchingSpecification(group, child.Remove, child.RemoveLocation, bucket.Expander);
             }
             else
             {
@@ -269,6 +267,8 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
                     ItemGroupLoggingHelper.LogTaskParameter(
                         LoggingContext,
                         TaskParameterMessageKind.RemoveItem,
+                        parameterName: null,
+                        propertyName: null,
                         child.ItemType,
                         itemsToRemove,
                         logItemMetadata: true,
@@ -325,14 +325,12 @@ private void ExecuteModify(ProjectItemGroupTaskItemInstance child, ItemBucket bu
                     ExpanderOptions.ExpandAll,
                     Project.Directory,
                     metadataInstance.ConditionLocation,
-                    LoggingContext.LoggingService,
-                    LoggingContext.BuildEventContext,
                     FileSystems.Default,
                     loggingContext: loggingContext);
 
                 if (condition)
                 {
-                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location, loggingContext);
+                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location);
                     metadataToSet[metadataInstance.Name] = Lookup.MetadataModification.CreateFromNewValue(evaluatedValue);
                 }
             }
@@ -387,7 +385,7 @@ private List<ProjectItemInstance> ExpandItemIntoItems(
             List<ProjectItemInstance> items = new List<ProjectItemInstance>();
 
             // Expand properties and metadata in Include
-            string evaluatedInclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Include, ExpanderOptions.ExpandPropertiesAndMetadata, originalItem.IncludeLocation, loggingContext);
+            string evaluatedInclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Include, ExpanderOptions.ExpandPropertiesAndMetadata, originalItem.IncludeLocation);
 
             if (evaluatedInclude.Length == 0)
             {
@@ -398,7 +396,7 @@ private List<ProjectItemInstance> ExpandItemIntoItems(
             var excludes = ImmutableList<string>.Empty.ToBuilder();
             if (originalItem.Exclude.Length > 0)
             {
-                string evaluatedExclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Exclude, ExpanderOptions.ExpandAll, originalItem.ExcludeLocation, loggingContext);
+                string evaluatedExclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Exclude, ExpanderOptions.ExpandAll, originalItem.ExcludeLocation);
 
                 if (evaluatedExclude.Length > 0)
                 {
@@ -537,14 +535,12 @@ private HashSet<string> EvaluateExcludePaths(IReadOnlyList<string> excludes, Ele
         /// <param name="specification">The specification to match against the items.</param>
         /// <param name="specificationLocation">The specification to match against the provided items</param>
         /// <param name="expander">The expander to use</param>
-        /// <param name="loggingContext">Context for logging</param>
         /// <returns>A list of matching items</returns>
         private List<ProjectItemInstance> FindItemsMatchingSpecification(
             ICollection<ProjectItemInstance> items,
             string specification,
             ElementLocation specificationLocation,
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander,
-            LoggingContext loggingContext = null)
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander)
         {
             if (items.Count == 0 || specification.Length == 0)
             {
@@ -556,7 +552,7 @@ private List<ProjectItemInstance> FindItemsMatchingSpecification(
             HashSet<string> specificationsToFind = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
             // Split by semicolons
-            var specificationPieces = expander.ExpandIntoStringListLeaveEscaped(specification, ExpanderOptions.ExpandAll, specificationLocation, loggingContext);
+            var specificationPieces = expander.ExpandIntoStringListLeaveEscaped(specification, ExpanderOptions.ExpandAll, specificationLocation);
 
             foreach (string piece in specificationPieces)
             {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
index df32111f095..deae62102f0 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
@@ -10,6 +10,7 @@
 #endif
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -35,6 +36,7 @@ internal static class ItemGroupLoggingHelper
         internal static string ItemGroupIncludeLogMessagePrefix = ResourceUtilities.GetResourceString("ItemGroupIncludeLogMessagePrefix");
         internal static string ItemGroupRemoveLogMessage = ResourceUtilities.GetResourceString("ItemGroupRemoveLogMessage");
         internal static string OutputItemParameterMessagePrefix = ResourceUtilities.GetResourceString("OutputItemParameterMessagePrefix");
+        internal static string OutputPropertyLogMessagePrefix = ResourceUtilities.GetResourceString("OutputPropertyLogMessagePrefix");
         internal static string TaskParameterPrefix = ResourceUtilities.GetResourceString("TaskParameterPrefix");
         internal static string SkipTargetUpToDateInputs = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("SkipTargetUpToDateInputs", string.Empty);
         internal static string SkipTargetUpToDateOutputs = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("SkipTargetUpToDateOutputs", string.Empty);
@@ -255,6 +257,8 @@ private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, ob
         internal static void LogTaskParameter(
             LoggingContext loggingContext,
             TaskParameterMessageKind messageKind,
+            string parameterName,
+            string propertyName,
             string itemType,
             IList items,
             bool logItemMetadata,
@@ -263,6 +267,8 @@ internal static void LogTaskParameter(
             var args = CreateTaskParameterEventArgs(
                 loggingContext.BuildEventContext,
                 messageKind,
+                parameterName,
+                propertyName,
                 itemType,
                 items,
                 logItemMetadata,
@@ -276,6 +282,8 @@ internal static void LogTaskParameter(
         internal static TaskParameterEventArgs CreateTaskParameterEventArgs(
             BuildEventContext buildEventContext,
             TaskParameterMessageKind messageKind,
+            string parameterName,
+            string propertyName,
             string itemType,
             IList items,
             bool logItemMetadata,
@@ -290,6 +298,8 @@ internal static TaskParameterEventArgs CreateTaskParameterEventArgs(
 
             var args = new TaskParameterEventArgs(
                 messageKind,
+                parameterName,
+                propertyName,
                 itemType,
                 items,
                 logItemMetadata,
@@ -355,26 +365,23 @@ private static void CreateItemsSnapshot(ref IList items)
 #endif
 
         internal static string GetTaskParameterText(TaskParameterEventArgs args)
-            => GetTaskParameterText(args.Kind, args.ItemType, args.Items, args.LogItemMetadata);
-
-        internal static string GetTaskParameterText(TaskParameterMessageKind messageKind, string itemType, IList items, bool logItemMetadata)
         {
-            var resourceText = messageKind switch
+            var resourceText = args.Kind switch
             {
                 TaskParameterMessageKind.AddItem => ItemGroupIncludeLogMessagePrefix,
                 TaskParameterMessageKind.RemoveItem => ItemGroupRemoveLogMessage,
                 TaskParameterMessageKind.TaskInput => TaskParameterPrefix,
-                TaskParameterMessageKind.TaskOutput => OutputItemParameterMessagePrefix,
+                TaskParameterMessageKind.TaskOutput => args.PropertyName is null ? OutputItemParameterMessagePrefix : OutputPropertyLogMessagePrefix,
                 TaskParameterMessageKind.SkippedTargetInputs => SkipTargetUpToDateInputs,
                 TaskParameterMessageKind.SkippedTargetOutputs => SkipTargetUpToDateOutputs,
-                _ => throw new NotImplementedException($"Unsupported {nameof(TaskParameterMessageKind)} value: {messageKind}")
+                _ => throw new NotImplementedException($"Unsupported {nameof(TaskParameterMessageKind)} value: {args.Kind}")
             };
 
             var itemGroupText = GetParameterText(
                 resourceText,
-                itemType,
-                items,
-                logItemMetadata);
+                args.PropertyName ?? args.ItemType,
+                args.Items,
+                args.LogItemMetadata);
             return itemGroupText;
         }
     }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
index 419ff97e0bd..18d85f2323c 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
@@ -52,7 +52,7 @@ internal override void ExecuteTask(Lookup lookup)
                     // Find all the metadata references in order to create buckets
                     List<string> parameterValues = new List<string>();
                     GetBatchableValuesFromProperty(parameterValues, property);
-                    buckets = BatchingEngine.PrepareBatchingBuckets(parameterValues, lookup, property.Location);
+                    buckets = BatchingEngine.PrepareBatchingBuckets(parameterValues, lookup, property.Location, LoggingContext);
 
                     // "Execute" each bucket
                     foreach (ItemBucket bucket in buckets)
@@ -64,9 +64,8 @@ internal override void ExecuteTask(Lookup lookup)
                             ExpanderOptions.ExpandAll,
                             Project.Directory,
                             property.ConditionLocation,
-                            LoggingContext.LoggingService,
-                            LoggingContext.BuildEventContext,
-                            FileSystems.Default);
+                            FileSystems.Default,
+                            LoggingContext);
 
                         if (condition)
                         {
@@ -78,7 +77,12 @@ internal override void ExecuteTask(Lookup lookup)
                                 "CannotModifyReservedProperty",
                                 property.Name);
 
+                            bucket.Expander.PropertiesUseTracker.CurrentlyEvaluatingPropertyElementName = property.Name;
+                            bucket.Expander.PropertiesUseTracker.PropertyReadContext =
+                                PropertyReadContext.PropertyEvaluation;
+
                             string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(property.Value, ExpanderOptions.ExpandAll, property.Location);
+                            bucket.Expander.PropertiesUseTracker.CheckPreexistingUndefinedUsage(property, evaluatedValue, LoggingContext);
 
                             if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents)
                             {
@@ -97,6 +101,8 @@ internal override void ExecuteTask(Lookup lookup)
                         foreach (ItemBucket bucket in buckets)
                         {
                             bucket.LeaveScope();
+                            // We are now done processing this property - so no need to pop its previous context.
+                            bucket.Expander.PropertiesUseTracker.ResetPropertyReadContext(pop: false);
                         }
                     }
                 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs b/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
index 21650e6448f..950b2848a68 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
@@ -3,6 +3,9 @@
 
 using System;
 using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using System.Diagnostics;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -30,12 +33,12 @@ internal sealed class ItemBucket : IComparable
         /// <summary>
         /// Metadata in this bucket
         /// </summary>
-        private Dictionary<string, string> _metadata;
+        private readonly Dictionary<string, string> _metadata;
 
         /// <summary>
         /// The items for this bucket.
         /// </summary>
-        private Lookup _lookup;
+        private readonly Lookup _lookup;
 
         /// <summary>
         /// When buckets are being created for batching purposes, this indicates which order the
@@ -44,22 +47,23 @@ internal sealed class ItemBucket : IComparable
         /// bucket created gets bucketSequenceNumber=0, the second bucket created gets
         /// bucketSequenceNumber=1, etc.
         /// </summary>
-        private int _bucketSequenceNumber;
+        private readonly int _bucketSequenceNumber;
 
         /// <summary>
         /// The entry we enter when we create the bucket.
         /// </summary>
-        private Lookup.Scope _lookupEntry;
+        private readonly Lookup.Scope _lookupEntry;
 
         #endregion
 
         #region Constructors
 
         /// <summary>
-        /// Private default constructor disallows parameterless instantiation.
+        /// Private constructor for creating comparison bucket.
         /// </summary>
-        private ItemBucket()
+        private ItemBucket(Dictionary<string, string> metadata)
         {
+            _metadata = metadata;
             // do nothing
         }
 
@@ -95,11 +99,19 @@ internal ItemBucket(
             }
 
             _metadata = metadata;
-            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(_lookup, _lookup, new StringMetadataTable(metadata), FileSystems.Default);
 
             _bucketSequenceNumber = bucketSequenceNumber;
         }
 
+        /// <summary>
+        /// Updates the logging context that this bucket is going to use.
+        /// </summary>
+        /// <param name="loggingContext"></param>
+        internal void Initialize(LoggingContext loggingContext)
+        {
+            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(_lookup, _lookup, new StringMetadataTable(_metadata), FileSystems.Default, loggingContext);
+        }
+
         #endregion
 
         #region Comparison methods
@@ -131,8 +143,7 @@ public int CompareTo(object obj)
         /// <returns>An item bucket that is invalid for everything except comparisons.</returns>
         internal static ItemBucket GetDummyBucketForComparisons(Dictionary<string, string> metadata)
         {
-            ItemBucket bucket = new ItemBucket();
-            bucket._metadata = metadata;
+            ItemBucket bucket = new ItemBucket(metadata);
 
             return bucket;
         }
@@ -147,6 +158,7 @@ internal Expander<ProjectPropertyInstance, ProjectItemInstance> Expander
         {
             get
             {
+                Debug.Assert(_expander != null, "ItemBucket.Initialize was not properly called");
                 return _expander;
             }
         }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index bb3f3c87d9e..6ff9319f3eb 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -737,7 +737,7 @@ private async Task<bool> PushTargets(IList<TargetSpecification> targets, TargetE
 
                 // Add to the list of targets to push.  We don't actually put it on the stack here because we could run into a circular dependency
                 // during this loop, in which case the target stack would be out of whack.
-                TargetEntry newEntry = new TargetEntry(_requestEntry, this as ITargetBuilderCallback, targetSpecification, baseLookup, parentTargetEntry, buildReason, _componentHost, stopProcessingOnCompletion);
+                TargetEntry newEntry = new TargetEntry(_requestEntry, this as ITargetBuilderCallback, targetSpecification, baseLookup, parentTargetEntry, buildReason, _componentHost, _projectLoggingContext, stopProcessingOnCompletion);
                 newEntry.ErrorTarget = addAsErrorTarget;
                 targetsToPush.Add(newEntry);
                 stopProcessingOnCompletion = false; // The first target on the stack (the last one to be run) always inherits the stopProcessing flag.
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index bbfc80ae5d9..bd58c8a4196 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -7,6 +7,7 @@
 using System.Linq;
 using System.Threading;
 using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
@@ -162,8 +163,17 @@ internal class TargetEntry : IEquatable<TargetEntry>
         /// <param name="parentTarget">The parent of this entry, if any.</param>
         /// <param name="buildReason">The reason the parent built this target.</param>
         /// <param name="host">The Build Component Host to use.</param>
+        /// <param name="loggingContext"></param>
         /// <param name="stopProcessingOnCompletion">True if the target builder should stop processing the current target stack when this target is complete.</param>
-        internal TargetEntry(BuildRequestEntry requestEntry, ITargetBuilderCallback targetBuilderCallback, TargetSpecification targetSpecification, Lookup baseLookup, TargetEntry parentTarget, TargetBuiltReason buildReason, IBuildComponentHost host, bool stopProcessingOnCompletion)
+        internal TargetEntry(
+            BuildRequestEntry requestEntry,
+            ITargetBuilderCallback targetBuilderCallback,
+            TargetSpecification targetSpecification,
+            Lookup baseLookup, TargetEntry parentTarget,
+            TargetBuiltReason buildReason,
+            IBuildComponentHost host,
+            LoggingContext loggingContext,
+            bool stopProcessingOnCompletion)
         {
             ErrorUtilities.VerifyThrowArgumentNull(requestEntry, nameof(requestEntry));
             ErrorUtilities.VerifyThrowArgumentNull(targetBuilderCallback, nameof(targetBuilderCallback));
@@ -176,7 +186,7 @@ internal TargetEntry(BuildRequestEntry requestEntry, ITargetBuilderCallback targ
             _targetSpecification = targetSpecification;
             _parentTarget = parentTarget;
             _buildReason = buildReason;
-            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(baseLookup, baseLookup, FileSystems.Default);
+            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(baseLookup, baseLookup, FileSystems.Default, loggingContext);
             _state = TargetEntryState.Dependencies;
             _baseLookup = baseLookup;
             _host = host;
@@ -351,8 +361,6 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
                 ExpanderOptions.ExpandPropertiesAndItems,
                 _requestEntry.ProjectRootDirectory,
                 _target.ConditionLocation,
-                projectLoggingContext.LoggingService,
-                projectLoggingContext.BuildEventContext,
                 FileSystems.Default,
                 loggingContext: projectLoggingContext);
 
@@ -393,7 +401,7 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
                 return new List<TargetSpecification>();
             }
 
-            var dependencies = _expander.ExpandIntoStringListLeaveEscaped(_target.DependsOnTargets, ExpanderOptions.ExpandPropertiesAndItems, _target.DependsOnTargetsLocation, projectLoggingContext);
+            var dependencies = _expander.ExpandIntoStringListLeaveEscaped(_target.DependsOnTargets, ExpanderOptions.ExpandPropertiesAndItems, _target.DependsOnTargetsLocation);
             List<TargetSpecification> dependencyTargets = new List<TargetSpecification>();
             foreach (string escapedDependency in dependencies)
             {
@@ -420,7 +428,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
 
                 // Generate the batching buckets.  Note that each bucket will get a lookup based on the baseLookup.  This lookup will be in its
                 // own scope, which we will collapse back down into the baseLookup at the bottom of the function.
-                List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(GetBatchableParametersForTarget(), _baseLookup, _target.Location);
+                List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(GetBatchableParametersForTarget(), _baseLookup, _target.Location, null);
 
                 WorkUnitResult aggregateResult = new WorkUnitResult();
                 TargetLoggingContext targetLoggingContext = null;
@@ -444,7 +452,15 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                         break;
                     }
 
+                    if (i > 0)
+                    {
+                        // Don't log the last target finished event until we can process the target outputs as we want to attach them to the
+                        // last target batch. The following statement logs the event for the bucket processed in the previous iteration.
+                        targetLoggingContext.LogTargetBatchFinished(projectFullPath, targetSuccess, null);
+                    }
+
                     targetLoggingContext = projectLoggingContext.LogTargetBatchStarted(projectFullPath, _target, parentTargetName, _buildReason);
+                    bucket.Initialize(targetLoggingContext);
                     WorkUnitResult bucketResult = null;
                     targetSuccess = false;
 
@@ -556,16 +572,6 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                         entryForExecution?.LeaveScope();
                         aggregateResult = aggregateResult.AggregateResult(new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, null));
                     }
-                    finally
-                    {
-                        // Don't log the last target finished event until we can process the target outputs as we want to attach them to the
-                        // last target batch.
-                        if (targetLoggingContext != null && i < numberOfBuckets - 1)
-                        {
-                            targetLoggingContext.LogTargetBatchFinished(projectFullPath, targetSuccess, null);
-                            targetLoggingContext = null;
-                        }
-                    }
                 }
 
                 // Produce the final results.
@@ -612,14 +618,14 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                                  ExpanderOptions.ExpandPropertiesAndItems,
                                  requestEntry.ProjectRootDirectory,
                                  _target.KeepDuplicateOutputsLocation,
-                                 projectLoggingContext.LoggingService,
-                                 projectLoggingContext.BuildEventContext, FileSystems.Default);
+                                 FileSystems.Default,
+                                 projectLoggingContext);
 
                         // NOTE: we need to gather the outputs in batches, because the output specification may reference item metadata
                         // Also, we are using the baseLookup, which has possibly had changes made to it since the project started.  Because of this, the
                         // set of outputs calculated here may differ from those which would have been calculated at the beginning of the target.  It is
                         // assumed the user intended this.
-                        List<ItemBucket> batchingBuckets = BatchingEngine.PrepareBatchingBuckets(GetBatchableParametersForTarget(), _baseLookup, _target.Location);
+                        List<ItemBucket> batchingBuckets = BatchingEngine.PrepareBatchingBuckets(GetBatchableParametersForTarget(), _baseLookup, _target.Location, targetLoggingContext);
 
                         if (keepDupes)
                         {
@@ -704,8 +710,8 @@ internal List<TargetSpecification> GetErrorTargets(ProjectLoggingContext project
                     ExpanderOptions.ExpandPropertiesAndItems,
                     _requestEntry.ProjectRootDirectory,
                     errorTargetInstance.ConditionLocation,
-                    projectLoggingContext.LoggingService,
-                    projectLoggingContext.BuildEventContext, FileSystems.Default);
+                    FileSystems.Default,
+                    projectLoggingContext);
 
                 if (condition)
                 {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
index 4b40715d67b..9940131c9e9 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
@@ -368,6 +368,8 @@ private void LogUniqueInputsAndOutputs()
             var args = ItemGroupLoggingHelper.CreateTaskParameterEventArgs(
                 _buildEventContext,
                 TaskParameterMessageKind.SkippedTargetInputs,
+                parameterName: null,
+                propertyName: null,
                 itemType: null,
                 _uniqueTargetInputs.Keys.ToArray(),
                 logItemMetadata: false,
@@ -377,6 +379,8 @@ private void LogUniqueInputsAndOutputs()
             args = ItemGroupLoggingHelper.CreateTaskParameterEventArgs(
                 _buildEventContext,
                 TaskParameterMessageKind.SkippedTargetOutputs,
+                parameterName: null,
+                propertyName: null,
                 itemType: null,
                 _uniqueTargetOutputs.Keys.ToArray(),
                 logItemMetadata: false,
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 485ee854f73..6bc0dd7fc23 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -313,7 +313,7 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
                 }
 
                 List<string> taskParameterValues = CreateListOfParameterValues();
-                buckets = BatchingEngine.PrepareBatchingBuckets(taskParameterValues, lookup, _targetChildInstance.Location);
+                buckets = BatchingEngine.PrepareBatchingBuckets(taskParameterValues, lookup, _targetChildInstance.Location, _targetLoggingContext);
 
                 Dictionary<string, string> lookupHash = null;
 
@@ -379,8 +379,6 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                 ExpanderOptions.ExpandAll,
                 _buildRequestEntry.ProjectRootDirectory,
                 _targetChildInstance.ConditionLocation,
-                _targetLoggingContext.LoggingService,
-                _targetLoggingContext.BuildEventContext,
                 FileSystems.Default,
                 loggingContext: _targetLoggingContext);
 
@@ -614,7 +612,7 @@ private void LogSkippedTask(ItemBucket bucket, TaskExecutionMode howToExecuteTas
                     if (!_targetLoggingContext.LoggingService.OnlyLogCriticalEvents)
                     {
                         // Expand the expression for the Log.  Since we know the condition evaluated to false, leave unexpandable properties in the condition so as not to cause an error
-                        string expanded = bucket.Expander.ExpandIntoStringAndUnescape(_targetChildInstance.Condition, ExpanderOptions.ExpandAll | ExpanderOptions.LeavePropertiesUnexpandedOnError | ExpanderOptions.Truncate, _targetChildInstance.ConditionLocation, loggingContext: _targetLoggingContext);
+                        string expanded = bucket.Expander.ExpandIntoStringAndUnescape(_targetChildInstance.Condition, ExpanderOptions.ExpandAll | ExpanderOptions.LeavePropertiesUnexpandedOnError | ExpanderOptions.Truncate, _targetChildInstance.ConditionLocation);
 
                         // Whilst we are within the processing of the task, we haven't actually started executing it, so
                         // our skip task message needs to be in the context of the target. However any errors should be reported
@@ -1080,9 +1078,8 @@ private bool GatherTaskOutputs(TaskExecutionHost taskExecutionHost, TaskExecutio
                     ExpanderOptions.ExpandAll,
                     _buildRequestEntry.ProjectRootDirectory,
                     taskOutputSpecification.ConditionLocation,
-                    _targetLoggingContext.LoggingService,
-                    _targetLoggingContext.BuildEventContext,
-                    FileSystems.Default);
+                    FileSystems.Default,
+                    _targetLoggingContext);
 
                 if (condition)
                 {
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index fdff89eb618..1a2ba345658 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -1177,7 +1177,7 @@ private bool InitializeTaskScalarParameter(
                 else
                 {
                     // Expand out all the metadata, properties, and item vectors in the string.
-                    string expandedParameterValue = _batchBucket.Expander.ExpandIntoStringAndUnescape(parameterValue, ExpanderOptions.ExpandAll, parameterLocation, _targetLoggingContext);
+                    string expandedParameterValue = _batchBucket.Expander.ExpandIntoStringAndUnescape(parameterValue, ExpanderOptions.ExpandAll, parameterLocation);
 
                     if (expandedParameterValue.Length == 0)
                     {
@@ -1317,10 +1317,14 @@ private bool InternalSetTaskParameter(
                     // Structured logging for all parameters that have logging enabled and are not empty lists.
                     if (parameterValueAsList?.Count > 0 || (parameterValueAsList == null && !legacyBehavior))
                     {
+                        // Note: We're setting TaskParameterEventArgs.ItemType to parameter name for backward compatibility with
+                        // older loggers and binlog viewers.
                         ItemGroupLoggingHelper.LogTaskParameter(
                             _taskLoggingContext,
                             TaskParameterMessageKind.TaskInput,
-                            parameter.Name,
+                            parameterName: parameter.Name,
+                            propertyName: null,
+                            itemType: parameter.Name,
                             parameterValueAsList ?? new object[] { parameterValue },
                             parameter.LogItemMetadata);
                     }
@@ -1429,7 +1433,9 @@ static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(IDictionary c
                         ItemGroupLoggingHelper.LogTaskParameter(
                             _taskLoggingContext,
                             TaskParameterMessageKind.TaskOutput,
-                            outputTargetName,
+                            parameterName: parameter.Name,
+                            propertyName: null,
+                            itemType: outputTargetName,
                             outputs,
                             parameter.LogItemMetadata);
                     }
@@ -1470,7 +1476,23 @@ static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(IDictionary c
                         var outputString = joinedOutputs.ToString();
                         if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents)
                         {
-                            _taskLoggingContext.LogComment(MessageImportance.Low, "OutputPropertyLogMessage", outputTargetName, outputString);
+                            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12))
+                            {
+                                // Note: We're setting TaskParameterEventArgs.ItemType to property name for backward compatibility with
+                                // older loggers and binlog viewers.
+                                ItemGroupLoggingHelper.LogTaskParameter(
+                                    _taskLoggingContext,
+                                    TaskParameterMessageKind.TaskOutput,
+                                    parameterName: parameter.Name,
+                                    propertyName: outputTargetName,
+                                    itemType: outputTargetName,
+                                    new object[] { outputString },
+                                    parameter.LogItemMetadata);
+                            }
+                            else
+                            {
+                                _taskLoggingContext.LogComment(MessageImportance.Low, "OutputPropertyLogMessage", outputTargetName, outputString);
+                            }
                         }
 
                         _batchBucket.Lookup.SetProperty(ProjectPropertyInstance.Create(outputTargetName, outputString, parameterLocation, _projectInstance.IsImmutable));
@@ -1505,7 +1527,9 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
                         ItemGroupLoggingHelper.LogTaskParameter(
                             _taskLoggingContext,
                             TaskParameterMessageKind.TaskOutput,
-                            outputTargetName,
+                            parameterName: parameter.Name,
+                            propertyName: null,
+                            itemType: outputTargetName,
                             outputs,
                             parameter.LogItemMetadata);
                     }
@@ -1539,7 +1563,23 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
                         var outputString = joinedOutputs.ToString();
                         if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents)
                         {
-                            _taskLoggingContext.LogComment(MessageImportance.Low, "OutputPropertyLogMessage", outputTargetName, outputString);
+                            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12))
+                            {
+                                // Note: We're setting TaskParameterEventArgs.ItemType to property name for backward compatibility with
+                                // older loggers and binlog viewers.
+                                ItemGroupLoggingHelper.LogTaskParameter(
+                                    _taskLoggingContext,
+                                    TaskParameterMessageKind.TaskOutput,
+                                    parameterName: parameter.Name,
+                                    propertyName: outputTargetName,
+                                    itemType: outputTargetName,
+                                    new object[] { outputString },
+                                    parameter.LogItemMetadata);
+                            }
+                            else
+                            {
+                                _taskLoggingContext.LogComment(MessageImportance.Low, "OutputPropertyLogMessage", outputTargetName, outputString);
+                            }
                         }
 
                         _batchBucket.Lookup.SetProperty(ProjectPropertyInstance.Create(outputTargetName, outputString, parameterLocation, _projectInstance.IsImmutable));
diff --git a/src/Build/BuildCheck/.editorconfig b/src/Build/BuildCheck/.editorconfig
new file mode 100644
index 00000000000..731ad1c1785
--- /dev/null
+++ b/src/Build/BuildCheck/.editorconfig
@@ -0,0 +1,2 @@
+[*.cs]
+csharp_style_namespace_declarations = file_scoped:warning
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs b/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
index 4940db20fd1..ab817077725 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
+++ b/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
@@ -1,6 +1,10 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
@@ -42,4 +46,73 @@ public class BuildAnalyzerConfiguration
     /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.
     /// </summary>
     public bool? IsEnabled { get; internal init; }
+
+    /// <summary>
+    /// Creates a <see cref="BuildAnalyzerConfiguration"/> object based on the provided configuration dictionary.
+    /// If the BuildAnalyzerConfiguration's property name presented in the dictionary, the value of this key-value pair is parsed and assigned to the instance's field.
+    /// If parsing failed the value will be equal to null.
+    /// </summary>
+    /// <param name="configDictionary">The configuration dictionary containing the settings for the build analyzer. The configuration's keys are expected to be in lower case or the EqualityComparer to ignore case.</param>
+    /// <returns>A new instance of <see cref="BuildAnalyzerConfiguration"/> with the specified settings.</returns>
+    internal static BuildAnalyzerConfiguration Create(Dictionary<string, string>? configDictionary)
+    {
+        return new()
+        {
+            EvaluationAnalysisScope = TryExtractValue(nameof(EvaluationAnalysisScope), configDictionary, out EvaluationAnalysisScope evaluationAnalysisScope) ? evaluationAnalysisScope : null,
+            Severity = TryExtractValue(nameof(Severity), configDictionary, out BuildAnalyzerResultSeverity severity) ? severity : null,
+            IsEnabled = TryExtractValue(nameof(IsEnabled), configDictionary, out bool isEnabled) ? isEnabled : null,
+        };
+    }
+
+    private static bool TryExtractValue<T>(string key, Dictionary<string, string>? config, out T value) where T : struct, Enum
+    {
+        value = default;
+
+        if (config == null || !config.TryGetValue(key.ToLower(), out var stringValue) || stringValue is null)
+        {
+            return false;
+        }
+
+        var isParsed = Enum.TryParse(stringValue, true, out value);
+
+        if (!isParsed)
+        {
+            ThrowIncorrectValueException(key, stringValue);
+        }
+
+        return isParsed;
+    }
+
+    private static bool TryExtractValue(string key, Dictionary<string, string>? config, out bool value)
+    {
+        value = default;
+
+        if (config == null || !config.TryGetValue(key.ToLower(), out var stringValue) || stringValue is null)
+        {
+            return false;
+        }
+
+        bool isParsed = false;
+        
+        if (bool.TryParse(stringValue, out bool boolValue))
+        {
+            value = boolValue;
+            isParsed = true;
+        }
+        
+        if (!isParsed)
+        {
+            ThrowIncorrectValueException(key, stringValue);
+        }
+
+        return isParsed;
+    }
+
+    private static void ThrowIncorrectValueException(string key, string value)
+    {
+        // TODO: It will be nice to have the filename where the incorrect configuration was placed. 
+        throw new BuildCheckConfigurationException(
+                $"Incorrect value provided in config for key {key}: '{value}'",
+                buildCheckConfigurationErrorScope: BuildCheckConfigurationErrorScope.EditorConfigParser);
+    }
 }
diff --git a/src/Build/BuildCheck/API/ConfigurationContext.cs b/src/Build/BuildCheck/API/ConfigurationContext.cs
index 81576a42fb5..3ecdd7c6527 100644
--- a/src/Build/BuildCheck/API/ConfigurationContext.cs
+++ b/src/Build/BuildCheck/API/ConfigurationContext.cs
@@ -20,19 +20,9 @@ private ConfigurationContext(CustomConfigurationData[] customConfigurationData)
 
     internal static ConfigurationContext FromDataEnumeration(CustomConfigurationData[] customConfigurationData)
     {
-        if (!customConfigurationData.Any(BuildCheck.CustomConfigurationData.NotNull))
-        {
-            return Null;
-        }
-
-        return new ConfigurationContext(
-            customConfigurationData
-                .Where(BuildCheck.CustomConfigurationData.NotNull)
-                .ToArray());
+        return new ConfigurationContext(customConfigurationData);
     }
 
-    internal static ConfigurationContext Null { get; } = new(Array.Empty<CustomConfigurationData>());
-
     /// <summary>
     /// Custom configuration data - per each rule that has some specified.
     /// </summary>
diff --git a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
index 673c98919a4..ee755cc7352 100644
--- a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
@@ -42,18 +42,17 @@ public List<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(AnalyzerAcquisiti
             assembly = Assembly.LoadFrom(analyzerAcquisitionData.AssemblyPath);
 #endif
 
-            IEnumerable<Type> analyzerTypes = assembly.GetExportedTypes().Where(t => typeof(BuildAnalyzer).IsAssignableFrom(t));
+            IList<Type> availableTypes = assembly.GetExportedTypes();
+            IList<Type> analyzerTypes = availableTypes.Where(t => typeof(BuildAnalyzer).IsAssignableFrom(t)).ToArray();
 
-            foreach (Type analyzerType in analyzerTypes)
+            foreach (Type analyzerCandidate in analyzerTypes)
             {
-                if (Activator.CreateInstance(analyzerType) is BuildAnalyzer instance)
-                {
-                    analyzersFactories.Add(() => instance);
-                }
-                else
-                {
-                    throw new InvalidOperationException($"Failed to create an instance of type {analyzerType.FullName} as BuildAnalyzer.");
-                }
+                analyzersFactories.Add(() => (BuildAnalyzer)Activator.CreateInstance(analyzerCandidate)!);
+            }
+
+            if (availableTypes.Count != analyzerTypes.Count)
+            {
+                availableTypes.Except(analyzerTypes).ToList().ForEach(t => _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "CustomAnalyzerBaseTypeNotAssignable", t.Name, t.Assembly));
             }
         }
         catch (ReflectionTypeLoadException ex)
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
index d73b9bb6231..32078038875 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
@@ -15,6 +15,13 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 /// </summary>
 internal sealed class BuildCheckCentralContext
 {
+    private readonly ConfigurationProvider _configurationProvider;
+
+    internal BuildCheckCentralContext(ConfigurationProvider configurationProvider)
+    {
+        _configurationProvider = configurationProvider;
+    }
+
     private record CallbackRegistry(
         List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>>)> EvaluatedPropertiesActions,
         List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<ParsedItemsAnalysisData>>)> ParsedItemsActions,
@@ -126,7 +133,7 @@ private void RunRegisteredActions<T>(
                 else
                 {
                     configPerRule =
-                        ConfigurationProvider.GetMergedConfigurations(projectFullPath,
+                        _configurationProvider.GetMergedConfigurations(projectFullPath,
                             analyzerCallback.Item1.BuildAnalyzer);
                     if (configPerRule.All(c => !c.IsEnabled))
                     {
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationErrorScope.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationErrorScope.cs
new file mode 100644
index 00000000000..9c4c06511be
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationErrorScope.cs
@@ -0,0 +1,17 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
+internal enum BuildCheckConfigurationErrorScope
+{
+    /// <summary>
+    /// Error related to the single rule.
+    /// </summary>
+    SingleRule,
+
+    /// <summary>
+    /// Error related to the parsing of .editorconfig file. 
+    /// </summary>
+    EditorConfigParser
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
index ed795891df5..69f3335681d 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
@@ -15,7 +15,15 @@ internal sealed class BuildCheckConfigurationException : Exception
     /// Exception to communicate issues with user specified configuration - unsupported scenarios, malformations, etc.
     /// This exception usually leads to defuncting the particular analyzer for the rest of the build (even if issue occured with a single project).
     /// </summary>
-    public BuildCheckConfigurationException(string message) : base(message)
+    internal BuildCheckConfigurationErrorScope buildCheckConfigurationErrorScope;
+
+    public BuildCheckConfigurationException(string message, Exception innerException, BuildCheckConfigurationErrorScope buildCheckConfigurationErrorScope = BuildCheckConfigurationErrorScope.SingleRule) : base(message, innerException)
+    {
+        this.buildCheckConfigurationErrorScope = buildCheckConfigurationErrorScope;
+    }
+
+    public BuildCheckConfigurationException(string message, BuildCheckConfigurationErrorScope buildCheckConfigurationErrorScope = BuildCheckConfigurationErrorScope.SingleRule) : base(message)
     {
+        this.buildCheckConfigurationErrorScope = buildCheckConfigurationErrorScope;
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index 0e425360d0f..f76b6434356 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -64,7 +64,8 @@ public void InitializeComponent(IBuildComponentHost host)
     internal sealed class BuildCheckManager : IBuildCheckManager
     {
         private readonly TracingReporter _tracingReporter = new TracingReporter();
-        private readonly BuildCheckCentralContext _buildCheckCentralContext = new();
+        private readonly ConfigurationProvider _configurationProvider = new ConfigurationProvider();
+        private readonly BuildCheckCentralContext _buildCheckCentralContext;
         private readonly ILoggingService _loggingService;
         private readonly List<BuildAnalyzerFactoryContext> _analyzersRegistry;
         private readonly bool[] _enabledDataSources = new bool[(int)BuildCheckDataSource.ValuesCount];
@@ -76,6 +77,7 @@ internal BuildCheckManager(ILoggingService loggingService)
             _analyzersRegistry = new List<BuildAnalyzerFactoryContext>();
             _acquisitionModule = new BuildCheckAcquisitionModule(loggingService);
             _loggingService = loggingService;
+            _buildCheckCentralContext = new(_configurationProvider);
             _buildEventsProcessor = new(_buildCheckCentralContext);
         }
 
@@ -213,7 +215,7 @@ private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryCont
             if (analyzerFactoryContext.MaterializedAnalyzer == null)
             {
                 BuildAnalyzerConfiguration[] userConfigs =
-                    ConfigurationProvider.GetUserConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
+                    _configurationProvider.GetUserConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
 
                 if (userConfigs.All(c => !(c.IsEnabled ?? analyzerFactoryContext.IsEnabledByDefault)))
                 {
@@ -222,7 +224,7 @@ private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryCont
                 }
 
                 CustomConfigurationData[] customConfigData =
-                    ConfigurationProvider.GetCustomConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
+                    _configurationProvider.GetCustomConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
 
                 ConfigurationContext configurationContext = ConfigurationContext.FromDataEnumeration(customConfigData);
 
@@ -246,7 +248,7 @@ private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryCont
                         $"The analyzer '{analyzer.FriendlyName}' exposes rules '{analyzer.SupportedRules.Select(r => r.Id).ToCsvString()}', but different rules were declared during registration: '{analyzerFactoryContext.RuleIds.ToCsvString()}'");
                 }
 
-                configurations = ConfigurationProvider.GetMergedConfigurations(userConfigs, analyzer);
+                configurations = _configurationProvider.GetMergedConfigurations(userConfigs, analyzer);
 
                 // technically all analyzers rules could be disabled, but that would mean
                 // that the provided 'IsEnabledByDefault' value wasn't correct - the only
@@ -261,9 +263,9 @@ private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryCont
             {
                 wrapper = analyzerFactoryContext.MaterializedAnalyzer;
 
-                configurations = ConfigurationProvider.GetMergedConfigurations(projectFullPath, wrapper.BuildAnalyzer);
+                configurations = _configurationProvider.GetMergedConfigurations(projectFullPath, wrapper.BuildAnalyzer);
 
-                ConfigurationProvider.CheckCustomConfigurationDataValidity(projectFullPath,
+                _configurationProvider.CheckCustomConfigurationDataValidity(projectFullPath,
                     analyzerFactoryContext.RuleIds[0]);
 
                 // Update the wrapper
diff --git a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
index cf2bae57bad..aa804067b60 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
@@ -151,7 +151,7 @@ internal void ProcessTaskParameterEventArgs(
         {
             // Add the parameter name and value to the matching entry in _tasksBeingExecuted. Parameters come typed as IList
             // but it's more natural to pass them as scalar values so we unwrap one-element lists.
-            string parameterName = taskParameterEventArgs.ItemType;
+            string parameterName = taskParameterEventArgs.ParameterName;
             object? parameterValue = taskParameterEventArgs.Items?.Count switch
             {
                 1 => taskParameterEventArgs.Items[0],
diff --git a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
index fe563a087f6..ab2e298879b 100644
--- a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
@@ -3,72 +3,39 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
-using System.IO;
 using System.Linq;
-using System.Text;
-using System.Text.Json.Serialization;
-using System.Text.Json;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
 using Microsoft.Build.Experimental.BuildCheck;
-using System.Configuration;
+using System.Collections.Concurrent;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
-
-// Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)
-// Tracked via: https://github.com/dotnet/msbuild/issues/9828
-internal static class ConfigurationProvider
+internal sealed class ConfigurationProvider
 {
-    // We might want to have a mechanism for removing unneeded configurations
-    //  (disabled rules and analyzers that need to run in different node)
-    private static readonly Dictionary<string, BuildAnalyzerConfiguration> _editorConfig = LoadConfiguration();
-
-    // This is just a testing implementation for quicker unblock of testing.
-    // Real implementation will use .editorconfig file.
-    // Sample json:
-    /////*lang=json,strict*/
-    ////"""
-    ////    {
-    ////        "ABC123": {
-    ////            "IsEnabled": true,
-    ////            "Severity": "Info"
-    ////        },
-    ////        "COND0543": {
-    ////            "IsEnabled": false,
-    ////            "Severity": "Error",
-    ////    		"EvaluationAnalysisScope": "AnalyzedProjectOnly",
-    ////    		"CustomSwitch": "QWERTY"
-    ////        },
-    ////        "BLA": {
-    ////            "IsEnabled": false
-    ////        }
-    ////    }
-    ////    """
-    //
-    // Plus there will need to be a mechanism of distinguishing different configs in different folders
-    //  - e.g. - what to do if we analyze two projects (not sharing output path) and they have different .editorconfig files?
-    private static Dictionary<string, BuildAnalyzerConfiguration> LoadConfiguration()
-    {
-        const string configFileName = "editorconfig.json";
-        string configPath = configFileName;
+    private readonly EditorConfigParser _editorConfigParser = new EditorConfigParser();
 
-        if (!File.Exists(configPath))
-        {
-            // This is just a dummy implementation for testing purposes
-            var dir = Environment.CurrentDirectory;
-            configPath = Path.Combine(dir, configFileName);
+    private const string BuildCheck_ConfigurationKey = "build_check";
 
-            if (!File.Exists(configPath))
-            {
-                return new Dictionary<string, BuildAnalyzerConfiguration>();
-            }
-        }
+    /// <summary>
+    /// The dictionary used for storing the BuildAnalyzerConfiguration per projectfile and rule id. The key is equal to {projectFullPath}-{ruleId}.
+    /// </summary>
+    private readonly ConcurrentDictionary<string, BuildAnalyzerConfiguration> _buildAnalyzerConfiguration = new ConcurrentDictionary<string, BuildAnalyzerConfiguration>(StringComparer.InvariantCultureIgnoreCase);
 
-        var json = File.ReadAllText(configPath);
-        var DeserializationOptions = new JsonSerializerOptions { Converters = { new JsonStringEnumConverter() } };
-        return JsonSerializer.Deserialize<Dictionary<string, BuildAnalyzerConfiguration>>(json, DeserializationOptions) ??
-               new Dictionary<string, BuildAnalyzerConfiguration>();
-    }
+    /// <summary>
+    /// The dictionary used for storing the key-value pairs retrieved from the .editorconfigs for specific projectfile. The key is equal to projectFullPath.
+    /// </summary>
+    private readonly ConcurrentDictionary<string, Dictionary<string, string>> _editorConfigData = new ConcurrentDictionary<string, Dictionary<string, string>>(StringComparer.InvariantCultureIgnoreCase);
+
+    /// <summary>
+    /// The dictionary used for storing the CustomConfigurationData per ruleId. The key is equal to ruleId.
+    /// </summary>
+    private readonly ConcurrentDictionary<string, CustomConfigurationData> _customConfigurationData = new ConcurrentDictionary<string, CustomConfigurationData>(StringComparer.InvariantCultureIgnoreCase);
+
+    private readonly string[] _infrastructureConfigurationKeys = new string[] {
+        nameof(BuildAnalyzerConfiguration.EvaluationAnalysisScope).ToLower(),
+        nameof(BuildAnalyzerConfiguration.IsEnabled).ToLower(),
+        nameof(BuildAnalyzerConfiguration.Severity).ToLower()
+    };
 
     /// <summary>
     /// Gets the user specified unrecognized configuration for the given analyzer rule.
@@ -80,39 +47,82 @@ private static Dictionary<string, BuildAnalyzerConfiguration> LoadConfiguration(
     /// <param name="projectFullPath"></param>
     /// <param name="ruleId"></param>
     /// <returns></returns>
-    public static CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)
+    public CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)
     {
-        return CustomConfigurationData.Null;
+        var configuration = GetConfiguration(projectFullPath, ruleId);
+
+        if (configuration is null)
+        {
+            return CustomConfigurationData.Null;
+        }
+
+        // remove the infrastructure owned key names
+        foreach (var infraConfigurationKey in _infrastructureConfigurationKeys)
+        {
+            configuration.Remove(infraConfigurationKey);
+        }
+
+        if (!configuration.Any())
+        {
+            return CustomConfigurationData.Null;
+        }
+
+        var data = new CustomConfigurationData(ruleId, configuration);
+
+        if (!_customConfigurationData.ContainsKey(ruleId))
+        {
+            _customConfigurationData[ruleId] = data;
+        }
+
+        return data;
     }
 
     /// <summary>
-    /// 
+    /// Verifies if previously fetched custom configurations are equal to current one. 
     /// </summary>
     /// <param name="projectFullPath"></param>
     /// <param name="ruleId"></param>
     /// <throws><see cref="BuildCheckConfigurationException"/> If CustomConfigurationData differs in a build for a same ruleId</throws>
     /// <returns></returns>
-    public static void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)
+    internal void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)
     {
-        // TBD
+        var configuration = GetCustomConfiguration(projectFullPath, ruleId);
+        VerifyCustomConfigurationEquality(ruleId, configuration);
     }
 
-    public static BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
+    internal void VerifyCustomConfigurationEquality(string ruleId, CustomConfigurationData configurationData)
+    {
+        if (_customConfigurationData.TryGetValue(ruleId, out var storedConfiguration))
+        {
+            if (!storedConfiguration.Equals(configurationData))
+            {
+                throw new BuildCheckConfigurationException("Custom configuration should be equal between projects");
+            }
+        }
+    }
+
+    internal BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
         string projectFullPath,
         BuildAnalyzer analyzer)
         => FillConfiguration(projectFullPath, analyzer.SupportedRules, GetMergedConfiguration);
 
-    public static BuildAnalyzerConfiguration[] GetUserConfigurations(
+    internal BuildAnalyzerConfiguration[] GetUserConfigurations(
         string projectFullPath,
         IReadOnlyList<string> ruleIds)
         => FillConfiguration(projectFullPath, ruleIds, GetUserConfiguration);
 
-    public static CustomConfigurationData[] GetCustomConfigurations(
+    /// <summary>
+    /// Retrieve array of CustomConfigurationData for a given projectPath and ruleIds
+    /// </summary>
+    /// <param name="projectFullPath"></param>
+    /// <param name="ruleIds"></param>
+    /// <returns></returns>
+    public CustomConfigurationData[] GetCustomConfigurations(
         string projectFullPath,
         IReadOnlyList<string> ruleIds)
         => FillConfiguration(projectFullPath, ruleIds, GetCustomConfiguration);
 
-    public static BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
+    internal BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
         BuildAnalyzerConfiguration[] userConfigs,
         BuildAnalyzer analyzer)
     {
@@ -120,7 +130,7 @@ public static BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
 
         for (int idx = 0; idx < userConfigs.Length; idx++)
         {
-            configurations[idx] = ConfigurationProvider.MergeConfiguration(
+            configurations[idx] = MergeConfiguration(
                 analyzer.SupportedRules[idx].Id,
                 analyzer.SupportedRules[idx].DefaultConfiguration,
                 userConfigs[idx]);
@@ -129,7 +139,7 @@ public static BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
         return configurations;
     }
 
-    private static TConfig[] FillConfiguration<TConfig, TRule>(string projectFullPath, IReadOnlyList<TRule> ruleIds, Func<string, TRule, TConfig> configurationProvider)
+    private TConfig[] FillConfiguration<TConfig, TRule>(string projectFullPath, IReadOnlyList<TRule> ruleIds, Func<string, TRule, TConfig> configurationProvider)
     {
         TConfig[] configurations = new TConfig[ruleIds.Count];
         for (int i = 0; i < ruleIds.Count; i++)
@@ -140,6 +150,72 @@ private static TConfig[] FillConfiguration<TConfig, TRule>(string projectFullPat
         return configurations;
     }
 
+
+    /// <summary>
+    /// Generates a new dictionary that contains the key-value pairs from the original dictionary if the key starts with 'keyFilter'.
+    /// If updateKey is set to 'true', the keys of the new dictionary will not include keyFilter.
+    /// </summary>
+    /// <param name="keyFilter"></param>
+    /// <param name="originalConfiguration"></param>
+    /// <param name="updateKey"></param>
+    /// <returns></returns>
+    private Dictionary<string, string> FilterDictionaryByKeys(string keyFilter, Dictionary<string, string> originalConfiguration, bool updateKey = false)
+    {
+        var filteredConfig = new Dictionary<string, string>();
+
+        foreach (var kv in originalConfiguration)
+        {
+            if (kv.Key.StartsWith(keyFilter, StringComparison.OrdinalIgnoreCase))
+            {
+                var newKey = kv.Key;
+                if (updateKey)
+                {
+                    newKey = kv.Key.Substring(keyFilter.Length);
+                }
+
+                filteredConfig[newKey] = kv.Value;
+            }
+        }
+
+        return filteredConfig;
+    }
+
+    /// <summary>
+    /// Fetches the .editorconfig data in form of Key-Value pair.
+    /// Resulted dictionary will contain only BuildCheck related rules.
+    /// </summary>
+    /// <param name="projectFullPath"></param>
+    /// <returns></returns>
+    /// <exception cref="BuildCheckConfigurationException"></exception>
+    private Dictionary<string, string> FetchEditorConfigRules(string projectFullPath)
+    {
+        var editorConfigRules = _editorConfigData.GetOrAdd(projectFullPath, (key) =>
+        {
+            Dictionary<string, string> config;
+            try
+            {
+                config = _editorConfigParser.Parse(projectFullPath);
+            }
+            catch (Exception exception)
+            {
+                throw new BuildCheckConfigurationException($"Parsing editorConfig data failed", exception, BuildCheckConfigurationErrorScope.EditorConfigParser);
+            }
+
+            // clear the dictionary from the key-value pairs not BuildCheck related and
+            // store the data so there is no need to parse the .editorconfigs all over again
+            Dictionary<string, string> filteredData = FilterDictionaryByKeys($"{BuildCheck_ConfigurationKey}.", config);
+            return filteredData;
+        });
+        
+        return editorConfigRules;
+    }
+
+    internal Dictionary<string, string> GetConfiguration(string projectFullPath, string ruleId)
+    {
+        var config = FetchEditorConfigRules(projectFullPath);
+        return FilterDictionaryByKeys($"{BuildCheck_ConfigurationKey}.{ruleId}.", config, updateKey: true);
+    }
+
     /// <summary>
     /// Gets effective user specified (or default) configuration for the given analyzer rule.
     /// The configuration values CAN be null upon this operation.
@@ -150,14 +226,24 @@ private static TConfig[] FillConfiguration<TConfig, TRule>(string projectFullPat
     /// <param name="projectFullPath"></param>
     /// <param name="ruleId"></param>
     /// <returns></returns>
-    public static BuildAnalyzerConfiguration GetUserConfiguration(string projectFullPath, string ruleId)
+    internal BuildAnalyzerConfiguration GetUserConfiguration(string projectFullPath, string ruleId)
     {
-        if (!_editorConfig.TryGetValue(ruleId, out BuildAnalyzerConfiguration? editorConfig))
+        var cacheKey = $"{ruleId}-{projectFullPath}";
+
+        var editorConfigValue = _buildAnalyzerConfiguration.GetOrAdd(cacheKey, (key) =>
         {
-            editorConfig = BuildAnalyzerConfiguration.Null;
-        }
+            BuildAnalyzerConfiguration? editorConfig = BuildAnalyzerConfiguration.Null;
+            var config = GetConfiguration(projectFullPath, ruleId);
+
+            if (config.Any())
+            {
+                editorConfig = BuildAnalyzerConfiguration.Create(config);
+            }
+
+            return editorConfig;
+        });
 
-        return editorConfig;
+        return editorConfigValue;
     }
 
     /// <summary>
@@ -167,10 +253,10 @@ public static BuildAnalyzerConfiguration GetUserConfiguration(string projectFull
     /// <param name="projectFullPath"></param>
     /// <param name="analyzerRule"></param>
     /// <returns></returns>
-    public static BuildAnalyzerConfigurationInternal GetMergedConfiguration(string projectFullPath, BuildAnalyzerRule analyzerRule)
+    internal BuildAnalyzerConfigurationInternal GetMergedConfiguration(string projectFullPath, BuildAnalyzerRule analyzerRule)
         => GetMergedConfiguration(projectFullPath, analyzerRule.Id, analyzerRule.DefaultConfiguration);
 
-    public static BuildAnalyzerConfigurationInternal MergeConfiguration(
+    internal BuildAnalyzerConfigurationInternal MergeConfiguration(
         string ruleId,
         BuildAnalyzerConfiguration defaultConfig,
         BuildAnalyzerConfiguration editorConfig)
@@ -180,13 +266,13 @@ public static BuildAnalyzerConfigurationInternal MergeConfiguration(
             isEnabled: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.IsEnabled),
             severity: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.Severity));
 
-    private static BuildAnalyzerConfigurationInternal GetMergedConfiguration(
+    private BuildAnalyzerConfigurationInternal GetMergedConfiguration(
         string projectFullPath,
         string ruleId,
         BuildAnalyzerConfiguration defaultConfig)
         => MergeConfiguration(ruleId, defaultConfig, GetUserConfiguration(projectFullPath, ruleId));
 
-    private static T GetConfigValue<T>(
+    private T GetConfigValue<T>(
         BuildAnalyzerConfiguration editorConfigValue,
         BuildAnalyzerConfiguration defaultValue,
         Func<BuildAnalyzerConfiguration, T?> propertyGetter) where T : struct
diff --git a/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs b/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
index d200d48ee66..afd3645cf2e 100644
--- a/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
+++ b/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
@@ -15,17 +15,27 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 ///  that were attribute to a particular rule, but were not recognized by the infrastructure.
 /// The configuration data that is recognized by the infrastructure is passed as <see cref="BuildAnalyzerConfiguration"/>.
 /// </summary>
-/// <param name="ruleId"></param>
-public class CustomConfigurationData(string ruleId)
+public sealed class CustomConfigurationData
 {
     public static CustomConfigurationData Null { get; } = new(string.Empty);
 
     public static bool NotNull(CustomConfigurationData data) => !Null.Equals(data);
 
+    public CustomConfigurationData(string ruleId)
+    {
+        RuleId = ruleId;
+    }
+
+    public CustomConfigurationData(string ruleId, Dictionary<string, string> properties)
+    {
+        RuleId = ruleId;
+        ConfigurationData = properties;
+    }
+
     /// <summary>
     /// Identifier of the rule that the configuration data is for.
     /// </summary>
-    public string RuleId { get; init; } = ruleId;
+    public string RuleId { get; init; }
 
     /// <summary>
     /// Key-value pairs of unstructured data from .editorconfig file.
@@ -50,15 +60,43 @@ public override bool Equals(object? obj)
             return true;
         }
 
-        if (obj.GetType() != this.GetType())
+        if (obj is not CustomConfigurationData)
         {
             return false;
         }
 
-        return Equals((CustomConfigurationData)obj);
-    }
+        var customConfigObj = (CustomConfigurationData) obj;
 
-    protected bool Equals(CustomConfigurationData other) => Equals(ConfigurationData, other.ConfigurationData);
+        if (customConfigObj.RuleId != RuleId)
+        {
+            return false;
+        }
 
-    public override int GetHashCode() => (ConfigurationData != null ? ConfigurationData.GetHashCode() : 0);
+        // validate keys and values
+        if (customConfigObj.ConfigurationData != null && ConfigurationData != null && ConfigurationData.Count == customConfigObj.ConfigurationData.Count)
+        {
+            foreach (var keyVal in customConfigObj.ConfigurationData)
+            {
+                if (!ConfigurationData.TryGetValue(keyVal.Key, out var value) || value != keyVal.Value)
+                {
+                    return false;
+                }
+            }
+        }
+        else if (customConfigObj.ConfigurationData == null && ConfigurationData == null)
+        {
+            return true;
+        }
+        else
+        {
+            return false;
+        }
+
+        return true;
+    }
+
+    public override int GetHashCode()
+    {
+        throw new NotImplementedException("CustomConfigurationData does not implement GetHashCode method");
+    }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
new file mode 100644
index 00000000000..d2f93664369
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
@@ -0,0 +1,184 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+// Note:
+// Code and logic is copied from the https://github.com/dotnet/roslyn/blob/06d3f153ed6af6f2b78028a1e1e6ecc55c8ff101/src/Compilers/Core/Portable/CommandLine/AnalyzerConfig.cs
+// with slight changes like:
+//  1. Remove dependency from Source text.
+//  2. Remove support of globalconfig
+//  3. Remove the FilePath and receive only the text
+
+using System;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
+
+internal partial class EditorConfigFile
+{
+    // Matches EditorConfig section header such as "[*.{js,py}]", see https://editorconfig.org for details
+    private const string s_sectionMatcherPattern = @"^\s*\[(([^#;]|\\#|\\;)+)\]\s*([#;].*)?$";
+
+    // Matches EditorConfig property such as "indent_style = space", see https://editorconfig.org for details
+    private const string s_propertyMatcherPattern = @"^\s*([\w\.\-_]+)\s*[=:]\s*(.*?)\s*([#;].*)?$";
+
+#if NETCOREAPP
+
+[GeneratedRegex(s_sectionMatcherPattern)]
+private static partial Regex GetSectionMatcherRegex();
+
+[GeneratedRegex(s_propertyMatcherPattern)]
+private static partial Regex GetPropertyMatcherRegex();
+
+#else
+    private static readonly Regex s_sectionMatcher = new Regex(s_sectionMatcherPattern, RegexOptions.Compiled);
+
+    private static readonly Regex s_propertyMatcher = new Regex(s_propertyMatcherPattern, RegexOptions.Compiled);
+
+    private static Regex GetSectionMatcherRegex() => s_sectionMatcher;
+
+    private static Regex GetPropertyMatcherRegex() => s_propertyMatcher;
+
+#endif
+
+    internal Section GlobalSection { get; }
+
+    internal ImmutableArray<Section> NamedSections { get; }
+
+    /// <summary>
+    /// Gets whether this editorconfig is a topmost editorconfig.
+    /// </summary>
+    internal bool IsRoot => GlobalSection.Properties.TryGetValue("root", out string? val) && val?.ToLower() == "true";
+
+    private EditorConfigFile(
+        Section globalSection,
+        ImmutableArray<Section> namedSections)
+    {
+        GlobalSection = globalSection;
+        NamedSections = namedSections;
+    }
+
+    /// <summary>
+    /// Parses an editor config file text located at the given path. No parsing
+    /// errors are reported. If any line contains a parse error, it is dropped.
+    /// </summary>
+    internal static EditorConfigFile Parse(string text)
+    {
+        Section? globalSection = null;
+        var namedSectionBuilder = ImmutableArray.CreateBuilder<Section>();
+
+        // N.B. The editorconfig documentation is quite loose on property interpretation.
+        // Specifically, it says:
+        //      Currently all properties and values are case-insensitive.
+        //      They are lowercased when parsed.
+        // To accommodate this, we use a lower case Unicode mapping when adding to the
+        // dictionary, but we also use a case-insensitive key comparer when doing lookups
+        var activeSectionProperties = ImmutableDictionary.CreateBuilder<string, string>(StringComparer.OrdinalIgnoreCase);
+        string activeSectionName = "";
+        var lines = string.IsNullOrEmpty(text) ? Array.Empty<string>() : text.Split(new string[] { Environment.NewLine }, StringSplitOptions.None);
+
+        foreach(var line in lines)
+        {
+            if (string.IsNullOrWhiteSpace(line))
+            {
+                continue;
+            }
+
+            if (IsComment(line))
+            {
+                continue;
+            }
+
+            var sectionMatches = GetSectionMatcherRegex().Matches(line);
+            if (sectionMatches.Count > 0 && sectionMatches[0].Groups.Count > 0)
+            {
+                addNewSection();
+
+                var sectionName = sectionMatches[0].Groups[1].Value;
+                Debug.Assert(!string.IsNullOrEmpty(sectionName));
+
+                activeSectionName = sectionName;
+                activeSectionProperties = ImmutableDictionary.CreateBuilder<string, string>();
+                continue;
+            }
+
+            var propMatches = GetPropertyMatcherRegex().Matches(line);
+            if (propMatches.Count > 0 && propMatches[0].Groups.Count > 1)
+            {
+                var key = propMatches[0].Groups[1].Value.ToLower();
+                var value = propMatches[0].Groups[2].Value;
+
+                Debug.Assert(!string.IsNullOrEmpty(key));
+                Debug.Assert(key == key.Trim());
+                Debug.Assert(value == value?.Trim());
+
+                activeSectionProperties[key] = value ?? "";
+                continue;
+            }
+        }
+
+        // Add the last section
+        addNewSection();
+
+        return new EditorConfigFile(globalSection!, namedSectionBuilder.ToImmutable());
+
+        void addNewSection()
+        {
+            // Close out the previous section
+            var previousSection = new Section(activeSectionName, activeSectionProperties.ToImmutable());
+            if (activeSectionName == "")
+            {
+                // This is the global section
+                globalSection = previousSection;
+            }
+            else
+            {
+                namedSectionBuilder.Add(previousSection);
+            }
+        }
+    }
+
+    private static bool IsComment(string line)
+    {
+        foreach (char c in line)
+        {
+            if (!char.IsWhiteSpace(c))
+            {
+                return c == '#' || c == ';';
+            }
+        }
+
+        return false;
+    }
+
+    /// <summary>
+    /// Represents a named section of the editorconfig file, which consists of a name followed by a set
+    /// of key-value pairs.
+    /// </summary>
+    internal sealed class Section
+    {
+        public Section(string name, ImmutableDictionary<string, string> properties)
+        {
+            Name = name;
+            Properties = properties;
+        }
+
+        /// <summary>
+        /// For regular files, the name as present directly in the section specification of the editorconfig file. For sections in
+        /// global configs, this is the unescaped full file path.
+        /// </summary>
+        public string Name { get; }
+
+        /// <summary>
+        /// Keys and values for this section. All keys are lower-cased according to the
+        /// EditorConfig specification and keys are compared case-insensitively. 
+        /// </summary>
+        public ImmutableDictionary<string, string> Properties { get; }
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigGlobsMatcher.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigGlobsMatcher.cs
new file mode 100644
index 00000000000..60df42cb36d
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigGlobsMatcher.cs
@@ -0,0 +1,614 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+// Note:
+// Copied from https://github.com/dotnet/roslyn/blob/06d3f153ed6af6f2b78028a1e1e6ecc55c8ff101/src/Compilers/Core/Portable/CommandLine/AnalyzerConfig.SectionNameMatching.cs
+// with some changes to make it quicker to integrate into the MSBuild.
+// Changes:
+//  1. ArrayBuilder was replaced with List.
+//  2. Exceptions. Wrap in try/catch blocks for proper reporting
+
+
+using System;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
+
+internal class EditorConfigGlobsMatcher
+{
+    internal readonly struct SectionNameMatcher
+    {
+        private readonly ImmutableArray<(int minValue, int maxValue)> _numberRangePairs;
+
+        internal Regex Regex { get; }
+
+        internal SectionNameMatcher(
+            Regex regex,
+            ImmutableArray<(int minValue, int maxValue)> numberRangePairs)
+        {
+            Debug.Assert(regex.GetGroupNumbers().Length - 1 == numberRangePairs.Length);
+            Regex = regex;
+            _numberRangePairs = numberRangePairs;
+        }
+
+        internal bool IsMatch(string s)
+        {
+            if (_numberRangePairs.IsEmpty)
+            {
+                return Regex.IsMatch(s);
+            }
+
+            var match = Regex.Match(s);
+            if (!match.Success)
+            {
+                return false;
+            }
+
+            Debug.Assert(match.Groups.Count - 1 == _numberRangePairs.Length);
+            for (int i = 0; i < _numberRangePairs.Length; i++)
+            {
+                var (minValue, maxValue) = _numberRangePairs[i];
+                // Index 0 is the whole regex
+                if (!int.TryParse(match.Groups[i + 1].Value, out int matchedNum) ||
+                    matchedNum < minValue ||
+                    matchedNum > maxValue)
+                {
+                    return false;
+                }
+            }
+            return true;
+        }
+    }
+
+    /// <summary>
+    /// Takes a <see cref="EditorConfigFile.Section.Name"/> and creates a matcher that
+    /// matches the given language. Returns null if the section name is
+    /// invalid.
+    /// </summary>
+    internal static SectionNameMatcher? TryCreateSectionNameMatcher(string sectionName)
+    {
+        // An editorconfig section name is a language for recognizing file paths
+        // defined by the following grammar:
+        //
+        // <path> ::= <path-list>
+        // <path-list> ::= <path-item> | <path-item> <path-list>
+        // <path-item> ::= "*"  | "**" | "?" | <char> | <choice> | <range>
+        // <char> ::= any unicode character
+        // <choice> ::= "{" <choice-list> "}"
+        // <choice-list> ::= <path-list> | <path-list> "," <choice-list>
+        // <range> ::= "{" <integer> ".." <integer> "}"
+        // <integer> ::= "-" <digit-list> | <digit-list>
+        // <digit-list> ::= <digit> | <digit> <digit-list>
+        // <digit> ::= 0-9
+
+        var sb = new StringBuilder();
+        sb.Append('^');
+
+        // EditorConfig matching depends on the whether or not there are
+        // directory separators and where they are located in the section
+        // name. Specifically, the editorconfig core parser says:
+        // https://github.com/editorconfig/editorconfig-core-c/blob/5d3996811e962a717a7d7fdd0a941192382241a7/src/lib/editorconfig.c#L231
+        //
+        //     Pattern would be:
+        //     /dir/of/editorconfig/file[double_star]/[section] if section does not contain '/',
+        //     /dir/of/editorconfig/file[section] if section starts with a '/', or
+        //     /dir/of/editorconfig/file/[section] if section contains '/' but does not start with '/'.
+
+        if (!sectionName.Contains("/"))
+        {
+            sb.Append(".*/");
+        }
+        else if (sectionName[0] != '/')
+        {
+            sb.Append('/');
+        }
+
+        var lexer = new SectionNameLexer(sectionName);
+        var numberRangePairs = new List<(int minValue, int maxValue)>();
+        if (!TryCompilePathList(ref lexer, sb, parsingChoice: false, numberRangePairs))
+        {
+            numberRangePairs.Clear();
+            return null;
+        }
+        sb.Append('$');
+
+
+        var imArray = ImmutableArray.CreateBuilder<(int, int)>(numberRangePairs is null ? 0 : numberRangePairs.Count);
+        if (numberRangePairs?.Count > 0)
+        {
+            imArray.AddRange(numberRangePairs);
+        }
+
+        return new SectionNameMatcher(
+            new Regex(sb.ToString(), RegexOptions.Compiled),
+            imArray.ToImmutableArray());
+    }
+
+    internal static string UnescapeSectionName(string sectionName)
+    {
+        var sb = new StringBuilder();
+        SectionNameLexer lexer = new SectionNameLexer(sectionName);
+        while (!lexer.IsDone)
+        {
+            var tokenKind = lexer.Lex();
+            if (tokenKind == TokenKind.SimpleCharacter)
+            {
+                sb.Append(lexer.EatCurrentCharacter());
+            }
+            else
+            {
+                // We only call this on strings that were already passed through IsAbsoluteEditorConfigPath, so
+                // we shouldn't have any other token kinds here.
+                throw new BuildCheckConfigurationException($"UnexpectedToken: {tokenKind}", BuildCheckConfigurationErrorScope.EditorConfigParser);
+            }
+        }
+        return sb.ToString();
+    }
+
+    internal static bool IsAbsoluteEditorConfigPath(string sectionName)
+    {
+        // NOTE: editorconfig paths must use '/' as a directory separator character on all OS.
+
+        // on all unix systems this is thus a simple test: does the path start with '/'
+        // and contain no special chars?
+
+        // on windows, a path can be either drive rooted or not (e.g. start with 'c:' or just '')
+        // in addition to being absolute or relative.
+        // for example c:myfile.cs is a relative path, but rooted on drive c:
+        // /myfile2.cs is an absolute path but rooted to the current drive.
+
+        // in addition there are UNC paths and volume guids (see https://docs.microsoft.com/en-us/dotnet/standard/io/file-path-formats)
+        // but these start with \\ (and thus '/' in editor config terminology)
+
+        // in this implementation we choose to ignore the drive root for the purposes of
+        // determining validity. On windows c:/file.cs and /file.cs are both assumed to be
+        // valid absolute paths, even though the second one is technically relative to
+        // the current drive of the compiler working directory. 
+
+        // Note that this check has no impact on config correctness. Files on windows
+        // will still be compared using their full path (including drive root) so it's
+        // not possible to target the wrong file. It's just possible that the user won't
+        // receive a warning that this section is ignored on windows in this edge case.
+
+        SectionNameLexer nameLexer = new SectionNameLexer(sectionName);
+        bool sawStartChar = false;
+        int logicalIndex = 0;
+        while (!nameLexer.IsDone)
+        {
+            if (nameLexer.Lex() != TokenKind.SimpleCharacter)
+            {
+                return false;
+            }
+            var simpleChar = nameLexer.EatCurrentCharacter();
+
+            // check the path starts with '/'
+            if (logicalIndex == 0)
+            {
+                if (simpleChar == '/')
+                {
+                    sawStartChar = true;
+                }
+                else if (Path.DirectorySeparatorChar == '/')
+                {
+                    return false;
+                }
+            }
+            // on windows we get a second chance to find the start char
+            else if (!sawStartChar && Path.DirectorySeparatorChar == '\\')
+            {
+                if (logicalIndex == 1 && simpleChar != ':')
+                {
+                    return false;
+                }
+                else if (logicalIndex == 2)
+                {
+                    if (simpleChar != '/')
+                    {
+                        return false;
+                    }
+                    else
+                    {
+                        sawStartChar = true;
+                    }
+                }
+            }
+            logicalIndex++;
+        }
+        return sawStartChar;
+    }
+
+
+    /// <summary>
+    /// <![CDATA[
+    /// <path-list> ::= <path-item> | <path-item> <path-list>
+    /// <path-item> ::= "*"  | "**" | "?" | <char> | <choice> | <range>
+    /// <char> ::= any unicode character
+    /// <choice> ::= "{" <choice-list> "}"
+    /// <choice-list> ::= <path-list> | <path-list> "," <choice-list>
+    /// ]]>
+    /// </summary>
+    private static bool TryCompilePathList(
+        ref SectionNameLexer lexer,
+        StringBuilder sb,
+        bool parsingChoice,
+        List<(int minValue, int maxValue)> numberRangePairs)
+    {
+        while (!lexer.IsDone)
+        {
+            var tokenKind = lexer.Lex();
+            switch (tokenKind)
+            {
+                case TokenKind.BadToken:
+                    // Parsing failure
+                    return false;
+                case TokenKind.SimpleCharacter:
+                    // Matches just this character
+                    sb.Append(Regex.Escape(lexer.EatCurrentCharacter().ToString()));
+                    break;
+                case TokenKind.Question:
+                    // '?' matches any single character
+                    sb.Append('.');
+                    break;
+                case TokenKind.Star:
+                    // Matches any string of characters except directory separator
+                    // Directory separator is defined in editorconfig spec as '/'
+                    sb.Append("[^/]*");
+                    break;
+                case TokenKind.StarStar:
+                    // Matches any string of characters
+                    sb.Append(".*");
+                    break;
+                case TokenKind.OpenCurly:
+                    // Back up token stream. The following helpers all expect a '{'
+                    lexer.Position--;
+                    // This is ambiguous between {num..num} and {item1,item2}
+                    // We need to look ahead to disambiguate. Looking for {num..num}
+                    // is easier because it can't be recursive.
+                    (string numStart, string numEnd)? rangeOpt = TryParseNumberRange(ref lexer);
+                    if (rangeOpt is null)
+                    {
+                        // Not a number range. Try a choice expression
+                        if (!TryCompileChoice(ref lexer, sb, numberRangePairs))
+                        {
+                            return false;
+                        }
+                        // Keep looping. There may be more after the '}'.
+                        break;
+                    }
+                    else
+                    {
+                        (string numStart, string numEnd) = rangeOpt.GetValueOrDefault();
+                        if (int.TryParse(numStart, out var intStart) && int.TryParse(numEnd, out var intEnd))
+                        {
+                            var pair = intStart < intEnd ? (intStart, intEnd) : (intEnd, intStart);
+                            numberRangePairs.Add(pair);
+                            // Group allowing any digit sequence. The validity will be checked outside of the regex
+                            sb.Append("(-?[0-9]+)");
+                            // Keep looping
+                            break;
+                        }
+                        return false;
+                    }
+                case TokenKind.CloseCurly:
+                    // Either the end of a choice, or a failed parse
+                    return parsingChoice;
+                case TokenKind.Comma:
+                    // The end of a choice section, or a failed parse
+                    return parsingChoice;
+                case TokenKind.OpenBracket:
+                    sb.Append('[');
+                    if (!TryCompileCharacterClass(ref lexer, sb))
+                    {
+                        return false;
+                    }
+                    break;
+                default:
+                    throw new BuildCheckConfigurationException($"UnexpectedToken: {tokenKind}", BuildCheckConfigurationErrorScope.EditorConfigParser);
+            }
+        }
+        // If we're parsing a choice we should not exit without a closing '}'
+        return !parsingChoice;
+    }
+
+    /// <summary>
+    /// Compile a globbing character class of the form [...]. Returns true if
+    /// the character class was successfully compiled. False if there was a syntax
+    /// error. The starting character is expected to be directly after the '['.
+    /// </summary>
+    private static bool TryCompileCharacterClass(ref SectionNameLexer lexer, StringBuilder sb)
+    {
+        // [...] should match any of the characters in the brackets, with special
+        // behavior for four characters: '!' immediately after the opening bracket
+        // implies the negation of the character class, '-' implies matching
+        // between the locale-dependent range of the previous and next characters,
+        // '\' escapes the following character, and ']' ends the range
+        if (!lexer.IsDone && lexer.CurrentCharacter == '!')
+        {
+            sb.Append('^');
+            lexer.Position++;
+        }
+        while (!lexer.IsDone)
+        {
+            var currentChar = lexer.EatCurrentCharacter();
+            switch (currentChar)
+            {
+                case '-':
+                    // '-' means the same thing in regex as it does in the glob, so
+                    // put it in verbatim
+                    sb.Append(currentChar);
+                    break;
+
+                case '\\':
+                    // Escape the next char
+                    if (lexer.IsDone)
+                    {
+                        return false;
+                    }
+                    sb.Append('\\');
+                    sb.Append(lexer.EatCurrentCharacter());
+                    break;
+
+                case ']':
+                    sb.Append(currentChar);
+                    return true;
+
+                default:
+                    sb.Append(Regex.Escape(currentChar.ToString()));
+                    break;
+            }
+        }
+        // Stream ended without a closing bracket
+        return false;
+    }
+
+    /// <summary>
+    /// Parses choice defined by the following grammar:
+    /// <![CDATA[
+    /// <choice> ::= "{" <choice-list> "}"
+    /// <choice-list> ::= <path-list> | <path-list> "," <choice-list>
+    /// ]]>
+    /// </summary>
+    private static bool TryCompileChoice(
+        ref SectionNameLexer lexer,
+        StringBuilder sb,
+        List<(int, int)> numberRangePairs)
+    {
+        if (lexer.Lex() != TokenKind.OpenCurly)
+        {
+            return false;
+        }
+
+        // Start a non-capturing group for the choice
+        sb.Append("(?:");
+
+        // We start immediately after a '{'
+        // Try to compile the nested <path-list>
+        while (TryCompilePathList(ref lexer, sb, parsingChoice: true, numberRangePairs))
+        {
+            // If we've successfully compiled a <path-list> the last token should
+            // have been a ',' or a '}'
+            char lastChar = lexer[lexer.Position - 1];
+            if (lastChar == ',')
+            {
+                // Another option
+                sb.Append('|');
+            }
+            else if (lastChar == '}')
+            {
+                // Close out the capture group
+                sb.Append(')');
+                return true;
+            }
+            else
+            {
+                throw new BuildCheckConfigurationException($"UnexpectedValue: {lastChar}", BuildCheckConfigurationErrorScope.EditorConfigParser);
+            }
+        }
+
+        // Propagate failure
+        return false;
+    }
+
+    /// <summary>
+    /// Parses range defined by the following grammar.
+    /// <![CDATA[
+    /// <range> ::= "{" <integer> ".." <integer> "}"
+    /// <integer> ::= "-" <digit-list> | <digit-list>
+    /// <digit-list> ::= <digit> | <digit> <digit-list>
+    /// <digit> ::= 0-9
+    /// ]]>
+    /// </summary>
+    private static (string numStart, string numEnd)? TryParseNumberRange(ref SectionNameLexer lexer)
+    {
+        var saved = lexer.Position;
+        if (lexer.Lex() != TokenKind.OpenCurly)
+        {
+            lexer.Position = saved;
+            return null;
+        }
+
+        var numStart = lexer.TryLexNumber();
+        if (numStart is null)
+        {
+            // Not a number
+            lexer.Position = saved;
+            return null;
+        }
+
+        // The next two characters must be ".."
+        if (!lexer.TryEatCurrentCharacter(out char c) || c != '.' ||
+            !lexer.TryEatCurrentCharacter(out c) || c != '.')
+        {
+            lexer.Position = saved;
+            return null;
+        }
+
+        // Now another number
+        var numEnd = lexer.TryLexNumber();
+        if (numEnd is null || lexer.IsDone || lexer.Lex() != TokenKind.CloseCurly)
+        {
+            // Not a number or no '}'
+            lexer.Position = saved;
+            return null;
+        }
+
+        return (numStart, numEnd);
+    }
+
+    private struct SectionNameLexer
+    {
+        private readonly string _sectionName;
+
+        internal int Position { get; set; }
+
+        internal SectionNameLexer(string sectionName)
+        {
+            _sectionName = sectionName;
+            Position = 0;
+        }
+
+        internal bool IsDone => Position >= _sectionName.Length;
+
+        internal TokenKind Lex()
+        {
+            int lexemeStart = Position;
+            switch (_sectionName[Position])
+            {
+                case '*':
+                    {
+                        int nextPos = Position + 1;
+                        if (nextPos < _sectionName.Length &&
+                            _sectionName[nextPos] == '*')
+                        {
+                            Position += 2;
+                            return TokenKind.StarStar;
+                        }
+                        else
+                        {
+                            Position++;
+                            return TokenKind.Star;
+                        }
+                    }
+
+                case '?':
+                    Position++;
+                    return TokenKind.Question;
+
+                case '{':
+                    Position++;
+                    return TokenKind.OpenCurly;
+
+                case ',':
+                    Position++;
+                    return TokenKind.Comma;
+
+                case '}':
+                    Position++;
+                    return TokenKind.CloseCurly;
+
+                case '[':
+                    Position++;
+                    return TokenKind.OpenBracket;
+
+                case '\\':
+                    {
+                        // Backslash escapes the next character
+                        Position++;
+                        if (IsDone)
+                        {
+                            return TokenKind.BadToken;
+                        }
+
+                        return TokenKind.SimpleCharacter;
+                    }
+
+                default:
+                    // Don't increment position, since caller needs to fetch the character
+                    return TokenKind.SimpleCharacter;
+            }
+        }
+
+        internal char CurrentCharacter => _sectionName[Position];
+
+        /// <summary>
+        /// Call after getting <see cref="TokenKind.SimpleCharacter" /> from <see cref="Lex()" />
+        /// </summary>
+        internal char EatCurrentCharacter() => _sectionName[Position++];
+
+        /// <summary>
+        /// Returns false if there are no more characters in the lex stream.
+        /// Otherwise, produces the next character in the stream and returns true.
+        /// </summary>
+        internal bool TryEatCurrentCharacter(out char nextChar)
+        {
+            if (IsDone)
+            {
+                nextChar = default;
+                return false;
+            }
+            else
+            {
+                nextChar = EatCurrentCharacter();
+                return true;
+            }
+        }
+
+        internal char this[int position] => _sectionName[position];
+
+        /// <summary>
+        /// Returns the string representation of a decimal integer, or null if
+        /// the current lexeme is not an integer.
+        /// </summary>
+        internal string? TryLexNumber()
+        {
+            bool start = true;
+            var sb = new StringBuilder();
+
+            while (!IsDone)
+            {
+                char currentChar = CurrentCharacter;
+                if (start && currentChar == '-')
+                {
+                    Position++;
+                    sb.Append('-');
+                }
+                else if (char.IsDigit(currentChar))
+                {
+                    Position++;
+                    sb.Append(currentChar);
+                }
+                else
+                {
+                    break;
+                }
+                start = false;
+            }
+
+            var str = sb.ToString();
+            return str.Length == 0 || str == "-"
+                ? null
+                : str;
+        }
+    }
+
+    private enum TokenKind
+    {
+        BadToken,
+        SimpleCharacter,
+        Star,
+        StarStar,
+        Question,
+        OpenCurly,
+        CloseCurly,
+        Comma,
+        DoubleDot,
+        OpenBracket,
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
new file mode 100644
index 00000000000..76baa1f1e66
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
@@ -0,0 +1,104 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Concurrent;
+using System.Collections.Generic;
+using System.Drawing.Design;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Shared;
+using static Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
+
+internal sealed class EditorConfigParser
+{
+    private const string EditorconfigFile = ".editorconfig";
+
+    /// <summary>
+    /// Cache layer of the parsed editor configs the key is the path to the .editorconfig file.
+    /// </summary>
+    private readonly ConcurrentDictionary<string, EditorConfigFile> _editorConfigFileCache = new ConcurrentDictionary<string, EditorConfigFile>(StringComparer.InvariantCultureIgnoreCase);
+
+    internal Dictionary<string, string> Parse(string filePath)
+    {
+        var editorConfigs = DiscoverEditorConfigFiles(filePath);
+        return MergeEditorConfigFiles(editorConfigs, filePath);
+    }
+
+    /// <summary>
+    /// Fetches the list of EditorconfigFile ordered from the nearest to the filePath.
+    /// </summary>
+    /// <param name="filePath"></param>
+    internal List<EditorConfigFile> DiscoverEditorConfigFiles(string filePath)
+    {
+        var editorConfigDataFromFilesList = new List<EditorConfigFile>();
+
+        var directoryOfTheProject = Path.GetDirectoryName(filePath);
+        // The method will look for the file in parent directory if not found in current until found or the directory is root. 
+        var editorConfigFilePath = FileUtilities.GetPathOfFileAbove(EditorconfigFile, directoryOfTheProject);
+
+        while (editorConfigFilePath != string.Empty)
+        {
+            var editorConfig = _editorConfigFileCache.GetOrAdd(editorConfigFilePath, (key) =>
+            {
+                using (FileStream stream = new FileStream(editorConfigFilePath, FileMode.Open, System.IO.FileAccess.Read, FileShare.Read))
+                {
+                    using StreamReader sr = new StreamReader(editorConfigFilePath);
+                    var editorConfigfileContent = sr.ReadToEnd();
+                    return EditorConfigFile.Parse(editorConfigfileContent);
+                }
+            });
+
+            editorConfigDataFromFilesList.Add(editorConfig);
+
+            if (editorConfig.IsRoot)
+            {
+                break;
+            }
+            else
+            {
+                // search in upper directory
+                editorConfigFilePath = FileUtilities.GetPathOfFileAbove(EditorconfigFile, Path.GetDirectoryName(Path.GetDirectoryName(editorConfigFilePath)));
+            }
+        }
+
+        return editorConfigDataFromFilesList;
+    }
+
+    /// <summary>
+    /// Retrieves the config dictionary from the sections that matched the filePath. 
+    /// </summary>
+    /// <param name="editorConfigFiles"></param>
+    /// <param name="filePath"></param>
+    internal Dictionary<string, string> MergeEditorConfigFiles(List<EditorConfigFile> editorConfigFiles, string filePath)
+    {
+        var resultingDictionary = new Dictionary<string, string>(StringComparer.InvariantCultureIgnoreCase);
+
+        for (int i = editorConfigFiles.Count - 1; i >= 0; i--)
+        {
+            foreach (var section in editorConfigFiles[i].NamedSections)
+            {
+                SectionNameMatcher? sectionNameMatcher = TryCreateSectionNameMatcher(section.Name);
+                if (sectionNameMatcher != null)
+                {
+                    if (sectionNameMatcher.Value.IsMatch(NormalizeWithForwardSlash(filePath)))
+                    {
+                        foreach (var property in section.Properties)
+                        {
+                            resultingDictionary[property.Key] = property.Value;
+                        }
+                    }
+                }
+            }
+        }
+        
+        return resultingDictionary;
+    }
+
+    internal static string NormalizeWithForwardSlash(string p) => Path.DirectorySeparatorChar == '/' ? p : p.Replace(Path.DirectorySeparatorChar, '/');
+}
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md b/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md
new file mode 100644
index 00000000000..e19b61c2c40
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md
@@ -0,0 +1,98 @@
+﻿# EditorConfigParser
+
+Logic of parsing and matching copied from Roslyn implementation.
+To track the request on sharing the code: https://github.com/dotnet/roslyn/issues/72324
+
+
+In current implementation the usage of the editorconfig is internal only and exposed via ConfigurationProvider functionality. 
+
+Configuration divided into two categories: 
+- Infra related configuration. IsEnabled, Severity, EvaluationAnalysisScope
+- Custom configuration, any other config specified by user for this particular rule
+
+### Example
+For the file/folder structure: 
+```
+├── folder1/
+│   └── .editorconfig
+│   └── folder2/
+        ├── folder3/
+        │   └── .editorconfig
+        │   └── test.proj
+        └── .editorconfig
+```
+
+we want to fetch configuration for the project: /full/path/folder1/folder2/folder3/test.proj 
+
+Infra related and custom configuration flows have one common logic: Fetching the configs from editorconfig
+
+```
+while(editorConfig is not root && parent directory exists){
+        collect, parse editorconfigs 
+}
+
+list<editorConfig>{
+    folder1/folder2/folder3/.editorconfig
+    folder1/folder2/.editorconfig
+    folder1/.editorconfig
+}
+```
+Reverse the order and collect all matching section key-value pairs into new dictionary
+Remove non-msbuild-analyzer related key-values (keys not starting with msbuild_analyzer.RULEID)
+
+The implementation differs depending on category: 
+ - Infra related config: Merges the configuration retrieved from configuration module with default values (respecting the specified configs in editorconfig) 
+ - Custom configuration: Remove all infra related keys from dictionary
+
+Four levels of cache introduced: 
+- When retrieving and parsing the editor config -> Parsed results are saved into dictionary: editorconfigPath = ParsedEditorConfig
+- When retrieving and merging the editor config data for project -> Parsed and merged results are saved into dictionary: projectFilePath = MargedData of ParsedEditorConfig
+- When retrieving Infra related config: ruleId-projectPath = BuildConfigInstance
+- CustomConfigurationData: In order to verify that the config data is the same between projects
+
+Usage examples (API)
+
+```
+var editorConfigParser = new EditorConfigParser();
+editorConfigParser.Parse("path/to/the/file")
+```
+
+The snippet above will return all applied key-value Dictionary<string, string> pairs collected from .editorconfig files
+
+Currently EditorConfigParser is used by [ConfigurationProvider](https://github.com/dotnet/msbuild/blob/e0dfb8d1ce5fc1de5153e65ea04c66a6dcac6279/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs#L129).
+
+#### Cache lifetime
+The lifetime of the cached configuration is defined by the usage of the instance of ConfigurationProvider. The instance of the ConfigurationProvider is created per BuildCheckManager.
+Lifecycle of BuildCheckManager could be found [here](https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#handling-the-distributed-model)
+
+
+#### Custom configuration data
+CustomConfigurationData is propogated to the BuildCheck Analyzer instance by passing the instance of [ConfigurationContext](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/ConfigurationContext.cs#L14)
+during the initialization of the [BuildAnalyzer](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/BuildAnalyzer.cs#L36).
+
+
+#### Example of consuming the CustomConfigurationData
+The `Initialize` method of BuildCheck Analyzer:
+```C#
+public override void Initialize(ConfigurationContext configurationContext)
+{
+    Console.WriteLine(configurationContext.CustomConfigurationData.Count);
+    for (int i = 0; i < configurationContext.CustomConfigurationData.Count; i++)
+    {
+        var customConfigPerRule = configurationContext.CustomConfigurationData[i]; 
+        Console.WriteLine(customConfigPerRule.RuleId); 
+
+        if (customConfigPerRule.ConfigurationData is not null) // null when the configuration was not provided from editorconfig
+        {
+            foreach (var kv in customConfigPerRule.ConfigurationData)
+            {
+                Console.WriteLine($"{kv.Key}------{kv.Value}");
+            }
+        }
+        else
+        {
+            Console.WriteLine($"The data is null for index: {i}");
+        }
+    }
+}
+```
diff --git a/src/Build/BuildCheck/Utilities/Constants.cs b/src/Build/BuildCheck/Utilities/Constants.cs
index 8ba5eaf65f6..50a3d1bc63c 100644
--- a/src/Build/BuildCheck/Utilities/Constants.cs
+++ b/src/Build/BuildCheck/Utilities/Constants.cs
@@ -7,13 +7,12 @@
 using System.Text;
 using System.Threading.Tasks;
 
-namespace Microsoft.Build.Experimental.BuildCheck.Utilities
+namespace Microsoft.Build.Experimental.BuildCheck.Utilities;
+
+/// <summary>
+/// Constants to be shared within BuildCheck infrastructure
+/// </summary>
+internal static class BuildCheckConstants
 {
-    /// <summary>
-    /// Constants to be shared within BuildCheck infrastructure
-    /// </summary>
-    internal static class BuildCheckConstants
-    {
-        internal const string infraStatPrefix = "infrastructureStat_";
-    }
+    internal const string infraStatPrefix = "infrastructureStat_";
 }
diff --git a/src/Build/Construction/ProjectPropertyElement.cs b/src/Build/Construction/ProjectPropertyElement.cs
index c9020db30ba..8929dea6406 100644
--- a/src/Build/Construction/ProjectPropertyElement.cs
+++ b/src/Build/Construction/ProjectPropertyElement.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Diagnostics;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Internal;
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
@@ -20,7 +21,7 @@ namespace Microsoft.Build.Construction
     /// So the CM only represents Normal properties.
     /// </remarks>
     [DebuggerDisplay("{Name} Value={Value} Condition={Condition}")]
-    public class ProjectPropertyElement : ProjectElement
+    public class ProjectPropertyElement : ProjectElement, IPropertyElementWithLocation
     {
         internal ProjectPropertyElementLink PropertyLink => (ProjectPropertyElementLink)Link;
 
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 791c88c741c..741babe959c 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -4263,7 +4263,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// <summary>
             /// Prepares the data object for evaluation.
             /// </summary>
-            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext)
+            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext, LoggingContext loggingContext)
             {
                 DefaultTargets = null;
                 Properties = new PropertyDictionary<ProjectProperty>();
@@ -4271,7 +4271,7 @@ public void InitializeForEvaluation(IToolsetProvider toolsetProvider, Evaluation
                 Items = new ItemDictionary<ProjectItem>();
                 ItemsIgnoringCondition = new ItemDictionary<ProjectItem>();
                 ItemsByEvaluatedIncludeCache = new MultiDictionary<string, ProjectItem>(StringComparer.OrdinalIgnoreCase);
-                Expander = new Expander<ProjectProperty, ProjectItem>(Properties, Items, evaluationContext);
+                Expander = new Expander<ProjectProperty, ProjectItem>(Properties, Items, evaluationContext, loggingContext);
                 ItemDefinitions = new RetrievableEntryHashSet<ProjectItemDefinition>(MSBuildNameIgnoreCaseComparer.Default);
                 Targets = new RetrievableEntryHashSet<ProjectTargetInstance>(StringComparer.OrdinalIgnoreCase);
                 ImportClosure = new List<ResolvedImport>();
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index bf9ae352007..eee61cb02f5 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -9,6 +9,7 @@
 using System.Linq;
 using System.Xml;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
@@ -685,7 +686,7 @@ internal static Toolset FactoryForDeserialization(ITranslator translator)
         /// <summary>
         /// Given a search path and a task pattern get a list of task or override task files.
         /// </summary>
-        internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, ILoggingService loggingServices, BuildEventContext buildEventContext, string taskPattern, string searchPath, string taskFileWarning)
+        internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, LoggingContext loggingContext, string taskPattern, string searchPath, string taskFileWarning)
         {
             string[] defaultTasksFiles = null;
 
@@ -703,8 +704,7 @@ internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, ILoggingServic
 
                 if (defaultTasksFiles.Length == 0)
                 {
-                    loggingServices.LogWarning(
-                        buildEventContext,
+                    loggingContext.LogWarning(
                         null,
                         new BuildEventFileInfo(/* this warning truly does not involve any file */ String.Empty),
                         taskFileWarning,
@@ -715,8 +715,7 @@ internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, ILoggingServic
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
-                loggingServices.LogWarning(
-                    buildEventContext,
+                loggingContext.LogWarning(
                     null,
                     new BuildEventFileInfo(/* this warning truly does not involve any file */ String.Empty),
                     taskFileWarning,
@@ -819,13 +818,12 @@ internal string GenerateSubToolsetVersion(int visualStudioVersionFromSolution)
         /// <summary>
         /// Return a task registry stub for the tasks in the *.tasks file for this toolset
         /// </summary>
-        /// <param name="loggingServices">The logging services used to log during task registration.</param>
-        /// <param name="buildEventContext">The build event context used to log during task registration.</param>
+        /// <param name="loggingContext">The logging context used to log during task registration.</param>
         /// <param name="projectRootElementCache">The <see cref="ProjectRootElementCache"/> to use.</param>
         /// <returns>The task registry</returns>
-        internal TaskRegistry GetTaskRegistry(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCacheBase projectRootElementCache)
+        internal TaskRegistry GetTaskRegistry(LoggingContext loggingContext, ProjectRootElementCacheBase projectRootElementCache)
         {
-            RegisterDefaultTasks(loggingServices, buildEventContext, projectRootElementCache);
+            RegisterDefaultTasks(loggingContext, projectRootElementCache);
             return _defaultTaskRegistry;
         }
 
@@ -846,13 +844,12 @@ internal string GenerateSubToolsetVersionUsingVisualStudioVersion(IDictionary<st
         /// <summary>
         /// Return a task registry for the override tasks in the *.overridetasks file for this toolset
         /// </summary>
-        /// <param name="loggingServices">The logging services used to log during task registration.</param>
-        /// <param name="buildEventContext">The build event context used to log during task registration.</param>
+        /// <param name="loggingContext">The logging context used to log during task registration.</param>
         /// <param name="projectRootElementCache">The <see cref="ProjectRootElementCache"/> to use.</param>
         /// <returns>The task registry</returns>
-        internal TaskRegistry GetOverrideTaskRegistry(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCacheBase projectRootElementCache)
+        internal TaskRegistry GetOverrideTaskRegistry(LoggingContext loggingContext, ProjectRootElementCacheBase projectRootElementCache)
         {
-            RegisterOverrideTasks(loggingServices, buildEventContext, projectRootElementCache);
+            RegisterOverrideTasks(loggingContext, projectRootElementCache);
             return _overrideTaskRegistry;
         }
 
@@ -867,10 +864,9 @@ internal TaskRegistry GetOverrideTaskRegistry(ILoggingService loggingServices, B
         /// 3) comment tags are always ignored regardless of their placement
         /// 4) the rest of the tags are expected to be &lt;UsingTask&gt; tags
         /// </remarks>
-        /// <param name="loggingServices">The logging services to use to log during this registration.</param>
-        /// <param name="buildEventContext">The build event context to use to log during this registration.</param>
+        /// <param name="loggingContext">The logging context to use to log during this registration.</param>
         /// <param name="projectRootElementCache">The <see cref="ProjectRootElementCache"/> to use.</param>
-        private void RegisterDefaultTasks(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCacheBase projectRootElementCache)
+        private void RegisterDefaultTasks(LoggingContext loggingContext, ProjectRootElementCacheBase projectRootElementCache)
         {
             if (!_defaultTasksRegistrationAttempted)
             {
@@ -878,10 +874,10 @@ private void RegisterDefaultTasks(ILoggingService loggingServices, BuildEventCon
                 {
                     _defaultTaskRegistry = new TaskRegistry(projectRootElementCache);
 
-                    InitializeProperties(loggingServices, buildEventContext);
+                    InitializeProperties(loggingContext);
 
-                    string[] defaultTasksFiles = GetTaskFiles(_getFiles, loggingServices, buildEventContext, DefaultTasksFilePattern, ToolsPath, "DefaultTasksFileLoadFailureWarning");
-                    LoadAndRegisterFromTasksFile(defaultTasksFiles, loggingServices, buildEventContext, "DefaultTasksFileFailure", projectRootElementCache, _defaultTaskRegistry);
+                    string[] defaultTasksFiles = GetTaskFiles(_getFiles, loggingContext, DefaultTasksFilePattern, ToolsPath, "DefaultTasksFileLoadFailureWarning");
+                    LoadAndRegisterFromTasksFile(defaultTasksFiles, loggingContext, "DefaultTasksFileFailure", projectRootElementCache, _defaultTaskRegistry);
                 }
                 finally
                 {
@@ -893,7 +889,7 @@ private void RegisterDefaultTasks(ILoggingService loggingServices, BuildEventCon
         /// <summary>
         /// Initialize the properties which are used to evaluate the tasks files.
         /// </summary>
-        private void InitializeProperties(ILoggingService loggingServices, BuildEventContext buildEventContext)
+        private void InitializeProperties(LoggingContext loggingContext)
         {
             if (_expander != null)
             {
@@ -965,18 +961,18 @@ private void InitializeProperties(ILoggingService loggingServices, BuildEventCon
 
                 propertyBag.ImportProperties(_globalProperties);
 
-                _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, FileSystems.Default);
+                _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, FileSystems.Default, loggingContext);
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
-                loggingServices.LogError(buildEventContext, new BuildEventFileInfo(/* this warning truly does not involve any file it is just gathering properties */String.Empty), "TasksPropertyBagError", e.Message);
+                loggingContext.LogError(new BuildEventFileInfo(/* this warning truly does not involve any file it is just gathering properties */String.Empty), "TasksPropertyBagError", e.Message);
             }
         }
 
         /// <summary>
         /// Used to load information about MSBuild override tasks i.e. tasks that override tasks declared in tasks or project files.
         /// </summary>
-        private void RegisterOverrideTasks(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCacheBase projectRootElementCache)
+        private void RegisterOverrideTasks(LoggingContext loggingContext, ProjectRootElementCacheBase projectRootElementCache)
         {
             if (!_overrideTasksRegistrationAttempted)
             {
@@ -1005,23 +1001,23 @@ private void RegisterOverrideTasks(ILoggingService loggingServices, BuildEventCo
                             if (!overrideDirectoryExists)
                             {
                                 string rootedPathMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OverrideTaskNotRootedPath", _overrideTasksPath);
-                                loggingServices.LogWarning(buildEventContext, null, new BuildEventFileInfo(String.Empty /* this warning truly does not involve any file*/), "OverrideTasksFileFailure", rootedPathMessage);
+                                loggingContext.LogWarning(null, new BuildEventFileInfo(String.Empty /* this warning truly does not involve any file*/), "OverrideTasksFileFailure", rootedPathMessage);
                             }
                         }
                     }
                     catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
                     {
                         string rootedPathMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OverrideTaskProblemWithPath", _overrideTasksPath, e.Message);
-                        loggingServices.LogWarning(buildEventContext, null, new BuildEventFileInfo(String.Empty /* this warning truly does not involve any file*/), "OverrideTasksFileFailure", rootedPathMessage);
+                        loggingContext.LogWarning(null, new BuildEventFileInfo(String.Empty /* this warning truly does not involve any file*/), "OverrideTasksFileFailure", rootedPathMessage);
                     }
 
                     if (overrideDirectoryExists)
                     {
-                        InitializeProperties(loggingServices, buildEventContext);
-                        string[] overrideTasksFiles = GetTaskFiles(_getFiles, loggingServices, buildEventContext, OverrideTasksFilePattern, _overrideTasksPath, "OverrideTasksFileLoadFailureWarning");
+                        InitializeProperties(loggingContext);
+                        string[] overrideTasksFiles = GetTaskFiles(_getFiles, loggingContext, OverrideTasksFilePattern, _overrideTasksPath, "OverrideTasksFileLoadFailureWarning");
 
                         // Load and register any override tasks
-                        LoadAndRegisterFromTasksFile(overrideTasksFiles, loggingServices, buildEventContext, "OverrideTasksFileFailure", projectRootElementCache, _overrideTaskRegistry);
+                        LoadAndRegisterFromTasksFile(overrideTasksFiles, loggingContext, "OverrideTasksFileFailure", projectRootElementCache, _overrideTaskRegistry);
                     }
                 }
                 finally
@@ -1034,14 +1030,13 @@ private void RegisterOverrideTasks(ILoggingService loggingServices, BuildEventCo
         /// <summary>
         /// Do the actual loading of the tasks or override tasks file and register the tasks in the task registry
         /// </summary>
-        private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, ILoggingService loggingServices, BuildEventContext buildEventContext, string taskFileError, ProjectRootElementCacheBase projectRootElementCache, TaskRegistry registry)
+        private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, LoggingContext loggingContext, string taskFileError, ProjectRootElementCacheBase projectRootElementCache, TaskRegistry registry)
         {
             string currentTasksFile = null;
             try
             {
                 TaskRegistry.InitializeTaskRegistryFromUsingTaskElements<ProjectPropertyInstance, ProjectItemInstance>(
-                    loggingServices,
-                    buildEventContext,
+                    loggingContext,
                     EnumerateTasksRegistrations(),
                     registry,
                     _expander,
@@ -1056,7 +1051,7 @@ private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, ILoggingSer
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
-                loggingServices.LogError(buildEventContext, new BuildEventFileInfo(currentTasksFile),
+                loggingContext.LogError(new BuildEventFileInfo(currentTasksFile),
                     taskFileError, e.Message);
             }
 
diff --git a/src/Build/Evaluation/ConditionEvaluator.cs b/src/Build/Evaluation/ConditionEvaluator.cs
index 1d231597726..f7918c19052 100644
--- a/src/Build/Evaluation/ConditionEvaluator.cs
+++ b/src/Build/Evaluation/ConditionEvaluator.cs
@@ -186,11 +186,9 @@ internal static bool EvaluateCondition<P, I>(
             ExpanderOptions expanderOptions,
             string evaluationDirectory,
             ElementLocation elementLocation,
-            ILoggingService loggingServices,
-            BuildEventContext buildEventContext,
             IFileSystem fileSystem,
-            ProjectRootElementCacheBase? projectRootElementCache = null,
-            LoggingContext? loggingContext = null)
+            LoggingContext? loggingContext,
+            ProjectRootElementCacheBase? projectRootElementCache = null)
             where P : class, IProperty
             where I : class, IItem
         {
@@ -202,11 +200,9 @@ internal static bool EvaluateCondition<P, I>(
                 conditionedPropertiesTable: null /* do not collect conditioned properties */,
                 evaluationDirectory,
                 elementLocation,
-                loggingServices,
-                buildEventContext,
                 fileSystem,
-                projectRootElementCache,
-                loggingContext);
+                loggingContext,
+                projectRootElementCache);
         }
 
         /// <summary>
@@ -224,18 +220,15 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>(
             Dictionary<string, List<string>>? conditionedPropertiesTable,
             string evaluationDirectory,
             ElementLocation elementLocation,
-            ILoggingService loggingServices,
-            BuildEventContext buildEventContext,
             IFileSystem fileSystem,
-            ProjectRootElementCacheBase? projectRootElementCache = null,
-            LoggingContext? loggingContext = null)
+            LoggingContext? loggingContext,
+            ProjectRootElementCacheBase? projectRootElementCache = null)
             where P : class, IProperty
             where I : class, IItem
         {
             ErrorUtilities.VerifyThrowArgumentNull(condition, nameof(condition));
             ErrorUtilities.VerifyThrowArgumentNull(expander, nameof(expander));
             ErrorUtilities.VerifyThrowArgumentLength(evaluationDirectory, nameof(evaluationDirectory));
-            ErrorUtilities.VerifyThrowArgumentNull(buildEventContext, nameof(buildEventContext));
 
             // An empty condition is equivalent to a "true" condition.
             if (condition.Length == 0)
@@ -263,8 +256,8 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>(
                 var conditionParser = new Parser();
 
                 #region REMOVE_COMPAT_WARNING
-                conditionParser.LoggingServices = loggingServices;
-                conditionParser.LogBuildEventContext = buildEventContext;
+                conditionParser.LoggingServices = loggingContext?.LoggingService;
+                conditionParser.LogBuildEventContext = loggingContext?.BuildEventContext ?? BuildEventContext.Invalid;
                 #endregion
 
                 parsedExpression = conditionParser.Parse(condition, options, elementLocation);
@@ -282,13 +275,14 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>(
                 fileSystem,
                 projectRootElementCache);
 
+            expander.PropertiesUseTracker.PropertyReadContext = PropertyReadContext.ConditionEvaluation;
             // We are evaluating this expression now and it can cache some state for the duration,
             // so we don't want multiple threads working on the same expression
             lock (parsedExpression)
             {
                 try
                 {
-                    result = parsedExpression.Evaluate(state, loggingContext);
+                    result = parsedExpression.Evaluate(state);
                 }
                 finally
                 {
@@ -298,6 +292,7 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>(
                         // Finished using the expression tree. Add it back to the pool so other threads can use it.
                         expressionPool.Push(parsedExpression);
                     }
+                    expander.PropertiesUseTracker.ResetPropertyReadContext();
                 }
             }
 
@@ -350,6 +345,8 @@ internal interface IConditionEvaluationState
 
             ElementLocation ElementLocation { get; }
 
+            PropertiesUseTracker PropertiesUseTracker { get; }
+
             /// <summary>
             ///     Table of conditioned properties and their values.
             ///     Used to populate configuration lists in some project systems.
@@ -362,7 +359,7 @@ internal interface IConditionEvaluationState
             ///     May return null if the expression would expand to non-empty and it broke out early.
             ///     Otherwise, returns the correctly expanded expression.
             /// </summary>
-            string ExpandIntoStringBreakEarly(string expression, LoggingContext? loggingContext = null);
+            string ExpandIntoStringBreakEarly(string expression);
 
             /// <summary>
             ///     Expands the specified expression into a list of TaskItem's.
@@ -372,7 +369,7 @@ internal interface IConditionEvaluationState
             /// <summary>
             ///     Expands the specified expression into a string.
             /// </summary>
-            string ExpandIntoString(string expression, LoggingContext? loggingContext = null);
+            string ExpandIntoString(string expression);
 
             /// <summary>
             ///     PRE cache
@@ -403,6 +400,8 @@ internal class ConditionEvaluationState<P, I> : IConditionEvaluationState
 
             public ElementLocation ElementLocation { get; }
 
+            public PropertiesUseTracker PropertiesUseTracker => _expander.PropertiesUseTracker;
+
             public IFileSystem FileSystem { get; }
 
             /// <summary>
@@ -447,13 +446,9 @@ internal ConditionEvaluationState(
             /// May return null if the expression would expand to non-empty and it broke out early.
             /// Otherwise, returns the correctly expanded expression.
             /// </summary>
-            public string ExpandIntoStringBreakEarly(string expression, LoggingContext? loggingContext = null)
+            public string ExpandIntoStringBreakEarly(string expression)
             {
-                var originalValue = _expander.WarnForUninitializedProperties;
-
-                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions | ExpanderOptions.BreakOnNotEmpty, ElementLocation, loggingContext);
-
-                _expander.WarnForUninitializedProperties = originalValue;
+                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions | ExpanderOptions.BreakOnNotEmpty, ElementLocation);
 
                 return expression;
             }
@@ -465,12 +460,8 @@ public string ExpandIntoStringBreakEarly(string expression, LoggingContext? logg
             /// <returns>A list of items.</returns>
             public IList<TaskItem> ExpandIntoTaskItems(string expression)
             {
-                var originalValue = _expander.WarnForUninitializedProperties;
-
                 var items = _expander.ExpandIntoTaskItemsLeaveEscaped(expression, _expanderOptions, ElementLocation);
 
-                _expander.WarnForUninitializedProperties = originalValue;
-
                 return items;
             }
 
@@ -478,15 +469,10 @@ public IList<TaskItem> ExpandIntoTaskItems(string expression)
             /// Expands the specified expression into a string.
             /// </summary>
             /// <param name="expression">The expression to expand.</param>
-            /// <param name="loggingContext"></param>
             /// <returns>The expanded string.</returns>
-            public string ExpandIntoString(string expression, LoggingContext? loggingContext = null)
+            public string ExpandIntoString(string expression)
             {
-                var originalValue = _expander.WarnForUninitializedProperties;
-
-                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions, ElementLocation, loggingContext);
-
-                _expander.WarnForUninitializedProperties = originalValue;
+                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions, ElementLocation);
 
                 return expression;
             }
diff --git a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
index ce021dc2f10..1303731a2f6 100644
--- a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
@@ -19,9 +19,9 @@ internal sealed class AndExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool, loggingContext))
+            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                      state.ElementLocation,
@@ -38,7 +38,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             }
             else
             {
-                if (!RightChild.TryBoolEvaluate(state, out bool rightBool, loggingContext))
+                if (!RightChild.TryBoolEvaluate(state, out bool rightBool))
                 {
                     ProjectErrorUtilities.ThrowInvalidProject(
                          state.ElementLocation,
diff --git a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
index e16e7537379..6d7b27eb243 100644
--- a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
@@ -30,7 +30,7 @@ internal FunctionCallExpressionNode(string functionName, List<GenericExpressionN
         /// <summary>
         /// Evaluate node as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
             if (String.Equals(_functionName, "exists", StringComparison.OrdinalIgnoreCase))
             {
diff --git a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
index 3d0d6d99456..e8a7858d415 100644
--- a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
@@ -14,9 +14,9 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class GenericExpressionNode
     {
-        internal abstract bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null);
-        internal abstract bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null);
-        internal abstract bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null);
+        internal abstract bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result);
+        internal abstract bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result);
+        internal abstract bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result);
 
         /// <summary>
         /// Returns true if this node evaluates to an empty string,
@@ -25,7 +25,7 @@ internal abstract class GenericExpressionNode
         /// to empty than to fully evaluate it.)
         /// Implementations should cache the result so that calls after the first are free.
         /// </summary>
-        internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state)
         {
             return false;
         }
@@ -34,7 +34,7 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal abstract string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null);
+        internal abstract string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state);
 
         /// <summary>
         /// Value before any item and property expressions are expanded
@@ -42,6 +42,12 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// <returns></returns>
         internal abstract string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluationState state);
 
+        /// <summary>
+        /// Checks if value is empty before any item and property expressions are expanded
+        /// </summary>
+        /// <returns></returns>
+        internal abstract bool IsUnexpandedValueEmpty();
+
         /// <summary>
         /// If any expression nodes cache any state for the duration of evaluation,
         /// now's the time to clean it up
@@ -52,17 +58,16 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// The main evaluate entry point for expression trees
         /// </summary>
         /// <param name="state"></param>
-        /// <param name="loggingContext"></param>
         /// <returns></returns>
-        internal bool Evaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal bool Evaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (!TryBoolEvaluate(state, out bool boolValue, loggingContext))
+            if (!TryBoolEvaluate(state, out bool boolValue))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
                     "ConditionNotBooleanDetail",
                     state.Condition,
-                    GetExpandedValue(state, loggingContext));
+                    GetExpandedValue(state));
             }
 
             return boolValue;
diff --git a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
index 208794b3603..f398e8d740a 100644
--- a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
@@ -37,7 +37,7 @@ internal abstract class MultipleComparisonNode : OperatorExpressionNode
         /// Order in which comparisons are attempted is numeric, boolean, then string.
         /// Updates conditioned properties table.
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
             ProjectErrorUtilities.VerifyThrowInvalidProject(
                 LeftChild != null && RightChild != null,
@@ -51,8 +51,18 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             // and we know which do, then we already have enough information to evaluate this expression.
             // That means we don't have to fully expand a condition like " '@(X)' == '' "
             // which is a performance advantage if @(X) is a huge item list.
-            bool leftEmpty = LeftChild.EvaluatesToEmpty(state, loggingContext);
-            bool rightEmpty = RightChild.EvaluatesToEmpty(state, loggingContext);
+
+            // This is the possible case of an expression similar to '$(a)' == '', where a usage of uninitialized
+            //  property is reasonable and should not be flagged by uninitialized reads detection.
+            // So if at least one side is empty, we know to signal to PropertiesUseTracker to not flag in this scope.
+            // The other side might not be property at all - that's fine, as then PropertiesUseTracker won't be even called.
+            if (LeftChild.IsUnexpandedValueEmpty() || RightChild.IsUnexpandedValueEmpty())
+            {
+                state.PropertiesUseTracker.PropertyReadContext = PropertyReadContext.ConditionEvaluationWithOneSideEmpty;
+            }
+
+            bool leftEmpty = LeftChild.EvaluatesToEmpty(state);
+            bool rightEmpty = RightChild.EvaluatesToEmpty(state);
             if (leftEmpty || rightEmpty)
             {
                 UpdateConditionedProperties(state);
@@ -69,13 +79,13 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                 // is 17.0).
                 return Compare(leftNumericValue, rightNumericValue);
             }
-            else if (LeftChild.TryBoolEvaluate(state, out bool leftBoolValue, loggingContext) && RightChild.TryBoolEvaluate(state, out bool rightBoolValue, loggingContext))
+            else if (LeftChild.TryBoolEvaluate(state, out bool leftBoolValue) && RightChild.TryBoolEvaluate(state, out bool rightBoolValue))
             {
                 return Compare(leftBoolValue, rightBoolValue);
             }
 
-            string leftExpandedValue = LeftChild.GetExpandedValue(state, loggingContext);
-            string rightExpandedValue = RightChild.GetExpandedValue(state, loggingContext);
+            string leftExpandedValue = LeftChild.GetExpandedValue(state);
+            string rightExpandedValue = RightChild.GetExpandedValue(state);
 
             ProjectErrorUtilities.VerifyThrowInvalidProject(
                 leftExpandedValue != null && rightExpandedValue != null,
@@ -85,6 +95,9 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
 
             UpdateConditionedProperties(state);
 
+            // reset back the property read context (it's no longer a condition with one side empty)
+            state.PropertiesUseTracker.PropertyReadContext = PropertyReadContext.ConditionEvaluation;
+
             return Compare(leftExpandedValue, rightExpandedValue);
         }
 
diff --git a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
index 71dec16ec3d..66bfc64c1c2 100644
--- a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
@@ -19,9 +19,9 @@ internal sealed class NotExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool boolValue, loggingContext))
+            if (!LeftChild.TryBoolEvaluate(state, out bool boolValue))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
@@ -42,12 +42,15 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
             return "!" + LeftChild.GetUnexpandedValue(state);
         }
 
+        /// <inheritdoc cref="GenericExpressionNode"/>
+        internal override bool IsUnexpandedValueEmpty() => false;
+
         /// <summary>
         /// Returns expanded value with '!' prepended. Useful for error messages.
         /// </summary>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
         {
-            return "!" + LeftChild.GetExpandedValue(state, loggingContext);
+            return "!" + LeftChild.GetExpandedValue(state);
         }
 
         internal override string DebuggerDisplay => $"(not {LeftChild.DebuggerDisplay})";
diff --git a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
index a371e9a0850..fb6cc3b3a71 100644
--- a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
@@ -38,7 +38,7 @@ internal abstract class NumericComparisonExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
             bool isLeftNum = LeftChild.TryNumericEvaluate(state, out double leftNum);
             bool isLeftVersion = LeftChild.TryVersionEvaluate(state, out Version leftVersion);
@@ -53,7 +53,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                     state.Condition,
                     /* helpfully display unexpanded token and expanded result in error message */
                     isLeftNum ? RightChild.GetUnexpandedValue(state) : LeftChild.GetUnexpandedValue(state),
-                    isLeftNum ? RightChild.GetExpandedValue(state, loggingContext) : LeftChild.GetExpandedValue(state, loggingContext));
+                    isLeftNum ? RightChild.GetExpandedValue(state) : LeftChild.GetExpandedValue(state));
             }
 
             return (isLeftNum, isLeftVersion, isRightNum, isRightVersion) switch
diff --git a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
index acfdd72bce9..6089e5dd255 100644
--- a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
@@ -3,11 +3,8 @@
 
 using System;
 using System.Diagnostics;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
@@ -16,29 +13,34 @@ namespace Microsoft.Build.Evaluation
     [DebuggerDisplay("{DebuggerDisplay,nq}")]
     internal sealed class NumericExpressionNode : OperandExpressionNode
     {
-        private string _value;
+        private readonly string _value;
 
         internal NumericExpressionNode(string value)
         {
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(value), "NumericExpressionNode cannot have empty value");
             _value = value;
         }
 
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
             result = default;
             return false;
         }
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
             return ConversionUtilities.TryConvertDecimalOrHexToDouble(_value, out result);
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version? result)
         {
             return Version.TryParse(_value, out result);
         }
 
+        /// <inheritdoc cref="GenericExpressionNode"/>
+        internal override bool IsUnexpandedValueEmpty()
+            => false;
+
         /// <summary>
         /// Get the unexpanded value
         /// </summary>
@@ -50,7 +52,7 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// <summary>
         /// Get the expanded value
         /// </summary>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
         {
             return _value;
         }
diff --git a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
index 2c172a9af0a..55cf768c60b 100644
--- a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
@@ -3,6 +3,7 @@
 
 using System;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Collections;
 
 #nullable disable
 
@@ -13,21 +14,21 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class OperatorExpressionNode : GenericExpressionNode
     {
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
-            result = BoolEvaluate(state, loggingContext);
+            result = BoolEvaluate(state);
             return true;
         }
 
-        internal abstract bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null);
+        internal abstract bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state);
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
             result = default;
             return false;
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
         {
             result = default;
             return false;
@@ -37,11 +38,15 @@ internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluatio
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
         {
             return null;
         }
 
+        /// <inheritdoc cref="GenericExpressionNode"/>
+        internal override bool IsUnexpandedValueEmpty()
+            => (LeftChild?.IsUnexpandedValueEmpty() ?? true) && (RightChild?.IsUnexpandedValueEmpty() ?? true);
+
         /// <summary>
         /// Value before any item and property expressions are expanded
         /// </summary>
diff --git a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
index 9d4add7436e..dae691252e2 100644
--- a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
@@ -19,15 +19,15 @@ internal sealed class OrExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool, loggingContext))
+            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
                     "ExpressionDoesNotEvaluateToBoolean",
                     LeftChild.GetUnexpandedValue(state),
-                    LeftChild.GetExpandedValue(state, loggingContext),
+                    LeftChild.GetExpandedValue(state),
                     state.Condition);
             }
 
@@ -38,7 +38,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             }
             else
             {
-                if (!RightChild.TryBoolEvaluate(state, out bool rightBool, loggingContext))
+                if (!RightChild.TryBoolEvaluate(state, out bool rightBool))
                 {
                     ProjectErrorUtilities.ThrowInvalidProject(
                         state.ElementLocation,
diff --git a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
index 2c3dcc080df..f66e2d5efee 100644
--- a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
@@ -31,34 +31,34 @@ internal StringExpressionNode(string value, bool expandable)
             _expandable = expandable;
         }
 
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
-            return ConversionUtilities.TryConvertStringToBool(GetExpandedValue(state, loggingContext), out result);
+            return ConversionUtilities.TryConvertStringToBool(GetExpandedValue(state), out result);
         }
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
-            if (ShouldBeTreatedAsVisualStudioVersion(state, loggingContext))
+            if (ShouldBeTreatedAsVisualStudioVersion(state))
             {
                 result = ConversionUtilities.ConvertDecimalOrHexToDouble(MSBuildConstants.CurrentVisualStudioVersion);
                 return true;
             }
             else
             {
-                return ConversionUtilities.TryConvertDecimalOrHexToDouble(GetExpandedValue(state, loggingContext), out result);
+                return ConversionUtilities.TryConvertDecimalOrHexToDouble(GetExpandedValue(state), out result);
             }
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
         {
-            if (ShouldBeTreatedAsVisualStudioVersion(state, loggingContext))
+            if (ShouldBeTreatedAsVisualStudioVersion(state))
             {
                 result = Version.Parse(MSBuildConstants.CurrentVisualStudioVersion);
                 return true;
             }
             else
             {
-                return Version.TryParse(GetExpandedValue(state, loggingContext), out result);
+                return Version.TryParse(GetExpandedValue(state), out result);
             }
         }
 
@@ -69,7 +69,7 @@ internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluatio
         /// to empty than to fully evaluate it.
         /// Implementations should cache the result so that calls after the first are free.
         /// </summary>
-        internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state)
         {
             if (_cachedExpandedValue == null)
             {
@@ -94,7 +94,7 @@ internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationS
                             break;
                     }
 
-                    string expandBreakEarly = state.ExpandIntoStringBreakEarly(_value, loggingContext);
+                    string expandBreakEarly = state.ExpandIntoStringBreakEarly(_value);
 
                     if (expandBreakEarly == null)
                     {
@@ -117,6 +117,10 @@ internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationS
         }
 
 
+        /// <inheritdoc cref="GenericExpressionNode"/>
+        internal override bool IsUnexpandedValueEmpty() 
+            => string.IsNullOrEmpty(_value);
+
         /// <summary>
         /// Value before any item and property expressions are expanded
         /// </summary>
@@ -130,13 +134,13 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
         {
             if (_cachedExpandedValue == null)
             {
                 if (_expandable)
                 {
-                    _cachedExpandedValue = state.ExpandIntoString(_value, loggingContext);
+                    _cachedExpandedValue = state.ExpandIntoString(_value);
                 }
                 else
                 {
@@ -169,7 +173,7 @@ internal override void ResetState()
         /// but now cause the project to throw InvalidProjectException when
         /// ToolsVersion is "Current". https://github.com/dotnet/msbuild/issues/4150
         /// </remarks>
-        private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionEvaluationState state)
         {
             if (!_shouldBeTreatedAsVisualStudioVersion.HasValue)
             {
@@ -177,7 +181,7 @@ private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionE
 
                 // Do this check first, because if it's not (common) we can early-out and the next
                 // expansion will be cheap because this will populate the cached expanded value.
-                if (string.Equals(GetExpandedValue(state, loggingContext), MSBuildConstants.CurrentToolsVersion, StringComparison.Ordinal))
+                if (string.Equals(GetExpandedValue(state), MSBuildConstants.CurrentToolsVersion, StringComparison.Ordinal))
                 {
                     // and it is just an expansion of MSBuildToolsVersion
                     _shouldBeTreatedAsVisualStudioVersion = string.Equals(_value, "$(MSBuildToolsVersion)", StringComparison.OrdinalIgnoreCase);
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 85447378533..b82733a9d8e 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -12,6 +12,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Components.Logging;
 using Microsoft.Build.BackEnd.Components.RequestBuilder;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -223,12 +224,8 @@ private Evaluator(
                 buildEventContext,
                 string.IsNullOrEmpty(projectRootElement.ProjectFileLocation.File) ? "(null)" : projectRootElement.ProjectFileLocation.File);
 
-            // If someone sets the 'MsBuildLogPropertyTracking' environment variable to a non-zero value, wrap property accesses for event reporting.
-            if (Traits.Instance.LogPropertyTracking > 0)
-            {
-                // Wrap the IEvaluatorData<> object passed in.
-                data = new PropertyTrackingEvaluatorDataWrapper<P, I, M, D>(data, _evaluationLoggingContext, Traits.Instance.LogPropertyTracking);
-            }
+            // Wrap the IEvaluatorData<> object passed in.
+            data = new PropertyTrackingEvaluatorDataWrapper<P, I, M, D>(data, _evaluationLoggingContext, Traits.Instance.LogPropertyTracking);
 
             // If the host wishes to provide a directory cache for this evaluation, create a new EvaluationContext with the right file system.
             _evaluationContext = evaluationContext;
@@ -240,12 +237,10 @@ private Evaluator(
             }
 
             // Create containers for the evaluation results
-            data.InitializeForEvaluation(toolsetProvider, _evaluationContext);
+            data.InitializeForEvaluation(toolsetProvider, _evaluationContext, _evaluationLoggingContext);
 
             _expander = new Expander<P, I>(data, data, _evaluationContext, _evaluationLoggingContext);
 
-            // This setting may change after the build has started, therefore if the user has not set the property to true on the build parameters we need to check to see if it is set to true on the environment variable.
-            _expander.WarnForUninitializedProperties = BuildParameters.WarnOnUninitializedProperty || Traits.Instance.EscapeHatches.WarnOnUninitializedProperty;
             _data = data;
             _itemGroupElements = new List<ProjectItemGroupElement>();
             _itemDefinitionGroupElements = new List<ProjectItemDefinitionGroupElement>();
@@ -713,8 +708,7 @@ private void Evaluate()
                 {
                     // Evaluate the usingtask and add the result into the data passed in
                     TaskRegistry.InitializeTaskRegistryFromUsingTaskElements<P, I>(
-                        _evaluationLoggingContext.LoggingService,
-                        _evaluationLoggingContext.BuildEventContext,
+                        _evaluationLoggingContext,
                         _usingTaskElements.Select(p => (p.Value, p.Key)),
                         _data.TaskRegistry,
                         _expander,
@@ -860,12 +854,12 @@ private void PerformDepthFirstPass(ProjectRootElement currentProjectOrImport)
             using (_evaluationProfiler.TrackFile(currentProjectOrImport.FullPath))
             {
                 // We accumulate InitialTargets from the project and each import
-                var initialTargets = _expander.ExpandIntoStringListLeaveEscaped(currentProjectOrImport.InitialTargets, ExpanderOptions.ExpandProperties, currentProjectOrImport.InitialTargetsLocation, _evaluationLoggingContext);
+                var initialTargets = _expander.ExpandIntoStringListLeaveEscaped(currentProjectOrImport.InitialTargets, ExpanderOptions.ExpandProperties, currentProjectOrImport.InitialTargetsLocation);
                 _initialTargetsList.AddRange(initialTargets);
 
                 if (!Traits.Instance.EscapeHatches.IgnoreTreatAsLocalProperty)
                 {
-                    foreach (string propertyName in _expander.ExpandIntoStringListLeaveEscaped(currentProjectOrImport.TreatAsLocalProperty, ExpanderOptions.ExpandProperties, currentProjectOrImport.TreatAsLocalPropertyLocation, _evaluationLoggingContext))
+                    foreach (string propertyName in _expander.ExpandIntoStringListLeaveEscaped(currentProjectOrImport.TreatAsLocalProperty, ExpanderOptions.ExpandProperties, currentProjectOrImport.TreatAsLocalPropertyLocation))
                     {
                         XmlUtilities.VerifyThrowProjectValidElementName(propertyName, currentProjectOrImport.Location);
                         _data.GlobalPropertiesToTreatAsLocal.Add(propertyName);
@@ -1051,8 +1045,8 @@ private void ReadTargetElement(ProjectTargetElement targetElement, LinkedList<Pr
         /// </summary>
         private void AddBeforeAndAfterTargetMappings(ProjectTargetElement targetElement, Dictionary<string, LinkedListNode<ProjectTargetElement>> activeTargets, Dictionary<string, List<TargetSpecification>> targetsWhichRunBeforeByTarget, Dictionary<string, List<TargetSpecification>> targetsWhichRunAfterByTarget)
         {
-            var beforeTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.BeforeTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.BeforeTargetsLocation, _evaluationLoggingContext);
-            var afterTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.AfterTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.AfterTargetsLocation, _evaluationLoggingContext);
+            var beforeTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.BeforeTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.BeforeTargetsLocation);
+            var afterTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.AfterTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.AfterTargetsLocation);
 
             foreach (string beforeTarget in beforeTargets)
             {
@@ -1285,90 +1279,23 @@ private void EvaluatePropertyElement(ProjectPropertyElement propertyElement)
                     return;
                 }
 
+                _expander.PropertiesUseTracker.PropertyReadContext = PropertyReadContext.ConditionEvaluation;
                 if (!EvaluateConditionCollectingConditionedProperties(propertyElement, ExpanderOptions.ExpandProperties, ParserOptions.AllowProperties))
                 {
                     return;
                 }
 
+                _expander.PropertiesUseTracker.PropertyReadContext = PropertyReadContext.PropertyEvaluation;
+
                 // Set the name of the property we are currently evaluating so when we are checking to see if we want to add the property to the list of usedUninitialized properties we can not add the property if
                 // it is the same as what we are setting the value on. Note: This needs to be set before we expand the property we are currently setting.
-                _expander.UsedUninitializedProperties.CurrentlyEvaluatingPropertyElementName = propertyElement.Name;
-
-                string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(propertyElement.Value, ExpanderOptions.ExpandProperties, propertyElement.Location, _evaluationLoggingContext);
-
-                // If we are going to set a property to a value other than null or empty we need to check to see if it has been used
-                // during evaluation.
-                if (evaluatedValue.Length > 0 && _expander.WarnForUninitializedProperties)
-                {
-                    // Is the property we are currently setting in the list of properties which have been used but not initialized
-                    IElementLocation elementWhichUsedProperty;
-                    bool isPropertyInList = _expander.UsedUninitializedProperties.TryGetPropertyElementLocation(propertyElement.Name, out elementWhichUsedProperty);
-
-                    if (isPropertyInList)
-                    {
-                        // Once we are going to warn for a property once, remove it from the list so we do not add it again.
-                        _expander.UsedUninitializedProperties.RemoveProperty(propertyElement.Name);
-                        _evaluationLoggingContext.LogWarning(null, new BuildEventFileInfo(propertyElement.Location), "UsedUninitializedProperty", propertyElement.Name, elementWhichUsedProperty.LocationString);
-                    }
-                }
-
-                _expander.UsedUninitializedProperties.CurrentlyEvaluatingPropertyElementName = null;
-
-                if (Traits.Instance.LogPropertyTracking == 0)
-                {
-                    P predecessor = _data.GetProperty(propertyElement.Name);
-                    P property = _data.SetProperty(propertyElement, evaluatedValue);
-
-                    if (predecessor != null)
-                    {
-                        LogPropertyReassignment(predecessor, property, propertyElement.Location.LocationString);
-                    }
-                }
-                else
-                {
-                    _data.SetProperty(propertyElement, evaluatedValue);
-                }
-            }
-        }
+                _expander.PropertiesUseTracker.CurrentlyEvaluatingPropertyElementName = propertyElement.Name;
 
-        private void LogPropertyReassignment(P predecessor, P property, string location)
-        {
-            string newValue = property.EvaluatedValue;
-            string oldValue = predecessor?.EvaluatedValue;
-
-            if (string.Equals(property.Name, "MSBuildAllProjects", StringComparison.OrdinalIgnoreCase))
-            {
-                // There's a huge perf cost to logging this and it increases the binlog size significantly.
-                // Meanwhile the usefulness of logging this is very low.
-                return;
-            }
+                string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(propertyElement.Value, ExpanderOptions.ExpandProperties, propertyElement.Location);
 
-            if (newValue != oldValue)
-            {
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10))
-                {
-                    var args = new PropertyReassignmentEventArgs(
-                        property.Name,
-                        oldValue,
-                        newValue,
-                        location,
-                        message: null)
-                    {
-                        BuildEventContext = _evaluationLoggingContext.BuildEventContext,
-                    };
+                _expander.PropertiesUseTracker.CheckPreexistingUndefinedUsage(propertyElement, evaluatedValue, _evaluationLoggingContext);
 
-                    _evaluationLoggingContext.LogBuildEvent(args);
-                }
-                else
-                {
-                    _evaluationLoggingContext.LogComment(
-                        MessageImportance.Low,
-                        "PropertyReassignment",
-                        property.Name,
-                        newValue,
-                        oldValue,
-                        location);
-                }
+                _data.SetProperty(propertyElement, evaluatedValue);
             }
         }
 
@@ -2035,7 +1962,7 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
         {
             imports = null;
 
-            string importExpressionEscaped = _expander.ExpandIntoStringLeaveEscaped(unescapedExpression, ExpanderOptions.ExpandProperties, importElement.ProjectLocation, _evaluationLoggingContext);
+            string importExpressionEscaped = _expander.ExpandIntoStringLeaveEscaped(unescapedExpression, ExpanderOptions.ExpandProperties, importElement.ProjectLocation);
             ElementLocation importLocationInProject = importElement.Location;
 
             if (String.IsNullOrWhiteSpace(importExpressionEscaped))
@@ -2459,8 +2386,6 @@ private bool EvaluateCondition(ProjectElement element, string condition, Expande
                     expanderOptions,
                     GetCurrentDirectoryForConditionEvaluation(element),
                     element.ConditionLocation,
-                    _evaluationLoggingContext.LoggingService,
-                    _evaluationLoggingContext.BuildEventContext,
                     _evaluationContext.FileSystem,
                     loggingContext: _evaluationLoggingContext);
 
@@ -2498,9 +2423,8 @@ private bool EvaluateConditionCollectingConditionedProperties(ProjectElement ele
                     _data.ConditionedProperties,
                     GetCurrentDirectoryForConditionEvaluation(element),
                     element.ConditionLocation,
-                    _evaluationLoggingContext.LoggingService,
-                    _evaluationLoggingContext.BuildEventContext,
                     _evaluationContext.FileSystem,
+                    _evaluationLoggingContext,
                     projectRootElementCache);
 
                 return result;
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index e67785390a4..c64d877596a 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -307,7 +307,7 @@ private void FlushFirstValueIfNeeded()
         /// <summary>
         /// Set of properties which are null during expansion.
         /// </summary>
-        private UsedUninitializedProperties _usedUninitializedProperties;
+        private PropertiesUseTracker _propertiesUseTracker;
 
         private readonly IFileSystem _fileSystem;
 
@@ -318,25 +318,42 @@ private void FlushFirstValueIfNeeded()
         /// </summary>
         internal EvaluationContext EvaluationContext { get; }
 
+        private Expander(IPropertyProvider<P> properties, LoggingContext loggingContext)
+        {
+            _properties = properties;
+            _propertiesUseTracker = new PropertiesUseTracker(loggingContext);
+            _loggingContext = loggingContext;
+        }
+
         /// <summary>
         /// Creates an expander passing it some properties to use.
         /// Properties may be null.
         /// </summary>
-        internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem)
+        internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem, LoggingContext loggingContext)
+            : this(properties, loggingContext)
         {
-            _properties = properties;
-            _usedUninitializedProperties = new UsedUninitializedProperties();
             _fileSystem = fileSystem;
         }
 
+        /// <summary>
+        /// Creates an expander passing it some properties to use.
+        /// Properties may be null.
+        ///
+        /// Used for tests and for ToolsetReader - that operates agnostic on the project
+        ///   - so no logging context is passed, and no BuildCheck analysis will be executed.
+        /// </summary>
+        internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem)
+        : this(properties, fileSystem, null)
+        { }
+
         /// <summary>
         /// Creates an expander passing it some properties to use and the evaluation context.
         /// Properties may be null.
         /// </summary>
-        internal Expander(IPropertyProvider<P> properties, EvaluationContext evaluationContext)
+        internal Expander(IPropertyProvider<P> properties, EvaluationContext evaluationContext,
+            LoggingContext loggingContext)
+            : this(properties, loggingContext)
         {
-            _properties = properties;
-            _usedUninitializedProperties = new UsedUninitializedProperties();
             _fileSystem = evaluationContext.FileSystem;
             EvaluationContext = evaluationContext;
         }
@@ -345,8 +362,8 @@ internal Expander(IPropertyProvider<P> properties, EvaluationContext evaluationC
         /// Creates an expander passing it some properties and items to use.
         /// Either or both may be null.
         /// </summary>
-        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IFileSystem fileSystem)
-            : this(properties, fileSystem)
+        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IFileSystem fileSystem, LoggingContext loggingContext)
+            : this(properties, fileSystem, loggingContext)
         {
             _items = items;
         }
@@ -356,45 +373,57 @@ internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IFile
         /// Creates an expander passing it some properties and items to use, and the evaluation context.
         /// Either or both may be null.
         /// </summary>
-        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, EvaluationContext evaluationContext)
-            : this(properties, evaluationContext)
+        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, EvaluationContext evaluationContext, LoggingContext loggingContext)
+            : this(properties, evaluationContext, loggingContext)
         {
             _items = items;
         }
 
         /// <summary>
-        /// Initializes a new instance of the <see cref="Expander{P, I}"/> class with the specified property provider, item provider, evaluation context, and logging context.
+        /// Creates an expander passing it some properties, items, and/or metadata to use.
+        /// Any or all may be null.
         /// </summary>
-        /// <param name="properties">The property provider supplying properties for expansion.</param>
-        /// <param name="items">The item provider supplying items for expansion.</param>
-        /// <param name="evaluationContext">The evaluation context used during expansion.</param>
-        /// <param name="loggingContext">The logging context used for logging or emmitting events during expansion.</param>
-        /// <exception cref="ArgumentNullException">Thrown when either <paramref name="properties"/> or <paramref name="evaluationContext"/> is null.</exception>
-        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, EvaluationContext evaluationContext, LoggingContext loggingContext)
-            : this(properties, evaluationContext)
+        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IMetadataTable metadata, IFileSystem fileSystem, LoggingContext loggingContext)
+            : this(properties, items, fileSystem, loggingContext)
         {
-            _items = items;
-            _loggingContext = loggingContext;
+            _metadata = metadata;
         }
 
         /// <summary>
         /// Creates an expander passing it some properties, items, and/or metadata to use.
         /// Any or all may be null.
+        ///
+        /// This is for the purpose of evaluations through API calls, that might not be able to pass the logging context
+        ///  - BuildCheck analysis won't be executed for those.
+        /// (for one of the calls we can actually pass IDataConsumingContext - as we have logging service and project)
+        /// 
         /// </summary>
         internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IMetadataTable metadata, IFileSystem fileSystem)
-            : this(properties, items, fileSystem)
+            : this(properties, items, fileSystem, null)
         {
             _metadata = metadata;
         }
 
+        private Expander(
+            IPropertyProvider<P> properties,
+            IItemProvider<I> items,
+            IMetadataTable metadata,
+            IFileSystem fileSystem,
+            EvaluationContext evaluationContext,
+            LoggingContext loggingContext)
+            : this(properties, items, metadata, fileSystem, loggingContext)
+        {
+            EvaluationContext = evaluationContext;
+        }
+
         /// <summary>
-        /// Whether to warn when we set a property for the first time, after it was previously used.
-        /// Default is false, unless MSBUILDWARNONUNINITIALIZEDPROPERTY is set.
+        /// Recreates the expander with passed in logging context
         /// </summary>
-        internal bool WarnForUninitializedProperties
+        /// <param name="loggingContext"></param>
+        /// <returns></returns>
+        internal Expander<P, I> WithLoggingContext(LoggingContext loggingContext)
         {
-            get { return _usedUninitializedProperties.Warn; }
-            set { _usedUninitializedProperties.Warn = value; }
+            return new Expander<P, I>(_properties, _items, _metadata, _fileSystem, EvaluationContext, loggingContext);
         }
 
         /// <summary>
@@ -411,10 +440,10 @@ internal IMetadataTable Metadata
         /// If a property is expanded but evaluates to null then it is considered to be un-initialized.
         /// We want to keep track of these properties so that we can warn if the property gets set later on.
         /// </summary>
-        internal UsedUninitializedProperties UsedUninitializedProperties
+        internal PropertiesUseTracker PropertiesUseTracker
         {
-            get { return _usedUninitializedProperties; }
-            set { _usedUninitializedProperties = value; }
+            get { return _propertiesUseTracker; }
+            set { _propertiesUseTracker = value; }
         }
 
         /// <summary>
@@ -443,9 +472,9 @@ internal static bool ExpressionContainsItemVector(string expression)
         ///
         /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
         /// </summary>
-        internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
+        internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions options, IElementLocation elementLocation)
         {
-            string result = ExpandIntoStringLeaveEscaped(expression, options, elementLocation, loggingContext);
+            string result = ExpandIntoStringLeaveEscaped(expression, options, elementLocation);
 
             return (result == null) ? null : EscapingUtilities.UnescapeAll(result);
         }
@@ -457,7 +486,7 @@ internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions o
         ///
         /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
         /// </summary>
-        internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
+        internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation)
         {
             if (expression.Length == 0)
             {
@@ -466,8 +495,8 @@ internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions
 
             ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
-            string result = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation, loggingContext);
-            result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem, loggingContext);
+            string result = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation, _loggingContext);
+            result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _propertiesUseTracker, _fileSystem);
             result = ItemExpander.ExpandItemVectorsIntoString<I>(this, result, _items, options, elementLocation);
             result = FileUtilities.MaybeAdjustFilePath(result);
 
@@ -488,7 +517,7 @@ internal object ExpandPropertiesLeaveTypedAndEscaped(string expression, Expander
             ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             string metaExpanded = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation);
-            return PropertyExpander<P>.ExpandPropertiesLeaveTypedAndEscaped(metaExpanded, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem);
+            return PropertyExpander<P>.ExpandPropertiesLeaveTypedAndEscaped(metaExpanded, _properties, options, elementLocation, _propertiesUseTracker, _fileSystem);
         }
 
         /// <summary>
@@ -497,11 +526,11 @@ internal object ExpandPropertiesLeaveTypedAndEscaped(string expression, Expander
         /// Use this form when the result is going to be processed further, for example by matching against the file system,
         /// so literals must be distinguished, and you promise to unescape after that.
         /// </summary>
-        internal SemiColonTokenizer ExpandIntoStringListLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
+        internal SemiColonTokenizer ExpandIntoStringListLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation)
         {
             ErrorUtilities.VerifyThrow((options & ExpanderOptions.BreakOnNotEmpty) == 0, "not supported");
 
-            return ExpressionShredder.SplitSemiColonSeparatedList(ExpandIntoStringLeaveEscaped(expression, options, elementLocation, loggingContext));
+            return ExpressionShredder.SplitSemiColonSeparatedList(ExpandIntoStringLeaveEscaped(expression, options, elementLocation));
         }
 
         /// <summary>
@@ -536,7 +565,7 @@ internal IList<T> ExpandIntoItemsLeaveEscaped<T>(string expression, IItemFactory
             ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             expression = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation);
-            expression = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(expression, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem);
+            expression = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(expression, _properties, options, elementLocation, _propertiesUseTracker, _fileSystem);
             expression = FileUtilities.MaybeAdjustFilePath(expression);
 
             List<T> result = new List<T>();
@@ -1121,9 +1150,8 @@ internal static string ExpandPropertiesLeaveEscaped(
                 IPropertyProvider<T> properties,
                 ExpanderOptions options,
                 IElementLocation elementLocation,
-                UsedUninitializedProperties usedUninitializedProperties,
-                IFileSystem fileSystem,
-                LoggingContext loggingContext = null)
+                PropertiesUseTracker propertiesUseTracker,
+                IFileSystem fileSystem)
             {
                 return
                     ConvertToString(
@@ -1132,9 +1160,8 @@ internal static string ExpandPropertiesLeaveEscaped(
                             properties,
                             options,
                             elementLocation,
-                            usedUninitializedProperties,
-                            fileSystem,
-                            loggingContext));
+                            propertiesUseTracker,
+                            fileSystem));
             }
 
             /// <summary>
@@ -1159,9 +1186,8 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                 IPropertyProvider<T> properties,
                 ExpanderOptions options,
                 IElementLocation elementLocation,
-                UsedUninitializedProperties usedUninitializedProperties,
-                IFileSystem fileSystem,
-                LoggingContext loggingContext = null)
+                PropertiesUseTracker propertiesUseTracker,
+                IFileSystem fileSystem)
             {
                 if (((options & ExpanderOptions.ExpandProperties) == 0) || String.IsNullOrEmpty(expression))
                 {
@@ -1270,13 +1296,12 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                                 properties,
                                 options,
                                 elementLocation,
-                                usedUninitializedProperties,
-                                fileSystem,
-                                loggingContext);
+                                propertiesUseTracker,
+                                fileSystem);
                         }
                         else // This is a regular property
                         {
-                            propertyValue = LookupProperty(properties, expression, propertyStartIndex + 2, propertyEndIndex - 1, elementLocation, usedUninitializedProperties, loggingContext);
+                            propertyValue = LookupProperty(properties, expression, propertyStartIndex + 2, propertyEndIndex - 1, elementLocation, propertiesUseTracker);
                         }
 
                         if (propertyValue != null)
@@ -1319,9 +1344,8 @@ internal static object ExpandPropertyBody(
                 IPropertyProvider<T> properties,
                 ExpanderOptions options,
                 IElementLocation elementLocation,
-                UsedUninitializedProperties usedUninitializedProperties,
-                IFileSystem fileSystem,
-                LoggingContext loggingContext)
+                PropertiesUseTracker propertiesUseTracker,
+                IFileSystem fileSystem)
             {
                 Function<T> function = null;
                 string propertyName = propertyBody;
@@ -1351,9 +1375,9 @@ internal static object ExpandPropertyBody(
                             propertyBody,
                             elementLocation,
                             propertyValue,
-                            usedUninitializedProperties,
+                            propertiesUseTracker,
                             fileSystem,
-                            loggingContext);
+                            propertiesUseTracker.LoggingContext);
 
                         // We may not have been able to parse out a function
                         if (function != null)
@@ -1381,7 +1405,7 @@ internal static object ExpandPropertyBody(
                         }
                         else
                         {
-                            propertyValue = LookupProperty(properties, propertyBody, 0, indexerStart - 1, elementLocation, usedUninitializedProperties);
+                            propertyValue = LookupProperty(properties, propertyBody, 0, indexerStart - 1, elementLocation, propertiesUseTracker);
                             propertyBody = propertyBody.Substring(indexerStart);
 
                             // recurse so that the function representing the indexer can be executed on the property value
@@ -1391,9 +1415,8 @@ internal static object ExpandPropertyBody(
                                 properties,
                                 options,
                                 elementLocation,
-                                usedUninitializedProperties,
-                                fileSystem,
-                                loggingContext);
+                                propertiesUseTracker,
+                                fileSystem);
                         }
                     }
                     else
@@ -1410,7 +1433,7 @@ internal static object ExpandPropertyBody(
                 // doesn't exist in the collection, and we're not executing a static function
                 if (!String.IsNullOrEmpty(propertyName))
                 {
-                    propertyValue = LookupProperty(properties, propertyName, elementLocation, usedUninitializedProperties);
+                    propertyValue = LookupProperty(properties, propertyName, elementLocation, propertiesUseTracker);
                 }
 
                 if (function != null)
@@ -1517,21 +1540,26 @@ internal static string ConvertToString(object valueToConvert)
             /// <summary>
             /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo).
             /// </summary>
-            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)
+            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, IElementLocation elementLocation, PropertiesUseTracker propertiesUseTracker)
             {
-                return LookupProperty(properties, propertyName, 0, propertyName.Length - 1, elementLocation, usedUninitializedProperties);
+                return LookupProperty(properties, propertyName, 0, propertyName.Length - 1, elementLocation, propertiesUseTracker);
             }
 
             /// <summary>
             /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo).
             /// </summary>
-            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties, LoggingContext loggingContext = null)
+            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, PropertiesUseTracker propertiesUseTracker)
             {
                 T property = properties.GetProperty(propertyName, startIndex, endIndex);
 
                 object propertyValue;
 
-                if (property == null && ((endIndex - startIndex) >= 7) && MSBuildNameIgnoreCaseComparer.Default.Equals("MSBuild", propertyName, startIndex, 7))
+                bool isArtifical = property == null && ((endIndex - startIndex) >= 7) &&
+                                   MSBuildNameIgnoreCaseComparer.Default.Equals("MSBuild", propertyName, startIndex, 7);
+
+                propertiesUseTracker.TrackRead(propertyName, startIndex, endIndex, elementLocation, property == null, isArtifical);
+                
+                if (isArtifical)
                 {
                     // It could be one of the MSBuildThisFileXXXX properties,
                     // whose values vary according to the file they are in.
@@ -1546,31 +1574,13 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
                 }
                 else if (property == null)
                 {
-                    // We have evaluated a property to null. We now need to see if we need to add it to the list of properties which are used before they have been initialized
-                    //
-                    // We also do not want to add the property to the list if the environment variable is not set, also we do not want to add the property to the list if we are currently
-                    // evaluating a condition because a common pattern for msbuild projects is to see if the property evaluates to empty and then set a value as this would cause a considerable number of false positives.   <A Condition="'$(A)' == ''">default</A>
-                    //
-                    // Another pattern used is where a property concatenates with other values,  <a>$(a);something</a> however we do not want to add the a element to the list because again this would make a number of
-                    // false positives. Therefore we check to see what element we are currently evaluating and if it is the same as our property we do not add the property to the list.
-                    if (usedUninitializedProperties.Warn && usedUninitializedProperties.CurrentlyEvaluatingPropertyElementName != null)
-                    {
-                        // Check to see if the property name does not match the property we are currently evaluating, note the property we are currently evaluating in the element name, this means no $( or )
-                        if (!MSBuildNameIgnoreCaseComparer.Default.Equals(usedUninitializedProperties.CurrentlyEvaluatingPropertyElementName, propertyName, startIndex, endIndex - startIndex + 1))
-                        {
-                            usedUninitializedProperties.TryAdd(
-                                propertyName: propertyName.Substring(startIndex, endIndex - startIndex + 1),
-                                elementLocation);
-                        }
-                    }
-
                     propertyValue = String.Empty;
                 }
                 else
                 {
                     if (property is ProjectPropertyInstance.EnvironmentDerivedProjectPropertyInstance environmentDerivedProperty)
                     {
-                        environmentDerivedProperty.loggingContext = loggingContext;
+                        environmentDerivedProperty.loggingContext = propertiesUseTracker.LoggingContext;
                     }
 
                     propertyValue = property.EvaluatedValueEscaped;
@@ -2755,7 +2765,7 @@ internal static IEnumerable<KeyValuePair<string, S>> ExecuteStringFunction(
                             arguments,
                             BindingFlags.Public | BindingFlags.InvokeMethod,
                             string.Empty,
-                            expander.UsedUninitializedProperties,
+                            expander.PropertiesUseTracker,
                             expander._fileSystem,
                             expander._loggingContext);
 
@@ -3187,7 +3197,7 @@ private struct FunctionBuilder<T>
             /// <summary>
             /// List of properties which have been used but have not been initialized yet.
             /// </summary>
-            public UsedUninitializedProperties UsedUninitializedProperties { get; set; }
+            public PropertiesUseTracker PropertiesUseTracker { get; set; }
 
             internal readonly Function<T> Build()
             {
@@ -3199,7 +3209,7 @@ internal readonly Function<T> Build()
                     Arguments,
                     BindingFlags,
                     Remainder,
-                    UsedUninitializedProperties,
+                    PropertiesUseTracker,
                     FileSystem,
                     LoggingContext);
             }
@@ -3251,7 +3261,7 @@ internal class Function<T>
             /// <summary>
             /// List of properties which have been used but have not been initialized yet.
             /// </summary>
-            private readonly UsedUninitializedProperties _usedUninitializedProperties;
+            private PropertiesUseTracker _propertiesUseTracker;
 
             private readonly IFileSystem _fileSystem;
 
@@ -3268,7 +3278,7 @@ internal Function(
                 string[] arguments,
                 BindingFlags bindingFlags,
                 string remainder,
-                UsedUninitializedProperties usedUninitializedProperties,
+                PropertiesUseTracker propertiesUseTracker,
                 IFileSystem fileSystem,
                 LoggingContext loggingContext)
             {
@@ -3287,7 +3297,7 @@ internal Function(
                 _receiverType = receiverType;
                 _bindingFlags = bindingFlags;
                 _remainder = remainder;
-                _usedUninitializedProperties = usedUninitializedProperties;
+                _propertiesUseTracker = propertiesUseTracker;
                 _fileSystem = fileSystem;
                 _loggingContext = loggingContext;
             }
@@ -3311,7 +3321,7 @@ internal static Function<T> ExtractPropertyFunction(
                 string expressionFunction,
                 IElementLocation elementLocation,
                 object propertyValue,
-                UsedUninitializedProperties usedUnInitializedProperties,
+                PropertiesUseTracker propertiesUseTracker,
                 IFileSystem fileSystem,
                 LoggingContext loggingContext)
             {
@@ -3335,7 +3345,7 @@ internal static Function<T> ExtractPropertyFunction(
                 ProjectErrorUtilities.VerifyThrowInvalidProject(!expressionRoot.IsEmpty, elementLocation, "InvalidFunctionPropertyExpression", expressionFunction, String.Empty);
 
                 functionBuilder.Expression = expressionFunction;
-                functionBuilder.UsedUninitializedProperties = usedUnInitializedProperties;
+                functionBuilder.PropertiesUseTracker = propertiesUseTracker;
 
                 // This is a static method call
                 // A static method is the content that follows the last "::", the rest being the type
@@ -3487,7 +3497,7 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                             properties,
                             options,
                             elementLocation,
-                            _usedUninitializedProperties,
+                            _propertiesUseTracker,
                             _fileSystem);
 
                         if (argument is string argumentValue)
@@ -3621,9 +3631,8 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                         properties,
                         options,
                         elementLocation,
-                        _usedUninitializedProperties,
-                        _fileSystem,
-                        _loggingContext);
+                        _propertiesUseTracker,
+                        _fileSystem);
                 }
 
                 // Exceptions coming from the actual function called are wrapped in a TargetInvocationException
@@ -5490,64 +5499,6 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
     }
 
 #nullable enable
-    /// <summary>
-    /// This class wraps information about properties which have been used before they are initialized.
-    /// </summary>
-    internal sealed class UsedUninitializedProperties
-    {
-        /// <summary>
-        /// Lazily allocated collection of properties and the element which used them.
-        /// </summary>
-        private Dictionary<string, IElementLocation>? _properties;
-
-        internal void TryAdd(string propertyName, IElementLocation elementLocation)
-        {
-            if (_properties is null)
-            {
-                _properties = new(StringComparer.OrdinalIgnoreCase);
-            }
-            else if (_properties.ContainsKey(propertyName))
-            {
-                return;
-            }
-
-            _properties.Add(propertyName, elementLocation);
-        }
-
-        internal bool TryGetPropertyElementLocation(string propertyName, [NotNullWhen(returnValue: true)] out IElementLocation? elementLocation)
-        {
-            if (_properties is null)
-            {
-                elementLocation = null;
-                return false;
-            }
-
-            return _properties.TryGetValue(propertyName, out elementLocation);
-        }
-
-        internal void RemoveProperty(string propertyName)
-        {
-            _properties?.Remove(propertyName);
-        }
-
-        /// <summary>
-        ///  Are we currently supposed to warn if we used an uninitialized property.
-        /// </summary>
-        internal bool Warn
-        {
-            get;
-            set;
-        }
-
-        /// <summary>
-        ///  What is the currently evaluating property element, this is so that we do not add a un initialized property if we are evaluating that property.
-        /// </summary>
-        internal string? CurrentlyEvaluatingPropertyElementName
-        {
-            get;
-            set;
-        }
-    }
 
     internal static class IntrinsicFunctionOverload
     {
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index 4d5b2ea8e98..12d42a71ea9 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -212,7 +213,7 @@ List<ProjectItemElement> EvaluatedItemElements
         /// <summary>
         /// Prepares the data block for a new evaluation pass
         /// </summary>
-        void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext);
+        void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext, LoggingContext loggingContext);
 
         /// <summary>
         /// Indicates to the data block that evaluation has completed,
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index c45edf0764b..e9b381b5aa1 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -157,23 +157,21 @@ private bool InitReferencedItemsIfNecessary()
         /// <param name="itemSpecLocation">The xml location the itemspec comes from</param>
         /// <param name="projectDirectory">The directory that the project is in.</param>
         /// <param name="expandProperties">Expand properties before breaking down fragments. Defaults to true</param>
-        /// <param name="loggingContext">Context in which to log</param>
         public ItemSpec(
             string itemSpec,
             Expander<P, I> expander,
             IElementLocation itemSpecLocation,
             string projectDirectory,
-            bool expandProperties = true,
-            LoggingContext loggingContext = null)
+            bool expandProperties = true)
         {
             ItemSpecString = itemSpec;
             Expander = expander;
             ItemSpecLocation = itemSpecLocation;
 
-            Fragments = BuildItemFragments(itemSpecLocation, projectDirectory, expandProperties, loggingContext);
+            Fragments = BuildItemFragments(itemSpecLocation, projectDirectory, expandProperties);
         }
 
-        private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties, LoggingContext loggingContext)
+        private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties)
         {
             // Code corresponds to Evaluator.CreateItemsFromInclude
             var evaluatedItemspecEscaped = ItemSpecString;
@@ -189,8 +187,7 @@ private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocat
                 evaluatedItemspecEscaped = Expander.ExpandIntoStringLeaveEscaped(
                     ItemSpecString,
                     ExpanderOptions.ExpandProperties,
-                    itemSpecLocation,
-                    loggingContext);
+                    itemSpecLocation);
             }
 
             var semicolonCount = 0;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index 79cd844c167..248945f74fd 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -291,9 +291,9 @@ public ProjectTargetInstance GetTarget(string targetName)
                 return _wrappedData.GetTarget(targetName);
             }
 
-            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext)
+            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext, LoggingContext loggingContext)
             {
-                _wrappedData.InitializeForEvaluation(toolsetProvider, evaluationContext);
+                _wrappedData.InitializeForEvaluation(toolsetProvider, evaluationContext, loggingContext);
             }
 
             public void RecordImport(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated, SdkResult sdkResult)
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index d40ea3145fa..bc35e8ce8b8 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -109,14 +109,14 @@ protected override ImmutableArray<I> SelectItems(OrderedItemDataCollection.Build
                                 MSBuildEventSource.Log.ExpandGlobStart(_rootDirectory ?? string.Empty, glob, string.Join(", ", excludePatternsForGlobs));
                             }
 
-                            using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))
+                            using (_lazyEvaluator?._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))
                             {
                                 includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(
                                     _rootDirectory,
                                     glob,
                                     excludePatternsForGlobs,
                                     fileMatcher: FileMatcher,
-                                    loggingMechanism: _lazyEvaluator._loggingContext,
+                                    loggingMechanism: _lazyEvaluator?._loggingContext,
                                     includeLocation: _itemElement.IncludeLocation,
                                     excludeLocation: _itemElement.ExcludeLocation);
                             }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index 6bf5b325d63..56d1c41e44e 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -248,7 +248,7 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                                 continue;
                             }
 
-                            string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(metadataElement.Value, metadataExpansionOptions, metadataElement.Location, _lazyEvaluator._loggingContext);
+                            string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(metadataElement.Value, metadataExpansionOptions, metadataElement.Location);
                             evaluatedValue = FileUtilities.MaybeAdjustFilePath(evaluatedValue, metadataElement.ContainingProject.DirectoryPath);
 
                             metadataTable.SetValue(metadataElement, evaluatedValue);
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index bb298ee7662..4b658abbecf 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -54,7 +54,7 @@ public LazyItemEvaluator(IEvaluatorData<P, I, M, D> data, IItemFactory<I, I> ite
             _outerEvaluatorData = data;
             _outerExpander = new Expander<P, I>(_outerEvaluatorData, _outerEvaluatorData, evaluationContext, loggingContext);
             _evaluatorData = new EvaluatorData(_outerEvaluatorData, _itemLists);
-            _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, evaluationContext);
+            _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, evaluationContext, loggingContext);
             _itemFactory = itemFactory;
             _loggingContext = loggingContext;
             _evaluationProfiler = evaluationProfiler;
@@ -90,8 +90,6 @@ private static bool EvaluateCondition(
                     expanderOptions,
                     GetCurrentDirectoryForConditionEvaluation(element, lazyEvaluator),
                     element.ConditionLocation,
-                    lazyEvaluator._loggingContext.LoggingService,
-                    lazyEvaluator._loggingContext.BuildEventContext,
                     lazyEvaluator.FileSystem,
                     loggingContext: lazyEvaluator._loggingContext);
                 MSBuildEventSource.Log.EvaluateConditionStop(condition, result);
@@ -619,7 +617,7 @@ private RemoveOperation BuildRemoveOperation(string rootDirectory, ProjectItemEl
 
         private void ProcessItemSpec(string rootDirectory, string itemSpec, IElementLocation itemSpecLocation, OperationBuilder builder)
         {
-            builder.ItemSpec = new ItemSpec<P, I>(itemSpec, _outerExpander, itemSpecLocation, rootDirectory, loggingContext: _loggingContext);
+            builder.ItemSpec = new ItemSpec<P, I>(itemSpec, _outerExpander, itemSpecLocation, rootDirectory);
 
             foreach (ItemSpecFragment fragment in builder.ItemSpec.Fragments)
             {
@@ -630,7 +628,7 @@ private void ProcessItemSpec(string rootDirectory, string itemSpec, IElementLoca
             }
         }
 
-        private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(ICollection<ProjectMetadataElement> metadata, Expander<P, I> expander, LoggingContext loggingContext = null)
+        private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(ICollection<ProjectMetadataElement> metadata, Expander<P, I> expander)
         {
             // Since we're just attempting to expand properties in order to find referenced items and not expanding metadata,
             // unexpected errors may occur when evaluating property functions on unexpanded metadata. Just ignore them if that happens.
@@ -644,8 +642,7 @@ private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(IColle
                 yield return expander.ExpandIntoStringLeaveEscaped(
                     metadatumElement.Value,
                     expanderOptions,
-                    metadatumElement.Location,
-                    loggingContext);
+                    metadatumElement.Location);
 
                 yield return expander.ExpandIntoStringLeaveEscaped(
                     metadatumElement.Condition,
@@ -660,7 +657,7 @@ private void ProcessMetadataElements(ProjectItemElement itemElement, OperationBu
             {
                 operationBuilder.Metadata.AddRange(itemElement.Metadata);
 
-                var itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(GetExpandedMetadataValuesAndConditions(itemElement.Metadata, _expander, _loggingContext));
+                var itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(GetExpandedMetadataValuesAndConditions(itemElement.Metadata, _expander));
                 if (itemsAndMetadataFound.Items != null)
                 {
                     foreach (var itemType in itemsAndMetadataFound.Items)
diff --git a/src/Build/Evaluation/PropertiesUseTracker.cs b/src/Build/Evaluation/PropertiesUseTracker.cs
new file mode 100644
index 00000000000..b88423adff1
--- /dev/null
+++ b/src/Build/Evaluation/PropertiesUseTracker.cs
@@ -0,0 +1,158 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics.CodeAnalysis;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+#nullable enable
+
+namespace Microsoft.Build.Evaluation;
+
+/// <summary>
+/// This class tracks reads of properties - so that it can detect uninitialized usages
+///  and so that it can forward the accessing information to further interested consumers (e.g. BuildCheck).
+/// </summary>
+internal sealed class PropertiesUseTracker
+{
+    internal LoggingContext LoggingContext { get; init; }
+
+    public PropertiesUseTracker(LoggingContext loggingContext) => LoggingContext = loggingContext;
+
+    /// <summary>
+    /// Whether to warn when we set a property for the first time, after it was previously used.
+    /// Default is false, unless MSBUILDWARNONUNINITIALIZEDPROPERTY is set.
+    /// </summary>
+    // This setting may change after the build has started, therefore if the user has not set the property to true on the build parameters we need to check to see if it is set to true on the environment variable.
+    private bool _warnForUninitializedProperties = BuildParameters.WarnOnUninitializedProperty || Traits.Instance.EscapeHatches.WarnOnUninitializedProperty;
+
+    /// <summary>
+    /// Lazily allocated collection of properties and the element which used them.
+    /// </summary>
+    private Dictionary<string, IElementLocation>? _properties;
+
+    internal void TrackRead(string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, bool isUninitialized, bool isArtificial)
+    {
+        if (isArtificial || !isUninitialized)
+        {
+            return;
+        }
+
+        // We have evaluated a property to null. We now need to see if we need to add it to the list of properties which are used before they have been initialized
+        //
+        // We also do not want to add the property to the list if the environment variable is not set, also we do not want to add the property to the list if we are currently
+        // evaluating a condition because a common pattern for msbuild projects is to see if the property evaluates to empty and then set a value as this would cause a considerable number of false positives.   <A Condition="'$(A)' == ''">default</A>
+        //
+        // Another pattern used is where a property concatenates with other values,  <a>$(a);something</a> however we do not want to add the a element to the list because again this would make a number of
+        // false positives. Therefore we check to see what element we are currently evaluating and if it is the same as our property we do not add the property to the list.
+
+        // here handle null probably (or otherwise execution)
+        if (_warnForUninitializedProperties && CurrentlyEvaluatingPropertyElementName != null)
+        {
+            // Check to see if the property name does not match the property we are currently evaluating, note the property we are currently evaluating in the element name, this means no $( or )
+            if (!MSBuildNameIgnoreCaseComparer.Default.Equals(CurrentlyEvaluatingPropertyElementName, propertyName, startIndex, endIndex - startIndex + 1))
+            {
+                TryAdd(
+                    propertyName: propertyName.Substring(startIndex, endIndex - startIndex + 1),
+                    elementLocation);
+            }
+        }
+    }
+
+    internal void TryAdd(string propertyName, IElementLocation elementLocation)
+    {
+        if (_properties is null)
+        {
+            _properties = new(StringComparer.OrdinalIgnoreCase);
+        }
+        else if (_properties.ContainsKey(propertyName))
+        {
+            return;
+        }
+
+        _properties.Add(propertyName, elementLocation);
+    }
+
+    internal bool TryGetPropertyElementLocation(string propertyName, [NotNullWhen(returnValue: true)] out IElementLocation? elementLocation)
+    {
+        if (_properties is null)
+        {
+            elementLocation = null;
+            return false;
+        }
+
+        return _properties.TryGetValue(propertyName, out elementLocation);
+    }
+
+    internal void RemoveProperty(string propertyName)
+    {
+        _properties?.Remove(propertyName);
+    }
+
+    /// <summary>
+    ///  What is the currently evaluating property element, this is so that we do not add a un initialized property if we are evaluating that property.
+    /// </summary>
+    internal string? CurrentlyEvaluatingPropertyElementName
+    {
+        get;
+        set;
+    }
+
+    internal void CheckPreexistingUndefinedUsage(IPropertyElementWithLocation propertyElement, string evaluatedValue, LoggingContext loggingContext)
+    {
+        // If we are going to set a property to a value other than null or empty we need to check to see if it has been used
+        // during evaluation.
+        if (evaluatedValue.Length > 0 && _warnForUninitializedProperties)
+        {
+            // Is the property we are currently setting in the list of properties which have been used but not initialized
+            IElementLocation? elementWhichUsedProperty;
+            bool isPropertyInList = TryGetPropertyElementLocation(propertyElement.Name, out elementWhichUsedProperty);
+
+            if (isPropertyInList)
+            {
+                // Once we are going to warn for a property once, remove it from the list so we do not add it again.
+                RemoveProperty(propertyElement.Name);
+                loggingContext.LogWarning(null, new BuildEventFileInfo(propertyElement.Location), "UsedUninitializedProperty", propertyElement.Name, elementWhichUsedProperty?.LocationString);
+            }
+        }
+
+        CurrentlyEvaluatingPropertyElementName = null;
+        PropertyReadContext = PropertyReadContext.Other;
+    }
+
+    private PropertyReadContext _propertyReadContext;
+    private PropertyReadContext _previousPropertyReadContext = PropertyReadContext.Other;
+    internal PropertyReadContext PropertyReadContext
+    {
+        private get => _propertyReadContext;
+        set
+        {
+            _previousPropertyReadContext = _propertyReadContext;
+            _propertyReadContext = value;
+        }
+    }
+
+    internal void ResetPropertyReadContext(bool pop = true)
+    {
+        _propertyReadContext = pop ? _previousPropertyReadContext : PropertyReadContext.Other;
+        _previousPropertyReadContext = PropertyReadContext.Other;
+    }
+}
+
+/// <summary>
+/// Type of the context in which a property is read.
+/// </summary>
+internal enum PropertyReadContext
+{
+    // we are not interested in distinguishing the item read etc.
+    Other,
+    ConditionEvaluation,
+    ConditionEvaluationWithOneSideEmpty,
+    PropertyEvaluation,
+    PropertyEvaluationSelf,
+}
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index 51117c2d7c1..4b2cd613881 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Components.Logging;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation.Context;
@@ -13,8 +14,6 @@
 using Microsoft.Build.Shared;
 using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
 
-#nullable disable
-
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
@@ -61,7 +60,11 @@ public PropertyTrackingEvaluatorDataWrapper(IEvaluatorData<P, I, M, D> dataToWra
         public P GetProperty(string name)
         {
             P prop = _wrapped.GetProperty(name);
-            this.TrackPropertyRead(name, prop);
+            if (IsPropertyReadTrackingRequested)
+            {
+                this.TrackPropertyRead(name, prop);
+            }
+
             return prop;
         }
 
@@ -72,22 +75,26 @@ public P GetProperty(string name)
         public P GetProperty(string name, int startIndex, int endIndex)
         {
             P prop = _wrapped.GetProperty(name, startIndex, endIndex);
-            this.TrackPropertyRead(name.Substring(startIndex, endIndex - startIndex + 1), prop);
+            if (IsPropertyReadTrackingRequested)
+            {
+                this.TrackPropertyRead(name.Substring(startIndex, endIndex - startIndex + 1), prop);
+            }
+
             return prop;
         }
 
         /// <summary>
         /// Sets a property which does not come from the Xml.
         /// </summary>
-        public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, BackEnd.Logging.LoggingContext loggingContext = null)
+        public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, LoggingContext? loggingContext = null)
         {
-            P originalProperty = _wrapped.GetProperty(name);
-            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, isEnvironmentVariable, loggingContext);
+            P? originalProperty = _wrapped.GetProperty(name);
+            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, isEnvironmentVariable, _evaluationLoggingContext);
 
             this.TrackPropertyWrite(
                 originalProperty,
                 newProperty,
-                string.Empty,
+                null,
                 this.DeterminePropertySource(isGlobalProperty, mayBeReserved, isEnvironmentVariable));
 
             return newProperty;
@@ -102,17 +109,18 @@ public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalPro
         /// </summary>
         public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped)
         {
-            P originalProperty = _wrapped.GetProperty(propertyElement.Name);
+            P? originalProperty = _wrapped.GetProperty(propertyElement.Name);
             P newProperty = _wrapped.SetProperty(propertyElement, evaluatedValueEscaped);
 
             this.TrackPropertyWrite(
                 originalProperty,
                 newProperty,
-                propertyElement.Location.LocationString,
+                propertyElement.Location,
                 PropertySource.Xml);
 
             return newProperty;
         }
+
         #endregion
 
         #region IEvaluatorData<> members that are forwarded directly to wrapped object.
@@ -137,7 +145,7 @@ public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedVal
         public IItemDictionary<I> Items => _wrapped.Items;
         public List<ProjectItemElement> EvaluatedItemElements => _wrapped.EvaluatedItemElements;
         public PropertyDictionary<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary => _wrapped.EnvironmentVariablePropertiesDictionary;
-        public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext) => _wrapped.InitializeForEvaluation(toolsetProvider, evaluationContext);
+        public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext, LoggingContext loggingContext) => _wrapped.InitializeForEvaluation(toolsetProvider, evaluationContext, loggingContext);
         public void FinishEvaluation() => _wrapped.FinishEvaluation();
         public void AddItem(I item) => _wrapped.AddItem(item);
         public void AddItemIgnoringCondition(I item) => _wrapped.AddItemIgnoringCondition(item);
@@ -155,6 +163,16 @@ public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedVal
         #endregion
 
         #region Private Methods...
+
+        private bool IsPropertyReadTrackingRequested
+            => IsEnvironmentVariableReadTrackingRequested ||
+               (_settings & PropertyTrackingSetting.UninitializedPropertyRead) ==
+               PropertyTrackingSetting.UninitializedPropertyRead;
+
+        private bool IsEnvironmentVariableReadTrackingRequested
+            => (_settings & PropertyTrackingSetting.EnvironmentVariableRead) ==
+               PropertyTrackingSetting.EnvironmentVariableRead;
+
         /// <summary>
         /// Logic containing what to do when a property is read.
         /// </summary>
@@ -172,7 +190,7 @@ private void TrackPropertyRead(string name, P property)
 
             // If a property matches the name of an environment variable, but has NOT been overwritten by a non-environment-variable property
             // track it as an environment variable read.
-            if (_wrapped.EnvironmentVariablePropertiesDictionary.Contains(name) && !_overwrittenEnvironmentVariables.Contains(name))
+            if (IsEnvironmentVariableReadTrackingRequested && _wrapped.EnvironmentVariablePropertiesDictionary.Contains(name) && !_overwrittenEnvironmentVariables.Contains(name))
             {
                 this.TrackEnvironmentVariableRead(name);
             }
@@ -220,16 +238,10 @@ private void TrackUninitializedPropertyRead(string name)
             _evaluationLoggingContext.LogBuildEvent(args);
         }
 
-        private void TrackPropertyWrite(P predecessor, P property, string location, PropertySource source)
+        private void TrackPropertyWrite(P? predecessor, P property, IElementLocation? location, PropertySource source)
         {
             string name = property.Name;
 
-            // If this property was an environment variable but no longer is, track it.
-            if (_wrapped.EnvironmentVariablePropertiesDictionary.Contains(name) && source != PropertySource.EnvironmentVariable)
-            {
-                _overwrittenEnvironmentVariables.Add(name);
-            }
-
             if (predecessor == null)
             {
                 // If this property had no previous value, then track an initial value.
@@ -238,7 +250,13 @@ private void TrackPropertyWrite(P predecessor, P property, string location, Prop
             else
             {
                 // There was a previous value, and it might have been changed. Track that.
-                TrackPropertyReassignment(predecessor, property, location);
+                TrackPropertyReassignment(predecessor, property, location?.LocationString);
+            }
+
+            // If this property was an environment variable but no longer is, track it.
+            if (IsEnvironmentVariableReadTrackingRequested && _wrapped.EnvironmentVariablePropertiesDictionary.Contains(name) && source != PropertySource.EnvironmentVariable)
+            {
+                _overwrittenEnvironmentVariables.Add(name);
             }
         }
 
@@ -270,14 +288,9 @@ private void TrackPropertyInitialValueSet(P property, PropertySource source)
         /// <param name="predecessor">The property's preceding state. Null if none.</param>
         /// <param name="property">The property's current state.</param>
         /// <param name="location">The location of this property's reassignment.</param>
-        private void TrackPropertyReassignment(P predecessor, P property, string location)
+        private void TrackPropertyReassignment(P? predecessor, P property, string? location)
         {
-            if ((_settings & PropertyTrackingSetting.PropertyReassignment) != PropertyTrackingSetting.PropertyReassignment)
-            {
-                return;
-            }
-
-            if (string.Equals(property.Name, "MSBuildAllProjects", StringComparison.OrdinalIgnoreCase))
+            if (MSBuildNameIgnoreCaseComparer.Default.Equals(property.Name, "MSBuildAllProjects"))
             {
                 // There's a huge perf cost to logging this and it increases the binlog size significantly.
                 // Meanwhile the usefulness of logging this is very low.
@@ -285,21 +298,37 @@ private void TrackPropertyReassignment(P predecessor, P property, string locatio
             }
 
             string newValue = property.EvaluatedValue;
-            string oldValue = predecessor.EvaluatedValue;
+            string? oldValue = predecessor?.EvaluatedValue;
             if (newValue == oldValue)
             {
                 return;
             }
 
-            var args = new PropertyReassignmentEventArgs(
-                property.Name,
-                oldValue,
-                newValue,
-                location,
-                message: null);
-            args.BuildEventContext = _evaluationLoggingContext.BuildEventContext;
-
-            _evaluationLoggingContext.LogBuildEvent(args);
+            // Either we want to specifically track property reassignments
+            // or we do not want to track nothing - in which case the prop reassignment is enabled by default.
+            if ((_settings & PropertyTrackingSetting.PropertyReassignment) == PropertyTrackingSetting.PropertyReassignment ||
+                (_settings == 0 && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10)))
+            {
+                var args = new PropertyReassignmentEventArgs(
+                        property.Name,
+                        oldValue,
+                        newValue,
+                        location,
+                        message: null)
+                    { BuildEventContext = _evaluationLoggingContext.BuildEventContext, };
+
+                _evaluationLoggingContext.LogBuildEvent(args);
+            }
+            else
+            {
+                _evaluationLoggingContext.LogComment(
+                    MessageImportance.Low,
+                    "PropertyReassignment",
+                    property.Name,
+                    newValue,
+                    oldValue,
+                    location);
+            }
         }
 
         /// <summary>
diff --git a/src/Build/Instance/IPropertyElementWithLocation.cs b/src/Build/Instance/IPropertyElementWithLocation.cs
new file mode 100644
index 00000000000..f77282d9590
--- /dev/null
+++ b/src/Build/Instance/IPropertyElementWithLocation.cs
@@ -0,0 +1,28 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Construction;
+
+namespace Microsoft.Build.Execution
+{
+    /// <summary>
+    /// Represents a xml node in a project file that defines a property.
+    /// </summary>
+    internal interface IPropertyElementWithLocation
+    {
+        /// <summary>
+        /// Name of the property.
+        /// </summary>
+        string Name { get; }
+
+        /// <summary>
+        /// Unevaluated value of the property.
+        /// </summary>
+        string Value { get; }
+
+        /// <summary>
+        /// Location of the property element within build scripts.
+        /// </summary>
+        ElementLocation Location { get; }
+    }
+}
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 32a408a5ca4..c8bdd009a8f 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -14,6 +14,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.Experimental.BuildCheck.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Definition;
@@ -1556,7 +1557,7 @@ ICollection<ProjectItemInstance> IItemProvider<ProjectItemInstance>.GetItems(str
         /// Only called during evaluation, so does not check for immutability.
         /// </summary>
         void IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.
-            InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext)
+            InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext, LoggingContext loggingContext)
         {
             // All been done in the constructor.  We don't allow re-evaluation of project instances.
         }
@@ -2089,7 +2090,7 @@ public bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<Fo
         /// </comment>
         public string ExpandString(string unexpandedValue)
         {
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(this, this, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(this, this, FileSystems.Default, _loggingContext);
 
             string result = expander.ExpandIntoStringAndUnescape(unexpandedValue, ExpanderOptions.ExpandPropertiesAndItems, ProjectFileLocation);
 
@@ -2107,7 +2108,7 @@ public string ExpandString(string unexpandedValue)
         /// </comment>
         public bool EvaluateCondition(string condition)
         {
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(this, this, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(this, this, FileSystems.Default, _loggingContext);
 
             bool result = ConditionEvaluator.EvaluateCondition(
                 condition,
@@ -2116,9 +2117,8 @@ public bool EvaluateCondition(string condition)
                 ExpanderOptions.ExpandPropertiesAndItems,
                 Directory,
                 ProjectFileLocation,
-                null /* no logging service */,
-                BuildEventContext.Invalid,
-                FileSystems.Default);
+                FileSystems.Default,
+                null /* no logging context */);
 
             return result;
         }
@@ -2894,6 +2894,12 @@ private static ProjectPropertyInstance InstantiateProjectPropertyInstance(Projec
             return instance;
         }
 
+        /// <summary>
+        /// Logging context - set during the evaluation.
+        /// Can be null - especially if the project was fetched from the cache.
+        /// </summary>
+        private LoggingContext _loggingContext;
+
         /// <summary>
         /// Common code for the constructors that evaluate directly.
         /// Global properties may be null.
@@ -2934,7 +2940,7 @@ private void Initialize(
             _itemDefinitions = new RetrievableEntryHashSet<ProjectItemDefinitionInstance>(MSBuildNameIgnoreCaseComparer.Default);
             _hostServices = buildParameters.HostServices;
             this.ProjectRootElementCache = buildParameters.ProjectRootElementCache;
-
+            _loggingContext = new AnalyzerLoggingContext(loggingService, buildEventContext);
             this.EvaluatedItemElements = new List<ProjectItemElement>();
 
             _explicitToolsVersionSpecified = (explicitToolsVersion != null);
diff --git a/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs b/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
index 6eb9b3f1972..5ce7695e734 100644
--- a/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.Execution
     /// Immutable.
     /// </summary>
     [DebuggerDisplay("{_name}={Value} Condition={_condition}")]
-    public class ProjectPropertyGroupTaskPropertyInstance : ITranslatable
+    public class ProjectPropertyGroupTaskPropertyInstance : ITranslatable, IPropertyElementWithLocation
     {
         /// <summary>
         /// Name of the property
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 5b65829e926..598819b3cd4 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -11,6 +11,7 @@
 using System.Reflection;
 using System.Threading;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
@@ -249,8 +250,7 @@ internal IDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> TaskReg
         /// <typeparam name="P">A type derived from IProperty</typeparam>
         /// <typeparam name="I">A type derived from IItem</typeparam>
         internal static void InitializeTaskRegistryFromUsingTaskElements<P, I>(
-            ILoggingService loggingService,
-            BuildEventContext buildEventContext,
+            LoggingContext loggingContext,
             IEnumerable<(ProjectUsingTaskElement projectUsingTaskXml, string directoryOfImportingFile)> registrations,
             TaskRegistry taskRegistry,
             Expander<P, I> expander,
@@ -262,8 +262,7 @@ internal static void InitializeTaskRegistryFromUsingTaskElements<P, I>(
             foreach ((ProjectUsingTaskElement projectUsingTaskXml, string directoryOfImportingFile) registration in registrations)
             {
                 RegisterTasksFromUsingTaskElement(
-                    loggingService,
-                    buildEventContext,
+                    loggingContext,
                     registration.directoryOfImportingFile,
                     registration.projectUsingTaskXml,
                     taskRegistry,
@@ -284,8 +283,7 @@ internal static void InitializeTaskRegistryFromUsingTaskElements<P, I>(
         /// <typeparam name="I">A type derived from IItem</typeparam>
         private static void RegisterTasksFromUsingTaskElement
             <P, I>(
-            ILoggingService loggingService,
-            BuildEventContext buildEventContext,
+            LoggingContext loggingContext,
             string directoryOfImportingFile,
             ProjectUsingTaskElement projectUsingTaskXml,
             TaskRegistry taskRegistry,
@@ -307,9 +305,8 @@ private static void RegisterTasksFromUsingTaskElement
                     expanderOptions,
                     projectUsingTaskXml.ContainingProject.DirectoryPath,
                     projectUsingTaskXml.ConditionLocation,
-                    loggingService,
-                    buildEventContext,
-                    fileSystem))
+                    fileSystem,
+                    loggingContext))
             {
                 return;
             }
@@ -444,7 +441,7 @@ private static void RegisterTasksFromUsingTaskElement
                 taskFactoryParameters.Add(XMakeAttributes.architecture, architecture == String.Empty ? XMakeAttributes.MSBuildArchitectureValues.any : architecture);
             }
 
-            taskRegistry.RegisterTask(taskName, AssemblyLoadInfo.Create(assemblyName, assemblyFile), taskFactory, taskFactoryParameters, parameterGroupAndTaskElementRecord, loggingService, buildEventContext, projectUsingTaskXml, ConversionUtilities.ValidBooleanTrue(overrideUsingTask));
+            taskRegistry.RegisterTask(taskName, AssemblyLoadInfo.Create(assemblyName, assemblyFile), taskFactory, taskFactoryParameters, parameterGroupAndTaskElementRecord, loggingContext, projectUsingTaskXml, ConversionUtilities.ValidBooleanTrue(overrideUsingTask));
         }
 
         private static Dictionary<string, string> CreateTaskFactoryParametersDictionary(int? initialCount = null)
@@ -547,7 +544,7 @@ internal RegisteredTaskRecord GetTaskRegistrationRecord(
             // Try the override task registry first
             if (_toolset != null)
             {
-                TaskRegistry toolsetRegistry = _toolset.GetOverrideTaskRegistry(targetLoggingContext.LoggingService, targetLoggingContext.BuildEventContext, RootElementCache);
+                TaskRegistry toolsetRegistry = _toolset.GetOverrideTaskRegistry(targetLoggingContext, RootElementCache);
                 taskRecord = toolsetRegistry.GetTaskRegistrationRecord(taskName, taskProjectFile, taskIdentityParameters, exactMatchRequired, targetLoggingContext, elementLocation, out retrievedFromCache);
             }
 
@@ -606,7 +603,7 @@ internal RegisteredTaskRecord GetTaskRegistrationRecord(
             // If we didn't find the task but we have a fallback registry in the toolset state, try that one.
             if (taskRecord == null && _toolset != null)
             {
-                TaskRegistry toolsetRegistry = _toolset.GetTaskRegistry(targetLoggingContext.LoggingService, targetLoggingContext.BuildEventContext, RootElementCache);
+                TaskRegistry toolsetRegistry = _toolset.GetTaskRegistry(targetLoggingContext, RootElementCache);
                 taskRecord = toolsetRegistry.GetTaskRegistrationRecord(taskName, taskProjectFile, taskIdentityParameters, exactMatchRequired, targetLoggingContext, elementLocation, out retrievedFromCache);
             }
 
@@ -687,8 +684,7 @@ private void RegisterTask(
             string taskFactory,
             Dictionary<string, string> taskFactoryParameters,
             RegisteredTaskRecord.ParameterGroupAndTaskElementRecord inlineTaskRecord,
-            ILoggingService loggingService,
-            BuildEventContext context,
+            LoggingContext loggingContext,
             ProjectUsingTaskElement projectUsingTaskInXml,
             bool overrideTask = false)
         {
@@ -733,7 +729,7 @@ private void RegisterTask(
                     {
                         if (rec.RegisteredName.Equals(taskIdentity.Name, StringComparison.OrdinalIgnoreCase))
                         {
-                            loggingService.LogError(context, null, new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), "DuplicateOverrideUsingTaskElement", taskName);
+                            loggingContext.LogError(new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), "DuplicateOverrideUsingTaskElement", taskName);
                             break;
                         }
                     }
@@ -745,7 +741,7 @@ private void RegisterTask(
                     List<RegisteredTaskRecord> unqualifiedTaskNameMatches = new();
                     unqualifiedTaskNameMatches.Add(newRecord);
                     _overriddenTasks.Add(unqualifiedTaskName, unqualifiedTaskNameMatches);
-                    loggingService.LogComment(context, MessageImportance.Low, "OverrideUsingTaskElementCreated", taskName, projectUsingTaskInXml.OverrideLocation);
+                    loggingContext.LogComment(MessageImportance.Low, "OverrideUsingTaskElementCreated", taskName, projectUsingTaskInXml.OverrideLocation);
                 }
             }
 
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index a7b005a1925..d4c37461938 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -71,6 +71,8 @@ public sealed class BinaryLogger : ILogger
         //   - GeneratedFileUsedEventArgs exposed for brief period of time (so let's continue with 20)
         // version 20:
         //   - TaskStartedEventArgs: Added TaskAssemblyLocation property
+        // version 21:
+        //   - TaskParameterEventArgs: Added ParameterName and PropertyName properties
 
         // This should be never changed.
         // The minimum version of the binary log reader that can read log of above version.
@@ -78,7 +80,7 @@ public sealed class BinaryLogger : ILogger
 
         // The current version of the binary log representation.
         // Changes with each update of the binary log format.
-        internal const int FileFormatVersion = 20;
+        internal const int FileFormatVersion = 21;
 
         // The minimum version of the binary log reader that can read log of above version.
         // This should be changed only when the binary log format is changed in a way that would prevent it from being
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 03ce7bed76c..358c410265f 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -1022,10 +1022,15 @@ private BuildEventArgs ReadTaskParameterEventArgs()
             var kind = (TaskParameterMessageKind)ReadInt32();
             var itemType = ReadDeduplicatedString();
             var items = ReadTaskItemList() as IList;
+            var (parameterName, propertyName) = _fileFormatVersion >= 21
+                ? (ReadDeduplicatedString(), ReadDeduplicatedString())
+                : (null, null);
 
             var e = ItemGroupLoggingHelper.CreateTaskParameterEventArgs(
                 fields.BuildEventContext,
                 kind,
+                parameterName,
+                propertyName,
                 itemType,
                 items,
                 logItemMetadata: true,
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 0c5c82846b3..a9a734b1638 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -571,6 +571,8 @@ private BinaryLogRecordKind Write(TaskParameterEventArgs e)
             Write((int)e.Kind);
             WriteDeduplicatedString(e.ItemType);
             WriteTaskItemList(e.Items, e.LogItemMetadata);
+            WriteDeduplicatedString(e.ParameterName);
+            WriteDeduplicatedString(e.PropertyName);
             if (e.Kind == TaskParameterMessageKind.AddItem
                || e.Kind == TaskParameterMessageKind.TaskOutput)
             {
diff --git a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
index 8e63fe788e3..55cc7fd8c57 100644
--- a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
@@ -182,6 +182,10 @@ private void ApplyParameter(IEventSource eventSource, string parameterName)
                     _forwardProjectContext = true;
                     isEventForwardingParameter = false;
                     break;
+                case RespectVerbosityDescription:
+                    _respectVerbosity = true;
+                    isEventForwardingParameter = false;
+                    break;
                 default:
                     isEventForwardingParameter = false;
                     break;
@@ -202,7 +206,7 @@ public virtual void Initialize(IEventSource eventSource)
 
             ParseParameters(eventSource);
 
-            if (!_forwardingSetFromParameters)
+            if (_respectVerbosity || !_forwardingSetFromParameters)
             {
                 SetForwardingBasedOnVerbosity(eventSource);
             }
@@ -421,6 +425,7 @@ private bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity)
         private const string NoSummaryDescription = "NOSUMMARY";
         private const string ShowCommandLineDescription = "SHOWCOMMANDLINE";
         private const string ForwardProjectContextDescription = "FORWARDPROJECTCONTEXTEVENTS";
+        private const string RespectVerbosityDescription = "RESPECTVERBOSITY";
 
         #region Per-build Members
 
@@ -435,6 +440,12 @@ private bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity)
         /// </summary>
         private bool _forwardingSetFromParameters;
 
+        /// <summary>
+        /// Indicates if the parameters explicitly specified respecting of the verbosity (forwarding will
+        ///  be set based on verbosity, in addition to explicitly configured forwarding via parameters).
+        /// </summary>
+        private bool _respectVerbosity;
+
         /// <summary>
         /// Indicates if the events to forward should include project context events, if not
         /// overridden by individual-event forwarding in <see cref="_forwardingSetFromParameters"/>.
diff --git a/src/Build/Logging/LoggerDescription.cs b/src/Build/Logging/LoggerDescription.cs
index ef3a68959ab..8f949afb9ad 100644
--- a/src/Build/Logging/LoggerDescription.cs
+++ b/src/Build/Logging/LoggerDescription.cs
@@ -118,6 +118,10 @@ public string LoggerSwitchParameters
             {
                 return _loggerSwitchParameters;
             }
+            internal set
+            {
+                _loggerSwitchParameters = value;
+            }
         }
 
         public bool IsOptional
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index f9528b3b6d8..d71ce74084b 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -30,10 +30,7 @@
   <ItemGroup>
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
-
-    <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
-    <PackageReference Include="System.Threading.Tasks.Dataflow" />
 
     <PackageReference Include="System.Reflection.MetadataLoadContext" />
 
@@ -50,6 +47,8 @@
     <PackageReference Include="System.Memory" />
     <PackageReference Include="System.Security.Principal.Windows" />
     <PackageReference Include="System.Text.Json" />
+    <PackageReference Include="System.Collections.Immutable" />
+    <PackageReference Include="System.Threading.Tasks.Dataflow" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
@@ -167,6 +166,10 @@
     <Compile Include="BuildCheck\Infrastructure\NullBuildCheckManager.cs" />
     <Compile Include="BuildCheck\Infrastructure\NullBuildCheckManagerProvider.cs" />
     <Compile Include="BuildCheck\Infrastructure\TracingReporter.cs" />
+    <Compile Include="BuildCheck\Infrastructure\EditorConfig\EditorConfigFile.cs" />
+    <Compile Include="BuildCheck\Infrastructure\EditorConfig\EditorConfigGlobsMatcher.cs" />
+    <Compile Include="BuildCheck\Infrastructure\EditorConfig\EditorConfigParser.cs" />
+    <Compile Include="BuildCheck\Infrastructure\BuildCheckConfigurationErrorScope.cs" />
     <Compile Include="BuildCheck\OM\BuildCheckDataContext.cs" />
     <Compile Include="BuildCheck\API\BuildAnalyzer.cs" />
     <Compile Include="BuildCheck\API\BuildAnalyzerConfiguration.cs" />
@@ -191,6 +194,7 @@
     <Compile Include="BuildCheck\Utilities\Constants.cs" />
     <Compile Include="BuildCheck\Utilities\EnumerableExtensions.cs" />
     <Compile Include="Evaluation\IItemTypeDefinition.cs" />
+    <Compile Include="Evaluation\PropertiesUseTracker.cs" />
     <Compile Include="FileAccess\DesiredAccess.cs" />
     <Compile Include="FileAccess\FileAccessData.cs" />
     <Compile Include="FileAccess\FlagsAndAttributes.cs" />
@@ -199,6 +203,7 @@
     <Compile Include="FileAccess\RequestedAccess.cs" />
     <Compile Include="BuildCheck\Logging\AnalyzerLoggingContext.cs" />
     <Compile Include="BuildCheck\Logging\AnalyzerLoggingContextFactory.cs" />
+    <Compile Include="Instance\IPropertyElementWithLocation.cs" />
     <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
     <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
     <Compile Include="BackEnd\Node\PartialBuildTelemetry.cs" />
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 62bcd2464c3..c1fd804eefc 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1102,6 +1102,9 @@
   <data name="OutputItemParameterMessagePrefix" xml:space="preserve">
     <value>Output Item(s): </value>
   </data>
+  <data name="OutputPropertyLogMessagePrefix" xml:space="preserve">
+    <value>Output Property: </value>
+  </data>
   <data name="OutputPropertyLogMessage" xml:space="preserve">
     <value>Output Property: {0}={1}</value>
   </data>
@@ -2111,6 +2114,10 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</value>
     <comment>The message is emitted when the custom analyzer assembly can not be found.</comment>
   </data>
+  <data name="CustomAnalyzerBaseTypeNotAssignable" xml:space="preserve">
+    <value>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</value>
+    <comment>The message is emitted when the custom analyzer assembly can not be successfully registered.</comment>
+  </data>
   <data name="TaskAssemblyLocationMismatch" xml:space="preserve">
     <value>Task assembly was loaded from '{0}' while the desired location was '{1}'.</value>
   </data>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index cce18578077..18b181ccbed 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -212,6 +212,11 @@
         <target state="translated">Nepodařilo se najít zadané sestavení vlastního analyzátoru: {0}. Zkontrolujte prosím, jestli existuje.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Nepodařilo se načíst vlastní typ analyzátoru: {0} ze sestavení: {1}. Ujistěte se, že dědí základní třídu Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Pokud se nemá jednat o vlastní analyzátor, neměl by být odkrytý. Další informace: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">Nepodařilo se zaregistrovat vlastní analyzátor: {0}.</target>
@@ -393,6 +398,11 @@
         <target state="translated">Metoda {0} se nedá zavolat s kolekcí, která obsahuje prázdné cílové názvy nebo názvy null.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">Výstupní vlastnost: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Vytvořilo se přepsání pomocí úlohy: {0} v {1}</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index d1aa6cbc8ec..d1939e8c983 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -212,6 +212,11 @@
         <target state="translated">Fehler beim Suchen der angegebenen benutzerdefinierten Analysetoolassembly: {0}. Überprüfen Sie, ob sie vorhanden ist.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Fehler beim Laden des benutzerdefinierten Analysetooltyps „{0}“ aus der Assembly „{1}“. Stellen Sie sicher, dass es die Basisklasse „Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer“ erbt. Wenn es sich nicht um ein benutzerdefiniertes Analysetool handelt, sollte es nicht verfügbar gemacht werden. Weitere Informationen: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">Fehler beim Registrieren des benutzerdefinierten Analysetools: {0}.</target>
@@ -393,6 +398,11 @@
         <target state="translated">Die Methode "{0}" kann nicht mit einer Sammlung aufgerufen werden, die NULL oder leere Zielnamen enthält.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">Ausgabeeigenschaft: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Außerkraftsetzung mit Task erstellt: {0} bei {1}</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 90914c626ff..5c249e91567 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -212,6 +212,11 @@
         <target state="translated">No se ha podido encontrar el ensamblado del analizador personalizado especificado: {0}. Compruebe si existe.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">No se pudo cargar el tipo de analizador personalizado: {0} del ensamblado: {1}. Asegúrese de que hereda la clase base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Si no está pensado para ser un analizador personalizado, entonces no debería exponerse. Más información: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">No se ha podido registrar el analizador personalizado: {0}.</target>
@@ -393,6 +398,11 @@
         <target state="translated">No se puede llamar al método {0} con una colección que contiene nombres de destino nulos o vacíos.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">Propiedad de salida: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Se creó una invalidación mediante la tarea: {0} en {1}</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 09bad2f7e80..544d09a28ea 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -212,6 +212,11 @@
         <target state="translated">Impossible de trouver l’assemblée d'analyseur personnalisé spécifié : {0}. Vérifiez s’il existe.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Échec du chargement du type d’analyseur personnalisé : {0} à partir de l’assembly : {1}. Assurez-vous qu’il hérite de la classe de base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. S’il ne doit pas être un analyseur personnalisé, il ne doit pas être exposé. Plus d’informations : https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">Échec de l’inscription de l’analyseur personnalisé : {0}.</target>
@@ -393,6 +398,11 @@
         <target state="translated">Impossible d'appeler la méthode {0} avec une collection contenant des noms de cibles qui ont une valeur null ou qui sont vides.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">Propriété de sortie : </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Remplacement créé à l’aide de la tâche : {0} au {1}</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 8bf8eec2d8d..2242fb24438 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -212,6 +212,11 @@
         <target state="translated">Impossibile trovare l'assembly dell'analizzatore personalizzato specificato: {0}. Verificare se esiste.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Non è stato possibile caricare il tipo di analizzatore diagnostico personalizzato: {0} dall'assembly: {1}. Assicurarsi che erediti la classe di base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Se non è destinato a essere un analizzatore personalizzato, non deve essere esposto. Per altre informazioni: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">Impossibile registrare l'analizzatore personalizzato: {0}.</target>
@@ -393,6 +398,11 @@
         <target state="translated">Non è possibile chiamare il metodo {0} con una raccolta contenente nomi di destinazione Null o vuoti.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">Proprietà di output: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">È stata creata una sostituzione con l'attività: {0} in {1}</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index fbdc02d0590..f2d35e4d44e 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -212,6 +212,11 @@
         <target state="translated">指定されたカスタム アナライザー アセンブリが見つかりませんでした: {0}。存在するかどうか確認してください。</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">カスタム アナライザーの種類を読み込めませんでした: アセンブリ {1} の {0}。Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 基底クラスを継承していることを確認してください。カスタム アナライザーを意図していない場合は、公開しないでください。詳細情報: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">カスタム アナライザーを登録できませんでした: {0}</target>
@@ -393,6 +398,11 @@
         <target state="translated">Null または空のターゲット名を含むコレクションを指定してメソッド {0} を呼び出すことはできません。</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">プロパティの出力: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">タスクを使用してオーバーライドを作成しました: {1} の {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index dc7c94b9d2f..b15a7cd0dcf 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -212,6 +212,11 @@
         <target state="translated">지정한 사용자 지정 분석기 어셈블리를 찾지 못했습니다. {0}. 존재하는지 확인하세요.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">사용자 지정 분석기 형식을 로드하지 못했습니다. 어셈블리에서 {0} : {1}. Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 기본 클래스를 상속해야 합니다. 사용자 지정 분석기가 아닌 경우 노출되지 않아야 합니다. 추가 정보: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">사용자 지정 분석기를 등록하지 못했습니다. {0}.</target>
@@ -393,6 +398,11 @@
         <target state="translated">null 또는 빈 대상 이름을 포함하는 컬렉션을 사용하여 {0} 메서드를 호출할 수 없습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">출력 속성: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">다음 작업을 사용하여 재정의를 만들었습니다. {1}의 {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index d8d09cb9c63..57e7834317c 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -212,6 +212,11 @@
         <target state="translated">Nie można odnaleźć określonego zestawu analizatora niestandardowego: {0}. Sprawdź, czy istnieje.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Nie udało się załadować niestandardowego analizatora typu: {0} z zestawu: {1}. Upewnij się, że dziedziczy po klasie bazowej Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Jeśli nie jest przeznaczony do niestandardowego analizatora, nie powinien być ujawniany. Więcej informacji: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">Nie można zarejestrować analizatora niestandardowego: {0}.</target>
@@ -393,6 +398,11 @@
         <target state="translated">Metody {0} nie można wywołać przy użyciu kolekcji zawierającej nazwy docelowe o wartości null lub puste.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">Właściwość danych wyjściowych: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Utworzono zastąpienie przy użyciu zadania: {0} o {1}</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 389700299cc..70fce9b1272 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -212,6 +212,11 @@
         <target state="translated">Falha ao localizar o assembly do analisador personalizado especificado: {0}. Verifique se existe.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Falha ao carregar o tipo de analisador personalizado: {0} do assembly: {1}. Certifique-se de que ele herde a classe base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Se não se destina a ser um analisador personalizado, ele não deve ser exposto. Mais informações: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">Falha ao registrar o analisador personalizado: {0}.</target>
@@ -393,6 +398,11 @@
         <target state="translated">O método {0} não pode ser chamado com uma coleção que contém nomes de destino nulos ou vazios.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">Propriedade de Saída: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Criou uma substituição usando a tarefa: {0} em {1}</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 5c04d7194eb..c57aef79086 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -212,6 +212,11 @@
         <target state="translated">Не удалось найти указанную сборку настраиваемого анализатора: {0}. Убедитесь, что она существует.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Не удалось загрузить настраиваемый тип анализатора {0} из сборки {1}. Убедитесь, что он наследует базовый класс Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Если он не предназначен для настраиваемого анализатора, его не следует предоставлять. Дополнительные сведения: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">Не удалось зарегистрировать настраиваемый анализатор: {0}.</target>
@@ -393,6 +398,11 @@
         <target state="translated">Метод {0} не может быть вызван с коллекцией, содержащей целевые имена, которые пусты или равны NULL.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">Выходное свойство: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Создано переопределение с помощью задачи {0} в {1}</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index a9dc8a0e065..cef442b611a 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -212,6 +212,11 @@
         <target state="translated">Belirtilen {0} özel çözümleyici derlemesi bulunamadı. Lütfen var olup olmadığını kontrol edin.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Özel çözümleyici türü yüklenemedi: {0} derlemeden: {1}. Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer temel sınıf devralınmış olduğundan emin olun. Özel bir çözümleyici olması amaçlanmadıysa açığa çıkarılmaması gerekir. Daha fazla bilgi: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">Özel çözümleyici kaydedilemedi: {0}.</target>
@@ -393,6 +398,11 @@
         <target state="translated">{0} metosu null veya boş hedef adları içeren bir koleksiyonla çağrılamaz.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">Çıkış Özelliği: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">{0} görevi kullanılarak geçersiz kılma işlemi oluşturuldu, saat: {1}</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 868e495f52b..f2cd331de9b 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -212,6 +212,11 @@
         <target state="translated">找不到指定的自定义分析器程序集: {0}。请检查它是否存在。</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">未能从程序集 {1} 加载自定义分析器类型 {0}。请确保它继承 Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 基类。如果不打算将其作为自定义分析器，则不应将其公开。详细信息: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">无法注册自定义分析器: {0}。</target>
@@ -393,6 +398,11 @@
         <target state="translated">无法使用包含 null 或空目标名称的集合调用方法 {0}。</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">输出属性: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">已使用任务创建替代: {0} 位于 {1}</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index b31a9ad4517..8a8c9980020 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -212,6 +212,11 @@
         <target state="translated">找不到指定的自訂分析器組件: {0}。請檢查它是否存在。</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">無法從組件 {1} 載入自訂分析器類型 {0}。請確定它繼承 Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 基類。如果不是要作為自訂分析器，則不應公開。更多資訊: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">無法登錄自訂分析器: {0}。</target>
@@ -393,6 +398,11 @@
         <target state="translated">無法使用內含 null 或空白目標名稱的集合呼叫方法 {0}。</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">輸出屬性: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">已使用下列工作建立覆寫: 於 {1} 的 {0}</target>
diff --git a/src/BuildCheck.UnitTests/AssemblyInfo.cs b/src/BuildCheck.UnitTests/AssemblyInfo.cs
index 3b5d7bbb185..5b383e24105 100644
--- a/src/BuildCheck.UnitTests/AssemblyInfo.cs
+++ b/src/BuildCheck.UnitTests/AssemblyInfo.cs
@@ -2,3 +2,13 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
+
+namespace Microsoft.Build.UnitTests.Shared;
+
+[System.AttributeUsage(System.AttributeTargets.Assembly)]
+internal sealed class BootstrapLocationAttribute(string bootstrapRoot, string bootstrapMsbuildBinaryLocation)
+    : System.Attribute
+{
+    public string BootstrapRoot { get; } = bootstrapRoot;
+    public string BootstrapMsbuildBinaryLocation { get; } = bootstrapMsbuildBinaryLocation;
+}
diff --git a/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs b/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
index a3f8b019439..7bd57f8014b 100644
--- a/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
+++ b/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
@@ -1,11 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Xunit;
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Experimental.BuildCheck;
diff --git a/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs b/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs
new file mode 100644
index 00000000000..edfdfaf4589
--- /dev/null
+++ b/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs
@@ -0,0 +1,113 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class BuildAnalyzerConfiguration_Test
+{
+    [Fact]
+    public void CreateWithNull_ReturnsObjectWithNullValues()
+    {
+        var buildConfig = BuildAnalyzerConfiguration.Create(null);
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBeNull();
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
+    }
+
+    [Fact]
+    public void CreateWithEmpty_ReturnsObjectWithNullValues()
+    {
+        var buildConfig = BuildAnalyzerConfiguration.Create(new Dictionary<string, string>());
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBeNull();
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("error", BuildAnalyzerResultSeverity.Error)]
+    [InlineData("info", BuildAnalyzerResultSeverity.Info)]
+    [InlineData("warning", BuildAnalyzerResultSeverity.Warning)]
+    [InlineData("WARNING", BuildAnalyzerResultSeverity.Warning)]
+    public void CreateBuildAnalyzerConfiguration_Severity(string parameter, BuildAnalyzerResultSeverity? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "severity" , parameter },
+        };
+        var buildConfig = BuildAnalyzerConfiguration.Create(config);
+
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBe(expected);
+
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("true", true)]
+    [InlineData("TRUE", true)]
+    [InlineData("false", false)]
+    [InlineData("FALSE", false)]
+    public void CreateBuildAnalyzerConfiguration_IsEnabled(string parameter, bool? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "isenabled" , parameter },
+        };
+
+        var buildConfig = BuildAnalyzerConfiguration.Create(config);
+
+        buildConfig.ShouldNotBeNull();
+        buildConfig.IsEnabled.ShouldBe(expected);
+
+        buildConfig.Severity.ShouldBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("ProjectOnly", EvaluationAnalysisScope.ProjectOnly)]
+    [InlineData("ProjectWithImportsFromCurrentWorkTree", EvaluationAnalysisScope.ProjectWithImportsFromCurrentWorkTree)]
+    [InlineData("ProjectWithImportsWithoutSdks", EvaluationAnalysisScope.ProjectWithImportsWithoutSdks)]
+    [InlineData("ProjectWithAllImports", EvaluationAnalysisScope.ProjectWithAllImports)]
+    [InlineData("projectwithallimports", EvaluationAnalysisScope.ProjectWithAllImports)]
+    public void CreateBuildAnalyzerConfiguration_EvaluationAnalysisScope(string parameter, EvaluationAnalysisScope? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "evaluationanalysisscope" , parameter },
+        };
+
+        var buildConfig = BuildAnalyzerConfiguration.Create(config);
+
+        buildConfig.ShouldNotBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBe(expected);
+
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.Severity.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("evaluationanalysisscope", "incorrec-value")]
+    [InlineData("isenabled", "incorrec-value")]
+    [InlineData("severity", "incorrec-value")]
+    public void CreateBuildAnalyzerConfiguration_ExceptionOnInvalidInputValue(string key, string value)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { key , value },
+        };
+
+        var exception = Should.Throw<BuildCheckConfigurationException>(() => {
+            BuildAnalyzerConfiguration.Create(config);
+        });
+        exception.Message.ShouldContain($"Incorrect value provided in config for key {key}");
+    }
+}
diff --git a/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
new file mode 100644
index 00000000000..d559e1724b1
--- /dev/null
+++ b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
@@ -0,0 +1,221 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class ConfigurationProvider_Tests
+{
+    [Fact]
+    public void GetRuleIdConfiguration_ReturnsEmptyConfig()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        test_key=test_value_updated
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        var configs = configurationProvider.GetConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        // empty
+        configs.ShouldBe(new Dictionary<string, string>());
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_ReturnsConfiguration()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        var configs = configurationProvider.GetConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        configs.Keys.Count.ShouldBe(2);
+
+        configs.ContainsKey("property1").ShouldBeTrue();
+        configs.ContainsKey("property2").ShouldBeTrue();
+
+        configs["property2"].ShouldBe("value2");
+        configs["property1"].ShouldBe("value1");
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_CustomConfigurationData()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=true
+        any_other_key1=any_other_value1
+        any_other_key2=any_other_value2
+        any_other_key3=any_other_value3
+        any_other_key3=any_other_value3
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        var customConfiguration = configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+        var configs = customConfiguration.ConfigurationData;
+
+        configs!.Keys.Count().ShouldBe(3);
+
+        configs.ContainsKey("property1").ShouldBeTrue();
+        configs.ContainsKey("property2").ShouldBeTrue();
+        configs.ContainsKey("isenabled2").ShouldBeTrue();
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_ReturnsBuildRuleConfiguration()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.Severity=Error
+        build_check.rule_id.EvaluationAnalysisScope=ProjectOnly
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        var buildConfig = configurationProvider.GetUserConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        buildConfig.ShouldNotBeNull();
+
+        buildConfig.IsEnabled?.ShouldBeTrue();
+        buildConfig.Severity?.ShouldBe(BuildAnalyzerResultSeverity.Error);
+        buildConfig.EvaluationAnalysisScope?.ShouldBe(EvaluationAnalysisScope.ProjectOnly);
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_CustomConfigurationValidity_NotValid_DifferentValues()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=true
+
+        [test123.csproj]
+        build_check.rule_id.property1=value2
+        build_check.rule_id.property2=value3
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=tru1
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        // should not fail => configurations are the same
+        Should.Throw<BuildCheckConfigurationException>(() =>
+        {
+            configurationProvider.CheckCustomConfigurationDataValidity(Path.Combine(workFolder1.Path, "test123.csproj"), "rule_id");
+        });
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_CustomConfigurationValidity_NotValid_DifferentKeys()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled2=true
+
+        [test123.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled2=true
+        build_check.rule_id.isEnabled3=true
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        // should not fail => configurations are the same
+        Should.Throw<BuildCheckConfigurationException>(() =>
+        {
+            configurationProvider.CheckCustomConfigurationDataValidity(Path.Combine(workFolder1.Path, "test123.csproj"), "rule_id");
+        });
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_CustomConfigurationValidity_Valid()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=true
+
+        [test123.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=true
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        // should fail, because the configs are the different
+        Should.NotThrow(() =>
+        {
+            configurationProvider.CheckCustomConfigurationDataValidity(Path.Combine(workFolder1.Path, "test123.csproj"), "rule_id");
+        });
+    }
+}
diff --git a/src/BuildCheck.UnitTests/CustomConfigurationData_Tests.cs b/src/BuildCheck.UnitTests/CustomConfigurationData_Tests.cs
new file mode 100644
index 00000000000..e8ff337e1a8
--- /dev/null
+++ b/src/BuildCheck.UnitTests/CustomConfigurationData_Tests.cs
@@ -0,0 +1,140 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class CustomConfigurationData_Tests
+{
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_NullInstance()
+    {
+        var customConfigurationData1 = CustomConfigurationData.Null;
+        var customConfigurationData2 = CustomConfigurationData.Null;
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_SameInstance()
+    {
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId");
+        var customConfigurationData2 = customConfigurationData1;
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeFalse_DifferentObjectType()
+    {
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId");
+        var customConfigurationData2 = new object();
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_DifferentInstanceSameValues()
+    {
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId");
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId");
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_CustomConfigDataSame()
+    {
+        var config1 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+
+        var config2 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeFalse_CustomConfigDataDifferent()
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId");
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeFalse_CustomConfigDataDifferentKeys()
+    {
+        var config1 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+
+        var config2 = new Dictionary<string, string>()
+        {
+            { "key2", "val2" }
+        };
+
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeFalse_CustomConfigDataDifferentValues()
+    {
+        var config1 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+
+        var config2 = new Dictionary<string, string>()
+        {
+            { "key1", "val2" }
+        };
+
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_CustomConfigDataKeysOrderDiffers()
+    {
+        var config1 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" },
+            { "key2", "val2" }
+        };
+
+        var config2 = new Dictionary<string, string>()
+        {
+            { "key2", "val2" },
+            { "key1", "val1" }
+        };
+
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+}
diff --git a/src/BuildCheck.UnitTests/EditorConfigParser_Tests.cs b/src/BuildCheck.UnitTests/EditorConfigParser_Tests.cs
new file mode 100644
index 00000000000..17bd60abbd1
--- /dev/null
+++ b/src/BuildCheck.UnitTests/EditorConfigParser_Tests.cs
@@ -0,0 +1,119 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class EditorConfigParser_Tests
+{
+    [Fact]
+    public void NoSectionConfigured_ResultsEmptyResultConfig()
+    {
+        var configs = new List<EditorConfigFile>(){
+            EditorConfigFile.Parse(""""
+                    property1=value1
+""""),
+            EditorConfigFile.Parse(""""
+                property1=value2
+                """"),
+            EditorConfigFile.Parse(""""
+                property1=value3
+                """"),
+        };
+
+        var parser = new EditorConfigParser();
+        var mergedResult = parser.MergeEditorConfigFiles(configs, "/some/path/to/file");
+        mergedResult.Keys.Count.ShouldBe(0);
+    }
+
+    [Fact]
+    public void ProperOrderOfconfiguration_ClosestToTheFileShouldBeApplied()
+    {
+        var configs = new List<EditorConfigFile>(){
+            EditorConfigFile.Parse(""""
+                    [*]
+                    property1=value1
+""""),
+            EditorConfigFile.Parse(""""
+                [*]
+                property1=value2
+                """"),
+            EditorConfigFile.Parse(""""
+                [*]
+                property1=value3
+                """"),
+        };
+
+        var parser = new EditorConfigParser();
+        var mergedResult = parser.MergeEditorConfigFiles(configs, "/some/path/to/file.proj");
+        mergedResult.Keys.Count.ShouldBe(1);
+        mergedResult["property1"].ShouldBe("value1");
+    }
+
+    [Fact]
+    public void EditorconfigFileDiscovery_RootTrue()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFolder workFolder2 = testEnvironment.CreateFolder(Path.Combine(workFolder1.Path, "subfolder"), createFolder: true);
+
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder2, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        test_key=test_value_updated
+        """);
+
+
+        TransientTestFile config2 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        [*.csproj]
+        test_key=should_not_be_respected_and_parsed
+        """);
+
+        var parser = new EditorConfigParser();
+        var listOfEditorConfigFile = parser.DiscoverEditorConfigFiles(Path.Combine(workFolder1.Path, "subfolder", "projectfile.proj") ).ToList();
+        // should be one because root=true so we do not need to go further
+        listOfEditorConfigFile.Count.ShouldBe(1);
+        listOfEditorConfigFile[0].IsRoot.ShouldBeTrue();
+        listOfEditorConfigFile[0].NamedSections[0].Name.ShouldBe("*.csproj");
+        listOfEditorConfigFile[0].NamedSections[0].Properties["test_key"].ShouldBe("test_value_updated");
+    }
+
+    [Fact]
+    public void EditorconfigFileDiscovery_RootFalse()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFolder workFolder2 = testEnvironment.CreateFolder(Path.Combine(workFolder1.Path, "subfolder"), createFolder: true);
+
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder2, ".editorconfig",
+        """
+        [*.csproj]
+        test_key=test_value_updated
+        """);
+
+        TransientTestFile config2 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        [*.csproj]
+        test_key=will_be_there
+        """);
+
+        var parser = new EditorConfigParser();
+        var listOfEditorConfigFile = parser.DiscoverEditorConfigFiles(Path.Combine(workFolder1.Path, "subfolder", "projectfile.proj")).ToList();
+
+        listOfEditorConfigFile.Count.ShouldBe(2);
+        listOfEditorConfigFile[0].IsRoot.ShouldBeFalse();
+        listOfEditorConfigFile[0].NamedSections[0].Name.ShouldBe("*.csproj");
+    }
+}
diff --git a/src/BuildCheck.UnitTests/EditorConfig_Tests.cs b/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
new file mode 100644
index 00000000000..1b1b0c5aaa4
--- /dev/null
+++ b/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
@@ -0,0 +1,1078 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Reflection;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
+using Xunit;
+using static Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;
+
+#nullable disable
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class EditorConfig_Tests
+{
+
+    #region AssertEqualityComparer<T>
+    private sealed class AssertEqualityComparer<T> : IEqualityComparer<T>
+    {
+        public static readonly IEqualityComparer<T> Instance = new AssertEqualityComparer<T>();
+
+        private static bool CanBeNull()
+        {
+            var type = typeof(T);
+            return !type.GetTypeInfo().IsValueType ||
+                (type.GetTypeInfo().IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>));
+        }
+
+        public static bool IsNull(T @object)
+        {
+            if (!CanBeNull())
+            {
+                return false;
+            }
+
+            return object.Equals(@object, default(T));
+        }
+
+        public static bool Equals(T left, T right)
+        {
+            return Instance.Equals(left, right);
+        }
+
+        bool IEqualityComparer<T>.Equals(T x, T y)
+        {
+            if (CanBeNull())
+            {
+                if (object.Equals(x, default(T)))
+                {
+                    return object.Equals(y, default(T));
+                }
+
+                if (object.Equals(y, default(T)))
+                {
+                    return false;
+                }
+            }
+
+            if (x.GetType() != y.GetType())
+            {
+                return false;
+            }
+
+            if (x is IEquatable<T> equatable)
+            {
+                return equatable.Equals(y);
+            }
+
+            if (x is IComparable<T> comparableT)
+            {
+                return comparableT.CompareTo(y) == 0;
+            }
+
+            if (x is IComparable comparable)
+            {
+                return comparable.CompareTo(y) == 0;
+            }
+
+            var enumerableX = x as IEnumerable;
+            var enumerableY = y as IEnumerable;
+
+            if (enumerableX != null && enumerableY != null)
+            {
+                var enumeratorX = enumerableX.GetEnumerator();
+                var enumeratorY = enumerableY.GetEnumerator();
+
+                while (true)
+                {
+                    bool hasNextX = enumeratorX.MoveNext();
+                    bool hasNextY = enumeratorY.MoveNext();
+
+                    if (!hasNextX || !hasNextY)
+                    {
+                        return hasNextX == hasNextY;
+                    }
+
+                    if (!Equals(enumeratorX.Current, enumeratorY.Current))
+                    {
+                        return false;
+                    }
+                }
+            }
+
+            return object.Equals(x, y);
+        }
+
+        int IEqualityComparer<T>.GetHashCode(T obj)
+        {
+            throw new NotImplementedException();
+        }
+    }
+
+    #endregion
+
+    // Section Matchin Test cases: https://github.com/dotnet/roslyn/blob/ba163e712b01358a217065eec8a4a82f94a7efd5/src/Compilers/Core/CodeAnalysisTest/Analyzers/AnalyzerConfigTests.cs#L337
+    #region Section Matching Tests
+    [Fact]
+    public void SimpleNameMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("abc").Value;
+        Assert.Equal("^.*/abc$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc"));
+        Assert.False(matcher.IsMatch("/aabc"));
+        Assert.False(matcher.IsMatch("/ abc"));
+        Assert.False(matcher.IsMatch("/cabc"));
+    }
+
+    [Fact]
+    public void StarOnlyMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("*").Value;
+        Assert.Equal("^.*/[^/]*$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc"));
+        Assert.True(matcher.IsMatch("/123"));
+        Assert.True(matcher.IsMatch("/abc/123"));
+    }
+
+    [Fact]
+    public void StarNameMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("*.cs").Value;
+        Assert.Equal("^.*/[^/]*\\.cs$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/123.cs"));
+        Assert.True(matcher.IsMatch("/dir/subpath.cs"));
+        // Only '/' is defined as a directory separator, so the caller
+        // is responsible for converting any other machine directory
+        // separators to '/' before matching
+        Assert.True(matcher.IsMatch("/dir\\subpath.cs"));
+
+        Assert.False(matcher.IsMatch("/abc.vb"));
+    }
+
+    [Fact]
+    public void StarStarNameMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("**.cs").Value;
+        Assert.Equal("^.*/.*\\.cs$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/dir/subpath.cs"));
+    }
+
+    [Fact]
+    public void EscapeDot()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("...").Value;
+        Assert.Equal("^.*/\\.\\.\\.$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/..."));
+        Assert.True(matcher.IsMatch("/subdir/..."));
+        Assert.False(matcher.IsMatch("/aaa"));
+        Assert.False(matcher.IsMatch("/???"));
+        Assert.False(matcher.IsMatch("/abc"));
+    }
+
+    [Fact]
+    public void EndBackslashMatch()
+    {
+        SectionNameMatcher? matcher = TryCreateSectionNameMatcher("abc\\");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void QuestionMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab?def").Value;
+        Assert.Equal("^.*/ab.def$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abcdef"));
+        Assert.True(matcher.IsMatch("/ab?def"));
+        Assert.True(matcher.IsMatch("/abzdef"));
+        Assert.True(matcher.IsMatch("/ab/def"));
+        Assert.True(matcher.IsMatch("/ab\\def"));
+    }
+
+    [Fact]
+    public void LiteralBackslash()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab\\\\c").Value;
+        Assert.Equal("^.*/ab\\\\c$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/ab\\c"));
+        Assert.False(matcher.IsMatch("/ab/c"));
+        Assert.False(matcher.IsMatch("/ab\\\\c"));
+    }
+
+    [Fact]
+    public void LiteralStars()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("\\***\\*\\**").Value;
+        Assert.Equal("^.*/\\*.*\\*\\*[^/]*$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/*ab/cd**efg*"));
+        Assert.False(matcher.IsMatch("/ab/cd**efg*"));
+        Assert.False(matcher.IsMatch("/*ab/cd*efg*"));
+        Assert.False(matcher.IsMatch("/*ab/cd**ef/gh"));
+    }
+
+    [Fact]
+    public void LiteralQuestions()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("\\??\\?*\\??").Value;
+        Assert.Equal("^.*/\\?.\\?[^/]*\\?.$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/?a?cde?f"));
+        Assert.True(matcher.IsMatch("/???????f"));
+        Assert.False(matcher.IsMatch("/aaaaaaaa"));
+        Assert.False(matcher.IsMatch("/aa?cde?f"));
+        Assert.False(matcher.IsMatch("/?a?cdexf"));
+        Assert.False(matcher.IsMatch("/?axcde?f"));
+    }
+
+    [Fact]
+    public void LiteralBraces()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("abc\\{\\}def").Value;
+        Assert.Equal(@"^.*/abc\{}def$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc{}def"));
+        Assert.True(matcher.IsMatch("/subdir/abc{}def"));
+        Assert.False(matcher.IsMatch("/abcdef"));
+        Assert.False(matcher.IsMatch("/abc}{def"));
+    }
+
+    [Fact]
+    public void LiteralComma()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("abc\\,def").Value;
+        Assert.Equal("^.*/abc,def$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc,def"));
+        Assert.True(matcher.IsMatch("/subdir/abc,def"));
+        Assert.False(matcher.IsMatch("/abcdef"));
+        Assert.False(matcher.IsMatch("/abc\\,def"));
+        Assert.False(matcher.IsMatch("/abc`def"));
+    }
+
+    [Fact]
+    public void SimpleChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("*.{cs,vb,fs}").Value;
+        Assert.Equal("^.*/[^/]*\\.(?:cs|vb|fs)$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/abc.vb"));
+        Assert.True(matcher.IsMatch("/abc.fs"));
+        Assert.True(matcher.IsMatch("/subdir/abc.cs"));
+        Assert.True(matcher.IsMatch("/subdir/abc.vb"));
+        Assert.True(matcher.IsMatch("/subdir/abc.fs"));
+
+        Assert.False(matcher.IsMatch("/abcxcs"));
+        Assert.False(matcher.IsMatch("/abcxvb"));
+        Assert.False(matcher.IsMatch("/abcxfs"));
+        Assert.False(matcher.IsMatch("/subdir/abcxcs"));
+        Assert.False(matcher.IsMatch("/subdir/abcxcb"));
+        Assert.False(matcher.IsMatch("/subdir/abcxcs"));
+    }
+
+    [Fact]
+    public void OneChoiceHasSlashes()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("{*.cs,subdir/test.vb}").Value;
+        // This is an interesting case that may be counterintuitive.  A reasonable understanding
+        // of the section matching could interpret the choice as generating multiple identical
+        // sections, so [{a, b, c}] would be equivalent to [a] ... [b] ... [c] with all of the
+        // same properties in each section. This is somewhat true, but the rules of how the matching
+        // prefixes are constructed violate this assumption because they are defined as whether or
+        // not a section contains a slash, not whether any of the choices contain a slash. So while
+        // [*.cs] usually translates into '**/*.cs' because it contains no slashes, the slashes in
+        // the second choice make this into '/*.cs', effectively matching only files in the root
+        // directory of the match, instead of all subdirectories.
+        Assert.Equal("^/(?:[^/]*\\.cs|subdir/test\\.vb)$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/test.cs"));
+        Assert.True(matcher.IsMatch("/subdir/test.vb"));
+
+        Assert.False(matcher.IsMatch("/subdir/test.cs"));
+        Assert.False(matcher.IsMatch("/subdir/subdir/test.vb"));
+        Assert.False(matcher.IsMatch("/test.vb"));
+    }
+
+    [Fact]
+    public void EmptyChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("{}").Value;
+        Assert.Equal("^.*/(?:)$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/"));
+        Assert.True(matcher.IsMatch("/subdir/"));
+        Assert.False(matcher.IsMatch("/."));
+        Assert.False(matcher.IsMatch("/anything"));
+    }
+
+    [Fact]
+    public void SingleChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("{*.cs}").Value;
+        Assert.Equal("^.*/(?:[^/]*\\.cs)$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/test.cs"));
+        Assert.True(matcher.IsMatch("/subdir/test.cs"));
+        Assert.False(matcher.IsMatch("test.vb"));
+        Assert.False(matcher.IsMatch("testxcs"));
+    }
+
+    [Fact]
+    public void UnmatchedBraces()
+    {
+        SectionNameMatcher? matcher = TryCreateSectionNameMatcher("{{{{}}");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void CommaOutsideBraces()
+    {
+        SectionNameMatcher? matcher = TryCreateSectionNameMatcher("abc,def");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void RecursiveChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("{test{.cs,.vb},other.{a{bb,cc}}}").Value;
+        Assert.Equal("^.*/(?:test(?:\\.cs|\\.vb)|other\\.(?:a(?:bb|cc)))$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/test.cs"));
+        Assert.True(matcher.IsMatch("/test.vb"));
+        Assert.True(matcher.IsMatch("/subdir/test.cs"));
+        Assert.True(matcher.IsMatch("/subdir/test.vb"));
+        Assert.True(matcher.IsMatch("/other.abb"));
+        Assert.True(matcher.IsMatch("/other.acc"));
+
+        Assert.False(matcher.IsMatch("/test.fs"));
+        Assert.False(matcher.IsMatch("/other.bbb"));
+        Assert.False(matcher.IsMatch("/other.ccc"));
+        Assert.False(matcher.IsMatch("/subdir/other.bbb"));
+        Assert.False(matcher.IsMatch("/subdir/other.ccc"));
+    }
+
+    [Fact]
+    public void DashChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab{-}cd{-,}ef").Value;
+        Assert.Equal("^.*/ab(?:-)cd(?:-|)ef$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/ab-cd-ef"));
+        Assert.True(matcher.IsMatch("/ab-cdef"));
+
+        Assert.False(matcher.IsMatch("/abcdef"));
+        Assert.False(matcher.IsMatch("/ab--cd-ef"));
+        Assert.False(matcher.IsMatch("/ab--cd--ef"));
+    }
+
+    [Fact]
+    public void MiddleMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab{cs,vb,fs}cd").Value;
+        Assert.Equal("^.*/ab(?:cs|vb|fs)cd$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abcscd"));
+        Assert.True(matcher.IsMatch("/abvbcd"));
+        Assert.True(matcher.IsMatch("/abfscd"));
+
+        Assert.False(matcher.IsMatch("/abcs"));
+        Assert.False(matcher.IsMatch("/abcd"));
+        Assert.False(matcher.IsMatch("/vbcd"));
+    }
+
+    private static IEnumerable<(string, string)> RangeAndInverse(string s1, string s2)
+    {
+        yield return (s1, s2);
+        yield return (s2, s1);
+    }
+
+    [Fact]
+    public void NumberMatch()
+    {
+        foreach (var (i1, i2) in RangeAndInverse("0", "10"))
+        {
+            var matcher = TryCreateSectionNameMatcher($"{{{i1}..{i2}}}").Value;
+
+            Assert.True(matcher.IsMatch("/0"));
+            Assert.True(matcher.IsMatch("/10"));
+            Assert.True(matcher.IsMatch("/5"));
+            Assert.True(matcher.IsMatch("/000005"));
+            Assert.False(matcher.IsMatch("/-1"));
+            Assert.False(matcher.IsMatch("/-00000001"));
+            Assert.False(matcher.IsMatch("/11"));
+        }
+    }
+
+    [Fact]
+    public void NumberMatchNegativeRange()
+    {
+        foreach (var (i1, i2) in RangeAndInverse("-10", "0"))
+        {
+            var matcher = TryCreateSectionNameMatcher($"{{{i1}..{i2}}}").Value;
+
+            Assert.True(matcher.IsMatch("/0"));
+            Assert.True(matcher.IsMatch("/-10"));
+            Assert.True(matcher.IsMatch("/-5"));
+            Assert.False(matcher.IsMatch("/1"));
+            Assert.False(matcher.IsMatch("/-11"));
+            Assert.False(matcher.IsMatch("/--0"));
+        }
+    }
+
+    [Fact]
+    public void NumberMatchNegToPos()
+    {
+        foreach (var (i1, i2) in RangeAndInverse("-10", "10"))
+        {
+            var matcher = TryCreateSectionNameMatcher($"{{{i1}..{i2}}}").Value;
+
+            Assert.True(matcher.IsMatch("/0"));
+            Assert.True(matcher.IsMatch("/-5"));
+            Assert.True(matcher.IsMatch("/5"));
+            Assert.True(matcher.IsMatch("/-10"));
+            Assert.True(matcher.IsMatch("/10"));
+            Assert.False(matcher.IsMatch("/-11"));
+            Assert.False(matcher.IsMatch("/11"));
+            Assert.False(matcher.IsMatch("/--0"));
+        }
+    }
+
+    [Fact]
+    public void MultipleNumberRanges()
+    {
+        foreach (var matchString in new[] { "a{-10..0}b{0..10}", "a{0..-10}b{10..0}" })
+        {
+            var matcher = TryCreateSectionNameMatcher(matchString).Value;
+
+            Assert.True(matcher.IsMatch("/a0b0"));
+            Assert.True(matcher.IsMatch("/a-5b0"));
+            Assert.True(matcher.IsMatch("/a-5b5"));
+            Assert.True(matcher.IsMatch("/a-5b10"));
+            Assert.True(matcher.IsMatch("/a-10b10"));
+            Assert.True(matcher.IsMatch("/a-10b0"));
+            Assert.True(matcher.IsMatch("/a-0b0"));
+            Assert.True(matcher.IsMatch("/a-0b-0"));
+
+            Assert.False(matcher.IsMatch("/a-11b10"));
+            Assert.False(matcher.IsMatch("/a-11b10"));
+            Assert.False(matcher.IsMatch("/a-10b11"));
+        }
+    }
+
+    [Fact]
+    public void BadNumberRanges()
+    {
+        var matcherOpt = TryCreateSectionNameMatcher("{0..");
+
+        Assert.Null(matcherOpt);
+
+        var matcher = TryCreateSectionNameMatcher("{0..}").Value;
+
+        Assert.True(matcher.IsMatch("/0.."));
+        Assert.False(matcher.IsMatch("/0"));
+        Assert.False(matcher.IsMatch("/0."));
+        Assert.False(matcher.IsMatch("/0abc"));
+
+        matcher = TryCreateSectionNameMatcher("{0..A}").Value;
+        Assert.True(matcher.IsMatch("/0..A"));
+        Assert.False(matcher.IsMatch("/0"));
+        Assert.False(matcher.IsMatch("/0abc"));
+
+        // The reference implementation uses atoi here so we can presume
+        // numbers out of range of Int32 are not well supported
+        matcherOpt = TryCreateSectionNameMatcher($"{{0..{UInt32.MaxValue}}}");
+
+        Assert.Null(matcherOpt);
+    }
+
+    [Fact]
+    public void CharacterClassSimple()
+    {
+        var matcher = TryCreateSectionNameMatcher("*.[cf]s").Value;
+        Assert.Equal(@"^.*/[^/]*\.[cf]s$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/abc.fs"));
+        Assert.False(matcher.IsMatch("/abc.vs"));
+    }
+
+    [Fact]
+    public void CharacterClassNegative()
+    {
+        var matcher = TryCreateSectionNameMatcher("*.[!cf]s").Value;
+        Assert.Equal(@"^.*/[^/]*\.[^cf]s$", matcher.Regex.ToString());
+
+        Assert.False(matcher.IsMatch("/abc.cs"));
+        Assert.False(matcher.IsMatch("/abc.fs"));
+        Assert.True(matcher.IsMatch("/abc.vs"));
+        Assert.True(matcher.IsMatch("/abc.xs"));
+        Assert.False(matcher.IsMatch("/abc.vxs"));
+    }
+
+    [Fact]
+    public void CharacterClassCaret()
+    {
+        var matcher = TryCreateSectionNameMatcher("*.[^cf]s").Value;
+        Assert.Equal(@"^.*/[^/]*\.[\^cf]s$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/abc.fs"));
+        Assert.True(matcher.IsMatch("/abc.^s"));
+        Assert.False(matcher.IsMatch("/abc.vs"));
+        Assert.False(matcher.IsMatch("/abc.xs"));
+        Assert.False(matcher.IsMatch("/abc.vxs"));
+    }
+
+    [Fact]
+    public void CharacterClassRange()
+    {
+        var matcher = TryCreateSectionNameMatcher("[0-9]x").Value;
+        Assert.Equal("^.*/[0-9]x$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/0x"));
+        Assert.True(matcher.IsMatch("/1x"));
+        Assert.True(matcher.IsMatch("/9x"));
+        Assert.False(matcher.IsMatch("/yx"));
+        Assert.False(matcher.IsMatch("/00x"));
+    }
+
+    [Fact]
+    public void CharacterClassNegativeRange()
+    {
+        var matcher = TryCreateSectionNameMatcher("[!0-9]x").Value;
+        Assert.Equal("^.*/[^0-9]x$", matcher.Regex.ToString());
+
+        Assert.False(matcher.IsMatch("/0x"));
+        Assert.False(matcher.IsMatch("/1x"));
+        Assert.False(matcher.IsMatch("/9x"));
+        Assert.True(matcher.IsMatch("/yx"));
+        Assert.False(matcher.IsMatch("/00x"));
+    }
+
+    [Fact]
+    public void CharacterClassRangeAndChoice()
+    {
+        var matcher = TryCreateSectionNameMatcher("[ab0-9]x").Value;
+        Assert.Equal("^.*/[ab0-9]x$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/ax"));
+        Assert.True(matcher.IsMatch("/bx"));
+        Assert.True(matcher.IsMatch("/0x"));
+        Assert.True(matcher.IsMatch("/1x"));
+        Assert.True(matcher.IsMatch("/9x"));
+        Assert.False(matcher.IsMatch("/yx"));
+        Assert.False(matcher.IsMatch("/0ax"));
+    }
+
+    [Fact]
+    public void CharacterClassOpenEnded()
+    {
+        var matcher = TryCreateSectionNameMatcher("[");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void CharacterClassEscapedOpenEnded()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[\]");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void CharacterClassEscapeAtEnd()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[\");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void CharacterClassOpenBracketInside()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[[a]bc").Value;
+
+        Assert.True(matcher.IsMatch("/abc"));
+        Assert.True(matcher.IsMatch("/[bc"));
+        Assert.False(matcher.IsMatch("/ab"));
+        Assert.False(matcher.IsMatch("/[b"));
+        Assert.False(matcher.IsMatch("/bc"));
+        Assert.False(matcher.IsMatch("/ac"));
+        Assert.False(matcher.IsMatch("/[c"));
+
+        Assert.Equal(@"^.*/[\[a]bc$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void CharacterClassStartingDash()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[-ac]bd").Value;
+
+        Assert.True(matcher.IsMatch("/abd"));
+        Assert.True(matcher.IsMatch("/cbd"));
+        Assert.True(matcher.IsMatch("/-bd"));
+        Assert.False(matcher.IsMatch("/bbd"));
+        Assert.False(matcher.IsMatch("/-cd"));
+        Assert.False(matcher.IsMatch("/bcd"));
+
+        Assert.Equal(@"^.*/[-ac]bd$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void CharacterClassEndingDash()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[ac-]bd").Value;
+
+        Assert.True(matcher.IsMatch("/abd"));
+        Assert.True(matcher.IsMatch("/cbd"));
+        Assert.True(matcher.IsMatch("/-bd"));
+        Assert.False(matcher.IsMatch("/bbd"));
+        Assert.False(matcher.IsMatch("/-cd"));
+        Assert.False(matcher.IsMatch("/bcd"));
+
+        Assert.Equal(@"^.*/[ac-]bd$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void CharacterClassEndBracketAfter()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[ab]]cd").Value;
+
+        Assert.True(matcher.IsMatch("/a]cd"));
+        Assert.True(matcher.IsMatch("/b]cd"));
+        Assert.False(matcher.IsMatch("/acd"));
+        Assert.False(matcher.IsMatch("/bcd"));
+        Assert.False(matcher.IsMatch("/acd"));
+
+        Assert.Equal(@"^.*/[ab]]cd$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void CharacterClassEscapeBackslash()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[ab\\]cd").Value;
+
+        Assert.True(matcher.IsMatch("/acd"));
+        Assert.True(matcher.IsMatch("/bcd"));
+        Assert.True(matcher.IsMatch("/\\cd"));
+        Assert.False(matcher.IsMatch("/dcd"));
+        Assert.False(matcher.IsMatch("/\\\\cd"));
+        Assert.False(matcher.IsMatch("/cd"));
+
+        Assert.Equal(@"^.*/[ab\\]cd$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void EscapeOpenBracket()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"ab\[cd").Value;
+
+        Assert.True(matcher.IsMatch("/ab[cd"));
+        Assert.False(matcher.IsMatch("/ab[[cd"));
+        Assert.False(matcher.IsMatch("/abc"));
+        Assert.False(matcher.IsMatch("/abd"));
+
+        Assert.Equal(@"^.*/ab\[cd$", matcher.Regex.ToString());
+    }
+    #endregion
+
+    #region Parsing Tests
+
+    private static void SetEqual<T>(IEnumerable<T> expected, IEnumerable<T> actual, IEqualityComparer<T> comparer = null, string message = null)
+    {
+        var expectedSet = new HashSet<T>(expected, comparer);
+        var result = expected.Count() == actual.Count() && expectedSet.SetEquals(actual);
+        Assert.True(result, message);
+    }
+
+    private static void Equal<T>(
+        IEnumerable<T> expected,
+        IEnumerable<T> actual,
+        IEqualityComparer<T> comparer = null,
+        string message = null)
+    {
+        if (expected == null)
+        {
+            Assert.Null(actual);
+        }
+        else
+        {
+            Assert.NotNull(actual);
+        }
+
+        if (SequenceEqual(expected, actual, comparer))
+        {
+            return;
+        }
+
+        Assert.True(false, message);
+    }
+
+    private static bool SequenceEqual<T>(IEnumerable<T> expected, IEnumerable<T> actual, IEqualityComparer<T> comparer = null)
+    {
+        if (ReferenceEquals(expected, actual))
+        {
+            return true;
+        }
+
+        var enumerator1 = expected.GetEnumerator();
+        var enumerator2 = actual.GetEnumerator();
+
+        while (true)
+        {
+            var hasNext1 = enumerator1.MoveNext();
+            var hasNext2 = enumerator2.MoveNext();
+
+            if (hasNext1 != hasNext2)
+            {
+                return false;
+            }
+
+            if (!hasNext1)
+            {
+                break;
+            }
+
+            var value1 = enumerator1.Current;
+            var value2 = enumerator2.Current;
+
+            if (!(comparer != null ? comparer.Equals(value1, value2) : AssertEqualityComparer<T>.Equals(value1, value2)))
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public static KeyValuePair<K, V> Create<K, V>(K key, V value)
+    {
+        return new KeyValuePair<K, V>(key, value);
+    }
+
+    [Fact]
+    public void SimpleCase()
+    {
+        var config = EditorConfigFile.Parse("""
+root = true
+
+# Comment1
+# Comment2
+##################################
+
+my_global_prop = my_global_val
+
+[*.cs]
+my_prop = my_val
+""");
+        Assert.Equal("", config.GlobalSection.Name);
+        var properties = config.GlobalSection.Properties;
+
+        SetEqual(
+            new[] { Create("my_global_prop", "my_global_val") ,
+                    Create("root", "true") },
+            properties);
+
+        var namedSections = config.NamedSections;
+        Assert.Equal("*.cs", namedSections[0].Name);
+        SetEqual(
+            new[] { Create("my_prop", "my_val") },
+            namedSections[0].Properties);
+        
+        Assert.True(config.IsRoot);
+    }
+
+    
+    [Fact]
+    // [WorkItem(52469, "https://github.com/dotnet/roslyn/issues/52469")]
+    public void ConfigWithEscapedValues()
+    {
+        var config = EditorConfigFile.Parse(@"is_global = true
+
+[c:/\{f\*i\?le1\}.cs]
+build_metadata.Compile.ToRetrieve = abc123
+
+[c:/f\,ile\#2.cs]
+build_metadata.Compile.ToRetrieve = def456
+
+[c:/f\;i\!le\[3\].cs]
+build_metadata.Compile.ToRetrieve = ghi789
+");
+
+        var namedSections = config.NamedSections;
+        Assert.Equal("c:/\\{f\\*i\\?le1\\}.cs", namedSections[0].Name);
+        Equal(
+            new[] { Create("build_metadata.compile.toretrieve", "abc123") },
+            namedSections[0].Properties);
+
+        Assert.Equal("c:/f\\,ile\\#2.cs", namedSections[1].Name);
+        Equal(
+            new[] { Create("build_metadata.compile.toretrieve", "def456") },
+            namedSections[1].Properties);
+
+        Assert.Equal("c:/f\\;i\\!le\\[3\\].cs", namedSections[2].Name);
+        Equal(
+            new[] { Create("build_metadata.compile.toretrieve", "ghi789") },
+            namedSections[2].Properties);
+    }
+
+    /*
+    [Fact]
+    [WorkItem(52469, "https://github.com/dotnet/roslyn/issues/52469")]
+    public void CanGetSectionsWithSpecialCharacters()
+    {
+        var config = ParseConfigFile(@"is_global = true
+
+[/home/foo/src/\{releaseid\}.cs]
+build_metadata.Compile.ToRetrieve = abc123
+
+[/home/foo/src/Pages/\#foo/HomePage.cs]
+build_metadata.Compile.ToRetrieve = def456
+");
+
+        var set = AnalyzerConfigSet.Create(ImmutableArray.Create(config));
+
+        var sectionOptions = set.GetOptionsForSourcePath("/home/foo/src/{releaseid}.cs");
+        Assert.Equal("abc123", sectionOptions.AnalyzerOptions["build_metadata.compile.toretrieve"]);
+
+        sectionOptions = set.GetOptionsForSourcePath("/home/foo/src/Pages/#foo/HomePage.cs");
+        Assert.Equal("def456", sectionOptions.AnalyzerOptions["build_metadata.compile.toretrieve"]);
+    }*/
+
+    [Fact]
+    public void MissingClosingBracket()
+    {
+        var config = EditorConfigFile.Parse(@"
+[*.cs
+my_prop = my_val");
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop", "my_val") },
+            properties);
+
+        Assert.Equal(0, config.NamedSections.Length);
+    }
+
+    
+    [Fact]
+    public void EmptySection()
+    {
+        var config = EditorConfigFile.Parse(@"
+[]
+my_prop = my_val");
+
+        var properties = config.GlobalSection.Properties;
+        Assert.Equal(new[] { Create("my_prop", "my_val") }, properties);
+        Assert.Equal(0, config.NamedSections.Length);
+    }
+
+    
+    [Fact]
+    public void CaseInsensitivePropKey()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_PROP = my_VAL");
+        var properties = config.GlobalSection.Properties;
+
+        Assert.True(properties.TryGetValue("my_PrOp", out var val));
+        Assert.Equal("my_VAL", val);
+        Assert.Equal("my_prop", properties.Keys.Single());
+    }
+
+    // there is no reversed keys support for msbuild
+    /*[Fact]
+    public void NonReservedKeyPreservedCaseVal()
+    {
+        var config = ParseConfigFile(string.Join(Environment.NewLine,
+            AnalyzerConfig.ReservedKeys.Select(k => "MY_" + k + " = MY_VAL")));
+        AssertEx.SetEqual(
+            AnalyzerConfig.ReservedKeys.Select(k => KeyValuePair.Create("my_" + k, "MY_VAL")).ToList(),
+            config.GlobalSection.Properties);
+    }*/
+
+
+    [Fact]
+    public void DuplicateKeys()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_prop = my_val
+my_prop = my_other_val");
+
+        var properties = config.GlobalSection.Properties;
+        Assert.Equal(new[] { Create("my_prop", "my_other_val") }, properties);
+    }
+
+    
+    [Fact]
+    public void DuplicateKeysCasing()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_prop = my_val
+my_PROP = my_other_val");
+
+        var properties = config.GlobalSection.Properties;
+        Assert.Equal(new[] { Create("my_prop", "my_other_val") }, properties);
+    }
+
+    
+    [Fact]
+    public void MissingKey()
+    {
+        var config = EditorConfigFile.Parse(@"
+= my_val1
+my_prop = my_val2");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop", "my_val2") },
+            properties);
+    }
+
+    
+
+    [Fact]
+    public void MissingVal()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_prop1 =
+my_prop2 = my_val");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop1", ""),
+                    Create("my_prop2", "my_val") },
+            properties);
+    }
+
+    
+    [Fact]
+    public void SpacesInProperties()
+    {
+        var config = EditorConfigFile.Parse(@"
+my prop1 = my_val1
+my_prop2 = my val2");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop2", "my val2") },
+            properties);
+    }
+
+    
+    [Fact]
+    public void EndOfLineComments()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_prop2 = my val2 # Comment");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop2", "my val2") },
+            properties);
+    }
+    
+    [Fact]
+    public void SymbolsStartKeys()
+    {
+        var config = EditorConfigFile.Parse(@"
+@!$abc = my_val1
+@!$\# = my_val2");
+
+        var properties = config.GlobalSection.Properties;
+        Assert.Equal(0, properties.Count);
+    }
+
+    
+    [Fact]
+    public void EqualsAndColon()
+    {
+        var config = EditorConfigFile.Parse(@"
+my:key1 = my_val
+my_key2 = my:val");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my", "key1 = my_val"),
+                    Create("my_key2", "my:val")},
+            properties);
+    }
+    
+    [Fact]
+    public void SymbolsInProperties()
+    {
+        var config = EditorConfigFile.Parse(@"
+my@key1 = my_val
+my_key2 = my@val");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_key2", "my@val") },
+            properties);
+    }
+    
+    [Fact]
+    public void LongLines()
+    {
+        // This example is described in the Python ConfigParser as allowing
+        // line continuation via the RFC 822 specification, section 3.1.1
+        // LONG HEADER FIELDS. The VS parser does not accept this as a
+        // valid parse for an editorconfig file. We follow similarly.
+        var config = EditorConfigFile.Parse(@"
+long: this value continues
+   in the next line");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("long", "this value continues") },
+            properties);
+    }
+
+    
+    [Fact]
+    public void CaseInsensitiveRoot()
+    {
+        var config = EditorConfigFile.Parse(@"
+RoOt = TruE");
+        Assert.True(config.IsRoot);
+    }
+
+
+    /*
+    Reserved values are not supported at the moment
+    [Fact]
+    public void ReservedValues()
+    {
+        int index = 0;
+        var config = ParseConfigFile(string.Join(Environment.NewLine,
+            AnalyzerConfig.ReservedValues.Select(v => "MY_KEY" + (index++) + " = " + v.ToUpperInvariant())));
+        index = 0;
+        AssertEx.SetEqual(
+            AnalyzerConfig.ReservedValues.Select(v => KeyValuePair.Create("my_key" + (index++), v)).ToList(),
+            config.GlobalSection.Properties);
+    }
+    */
+
+    /*
+    [Fact]
+    public void ReservedKeys()
+    {
+        var config = ParseConfigFile(string.Join(Environment.NewLine,
+            AnalyzerConfig.ReservedKeys.Select(k => k + " = MY_VAL")));
+        AssertEx.SetEqual(
+            AnalyzerConfig.ReservedKeys.Select(k => KeyValuePair.Create(k, "my_val")).ToList(),
+            config.GlobalSection.Properties);
+    }
+    */
+    #endregion
+}
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
index 17c1d1764d9..47ef63417cb 100644
--- a/src/BuildCheck.UnitTests/EndToEndTests.cs
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -2,12 +2,11 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
 using System.IO;
 using System.Xml;
+using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.Shared;
-using Newtonsoft.Json.Linq;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
@@ -26,7 +25,9 @@ public EndToEndTests(ITestOutputHelper output)
         _env.WithEnvironmentInvariant();
     }
 
-    private static string TestAssetsRootPath { get; } = Path.Combine(Path.GetDirectoryName(typeof(EndToEndTests).Assembly.Location) ?? AppContext.BaseDirectory, "TestAssets");
+    private static string AssemblyLocation { get; } = Path.Combine(Path.GetDirectoryName(typeof(EndToEndTests).Assembly.Location) ?? AppContext.BaseDirectory);
+
+    private static string TestAssetsRootPath { get; } = Path.Combine(AssemblyLocation, "TestAssets");
 
     public void Dispose() => _env.Dispose();
 
@@ -63,7 +64,6 @@ public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode, bool ana
 
         string contents2 = $"""
             <Project Sdk="Microsoft.NET.Sdk">
-                               
                 <PropertyGroup>
                 <OutputType>Exe</OutputType>
                 <TargetFramework>net8.0</TargetFramework>
@@ -89,27 +89,20 @@ public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode, bool ana
         TransientTestFile projectFile = _env.CreateFile(workFolder, "FooBar.csproj", contents);
         TransientTestFile projectFile2 = _env.CreateFile(workFolder, "FooBar-Copy.csproj", contents2);
 
-        // var cache = new SimpleProjectRootElementCache();
-        // ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(projectFile.Path, /*unused*/null, /*unused*/null, cache, false /*Not explicitly loaded - unused*/);
-
-        TransientTestFile config = _env.CreateFile(workFolder, "editorconfig.json",
-            /*lang=json,strict*/
+        TransientTestFile config = _env.CreateFile(workFolder, ".editorconfig",
             """
-            {
-                "BC0101": {
-                    "IsEnabled": true,
-                    "Severity": "Error"
-                },
-                "COND0543": {
-                    "IsEnabled": false,
-                    "Severity": "Error",
-                    "EvaluationAnalysisScope": "AnalyzedProjectOnly",
-                    "CustomSwitch": "QWERTY"
-                },
-                "BLA": {
-                    "IsEnabled": false
-                }
-            }
+            root=true
+
+            [*.csproj]
+            build_check.BC0101.IsEnabled=true
+            build_check.BC0101.Severity=warning
+
+            build_check.COND0543.IsEnabled=false
+            build_check.COND0543.Severity=Error
+            build_check.COND0543.EvaluationAnalysisScope=AnalyzedProjectOnly
+            build_check.COND0543.CustomSwitch=QWERTY
+
+            build_check.BLA.IsEnabled=false
             """);
 
         // OSX links /var into /private, which makes Path.GetTempPath() return "/var..." but Directory.GetCurrentDirectory return "/private/var...".
@@ -136,53 +129,33 @@ public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode, bool ana
     }
 
     [Theory]
-    [InlineData(new[] { "CustomAnalyzer" }, "AnalysisCandidate", new[] { "CustomRule1", "CustomRule2" })]
-    [InlineData(new[] { "CustomAnalyzer", "CustomAnalyzer2" }, "AnalysisCandidateWithMultipleAnalyzersInjected", new[] { "CustomRule1", "CustomRule2", "CustomRule3" })]
-    public void CustomAnalyzerTest(string[] customAnalyzerNames, string analysisCandidate, string[] expectedRegisteredRules)
+    [InlineData("AnalysisCandidate", new[] { "CustomRule1", "CustomRule2" })]
+    [InlineData("AnalysisCandidateWithMultipleAnalyzersInjected", new[] { "CustomRule1", "CustomRule2", "CustomRule3" }, true)]
+    public void CustomAnalyzerTest(string analysisCandidate, string[] expectedRegisteredRules, bool expectedRejectedAnalyzers = false)
     {
         using (var env = TestEnvironment.Create())
         {
-            var candidatesNugetFullPaths = BuildAnalyzerRules(env, customAnalyzerNames);
-
-            candidatesNugetFullPaths.ShouldNotBeEmpty("Nuget package with custom analyzer was not generated or detected.");
-
             var analysisCandidatePath = Path.Combine(TestAssetsRootPath, analysisCandidate);
-            AddCustomDataSourceToNugetConfig(analysisCandidatePath, candidatesNugetFullPaths);
+            AddCustomDataSourceToNugetConfig(analysisCandidatePath);
 
             string projectAnalysisBuildLog = RunnerUtilities.ExecBootstrapedMSBuild(
                 $"{Path.Combine(analysisCandidatePath, $"{analysisCandidate}.csproj")} /m:1 -nr:False -restore /p:OutputPath={env.CreateFolder().Path} -analyze -verbosity:n",
                 out bool successBuild);
-            successBuild.ShouldBeTrue();
+            successBuild.ShouldBeTrue(projectAnalysisBuildLog);
 
-            foreach (string expectedRegisteredRule in expectedRegisteredRules)
+            foreach (string registeredRule in expectedRegisteredRules)
             {
-                projectAnalysisBuildLog.ShouldContain($"Custom analyzer rule: {expectedRegisteredRule} has been registered successfully.");
+                projectAnalysisBuildLog.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CustomAnalyzerSuccessfulAcquisition", registeredRule));
             }
-        }
-    }
 
-    private IList<string> BuildAnalyzerRules(TestEnvironment env, string[] customAnalyzerNames)
-    {
-        var candidatesNugetFullPaths = new List<string>();
-
-        foreach (var customAnalyzerName in customAnalyzerNames)
-        {
-            var candidateAnalysisProjectPath = Path.Combine(TestAssetsRootPath, customAnalyzerName, $"{customAnalyzerName}.csproj");
-            var nugetPackResults = RunnerUtilities.ExecBootstrapedMSBuild(
-                 $"{candidateAnalysisProjectPath} /m:1 -nr:False -restore /p:OutputPath={env.CreateFolder().Path} -getTargetResult:Build", out bool success, attachProcessId: false);
-
-            success.ShouldBeTrue();
-
-            string? candidatesNugetPackageFullPath = (string?)(JObject.Parse(nugetPackResults)?["TargetResults"]?["Build"]?["Items"]?[0]?["RelativeDir"] ?? string.Empty);
-
-            candidatesNugetPackageFullPath.ShouldNotBeNull();
-            candidatesNugetFullPaths.Add(candidatesNugetPackageFullPath);
+            if (expectedRejectedAnalyzers)
+            {
+                projectAnalysisBuildLog.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CustomAnalyzerBaseTypeNotAssignable", "InvalidAnalyzer", "InvalidCustomAnalyzer, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"));
+            }
         }
-
-        return candidatesNugetFullPaths;
     }
 
-    private void AddCustomDataSourceToNugetConfig(string analysisCandidatePath, IList<string> candidatesNugetPackageFullPaths)
+    private void AddCustomDataSourceToNugetConfig(string analysisCandidatePath)
     {
         var nugetTemplatePath = Path.Combine(analysisCandidatePath, "nugetTemplate.config");
 
@@ -191,10 +164,10 @@ private void AddCustomDataSourceToNugetConfig(string analysisCandidatePath, ILis
         if (doc.DocumentElement != null)
         {
             XmlNode? packageSourcesNode = doc.SelectSingleNode("//packageSources");
-            for (int i = 0; i < candidatesNugetPackageFullPaths.Count; i++)
-            {
-                AddPackageSource(doc, packageSourcesNode, $"Key{i}", Path.GetDirectoryName(candidatesNugetPackageFullPaths[i]) ?? string.Empty);
-            }
+
+            // The test packages are generated during the test project build and saved in CustomAnalyzers folder.
+            string analyzersPackagesPath = Path.Combine(Directory.GetParent(AssemblyLocation)?.Parent?.FullName ?? string.Empty, "CustomAnalyzers");
+            AddPackageSource(doc, packageSourcesNode, "Key", analyzersPackagesPath);
 
             doc.Save(Path.Combine(analysisCandidatePath, "nuget.config"));
         }
diff --git a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
index 9a500f371df..6a72903b8e6 100644
--- a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
+++ b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
@@ -15,6 +15,12 @@
     <ProjectReference Include="..\UnitTests.Shared\Microsoft.Build.UnitTests.Shared.csproj" />
     <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
   </ItemGroup>
+  
+  <ItemGroup Label="TestAssests">
+    <ProjectReference Include=".\TestAssets\CustomAnalyzer\CustomAnalyzer.csproj" />
+    <ProjectReference Include=".\TestAssets\CustomAnalyzer2\CustomAnalyzer2.csproj" />
+    <ProjectReference Include=".\TestAssets\InvalidCustomAnalyzer\InvalidCustomAnalyzer.csproj" />
+  </ItemGroup>
 
   <ItemGroup>
     <PackageReference Include="System.Collections.Immutable" />
diff --git a/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs b/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
index 05d1266d2ac..7734c19f311 100644
--- a/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
+++ b/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
@@ -1,12 +1,8 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.UnitTests;
diff --git a/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs b/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
index bd93ddcf927..67d7cf784ef 100644
--- a/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
+++ b/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
@@ -114,15 +114,17 @@ public void ReportsSimpleTaskParameters()
             data.Parameters["Text"].Value.ShouldBe("Hello");
         }
 
-        [Fact]
-        public void ReportsComplexTaskParameters()
+        [Theory]
+        [InlineData("<Output TaskParameter='CombinedPaths' ItemName='OutputDirectories' />")]
+        [InlineData("<Output TaskParameter='CombinedPaths' PropertyName='OutputDirectories' />")]
+        public void ReportsComplexTaskParameters(string outputElement)
         {
-            BuildProject("""
+            BuildProject($"""
                 <ItemGroup>
                   <TestItem Include='item1;item2'/>
                 </ItemGroup>
                 <CombinePath BasePath='base' Paths='@(TestItem)'>
-                    <Output TaskParameter='CombinedPaths' ItemName='OutputDirectories' />
+                    {outputElement}
                 </CombinePath>
             """);
 
@@ -139,9 +141,8 @@ public void ReportsComplexTaskParameters()
             listValue[1]!.ShouldBeAssignableTo(typeof(ITaskItem));
             ((ITaskItem)listValue[0]!).ItemSpec.ShouldBe("item1");
             ((ITaskItem)listValue[1]!).ItemSpec.ShouldBe("item2");
-
-            // The name of the parameter would ideally be "CombinedPaths" but we don't seem to be currently logging it.
-            data.Parameters["OutputDirectories"].IsOutput.ShouldBe(true);
+            data.Parameters["CombinedPaths"].IsOutput.ShouldBe(true);
+            data.Parameters["CombinedPaths"].Value.ShouldNotBeNull();
         }
     }
 }
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/nugetTemplate.config b/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/nugetTemplate.config
index 1097d29bafd..aa5beec8aa0 100644
--- a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/nugetTemplate.config
+++ b/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/nugetTemplate.config
@@ -1,6 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
 <configuration>
-   <packageSources>
-
+  <packageSources>
   </packageSources>
 </configuration>
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/AnalysisCandidateWithMultipleAnalyzersInjected.csproj b/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/AnalysisCandidateWithMultipleAnalyzersInjected.csproj
index 9e71d7ff38f..0ffaa8d26b7 100644
--- a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/AnalysisCandidateWithMultipleAnalyzersInjected.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/AnalysisCandidateWithMultipleAnalyzersInjected.csproj
@@ -8,6 +8,7 @@
   <ItemGroup>
     <PackageReference Include="CustomAnalyzer" Version="1.0.0"/>
     <PackageReference Include="CustomAnalyzer2" Version="1.0.0"/>
+    <PackageReference Include="InvalidCustomAnalyzer" Version="1.0.0"/>
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/nugetTemplate.config b/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/nugetTemplate.config
index 1097d29bafd..1c0c23b1405 100644
--- a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/nugetTemplate.config
+++ b/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/nugetTemplate.config
@@ -1,6 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
 <configuration>
    <packageSources>
-
   </packageSources>
 </configuration>
diff --git a/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props b/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props
new file mode 100644
index 00000000000..4e4cb1c0796
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props
@@ -0,0 +1,17 @@
+<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+
+  <!-- The properties need to be redefined to have a nuget package built as a part of MSBuild build. -->
+  <PropertyGroup>
+    <IsPackable>true</IsPackable>
+    <IsShipping>false</IsShipping>
+    <PackageVersion>1.0.0</PackageVersion>
+    <ArtifactsNonShippingPackagesDir>$(ArtifactsBinDir)Microsoft.Build.BuildCheck.UnitTests\CustomAnalyzers</ArtifactsNonShippingPackagesDir>
+    <NoWarn>NU5101;NU5128;MSB3277;NU1507;NU1701;NU1702;NU5104</NoWarn>
+  </PropertyGroup>
+
+  <!-- In the real world scenario, the dependencies are added as Nuget PackageReference, modified for test purposes only. -->
+  <ItemGroup>
+    <ProjectReference Include="..\..\..\Build\Microsoft.Build.csproj" IncludeInPackage="true" />
+  </ItemGroup>
+
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.targets b/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.targets
new file mode 100644
index 00000000000..a1ea76b439e
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.targets
@@ -0,0 +1,41 @@
+<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+
+  <Target Name="AddNuGetDlls" BeforeTargets="_GetPackageFiles">
+    <!-- Resolve the project references to get their output DLL paths -->
+    <ItemGroup>
+      <ResolvedProjectReference Include="@(ReferencePath)" Condition="%(ReferencePath.ReferenceSourceTarget) == 'ProjectReference'">
+        <OutputPath>%(ReferencePath.OriginalItemSpec)</OutputPath>
+      </ResolvedProjectReference>
+
+      <!-- Add the DLL produced by the referenced project to the _PackagesToPack list -->
+      <_PackagesToPack Include="@(ResolvedProjectReference->'%(OutputPath)')">
+          <NuGetPackageId>@(ResolvedProjectReference->'%(AssemblyName)')</NuGetPackageId>
+      </_PackagesToPack>
+    </ItemGroup>
+    
+    <!-- Merge the collection of PackageReference and Assemblies using the NuGetPackageId key.
+       This produces a new list containing the DLL path and the "IncludeInPackage" metadata-->
+    <JoinItems Left="@(ResolvedCompileFileDefinitions)" LeftKey="NuGetPackageId" LeftMetadata="*" Right="@(ProjectReference)" RightKey="" RightMetadata="*" ItemSpecToUse="Left">
+      <Output TaskParameter="JoinResult" ItemName="_PackagesToPack" />
+    </JoinItems>
+
+    <ItemGroup>
+      <Message Importance="High" Text="Adding DLLs from the following packages: @(_PackagesToPack->'%(NuGetPackageId)')" />
+
+      <!-- Remove NETStandard DLLs -->
+      <_PackagesToPack Remove="@(_PackagesToPack)" Condition="%(NuGetPackageId) == 'NETStandard.Library'" />
+      <_PackagesToPack Remove="@(_PackagesToPack)" Condition="%(_PackagesToPack.IncludeInPackage) != 'true'" />
+    </ItemGroup>
+
+    <Message Importance="High" Text="Adding DLLs from the following packages: @(ResolvedProjectReferences->'%(OutputPath)%(AssemblyName).dll')" />
+
+    <ItemGroup>
+      <!-- Update the collection of items to pack with the DLLs from the NuGet packages -->
+      <None Include="@(_PackagesToPack)" Pack="true" PackagePath="build" Visible="false" />
+
+      <!-- Add the DLL produced by the current project to the NuGet package -->
+      <None Include="$(OutputPath)\$(AssemblyName).dll" Pack="true" PackagePath="build" Visible="false" />
+    </ItemGroup>
+  </Target>
+
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.csproj b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.csproj
index f780e9eb213..f27ab620690 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.csproj
@@ -1,29 +1,17 @@
 <Project Sdk="Microsoft.NET.Sdk">
 
+  <Import Project="..\Common\CommonTest.props" />
+
   <PropertyGroup>
     <TargetFramework>netstandard2.0</TargetFramework>
-    <GeneratePackageOnBuild>True</GeneratePackageOnBuild>
-    <IncludeBuildOutput>false</IncludeBuildOutput>
-    <!-- The output structure was modified for msbuild development needs.-->
-    <NoWarn>NU5101;NU5128;MSB3277</NoWarn>
+    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
   </PropertyGroup>
 
   <ItemGroup>
     <None Include="CustomAnalyzer.props" Pack="true" PackagePath="build\CustomAnalyzer.props" />
+    <Content Include="README.md" />
   </ItemGroup>
 
-  <ItemGroup>
-    <!-- In the real world scenario, the DLLs are added as PackageReference, modified for test purposes only. -->
-    <Reference Include="Microsoft.Build">
-      <HintPath>$(MSBuildProjectDirectory)\..\..\Microsoft.Build.dll</HintPath>
-    </Reference>
-  </ItemGroup>
-
-  <Target Name="AddNuGetDlls" BeforeTargets="_GetPackageFiles">
-    <ItemGroup>
-      <!-- Add the DLL produced by the current project to the NuGet package -->
-      <None Include="$(OutputPath)\$(AssemblyName).dll" Pack="true" PackagePath="build" Visible="false" />
-    </ItemGroup>
-  </Target>
+  <Import Project="..\Common\CommonTest.targets" />
 
 </Project>
diff --git a/template_feed/Microsoft.AnalyzerTemplate/README.md b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/README.md
similarity index 100%
rename from template_feed/Microsoft.AnalyzerTemplate/README.md
rename to src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/README.md
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.csproj b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.csproj
index 17007b03785..a405546f1cc 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.csproj
@@ -1,28 +1,17 @@
 <Project Sdk="Microsoft.NET.Sdk">
 
+  <Import Project="..\Common\CommonTest.props" />
+
   <PropertyGroup>
     <TargetFramework>netstandard2.0</TargetFramework>
-    <GeneratePackageOnBuild>True</GeneratePackageOnBuild>
-    <!-- The output structure was modified for msbuild development needs.-->
-    <NoWarn>NU5101;NU5128;MSB3277</NoWarn>
+    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
   </PropertyGroup>
 
   <ItemGroup>
     <None Include="CustomAnalyzer2.props" Pack="true" PackagePath="build\CustomAnalyzer2.props" />
+    <Content Include="README.md" />
   </ItemGroup>
 
-  <ItemGroup>
-    <!-- In the real world scenario, the DLLs are added as PackageReference, modified for test purposes only. -->
-    <Reference Include="Microsoft.Build">
-      <HintPath>$(MSBuildProjectDirectory)\..\..\Microsoft.Build.dll</HintPath>
-    </Reference>
-  </ItemGroup>
-
-  <Target Name="AddNuGetDlls" BeforeTargets="_GetPackageFiles">
-    <ItemGroup>
-      <!-- Add the DLL produced by the current project to the NuGet package -->
-      <None Include="$(OutputPath)\$(AssemblyName).dll" Pack="true" PackagePath="build" Visible="false" />
-    </ItemGroup>
-  </Target>
-
+  <Import Project="..\Common\CommonTest.targets" />
+  
 </Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/README.md b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/README.md
new file mode 100644
index 00000000000..4f29145e7f0
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Analyzer Template
+
+## Overview
+MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild analyzer libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom analysis rules.
+
+## Getting Started
+To use the MSBuild Custom Analyzer Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildanalyzer
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildanalyzer -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
\ No newline at end of file
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidAnalyzer.cs b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidAnalyzer.cs
new file mode 100644
index 00000000000..e5f466ce414
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidAnalyzer.cs
@@ -0,0 +1,9 @@
+﻿using System.Collections.Generic;
+
+namespace InvalidCustomAnalyzer
+{
+    public sealed class InvalidAnalyzer
+    {
+        public string FriendlyName => "InvalidAnalyzer";
+    }
+}
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.csproj b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.csproj
new file mode 100644
index 00000000000..4ef7f0674ca
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.csproj
@@ -0,0 +1,17 @@
+<Project Sdk="Microsoft.NET.Sdk">
+
+  <Import Project="..\Common\CommonTest.props" />
+
+  <PropertyGroup>
+    <TargetFramework>netstandard2.0</TargetFramework>
+    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <None Include="InvalidCustomAnalyzer.props" Pack="true" PackagePath="build\InvalidCustomAnalyzer.props" />
+    <Content Include="README.md" />
+  </ItemGroup>
+
+  <Import Project="..\Common\CommonTest.targets" />
+
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.props b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.props
new file mode 100644
index 00000000000..52a9bab57c0
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.props
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+  <PropertyGroup>
+	  <MSBuildAnalyzer>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)InvalidCustomAnalyzer.dll))</MSBuildAnalyzer>
+  </PropertyGroup>
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/README.md b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/README.md
new file mode 100644
index 00000000000..4f29145e7f0
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Analyzer Template
+
+## Overview
+MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild analyzer libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom analysis rules.
+
+## Getting Started
+To use the MSBuild Custom Analyzer Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildanalyzer
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildanalyzer -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
\ No newline at end of file
diff --git a/src/Deprecated/Conversion/ProjectFileConverter.cs b/src/Deprecated/Conversion/ProjectFileConverter.cs
index 5e08c084d76..1990818c5e3 100644
--- a/src/Deprecated/Conversion/ProjectFileConverter.cs
+++ b/src/Deprecated/Conversion/ProjectFileConverter.cs
@@ -116,9 +116,23 @@ namespace Microsoft.Build.Conversion
      *
      **************************************************************************/
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
     /// This class performs a project file format conversion from Visual Studio
     /// .NET 2002 or 2003 to MSBuild format (for Whidbey).
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     /// <owner>rgoel</owner>
     public sealed class ProjectFileConverter
     {
@@ -192,9 +206,24 @@ public sealed class ProjectFileConverter
         private Dictionary<string, string> propertiesToEscape = null;
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Default constructor.  We need a constructor that takes zero parameters,
         /// because this class needs to be instantiated from COM.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>rgoel</owner>
         public ProjectFileConverter
             (
@@ -209,9 +238,24 @@ public ProjectFileConverter
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// The read/write accessor for the old project filename.  This must be
         /// set by the consumer before calling Convert().
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>rgoel</owner>
         public string OldProjectFile
         {
@@ -226,9 +270,24 @@ public string OldProjectFile
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// The read/write accessor for the new project filename.  This must be
         /// set by the consumer before calling Convert().
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>rgoel</owner>
         public string NewProjectFile
         {
@@ -243,12 +302,27 @@ public string NewProjectFile
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// The read/write accessor for the boolean which tells the converter
         /// whether the project file we're converting is a "main" project file
         /// or a .USER file.  Most of the conversion logic is identical for
         /// both types of files, but for example, one difference is that the
         /// "main" project file gets an &lt;Import&gt; tag inserted at the end.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>rgoel</owner>
         public bool IsUserFile
         {
@@ -263,10 +337,25 @@ public bool IsUserFile
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// The read/write accessor for the solution file which contains this
         /// project being converted.  This is used to look up information about the
         /// project-to-project references.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>rgoel</owner>
         public string SolutionFile
         {
@@ -281,9 +370,24 @@ public string SolutionFile
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Indicates if the last attempted conversion was skipped because the project is already in the latest format.
         /// This will always return false;
         /// </summary>
+        ///<remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>SumedhK</owner>
         /// <value>true, if conversion was skipped</value>
         public bool ConversionSkippedBecauseProjectAlreadyConverted
@@ -295,8 +399,23 @@ public bool ConversionSkippedBecauseProjectAlreadyConverted
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This property returns the list of warnings that were generated during the conversion
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>faisalmo</owner>
         /// <value>true, if conversion was skipped</value>
         [SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Justification = "Public interface that has shipped previously. ")]
@@ -309,9 +428,24 @@ public string[] ConversionWarnings
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Is the conversion a minor upgrade operation?
         /// Minor upgrade also means the converted project file can be opened in old VS as well, so we won't update the tools version.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public bool IsMinorUpgrade
         {
             get
@@ -326,11 +460,26 @@ public bool IsMinorUpgrade
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This is the entry point method, which performs the project file format
         /// conversion.  This method will overwrite "newProjectFile" if it already
         /// exists, so the caller of this method should confirm with the user
         /// that that's what he really wants to do.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>rgoel</owner>
         public void Convert()
         {
@@ -914,12 +1063,27 @@ private bool FixTargetFrameworkSubset()
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Performs conversions specific to F# projects (VS2008 CTP -> VS2012) and (VS2010 -> VS2012).
         /// This involves: changing the location of FSharp targets,
         /// and for 2008CTP, adding explicit mscorlib and FSharp.Core references.
         /// </summary>
         /// <param name="actuallyMakeChanges">if true, make the changes, otherwise, don't actually make any changes, but do report the return boolean as to whether you would make changes</param>
         /// <returns>true if anything was (would be) changed, false otherwise</returns>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public bool FSharpSpecificConversions(bool actuallyMakeChanges)
         {
             // For FSharp projects, should import different location of FSharp targets
@@ -1350,10 +1514,25 @@ private bool VBSpecificConversions()
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This is the entry point method, which performs the project file format
         /// conversion.  This method will simply create a new MSBuild Project object
         /// in memory, instead of trying to write it to disk.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public ProjectRootElement ConvertInMemory()
         {
             ConvertInMemoryToMSBuildProject();
diff --git a/src/Deprecated/Engine/Engine/BuildTask.cs b/src/Deprecated/Engine/Engine/BuildTask.cs
index 876aea82f2e..4901dbab37b 100644
--- a/src/Deprecated/Engine/Engine/BuildTask.cs
+++ b/src/Deprecated/Engine/Engine/BuildTask.cs
@@ -17,8 +17,23 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// This class represents a single task.
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     /// <owner>rgoel</owner>
     public class BuildTask
     {
@@ -128,8 +143,23 @@ internal XmlElement TaskXmlElement
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Accessor for the task's "name" element.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public string Name
         {
@@ -140,8 +170,23 @@ public string Name
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Accessor for the task's "condition".
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public string Condition
         {
@@ -169,8 +214,23 @@ public string Condition
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Accessor for the task's "ContinueOnError".
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public bool ContinueOnError
         {
@@ -223,9 +283,24 @@ public bool ContinueOnError
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// System.Type object corresponding to the task class that implements
         /// the functionality that runs this task object.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public Type Type
         {
@@ -260,8 +335,23 @@ public Type Type
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Accessor for the "host object" for this task.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public ITaskHost HostObject
         {
@@ -299,6 +389,11 @@ internal Target ParentTarget
         #region Methods
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This retrieves the list of all parameter names from the element
         /// node of this task. Note that it excludes anything that a specific
         /// property is exposed for or that isn't valid here (Name, Condition,
@@ -309,6 +404,16 @@ internal Target ParentTarget
         /// much simpler.
         /// </summary>
         /// <returns></returns>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>rgoel</owner>
         public string[] GetParameterNames()
         {
@@ -332,11 +437,26 @@ public string[] GetParameterNames()
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This retrieves an arbitrary attribute from the task element.  These
         /// are attributes that the project author has placed on the task element
         /// that have no meaning to MSBuild other than that they get passed to the
         /// task itself as arguments.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public string GetParameterValue
         (
@@ -357,6 +477,11 @@ string attributeName
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This sets an arbitrary attribute on the task element.  These
         /// are attributes that the project author has placed on the task element
         /// that get passed in to the task.
@@ -366,6 +491,16 @@ string attributeName
         /// <param name="parameterName"></param>
         /// <param name="parameterValue"></param>
         /// <param name="treatParameterValueAsLiteral"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public void SetParameterValue
             (
@@ -378,10 +513,25 @@ bool treatParameterValueAsLiteral
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This sets an arbitrary attribute on the task element.  These
         /// are attributes that the project author has placed on the task element
         /// that get passed in to the task.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public void SetParameterValue
         (
@@ -409,10 +559,25 @@ string parameterValue
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Adds an Output tag to this task element
         /// </summary>
         /// <param name="taskParameter"></param>
         /// <param name="itemName"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public void AddOutputItem(string taskParameter, string itemName)
         {
@@ -449,10 +614,25 @@ internal void AddOutputItem(string taskParameter, string itemName, string condit
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Adds an Output tag to this task element
         /// </summary>
         /// <param name="taskParameter"></param>
         /// <param name="propertyName"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public void AddOutputProperty(string taskParameter, string propertyName)
         {
@@ -473,8 +653,23 @@ public void AddOutputProperty(string taskParameter, string propertyName)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Runs the task associated with this object.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public bool Execute
             (
diff --git a/src/Deprecated/Engine/Engine/Import.cs b/src/Deprecated/Engine/Engine/Import.cs
index bad3fb3d99d..e51e7d5c55b 100644
--- a/src/Deprecated/Engine/Engine/Import.cs
+++ b/src/Deprecated/Engine/Engine/Import.cs
@@ -12,8 +12,23 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// This class represents a single Import element in a project file
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     /// <owner>LukaszG</owner>
     public class Import : IItemPropertyGrouping
     {
@@ -43,8 +58,23 @@ internal XmlElement ImportElement
         private bool importedFromAnotherProject;
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Returns true if this Import came from an imported project
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public bool IsImported
         {
@@ -54,8 +84,23 @@ public bool IsImported
         private XmlAttribute projectPathAttribute = null;
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Returns the original import path from the Import element
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public string ProjectPath
         {
@@ -82,8 +127,23 @@ internal XmlAttribute ProjectPathAttribute
         private string evaluatedProjectPath = null;
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Returns the full evaluated import path
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public string EvaluatedProjectPath
         {
@@ -93,8 +153,23 @@ public string EvaluatedProjectPath
         private XmlAttribute conditionAttribute = null;
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// The condition string for this UsingTask
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public string Condition
         {
diff --git a/src/Deprecated/Engine/Engine/ImportCollection.cs b/src/Deprecated/Engine/Engine/ImportCollection.cs
index 21957a6cbfe..0b724418cad 100644
--- a/src/Deprecated/Engine/Engine/ImportCollection.cs
+++ b/src/Deprecated/Engine/Engine/ImportCollection.cs
@@ -14,8 +14,23 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// This class represents a collection of all Import elements in a given project file
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     /// <owner>LukaszG</owner>
     public class ImportCollection : IEnumerable, ICollection
     {
@@ -48,9 +63,24 @@ internal ImportCollection(Project parentProject)
         #region IEnumerable Members
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// IEnumerable member method for returning the enumerator
         /// </summary>
         /// <returns></returns>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public IEnumerator GetEnumerator()
         {
@@ -63,10 +93,25 @@ public IEnumerator GetEnumerator()
         #region ICollection Members
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// ICollection member method for copying the contents of this collection into an array
         /// </summary>
         /// <param name="array"></param>
         /// <param name="index"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public void CopyTo(Array array, int index)
         {
@@ -75,8 +120,23 @@ public void CopyTo(Array array, int index)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// ICollection member property for returning the number of items in this collection
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public int Count
         {
@@ -88,8 +148,23 @@ public int Count
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// ICollection member property for determining whether this collection is thread-safe
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public bool IsSynchronized
         {
@@ -101,8 +176,23 @@ public bool IsSynchronized
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// ICollection member property for returning this collection's synchronization object
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public object SyncRoot
         {
@@ -155,10 +245,25 @@ internal Import this[string index]
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Copy the contents of this collection into a strongly typed array
         /// </summary>
         /// <param name="array"></param>
         /// <param name="index"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public void CopyTo(Import[] array, int index)
         {
@@ -171,6 +276,16 @@ public void CopyTo(Import[] array, int index)
         /// </summary>
         /// <param name="projectFile">Project file to add the import to</param>
         /// <param name="condition">Condition. If null, no condition is added.</param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void AddNewImport(string projectFile, string condition)
         {
             ErrorUtilities.VerifyThrowArgumentLength(projectFile, nameof(projectFile));
@@ -194,6 +309,16 @@ public void AddNewImport(string projectFile, string condition)
         /// from the project's XML.
         /// </summary>
         /// <param name="importToRemove"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>JeffCal</owner>
         public void RemoveImport
         (
diff --git a/src/Deprecated/Engine/Engine/Target.cs b/src/Deprecated/Engine/Engine/Target.cs
index 45612ae14d7..ed6334ecee4 100644
--- a/src/Deprecated/Engine/Engine/Target.cs
+++ b/src/Deprecated/Engine/Engine/Target.cs
@@ -19,8 +19,23 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// This class represents a single target in its parent project.
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     [DebuggerDisplay("Target (Name = { Name }, Condition = { Condition })")]
     public class Target : IEnumerable
     {
@@ -274,9 +289,24 @@ internal int Id
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Gets the target's name as specified in the "Name" attribute. The value of this attribute is never evaluated.
         /// </summary>
         /// <value>The target name string.</value>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public string Name
         {
             get
@@ -286,10 +316,25 @@ public string Name
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Gets the target's unevaluated "DependsOnTargets" string.
         /// Returns unevaluated.
         /// </summary>
         /// <value>The raw "DependsOnTargets" string.</value>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public string DependsOnTargets
         {
             get
@@ -304,10 +349,25 @@ public string DependsOnTargets
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Gets the target's unevaluated "Inputs" string.
         /// Returns unevaluated.
         /// </summary>
         /// <value>The raw "Inputs" string.</value>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public string Inputs
         {
             get
@@ -322,10 +382,25 @@ public string Inputs
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Gets the target's unevaluated "Outputs" string.
         /// Returns unevaluated.
         /// </summary>
         /// <value>The raw "Outputs" string.</value>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public string Outputs
         {
             get
@@ -340,10 +415,25 @@ public string Outputs
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Accessor for the item's "condition". Returned unevaluated.
         /// </summary>
         /// <returns>Condition string.</returns>
         /// <value>The raw condition string.</value>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public string Condition
         {
             get
@@ -472,11 +562,26 @@ internal List<string> GetBatchableTargetParameters()
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This returns a boolean telling you whether this particular target
         /// was imported from another project, or whether it was defined
         /// in the main project.
         /// </summary>
         /// <value></value>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public bool IsImported
         {
             get
@@ -506,10 +611,25 @@ internal TargetExecutionWrapper ExecutionState
         #region Methods
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Allows the caller to use a foreach loop to enumerate through the individual
         /// BuildTask objects contained within this Target.
         /// </summary>
         /// <returns></returns>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public IEnumerator GetEnumerator
             (
             )
@@ -763,10 +883,25 @@ string attributeValue
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Adds a task with the specified name to the end of this target.  This method
         /// does all of the work to manipulate the project's XML content.
         /// </summary>
         /// <param name="taskName"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public BuildTask AddNewTask
             (
             string taskName
@@ -792,11 +927,26 @@ string taskName
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Removes the specified BuildTask from the target.  This method correctly updates
         /// the project's XML content, so the task will no longer show up when the project
         /// is saved out.
         /// </summary>
         /// <param name="taskElement"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void RemoveTask
             (
             BuildTask taskElement
diff --git a/src/Deprecated/Engine/Engine/TargetCollection.cs b/src/Deprecated/Engine/Engine/TargetCollection.cs
index a10b4ee96a5..fa101c9c3c4 100644
--- a/src/Deprecated/Engine/Engine/TargetCollection.cs
+++ b/src/Deprecated/Engine/Engine/TargetCollection.cs
@@ -16,10 +16,25 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// This class represents a collection of persisted &lt;Target&gt;'s.  Each
     /// MSBuild project has exactly one TargetCollection, which includes
     /// all the imported Targets as well as the ones in the main project file.
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     /// <owner>rgoel</owner>
     public class TargetCollection : IEnumerable, ICollection
     {
@@ -66,9 +81,24 @@ internal Project ParentProject
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Read-only property which returns the number of Targets contained
         /// in our collection.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public int Count
         {
@@ -81,8 +111,23 @@ public int Count
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This ICollection property tells whether this object is thread-safe.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public bool IsSynchronized
         {
@@ -93,9 +138,24 @@ public bool IsSynchronized
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This ICollection property returns the object to be used to synchronize
         /// access to the class.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public object SyncRoot
         {
@@ -106,11 +166,26 @@ public object SyncRoot
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Gets the target with the given name, case-insensitively.
         /// Note that this also defines the .BuildItem() accessor automagically.
         /// </summary>
         /// <owner>RGoel</owner>
         /// <param name="index"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <returns>The target with the given name.</returns>
         public Target this[string index]
         {
@@ -127,9 +202,24 @@ public Target this[string index]
         #region Methods
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This ICollection method copies the contents of this collection to an
         /// array.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public void CopyTo
         (
@@ -143,10 +233,25 @@ int index
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This IEnumerable method returns an IEnumerator object, which allows
         /// the caller to enumerate through the Target objects contained in
         /// this TargetCollection.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public IEnumerator GetEnumerator
             (
@@ -174,9 +279,24 @@ internal void AddOverrideTarget(Target newTarget)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Adds a new &lt;Target&gt; element to the project file, at the very end.
         /// </summary>
         /// <param name="targetName"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <returns>The new Target object.</returns>
         public Target AddNewTarget
         (
@@ -205,10 +325,25 @@ string targetName
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Removes a target from the project, and removes the corresponding &lt;Target&gt; element
         /// from the project's XML.
         /// </summary>
         /// <param name="targetToRemove"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public void RemoveTarget
         (
@@ -247,10 +382,25 @@ Target targetToRemove
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Checks if a target with given name already exists
         /// </summary>
         /// <param name="targetName">name of the target we're looking for</param>
         /// <returns>true if the target already exists</returns>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public bool Exists
         (
             string targetName
diff --git a/src/Deprecated/Engine/Engine/Toolset.cs b/src/Deprecated/Engine/Engine/Toolset.cs
index e67724efe90..6cd7b37a330 100644
--- a/src/Deprecated/Engine/Engine/Toolset.cs
+++ b/src/Deprecated/Engine/Engine/Toolset.cs
@@ -12,8 +12,23 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// Aggregation of a toolset version (eg. "2.0"), tools path, and optional set of associated properties
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     public class Toolset
     {
         // Name of the tools version
@@ -30,6 +45,17 @@ public class Toolset
         /// </summary>
         /// <param name="toolsVersion">Name of the toolset</param>
         /// <param name="toolsPath">Path to this toolset's tasks and targets</param>
+        /// <remarks>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public Toolset(string toolsVersion, string toolsPath)
             : this(toolsVersion, toolsPath, null)
         {
@@ -42,6 +68,16 @@ public Toolset(string toolsVersion, string toolsPath)
         /// <param name="toolsPath">Path to this toolset's tasks and targets</param>
         /// <param name="buildProperties">Properties that should be associated with the Toolset.
         /// May be null, in which case an empty property group will be used.</param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public Toolset(string toolsVersion, string toolsPath, BuildPropertyGroup buildProperties)
         {
             ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, nameof(toolsVersion));
@@ -60,6 +96,16 @@ public Toolset(string toolsVersion, string toolsPath, BuildPropertyGroup buildPr
         /// <summary>
         /// Name of this toolset
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public string ToolsVersion
         {
             get
@@ -71,6 +117,16 @@ public string ToolsVersion
         /// <summary>
         /// Path to this toolset's tasks and targets. Corresponds to $(MSBuildToolsPath) in a project or targets file.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public string ToolsPath
         {
             get
@@ -104,6 +160,16 @@ private set
         /// <summary>
         /// Properties associated with the toolset
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public BuildPropertyGroup BuildProperties
         {
             get
@@ -115,6 +181,16 @@ public BuildPropertyGroup BuildProperties
         /// <summary>
         /// Make a deep copy of the Toolset
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public Toolset Clone()
         {
             // Can't use BuildPropertyGroupProxy as it's not a BuildPropertyGroup,
diff --git a/src/Deprecated/Engine/Engine/ToolsetCollection.cs b/src/Deprecated/Engine/Engine/ToolsetCollection.cs
index e5e85a280cb..57769b2776b 100644
--- a/src/Deprecated/Engine/Engine/ToolsetCollection.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetCollection.cs
@@ -13,12 +13,27 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// Implementation of ICollection&lt;Toolset&gt; that also supports
     /// key-based retrieval by passing the string value of the tools version
     /// corresponding with the desired Toolset.
     /// NOTE: This collection does not support ICollection&lt;Toolset&gt;'s
     /// Remove or Clear methods, and calls to these will generate exceptions.
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     public class ToolsetCollection : ICollection<Toolset>
     {
         // the parent engine
@@ -50,8 +65,23 @@ internal ToolsetCollection(Engine parentEngine)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// The names of the toolsets stored in this collection.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public IEnumerable<string> ToolsVersions
         {
             get
@@ -61,10 +91,25 @@ public IEnumerable<string> ToolsVersions
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Gets the Toolset with matching toolsVersion.
         /// </summary>
         /// <param name="toolsVersion"></param>
         /// <returns>Toolset with matching toolsVersion, or null if none exists.</returns>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public Toolset this[string toolsVersion]
         {
             get
@@ -82,11 +127,26 @@ public Toolset this[string toolsVersion]
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Determines whether the collection contains a Toolset with matching
         /// tools version.
         /// </summary>
         /// <param name="key"></param>
         /// <returns></returns>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public bool Contains(string toolsVersion)
         {
             return toolsetMap.ContainsKey(toolsVersion);
@@ -106,8 +166,23 @@ public int Count
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Always returns false
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public bool IsReadOnly
         {
             get
@@ -117,11 +192,26 @@ public bool IsReadOnly
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// Adds the given Toolset to this collection, replacing any previous value
         /// with the same tools version.  Also notifies the parent Engine of the
         /// change.
         /// </summary>
         /// <param name="item"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void Add(Toolset item)
         {
             ErrorUtilities.VerifyThrowArgumentNull(item, nameof(item));
@@ -141,57 +231,147 @@ public void Add(Toolset item)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This method is not supported.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void Clear()
         {
             throw new NotSupportedException();
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Determines whether or not this collection contains the given toolset.
         /// </summary>
         /// <param name="item"></param>
         /// <returns></returns>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public bool Contains(Toolset item)
         {
             return toolsetMap.ContainsValue(item);
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Copies the contents of this collection to the given array, beginning
         /// at the given index.
         /// </summary>
         /// <param name="array"></param>
         /// <param name="arrayIndex"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void CopyTo(Toolset[] array, int arrayIndex)
         {
             toolsetMap.Values.CopyTo(array, arrayIndex);
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Generic enumerator for the Toolsets in this collection.
         /// </summary>
         /// <returns></returns>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public IEnumerator<Toolset> GetEnumerator()
         {
             return this.toolsetMap.Values.GetEnumerator();
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Non-generic enumerator for the Toolsets in this collection.
         /// </summary>
         /// <returns></returns>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
         {
             return GetEnumerator();
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// This method is not supported.
         /// </summary>
         /// <param name="item"></param>
         /// <returns></returns>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public bool Remove(Toolset item)
         {
             throw new NotSupportedException();
diff --git a/src/Deprecated/Engine/Engine/UsingTask.cs b/src/Deprecated/Engine/Engine/UsingTask.cs
index 1d51301bf7d..ae384542520 100644
--- a/src/Deprecated/Engine/Engine/UsingTask.cs
+++ b/src/Deprecated/Engine/Engine/UsingTask.cs
@@ -13,8 +13,23 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// This class represents a single UsingTask element in a project file
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     /// <owner>LukaszG</owner>
     public class UsingTask
     {
@@ -23,8 +38,23 @@ public class UsingTask
         private bool importedFromAnotherProject;
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Returns true if this UsingTask was imported from another project
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public bool IsImported
         {
@@ -34,8 +64,23 @@ public bool IsImported
         private XmlAttribute taskNameAttribute = null;
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// The task name
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public string TaskName
         {
@@ -53,8 +98,23 @@ internal XmlAttribute TaskNameAttribute
         private XmlAttribute assemblyNameAttribute = null;
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// The name of the assembly containing the task
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public string AssemblyName
         {
@@ -72,8 +132,23 @@ internal XmlAttribute AssemblyNameAttribute
         private XmlAttribute assemblyFileAttribute = null;
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// The assembly file containing the task
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public string AssemblyFile
         {
@@ -91,8 +166,23 @@ internal XmlAttribute AssemblyFileAttribute
         private XmlAttribute conditionAttribute = null;
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// The condition string for this UsingTask
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public string Condition
         {
diff --git a/src/Deprecated/Engine/Engine/UsingTaskCollection.cs b/src/Deprecated/Engine/Engine/UsingTaskCollection.cs
index 192f47830bc..feee5b19458 100644
--- a/src/Deprecated/Engine/Engine/UsingTaskCollection.cs
+++ b/src/Deprecated/Engine/Engine/UsingTaskCollection.cs
@@ -13,8 +13,23 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// This class represents a collection of all UsingTask elements in a given project file.
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     /// <owner>LukaszG</owner>
     public class UsingTaskCollection : IEnumerable, ICollection
     {
@@ -40,9 +55,24 @@ internal UsingTaskCollection()
         #region IEnumerable Members
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// IEnumerable member method for returning the enumerator
         /// </summary>
         /// <returns></returns>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public IEnumerator GetEnumerator()
         {
@@ -55,10 +85,25 @@ public IEnumerator GetEnumerator()
         #region ICollection Members
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// ICollection member method for copying the contents of this collection into an array
         /// </summary>
         /// <param name="array"></param>
         /// <param name="index"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public void CopyTo(Array array, int index)
         {
@@ -67,8 +112,23 @@ public void CopyTo(Array array, int index)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// ICollection member property for returning the number of items in this collection
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public int Count
         {
@@ -80,8 +140,23 @@ public int Count
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// ICollection member property for determining whether this collection is thread-safe
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public bool IsSynchronized
         {
@@ -93,8 +168,23 @@ public bool IsSynchronized
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// ICollection member property for returning this collection's synchronization object
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public object SyncRoot
         {
@@ -146,10 +236,25 @@ internal UsingTask this[int index]
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Copy the contents of this collection into a strongly typed array
         /// </summary>
         /// <param name="array"></param>
         /// <param name="index"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>LukaszG</owner>
         public void CopyTo(UsingTask[] array, int index)
         {
diff --git a/src/Deprecated/Engine/Engine/Utilities.cs b/src/Deprecated/Engine/Engine/Utilities.cs
index a88f594fef9..71593148804 100644
--- a/src/Deprecated/Engine/Engine/Utilities.cs
+++ b/src/Deprecated/Engine/Engine/Utilities.cs
@@ -18,8 +18,23 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// This class contains utility methods for the MSBuild engine.
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     /// <owner>RGoel</owner>
     public static class Utilities
     {
@@ -521,11 +536,26 @@ internal static string RemoveXmlNamespace(string xml)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Escapes given string, that is replaces special characters with escape sequences that allow MSBuild hosts
         /// to treat MSBuild-interpreted characters literally (';' becomes "%3b" and so on).
         /// </summary>
         /// <param name="unescapedExpression">string to escape</param>
         /// <returns>escaped string</returns>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public static string Escape(string unescapedExpression)
         {
             return EscapingUtilities.Escape(unescapedExpression);
diff --git a/src/Deprecated/Engine/Errors/InternalLoggerException.cs b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
index a0d44e8eebe..a8b941e0975 100644
--- a/src/Deprecated/Engine/Errors/InternalLoggerException.cs
+++ b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
@@ -15,9 +15,24 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// This exception is used to wrap an unhandled exception from a logger. This exception aborts the build, and it can only be
     /// thrown by the MSBuild engine.
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     /// <owner>SumedhK</owner>
     // WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
     // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
@@ -124,11 +139,26 @@ private InternalLoggerException(SerializationInfo info, StreamingContext context
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// ISerializable method which we must override since Exception implements this interface
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
         /// <param name="info"></param>
         /// <param name="context"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
diff --git a/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs b/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
index f62d0a4f61d..8d329e3076c 100644
--- a/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
+++ b/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
@@ -15,9 +15,24 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// This exception is thrown whenever there is a problem with the user's XML project file. The problem might be semantic or
     /// syntactical. The latter would be of a type typically caught by XSD validation (if it was performed by the project writer).
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     /// <owner>RGoel</owner>
     // WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
     // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
@@ -29,12 +44,27 @@ public sealed class InvalidProjectFileException : Exception
         #region Basic constructors
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Default constructor.
         /// </summary>
         /// <remarks>
         /// This constructor only exists to satisfy .NET coding guidelines. Use a rich constructor whenever possible.
         /// </remarks>
         /// <owner>RGoel</owner>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public InvalidProjectFileException()
             : base()
         {
@@ -42,6 +72,11 @@ public InvalidProjectFileException()
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// Creates an instance of this exception using the specified error message.
         /// </summary>
         /// <remarks>
@@ -49,6 +84,16 @@ public InvalidProjectFileException()
         /// </remarks>
         /// <owner>SumedhK</owner>
         /// <param name="message"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public InvalidProjectFileException(string message)
             : base(message)
         {
@@ -56,6 +101,11 @@ public InvalidProjectFileException(string message)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// Creates an instance of this exception using the specified error message and inner exception.
         /// </summary>
         /// <owner>SumedhK</owner>
@@ -64,6 +114,16 @@ public InvalidProjectFileException(string message)
         /// </remarks>
         /// <param name="message"></param>
         /// <param name="innerException"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public InvalidProjectFileException(string message, Exception innerException)
             : base(message, innerException)
         {
@@ -95,11 +155,26 @@ private InvalidProjectFileException(SerializationInfo info, StreamingContext con
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// ISerializable method which we must override since Exception implements this interface
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
         /// <param name="info"></param>
         /// <param name="context"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
@@ -121,6 +196,11 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
         #region Rich constructors
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Creates an instance of this exception using rich error information.
         /// </summary>
         /// <remarks>This constructor is preferred over the basic constructors.</remarks>
@@ -130,6 +210,16 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
         /// <param name="errorSubcategory">Error sub-category that describes the error (can be null).</param>
         /// <param name="errorCode">The error code (can be null).</param>
         /// <param name="helpKeyword">The F1-help keyword for the host IDE (can be null).</param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public InvalidProjectFileException
         (
             XmlNode xmlNode,
@@ -154,6 +244,11 @@ string helpKeyword
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Creates an instance of this exception using rich error information.
         /// </summary>
         /// <remarks>This constructor is preferred over the basic constructors.</remarks>
@@ -167,6 +262,16 @@ string helpKeyword
         /// <param name="errorSubcategory">Error sub-category that describes the error (can be null).</param>
         /// <param name="errorCode">The error code (can be null).</param>
         /// <param name="helpKeyword">The F1-help keyword for the host IDE (can be null).</param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public InvalidProjectFileException
         (
             string projectFile,
@@ -199,10 +304,25 @@ string helpKeyword
         #region Properties
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Gets the exception message including the affected project file (if any).
         /// </summary>
         /// <owner>SumedhK</owner>
         /// <value>The complete message string.</value>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public override string Message
         {
             get
@@ -214,10 +334,25 @@ public override string Message
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Gets the exception message not including the project file.
         /// </summary>
         /// <owner>SumedhK</owner>
         /// <value>The error message string only.</value>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public string BaseMessage
         {
             get
@@ -227,10 +362,25 @@ public string BaseMessage
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Gets the project file (if any) associated with this exception.
         /// </summary>
         /// <owner>SumedhK</owner>
         /// <value>Project filename/path string, or null.</value>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public string ProjectFile
         {
             get
@@ -240,10 +390,25 @@ public string ProjectFile
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// Gets the invalid line number (if any) in the project.
         /// </summary>
         /// <owner>SumedhK</owner>
         /// <value>The invalid line number, or zero.</value>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public int LineNumber
         {
             get
@@ -253,10 +418,25 @@ public int LineNumber
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Gets the invalid column number (if any) in the project.
         /// </summary>
         /// <owner>SumedhK</owner>
         /// <value>The invalid column number, or zero.</value>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public int ColumnNumber
         {
             get
@@ -266,10 +446,25 @@ public int ColumnNumber
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Gets the last line number (if any) of a range of invalid lines in the project.
         /// </summary>
         /// <owner>SumedhK</owner>
         /// <value>The last invalid line number, or zero.</value>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public int EndLineNumber
         {
             get
@@ -279,10 +474,25 @@ public int EndLineNumber
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// Gets the last column number (if any) of a range of invalid columns in the project.
         /// </summary>
         /// <owner>SumedhK</owner>
         /// <value>The last invalid column number, or zero.</value>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public int EndColumnNumber
         {
             get
@@ -292,10 +502,25 @@ public int EndColumnNumber
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Gets the error sub-category (if any) that describes the type of this error.
         /// </summary>
         /// <owner>SumedhK</owner>
         /// <value>The sub-category string, or null.</value>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public string ErrorSubcategory
         {
             get
@@ -305,10 +530,25 @@ public string ErrorSubcategory
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// Gets the error code (if any) associated with the exception message.
         /// </summary>
         /// <owner>SumedhK</owner>
         /// <value>Error code string, or null.</value>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public string ErrorCode
         {
             get
@@ -318,10 +558,25 @@ public string ErrorCode
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// Gets the F1-help keyword (if any) associated with this error, for the host IDE.
         /// </summary>
         /// <owner>SumedhK</owner>
         /// <value>The keyword string, or null.</value>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public string HelpKeyword
         {
             get
diff --git a/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs b/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
index 492a829536a..349ff2bb620 100644
--- a/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
@@ -14,8 +14,23 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// Exception subclass that ToolsetReaders should throw.
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     [Serializable]
     public class InvalidToolsetDefinitionException : Exception
     {
@@ -25,27 +40,72 @@ public class InvalidToolsetDefinitionException : Exception
         private string errorCode = null;
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// Basic constructor.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public InvalidToolsetDefinitionException()
             : base()
         {
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// Basic constructor.
         /// </summary>
         /// <param name="message"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public InvalidToolsetDefinitionException(string message)
             : base(message)
         {
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// Basic constructor.
         /// </summary>
         /// <param name="message"></param>
         /// <param name="innerException"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public InvalidToolsetDefinitionException(string message, Exception innerException)
             : base(message, innerException)
         {
@@ -65,10 +125,25 @@ protected InvalidToolsetDefinitionException(SerializationInfo info, StreamingCon
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// Constructor that takes an MSBuild error code
         /// </summary>
         /// <param name="message"></param>
         /// <param name="errorCode"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public InvalidToolsetDefinitionException(string message, string errorCode)
             : base(message)
         {
@@ -76,11 +151,26 @@ public InvalidToolsetDefinitionException(string message, string errorCode)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Constructor that takes an MSBuild error code
         /// </summary>
         /// <param name="message"></param>
         /// <param name="errorCode"></param>
         /// <param name="innerException"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public InvalidToolsetDefinitionException(string message, string errorCode, Exception innerException)
             : base(message, innerException)
         {
@@ -88,11 +178,26 @@ public InvalidToolsetDefinitionException(string message, string errorCode, Excep
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// ISerializable method which we must override since Exception implements this interface
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
         /// <param name="info"></param>
         /// <param name="context"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
@@ -104,9 +209,24 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// The MSBuild error code corresponding with this exception, or
         /// null if none was specified.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public string ErrorCode
         {
             get
diff --git a/src/Deprecated/Engine/Errors/RemoteErrorException.cs b/src/Deprecated/Engine/Errors/RemoteErrorException.cs
index a8d62fd2b3e..94e7adf41c3 100644
--- a/src/Deprecated/Engine/Errors/RemoteErrorException.cs
+++ b/src/Deprecated/Engine/Errors/RemoteErrorException.cs
@@ -15,8 +15,23 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// This class is used to wrap exceptions that occur on a different node
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     [Serializable]
     public sealed class RemoteErrorException : Exception
     {
@@ -44,11 +59,26 @@ private RemoteErrorException(SerializationInfo info, StreamingContext context)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// ISerializable method which we must override since Exception implements this interface
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
         /// <param name="info"></param>
         /// <param name="context"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
diff --git a/src/Deprecated/Engine/Items/BuildItem.cs b/src/Deprecated/Engine/Items/BuildItem.cs
index 338456d3812..69e73737084 100644
--- a/src/Deprecated/Engine/Items/BuildItem.cs
+++ b/src/Deprecated/Engine/Items/BuildItem.cs
@@ -19,11 +19,26 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// This class represents a single item of the project. An item is usually a file on disk, with a type associated with it, and
     /// its own item-specific attributes. The list of items is initially specified via XML tags in the project file, although a
     /// single item tag can represent multiple items through the use of standard wilcards * and ?. Also, tasks can add new items
     /// of various types to the project's item list -- these items don't have any XML representation.
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     /// <owner>RGoel</owner>
     [DebuggerDisplay("BuildItem (Name = { Name }, Include = { Include }, FinalItemSpec = { FinalItemSpec }, Condition = { Condition } )")]
     public class BuildItem
@@ -462,9 +477,24 @@ private void BuildItemHelper(XmlDocument ownerDocument, string itemName, string
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This constructor creates a new virtual (non-persisted) item with the
         /// specified type and include.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public BuildItem(string itemName, string itemInclude) :
             this(null /* no XML */, itemName, itemInclude, null /* no item definition library */)
         {
@@ -497,9 +527,24 @@ internal BuildItem(XmlElement itemElement, bool importedFromAnotherProject, bool
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This constructor creates a new virtual (non-persisted) item based
         /// on a ITaskItem object that was emitted by a task.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public BuildItem(string itemName, ITaskItem taskItem)
         {
             ErrorUtilities.VerifyThrowArgumentNull(taskItem, nameof(taskItem));
@@ -537,17 +582,37 @@ public BuildItem(string itemName, ITaskItem taskItem)
         #region Properties
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This returns a boolean telling you whether this particular item
         /// was imported from another project, or whether it was defined
         /// in the main project.  For virtual items which have no
         /// persistence, this is false.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public bool IsImported
         {
             get { return importedFromAnotherProject; }
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Accessor for the item's "type" string.  Note that changing the "Type"
         /// of an BuildItem requires the whole project to be re-evalauted.  This is because
         /// items are frequently stored in hash tables based on their item types,
@@ -555,6 +620,16 @@ public bool IsImported
         /// implementation the caller who changes the item type is responsible
         /// for calling Project.MarkAsDirty().
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public string Name
         {
             get
@@ -613,8 +688,24 @@ internal ItemDefinitionLibrary ItemDefinitionLibrary
             set { itemDefinitionLibrary = value; }
         }
 
+        /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Accessor for the item's "include" string.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public string Include
         {
@@ -674,8 +765,23 @@ public string Include
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Gets the names of metadata on the item -- also includes the pre-defined/reserved item-spec modifiers.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>SumedhK, JomoF</owner>
         /// <value>Collection of name strings.</value>
         public ICollection MetadataNames
@@ -693,8 +799,23 @@ public ICollection MetadataNames
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Gets the number of metadata set on the item.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>SumedhK</owner>
         /// <value>Count of metadata.</value>
         public int MetadataCount
@@ -706,8 +827,23 @@ public int MetadataCount
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Gets the names of metadata on the item -- also includes the pre-defined/reserved item-spec modifiers.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>SumedhK, JomoF</owner>
         /// <value>Collection of name strings.</value>
         public ICollection CustomMetadataNames
@@ -720,8 +856,23 @@ public ICollection CustomMetadataNames
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Gets the number of metadata set on the item.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>SumedhK</owner>
         /// <value>Count of metadata.</value>
         public int CustomMetadataCount
@@ -742,8 +893,23 @@ internal XmlAttribute IncludeAttribute
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Accessor for the item's "exclude" string.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public string Exclude
         {
@@ -773,8 +939,23 @@ internal XmlAttribute ExcludeAttribute
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Accessor for the item's "condition".
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public string Condition
         {
@@ -1197,9 +1378,23 @@ BuildEventContext buildEventContext
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Indicates if the given metadata is set on the item.
         /// </summary>
-        /// <remarks>BuildItem-spec modifiers are treated as metadata.</remarks>
+        /// <remarks>BuildItem-spec modifiers are treated as metadata.
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public bool HasMetadata(string metadataName)
         {
             ErrorUtilities.VerifyThrowArgumentLength(metadataName, nameof(metadataName));
@@ -1234,6 +1429,11 @@ public bool HasMetadata(string metadataName)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Retrieves an arbitrary unevaluated metadata value from the item element. These are pieces of metadata that the project author has
         /// placed on the item element that have no meaning to MSBuild. They are just arbitrary metadata that travel around with
         /// the BuildItem wherever it goes.
@@ -1241,6 +1441,16 @@ public bool HasMetadata(string metadataName)
         /// <param name="metadataName">The name of the metadata to retrieve.</param>
         /// <returns>The value of the requested metadata.</returns>
         /// <exception cref="InvalidOperationException">Thrown when the requested metadata is not applicable to the item.</exception>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public string GetMetadata(string metadataName)
         {
             string metadataValue;
@@ -1272,6 +1482,11 @@ public string GetMetadata(string metadataName)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Retrieves an arbitrary metadata from the item element, expands any property and item references within it, and
         /// unescapes it.
         /// </summary>
@@ -1279,6 +1494,16 @@ public string GetMetadata(string metadataName)
         /// <param name="metadataName">The name of the attribute to retrieve.</param>
         /// <returns>The evaluated value of the requested attribute.</returns>
         /// <exception cref="InvalidOperationException">Thrown when the requested attribute is not applicable to the item.</exception>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public string GetEvaluatedMetadata(string metadataName)
         {
             return EscapingUtilities.UnescapeAll(this.GetEvaluatedMetadataEscaped(metadataName));
@@ -1368,9 +1593,24 @@ internal int GetCustomMetadataCount()
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Copies all custom attributes to given item.
         /// </summary>
         /// <param name="destinationItem">BuildItem to copy custom attributes to</param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void CopyCustomMetadataTo(BuildItem destinationItem)
         {
             ErrorUtilities.VerifyThrowArgumentNull(destinationItem, nameof(destinationItem));
@@ -1501,10 +1741,25 @@ private IDictionary MergeDefaultMetadata(IDictionary customMetadata)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Sets custom metadata on this item, with the option of treating the metadata value
         /// literally, meaning that special sharacters will be escaped.
         /// Does not backup metadata before making changes.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void SetMetadata(string metadataName, string metadataValue, bool treatMetadataValueAsLiteral)
         {
             SetMetadata(metadataName, treatMetadataValueAsLiteral ? EscapingUtilities.Escape(metadataValue) : metadataValue);
@@ -1570,10 +1825,25 @@ internal void RevertToPersistedMetadata()
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Sets an arbitrary metadata on the item element. These are metadata that the project author has placed on the item
         /// element that have no meaning to MSBuild. They are just arbitrary metadata that travel around with the BuildItem.
         /// Does not backup metadata before making changes.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void SetMetadata(string metadataName, string metadataValue)
         {
             MustNotBeImported();
@@ -1602,9 +1872,24 @@ public void SetMetadata(string metadataName, string metadataValue)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// Removes the specified metadata on the item.
         /// </summary>
         /// <remarks>Removal of well-known metadata is not allowed.</remarks>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void RemoveMetadata(string metadataName)
         {
             ErrorUtilities.VerifyThrowArgument(!FileUtilities.IsItemSpecModifier(metadataName), "Shared.CannotChangeItemSpecModifiers", metadataName);
@@ -1867,11 +2152,26 @@ internal void SplitChildItemIfNecessary()
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This creates a shallow clone of the BuildItem.  If this is an xml-backed item,
         /// then the clone references the same XML element as the original, meaning
         /// that modifications to the clone will affect the original.
         /// </summary>
         /// <returns></returns>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>rgoel</owner>
         public BuildItem Clone()
         {
diff --git a/src/Deprecated/Engine/Items/BuildItemGroup.cs b/src/Deprecated/Engine/Items/BuildItemGroup.cs
index c3e6cb2d3c0..a6636fc7580 100644
--- a/src/Deprecated/Engine/Items/BuildItemGroup.cs
+++ b/src/Deprecated/Engine/Items/BuildItemGroup.cs
@@ -16,10 +16,25 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// This class represents a collection of items.  It may be represented
     /// physically by an &lt;ItemGroup&gt; element persisted in the project file,
     /// or it may just be a virtual BuildItemGroup (e.g., the evaluated items).
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     [DebuggerDisplay("BuildItemGroup (Count = { Count }, Condition = { Condition })")]
     public class BuildItemGroup : IItemPropertyGrouping, IEnumerable
     {
@@ -56,8 +71,23 @@ public class BuildItemGroup : IItemPropertyGrouping, IEnumerable
         #region Constructors
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Default constructor, which initializes a virtual (non-persisted) BuildItemGroup.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public BuildItemGroup()
         {
             this.items = new List<BuildItem>();
@@ -102,19 +132,49 @@ internal BuildItemGroup(XmlDocument ownerDocument, bool importedFromAnotherProje
         #region Properties
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This returns a boolean telling you whether this particular item
         /// group was imported from another project, or whether it was defined
         /// in the main project.  For virtual item groups which have no
         /// persistence, this is false.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public bool IsImported
         {
             get { return importedFromAnotherProject; }
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Accessor for the condition on the item group.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public string Condition
         {
             get
@@ -157,16 +217,46 @@ internal void ClearParentProject()
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Number of items in this group.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public int Count
         {
             get { return items.Count; }
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Gets the item at the specified index.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public BuildItem this[int index]
         {
             get { return items[index]; }
@@ -202,19 +292,49 @@ internal XmlElement ParentElement
         #region Methods
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Copies the items in this group into a new array.
         /// NOTE: the copies are NOT clones i.e. only the references are copied
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public BuildItem[] ToArray()
         {
             return items.ToArray();
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This IEnumerable method returns an IEnumerator object, which allows
         /// the caller to enumerate through the BuildItem objects contained in
         /// this BuildItemGroup.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public IEnumerator GetEnumerator()
         {
             return items.GetEnumerator();
@@ -439,10 +559,25 @@ internal void AddItem(BuildItem itemToAdd)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Creates a new BuildItem defined by the given "Type" and "Include", and
         /// adds it to the end of this BuildItemGroup.
         /// If the group is persisted, the item is persisted; otherwise it is virtual
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public BuildItem AddNewItem(string itemName, string itemInclude)
         {
             BuildItem newItem;
@@ -463,9 +598,24 @@ public BuildItem AddNewItem(string itemName, string itemInclude)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Adds a new item to the ItemGroup, optional treating the item Include as literal so that
         /// any special characters will be escaped before persisting it.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public BuildItem AddNewItem(string itemName, string itemInclude, bool treatItemIncludeAsLiteral)
         {
             return AddNewItem(itemName, treatItemIncludeAsLiteral ? EscapingUtilities.Escape(itemInclude) : itemInclude);
@@ -499,6 +649,16 @@ internal void RemoveItemWithBackup(BuildItem itemToRemove)
         /// Removes the given BuildItem from this BuildItemGroup.
         /// If item is not in this group, does nothing.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void RemoveItem(BuildItem itemToRemove)
         {
             MustBeInitialized();
@@ -508,9 +668,24 @@ public void RemoveItem(BuildItem itemToRemove)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Removes the item at the specified index.
         /// </summary>
         /// <exception cref="ArgumentOutOfRangeException">If index is out of bounds</exception>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void RemoveItemAt(int index)
         {
             MustBeInitialized();
@@ -537,12 +712,27 @@ private void RemoveItemElement(BuildItem item)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Clones the BuildItemGroup.  A shallow clone here is one that references
         /// the same BuildItem objects as the original, whereas a deep clone actually
         /// clones the BuildItem objects as well.  If this is a persisted BuildItemGroup,
         /// only deep clones are allowed, because you can't have the same XML
         /// element belonging to two parents.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public BuildItemGroup Clone(bool deepClone)
         {
             BuildItemGroup clone;
@@ -590,9 +780,24 @@ internal BuildItemGroup ShallowClone()
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Removes all Items from this BuildItemGroup, and also deletes the Condition
         /// and Name.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void Clear()
         {
             MustBeInitialized();
diff --git a/src/Deprecated/Engine/Items/BuildItemGroupCollection.cs b/src/Deprecated/Engine/Items/BuildItemGroupCollection.cs
index 481b6a9e178..f8bb79c6360 100644
--- a/src/Deprecated/Engine/Items/BuildItemGroupCollection.cs
+++ b/src/Deprecated/Engine/Items/BuildItemGroupCollection.cs
@@ -13,6 +13,11 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// This class represents a collection of persisted &lt;ItemGroup&gt;'s.  Each
     /// MSBuild project has exactly one BuildItemGroupCollection, which includes
     /// all the imported ItemGroups as well as the ones in the main project file.
@@ -21,6 +26,16 @@ namespace Microsoft.Build.BuildEngine
     /// calls into the GroupingCollection within the Project to do it's work.  It
     /// doesn't maintain any BuildPropertyGroup state on its own.
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     /// <owner>DavidLe</owner>
     public class BuildItemGroupCollection : IEnumerable, ICollection
     {
@@ -63,10 +78,23 @@ GroupingCollection groupingCollection
         #region Properties
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Read-only property which returns the number of ItemGroups contained
         /// in our collection.
         /// </summary>
         /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
         /// </remarks>
         /// <owner>DavidLe</owner>
         public int Count
@@ -78,8 +106,23 @@ public int Count
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This ICollection property tells whether this object is thread-safe.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>DavidLe</owner>
         public bool IsSynchronized
         {
@@ -90,9 +133,24 @@ public bool IsSynchronized
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This ICollection property returns the object to be used to synchronize
         /// access to the class.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>DavidLe</owner>
         public object SyncRoot
         {
@@ -141,12 +199,27 @@ internal BuildItemGroup LastLocalItemGroup
         #region Methods
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This ICollection method copies the contents of this collection to an
         /// array.
         /// </summary>
         /// <owner>DavidLe</owner>
         /// <param name="array"></param>
         /// <param name="index"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void CopyTo
         (
             Array array,
@@ -157,10 +230,25 @@ int index
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This IEnumerable method returns an IEnumerator object, which allows
         /// the caller to enumerate through the BuildItemGroup objects contained in
         /// this BuildItemGroupCollection.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>DavidLe</owner>
         public IEnumerator GetEnumerator
             (
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNode.cs b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
index ebf9109bf72..242e4c3f095 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNode.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
@@ -16,16 +16,46 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// This class hosts a node class in the child process. It uses shared memory to communicate
     /// with the local node provider.
     /// Wraps a Node.
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     public class LocalNode
     {
         #region Static Constructors
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Hook up an unhandled exception handler, in case our error handling paths are leaky
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         static LocalNode()
         {
             AppDomain currentDomain = AppDomain.CurrentDomain;
@@ -214,9 +244,24 @@ private static bool CreateGlobalEvents(int nodeNumber)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This function starts local node when process is launched and shuts it down on time out
         /// Called by msbuild.exe.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         [System.Diagnostics.CodeAnalysis.SuppressMessage("Reliability", "CA2000:Dispose objects before losing scope", Justification = "Agreed not to touch entries from Deprecated folder")]
         public static void StartLocalNodeServer(int nodeNumber)
         {
diff --git a/src/Deprecated/Engine/Logging/ConsoleLogger.cs b/src/Deprecated/Engine/Logging/ConsoleLogger.cs
index 6405295a126..60e8dbb99d7 100644
--- a/src/Deprecated/Engine/Logging/ConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ConsoleLogger.cs
@@ -35,11 +35,26 @@ namespace Microsoft.Build.BuildEngine
     #endregion
 
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// This class implements the default logger that outputs event data
     /// to the console (stdout).
     /// It is a facade: it creates, wraps and delegates to a kind of BaseConsoleLogger,
     /// either SerialConsoleLogger or ParallelConsoleLogger.
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     /// <remarks>This class is not thread safe.</remarks>
     public class ConsoleLogger : INodeLogger
     {
@@ -56,8 +71,23 @@ public class ConsoleLogger : INodeLogger
         #region Constructors
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// Default constructor.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public ConsoleLogger()
             : this(LoggerVerbosity.Normal)
         {
@@ -65,10 +95,25 @@ public ConsoleLogger()
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Create a logger instance with a specific verbosity.  This logs to
         /// the default console.
         /// </summary>
         /// <param name="verbosity">Verbosity level.</param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public ConsoleLogger(LoggerVerbosity verbosity)
             :
             this
@@ -83,12 +128,27 @@ public ConsoleLogger(LoggerVerbosity verbosity)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Initializes the logger, with alternate output handlers.
         /// </summary>
         /// <param name="verbosity"></param>
         /// <param name="write"></param>
         /// <param name="colorSet"></param>
         /// <param name="colorReset"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public ConsoleLogger
         (
             LoggerVerbosity verbosity,
@@ -161,9 +221,24 @@ private void InitializeBaseConsoleLogger()
         #region Properties
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// Gets or sets the level of detail to show in the event log.
         /// </summary>
         /// <value>Verbosity level.</value>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public LoggerVerbosity Verbosity
         {
             get
@@ -185,10 +260,25 @@ public LoggerVerbosity Verbosity
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// The console logger takes a single parameter to suppress the output of the errors
         /// and warnings summary at the end of a build.
         /// </summary>
         /// <value>null</value>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public string Parameters
         {
             get
@@ -210,10 +300,24 @@ public string Parameters
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Suppresses the display of project headers. Project headers are
         /// displayed by default unless this property is set.
         /// </summary>
-        /// <remarks>This is only needed by the IDE logger.</remarks>
+        /// <remarks>This is only needed by the IDE logger.
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public bool SkipProjectStartedText
         {
             get
@@ -235,8 +339,23 @@ public bool SkipProjectStartedText
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// Suppresses the display of error and warnings summary.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public bool ShowSummary
         {
             get
@@ -286,10 +405,25 @@ protected WriteHandler WriteHandler
         #region Methods
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// Apply a parameter.
         /// NOTE: This method was public by accident in Whidbey, so it cannot be made internal now. It has
         /// no good reason for being public.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void ApplyParameter(string parameterName, string parameterValue)
         {
             ErrorUtilities.VerifyThrowInvalidOperation(consoleLogger != null, "MustCallInitializeBeforeApplyParameter");
@@ -297,15 +431,46 @@ public void ApplyParameter(string parameterName, string parameterValue)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Signs up the console logger for all build events.
         /// </summary>
         /// <param name="eventSource">Available events.</param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public virtual void Initialize(IEventSource eventSource)
         {
             InitializeBaseConsoleLogger();
             consoleLogger.Initialize(eventSource);
         }
 
+        /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public virtual void Initialize(IEventSource eventSource, int nodeCount)
         {
             this.numberOfProcessors = nodeCount;
@@ -314,19 +479,49 @@ public virtual void Initialize(IEventSource eventSource, int nodeCount)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// The console logger does not need to release any resources.
         /// This method does nothing.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public virtual void Shutdown()
         {
             consoleLogger?.Shutdown();
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Handler for build started events
         /// </summary>
         /// <param name="sender">sender (should be null)</param>
         /// <param name="e">event arguments</param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void BuildStartedHandler(object sender, BuildStartedEventArgs e)
         {
             InitializeBaseConsoleLogger(); // for compat: see DDB#136924
@@ -335,10 +530,25 @@ public void BuildStartedHandler(object sender, BuildStartedEventArgs e)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Handler for build finished events
         /// </summary>
         /// <param name="sender">sender (should be null)</param>
         /// <param name="e">event arguments</param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void BuildFinishedHandler(object sender, BuildFinishedEventArgs e)
         {
             InitializeBaseConsoleLogger(); // for compat: see DDB#136924
@@ -347,10 +557,25 @@ public void BuildFinishedHandler(object sender, BuildFinishedEventArgs e)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Handler for project started events
         /// </summary>
         /// <param name="sender">sender (should be null)</param>
         /// <param name="e">event arguments</param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void ProjectStartedHandler(object sender, ProjectStartedEventArgs e)
         {
             InitializeBaseConsoleLogger(); // for compat: see DDB#136924
@@ -359,10 +584,25 @@ public void ProjectStartedHandler(object sender, ProjectStartedEventArgs e)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Handler for project finished events
         /// </summary>
         /// <param name="sender">sender (should be null)</param>
         /// <param name="e">event arguments</param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void ProjectFinishedHandler(object sender, ProjectFinishedEventArgs e)
         {
             InitializeBaseConsoleLogger(); // for compat: see DDB#136924
@@ -371,10 +611,25 @@ public void ProjectFinishedHandler(object sender, ProjectFinishedEventArgs e)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Handler for target started events
         /// </summary>
         /// <param name="sender">sender (should be null)</param>
         /// <param name="e">event arguments</param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void TargetStartedHandler(object sender, TargetStartedEventArgs e)
         {
             InitializeBaseConsoleLogger(); // for compat: see DDB#136924
@@ -383,10 +638,25 @@ public void TargetStartedHandler(object sender, TargetStartedEventArgs e)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Handler for target finished events
         /// </summary>
         /// <param name="sender">sender (should be null)</param>
         /// <param name="e">event arguments</param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void TargetFinishedHandler(object sender, TargetFinishedEventArgs e)
         {
             InitializeBaseConsoleLogger(); // for compat: see DDB#136924
@@ -395,10 +665,25 @@ public void TargetFinishedHandler(object sender, TargetFinishedEventArgs e)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Handler for task started events
         /// </summary>
         /// <param name="sender">sender (should be null)</param>
         /// <param name="e">event arguments</param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void TaskStartedHandler(object sender, TaskStartedEventArgs e)
         {
             InitializeBaseConsoleLogger(); // for compat: see DDB#136924
@@ -407,10 +692,25 @@ public void TaskStartedHandler(object sender, TaskStartedEventArgs e)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Handler for task finished events
         /// </summary>
         /// <param name="sender">sender (should be null)</param>
         /// <param name="e">event arguments</param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void TaskFinishedHandler(object sender, TaskFinishedEventArgs e)
         {
             InitializeBaseConsoleLogger(); // for compat: see DDB#136924
@@ -419,8 +719,23 @@ public void TaskFinishedHandler(object sender, TaskFinishedEventArgs e)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Prints an error event
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void ErrorHandler(object sender, BuildErrorEventArgs e)
         {
             InitializeBaseConsoleLogger(); // for compat: see DDB#136924
@@ -429,8 +744,23 @@ public void ErrorHandler(object sender, BuildErrorEventArgs e)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Prints a warning event
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void WarningHandler(object sender, BuildWarningEventArgs e)
         {
             InitializeBaseConsoleLogger(); // for compat: see DDB#136924
@@ -439,8 +769,23 @@ public void WarningHandler(object sender, BuildWarningEventArgs e)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Prints a message event
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void MessageHandler(object sender, BuildMessageEventArgs e)
         {
             InitializeBaseConsoleLogger(); // for compat: see DDB#136924
@@ -449,8 +794,23 @@ public void MessageHandler(object sender, BuildMessageEventArgs e)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// Prints a custom event
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void CustomEventHandler(object sender, CustomBuildEventArgs e)
         {
             InitializeBaseConsoleLogger(); // for compat: see DDB#136924
diff --git a/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs b/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
index 97ec2c4385a..242adbfaafd 100644
--- a/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
+++ b/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
@@ -14,15 +14,45 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// Logger that forwards events to a central logger (e.g ConsoleLogger)
     /// residing on the parent node.
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     public class ConfigurableForwardingLogger : IForwardingLogger
     {
         #region Constructors
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Default constructor.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public ConfigurableForwardingLogger()
         {
             InitializeForwardingTable();
@@ -32,9 +62,24 @@ public ConfigurableForwardingLogger()
         #region Properties
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Gets or sets the level of detail to show in the event log.
         /// </summary>
         /// <value>Verbosity level.</value>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public LoggerVerbosity Verbosity
         {
             get { return verbosity; }
@@ -42,10 +87,25 @@ public LoggerVerbosity Verbosity
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// The console logger takes a single parameter to suppress the output of the errors
         /// and warnings summary at the end of a build.
         /// </summary>
         /// <value>null</value>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public string Parameters
         {
             get { return loggerParameters; }
@@ -53,15 +113,46 @@ public string Parameters
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This property is set by the build engine to allow a node loggers to forward messages to the
         /// central logger
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public IEventRedirector BuildEventRedirector
         {
             get { return this.buildEventRedirector; }
             set { this.buildEventRedirector = value; }
         }
 
+        /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public int NodeId
         {
             get { return nodeId; }
@@ -151,8 +242,23 @@ private void ApplyParameter(string parameterName)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Signs up the console logger for all build events.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public virtual void Initialize(IEventSource eventSource)
         {
             ErrorUtilities.VerifyThrowArgumentNull(eventSource, nameof(eventSource));
@@ -181,8 +287,23 @@ public virtual void Initialize(IEventSource eventSource)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Signs up the console logger for all build events.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void Initialize(IEventSource eventSource, int nodeCount)
         {
             Initialize(eventSource);
@@ -262,8 +383,23 @@ private void ResetLoggerState()
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// Called when Engine is done with this logger
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public virtual void Shutdown()
         {
             // Nothing to do
diff --git a/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
index 05f5b1d2269..063d7545b85 100644
--- a/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -14,14 +14,44 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// This class will create a text file which will contain the build log for that node
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     public class DistributedFileLogger : IForwardingLogger
     {
         #region Constructors
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Default constructor.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public DistributedFileLogger()
             : base()
         {
@@ -30,6 +60,22 @@ public DistributedFileLogger()
 
         #region Methods
 
+        /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void Initialize(IEventSource eventSource, int nodeCount)
         {
             Initialize(eventSource);
@@ -88,6 +134,22 @@ private void ApplyFileLoggerParameter(string parameterName, string parameterValu
             }
         }
 
+        /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void Initialize(IEventSource eventSource)
         {
             ErrorUtilities.VerifyThrowArgumentNull(eventSource, nameof(eventSource));
@@ -124,6 +186,22 @@ public void Initialize(IEventSource eventSource)
             nodeFileLogger.Initialize(eventSource, 2);
         }
 
+        /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void Shutdown()
         {
             nodeFileLogger?.Shutdown();
@@ -140,6 +218,23 @@ internal FileLogger InternalFilelogger
                 return nodeFileLogger;
             }
         }
+
+        /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public IEventRedirector BuildEventRedirector
         {
             get
@@ -153,6 +248,22 @@ public IEventRedirector BuildEventRedirector
         }
 
         // Node Id of the node which the forwarding logger is attached to
+        /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public int NodeId
         {
             get
@@ -166,6 +277,22 @@ public int NodeId
         }
 
         // The verbosity for now is set at detailed
+        /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public LoggerVerbosity Verbosity
         {
             get
@@ -179,6 +306,22 @@ public LoggerVerbosity Verbosity
             }
         }
 
+        /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public string Parameters
         {
             get
diff --git a/src/Deprecated/Engine/Logging/FileLogger.cs b/src/Deprecated/Engine/Logging/FileLogger.cs
index 25db6182dcf..3869711b643 100644
--- a/src/Deprecated/Engine/Logging/FileLogger.cs
+++ b/src/Deprecated/Engine/Logging/FileLogger.cs
@@ -15,12 +15,26 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// A specialization of the ConsoleLogger that logs to a file instead of the console.
     /// The output in terms of what is written and how it looks is identical. For example you can
     /// log verbosely to a file using the FileLogger while simultaneously logging only high priority events
     /// to the console using a ConsoleLogger.
     /// </summary>
     /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// 
     /// It's unfortunate that this is derived from ConsoleLogger, which is itself a facade; it makes things more
     /// complex -- for example, there is parameter parsing in this class, plus in BaseConsoleLogger. However we have
     /// to derive FileLogger from ConsoleLogger because it shipped that way in Whidbey.
@@ -30,8 +44,23 @@ public class FileLogger : ConsoleLogger
         #region Constructors
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Default constructor.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>KieranMo</owner>
         public FileLogger() : base(LoggerVerbosity.Normal)
         {
@@ -41,9 +70,24 @@ public FileLogger() : base(LoggerVerbosity.Normal)
         #endregion
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// Signs up the console file logger for all build events.
         /// This is the backward-compatible overload.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <param name="eventSource">Available events.</param>
         public override void Initialize(IEventSource eventSource)
         {
@@ -107,8 +151,23 @@ private void InitializeFileLogger(IEventSource eventSource, int nodeCount)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// Multiproc aware initialization
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public override void Initialize(IEventSource eventSource, int nodeCount)
         {
             InitializeFileLogger(eventSource, nodeCount);
@@ -140,8 +199,23 @@ private void Write(string text)
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Shutdown method implementation of ILogger - we need to flush and close our logfile.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public override void Shutdown()
         {
             fileWriter?.Close();
diff --git a/src/Deprecated/Engine/Logging/LoggerDescription.cs b/src/Deprecated/Engine/Logging/LoggerDescription.cs
index fabc6e48949..40b9536e81f 100644
--- a/src/Deprecated/Engine/Logging/LoggerDescription.cs
+++ b/src/Deprecated/Engine/Logging/LoggerDescription.cs
@@ -15,10 +15,25 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// This class is used to contain information about a logger as a collection of values that
     /// can be used to instantiate the logger and can be serialized to be passed between different
     /// processes.
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     public class LoggerDescription
     {
         #region Constructor
@@ -28,8 +43,23 @@ internal LoggerDescription()
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Creates a logger description from given data
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public LoggerDescription
         (
             string loggerClassName,
@@ -88,8 +118,23 @@ internal string Name
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// Returns the string of logger parameters, null if there are none
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public string LoggerSwitchParameters
         {
             get
@@ -99,8 +144,23 @@ public string LoggerSwitchParameters
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Return the verbosity for this logger (from command line all loggers get same verbosity)
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public LoggerVerbosity Verbosity
         {
             get
diff --git a/src/Deprecated/Engine/Properties/BuildProperty.cs b/src/Deprecated/Engine/Properties/BuildProperty.cs
index a90066fefd3..00223fa2a44 100644
--- a/src/Deprecated/Engine/Properties/BuildProperty.cs
+++ b/src/Deprecated/Engine/Properties/BuildProperty.cs
@@ -56,11 +56,26 @@ internal enum PropertyType
     }
 
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// This class holds an MSBuild property.  This may be a property that is
     /// represented in the MSBuild project file by an XML element, or it
     /// may not be represented in any real XML file (e.g., global properties,
     /// environment properties, etc.)
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     /// <owner>rgoel</owner>
     [DebuggerDisplay("BuildProperty (Name = { Name }, Value = { Value }, FinalValue = { FinalValue }, Condition = { Condition })")]
     public class BuildProperty
@@ -332,12 +347,27 @@ PropertyType propertyType
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Constructor, which initializes the property from just the property
         /// name and value, creating it as a "normal" property.  This ends up
         /// creating a new XML element for the property under a dummy XML document.
         /// </summary>
         /// <param name="propertyName"></param>
         /// <param name="propertyValue"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>rgoel</owner>
         public BuildProperty
         (
@@ -353,6 +383,11 @@ string propertyValue
         #region Properties
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Accessor for the property name.  This is read-only, so one cannot
         /// change the property name once it's set ... your only option is
         /// to create a new BuildProperty object.  The reason is that BuildProperty objects
@@ -360,6 +395,16 @@ string propertyValue
         /// on the property name.  Modifying the property name of an existing
         /// BuildProperty object would make the hash table incorrect.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public string Name
         {
@@ -383,9 +428,24 @@ public string Name
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Accessor for the property value.  Normal properties can be modified;
         /// other property types cannot.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public string Value
         {
@@ -470,8 +530,23 @@ internal string FinalValueEscaped
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Returns the unescaped value of the property.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public string FinalValue
         {
@@ -503,8 +578,23 @@ internal PropertyType Type
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Did this property originate from an imported project file?
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public bool IsImported
         {
@@ -515,8 +605,23 @@ public bool IsImported
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Accessor for the condition on the property.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public string Condition
         {
@@ -626,6 +731,11 @@ private void MarkPropertyAsDirty
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Creates a shallow or deep clone of this BuildProperty object.
         ///
         /// A shallow clone points at the same XML element as the original, so
@@ -637,6 +747,16 @@ private void MarkPropertyAsDirty
         /// </summary>
         /// <param name="deepClone"></param>
         /// <returns></returns>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>rgoel</owner>
         public BuildProperty Clone
         (
@@ -709,8 +829,23 @@ BuildProperty compareToProperty
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Returns the property value.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public override string ToString
             (
@@ -724,11 +859,26 @@ public override string ToString
         #region Operators
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This allows an implicit typecast from a "BuildProperty" to a "string"
         /// when trying to access the property's value.
         /// </summary>
         /// <param name="propertyToCast"></param>
         /// <returns></returns>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>rgoel</owner>
         public static explicit operator string
         (
diff --git a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
index ecbd7f6b82b..38ca722ac49 100644
--- a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
+++ b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
@@ -18,12 +18,27 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// A BuildPropertyGroup is a collection of BuildProperty objects. This could be represented by a persisted &lt;PropertyGroup&gt;
     /// element in the project file, or it could be a virtual collection of properties, such as in the case of global properties,
     /// environment variable properties, or the final evaluated properties of a project. These two types of PropertyGroups
     /// (persisted and virtual) are handled differently by many of the methods in this class, but in order to reduce the number of
     /// concepts for the consumer of the OM, we've merged them into a single class.
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     /// <owner>RGoel</owner>
     [DebuggerDisplay("BuildPropertyGroup (Count = { Count }, Condition = { Condition })")]
     public class BuildPropertyGroup : IItemPropertyGrouping, IEnumerable
@@ -133,16 +148,46 @@ internal void CreateFromStream(BinaryReader reader)
         #region Constructors
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Default constructor, that creates an empty virtual (non-persisted) BuildPropertyGroup.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public BuildPropertyGroup()
             : this(null, 0)
         {
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Default constructor, that creates an empty virtual (non-persisted) BuildPropertyGroup.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public BuildPropertyGroup(Project parentProject)
             : this(parentProject, 0)
         {
@@ -316,11 +361,26 @@ bool importedFromAnotherProject
         #region Properties
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This returns a boolean telling you whether this particular property
         /// group was imported from another project, or whether it was defined
         /// in the main project.  For virtual property groups which have no
         /// persistence, this is false.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public bool IsImported
         {
@@ -331,8 +391,23 @@ public bool IsImported
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Accessor for the condition on the property group.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public string Condition
         {
@@ -359,8 +434,23 @@ public string Condition
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Allows setting the condition for imported property groups. Changes will not be persisted.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void SetImportedPropertyGroupCondition(string condition)
         {
             // If this BuildPropertyGroup object is not actually represented by a
@@ -456,8 +546,23 @@ internal XmlElement ParentElement
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// 
+        /// <xref:Microsoft.Build.Execution>
         /// Returns the number of properties contained in this BuildPropertyGroup.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public int Count
         {
@@ -524,6 +629,11 @@ internal string ImportedFromFilename
         #region Operators
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This is the indexer for the BuildPropertyGroup class, which allows the caller to set or get the property data using simple
         /// array indexer [] notation. The caller passes in the property name inside the [], and out comes the  BuildProperty object,
         /// which can be typecast to a string in order to get just the property value. Or if it's used on the left of the "="
@@ -533,6 +643,16 @@ internal string ImportedFromFilename
         /// <owner>RGoel</owner>
         /// <param name="propertyName"></param>
         /// <returns>The property with the given name, or null if it does not exist in this group</returns>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public BuildProperty this[string propertyName]
         {
             get
@@ -567,11 +687,26 @@ public BuildProperty this[string propertyName]
         #region Methods
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This IEnumerable method returns an IEnumerator object, which allows
         /// the caller to enumerate through the BuildProperty objects contained in
         /// this BuildPropertyGroup.
         /// </summary>
         /// <returns></returns>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public IEnumerator GetEnumerator
             (
@@ -609,6 +744,11 @@ internal BuildPropertyGroup ShallowClone()
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This method creates a copy of the BuildPropertyGroup. A shallow clone will reference the same BuildProperty objects as the
         /// original. A deep clone will deep clone the BuildProperty objects themselves. If this is a persisted BuildPropertyGroup, only
         /// deep clones are allowed, because you can't have the same XML element belonging to two parents.
@@ -616,6 +756,16 @@ internal BuildPropertyGroup ShallowClone()
         /// <owner>RGoel</owner>
         /// <param name="deepClone"></param>
         /// <returns>The cloned BuildPropertyGroup.</returns>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public BuildPropertyGroup Clone
         (
             bool deepClone
@@ -861,6 +1011,11 @@ BuildProperty newProperty
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Sets a property taking the property name and value as strings directly.
         ///
         /// Either overrides the value of the property with the given name, or adds it if it
@@ -873,18 +1028,43 @@ BuildProperty newProperty
         /// </summary>
         /// <param name="propertyName"></param>
         /// <param name="propertyValue"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public void SetProperty(string propertyName, string propertyValue)
         {
             this.SetProperty(new BuildProperty(propertyName, propertyValue));
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Sets a property in this PropertyGroup, optionally escaping the property value so
         /// that it will be treated as a literal.
         /// </summary>
         /// <param name="propertyName"></param>
         /// <param name="propertyValue"></param>
         /// <param name="treatPropertyValueAsLiteral"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public void SetProperty
             (
@@ -898,6 +1078,11 @@ bool treatPropertyValueAsLiteral
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// The AddNewProperty method adds a new property element to the persisted
         /// &lt;PropertyGroup&gt; at the end.  This method takes the property name and
         /// value as strings directly, so that the BuildProperty object can be created
@@ -906,6 +1091,16 @@ bool treatPropertyValueAsLiteral
         /// <param name="propertyName"></param>
         /// <param name="propertyValue"></param>
         /// <returns></returns>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public BuildProperty AddNewProperty
         (
@@ -926,6 +1121,11 @@ string propertyValue
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Adds a new property to the PropertyGroup, optionally escaping the property value so
         /// that it will be treated as a literal.
         /// </summary>
@@ -933,6 +1133,16 @@ string propertyValue
         /// <param name="propertyValue"></param>
         /// <param name="treatPropertyValueAsLiteral"></param>
         /// <returns></returns>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public BuildProperty AddNewProperty
             (
@@ -1025,10 +1235,25 @@ BuildProperty propertyToAdd
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Removes the given BuildProperty object from either a persisted or a virtual
         /// BuildPropertyGroup.
         /// </summary>
         /// <param name="property"></param>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public void RemoveProperty
         (
@@ -1069,9 +1294,24 @@ BuildProperty property
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Removes all properties with the given name from either a persisted or a virtual BuildPropertyGroup. For persisted
         /// PropertyGroups, there could be multiple. For a virtual BuildPropertyGroup, there can be only one.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         /// <param name="propertyName"></param>
         public void RemoveProperty
@@ -1245,8 +1485,23 @@ internal void ClearImportedPropertyGroup
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Removes all properties and conditions from this BuildPropertyGroup.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public void Clear
             (
diff --git a/src/Deprecated/Engine/Properties/BuildPropertyGroupCollection.cs b/src/Deprecated/Engine/Properties/BuildPropertyGroupCollection.cs
index 15751e39f9c..4404ad64c28 100644
--- a/src/Deprecated/Engine/Properties/BuildPropertyGroupCollection.cs
+++ b/src/Deprecated/Engine/Properties/BuildPropertyGroupCollection.cs
@@ -11,6 +11,11 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// This class represents a collection of persisted &lt;PropertyGroup&gt;'s.  Each
     /// MSBuild project has exactly one BuildPropertyGroupCollection, which includes
     /// all the imported PropertyGroups as well as the ones in the main project file.
@@ -19,6 +24,16 @@ namespace Microsoft.Build.BuildEngine
     /// calls into the GroupingCollection within the Project to do it's work.  It
     /// doesn't maintain any BuildPropertyGroup state on its own.
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     /// <owner>DavidLe</owner>
     public class BuildPropertyGroupCollection : ICollection, IEnumerable
     {
@@ -59,9 +74,24 @@ GroupingCollection groupingCollection
         #region Properties
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Read-only property which returns the number of PropertyGroups contained
         /// in our collection.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public int Count
         {
@@ -72,8 +102,23 @@ public int Count
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This ICollection property tells whether this object is thread-safe.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public bool IsSynchronized
         {
@@ -84,9 +129,24 @@ public bool IsSynchronized
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This ICollection property returns the object to be used to synchronize
         /// access to the class.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public object SyncRoot
         {
@@ -134,9 +194,24 @@ internal BuildPropertyGroup LastLocalPropertyGroup
         #region Methods
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This ICollection method copies the contents of this collection to an
         /// array.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public void CopyTo
         (
@@ -148,10 +223,25 @@ int index
         }
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// This IEnumerable method returns an IEnumerator object, which allows
         /// the caller to enumerate through the BuildPropertyGroup objects contained in
         /// this BuildPropertyGroupCollection.
         /// </summary>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         /// <owner>RGoel</owner>
         public IEnumerator GetEnumerator
             (
diff --git a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
index f8c02067a6f..2f0e9475f4c 100644
--- a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
@@ -19,8 +19,23 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
+    /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// <xref:Microsoft.Build.Construction>
+    /// <xref:Microsoft.Build.Evaluation>
+    /// <xref:Microsoft.Build.Execution>
+    /// 
     /// This class is used to generate an MSBuild wrapper project for a solution file or standalone VC project.
     /// </summary>
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!WARNING]
+    /// > This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+    /// > <xref:Microsoft.Build.Construction>
+    /// > <xref:Microsoft.Build.Evaluation>
+    /// > <xref:Microsoft.Build.Execution>
+    /// ]]></format>
+    /// </remarks>
     /// <owner>LukaszG, RGoel</owner>
     public static class SolutionWrapperProject
     {
@@ -31,6 +46,11 @@ public static class SolutionWrapperProject
         private const string cacheVersionNumber = "_SolutionProjectCacheVersion";
 
         /// <summary>
+        /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// <xref:Microsoft.Build.Construction>
+        /// <xref:Microsoft.Build.Evaluation>
+        /// <xref:Microsoft.Build.Execution>
+        /// 
         /// Given the full path to a solution, returns a string containing the v3.5 MSBuild-format
         /// wrapper project for that solution.
         /// </summary>
@@ -38,6 +58,16 @@ public static class SolutionWrapperProject
         /// <param name="toolsVersionOverride">May be null.  If non-null, contains the ToolsVersion passed in on the command line</param>\
         /// <param name="projectBuildEventContext">An event context for logging purposes.</param>
         /// <returns></returns>
+        /// <remarks>
+        /// <format type="text/markdown"><![CDATA[
+        /// ## Remarks
+        /// > [!WARNING]
+        /// > This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
+        /// > <xref:Microsoft.Build.Construction>
+        /// > <xref:Microsoft.Build.Evaluation>
+        /// > <xref:Microsoft.Build.Execution>
+        /// ]]></format>
+        /// </remarks>
         public static string Generate(string solutionPath, string toolsVersionOverride, BuildEventContext projectBuildEventContext)
         {
             Project msbuildProject = new Project();
diff --git a/src/Framework/Logging/AnsiDetector.cs b/src/Framework/Logging/AnsiDetector.cs
new file mode 100644
index 00000000000..2b0c0e8b38a
--- /dev/null
+++ b/src/Framework/Logging/AnsiDetector.cs
@@ -0,0 +1,53 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+// Portions of the code in this file were ported from the spectre.console by Patrik Svensson, Phil Scott, Nils Andresen
+// https://github.com/spectreconsole/spectre.console/blob/main/src/Spectre.Console/Internal/Backends/Ansi/AnsiDetector.cs
+// and from the supports-ansi project by Qingrong Ke
+// https://github.com/keqingrong/supports-ansi/blob/master/index.js
+
+using System;
+using System.Linq;
+using System.Text.RegularExpressions;
+
+namespace Microsoft.Build.Framework.Logging
+{
+    internal class AnsiDetector
+    {
+        private static readonly Regex[] terminalsRegexes =
+        {
+            new("^xterm"), // xterm, PuTTY, Mintty
+            new("^rxvt"), // RXVT
+            new("^(?!eterm-color).*eterm.*"), // Accepts eterm, but not eterm-color, which does not support moving the cursor, see #9950.
+            new("^screen"), // GNU screen, tmux
+            new("tmux"), // tmux
+            new("^vt100"), // DEC VT series
+            new("^vt102"), // DEC VT series
+            new("^vt220"), // DEC VT series
+            new("^vt320"), // DEC VT series
+            new("ansi"), // ANSI
+            new("scoansi"), // SCO ANSI
+            new("cygwin"), // Cygwin, MinGW
+            new("linux"), // Linux console
+            new("konsole"), // Konsole
+            new("bvterm"), // Bitvise SSH Client
+            new("^st-256color"), // Suckless Simple Terminal, st
+            new("alacritty"), // Alacritty
+        };
+
+        internal static bool IsAnsiSupported(string termType)
+        {
+            if (string.IsNullOrEmpty(termType))
+            {
+                return false;
+            }
+
+            if (terminalsRegexes.Any(regex => regex.IsMatch(termType)))
+            {
+                return true;
+            }
+
+            return false;
+        }
+    }
+}
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index 747a065590e..3cd7934c726 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -10,7 +10,7 @@
 using System.Reflection;
 using System.Runtime.InteropServices;
 using System.Runtime.Versioning;
-
+using Microsoft.Build.Framework.Logging;
 using Microsoft.Build.Shared;
 using Microsoft.Win32;
 using Microsoft.Win32.SafeHandles;
@@ -1493,8 +1493,8 @@ internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalC
         }
         else
         {
-            // On posix OSes we expect console always supports VT100 coloring unless it is explicitly marked as "dumb".
-            acceptAnsiColorCodes = Environment.GetEnvironmentVariable("TERM") != "dumb";
+            // On posix OSes detect whether the terminal supports VT100 from the value of the TERM environment variable.
+            acceptAnsiColorCodes = AnsiDetector.IsAnsiSupported(Environment.GetEnvironmentVariable("TERM"));
             // It wasn't redirected as tested above so we assume output is screen/console
             outputIsScreen = true;
         }
diff --git a/src/Framework/TaskParameterEventArgs.cs b/src/Framework/TaskParameterEventArgs.cs
index 7aa294f828c..8dcf97730c7 100644
--- a/src/Framework/TaskParameterEventArgs.cs
+++ b/src/Framework/TaskParameterEventArgs.cs
@@ -34,6 +34,8 @@ public class TaskParameterEventArgs : BuildMessageEventArgs
         /// </summary>
         public TaskParameterEventArgs(
             TaskParameterMessageKind kind,
+            string parameterName,
+            string propertyName,
             string itemType,
             IList items,
             bool logItemMetadata,
@@ -41,14 +43,57 @@ public TaskParameterEventArgs(
             : base(null, null, null, MessageImportance.Low, eventTimestamp)
         {
             Kind = kind;
+            ParameterName = parameterName;
+            PropertyName = propertyName;
             ItemType = itemType;
             Items = items;
             LogItemMetadata = logItemMetadata;
         }
 
+        /// <summary>
+        /// Creates an instance of this class for the given task parameter.
+        /// </summary>
+        public TaskParameterEventArgs(
+            TaskParameterMessageKind kind,
+            string itemType,
+            IList items,
+            bool logItemMetadata,
+            DateTime eventTimestamp)
+            : this(kind, parameterName: null, propertyName: null, itemType, items, logItemMetadata, eventTimestamp)
+        { }
+
+        /// <summary>
+        /// The kind of event represented by this instance.
+        /// </summary>
         public TaskParameterMessageKind Kind { get; private set; }
+
+        /// <summary>
+        /// The name of the parameter if <see cref="Kind"/> is <see cref="TaskParameterMessageKind.TaskInput"/> or <see cref="TaskParameterMessageKind.TaskOutput"/>,
+        /// null otherwise.
+        /// </summary>
+        public string ParameterName { get; private set; }
+
+        /// <summary>
+        /// The name of the property if <see cref="Kind"/> is <see cref="TaskParameterMessageKind.TaskOutput"/> and the task output
+        /// is assigned to a property, null otherwise.
+        /// </summary>
+        public string PropertyName { get; private set; }
+
+        /// <summary>
+        /// The name of the item being manipulated, e.g. "Compile" if this is an item operation. If this object represents a task input, this property should be set
+        /// to the same value as <see cref="ParameterName"/> for backward compatibility. Similarly, if this object represents a task output assigned to a property,
+        /// this should be set to the same value as <see cref="PropertyName"/> for backward compatibility.
+        /// </summary>
         public string ItemType { get; private set; }
+
+        /// <summary>
+        /// The values being manipulated (added, removed, passed to/from task).
+        /// </summary>
         public IList Items { get; private set; }
+
+        /// <summary>
+        /// True if the <see cref="Message"/> string should include metadata.
+        /// </summary>
         public bool LogItemMetadata { get; private set; }
 
         /// <summary>
@@ -85,6 +130,8 @@ internal override void CreateFromStream(BinaryReader reader, int version)
             RawTimestamp = reader.ReadTimestamp();
             BuildEventContext = reader.ReadOptionalBuildEventContext();
             Kind = (TaskParameterMessageKind)reader.Read7BitEncodedInt();
+            ParameterName = reader.ReadOptionalString();
+            PropertyName = reader.ReadOptionalString();
             ItemType = reader.ReadOptionalString();
             LineNumber = reader.Read7BitEncodedInt();
             ColumnNumber = reader.Read7BitEncodedInt();
@@ -134,6 +181,8 @@ internal override void WriteToStream(BinaryWriter writer)
             writer.WriteTimestamp(RawTimestamp);
             writer.WriteOptionalBuildEventContext(BuildEventContext);
             writer.Write7BitEncodedInt((int)Kind);
+            writer.WriteOptionalString(ParameterName);
+            writer.WriteOptionalString(PropertyName);
             writer.WriteOptionalString(ItemType);
             writer.Write7BitEncodedInt(LineNumber);
             writer.Write7BitEncodedInt(ColumnNumber);
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index f396ca22cfe..b84cdc9dcd6 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -194,7 +194,6 @@
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework' AND '$(DotNetBuildFromSource)' != 'true'">
     <!-- Bump these to the latest version despite transitive references to older -->
     <PackageReference Include="System.Private.Uri" PrivateAssets="all" />
-    <PackageReference Include="System.Runtime" PrivateAssets="all" />
   </ItemGroup>
   <ItemGroup>
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 186e3c18a53..83b48d2558c 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -1869,6 +1869,7 @@ elementFormDefault="qualified">
     <xs:element name="LangVersion" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="VBRuntime" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="Prefer32Bit" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="PreferNativeArm64" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="HighEntropyVA" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="LinkIncremental" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ManifestCertificateThumbprint" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
diff --git a/src/MSBuild/TerminalLogger/Terminal.cs b/src/MSBuild/TerminalLogger/Terminal.cs
index 91565e1f797..16651d85fb9 100644
--- a/src/MSBuild/TerminalLogger/Terminal.cs
+++ b/src/MSBuild/TerminalLogger/Terminal.cs
@@ -200,6 +200,15 @@ public void WriteColorLine(TerminalColor color, string text)
     /// <inheritdoc/>
     public void Dispose()
     {
-        Console.OutputEncoding = _originalOutputEncoding;
+        try
+        {
+            Console.OutputEncoding = _originalOutputEncoding;
+        }
+        catch
+        {
+            // In some terminal emulators setting back the previous console output encoding fails.
+            // See https://github.com/dotnet/msbuild/issues/9662.
+            // We do not want to throw an exception if it happens, since it is a non-essentual failure in the logger.
+        }
     }
 }
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 6634af8df2f..470c4c7dd7d 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -136,6 +136,9 @@
     <Compile Include="..\Framework\NativeMethods.cs">
       <Link>NativeMethodsShared.cs</Link>
     </Compile>
+    <Compile Include="..\Framework\Logging\AnsiDetector.cs">
+      <Link>AnsiDetector.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\NodeBuildComplete.cs">
       <Link>NodeBuildComplete.cs</Link>
     </Compile>
diff --git a/src/Shared/ExceptionHandling.cs b/src/Shared/ExceptionHandling.cs
index f8601953836..5e2425fa76d 100644
--- a/src/Shared/ExceptionHandling.cs
+++ b/src/Shared/ExceptionHandling.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 #nullable disable
@@ -335,39 +335,49 @@ internal static void UnhandledExceptionHandler(object sender, UnhandledException
         /// </summary>
         internal static void DumpExceptionToFile(Exception ex)
         {
-            // Locking on a type is not recommended.  However, we are doing it here to be extra cautious about compatibility because
-            //  this method previously had a [MethodImpl(MethodImplOptions.Synchronized)] attribute, which does lock on the type when
-            //  applied to a static method.
-            lock (typeof(ExceptionHandling))
+            try
             {
-                if (s_dumpFileName == null)
+                // Locking on a type is not recommended.  However, we are doing it here to be extra cautious about compatibility because
+                //  this method previously had a [MethodImpl(MethodImplOptions.Synchronized)] attribute, which does lock on the type when
+                //  applied to a static method.
+                lock (typeof(ExceptionHandling))
                 {
-                    Guid guid = Guid.NewGuid();
-
-                    // For some reason we get Watson buckets because GetTempPath gives us a folder here that doesn't exist.
-                    // Either because %TMP% is misdefined, or because they deleted the temp folder during the build.
-                    // If this throws, no sense catching it, we can't log it now, and we're here
-                    // because we're a child node with no console to log to, so die
-                    Directory.CreateDirectory(DebugDumpPath);
-
-                    var pid = Process.GetCurrentProcess().Id;
-                    // This naming pattern is assumed in ReadAnyExceptionFromFile
-                    s_dumpFileName = Path.Combine(DebugDumpPath, $"MSBuild_pid-{pid}_{guid:n}.failure.txt");
+                    if (s_dumpFileName == null)
+                    {
+                        Guid guid = Guid.NewGuid();
+
+                        // For some reason we get Watson buckets because GetTempPath gives us a folder here that doesn't exist.
+                        // Either because %TMP% is misdefined, or because they deleted the temp folder during the build.
+                        // If this throws, no sense catching it, we can't log it now, and we're here
+                        // because we're a child node with no console to log to, so die
+                        Directory.CreateDirectory(DebugDumpPath);
+
+                        var pid = Process.GetCurrentProcess().Id;
+                        // This naming pattern is assumed in ReadAnyExceptionFromFile
+                        s_dumpFileName = Path.Combine(DebugDumpPath, $"MSBuild_pid-{pid}_{guid:n}.failure.txt");
+
+                        using (StreamWriter writer = FileUtilities.OpenWrite(s_dumpFileName, append: true))
+                        {
+                            writer.WriteLine("UNHANDLED EXCEPTIONS FROM PROCESS {0}:", pid);
+                            writer.WriteLine("=====================");
+                        }
+                    }
 
                     using (StreamWriter writer = FileUtilities.OpenWrite(s_dumpFileName, append: true))
                     {
-                        writer.WriteLine("UNHANDLED EXCEPTIONS FROM PROCESS {0}:", pid);
-                        writer.WriteLine("=====================");
+                        // "G" format is, e.g., 6/15/2008 9:15:07 PM
+                        writer.WriteLine(DateTime.Now.ToString("G", CultureInfo.CurrentCulture));
+                        writer.WriteLine(ex.ToString());
+                        writer.WriteLine("===================");
                     }
                 }
-
-                using (StreamWriter writer = FileUtilities.OpenWrite(s_dumpFileName, append: true))
-                {
-                    // "G" format is, e.g., 6/15/2008 9:15:07 PM
-                    writer.WriteLine(DateTime.Now.ToString("G", CultureInfo.CurrentCulture));
-                    writer.WriteLine(ex.ToString());
-                    writer.WriteLine("===================");
-                }
+            }
+            
+            // Some customers experience exceptions such as 'OutOfMemory' errors when msbuild attempts to log errors to a local file.
+            // This catch helps to prevent the application from crashing in this best-effort dump-diagnostics path,
+            // but doesn't prevent the overall crash from going to Watson.
+            catch
+            {
             }
         }
 
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index 3a67481a23e..0eacfd24c73 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -1458,7 +1458,7 @@ internal static string GetDirectoryNameOfFileAbove(string startingDirectory, str
             while (lookInDirectory != null);
 
             // When we didn't find the location, then return an empty string
-            return String.Empty;
+            return string.Empty;
         }
 
         /// <summary>
diff --git a/src/Tasks.UnitTests/AddToWin32Manifest_Tests.cs b/src/Tasks.UnitTests/AddToWin32Manifest_Tests.cs
new file mode 100644
index 00000000000..2de044bbddd
--- /dev/null
+++ b/src/Tasks.UnitTests/AddToWin32Manifest_Tests.cs
@@ -0,0 +1,194 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using System.Runtime.InteropServices;
+using System.Runtime.Versioning;
+using System.Xml;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.UnitTests;
+using Microsoft.Build.Utilities;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace Microsoft.Build.Tasks.UnitTests
+{
+    public class AddToWin32Manifest_Tests
+    {
+        private static string TestAssetsRootPath { get; } = Path.Combine(
+            Path.GetDirectoryName(typeof(AddToWin32Manifest_Tests).Assembly.Location) ?? AppContext.BaseDirectory,
+            "TestResources",
+            "Manifests");
+
+        private readonly ITestOutputHelper _testOutput;
+
+        public AddToWin32Manifest_Tests(ITestOutputHelper testOutput) => _testOutput = testOutput;
+
+        [Theory]
+        [InlineData("testManifestWithInvalidSupportedArchs.manifest", false)]
+        [InlineData("testManifestWithApplicationDefined.manifest", true)]
+        [InlineData("testManifestSavesTheCurrentNodesPositions.manifest", true)]
+        [InlineData("testManifestNoPrefixes.manifest", true)]
+        [InlineData(null, true)]
+        public void ManifestPopulationCheck(string manifestName, bool expectedResult)
+        {
+            AddToWin32Manifest task = new AddToWin32Manifest()
+            {
+                BuildEngine = new MockEngine(_testOutput)
+            };
+
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                var tempOutput = env.CreateFolder().Path;
+                task.OutputDirectory = tempOutput;
+                task.SupportedArchitectures = "amd64 arm64";
+                if (!string.IsNullOrEmpty(manifestName))
+                {
+                    task.ApplicationManifest = new TaskItem(Path.Combine(TestAssetsRootPath, manifestName));
+                }
+
+                var result = task.Execute();
+
+                result.ShouldBe(expectedResult);
+
+                if (result)
+                {
+                    string generatedManifest = task.ManifestPath;
+                    string expectedManifest = Path.Combine(TestAssetsRootPath, $"{manifestName ?? "default.win32manifest"}_expected");
+
+                    XmlDocument expectedDoc = new XmlDocument();
+                    XmlDocument actualDoc = new XmlDocument();
+
+                    expectedDoc.Load(expectedManifest);
+                    actualDoc.Load(generatedManifest);
+
+                    expectedDoc.OuterXml.ShouldBe(actualDoc.OuterXml);
+                    expectedDoc.InnerXml.ShouldBe(actualDoc.InnerXml);
+                }
+            }
+        }
+
+        [SupportedOSPlatform("windows")]
+        [WindowsOnlyTheory]
+        [InlineData(null, true)]
+        [InlineData("buildIn.manifest", true)]
+        [InlineData("testManifestWithValidSupportedArchs.manifest", true)]
+        public void E2EScenarioTests(string manifestName, bool expectedResult)
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                var outputPath = env.CreateFolder().Path;
+                string projectContent = @$"
+                <Project DefaultTargets=""Build"">
+                    <Import Project=""$(MSBuildBinPath)\Microsoft.Common.props"" />
+
+                    <PropertyGroup>
+                        <Platform>AnyCPU</Platform>
+                        <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
+                        <OutputType>Library</OutputType>
+                        <PreferNativeArm64>true</PreferNativeArm64>
+                        <Prefer32Bit>false</Prefer32Bit>
+                        {(!string.IsNullOrEmpty(manifestName) ? $"<ApplicationManifest>{manifestName}</ApplicationManifest>" : "")}
+                        <IntermediateOutputPath>{outputPath}</IntermediateOutputPath>
+                    </PropertyGroup>
+
+                    <Target Name=""Build""/>
+                    <Import Project=""$(MSBuildBinPath)\Microsoft.CSharp.targets"" />
+
+                </Project>
+                ";
+
+                var projectFolder = env.CreateFolder();
+                var projectFile = env.CreateFile(projectFolder, "test.csproj", projectContent).Path;
+
+                // copy application manifest
+                if (!string.IsNullOrEmpty(manifestName))
+                {
+                    File.Copy(Path.Combine(TestAssetsRootPath, manifestName), Path.Combine(projectFolder.Path, manifestName));
+                }
+
+                Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(projectFile, touchProject: false);
+
+                bool result = project.Build(new MockLogger(_testOutput));
+                result.ShouldBe(expectedResult);
+
+                // #2 - represents the name for native resource (Win 32 resource), #24 - the type (Manifest) 
+                byte[]? actualManifestBytes = AssemblyNativeResourceManager.GetResourceFromExecutable(Path.Combine(outputPath, "test.dll"), "#2", "#24");
+
+                // check manifest content
+                if (actualManifestBytes != null)
+                {
+                    string expectedManifest = Path.Combine(TestAssetsRootPath, $"{manifestName ?? "default.win32manifest"}_expected");
+
+                    XmlDocument expectedDoc = new XmlDocument();
+                    XmlDocument actualDoc = new XmlDocument();
+
+                    expectedDoc.Load(expectedManifest);
+                    using (MemoryStream stream = new MemoryStream(actualManifestBytes))
+                    {
+                        actualDoc.Load(stream);
+                    }
+
+                    NormalizeLineEndings(expectedDoc.OuterXml).ShouldBe(NormalizeLineEndings(actualDoc.OuterXml));
+                    NormalizeLineEndings(expectedDoc.InnerText).ShouldBe(NormalizeLineEndings(actualDoc.InnerText));
+                }
+            }
+
+            static string NormalizeLineEndings(string input) => input.Replace("\r\n", "\n").Replace("\r", "\n");
+        }
+
+        [SupportedOSPlatform("windows")]
+        internal sealed class AssemblyNativeResourceManager
+        {
+            public enum LoadLibraryFlags : uint { LOAD_LIBRARY_AS_DATAFILE = 2 };
+
+            [DllImport("Kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
+            public static extern IntPtr LoadLibrary(string lpFileName, IntPtr hReservedNull, LoadLibraryFlags dwFlags);
+
+            [DllImport("kernel32.dll", SetLastError = true)]
+            public static extern IntPtr FindResource(IntPtr hModule, string lpName, string lpType);
+
+            [DllImport("kernel32.dll", SetLastError = true)]
+            public static extern IntPtr LoadResource(IntPtr hModule, IntPtr hResInfo);
+
+            [DllImport("kernel32.dll", SetLastError = true)]
+            public static extern IntPtr LockResource(IntPtr hResData);
+
+            [DllImport("kernel32.dll", SetLastError = true)]
+            public static extern uint SizeofResource(IntPtr hModule, IntPtr hResInfo);
+
+            public static byte[]? GetResourceFromExecutable(string assembly, string lpName, string lpType)
+            {
+                IntPtr hModule = LoadLibrary(assembly, IntPtr.Zero, LoadLibraryFlags.LOAD_LIBRARY_AS_DATAFILE);
+                try
+                {
+                    if (hModule != IntPtr.Zero)
+                    {
+                        IntPtr hResource = FindResource(hModule, lpName, lpType);
+                        if (hResource != IntPtr.Zero)
+                        {
+                            uint resSize = SizeofResource(hModule, hResource);
+                            IntPtr resData = LoadResource(hModule, hResource);
+                            if (resData != IntPtr.Zero)
+                            {
+                                byte[] uiBytes = new byte[resSize];
+                                IntPtr ipMemorySource = LockResource(resData);
+                                Marshal.Copy(ipMemorySource, uiBytes, 0, (int)resSize);
+
+                                return uiBytes;
+                            }
+                        }
+                    }
+                }
+                finally
+                {
+                    NativeMethodsShared.FreeLibrary(hModule);
+                }
+
+                return null;
+            }
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/MSBuildInternalMessage_Tests.cs b/src/Tasks.UnitTests/MSBuildInternalMessage_Tests.cs
new file mode 100644
index 00000000000..c03a9e2cde1
--- /dev/null
+++ b/src/Tasks.UnitTests/MSBuildInternalMessage_Tests.cs
@@ -0,0 +1,63 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Shared;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace Microsoft.Build.Tasks.UnitTests
+{
+    public class MSBuildInternalMessage_Tests
+    {
+        private readonly ITestOutputHelper _testOutput;
+
+        public MSBuildInternalMessage_Tests(ITestOutputHelper testOutput) => _testOutput = testOutput;
+
+        [Theory]
+        [InlineData(true, true, "CommonTarget.Prefer32BitAndPreferNativeArm64Enabled", false)]
+        [InlineData(false, false, "CommonTarget.PlatformIsAnyCPUAndPreferNativeArm64Enabled", true, new[] { "Release" })]
+        public void E2EScenarioTests(bool prefer32, bool isPlatformAnyCpu, string expectedResourceName, bool isNetWarningExpected, string[]? formatArgs = null)
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                var outputPath = env.CreateFolder().Path;
+                string projectContent = @$"
+                <Project DefaultTargets=""Build"">
+                    <Import Project=""$(MSBuildBinPath)\Microsoft.Common.props"" />
+
+                    <PropertyGroup>
+                        <Platform>{(isPlatformAnyCpu ? "AnyCPU" : "Release")}</Platform>
+                        <OutputType>Library</OutputType>
+                        <PreferNativeArm64>true</PreferNativeArm64>
+                        <Prefer32Bit>{(prefer32 ? "true" : "false")}</Prefer32Bit>
+                    </PropertyGroup>
+
+                    <Target Name=""Build""/>
+                    <Import Project=""$(MSBuildBinPath)\Microsoft.CSharp.targets"" />
+
+                </Project>
+                ";
+
+                var projectFile = env.CreateFile(env.CreateFolder(), "test.csproj", projectContent).Path;
+                Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(projectFile, touchProject: false);
+
+                string expectedBuildMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(expectedResourceName, formatArgs);
+                MockLogger logger = new MockLogger(_testOutput);
+
+                project.Build(logger);
+
+                if (isNetWarningExpected)
+                {
+                    logger.Warnings[0].RawMessage.ShouldBe(expectedBuildMessage);
+                }
+                else
+                {
+                    logger.Errors[0].RawMessage.ShouldBe(expectedBuildMessage);
+                }
+            }
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index 2c1fca47574..81b5048f0f7 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -152,6 +152,9 @@
     <None Update="TestResources\lorem.bin">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </None>
+    <None Update="TestResources\Manifests\*">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </None>
     <None Update="TestResources\mycert.pfx">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </None>
diff --git a/src/Tasks.UnitTests/TestResources/Manifests/buildIn.manifest b/src/Tasks.UnitTests/TestResources/Manifests/buildIn.manifest
new file mode 100644
index 00000000000..c8f1c0d76c7
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/Manifests/buildIn.manifest
@@ -0,0 +1,69 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
+    <assemblyIdentity version="1.0.0.0" name="MyApplication.app" />
+    <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
+        <security>
+            <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
+                <!-- UAC Manifest Options
+             If you want to change the Windows User Account Control level replace the 
+             requestedExecutionLevel node with one of the following.
+
+        <requestedExecutionLevel  level="asInvoker" uiAccess="false" />
+        <requestedExecutionLevel  level="requireAdministrator" uiAccess="false" />
+        <requestedExecutionLevel  level="highestAvailable" uiAccess="false" />
+
+            Specifying requestedExecutionLevel element will disable file and registry virtualization. 
+            Remove this element if your application requires this virtualization for backwards
+            compatibility.
+        -->
+                <requestedExecutionLevel level="asInvoker" uiAccess="false" />
+            </requestedPrivileges>
+        </security>
+    </trustInfo>
+    <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
+        <application>
+            <!-- A list of the Windows versions that this application has been tested on
+           and is designed to work with. Uncomment the appropriate elements
+           and Windows will automatically select the most compatible environment. -->
+            <!-- Windows Vista -->
+            <!--<supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}" />-->
+            <!-- Windows 7 -->
+            <!--<supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}" />-->
+            <!-- Windows 8 -->
+            <!--<supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}" />-->
+            <!-- Windows 8.1 -->
+            <!--<supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}" />-->
+            <!-- Windows 10 -->
+            <!--<supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}" />-->
+        </application>
+    </compatibility>
+    <!-- Indicates that the application is DPI-aware and will not be automatically scaled by Windows at higher
+       DPIs. Windows Presentation Foundation (WPF) applications are automatically DPI-aware and do not need 
+       to opt in. Windows Forms applications targeting .NET Framework 4.6 that opt into this setting, should 
+       also set the 'EnableWindowsFormsHighDpiAutoResizing' setting to 'true' in their app.config. 
+       
+       Makes the application long-path aware. See https://docs.microsoft.com/windows/win32/fileio/maximum-file-path-limitation -->
+    <!--
+  <application xmlns="urn:schemas-microsoft-com:asm.v3">
+    <windowsSettings>
+      <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true</dpiAware>
+      <longPathAware xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">true</longPathAware>
+    </windowsSettings>
+  </application>
+  -->
+    <!-- Enable themes for Windows common controls and dialogs (Windows XP and later) -->
+    <!--
+  <dependency>
+    <dependentAssembly>
+      <assemblyIdentity
+          type="win32"
+          name="Microsoft.Windows.Common-Controls"
+          version="6.0.0.0"
+          processorArchitecture="*"
+          publicKeyToken="6595b64144ccf1df"
+          language="*"
+        />
+    </dependentAssembly>
+  </dependency>
+  -->
+</assembly>
diff --git a/src/Tasks.UnitTests/TestResources/Manifests/buildIn.manifest_expected b/src/Tasks.UnitTests/TestResources/Manifests/buildIn.manifest_expected
new file mode 100644
index 00000000000..08194699912
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/Manifests/buildIn.manifest_expected
@@ -0,0 +1,72 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
+    <assemblyIdentity version="1.0.0.0" name="MyApplication.app" />
+    <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
+        <security>
+            <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
+                <!-- UAC Manifest Options
+             If you want to change the Windows User Account Control level replace the 
+             requestedExecutionLevel node with one of the following.
+
+        <requestedExecutionLevel  level="asInvoker" uiAccess="false" />
+        <requestedExecutionLevel  level="requireAdministrator" uiAccess="false" />
+        <requestedExecutionLevel  level="highestAvailable" uiAccess="false" />
+
+            Specifying requestedExecutionLevel element will disable file and registry virtualization. 
+            Remove this element if your application requires this virtualization for backwards
+            compatibility.
+        -->
+                <requestedExecutionLevel level="asInvoker" uiAccess="false" />
+            </requestedPrivileges>
+        </security>
+    </trustInfo>
+    <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
+        <application>
+            <!-- A list of the Windows versions that this application has been tested on
+           and is designed to work with. Uncomment the appropriate elements
+           and Windows will automatically select the most compatible environment. -->
+            <!-- Windows Vista -->
+            <!--<supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}" />-->
+            <!-- Windows 7 -->
+            <!--<supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}" />-->
+            <!-- Windows 8 -->
+            <!--<supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}" />-->
+            <!-- Windows 8.1 -->
+            <!--<supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}" />-->
+            <!-- Windows 10 -->
+            <!--<supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}" />-->
+            <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2024/WindowsSettings" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
+                <supportedArchitectures>amd64 arm64</supportedArchitectures>
+            </asmv3:windowsSettings>
+        </application>
+    </compatibility>
+    <!-- Indicates that the application is DPI-aware and will not be automatically scaled by Windows at higher
+       DPIs. Windows Presentation Foundation (WPF) applications are automatically DPI-aware and do not need 
+       to opt in. Windows Forms applications targeting .NET Framework 4.6 that opt into this setting, should 
+       also set the 'EnableWindowsFormsHighDpiAutoResizing' setting to 'true' in their app.config. 
+       
+       Makes the application long-path aware. See https://docs.microsoft.com/windows/win32/fileio/maximum-file-path-limitation -->
+    <!--
+  <application xmlns="urn:schemas-microsoft-com:asm.v3">
+    <windowsSettings>
+      <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true</dpiAware>
+      <longPathAware xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">true</longPathAware>
+    </windowsSettings>
+  </application>
+  -->
+    <!-- Enable themes for Windows common controls and dialogs (Windows XP and later) -->
+    <!--
+  <dependency>
+    <dependentAssembly>
+      <assemblyIdentity
+          type="win32"
+          name="Microsoft.Windows.Common-Controls"
+          version="6.0.0.0"
+          processorArchitecture="*"
+          publicKeyToken="6595b64144ccf1df"
+          language="*"
+        />
+    </dependentAssembly>
+  </dependency>
+  -->
+</assembly>
diff --git a/src/Tasks.UnitTests/TestResources/Manifests/default.win32manifest_expected b/src/Tasks.UnitTests/TestResources/Manifests/default.win32manifest_expected
new file mode 100644
index 00000000000..d48062a4e72
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/Manifests/default.win32manifest_expected
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8" standalone="yes"?>
+<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
+  <assemblyIdentity version="1.0.0.0" name="MyApplication.app"/>
+  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
+    <security>
+      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
+        <requestedExecutionLevel level="asInvoker" uiAccess="false"/>
+      </requestedPrivileges>
+    </security>
+  </trustInfo>
+  <asmv3:application xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
+    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2024/WindowsSettings">
+      <supportedArchitectures>amd64 arm64</supportedArchitectures>
+    </asmv3:windowsSettings>
+  </asmv3:application>
+</assembly>
diff --git a/src/Tasks.UnitTests/TestResources/Manifests/testManifestNoPrefixes.manifest b/src/Tasks.UnitTests/TestResources/Manifests/testManifestNoPrefixes.manifest
new file mode 100644
index 00000000000..70349317bc2
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/Manifests/testManifestNoPrefixes.manifest
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8" standalone="yes"?>
+<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
+    <application xmlns="urn:schemas-microsoft-com:asm.v3">
+        <windowsSettings xmlns="http://schemas.microsoft.com/SMI/2024/WindowsSettings">
+            <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true</dpiAware>
+            <longPathAware xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">true</longPathAware>
+        </windowsSettings>
+    </application>
+</assembly>
diff --git a/src/Tasks.UnitTests/TestResources/Manifests/testManifestNoPrefixes.manifest_expected b/src/Tasks.UnitTests/TestResources/Manifests/testManifestNoPrefixes.manifest_expected
new file mode 100644
index 00000000000..3c8e87cc046
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/Manifests/testManifestNoPrefixes.manifest_expected
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8" standalone="yes"?>
+<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
+    <application xmlns="urn:schemas-microsoft-com:asm.v3">
+        <windowsSettings xmlns="http://schemas.microsoft.com/SMI/2024/WindowsSettings">
+            <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true</dpiAware>
+            <longPathAware xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">true</longPathAware>
+            <supportedArchitectures>amd64 arm64</supportedArchitectures>
+        </windowsSettings>
+    </application>
+</assembly>
diff --git a/src/Tasks.UnitTests/TestResources/Manifests/testManifestSavesTheCurrentNodesPositions.manifest b/src/Tasks.UnitTests/TestResources/Manifests/testManifestSavesTheCurrentNodesPositions.manifest
new file mode 100644
index 00000000000..4c722f2df60
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/Manifests/testManifestSavesTheCurrentNodesPositions.manifest
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8" standalone="yes"?>
+<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
+  <asmv3:application xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
+    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2024/WindowsSettings">
+    </asmv3:windowsSettings>
+  </asmv3:application>
+  <testNode>
+    <nestedTest>test</nestedTest>   
+  </testNode>
+</assembly>
diff --git a/src/Tasks.UnitTests/TestResources/Manifests/testManifestSavesTheCurrentNodesPositions.manifest_expected b/src/Tasks.UnitTests/TestResources/Manifests/testManifestSavesTheCurrentNodesPositions.manifest_expected
new file mode 100644
index 00000000000..5213064fcba
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/Manifests/testManifestSavesTheCurrentNodesPositions.manifest_expected
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8" standalone="yes"?>
+<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
+    <asmv3:application xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
+        <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2024/WindowsSettings">
+            <supportedArchitectures>amd64 arm64</supportedArchitectures>
+        </asmv3:windowsSettings>
+    </asmv3:application>
+    <testNode>
+        <nestedTest>test</nestedTest>
+    </testNode>
+</assembly>
diff --git a/src/Tasks.UnitTests/TestResources/Manifests/testManifestWithApplicationDefined.manifest b/src/Tasks.UnitTests/TestResources/Manifests/testManifestWithApplicationDefined.manifest
new file mode 100644
index 00000000000..bc8eb93d98a
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/Manifests/testManifestWithApplicationDefined.manifest
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8" standalone="yes"?>
+<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
+  <asmv3:application xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
+    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2024/WindowsSettings">
+    </asmv3:windowsSettings>
+  </asmv3:application>
+</assembly>
diff --git a/src/Tasks.UnitTests/TestResources/Manifests/testManifestWithApplicationDefined.manifest_expected b/src/Tasks.UnitTests/TestResources/Manifests/testManifestWithApplicationDefined.manifest_expected
new file mode 100644
index 00000000000..7d2897b86ab
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/Manifests/testManifestWithApplicationDefined.manifest_expected
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8" standalone="yes"?>
+<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
+  <asmv3:application xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
+    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2024/WindowsSettings">
+       <supportedArchitectures>amd64 arm64</supportedArchitectures>
+    </asmv3:windowsSettings>
+  </asmv3:application>
+</assembly>
diff --git a/src/Tasks.UnitTests/TestResources/Manifests/testManifestWithInvalidSupportedArchs.manifest b/src/Tasks.UnitTests/TestResources/Manifests/testManifestWithInvalidSupportedArchs.manifest
new file mode 100644
index 00000000000..951ab4c1734
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/Manifests/testManifestWithInvalidSupportedArchs.manifest
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8" standalone="yes"?>
+<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
+  <asmv3:application xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
+    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2024/WindowsSettings">
+      <supportedArchitectures>dummy</supportedArchitectures>
+    </asmv3:windowsSettings>
+  </asmv3:application>
+</assembly>
diff --git a/src/Tasks.UnitTests/TestResources/Manifests/testManifestWithValidSupportedArchs.manifest b/src/Tasks.UnitTests/TestResources/Manifests/testManifestWithValidSupportedArchs.manifest
new file mode 100644
index 00000000000..2662a0c776d
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/Manifests/testManifestWithValidSupportedArchs.manifest
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8" standalone="yes"?>
+<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
+  <asmv3:application xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
+    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2024/WindowsSettings">
+      <supportedArchitectures>amd64 arm64</supportedArchitectures>
+      <test></test>
+    </asmv3:windowsSettings>
+  </asmv3:application>
+</assembly>
diff --git a/src/Tasks.UnitTests/TestResources/Manifests/testManifestWithValidSupportedArchs.manifest_expected b/src/Tasks.UnitTests/TestResources/Manifests/testManifestWithValidSupportedArchs.manifest_expected
new file mode 100644
index 00000000000..2662a0c776d
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/Manifests/testManifestWithValidSupportedArchs.manifest_expected
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8" standalone="yes"?>
+<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
+  <asmv3:application xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
+    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2024/WindowsSettings">
+      <supportedArchitectures>amd64 arm64</supportedArchitectures>
+      <test></test>
+    </asmv3:windowsSettings>
+  </asmv3:application>
+</assembly>
diff --git a/src/Tasks/AddToWin32Manifest.cs b/src/Tasks/AddToWin32Manifest.cs
new file mode 100644
index 00000000000..50aeaba4434
--- /dev/null
+++ b/src/Tasks/AddToWin32Manifest.cs
@@ -0,0 +1,252 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using System.Text;
+using System.Xml;
+
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
+using Microsoft.Build.Utilities;
+
+namespace Microsoft.Build.Tasks
+{
+    /// <summary>
+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.
+    /// </summary>
+    public sealed class AddToWin32Manifest : TaskExtension
+    {
+        private const string supportedArchitectures = "supportedArchitectures";
+        private const string windowsSettings = "windowsSettings";
+        private const string application = "application";
+        private const string asmv3Prefix = "asmv3";
+        private const string DefaultManifestName = "default.win32manifest";
+        private const string WindowsSettingsNamespace = "http://schemas.microsoft.com/SMI/2024/WindowsSettings";
+
+        private string _outputDirectory = string.Empty;
+        private string _supportedArchitectures = string.Empty;
+        private string _generatedManifestFullPath = string.Empty;
+
+        /// <summary>
+        /// Represents the result of validating an application manifest.
+        /// </summary>
+        private enum ManifestValidationResult
+        {
+            /// <summary>
+            /// The manifest validation was successful.
+            /// </summary>
+            Success = 1,
+
+            /// <summary>
+            /// The manifest validation failed.
+            /// </summary>
+            Failure,
+
+            /// <summary>
+            /// The supported architectures exist in the manifest with the expected value.
+            /// </summary>
+            SupportedArchitecturesExists,
+        }
+
+        /// <summary>
+        /// Existing application manifest.
+        /// </summary>
+        public ITaskItem? ApplicationManifest { get; set; }
+
+        /// <summary>
+        /// Intermediate output directory.
+        /// </summary>
+        [Required]
+        public string OutputDirectory
+        {
+            get => _outputDirectory;
+            set => _outputDirectory = value ?? throw new ArgumentNullException(nameof(OutputDirectory));
+        }
+
+        /// <summary>
+        /// Value for supportedArchitectures node.
+        /// </summary>
+        [Required]
+        public string SupportedArchitectures
+        {
+            get => _supportedArchitectures;
+            set => _supportedArchitectures = value ?? throw new ArgumentNullException(nameof(SupportedArchitectures));
+        }
+
+        /// <summary>
+        /// Returns path to the generated manifest.
+        /// </summary>
+        [Output]
+        public string ManifestPath
+        {
+            get => _generatedManifestFullPath;
+            private set => _generatedManifestFullPath = value;
+        }
+
+        private string? GetManifestPath()
+        {
+            if (ApplicationManifest != null)
+            {
+                if (string.IsNullOrEmpty(ApplicationManifest.ItemSpec) || !File.Exists(ApplicationManifest?.ItemSpec))
+                {
+                    Log.LogErrorWithCodeFromResources(null, ApplicationManifest?.ItemSpec, 0, 0, 0, 0, "AddToWin32Manifest.SpecifiedApplicationManifestCanNotBeFound");
+                    return null;
+                }
+
+                return ApplicationManifest!.ItemSpec;
+            }
+
+            string? defaultManifestPath = ToolLocationHelper.GetPathToDotNetFrameworkFile(DefaultManifestName, TargetDotNetFrameworkVersion.Version46);
+
+            return defaultManifestPath;
+        }
+
+        private Stream? GetManifestStream(string? path)
+        {
+            // The logic for getting default manifest is similar to the one from Roslyn:
+            // If Roslyn logic returns null, we fall back to reading embedded manifest.
+            return path is null
+                    ? typeof(AddToWin32Manifest).Assembly.GetManifestResourceStream($"Microsoft.Build.Tasks.Resources.{DefaultManifestName}")
+                    : File.OpenRead(path);
+        }
+
+        public override bool Execute()
+        {
+            string? manifestPath = GetManifestPath();
+            try
+            {
+                using Stream? stream = GetManifestStream(manifestPath);
+
+                if (stream is null)
+                {
+                    Log.LogErrorWithCodeFromResources(null, manifestPath, 0, 0, 0, 0, "AddToWin32Manifest.ManifestCanNotBeOpened");
+
+                    return !Log.HasLoggedErrors;
+                }
+
+                XmlDocument document = LoadManifest(stream);
+                XmlNamespaceManager xmlNamespaceManager = XmlNamespaces.GetNamespaceManager(document.NameTable);
+
+                ManifestValidationResult validationResult = ValidateManifest(manifestPath, document, xmlNamespaceManager);
+
+                switch (validationResult)
+                {
+                    case ManifestValidationResult.Success:
+                        AddSupportedArchitecturesElement(document, xmlNamespaceManager);
+                        SaveManifest(document, Path.GetFileName(ApplicationManifest?.ItemSpec) ?? DefaultManifestName);
+                        return !Log.HasLoggedErrors;
+                    case ManifestValidationResult.SupportedArchitecturesExists:
+                        return !Log.HasLoggedErrors;
+                    case ManifestValidationResult.Failure:
+                        return !Log.HasLoggedErrors;
+                    default:
+                        return false;
+                }
+            }
+            catch (Exception ex)
+            {
+                Log.LogErrorWithCodeFromResources(null, manifestPath, 0, 0, 0, 0, "AddToWin32Manifest.ManifestCanNotBeOpenedWithException", ex.Message);
+
+                return !Log.HasLoggedErrors;
+            }
+        }
+
+        private XmlDocument LoadManifest(Stream stream)
+        {
+            XmlDocument document = new XmlDocument();
+
+            using (XmlReader xr = XmlReader.Create(stream, new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true }))
+            {
+                document.Load(xr);
+            }
+
+            return document;
+        }
+
+        private void SaveManifest(XmlDocument document, string manifestName)
+        {
+            ManifestPath = Path.Combine(OutputDirectory, manifestName);
+            using (var xmlWriter = new XmlTextWriter(ManifestPath, Encoding.UTF8))
+            {
+                xmlWriter.Formatting = Formatting.Indented;
+                xmlWriter.Indentation = 4;
+                document.Save(xmlWriter);
+            }
+        }
+
+        private ManifestValidationResult ValidateManifest(string? manifestPath, XmlDocument document, XmlNamespaceManager xmlNamespaceManager)
+        {
+            if (ApplicationManifest == null)
+            {
+                return ManifestValidationResult.Success;
+            }
+
+            XmlNode? assemblyNode = document.SelectSingleNode(XPaths.assemblyElement, xmlNamespaceManager);
+
+            if (assemblyNode is null)
+            {
+                Log.LogErrorWithCodeFromResources(null, manifestPath, 0, 0, 0, 0, "AddToWin32Manifest.AssemblyNodeIsMissed");
+                return ManifestValidationResult.Failure;
+            }
+
+            XmlNode? supportedArchitecturesNode = GetNode(assemblyNode, supportedArchitectures, xmlNamespaceManager);
+            if (supportedArchitecturesNode != null)
+            {
+                if (!string.Equals(supportedArchitecturesNode.InnerText.Trim(), SupportedArchitectures, StringComparison.OrdinalIgnoreCase))
+                {
+                    Log.LogErrorWithCodeFromResources(null, manifestPath, 0, 0, 0, 0, "AddToWin32Manifest.InvalidValueInSupportedArchitectures", supportedArchitecturesNode.InnerText);
+
+                    return ManifestValidationResult.Failure;
+                }
+
+                return ManifestValidationResult.SupportedArchitecturesExists;
+            }
+
+            return ManifestValidationResult.Success;
+        }
+
+        private void AddSupportedArchitecturesElement(XmlDocument document, XmlNamespaceManager xmlNamespaceManager)
+        {
+            XmlNode? assemblyNode = document.SelectSingleNode(XPaths.assemblyElement, xmlNamespaceManager);
+            XmlElement appNode = GetOrCreateXmlElement(document, xmlNamespaceManager, application, asmv3Prefix, XmlNamespaces.asmv3);
+            XmlElement winSettingsNode = GetOrCreateXmlElement(document, xmlNamespaceManager, windowsSettings, asmv3Prefix, XmlNamespaces.asmv3);
+            if (string.IsNullOrEmpty(winSettingsNode.GetAttribute(XMakeAttributes.xmlns)))
+            {
+                winSettingsNode.SetAttribute(XMakeAttributes.xmlns, WindowsSettingsNamespace);
+            }
+
+            XmlElement supportedArchitecturesNode = GetOrCreateXmlElement(document, xmlNamespaceManager, supportedArchitectures, namespaceURI: WindowsSettingsNamespace);
+            supportedArchitecturesNode.InnerText = SupportedArchitectures;
+            winSettingsNode.AppendChild(supportedArchitecturesNode);
+
+            // If ParentNode is null, this indicates that winSettingsNode was not a part of the manifest.
+            if (winSettingsNode.ParentNode == null)
+            {
+                appNode.AppendChild(winSettingsNode);
+            }
+
+            if (appNode.ParentNode == null)
+            {
+                assemblyNode!.AppendChild(appNode);
+            }
+        }
+
+        private XmlElement GetOrCreateXmlElement(XmlDocument document, XmlNamespaceManager xmlNamespaceManager, string localName, string prefix = "", string namespaceURI = "")
+        {
+            XmlNode? existingNode = GetNode(document, localName, xmlNamespaceManager);
+
+            if (existingNode is XmlElement element)
+            {
+                return element;
+            }
+
+            return !string.IsNullOrEmpty(prefix)
+                ? document.CreateElement(prefix, localName, namespaceURI)
+                : document.CreateElement(localName, namespaceURI);
+        }
+
+        private XmlNode? GetNode(XmlNode node, string localName, XmlNamespaceManager xmlNamespaceManager) => node.SelectSingleNode($"//*[local-name()='{localName}']", xmlNamespaceManager);
+    }
+}
diff --git a/src/Tasks/MSBuildInternalMessage.cs b/src/Tasks/MSBuildInternalMessage.cs
new file mode 100644
index 00000000000..0595e286179
--- /dev/null
+++ b/src/Tasks/MSBuildInternalMessage.cs
@@ -0,0 +1,84 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Tasks
+{
+    /// <summary>
+    /// Represents a task that produces localized messages based on the specified resource name.
+    /// This task is intended to be called from internal targets only.
+    /// </summary>
+    public sealed class MSBuildInternalMessage : TaskExtension
+    {
+        private enum BuildMessageSeverity
+        {
+            /// <summary>
+            /// Indicates that the message corresponds to build information.
+            /// </summary>
+            Message,
+
+            /// <summary>
+            /// Indicates that the message corresponds to a build warning.
+            /// </summary>
+            Warning,
+
+            /// <summary>
+            /// Indicates that the message corresponds to a build error.
+            /// </summary>
+            Error,
+        }
+
+        /// <summary>
+        /// The name of the resource in Strings.resx that contains the desired error message.
+        /// </summary>
+        [Required]
+        public string ResourceName { get; set; } = string.Empty;
+
+        /// <summary>
+        /// Resource arguments to be used in the format string.
+        /// </summary>
+        public string[] FormatArguments { get; set; } = [];
+
+        /// <summary>
+        /// <see cref="BuildMessageSeverity"/>.
+        /// </summary>
+        [Required]
+        public string Severity { set; get; } = string.Empty;
+
+        /// <summary>
+        /// Configurable message importance.
+        /// </summary>
+        public string MessageImportance { get; set; } = "Normal";
+
+        public override bool Execute()
+        {
+            if (Enum.TryParse(Severity, ignoreCase: true, out BuildMessageSeverity severity))
+            {
+                switch (severity)
+                {
+                    case BuildMessageSeverity.Error:
+                        Log.LogErrorWithCodeFromResources(ResourceName, FormatArguments);
+                        return !Log.HasLoggedErrors;
+
+                    case BuildMessageSeverity.Warning:
+                        Log.LogWarningWithCodeFromResources(ResourceName, FormatArguments);
+                        return !Log.HasLoggedErrors;
+
+                    case BuildMessageSeverity.Message:
+                        MessageImportance importance = (MessageImportance)Enum.Parse(typeof(MessageImportance), MessageImportance, true);
+                        Log.LogMessageFromResources(importance, ResourceName, FormatArguments);
+                        return !Log.HasLoggedErrors;
+
+                    default:
+                        return !Log.HasLoggedErrors;
+                }
+            }
+
+            Log.LogErrorFromResources("CommonTarget.SpecifiedSeverityDoesNotExist", Severity);
+
+            return !Log.HasLoggedErrors;
+        }
+    }
+}
diff --git a/src/Tasks/ManifestUtil/XmlNamespaces.cs b/src/Tasks/ManifestUtil/XmlNamespaces.cs
index 033c1f4006c..bccdf44abf6 100644
--- a/src/Tasks/ManifestUtil/XmlNamespaces.cs
+++ b/src/Tasks/ManifestUtil/XmlNamespaces.cs
@@ -25,6 +25,7 @@ public static XmlNamespaceManager GetNamespaceManager(XmlNameTable nameTable)
             nsmgr.AddNamespace("dsig", dsig);
             nsmgr.AddNamespace("xrml", xrml);
             nsmgr.AddNamespace("xsi", xsi);
+
             return nsmgr;
         }
     }
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 3012b0ef44e..5bdaff55739 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -258,7 +258,9 @@
     <Compile Include="Move.cs" />
     <Compile Include="MSBuild.cs" />
     <Compile Include="NativeMethods.cs" />
+    <Compile Include="MSBuildInternalMessage.cs" />
     <Compile Include="ParserState.cs" />
+    <Compile Include="AddToWin32Manifest.cs" />
     <Compile Include="RedistList.cs" />
     <Compile Include="RemoveDir.cs" />
     <Compile Include="ResGenDependencies.cs" />
@@ -484,6 +486,8 @@
       <LogicalName>$(AssemblyName).Strings.ManifestUtilities.resources</LogicalName>
       <SubType>Designer</SubType>
     </EmbeddedResource>
+    <!-- The manifest is needed when PreferNativeArm64 is enabled in Unix environments. -->
+    <EmbeddedResource Include="Resources\default.win32manifest" />
     <!-- Other Source Files -->
     <EmbeddedResource Include="ManifestUtil\manifest.xml">
       <LogicalName>Microsoft.Build.Tasks.Deployment.ManifestUtilities.manifest.xml</LogicalName>
@@ -654,6 +658,9 @@
     <!-- Needed by Xaml Task Factory -->
     <Reference Include="System.Xaml" />
   </ItemGroup>
+  <ItemGroup>
+    <None Include="Resources\default.win32manifest" />
+  </ItemGroup>
   <ItemGroup>
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" SetTargetFramework="TargetFramework=netstandard2.0" OutputItemType="NetstandardRefAssemblies" />
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" SetTargetFramework="TargetFramework=netstandard2.0" OutputItemType="NetstandardRefAssemblies" />
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 5e81c64c525..4080585a710 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -427,6 +427,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <_WindowsMetadataOutputPath>$(OutDir)$(WinMDExpOutputWindowsMetadataFilename)</_WindowsMetadataOutputPath>
   </PropertyGroup>
 
+  <!-- ARM64-related properties -->
+  <PropertyGroup>
+    <_SupportedArchitectures>amd64 arm64</_SupportedArchitectures>
+  </PropertyGroup>
+
   <ItemGroup>
     <!-- Create an item for entry point of the ClickOnce application (Example: WindowsApplication1.exe) -->
     <_DeploymentManifestEntryPoint Include="@(IntermediateAssembly)">
@@ -854,6 +859,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <PlatformTargetAsMSBuildArchitecture>x86</PlatformTargetAsMSBuildArchitecture>
     </PropertyGroup>
 
+    <MSBuildInternalMessage Condition=" '$(Prefer32Bit)' == 'true' and '$(PreferNativeArm64)' == 'true' " ResourceName="CommonTarget.Prefer32BitAndPreferNativeArm64Enabled" Severity="Error"/>
+
+    <MSBuildInternalMessage Condition=" '$(NoWin32Manifest)' == 'true' and '$(PreferNativeArm64)' == 'true' " ResourceName="CommonTarget.NoWin32ManifestAndPreferNativeArm64Enabled" Severity="Error"/>
+
+    <MSBuildInternalMessage Condition=" '$(PreferNativeArm64)' == 'true' and '$(Platform)' != 'AnyCPU' " ResourceName="CommonTarget.PlatformIsAnyCPUAndPreferNativeArm64Enabled" Severity="Warning" FormatArguments="$(Platform)" />
+
     <!--
       Log an error if the user set MSBuildProjectExtensionsPath in the body of a project. In an SDK style project
       if you set a value in the body, the value is not used by the top implicit import but is used by the bottom.
@@ -3600,6 +3611,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       ResolveReferences;
       ResolveKeySource;
       SetWin32ManifestProperties;
+      _SetPreferNativeArm64Win32ManifestProperties;
       FindReferenceAssembliesForReferences;
       _GenerateCompileInputs;
       BeforeCompile;
@@ -4139,12 +4151,40 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <Win32Manifest>$(ApplicationManifest)</Win32Manifest>
     </PropertyGroup>
 
-    <GetFrameworkPath Condition="'$(ApplicationManifest)'=='' and '$(NoWin32Manifest)'!='true'">
+    <!-- If PreferNativeArm64 is enabled, it searches for the same default.win32manifest  -->
+    <GetFrameworkPath Condition="'$(ApplicationManifest)'=='' and '$(NoWin32Manifest)'!='true' and '$(PreferNativeArm64)' != 'true'">
       <Output TaskParameter="FrameworkVersion40Path"  PropertyName="_FrameworkVersion40Path" />
     </GetFrameworkPath>
 
     <PropertyGroup>
-      <EmbeddedWin32Manifest  Condition="'$(ApplicationManifest)'=='' and '$(NoWin32Manifest)'!='true' and Exists('$(_FrameworkVersion40Path)\default.win32manifest')">$(_FrameworkVersion40Path)\default.win32manifest</EmbeddedWin32Manifest>
+      <EmbeddedWin32Manifest Condition="'$(ApplicationManifest)'=='' and '$(NoWin32Manifest)'!='true' and '$(PreferNativeArm64)' != 'true' and Exists('$(_FrameworkVersion40Path)\default.win32manifest')">$(_FrameworkVersion40Path)\default.win32manifest</EmbeddedWin32Manifest>
+    </PropertyGroup>
+
+  </Target>
+
+  <!--
+    ============================================================
+                                        _SetPreferNativeArm64Win32ManifestProperties
+
+    Populates Manifest with SupportedArchitectures and updates Win32Manifest property to be used later in the build.
+    ============================================================
+    -->
+
+  <Target
+      Name="_SetPreferNativeArm64Win32ManifestProperties"
+      Condition=" '$(PreferNativeArm64)'=='true' and '$(NoWin32Manifest)'!='true'"
+      DependsOnTargets="SetWin32ManifestProperties">
+
+    <AddToWin32Manifest
+      ApplicationManifest="$(Win32Manifest)"
+      OutputDirectory="$(IntermediateOutputPath)"
+      SupportedArchitectures="$(_SupportedArchitectures)">
+
+      <Output TaskParameter="ManifestPath" PropertyName="_Win32Manifest"/>
+    </AddToWin32Manifest>
+
+    <PropertyGroup>
+      <Win32Manifest Condition="'$(_Win32Manifest)' != ''">$(_Win32Manifest)</Win32Manifest>
     </PropertyGroup>
 
   </Target>
@@ -4294,6 +4334,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     </GenerateApplicationManifest>
 
+    <AddToWin32Manifest
+        Condition="'$(PreferNativeArm64)'=='true'"
+        ApplicationManifest="@(ApplicationManifest)"
+        OutputDirectory="$(IntermediateOutputPath)"
+        SupportedArchitectures="$(_SupportedArchitectures)">
+    </AddToWin32Manifest>
+
     <PropertyGroup>
       <_DeploymentCopyApplicationManifest>true</_DeploymentCopyApplicationManifest>
     </PropertyGroup>
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index cf67254502d..35018eb1918 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -8,6 +8,7 @@
 
   <!-- NOTE: Using the fully qualified class name in a <UsingTask> tag is faster than using a partially qualified name. -->
 
+  <UsingTask TaskName="Microsoft.Build.Tasks.AddToWin32Manifest"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.AL"                                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.AspNetCompiler"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.AssignCulture"                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
@@ -62,6 +63,7 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.Message"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.Move"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.MSBuild"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.MSBuildInternalMessage"                AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ReadLinesFromFile"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
 
   <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildRuntimeType)' == 'Core' or '$(DisableOutOfProcTaskHost)' != ''" />
diff --git a/src/Tasks/Microsoft.NETFramework.CurrentVersion.props b/src/Tasks/Microsoft.NETFramework.CurrentVersion.props
index 0f03f04dfef..8fe39f32479 100644
--- a/src/Tasks/Microsoft.NETFramework.CurrentVersion.props
+++ b/src/Tasks/Microsoft.NETFramework.CurrentVersion.props
@@ -83,7 +83,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <TargetedRuntimeVersion Condition="'$(TargetedRuntimeVersion)' == ''">v$(MSBuildRuntimeVersion)</TargetedRuntimeVersion>
   </PropertyGroup>
 
-  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetingClr2Framework)' != 'true' and '$(TargetFrameworkVersion)' != 'v4.0' and ('$(OutputType)' == 'exe' or '$(OutputType)' == 'winexe' or '$(OutputType)' == 'appcontainerexe' or '$(OutputType)' == '')">
+  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetingClr2Framework)' != 'true' and '$(TargetFrameworkVersion)' != 'v4.0' and ('$(OutputType)' == 'exe' or '$(OutputType)' == 'winexe' or '$(OutputType)' == 'appcontainerexe' or '$(OutputType)' == '') and '$(PreferNativeArm64)' != 'true'">
     <Prefer32Bit Condition="'$(Prefer32Bit)' == ''">true</Prefer32Bit>
   </PropertyGroup>
 
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index a969d1dc8de..7761f84804a 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -2621,7 +2621,7 @@
     <value>MSB3781: The SDK "{0}" depends on the following SDK(s) {1}, which have not been added to the project or were not found. Please ensure that you add these dependencies to your project or you may experience runtime issues. You can add dependencies to your project through the Reference Manager.</value>
     <comment>{StrBegin="MSB3781: "}</comment>
    </data>
-    <data name="ResolveSDKReference.Prefer32BitNotSupportedWithNeutralProject" xml:space="preserve">
+   <data name="ResolveSDKReference.Prefer32BitNotSupportedWithNeutralProject" xml:space="preserve">
     <value>MSB3782: The "{0}" SDK does not support targeting a neutral architecture with "Prefer 32-Bit" enabled for the project. Please go to the project properties (Build tab for C# and Compile tab for VB) and disable the "Prefer 32-bit" option, or change your project to target a non-neutral architecture.</value>
     <comment>{StrBegin="MSB3782: "} Also, please localize "Prefer 32-Bit" in the same way that it is localized in wizard\vbdesigner\designer\proppages\buildproppage.resx</comment>
    </data>
@@ -3013,6 +3013,47 @@
     <value>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</value>
     <comment>{StrBegin="MSB3992: "}</comment>
   </data>
+
+  <!--
+        MSB4300 - MSB4310   Task: AddToWin32Manifest
+  -->
+  <data name="AddToWin32Manifest.InvalidValueInSupportedArchitectures">
+    <value>MSB4300: The specified value '{0}' for the supportedArchitectures element is invalid. Either remove it from the manifest or set it to 'amd64 arm64'.</value>
+    <comment>{StrBegin="MSB4300: "}</comment>
+  </data>
+  <data name="AddToWin32Manifest.AssemblyNodeIsMissed">
+    <value>The assembly element is missing from the application manifest.</value>
+  </data>
+  <data name="AddToWin32Manifest.SpecifiedApplicationManifestCanNotBeFound">
+    <value>The application manifest file cannot be found. Please make sure it exists.</value>
+  </data>
+  <data name="AddToWin32Manifest.ManifestCanNotBeOpened">
+    <value>The manifest file either does not exist or can not be read. Please make sure it exists and has relevant content.</value>
+  </data>
+  <data name="AddToWin32Manifest.ManifestCanNotBeOpenedWithException">
+    <value>The manifest file opening has failed with exception: '{0}'. Please make sure it exists and has relevant content.</value>
+  </data>
+
+  <!--
+        MSB9901 - MSB9990   MSBuild common targets messages
+  -->
+  <data name="CommonTarget.SpecifiedSeverityDoesNotExist">
+    <value>MSB9901: The specified severity is not relevant: '{0}' for the message: '{1}'.</value>
+    <comment>{StrBegin="MSB9901: "}</comment>
+  </data>
+  <data name="CommonTarget.Prefer32BitAndPreferNativeArm64Enabled">
+    <value>MSB9902: Prefer32Bit and PreferNativeArm64 options are mutually exclusive. Please enable only one.</value>
+    <comment>{StrBegin="MSB9902: "}</comment>
+  </data>
+  <data name="CommonTarget.NoWin32ManifestAndPreferNativeArm64Enabled">
+    <value>MSB9903: PreferNativeArm64 requires a Win32 application manifest and is mutually exclusive with NoWin32Manifest.</value>
+    <comment>{StrBegin="MSB9903: "}</comment>
+  </data>
+  <data name="CommonTarget.PlatformIsAnyCPUAndPreferNativeArm64Enabled">
+    <value>MSB9904: When PreferNativeArm64 is enabled, ensure that the Platform is set to AnyCPU. Current Platform: {0}.</value>
+    <comment>{StrBegin="MSB9904: "}</comment>
+  </data>
+
   <!--
         The tasks message bucket is: MSB3001 - MSB3999
 
@@ -3100,9 +3141,12 @@
             MSB3971 - MSB3980   Task: GetReferenceAssemblyPaths overflow
             MSB3981 - MSB3990   Task: GetCompatiblePlatform
             MSB3991 - MSB3999   Task: CombineTargetFrameworkInfoProperties
+            MSB4300 - MSB4310   Task: AddToWin32Manifest
 
             MSB4000 - MSB4200   Portable targets & tasks (vsproject\flavors\portable\msbuild)
             MSB9000 - MSB9900   MSBuild targets files (C++)
+            
+            MSB9901 - MSB9990   MSBuild common targets messages
 
         The following codes are not longer used but have shipped so should not be reused:
             MSB3109
diff --git a/src/Tasks/Resources/default.win32manifest b/src/Tasks/Resources/default.win32manifest
new file mode 100644
index 00000000000..f8f55e0a44e
--- /dev/null
+++ b/src/Tasks/Resources/default.win32manifest
@@ -0,0 +1,12 @@
+﻿<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+
+<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
+  <assemblyIdentity version="1.0.0.0" name="MyApplication.app"/>
+  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
+    <security>
+      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
+        <requestedExecutionLevel level="asInvoker" uiAccess="false"/>
+      </requestedPrivileges>
+    </security>
+  </trustInfo>
+</assembly>
\ No newline at end of file
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index b4fc18d7e3f..8bb9db37186 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -2,6 +2,16 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="cs" original="../Strings.resx">
     <body>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpened">
+        <source>The manifest file either does not exist or can not be read. Please make sure it exists and has relevant content.</source>
+        <target state="translated">Soubor manifestu buď neexistuje, nebo ho nejde přečíst. Ujistěte se prosím, že existuje a má relevantní obsah.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpenedWithException">
+        <source>The manifest file opening has failed with exception: '{0}'. Please make sure it exists and has relevant content.</source>
+        <target state="translated">Otevření souboru manifestu selhalo s výjimkou: {0}. Ujistěte se prosím, že existuje a má relevantní obsah.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AppConfig.BindingRedirectMissingOldVersion">
         <source>BindingRedirect is missing required field 'oldVersion'.</source>
         <target state="translated">Nebylo nalezeno požadované pole oldVersion pro element BindingRedirect.</target>
@@ -131,6 +141,26 @@
         <target state="translated">MSB3992: Hodnota {0} není nastaven. Pokud {1} má hodnotu true, nezapomeňte nastavit hodnotu pro {0}.</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
+      <trans-unit id="CommonTarget.NoWin32ManifestAndPreferNativeArm64Enabled">
+        <source>MSB9903: PreferNativeArm64 requires a Win32 application manifest and is mutually exclusive with NoWin32Manifest.</source>
+        <target state="translated">MSB9903: Možnost PreferNativeArm64 vyžaduje manifest aplikace Win32 a vzájemně se vylučuje s možností NoWin32Manifest.</target>
+        <note>{StrBegin="MSB9903: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.PlatformIsAnyCPUAndPreferNativeArm64Enabled">
+        <source>MSB9904: When PreferNativeArm64 is enabled, ensure that the Platform is set to AnyCPU. Current Platform: {0}.</source>
+        <target state="translated">MSB9904: Pokud je povolená možnost PreferNativeArm64, ujistěte se, že je platforma nastavená na AnyCPU. Aktuální platforma: {0}.</target>
+        <note>{StrBegin="MSB9904: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.Prefer32BitAndPreferNativeArm64Enabled">
+        <source>MSB9902: Prefer32Bit and PreferNativeArm64 options are mutually exclusive. Please enable only one.</source>
+        <target state="translated">MSB9902: Možnosti Prefer32Bit a PreferNativeArm64 se vzájemně vylučují. Povolte prosím jenom jednu z nich.</target>
+        <note>{StrBegin="MSB9902: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.SpecifiedSeverityDoesNotExist">
+        <source>MSB9901: The specified severity is not relevant: '{0}' for the message: '{1}'.</source>
+        <target state="translated">MSB9901: Zadaná závažnost není relevantní: {0} pro zprávu: {1}.</target>
+        <note>{StrBegin="MSB9901: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: Závažná chyba: víc než {0} argumentů příkazového řádku</target>
@@ -1564,6 +1594,21 @@
         <target state="translated">Vlastnost StopOnFirstFailure nebude mít žádný účinek, jsou-li splněny všechny následující podmínky: 1) systém pracuje v režimu více procesů, 2) vlastnost BuildInParallel má hodnotu True, 3) vlastnost RunEachTargetSeparately má hodnotu False.</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="AddToWin32Manifest.AssemblyNodeIsMissed">
+        <source>The assembly element is missing from the application manifest.</source>
+        <target state="translated">V manifestu aplikace chybí element assembly.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.InvalidValueInSupportedArchitectures">
+        <source>MSB4300: The specified value '{0}' for the supportedArchitectures element is invalid. Either remove it from the manifest or set it to 'amd64 arm64'.</source>
+        <target state="translated">MSB4300: Zadaná hodnota {0} pro element supportedArchitectures je neplatná. Buď ho odeberte z manifestu, nebo ho nastavte na hodnotu amd64 arm64.</target>
+        <note>{StrBegin="MSB4300: "}</note>
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.SpecifiedApplicationManifestCanNotBeFound">
+        <source>The application manifest file cannot be found. Please make sure it exists.</source>
+        <target state="translated">Nepovedlo se najít soubor manifestu aplikace. Ujistěte se prosím, že existuje.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: Nelze číst řádky ze souboru {0}. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index a185f1c58dc..65661176521 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -2,6 +2,16 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="de" original="../Strings.resx">
     <body>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpened">
+        <source>The manifest file either does not exist or can not be read. Please make sure it exists and has relevant content.</source>
+        <target state="translated">Die Manifestdatei ist entweder nicht vorhanden oder kann nicht gelesen werden. Stellen Sie sicher, dass sie vorhanden ist und relevante Inhalte enthält.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpenedWithException">
+        <source>The manifest file opening has failed with exception: '{0}'. Please make sure it exists and has relevant content.</source>
+        <target state="translated">Ausnahmefehler beim Öffnen der Manifestdatei: "{0}". Stellen Sie sicher, dass sie vorhanden ist und relevante Inhalte enthält.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AppConfig.BindingRedirectMissingOldVersion">
         <source>BindingRedirect is missing required field 'oldVersion'.</source>
         <target state="translated">Im BindingRedirect-Eintrag fehlt das Pflichtfeld "oldVersion".</target>
@@ -131,6 +141,26 @@
         <target state="translated">MSB3992: „{0}“ ist nicht festgelegt. Wenn {1} wahr ist, legen Sie auf jeden Fall einen Wert für „{0}“ fest.</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
+      <trans-unit id="CommonTarget.NoWin32ManifestAndPreferNativeArm64Enabled">
+        <source>MSB9903: PreferNativeArm64 requires a Win32 application manifest and is mutually exclusive with NoWin32Manifest.</source>
+        <target state="translated">MSB9903: "PreferNativeArm64" erfordert ein Win32-Anwendungsmanifest und schließt sich mit "NoWin32Manifest" gegenseitig aus.</target>
+        <note>{StrBegin="MSB9903: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.PlatformIsAnyCPUAndPreferNativeArm64Enabled">
+        <source>MSB9904: When PreferNativeArm64 is enabled, ensure that the Platform is set to AnyCPU. Current Platform: {0}.</source>
+        <target state="translated">MSB9904: Wenn "PreferNativeArm64" aktiviert ist, stellen Sie sicher, dass die Plattform auf AnyCPU festgelegt ist. Aktuelle Plattform: {0}.</target>
+        <note>{StrBegin="MSB9904: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.Prefer32BitAndPreferNativeArm64Enabled">
+        <source>MSB9902: Prefer32Bit and PreferNativeArm64 options are mutually exclusive. Please enable only one.</source>
+        <target state="translated">MSB9902: Die Optionen "Prefer32Bit" und "PreferNativeArm64" schließen sich gegenseitig aus. Aktivieren Sie nur eine.</target>
+        <note>{StrBegin="MSB9902: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.SpecifiedSeverityDoesNotExist">
+        <source>MSB9901: The specified severity is not relevant: '{0}' for the message: '{1}'.</source>
+        <target state="translated">MSB9901: Der angegebene Schweregrad ist nicht relevant: "{0}" für die Nachricht: "{1}".</target>
+        <note>{StrBegin="MSB9901: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: Schwerwiegender Fehler: mehr als {0} Befehlszeilenargumente.</target>
@@ -1564,6 +1594,21 @@
         <target state="translated">StopOnFirstFailure hat keine Auswirkungen, wenn die folgenden Bedingungen alle gelten: 1) Das System wird im Mehrprozessmodus ausgeführt. 2) Die BuildInParallel-Eigenschaft ist TRUE. 3) Die RunEachTargetSeparately-Eigenschaft ist FALSE.</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="AddToWin32Manifest.AssemblyNodeIsMissed">
+        <source>The assembly element is missing from the application manifest.</source>
+        <target state="translated">Das Assemblyelement fehlt im Anwendungsmanifest.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.InvalidValueInSupportedArchitectures">
+        <source>MSB4300: The specified value '{0}' for the supportedArchitectures element is invalid. Either remove it from the manifest or set it to 'amd64 arm64'.</source>
+        <target state="translated">MSB4300: Der angegebene Wert "{0}" für das supportedArchitectures-Element ist ungültig. Entfernen Sie ihn aus dem Manifest, oder legen Sie ihn auf "amd64 arm64" fest.</target>
+        <note>{StrBegin="MSB4300: "}</note>
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.SpecifiedApplicationManifestCanNotBeFound">
+        <source>The application manifest file cannot be found. Please make sure it exists.</source>
+        <target state="translated">Die Anwendungsmanifestdatei wurde nicht gefunden. Stellen Sie sicher, dass sie vorhanden ist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: Die Zeilen aus der Datei "{0}" konnten nicht gelesen werden. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index eef9d9a6a5e..26b96fb0e25 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -2,6 +2,16 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="es" original="../Strings.resx">
     <body>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpened">
+        <source>The manifest file either does not exist or can not be read. Please make sure it exists and has relevant content.</source>
+        <target state="translated">El archivo de manifiesto no existe o no se puede leer. Asegúrese de que existe y de que tiene contenido relevante.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpenedWithException">
+        <source>The manifest file opening has failed with exception: '{0}'. Please make sure it exists and has relevant content.</source>
+        <target state="translated">Error al abrir el archivo de manifiesto con la excepción: '{0}'. Asegúrese de que existe y de que tiene contenido relevante.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AppConfig.BindingRedirectMissingOldVersion">
         <source>BindingRedirect is missing required field 'oldVersion'.</source>
         <target state="translated">Falta el campo obligatorio 'oldVersion' en BindingRedirect.</target>
@@ -131,6 +141,26 @@
         <target state="translated">MSB3992: "{0}" no se ha establecido. Cuando {1} sea true, asegúrese de establecer un valor para "{0}".</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
+      <trans-unit id="CommonTarget.NoWin32ManifestAndPreferNativeArm64Enabled">
+        <source>MSB9903: PreferNativeArm64 requires a Win32 application manifest and is mutually exclusive with NoWin32Manifest.</source>
+        <target state="translated">MSB9903: PreferNativeArm64 requiere un manifiesto de aplicación Win32 y se excluye mutuamente con NoWin32Manifest.</target>
+        <note>{StrBegin="MSB9903: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.PlatformIsAnyCPUAndPreferNativeArm64Enabled">
+        <source>MSB9904: When PreferNativeArm64 is enabled, ensure that the Platform is set to AnyCPU. Current Platform: {0}.</source>
+        <target state="translated">MSB9904: cuando PreferNativeArm64 esté habilitado, asegúrese de que la plataforma está establecida en AnyCPU. Plataforma actual: {0}.</target>
+        <note>{StrBegin="MSB9904: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.Prefer32BitAndPreferNativeArm64Enabled">
+        <source>MSB9902: Prefer32Bit and PreferNativeArm64 options are mutually exclusive. Please enable only one.</source>
+        <target state="translated">MSB9902: las opciones Prefer32Bit y PreferNativeArm64 se excluyen mutuamente. Habilite solo una.</target>
+        <note>{StrBegin="MSB9902: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.SpecifiedSeverityDoesNotExist">
+        <source>MSB9901: The specified severity is not relevant: '{0}' for the message: '{1}'.</source>
+        <target state="translated">MSB9901: la gravedad especificada no es relevante: '{0}' para el mensaje: '{1}'.</target>
+        <note>{StrBegin="MSB9901: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: Error irrecuperable: más de {0} argumentos de línea de comandos.</target>
@@ -1564,6 +1594,21 @@
         <target state="translated">StopOnFirstFailure no surtirá efecto si se dan todas las condiciones siguientes: 1) El sistema se ejecuta en modo de proceso múltiple. 2) La propiedad BuildInParallel es true. 3) La propiedad RunEachTargetSeparately es false.</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="AddToWin32Manifest.AssemblyNodeIsMissed">
+        <source>The assembly element is missing from the application manifest.</source>
+        <target state="translated">Falta el elemento de ensamblado en el manifiesto de aplicación.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.InvalidValueInSupportedArchitectures">
+        <source>MSB4300: The specified value '{0}' for the supportedArchitectures element is invalid. Either remove it from the manifest or set it to 'amd64 arm64'.</source>
+        <target state="translated">MSB4300: el valor especificado '{0}' para el elemento supportedArchitectures no es válido. Quítelo del manifiesto o establézcalo en "amd64 arm64".</target>
+        <note>{StrBegin="MSB4300: "}</note>
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.SpecifiedApplicationManifestCanNotBeFound">
+        <source>The application manifest file cannot be found. Please make sure it exists.</source>
+        <target state="translated">No se encuentra el archivo de manifiesto de aplicación. Asegúrese de que existe.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: No se pudieron leer las líneas del archivo "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 0a38e39c972..64591057ddc 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -2,6 +2,16 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="fr" original="../Strings.resx">
     <body>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpened">
+        <source>The manifest file either does not exist or can not be read. Please make sure it exists and has relevant content.</source>
+        <target state="translated">Le fichier manifeste n’existe pas ou ne peut pas être lu. Vérifiez qu’il existe et qu’il contient du contenu pertinent.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpenedWithException">
+        <source>The manifest file opening has failed with exception: '{0}'. Please make sure it exists and has relevant content.</source>
+        <target state="translated">L’ouverture du fichier manifeste a échoué avec l’exception : «{0}». Vérifiez qu’il existe et qu’il contient du contenu pertinent.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AppConfig.BindingRedirectMissingOldVersion">
         <source>BindingRedirect is missing required field 'oldVersion'.</source>
         <target state="translated">Le champ 'oldVersion' obligatoire doit être défini pour BindingRedirect.</target>
@@ -131,6 +141,26 @@
         <target state="translated">MSB3992: « {{0}0} » n’est pas défini. Lorsque {1} la valeur est true, veillez à définir une valeur pour «{0} ».</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
+      <trans-unit id="CommonTarget.NoWin32ManifestAndPreferNativeArm64Enabled">
+        <source>MSB9903: PreferNativeArm64 requires a Win32 application manifest and is mutually exclusive with NoWin32Manifest.</source>
+        <target state="new">MSB9903: PreferNativeArm64 requires a Win32 application manifest and is mutually exclusive with NoWin32Manifest.</target>
+        <note>{StrBegin="MSB9903: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.PlatformIsAnyCPUAndPreferNativeArm64Enabled">
+        <source>MSB9904: When PreferNativeArm64 is enabled, ensure that the Platform is set to AnyCPU. Current Platform: {0}.</source>
+        <target state="new">MSB9904: When PreferNativeArm64 is enabled, ensure that the Platform is set to AnyCPU. Current Platform: {0}.</target>
+        <note>{StrBegin="MSB9904: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.Prefer32BitAndPreferNativeArm64Enabled">
+        <source>MSB9902: Prefer32Bit and PreferNativeArm64 options are mutually exclusive. Please enable only one.</source>
+        <target state="new">MSB9902: Prefer32Bit and PreferNativeArm64 options are mutually exclusive. Please enable only one.</target>
+        <note>{StrBegin="MSB9902: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.SpecifiedSeverityDoesNotExist">
+        <source>MSB9901: The specified severity is not relevant: '{0}' for the message: '{1}'.</source>
+        <target state="new">MSB9901: The specified severity is not relevant: '{0}' for the message: '{1}'.</target>
+        <note>{StrBegin="MSB9901: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: Erreur fatale : plus de {0} arguments de ligne de commande.</target>
@@ -1564,6 +1594,21 @@
         <target state="translated">StopOnFirstFailure reste sans effet dans les conditions suivantes : 1) Le système s'exécute en mode multiprocessus. 2) La propriété BuildInParallel a la valeur true. 3) La propriété RunEachTargetSeparately a la valeur false.</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="AddToWin32Manifest.AssemblyNodeIsMissed">
+        <source>The assembly element is missing from the application manifest.</source>
+        <target state="translated">L’élément assembly est manquant dans le manifeste de l’application.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.InvalidValueInSupportedArchitectures">
+        <source>MSB4300: The specified value '{0}' for the supportedArchitectures element is invalid. Either remove it from the manifest or set it to 'amd64 arm64'.</source>
+        <target state="new">MSB4300: The specified value '{0}' for the supportedArchitectures element is invalid. Either remove it from the manifest or set it to 'amd64 arm64'.</target>
+        <note>{StrBegin="MSB4300: "}</note>
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.SpecifiedApplicationManifestCanNotBeFound">
+        <source>The application manifest file cannot be found. Please make sure it exists.</source>
+        <target state="translated">Le fichier manifeste de l’application est introuvable. Assurez-vous qu’il existe.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: Impossible de lire les lignes dans le fichier "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 27b03e70d2e..b6dedbeb34d 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -2,6 +2,16 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="it" original="../Strings.resx">
     <body>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpened">
+        <source>The manifest file either does not exist or can not be read. Please make sure it exists and has relevant content.</source>
+        <target state="translated">Il file manifesto non esiste o non può essere letto. Assicurarsi che esista e che contenga contenuto pertinente.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpenedWithException">
+        <source>The manifest file opening has failed with exception: '{0}'. Please make sure it exists and has relevant content.</source>
+        <target state="translated">Apertura del file manifesto non riuscita con eccezione: "{0}". Assicurarsi che esista e che contenga contenuto pertinente.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AppConfig.BindingRedirectMissingOldVersion">
         <source>BindingRedirect is missing required field 'oldVersion'.</source>
         <target state="translated">In BindingRedirect manca il campo obbligatorio 'oldVersion'.</target>
@@ -131,6 +141,26 @@
         <target state="translated">MSB3992: '{0}' non è impostato. Quando {1} è true, assicurarsi di impostare un valore per '{0}'.</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
+      <trans-unit id="CommonTarget.NoWin32ManifestAndPreferNativeArm64Enabled">
+        <source>MSB9903: PreferNativeArm64 requires a Win32 application manifest and is mutually exclusive with NoWin32Manifest.</source>
+        <target state="translated">MSB9903: PreferNativeArm64 richiede un manifesto dell'applicazione Win32 e si esclude a vicenda con NoWin32Manifest.</target>
+        <note>{StrBegin="MSB9903: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.PlatformIsAnyCPUAndPreferNativeArm64Enabled">
+        <source>MSB9904: When PreferNativeArm64 is enabled, ensure that the Platform is set to AnyCPU. Current Platform: {0}.</source>
+        <target state="translated">MSB9904: quando l'opzione PreferNativeArm64 è abilitata, assicurarsi che la piattaforma sia impostata su AnyCPU. Piattaforma corrente: {0}.</target>
+        <note>{StrBegin="MSB9904: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.Prefer32BitAndPreferNativeArm64Enabled">
+        <source>MSB9902: Prefer32Bit and PreferNativeArm64 options are mutually exclusive. Please enable only one.</source>
+        <target state="translated">MSB9902: le opzioni Prefer32Bit e PreferNativeArm64 si escludono a vicenda. Abilitarne solo una.</target>
+        <note>{StrBegin="MSB9902: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.SpecifiedSeverityDoesNotExist">
+        <source>MSB9901: The specified severity is not relevant: '{0}' for the message: '{1}'.</source>
+        <target state="translated">MSB9901: la gravità specificata non è rilevante: "{0}" per il messaggio: "{1}".</target>
+        <note>{StrBegin="MSB9901: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: Errore irreversibile: più di {0} argomenti della riga di comando.</target>
@@ -1564,6 +1594,21 @@
         <target state="translated">StopOnFirstFailure non avrà alcun effetto in presenza di tutte le condizioni seguenti: 1) il sistema è in esecuzione in modalità a più processi 2) la proprietà BuildInParallel è true. 3) la proprietà RunEachTargetSeparately è false.</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="AddToWin32Manifest.AssemblyNodeIsMissed">
+        <source>The assembly element is missing from the application manifest.</source>
+        <target state="translated">Manca l'elemento dell'assembly dal manifesto dell'applicazione.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.InvalidValueInSupportedArchitectures">
+        <source>MSB4300: The specified value '{0}' for the supportedArchitectures element is invalid. Either remove it from the manifest or set it to 'amd64 arm64'.</source>
+        <target state="translated">MSB4300: il valore specificato "{0}" per l'elemento supportedArchitectures non è valido. Rimuoverlo dal manifesto o impostarlo su "amd64 arm64".</target>
+        <note>{StrBegin="MSB4300: "}</note>
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.SpecifiedApplicationManifestCanNotBeFound">
+        <source>The application manifest file cannot be found. Please make sure it exists.</source>
+        <target state="translated">Non è possibile trovare il file manifesto dell'applicazione. Assicurarsi che esista.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: non è stato possibile leggere le righe dal file "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index 855a8a09ef6..ad9253819a8 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -2,6 +2,16 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ja" original="../Strings.resx">
     <body>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpened">
+        <source>The manifest file either does not exist or can not be read. Please make sure it exists and has relevant content.</source>
+        <target state="translated">マニフェスト ファイルが存在しないか、読み取れません。これが存在し、関連するコンテンツがあることを確認してください。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpenedWithException">
+        <source>The manifest file opening has failed with exception: '{0}'. Please make sure it exists and has relevant content.</source>
+        <target state="translated">マニフェスト ファイルを開けませんでした。例外: '{0}'。これが存在し、関連するコンテンツがあることを確認してください。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AppConfig.BindingRedirectMissingOldVersion">
         <source>BindingRedirect is missing required field 'oldVersion'.</source>
         <target state="translated">BindingRedirect には必須フィールド 'oldVersion' がありません。</target>
@@ -131,6 +141,26 @@
         <target state="translated">MSB3992: '{0}' が設定されていません。{1} が true の場合は、必ず '{0}' の値を設定してください。</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
+      <trans-unit id="CommonTarget.NoWin32ManifestAndPreferNativeArm64Enabled">
+        <source>MSB9903: PreferNativeArm64 requires a Win32 application manifest and is mutually exclusive with NoWin32Manifest.</source>
+        <target state="translated">MSB9903: PreferNativeArm64 は、Win32 アプリケーション マニフェストを必要とし、NoWin32Manifest と相互に排他的です。</target>
+        <note>{StrBegin="MSB9903: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.PlatformIsAnyCPUAndPreferNativeArm64Enabled">
+        <source>MSB9904: When PreferNativeArm64 is enabled, ensure that the Platform is set to AnyCPU. Current Platform: {0}.</source>
+        <target state="translated">MSB9904: PreferNativeArm64 が有効である場合、プラットフォームが AnyCPU に設定されていることを確認してください。現在のプラットフォーム: {0}。</target>
+        <note>{StrBegin="MSB9904: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.Prefer32BitAndPreferNativeArm64Enabled">
+        <source>MSB9902: Prefer32Bit and PreferNativeArm64 options are mutually exclusive. Please enable only one.</source>
+        <target state="translated">MSB9902: Prefer32Bit オプションと PreferNativeArm64 オプションは相互に排他的です。1 つだけ有効にしてください。</target>
+        <note>{StrBegin="MSB9902: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.SpecifiedSeverityDoesNotExist">
+        <source>MSB9901: The specified severity is not relevant: '{0}' for the message: '{1}'.</source>
+        <target state="translated">MSB9901: 指定された重要度に関連性がありません: メッセージの '{0}': '{1}'。</target>
+        <note>{StrBegin="MSB9901: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: 致命的なエラー: コマンド ライン引数が {0} を超えています。</target>
@@ -1564,6 +1594,21 @@
         <target state="translated">StopOnFirstFailure は、次のすべての条件に該当する場合に無効となります。1) システムがマルチプロセッサ モードで実行されている。2) BuildInParallel プロパティが true に設定されている。3) RunEachTargetSeparately プロパティが false に設定されている。</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="AddToWin32Manifest.AssemblyNodeIsMissed">
+        <source>The assembly element is missing from the application manifest.</source>
+        <target state="translated">アセンブリ要素がアプリケーション マニフェストにありません。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.InvalidValueInSupportedArchitectures">
+        <source>MSB4300: The specified value '{0}' for the supportedArchitectures element is invalid. Either remove it from the manifest or set it to 'amd64 arm64'.</source>
+        <target state="translated">MSB4300: supportedArchitectures 要素に指定された値 '{0}' が無効です。マニフェストから削除するか、'amd64 arm64' に設定してください。</target>
+        <note>{StrBegin="MSB4300: "}</note>
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.SpecifiedApplicationManifestCanNotBeFound">
+        <source>The application manifest file cannot be found. Please make sure it exists.</source>
+        <target state="translated">アプリケーション マニフェスト ファイルが見つかりません。これが存在することを確認してください。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: ファイル "{0}" からの行を読み取れませんでした。{1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 9e7d5d6eabc..602b92b7a00 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -2,6 +2,16 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ko" original="../Strings.resx">
     <body>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpened">
+        <source>The manifest file either does not exist or can not be read. Please make sure it exists and has relevant content.</source>
+        <target state="translated">매니페스트 파일이 없거나 읽을 수 없습니다. 해당 콘텐츠가 존재하고 관련 콘텐츠가 있는지 확인하세요.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpenedWithException">
+        <source>The manifest file opening has failed with exception: '{0}'. Please make sure it exists and has relevant content.</source>
+        <target state="translated">'{0}' 예외로 인해 매니페스트 파일을 열지 못했습니다. 해당 콘텐츠가 존재하고 관련 콘텐츠가 있는지 확인하세요.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AppConfig.BindingRedirectMissingOldVersion">
         <source>BindingRedirect is missing required field 'oldVersion'.</source>
         <target state="translated">BindingRedirect에 필수 필드인 'oldVersion'이 없습니다.</target>
@@ -131,6 +141,26 @@
         <target state="translated">MSB3992: '{0}'이(가) 설정되지 않았습니다. {1}이(가) true인 경우 '{0}'에 값을 설정해야 합니다.</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
+      <trans-unit id="CommonTarget.NoWin32ManifestAndPreferNativeArm64Enabled">
+        <source>MSB9903: PreferNativeArm64 requires a Win32 application manifest and is mutually exclusive with NoWin32Manifest.</source>
+        <target state="translated">MSB9903: PreferNativeArm64에는 Win32 애플리케이션 매니페스트가 필요하며 NoWin32Manifest와 함께 사용할 수 없습니다.</target>
+        <note>{StrBegin="MSB9903: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.PlatformIsAnyCPUAndPreferNativeArm64Enabled">
+        <source>MSB9904: When PreferNativeArm64 is enabled, ensure that the Platform is set to AnyCPU. Current Platform: {0}.</source>
+        <target state="translated">MSB9904: PreferNativeArm64를 사용하도록 설정한 경우 플랫폼이 AnyCPU로 설정되어 있는지 확인합니다. 현재 플랫폼: {0}.</target>
+        <note>{StrBegin="MSB9904: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.Prefer32BitAndPreferNativeArm64Enabled">
+        <source>MSB9902: Prefer32Bit and PreferNativeArm64 options are mutually exclusive. Please enable only one.</source>
+        <target state="translated">MSB9902: Prefer32Bit 및 PreferNativeArm64 옵션은 함께 사용할 수 없습니다. 하나만 사용하도록 설정하세요.</target>
+        <note>{StrBegin="MSB9902: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.SpecifiedSeverityDoesNotExist">
+        <source>MSB9901: The specified severity is not relevant: '{0}' for the message: '{1}'.</source>
+        <target state="translated">MSB9901: 지정한 심각도가 관련되지 않습니다. '{1}' 메시지의 '{0}'.</target>
+        <note>{StrBegin="MSB9901: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: 심각한 오류: 명령줄 인수가 {0}개를 넘었습니다.</target>
@@ -1564,6 +1594,21 @@
         <target state="translated">다음 조건이 모두 충족되면 StopOnFirstFailure가 효과가 없습니다. 1) 시스템이 다중 프로세스 모드에서 실행 중입니다. 2) BuildInParallel 속성이 true입니다. 3) RunEachTargetSeparately 속성이 false입니다.</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="AddToWin32Manifest.AssemblyNodeIsMissed">
+        <source>The assembly element is missing from the application manifest.</source>
+        <target state="translated">어셈블리 요소가 애플리케이션 매니페스트에 없습니다.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.InvalidValueInSupportedArchitectures">
+        <source>MSB4300: The specified value '{0}' for the supportedArchitectures element is invalid. Either remove it from the manifest or set it to 'amd64 arm64'.</source>
+        <target state="translated">MSB4300: supportedArchitectures 요소에 대해 지정된 값 '{0}'이(가) 잘못되었습니다. 매니페스트에서 제거하거나 'amd64 arm64'로 설정합니다.</target>
+        <note>{StrBegin="MSB4300: "}</note>
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.SpecifiedApplicationManifestCanNotBeFound">
+        <source>The application manifest file cannot be found. Please make sure it exists.</source>
+        <target state="translated">애플리케이션 매니페스트 파일을 찾을 수 없습니다. 존재하는지 확인하세요.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: "{0}" 파일에서 줄을 읽을 수 없습니다. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 6f0ed65f8bc..5444be59980 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -2,6 +2,16 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="pl" original="../Strings.resx">
     <body>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpened">
+        <source>The manifest file either does not exist or can not be read. Please make sure it exists and has relevant content.</source>
+        <target state="translated">Plik manifestu nie istnieje lub nie można go odczytać. Upewnij się, że istnieje i ma odpowiednią zawartość.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpenedWithException">
+        <source>The manifest file opening has failed with exception: '{0}'. Please make sure it exists and has relevant content.</source>
+        <target state="translated">Otwieranie pliku manifestu nie powiodło się. Wyjątek: „{0}”. Upewnij się, że istnieje i ma odpowiednią zawartość.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AppConfig.BindingRedirectMissingOldVersion">
         <source>BindingRedirect is missing required field 'oldVersion'.</source>
         <target state="translated">W parametrze BindingRedirect brakuje wymaganego pola 'oldVersion'.</target>
@@ -131,6 +141,26 @@
         <target state="translated">MSB3992: nie ustawiono „{0}”. Jeśli {1} ma wartość true, upewnij się, że ustawiono wartość dla „{0}”.</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
+      <trans-unit id="CommonTarget.NoWin32ManifestAndPreferNativeArm64Enabled">
+        <source>MSB9903: PreferNativeArm64 requires a Win32 application manifest and is mutually exclusive with NoWin32Manifest.</source>
+        <target state="translated">MSB9903: element PreferNativeArm64 wymaga manifestu aplikacji Win32 i wzajemnie się wyklucza z elementem NoWin32Manifest.</target>
+        <note>{StrBegin="MSB9903: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.PlatformIsAnyCPUAndPreferNativeArm64Enabled">
+        <source>MSB9904: When PreferNativeArm64 is enabled, ensure that the Platform is set to AnyCPU. Current Platform: {0}.</source>
+        <target state="translated">MSB9904: po włączeniu elementu PreferNativeArm64 upewnij się, że platforma ma wartość AnyCPU. Bieżąca platforma: {0}.</target>
+        <note>{StrBegin="MSB9904: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.Prefer32BitAndPreferNativeArm64Enabled">
+        <source>MSB9902: Prefer32Bit and PreferNativeArm64 options are mutually exclusive. Please enable only one.</source>
+        <target state="translated">MSB9902: opcje Prefer32Bit i PreferNativeArm64 wykluczają się wzajemnie. Włącz tylko jedną.</target>
+        <note>{StrBegin="MSB9902: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.SpecifiedSeverityDoesNotExist">
+        <source>MSB9901: The specified severity is not relevant: '{0}' for the message: '{1}'.</source>
+        <target state="translated">MSB9901: określona ważność nie jest istotna: „{0}” dla komunikatu: „{1}”.</target>
+        <note>{StrBegin="MSB9901: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: Błąd krytyczny: liczba argumentów wiersza polecenia większa niż {0}.</target>
@@ -1564,6 +1594,21 @@
         <target state="translated">Działanie funkcji StopOnFirstFailure nie przyniesie efektu, jeśli będą spełnione wszystkie następujące warunki: 1) System działa w trybie wieloprocesowym. 2) Właściwość BuildInParallel ma wartość true. 3) Właściwość RunEachTargetSeparately ma wartość false.</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="AddToWin32Manifest.AssemblyNodeIsMissed">
+        <source>The assembly element is missing from the application manifest.</source>
+        <target state="translated">Brak elementu zestawu w manifeście aplikacji.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.InvalidValueInSupportedArchitectures">
+        <source>MSB4300: The specified value '{0}' for the supportedArchitectures element is invalid. Either remove it from the manifest or set it to 'amd64 arm64'.</source>
+        <target state="translated">MSB4300: określona wartość „{0}” dla elementu supportedArchitectures jest nieprawidłowa. Usuń ją z manifestu lub ustaw na wartość „amd64 arm64”.</target>
+        <note>{StrBegin="MSB4300: "}</note>
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.SpecifiedApplicationManifestCanNotBeFound">
+        <source>The application manifest file cannot be found. Please make sure it exists.</source>
+        <target state="translated">Nie można odnaleźć pliku manifestu aplikacji. Upewnij się, że istnieje.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: Nie można odczytać wierszy z pliku „{0}”. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index d6bccad1740..51d2f87ec55 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -2,6 +2,16 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="pt-BR" original="../Strings.resx">
     <body>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpened">
+        <source>The manifest file either does not exist or can not be read. Please make sure it exists and has relevant content.</source>
+        <target state="translated">O arquivo de manifesto não existe ou não pode ser lido. Certifique-se de que ele exista e tenha conteúdo relevante.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpenedWithException">
+        <source>The manifest file opening has failed with exception: '{0}'. Please make sure it exists and has relevant content.</source>
+        <target state="translated">A abertura do arquivo de manifesto falhou com a exceção: '{0}'. Certifique-se de que ele exista e tenha conteúdo relevante.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AppConfig.BindingRedirectMissingOldVersion">
         <source>BindingRedirect is missing required field 'oldVersion'.</source>
         <target state="translated">O campo "oldVersion" obrigatório está ausente em BindingRedirect.</target>
@@ -131,6 +141,26 @@
         <target state="translated">MSB3992: '{0}' não está definido. Quando {1} for verdadeiro, certifique-se de definir um valor para '{0}'.</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
+      <trans-unit id="CommonTarget.NoWin32ManifestAndPreferNativeArm64Enabled">
+        <source>MSB9903: PreferNativeArm64 requires a Win32 application manifest and is mutually exclusive with NoWin32Manifest.</source>
+        <target state="translated">MSB9903: PreferNativeArm64 requer um manifesto do aplicativo Win32 e é mutuamente exclusiva com NoWin32Manifest.</target>
+        <note>{StrBegin="MSB9903: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.PlatformIsAnyCPUAndPreferNativeArm64Enabled">
+        <source>MSB9904: When PreferNativeArm64 is enabled, ensure that the Platform is set to AnyCPU. Current Platform: {0}.</source>
+        <target state="translated">MSB9904: Quando PreferNativeArm64 estiver habilitado, certifique-se de que a Plataforma esteja definida como AnyCPU. Plataforma Atual: {0}.</target>
+        <note>{StrBegin="MSB9904: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.Prefer32BitAndPreferNativeArm64Enabled">
+        <source>MSB9902: Prefer32Bit and PreferNativeArm64 options are mutually exclusive. Please enable only one.</source>
+        <target state="translated">MSB9902: As opções Prefer32Bit e PreferNativeArm64 são mutuamente exclusivas. Habilite apenas um.</target>
+        <note>{StrBegin="MSB9902: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.SpecifiedSeverityDoesNotExist">
+        <source>MSB9901: The specified severity is not relevant: '{0}' for the message: '{1}'.</source>
+        <target state="translated">MSB9901: A gravidade especificada não é relevante: '{0}' para a mensagem: '{1}'.</target>
+        <note>{StrBegin="MSB9901: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: Erro Fatal: mais de {0} argumentos de linha de comando.</target>
@@ -1564,6 +1594,21 @@
         <target state="translated">StopOnFirstFailure não terá efeito quando estas condições existirem: 1) O sistema estiver sendo executado no modo de processamento múltiplo 2) A propriedade BuildInParallel for true. 3) A propriedade RunEachTargetSeparately for false.</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="AddToWin32Manifest.AssemblyNodeIsMissed">
+        <source>The assembly element is missing from the application manifest.</source>
+        <target state="translated">O elemento assembly está ausente no manifesto do aplicativo.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.InvalidValueInSupportedArchitectures">
+        <source>MSB4300: The specified value '{0}' for the supportedArchitectures element is invalid. Either remove it from the manifest or set it to 'amd64 arm64'.</source>
+        <target state="translated">MSB4300: O valor especificado “{0}” para o elemento supportedArchitectures é inválido. Remova-o do manifesto ou defina-o como 'amd64 arm64'.</target>
+        <note>{StrBegin="MSB4300: "}</note>
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.SpecifiedApplicationManifestCanNotBeFound">
+        <source>The application manifest file cannot be found. Please make sure it exists.</source>
+        <target state="translated">O arquivo de manifesto do aplicativo não pode ser encontrado. Verifique se ele existe.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: Não foi possível ler linhas do arquivo "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 13636f628c9..bfe3ff60874 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -2,6 +2,16 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ru" original="../Strings.resx">
     <body>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpened">
+        <source>The manifest file either does not exist or can not be read. Please make sure it exists and has relevant content.</source>
+        <target state="translated">Файл манифеста не существует или не может быть прочитан. Убедитесь, что он существует и содержит релевантный контент.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpenedWithException">
+        <source>The manifest file opening has failed with exception: '{0}'. Please make sure it exists and has relevant content.</source>
+        <target state="translated">Сбой открытия файла манифеста. Исключение: "{0}". Убедитесь, что он существует и содержит релевантный контент.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AppConfig.BindingRedirectMissingOldVersion">
         <source>BindingRedirect is missing required field 'oldVersion'.</source>
         <target state="translated">В BindingRedirect отсутствует обязательное поле "oldVersion".</target>
@@ -131,6 +141,26 @@
         <target state="translated">MSB3992: "{0}" не настроено. Если для {1} присвоено значение true, настройте значение для "{0}".</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
+      <trans-unit id="CommonTarget.NoWin32ManifestAndPreferNativeArm64Enabled">
+        <source>MSB9903: PreferNativeArm64 requires a Win32 application manifest and is mutually exclusive with NoWin32Manifest.</source>
+        <target state="translated">MSB9903: PreferNativeArm64 требует манифеста приложения Win32 и является взаимоисключающим с NoWin32Manifest.</target>
+        <note>{StrBegin="MSB9903: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.PlatformIsAnyCPUAndPreferNativeArm64Enabled">
+        <source>MSB9904: When PreferNativeArm64 is enabled, ensure that the Platform is set to AnyCPU. Current Platform: {0}.</source>
+        <target state="translated">MSB9904: если включен PreferNativeArm64, установите для платформы значение AnyCPU. Текущая платформа: {0}.</target>
+        <note>{StrBegin="MSB9904: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.Prefer32BitAndPreferNativeArm64Enabled">
+        <source>MSB9902: Prefer32Bit and PreferNativeArm64 options are mutually exclusive. Please enable only one.</source>
+        <target state="translated">MSB9902: параметры Prefer32Bit и PreferNativeArm64 являются взаимоисключающими. Включите только один.</target>
+        <note>{StrBegin="MSB9902: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.SpecifiedSeverityDoesNotExist">
+        <source>MSB9901: The specified severity is not relevant: '{0}' for the message: '{1}'.</source>
+        <target state="translated">MSB9901: Указанная серьезность не релевантна: "{0}" для сообщения: "{1}".</target>
+        <note>{StrBegin="MSB9901: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: неустранимая ошибка: число аргументов командной строки превышает {0}.</target>
@@ -1564,6 +1594,21 @@
         <target state="translated">StopOnFirstFailure будет игнорироваться при одновременном соблюдении следующих условий: 1) система выполняется в режиме с несколькими процессами; 2) свойство BuildInParallel имеет значение true; 3) свойство RunEachTargetSeparately имеет значение false.</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="AddToWin32Manifest.AssemblyNodeIsMissed">
+        <source>The assembly element is missing from the application manifest.</source>
+        <target state="translated">Элемент сборки отсутствует в манифесте приложения.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.InvalidValueInSupportedArchitectures">
+        <source>MSB4300: The specified value '{0}' for the supportedArchitectures element is invalid. Either remove it from the manifest or set it to 'amd64 arm64'.</source>
+        <target state="translated">MSB4300: указанное значение "{0}" для элемента supportArchitectures недопустимо. Удалите его из манифеста или установите для него значение "amd64 arm64".</target>
+        <note>{StrBegin="MSB4300: "}</note>
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.SpecifiedApplicationManifestCanNotBeFound">
+        <source>The application manifest file cannot be found. Please make sure it exists.</source>
+        <target state="translated">Не удается найти файл манифеста приложения. Проверьте, существует ли он.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: Не удалось прочесть строки из файла "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 80e916c9578..3239df495ae 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -2,6 +2,16 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="tr" original="../Strings.resx">
     <body>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpened">
+        <source>The manifest file either does not exist or can not be read. Please make sure it exists and has relevant content.</source>
+        <target state="translated">Bildirim dosyası yok veya okunamıyor. Lütfen var olduğundan ve ilgili içeriğe sahip olduğundan emin olun.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpenedWithException">
+        <source>The manifest file opening has failed with exception: '{0}'. Please make sure it exists and has relevant content.</source>
+        <target state="translated">Bildirim dosyası açma işlemi şu özel durumla başarısız oldu: '{0}'. Lütfen var olduğundan ve ilgili içeriğe sahip olduğundan emin olun.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AppConfig.BindingRedirectMissingOldVersion">
         <source>BindingRedirect is missing required field 'oldVersion'.</source>
         <target state="translated">BindingRedirect için gereken 'oldVersion' alanı eksik.</target>
@@ -131,6 +141,26 @@
         <target state="translated">MSB3992: '{0}' ayarlanmamış. {1} doğru olduğunda, '{0}' için bir değer ayarlandığından emin olun.</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
+      <trans-unit id="CommonTarget.NoWin32ManifestAndPreferNativeArm64Enabled">
+        <source>MSB9903: PreferNativeArm64 requires a Win32 application manifest and is mutually exclusive with NoWin32Manifest.</source>
+        <target state="translated">MSB9903: PreferNativeArm64 bir Win32 uygulama bildirimi gerektirir ve NoWin32Manifest ile birbirini dışlar.</target>
+        <note>{StrBegin="MSB9903: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.PlatformIsAnyCPUAndPreferNativeArm64Enabled">
+        <source>MSB9904: When PreferNativeArm64 is enabled, ensure that the Platform is set to AnyCPU. Current Platform: {0}.</source>
+        <target state="translated">MSB9904: PreferNativeArm64 etkinleştirildiğinde, Platformun AnyCPU olarak ayarlandığından emin olun. Geçerli Platform: {0}.</target>
+        <note>{StrBegin="MSB9904: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.Prefer32BitAndPreferNativeArm64Enabled">
+        <source>MSB9902: Prefer32Bit and PreferNativeArm64 options are mutually exclusive. Please enable only one.</source>
+        <target state="translated">MSB9902: Prefer32Bit ve PreferNativeArm64 seçenekleri birbirini dışlar. Lütfen yalnızca birini etkinleştirin.</target>
+        <note>{StrBegin="MSB9902: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.SpecifiedSeverityDoesNotExist">
+        <source>MSB9901: The specified severity is not relevant: '{0}' for the message: '{1}'.</source>
+        <target state="translated">MSB9901: Belirtilen önem derecesi ilişkili değil: '{1}' iletisi için '{0}'.</target>
+        <note>{StrBegin="MSB9901: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: Kritik Hata: Komut satırı bağımsız değişkenleri şu sayıdan fazla: {0}.</target>
@@ -1564,6 +1594,21 @@
         <target state="translated">Şu koşulların tümü doğru olduğunda StopOnFirstFailure etkisiz olur: 1) Sistem çoklu işlem modunda çalışıyorsa. 2) BuildInParallel özelliği true ise. 3) RunEachTargetSeparately özelliği false ise.</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="AddToWin32Manifest.AssemblyNodeIsMissed">
+        <source>The assembly element is missing from the application manifest.</source>
+        <target state="translated">Uygulama bildiriminde bütünleştirilmiş kod öğesi eksik.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.InvalidValueInSupportedArchitectures">
+        <source>MSB4300: The specified value '{0}' for the supportedArchitectures element is invalid. Either remove it from the manifest or set it to 'amd64 arm64'.</source>
+        <target state="translated">MSB4300: SupportedArchitectures öğesi için belirtilen '{0}' değeri geçersiz. Bildirimden kaldırın veya 'amd64 arm64' olarak ayarlayın.</target>
+        <note>{StrBegin="MSB4300: "}</note>
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.SpecifiedApplicationManifestCanNotBeFound">
+        <source>The application manifest file cannot be found. Please make sure it exists.</source>
+        <target state="translated">Uygulama bildirim dosyası bulunamıyor. Lütfen var olduğundan emin olun.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: "{0}" dosyasındaki satırlar okunamadı. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index fb45fb03527..4a16a34cc82 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -2,6 +2,16 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Strings.resx">
     <body>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpened">
+        <source>The manifest file either does not exist or can not be read. Please make sure it exists and has relevant content.</source>
+        <target state="translated">清单文件不存在或无法读取。请确保它存在并具有相关内容。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpenedWithException">
+        <source>The manifest file opening has failed with exception: '{0}'. Please make sure it exists and has relevant content.</source>
+        <target state="translated">清单文件打开失败，出现异常:“{0}”。请确保它存在并具有相关内容。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AppConfig.BindingRedirectMissingOldVersion">
         <source>BindingRedirect is missing required field 'oldVersion'.</source>
         <target state="translated">BindingRedirect 缺少必需的字段“oldVersion”。</target>
@@ -131,6 +141,26 @@
         <target state="translated">MSB3992: 未设置 "{0}"。如果 {1} 为 true，请确保为 "{0}" 设置值。</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
+      <trans-unit id="CommonTarget.NoWin32ManifestAndPreferNativeArm64Enabled">
+        <source>MSB9903: PreferNativeArm64 requires a Win32 application manifest and is mutually exclusive with NoWin32Manifest.</source>
+        <target state="translated">MSB9903: PreferNativeArm64 需要 Win32 应用程序清单，并且与 NoWin32Manifest 互斥。</target>
+        <note>{StrBegin="MSB9903: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.PlatformIsAnyCPUAndPreferNativeArm64Enabled">
+        <source>MSB9904: When PreferNativeArm64 is enabled, ensure that the Platform is set to AnyCPU. Current Platform: {0}.</source>
+        <target state="translated">MSB9904: 启用 PreferNativeArm64 时，请确保平台设置为 AnyCPU。当前平台: {0}。</target>
+        <note>{StrBegin="MSB9904: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.Prefer32BitAndPreferNativeArm64Enabled">
+        <source>MSB9902: Prefer32Bit and PreferNativeArm64 options are mutually exclusive. Please enable only one.</source>
+        <target state="translated">MSB9902: Prefer32Bit 和 PreferNativeArm64 选项互斥。请仅启用一个。</target>
+        <note>{StrBegin="MSB9902: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.SpecifiedSeverityDoesNotExist">
+        <source>MSB9901: The specified severity is not relevant: '{0}' for the message: '{1}'.</source>
+        <target state="translated">MSB9901: 指定的严重性不相关: 消息“{1}”的“{0}”。</target>
+        <note>{StrBegin="MSB9901: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: 严重错误: 超出 {0} 个命令行参数。</target>
@@ -1564,6 +1594,21 @@
         <target state="translated">如果满足以下所有条件，StopOnFirstFailure 将不起任何作用: 1) 系统在多进程模式下运行。2) BuildInParallel 属性为 true。3) RunEachTargetSeparately 属性为 false。</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="AddToWin32Manifest.AssemblyNodeIsMissed">
+        <source>The assembly element is missing from the application manifest.</source>
+        <target state="translated">应用程序清单中缺少程序集元素。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.InvalidValueInSupportedArchitectures">
+        <source>MSB4300: The specified value '{0}' for the supportedArchitectures element is invalid. Either remove it from the manifest or set it to 'amd64 arm64'.</source>
+        <target state="translated">MSB4300: supportedArchitectures 元素的指定值“{0}”无效。将其从清单中移除或设置为 "amd64 arm64"。</target>
+        <note>{StrBegin="MSB4300: "}</note>
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.SpecifiedApplicationManifestCanNotBeFound">
+        <source>The application manifest file cannot be found. Please make sure it exists.</source>
+        <target state="translated">找不到应用程序清单文件。请确保它存在。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: 未能从文件“{0}”读取命令行。{1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 1ce29e770f5..2ef9b7e4e22 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -2,6 +2,16 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Strings.resx">
     <body>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpened">
+        <source>The manifest file either does not exist or can not be read. Please make sure it exists and has relevant content.</source>
+        <target state="translated">資訊清單檔案不存在或無法讀取。請確定它存在且具有相關內容。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.ManifestCanNotBeOpenedWithException">
+        <source>The manifest file opening has failed with exception: '{0}'. Please make sure it exists and has relevant content.</source>
+        <target state="translated">資訊清單檔案開啟失敗，發生例外狀況: '{0}'。請確定它存在且具有相關內容。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AppConfig.BindingRedirectMissingOldVersion">
         <source>BindingRedirect is missing required field 'oldVersion'.</source>
         <target state="translated">BindingRedirect 遺漏必要的 'oldVersion' 欄位。</target>
@@ -131,6 +141,26 @@
         <target state="translated">MSB3992: 未設定 '{0}'。當 {1} 為 true 時，請務必j將 '{0}' 設定一個值。</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
+      <trans-unit id="CommonTarget.NoWin32ManifestAndPreferNativeArm64Enabled">
+        <source>MSB9903: PreferNativeArm64 requires a Win32 application manifest and is mutually exclusive with NoWin32Manifest.</source>
+        <target state="translated">MSB9903: PreferNativeArm64 需要 Win32 應用程式資訊清單，且與 NoWin32Manifest 互斥。</target>
+        <note>{StrBegin="MSB9903: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.PlatformIsAnyCPUAndPreferNativeArm64Enabled">
+        <source>MSB9904: When PreferNativeArm64 is enabled, ensure that the Platform is set to AnyCPU. Current Platform: {0}.</source>
+        <target state="translated">MSB9904: 啟用 PreferNativeArm64 時，請確認平台已設為 AnyCPU。目前平台: {0}。</target>
+        <note>{StrBegin="MSB9904: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.Prefer32BitAndPreferNativeArm64Enabled">
+        <source>MSB9902: Prefer32Bit and PreferNativeArm64 options are mutually exclusive. Please enable only one.</source>
+        <target state="translated">MSB9902: Prefer32Bit 和 PreferNativeArm64 選項互斥。請只啟用一個。</target>
+        <note>{StrBegin="MSB9902: "}</note>
+      </trans-unit>
+      <trans-unit id="CommonTarget.SpecifiedSeverityDoesNotExist">
+        <source>MSB9901: The specified severity is not relevant: '{0}' for the message: '{1}'.</source>
+        <target state="translated">MSB9901: 指定的嚴重性不相關: 訊息 '{1}' 的 '{0}'。</target>
+        <note>{StrBegin="MSB9901: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: 嚴重錯誤: 命令列引數的數目超過 {0} 個。</target>
@@ -1564,6 +1594,21 @@
         <target state="translated">當下列條件全部成立時，StopOnFirstFailure 將沒有作用: 1) 系統正在多處理程序模式中執行 2) BuildInParallel 屬性為 true。3) RunEachTargetSeparately 屬性為 false。</target>
         <note>LOCALIZATION:  Do not localize the words "RunEachTargetSeparately", "BuildingInParallel", or "StopOnFirstFailure".</note>
       </trans-unit>
+      <trans-unit id="AddToWin32Manifest.AssemblyNodeIsMissed">
+        <source>The assembly element is missing from the application manifest.</source>
+        <target state="translated">應用程式資訊清單中遺失組件元素。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.InvalidValueInSupportedArchitectures">
+        <source>MSB4300: The specified value '{0}' for the supportedArchitectures element is invalid. Either remove it from the manifest or set it to 'amd64 arm64'.</source>
+        <target state="translated">MSB4300: supportedArchitectures 元素的指定值 '{0}' 無效。請將它從資訊清單移除，或將其設為 'amd64 arm64'。</target>
+        <note>{StrBegin="MSB4300: "}</note>
+      </trans-unit>
+      <trans-unit id="AddToWin32Manifest.SpecifiedApplicationManifestCanNotBeFound">
+        <source>The application manifest file cannot be found. Please make sure it exists.</source>
+        <target state="translated">找不到應用程式資訊清單檔。請確定它存在。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ReadLinesFromFile.ErrorOrWarning">
         <source>MSB3501: Could not read lines from file "{0}". {1}</source>
         <target state="translated">MSB3501: 無法從檔案 "{0}" 讀取行。{1}</target>
diff --git a/template_feed/Microsoft.Build.Templates.csproj b/template_feed/Microsoft.Build.Templates.csproj
new file mode 100644
index 00000000000..d56a04b4c27
--- /dev/null
+++ b/template_feed/Microsoft.Build.Templates.csproj
@@ -0,0 +1,29 @@
+<Project Sdk="Microsoft.NET.Sdk">
+
+  <PropertyGroup>
+    <PackageId>Microsoft.Build.Templates</PackageId>
+    <Authors>Microsoft</Authors>
+    <Description>Common Microsoft Build Templates</Description>
+    <PackageProjectUrl>https://github.com/dotnet/msbuild</PackageProjectUrl>
+    <PackageType>Template</PackageType>
+    <TargetFramework>$(LatestDotNetCoreForMSBuild)</TargetFramework>
+    <IncludeBuildOutput>false</IncludeBuildOutput>
+    <NoWarn>$(NoWarn);NU5128</NoWarn>
+    <IsPackable>true</IsPackable>
+    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
+  </PropertyGroup>
+
+  <PropertyGroup>
+    <LocalizeTemplates>false</LocalizeTemplates>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <PackageReference Include="Microsoft.TemplateEngine.Tasks" Version="*" PrivateAssets="all" IsImplicitlyDefined="true"/>
+  </ItemGroup>
+
+  <ItemGroup>
+    <Content Include="content\**" Exclude="content\**\bin\**;content\**\obj\**" PackagePath="content"/>
+    <Compile Remove="**\*" />
+  </ItemGroup>
+
+</Project>
diff --git a/template_feed/README.md b/template_feed/README.md
new file mode 100644
index 00000000000..f2b021d3647
--- /dev/null
+++ b/template_feed/README.md
@@ -0,0 +1,9 @@
+## MSBuild Custom Analyzer Template Package
+
+The package contains the template designed to streamline the creation of MSBuild analyzer libraries.
+| Template name | Short name | Description|
+|---|---|---|
+|MSBuild Custom Analyzer Template|`msbuildanalyzer`|A project for creating a MSBuild analyzer library that targets .NET Standard.|
+
+The package is available for download from nuget.org.
+Please feel to contribute or provide the feedback in discussions or via opening the issue in dotnet/msbuild repo.
diff --git a/template_feed/Microsoft.AnalyzerTemplate/.template.config/template.json b/template_feed/content/Microsoft.AnalyzerTemplate/.template.config/template.json
similarity index 99%
rename from template_feed/Microsoft.AnalyzerTemplate/.template.config/template.json
rename to template_feed/content/Microsoft.AnalyzerTemplate/.template.config/template.json
index 52c4467e930..8bd2d1853e3 100644
--- a/template_feed/Microsoft.AnalyzerTemplate/.template.config/template.json
+++ b/template_feed/content/Microsoft.AnalyzerTemplate/.template.config/template.json
@@ -46,4 +46,4 @@
         "continueOnError": true
       }
     ]
-  }
\ No newline at end of file
+  }
diff --git a/template_feed/Microsoft.AnalyzerTemplate/Analyzer1.cs b/template_feed/content/Microsoft.AnalyzerTemplate/Analyzer1.cs
similarity index 100%
rename from template_feed/Microsoft.AnalyzerTemplate/Analyzer1.cs
rename to template_feed/content/Microsoft.AnalyzerTemplate/Analyzer1.cs
diff --git a/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj b/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
similarity index 100%
rename from template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
rename to template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
diff --git a/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props b/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props
similarity index 100%
rename from template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props
rename to template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/README.md b/template_feed/content/Microsoft.AnalyzerTemplate/README.md
new file mode 100644
index 00000000000..4f29145e7f0
--- /dev/null
+++ b/template_feed/content/Microsoft.AnalyzerTemplate/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Analyzer Template
+
+## Overview
+MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild analyzer libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom analysis rules.
+
+## Getting Started
+To use the MSBuild Custom Analyzer Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildanalyzer
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildanalyzer -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
\ No newline at end of file
