diff --git a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
index fbe94d80c8d..ba5e65870a0 100644
--- a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
@@ -128,11 +128,11 @@ public AssignTargetPath() { }
     public partial class CallTarget : Microsoft.Build.Tasks.TaskExtension
     {
         public CallTarget() { }
-        public bool RunEachTargetSeparately { get { throw null; } set { } }
+        public bool RunEachTargetSeparately { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         public Microsoft.Build.Framework.ITaskItem[] TargetOutputs { get { throw null; } }
-        public string[] Targets { get { throw null; } set { } }
-        public bool UseResultsCache { get { throw null; } set { } }
+        public string[] Targets { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool UseResultsCache { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public partial class CodeTaskFactory : Microsoft.Build.Framework.ITaskFactory
@@ -267,21 +267,21 @@ public void Cancel() { }
     public sealed partial class Error : Microsoft.Build.Tasks.TaskExtension
     {
         public Error() { }
-        public string Code { get { throw null; } set { } }
-        public string File { get { throw null; } set { } }
-        public string HelpKeyword { get { throw null; } set { } }
-        public string Text { get { throw null; } set { } }
+        public string Code { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string File { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string HelpKeyword { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Text { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public sealed partial class ErrorFromResources : Microsoft.Build.Tasks.TaskExtension
     {
         public ErrorFromResources() { }
-        public string[] Arguments { get { throw null; } set { } }
-        public string Code { get { throw null; } set { } }
-        public string File { get { throw null; } set { } }
-        public string HelpKeyword { get { throw null; } set { } }
+        public string[] Arguments { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Code { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string File { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string HelpKeyword { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
-        public string Resource { get { throw null; } set { } }
+        public string Resource { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public partial class Exec : Microsoft.Build.Tasks.ToolTaskExtension
@@ -295,7 +295,7 @@ public Exec() { }
         public string CustomErrorRegularExpression { get { throw null; } set { } }
         public string CustomWarningRegularExpression { get { throw null; } set { } }
         public bool IgnoreExitCode { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
-        public bool IgnoreStandardErrorWarningFormat { get { throw null; } set { } }
+        public bool IgnoreStandardErrorWarningFormat { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         public Microsoft.Build.Framework.ITaskItem[] Outputs { get { throw null; } set { } }
         protected override System.Text.Encoding StandardErrorEncoding { get { throw null; } }
@@ -322,34 +322,34 @@ protected override void LogToolCommand(string message) { }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public partial struct ExtractedClassName
     {
-        public bool IsInsideConditionalBlock { get { throw null; } set { } }
-        public string Name { get { throw null; } set { } }
+        public bool IsInsideConditionalBlock { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Name { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
     }
     public partial class FindAppConfigFile : Microsoft.Build.Tasks.TaskExtension
     {
         public FindAppConfigFile() { }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem AppConfigFile { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem AppConfigFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] PrimaryList { get { throw null; } set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] SecondaryList { get { throw null; } set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
-        public string TargetPath { get { throw null; } set { } }
+        public string TargetPath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public partial class FindInList : Microsoft.Build.Tasks.TaskExtension
     {
         public FindInList() { }
-        public bool CaseSensitive { get { throw null; } set { } }
-        public bool FindLastMatch { get { throw null; } set { } }
+        public bool CaseSensitive { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool FindLastMatch { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem ItemFound { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem ItemFound { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
-        public string ItemSpecToFind { get { throw null; } set { } }
+        public string ItemSpecToFind { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] List { get { throw null; } set { } }
-        public bool MatchFileNameOnly { get { throw null; } set { } }
+        public bool MatchFileNameOnly { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public partial class FindInvalidProjectReferences : Microsoft.Build.Tasks.TaskExtension
@@ -380,43 +380,43 @@ public FindUnderPath() { }
     public sealed partial class FormatUrl : Microsoft.Build.Tasks.TaskExtension
     {
         public FormatUrl() { }
-        public string InputUrl { get { throw null; } set { } }
+        public string InputUrl { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public string OutputUrl { get { throw null; } set { } }
+        public string OutputUrl { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public sealed partial class FormatVersion : Microsoft.Build.Tasks.TaskExtension
     {
         public FormatVersion() { }
-        public string FormatType { get { throw null; } set { } }
+        public string FormatType { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public string OutputVersion { get { throw null; } set { } }
-        public int Revision { get { throw null; } set { } }
-        public string Version { get { throw null; } set { } }
+        public string OutputVersion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public int Revision { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Version { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public sealed partial class GenerateApplicationManifest : Microsoft.Build.Tasks.GenerateManifestBase
     {
         public GenerateApplicationManifest() { }
-        public string ClrVersion { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem ConfigFile { get { throw null; } set { } }
+        public string ClrVersion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public Microsoft.Build.Framework.ITaskItem ConfigFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public Microsoft.Build.Framework.ITaskItem[] Dependencies { get { throw null; } set { } }
-        public string ErrorReportUrl { get { throw null; } set { } }
+        public string ErrorReportUrl { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public Microsoft.Build.Framework.ITaskItem[] FileAssociations { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
-        public bool HostInBrowser { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem IconFile { get { throw null; } set { } }
+        public bool HostInBrowser { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public Microsoft.Build.Framework.ITaskItem IconFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public Microsoft.Build.Framework.ITaskItem[] IsolatedComReferences { get { throw null; } set { } }
-        public string ManifestType { get { throw null; } set { } }
-        public string OSVersion { get { throw null; } set { } }
-        public string Product { get { throw null; } set { } }
-        public string Publisher { get { throw null; } set { } }
-        public bool RequiresMinimumFramework35SP1 { get { throw null; } set { } }
-        public string SuiteName { get { throw null; } set { } }
-        public string SupportUrl { get { throw null; } set { } }
-        public string TargetFrameworkProfile { get { throw null; } set { } }
-        public string TargetFrameworkSubset { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem TrustInfoFile { get { throw null; } set { } }
+        public string ManifestType { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string OSVersion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Product { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Publisher { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool RequiresMinimumFramework35SP1 { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string SuiteName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string SupportUrl { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string TargetFrameworkProfile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string TargetFrameworkSubset { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public Microsoft.Build.Framework.ITaskItem TrustInfoFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public bool UseApplicationTrust { get { throw null; } set { } }
         protected override System.Type GetObjectType() { throw null; }
         protected override bool OnManifestLoaded(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
@@ -436,46 +436,46 @@ public GenerateBindingRedirects() { }
     public sealed partial class GenerateBootstrapper : Microsoft.Build.Tasks.TaskExtension
     {
         public GenerateBootstrapper() { }
-        public string ApplicationFile { get { throw null; } set { } }
-        public string ApplicationName { get { throw null; } set { } }
-        public bool ApplicationRequiresElevation { get { throw null; } set { } }
-        public string ApplicationUrl { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string[] BootstrapperComponentFiles { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] BootstrapperItems { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string BootstrapperKeyFile { get { throw null; } set { } }
-        public string ComponentsLocation { get { throw null; } set { } }
-        public string ComponentsUrl { get { throw null; } set { } }
-        public bool CopyComponents { get { throw null; } set { } }
-        public string Culture { get { throw null; } set { } }
-        public string FallbackCulture { get { throw null; } set { } }
-        public string OutputPath { get { throw null; } set { } }
-        public string Path { get { throw null; } set { } }
-        public string SupportUrl { get { throw null; } set { } }
-        public bool Validate { get { throw null; } set { } }
-        public string VisualStudioVersion { get { throw null; } set { } }
+        public string ApplicationFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string ApplicationName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool ApplicationRequiresElevation { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string ApplicationUrl { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public string[] BootstrapperComponentFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public Microsoft.Build.Framework.ITaskItem[] BootstrapperItems { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public string BootstrapperKeyFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string ComponentsLocation { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string ComponentsUrl { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool CopyComponents { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Culture { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string FallbackCulture { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string OutputPath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Path { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string SupportUrl { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool Validate { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string VisualStudioVersion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public sealed partial class GenerateDeploymentManifest : Microsoft.Build.Tasks.GenerateManifestBase
     {
         public GenerateDeploymentManifest() { }
         public bool CreateDesktopShortcut { get { throw null; } set { } }
-        public string DeploymentUrl { get { throw null; } set { } }
+        public string DeploymentUrl { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public bool DisallowUrlActivation { get { throw null; } set { } }
         public string ErrorReportUrl { get { throw null; } set { } }
         public bool Install { get { throw null; } set { } }
         public bool MapFileExtensions { get { throw null; } set { } }
-        public string MinimumRequiredVersion { get { throw null; } set { } }
-        public string Product { get { throw null; } set { } }
-        public string Publisher { get { throw null; } set { } }
+        public string MinimumRequiredVersion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Product { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Publisher { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string SuiteName { get { throw null; } set { } }
-        public string SupportUrl { get { throw null; } set { } }
+        public string SupportUrl { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public bool TrustUrlParameters { get { throw null; } set { } }
         public bool UpdateEnabled { get { throw null; } set { } }
         public int UpdateInterval { get { throw null; } set { } }
-        public string UpdateMode { get { throw null; } set { } }
-        public string UpdateUnit { get { throw null; } set { } }
+        public string UpdateMode { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string UpdateUnit { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         protected override System.Type GetObjectType() { throw null; }
         protected override bool OnManifestLoaded(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
         protected override bool OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
@@ -484,17 +484,17 @@ public GenerateDeploymentManifest() { }
     public abstract partial class GenerateManifestBase : Microsoft.Build.Utilities.Task
     {
         protected GenerateManifestBase() { }
-        public string AssemblyName { get { throw null; } set { } }
-        public string AssemblyVersion { get { throw null; } set { } }
-        public string Description { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem InputManifest { get { throw null; } set { } }
-        public int MaxTargetPath { get { throw null; } set { } }
+        public string AssemblyName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string AssemblyVersion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Description { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public Microsoft.Build.Framework.ITaskItem EntryPoint { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public Microsoft.Build.Framework.ITaskItem InputManifest { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public int MaxTargetPath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem OutputManifest { get { throw null; } set { } }
-        public string Platform { get { throw null; } set { } }
-        public string TargetCulture { get { throw null; } set { } }
-        public string TargetFrameworkMoniker { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem OutputManifest { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Platform { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string TargetCulture { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string TargetFrameworkMoniker { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string TargetFrameworkVersion { get { throw null; } set { } }
         protected internal Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference AddAssemblyFromItem(Microsoft.Build.Framework.ITaskItem item) { throw null; }
         protected internal Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference AddAssemblyNameFromItem(Microsoft.Build.Framework.ITaskItem item, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType referenceType) { throw null; }
@@ -551,21 +551,21 @@ public GenerateResource() { }
     public sealed partial class GenerateTrustInfo : Microsoft.Build.Tasks.TaskExtension
     {
         public GenerateTrustInfo() { }
-        public Microsoft.Build.Framework.ITaskItem[] ApplicationDependencies { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem BaseManifest { get { throw null; } set { } }
-        public string ExcludedPermissions { get { throw null; } set { } }
-        public string TargetFrameworkMoniker { get { throw null; } set { } }
-        public string TargetZone { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] ApplicationDependencies { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public Microsoft.Build.Framework.ITaskItem BaseManifest { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string ExcludedPermissions { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string TargetFrameworkMoniker { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string TargetZone { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem TrustInfoFile { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem TrustInfoFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public partial class GetAssemblyIdentity : Microsoft.Build.Tasks.TaskExtension
     {
         public GetAssemblyIdentity() { }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Assemblies { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Assemblies { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] AssemblyFiles { get { throw null; } set { } }
         public override bool Execute() { throw null; }
@@ -644,14 +644,14 @@ public GetInstalledSDKLocations() { }
     public partial class GetReferenceAssemblyPaths : Microsoft.Build.Tasks.TaskExtension
     {
         public GetReferenceAssemblyPaths() { }
-        public bool BypassFrameworkInstallChecks { get { throw null; } set { } }
+        public bool BypassFrameworkInstallChecks { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         public string[] FullFrameworkReferenceAssemblyPaths { get { throw null; } }
         [Microsoft.Build.Framework.OutputAttribute]
         public string[] ReferenceAssemblyPaths { get { throw null; } }
-        public string RootPath { get { throw null; } set { } }
+        public string RootPath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public bool SuppressNotFoundError { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
-        public string TargetFrameworkMoniker { get { throw null; } set { } }
+        public string TargetFrameworkMoniker { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         public string TargetFrameworkMonikerDisplayName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
@@ -661,7 +661,7 @@ public partial class GetSDKReferenceFiles : Microsoft.Build.Tasks.TaskExtension
         public GetSDKReferenceFiles() { }
         public string CacheFileFolderPath { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] CopyLocalFiles { get { throw null; } }
+        public Microsoft.Build.Framework.ITaskItem[] CopyLocalFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public bool LogCacheFileExceptions { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public bool LogRedistConflictBetweenSDKsAsWarning { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public bool LogRedistConflictWithinSDKAsWarning { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
@@ -670,10 +670,10 @@ public GetSDKReferenceFiles() { }
         public bool LogReferenceConflictWithinSDKAsWarning { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public bool LogReferencesList { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] RedistFiles { get { throw null; } }
+        public Microsoft.Build.Framework.ITaskItem[] RedistFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public string[] ReferenceExtensions { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] References { get { throw null; } }
+        public Microsoft.Build.Framework.ITaskItem[] References { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public Microsoft.Build.Framework.ITaskItem[] ResolvedSDKReferences { get { throw null; } set { } }
         public string TargetPlatformIdentifier { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string TargetPlatformVersion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
@@ -741,18 +741,18 @@ public MakeDir() { }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] Directories { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] DirectoriesCreated { get { throw null; } }
+        public Microsoft.Build.Framework.ITaskItem[] DirectoriesCreated { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public override bool Execute() { throw null; }
     }
     public sealed partial class Message : Microsoft.Build.Tasks.TaskExtension
     {
         public Message() { }
-        public string Code { get { throw null; } set { } }
-        public string File { get { throw null; } set { } }
-        public string HelpKeyword { get { throw null; } set { } }
-        public string Importance { get { throw null; } set { } }
-        public bool IsCritical { get { throw null; } set { } }
-        public string Text { get { throw null; } set { } }
+        public string Code { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string File { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string HelpKeyword { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Importance { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool IsCritical { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Text { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public partial class Move : Microsoft.Build.Tasks.TaskExtension, Microsoft.Build.Framework.ICancelableTask, Microsoft.Build.Framework.ITask
@@ -762,7 +762,7 @@ public Move() { }
         public Microsoft.Build.Framework.ITaskItem[] DestinationFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public Microsoft.Build.Framework.ITaskItem DestinationFolder { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] MovedFiles { get { throw null; } }
+        public Microsoft.Build.Framework.ITaskItem[] MovedFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public bool OverwriteReadOnlyFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] SourceFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
@@ -773,22 +773,22 @@ public void Cancel() { }
     public partial class MSBuild : Microsoft.Build.Tasks.TaskExtension
     {
         public MSBuild() { }
-        public bool BuildInParallel { get { throw null; } set { } }
+        public bool BuildInParallel { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Projects { get { throw null; } set { } }
-        public string[] Properties { get { throw null; } set { } }
-        public bool RebaseOutputs { get { throw null; } set { } }
-        public string RemoveProperties { get { throw null; } set { } }
-        public bool RunEachTargetSeparately { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Projects { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string[] Properties { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool RebaseOutputs { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string RemoveProperties { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool RunEachTargetSeparately { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string SkipNonexistentProjects { get { throw null; } set { } }
-        public bool StopOnFirstFailure { get { throw null; } set { } }
-        public string[] TargetAndPropertyListSeparators { get { throw null; } set { } }
+        public bool StopOnFirstFailure { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string[] TargetAndPropertyListSeparators { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         public Microsoft.Build.Framework.ITaskItem[] TargetOutputs { get { throw null; } }
-        public string[] Targets { get { throw null; } set { } }
-        public string ToolsVersion { get { throw null; } set { } }
-        public bool UnloadProjectsOnCompletion { get { throw null; } set { } }
-        public bool UseResultsCache { get { throw null; } set { } }
+        public string[] Targets { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string ToolsVersion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool UnloadProjectsOnCompletion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool UseResultsCache { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public partial class ReadLinesFromFile : Microsoft.Build.Tasks.TaskExtension
diff --git a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
index cc819d42ff0..72ac670b95b 100644
--- a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
@@ -57,11 +57,11 @@ public AssignTargetPath() { }
     public partial class CallTarget : Microsoft.Build.Tasks.TaskExtension
     {
         public CallTarget() { }
-        public bool RunEachTargetSeparately { get { throw null; } set { } }
+        public bool RunEachTargetSeparately { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         public Microsoft.Build.Framework.ITaskItem[] TargetOutputs { get { throw null; } }
-        public string[] Targets { get { throw null; } set { } }
-        public bool UseResultsCache { get { throw null; } set { } }
+        public string[] Targets { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool UseResultsCache { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     [System.ObsoleteAttribute("The CodeTaskFactory is not supported on .NET Core.  This class is included so that users receive run-time errors and should not be used for any other purpose.", true)]
@@ -197,21 +197,21 @@ public void Cancel() { }
     public sealed partial class Error : Microsoft.Build.Tasks.TaskExtension
     {
         public Error() { }
-        public string Code { get { throw null; } set { } }
-        public string File { get { throw null; } set { } }
-        public string HelpKeyword { get { throw null; } set { } }
-        public string Text { get { throw null; } set { } }
+        public string Code { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string File { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string HelpKeyword { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Text { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public sealed partial class ErrorFromResources : Microsoft.Build.Tasks.TaskExtension
     {
         public ErrorFromResources() { }
-        public string[] Arguments { get { throw null; } set { } }
-        public string Code { get { throw null; } set { } }
-        public string File { get { throw null; } set { } }
-        public string HelpKeyword { get { throw null; } set { } }
+        public string[] Arguments { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Code { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string File { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string HelpKeyword { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
-        public string Resource { get { throw null; } set { } }
+        public string Resource { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public partial class Exec : Microsoft.Build.Tasks.ToolTaskExtension
@@ -225,7 +225,7 @@ public Exec() { }
         public string CustomErrorRegularExpression { get { throw null; } set { } }
         public string CustomWarningRegularExpression { get { throw null; } set { } }
         public bool IgnoreExitCode { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
-        public bool IgnoreStandardErrorWarningFormat { get { throw null; } set { } }
+        public bool IgnoreStandardErrorWarningFormat { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         public Microsoft.Build.Framework.ITaskItem[] Outputs { get { throw null; } set { } }
         protected override System.Text.Encoding StandardErrorEncoding { get { throw null; } }
@@ -252,34 +252,34 @@ protected override void LogToolCommand(string message) { }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public partial struct ExtractedClassName
     {
-        public bool IsInsideConditionalBlock { get { throw null; } set { } }
-        public string Name { get { throw null; } set { } }
+        public bool IsInsideConditionalBlock { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Name { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
     }
     public partial class FindAppConfigFile : Microsoft.Build.Tasks.TaskExtension
     {
         public FindAppConfigFile() { }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem AppConfigFile { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem AppConfigFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] PrimaryList { get { throw null; } set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] SecondaryList { get { throw null; } set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
-        public string TargetPath { get { throw null; } set { } }
+        public string TargetPath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public partial class FindInList : Microsoft.Build.Tasks.TaskExtension
     {
         public FindInList() { }
-        public bool CaseSensitive { get { throw null; } set { } }
-        public bool FindLastMatch { get { throw null; } set { } }
+        public bool CaseSensitive { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool FindLastMatch { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem ItemFound { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem ItemFound { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
-        public string ItemSpecToFind { get { throw null; } set { } }
+        public string ItemSpecToFind { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] List { get { throw null; } set { } }
-        public bool MatchFileNameOnly { get { throw null; } set { } }
+        public bool MatchFileNameOnly { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public partial class FindUnderPath : Microsoft.Build.Tasks.TaskExtension
@@ -298,11 +298,11 @@ public FindUnderPath() { }
     public sealed partial class FormatVersion : Microsoft.Build.Tasks.TaskExtension
     {
         public FormatVersion() { }
-        public string FormatType { get { throw null; } set { } }
+        public string FormatType { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public string OutputVersion { get { throw null; } set { } }
-        public int Revision { get { throw null; } set { } }
-        public string Version { get { throw null; } set { } }
+        public string OutputVersion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public int Revision { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Version { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public partial class GenerateBindingRedirects : Microsoft.Build.Tasks.TaskExtension
@@ -359,7 +359,7 @@ public partial class GetAssemblyIdentity : Microsoft.Build.Tasks.TaskExtension
     {
         public GetAssemblyIdentity() { }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Assemblies { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Assemblies { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] AssemblyFiles { get { throw null; } set { } }
         public override bool Execute() { throw null; }
@@ -402,14 +402,14 @@ public GetFrameworkPath() { }
     public partial class GetReferenceAssemblyPaths : Microsoft.Build.Tasks.TaskExtension
     {
         public GetReferenceAssemblyPaths() { }
-        public bool BypassFrameworkInstallChecks { get { throw null; } set { } }
+        public bool BypassFrameworkInstallChecks { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         public string[] FullFrameworkReferenceAssemblyPaths { get { throw null; } }
         [Microsoft.Build.Framework.OutputAttribute]
         public string[] ReferenceAssemblyPaths { get { throw null; } }
-        public string RootPath { get { throw null; } set { } }
+        public string RootPath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public bool SuppressNotFoundError { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
-        public string TargetFrameworkMoniker { get { throw null; } set { } }
+        public string TargetFrameworkMoniker { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         public string TargetFrameworkMonikerDisplayName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
@@ -429,18 +429,18 @@ public MakeDir() { }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] Directories { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] DirectoriesCreated { get { throw null; } }
+        public Microsoft.Build.Framework.ITaskItem[] DirectoriesCreated { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public override bool Execute() { throw null; }
     }
     public sealed partial class Message : Microsoft.Build.Tasks.TaskExtension
     {
         public Message() { }
-        public string Code { get { throw null; } set { } }
-        public string File { get { throw null; } set { } }
-        public string HelpKeyword { get { throw null; } set { } }
-        public string Importance { get { throw null; } set { } }
-        public bool IsCritical { get { throw null; } set { } }
-        public string Text { get { throw null; } set { } }
+        public string Code { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string File { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string HelpKeyword { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Importance { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool IsCritical { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string Text { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public partial class Move : Microsoft.Build.Tasks.TaskExtension, Microsoft.Build.Framework.ICancelableTask, Microsoft.Build.Framework.ITask
@@ -450,7 +450,7 @@ public Move() { }
         public Microsoft.Build.Framework.ITaskItem[] DestinationFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public Microsoft.Build.Framework.ITaskItem DestinationFolder { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] MovedFiles { get { throw null; } }
+        public Microsoft.Build.Framework.ITaskItem[] MovedFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public bool OverwriteReadOnlyFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] SourceFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
@@ -461,22 +461,22 @@ public void Cancel() { }
     public partial class MSBuild : Microsoft.Build.Tasks.TaskExtension
     {
         public MSBuild() { }
-        public bool BuildInParallel { get { throw null; } set { } }
+        public bool BuildInParallel { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Projects { get { throw null; } set { } }
-        public string[] Properties { get { throw null; } set { } }
-        public bool RebaseOutputs { get { throw null; } set { } }
-        public string RemoveProperties { get { throw null; } set { } }
-        public bool RunEachTargetSeparately { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Projects { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string[] Properties { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool RebaseOutputs { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string RemoveProperties { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool RunEachTargetSeparately { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string SkipNonexistentProjects { get { throw null; } set { } }
-        public bool StopOnFirstFailure { get { throw null; } set { } }
-        public string[] TargetAndPropertyListSeparators { get { throw null; } set { } }
+        public bool StopOnFirstFailure { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string[] TargetAndPropertyListSeparators { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         public Microsoft.Build.Framework.ITaskItem[] TargetOutputs { get { throw null; } }
-        public string[] Targets { get { throw null; } set { } }
-        public string ToolsVersion { get { throw null; } set { } }
-        public bool UnloadProjectsOnCompletion { get { throw null; } set { } }
-        public bool UseResultsCache { get { throw null; } set { } }
+        public string[] Targets { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string ToolsVersion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool UnloadProjectsOnCompletion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool UseResultsCache { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public partial class ReadLinesFromFile : Microsoft.Build.Tasks.TaskExtension
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index 8011f798eae..36c720c6c96 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -6,7 +6,6 @@
 //-----------------------------------------------------------------------
 
 using System;
-using System.CodeDom.Compiler;
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
@@ -19,8 +18,6 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Definition;
-using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
@@ -48,7 +45,7 @@ public class BuildManager_Tests : IDisposable
         /// <summary>
         /// The standard build manager for each test.
         /// </summary>
-        private BuildManager _buildManager;
+        private readonly BuildManager _buildManager;
 
         /// <summary>
         /// The build parameters.
@@ -132,8 +129,7 @@ public void SimpleBuild()
             ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
             Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
 
-            string propertyValue;
-            Assert.True(properties.TryGetValue("InitialProperty1", out propertyValue));
+            Assert.True(properties.TryGetValue("InitialProperty1", out string propertyValue));
             Assert.True(String.Equals(propertyValue, "InitialProperty1", StringComparison.OrdinalIgnoreCase));
 
             Assert.True(properties.TryGetValue("InitialProperty2", out propertyValue));
@@ -176,8 +172,7 @@ public void VerifyEnvironmentSavedBetweenCalls()
 
             project.Save();
 
-            
-                string contents2 = CleanupFileContents(@"
+            string contents2 = CleanupFileContents(@"
 <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
         <Target Name='Build' >
          <MSBuild Targets='SetEnv' Projects='" + project.FullPath + "'/>" +
@@ -216,9 +211,12 @@ public void ShutdownNodesAfterParallelBuild(int numberOfParallelProjectsToBuild,
             _env.ClearTestInvariants();
 
             // Communications debug log enabled, picked up by TestEnvironment
-            if (enbaleDebugComm) _env.SetEnvironmentVariable("MSBUILDDEBUGCOMM", "1");
+            if (enbaleDebugComm)
+            {
+                _env.SetEnvironmentVariable("MSBUILDDEBUGCOMM", "1");
+            }
 
-            ProjectCollection projectCollection = new ProjectCollection();
+            var projectCollection = new ProjectCollection();
 
             // Get number of MSBuild processes currently instantiated
             int numberProcsOriginally = (new List<Process>(Process.GetProcessesByName("MSBuild"))).Count;
@@ -243,13 +241,12 @@ public void ShutdownNodesAfterParallelBuild(int numberOfParallelProjectsToBuild,
             };
 
             // Tell the build manager to not disturb process wide state
-
-            BuildRequestData requestData = new BuildRequestData(rootProject, new[] { "Build" }, null);
+            var requestData = new BuildRequestData(rootProject, new[] { "Build" }, null);
 
             // Use a separate BuildManager for the node shutdown build, so that we don't have 
             // to worry about taking dependencies on whether or not the existing ones have already 
             // disappeared. 
-            BuildManager shutdownManager = new BuildManager("IdleNodeShutdown");
+            var shutdownManager = new BuildManager("IdleNodeShutdown");
             shutdownManager.Build(buildParameters, requestData);
 
             // Number of nodes after the build has to be greater than the original number
@@ -307,7 +304,7 @@ public void DisableInProcNode()
         /// <param name="buildParametersModifier">Runs a test out of proc.</param>
         public void RunOutOfProcBuild(Action<BuildParameters> buildParametersModifier)
         {
-            const string Contents = @"
+            const string contents = @"
 <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
 <ItemGroup>
        <InitialProperty Include='InitialProperty2'/>
@@ -325,10 +322,10 @@ public void RunOutOfProcBuild(Action<BuildParameters> buildParametersModifier)
             // Need to set this env variable to enable Process.GetCurrentProcess().Id in the project file.
             _env.SetEnvironmentVariable("MSBUILDENABLEALLPROPERTYFUNCTIONS", "1");
 
-            Project project = CreateProject(CleanupFileContents(Contents), MSBuildDefaultToolsVersion, _projectCollection, false);
+            Project project = CreateProject(CleanupFileContents(contents), MSBuildDefaultToolsVersion, _projectCollection, false);
 
-            BuildRequestData data = new BuildRequestData(project.CreateProjectInstance(), new string[0], _projectCollection.HostServices);
-            BuildParameters customparameters = new BuildParameters { EnableNodeReuse = false, Loggers = new ILogger[] { _logger } };
+            var data = new BuildRequestData(project.CreateProjectInstance(), new string[0], _projectCollection.HostServices);
+            var customparameters = new BuildParameters { EnableNodeReuse = false, Loggers = new ILogger[] { _logger } };
             buildParametersModifier(customparameters);
 
             BuildResult result = _buildManager.Build(customparameters, data);
@@ -337,8 +334,7 @@ public void RunOutOfProcBuild(Action<BuildParameters> buildParametersModifier)
 
             Assert.Equal(BuildResultCode.Success, result.OverallResult);
             Assert.Equal(3, item.Length);
-            int processId;
-            Assert.True(int.TryParse(item[2].ItemSpec, out processId), $"Process ID passed from the 'test' target is not a valid integer (actual is '{item[2].ItemSpec}')");
+            Assert.True(int.TryParse(item[2].ItemSpec, out int processId), $"Process ID passed from the 'test' target is not a valid integer (actual is '{item[2].ItemSpec}')");
             Assert.NotEqual(Process.GetCurrentProcess().Id, processId); // "Build is expected to be out-of-proc. In fact it was in-proc."
         }
 
@@ -393,10 +389,10 @@ public void RequestedResultsAreSatisfied()
                 PropertyFilters = new List<string> {"NewProperty", "RequestedProperty"},
             };
 
-            BuildRequestData data = new BuildRequestData(project.CreateProjectInstance(), new [] {"test", "other"},
+            var data = new BuildRequestData(project.CreateProjectInstance(), new [] {"test", "other"},
                 _projectCollection.HostServices, BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild, null,
                 requestedProjectState);
-            BuildParameters customparameters = new BuildParameters
+            var customparameters = new BuildParameters
             {
                 EnableNodeReuse = false,
                 Loggers = new ILogger[] {_logger},
@@ -465,8 +461,7 @@ public void InProcForwardPropertiesFromChild()
             ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
             Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
 
-            string propertyValue;
-            Assert.True(properties.TryGetValue("InitialProperty1", out propertyValue));
+            Assert.True(properties.TryGetValue("InitialProperty1", out string propertyValue));
             Assert.True(String.Equals(propertyValue, "InitialProperty1", StringComparison.OrdinalIgnoreCase));
 
             Assert.True(properties.TryGetValue("InitialProperty2", out propertyValue));
@@ -506,8 +501,7 @@ public void InProcMsBuildForwardAllPropertiesFromChild()
             ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
             Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
 
-            string propertyValue = null;
-            Assert.True(properties.TryGetValue("InitialProperty1", out propertyValue));
+            Assert.True(properties.TryGetValue("InitialProperty1", out string propertyValue));
             Assert.True(String.Equals(propertyValue, "InitialProperty1", StringComparison.OrdinalIgnoreCase));
 
             Assert.True(properties.TryGetValue("InitialProperty2", out propertyValue));
@@ -551,8 +545,7 @@ public void MsBuildForwardAllPropertiesFromChildLaunchChildNode()
             ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
             Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
 
-            string propertyValue;
-            Assert.True(properties.TryGetValue("InitialProperty1", out propertyValue));
+            Assert.True(properties.TryGetValue("InitialProperty1", out string propertyValue));
             Assert.True(String.Equals(propertyValue, "InitialProperty1", StringComparison.OrdinalIgnoreCase));
 
             Assert.True(properties.TryGetValue("InitialProperty2", out propertyValue));
@@ -605,8 +598,7 @@ public void OutOfProcNodeForwardCertainproperties()
 
             Assert.Equal(1, properties.Count);
 
-            string propertyValue;
-            Assert.True(properties.TryGetValue("InitialProperty3", out propertyValue));
+            Assert.True(properties.TryGetValue("InitialProperty3", out string propertyValue));
             Assert.True(String.Equals(propertyValue, "InitialProperty3", StringComparison.OrdinalIgnoreCase));
         }
 
@@ -675,8 +667,7 @@ public void OutOfProcNodeForwardCertainpropertiesAlsoGetResultsFromCache()
             Assert.NotNull(properties);
             Assert.Equal(1, properties.Count);
 
-            string propertyValue;
-            Assert.True(properties.TryGetValue("InitialProperty3", out propertyValue));
+            Assert.True(properties.TryGetValue("InitialProperty3", out string propertyValue));
             Assert.True(String.Equals(propertyValue, "InitialProperty3", StringComparison.OrdinalIgnoreCase));
 
             projectStartedEvent = _logger.ProjectStartedEvents[2];
@@ -775,16 +766,15 @@ public override bool Execute()
 
             _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
 
-            ProjectCollection projectCollection = new ProjectCollection();
-            Toolset newToolSet = new Toolset("CustomToolSet", "c:\\SomePath", projectCollection, null);
+            var projectCollection = new ProjectCollection();
+            var newToolSet = new Toolset("CustomToolSet", "c:\\SomePath", projectCollection, null);
             projectCollection.AddToolset(newToolSet);
 
             var project = CreateProject(contents, null, projectCollection, false);
             var data = new BuildRequestData(project.FullPath, new Dictionary<string, string>(),
                 MSBuildDefaultToolsVersion, new string[] { }, null);
 
-            BuildParameters customParameters = new BuildParameters(projectCollection);
-            customParameters.Loggers = new ILogger[] { _logger };
+            var customParameters = new BuildParameters(projectCollection) { Loggers = new ILogger[] { _logger } };
             BuildResult result = _buildManager.Build(customParameters, data);
             Assert.Equal(BuildResultCode.Success, result.OverallResult);
         }
@@ -811,7 +801,8 @@ public void ForwardNoPropertiesLaunchChildNodeDefault()
     <Message Text='[success]'/>
  </Target>
 </Project>
-");            _env.SetEnvironmentVariable("MsBuildForwardPropertiesFromChild", null);
+");
+            _env.SetEnvironmentVariable("MsBuildForwardPropertiesFromChild", null);
             _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
 
             var project = CreateProject(contents, null, _projectCollection, false);
@@ -1103,7 +1094,7 @@ public void EndBuildCalledWithinSubmissionCallback()
             BuildRequestData data = GetBuildRequestData(contents);
             _buildManager.BeginBuild(_parameters);
             BuildSubmission submission1 = _buildManager.PendBuildRequest(data);
-            AutoResetEvent callbackFinished = new AutoResetEvent(false);
+            var callbackFinished = new AutoResetEvent(false);
             submission1.ExecuteAsync(submission =>
             {
                 _buildManager.EndBuild();
@@ -1208,7 +1199,7 @@ public void OverlappingIdenticalBuildSubmissions()
 ");
 
             BuildRequestData data = GetBuildRequestData(contents);
-            BuildRequestData data2 = new BuildRequestData(data.ProjectInstance, data.TargetNames.ToArray(), data.HostServices);
+            var data2 = new BuildRequestData(data.ProjectInstance, data.TargetNames.ToArray(), data.HostServices);
 
             _buildManager.BeginBuild(_parameters);
             BuildSubmission submission1 = _buildManager.PendBuildRequest(data);
@@ -1259,7 +1250,7 @@ public void OverlappingBuildSubmissions_OnlyOneSucceeds()
 ");
 
             BuildRequestData data = GetBuildRequestData(contents, new[] { "A" });
-            BuildRequestData data2 = new BuildRequestData(data.ProjectInstance, new[] { "MaySkip" }, data.HostServices);
+            var data2 = new BuildRequestData(data.ProjectInstance, new[] { "MaySkip" }, data.HostServices);
 
             _buildManager.BeginBuild(_parameters);
             BuildSubmission submission1 = _buildManager.PendBuildRequest(data);
@@ -1608,7 +1599,7 @@ public void OutOfProcNodeDoesntLockWorkingDirectory()
 
             File.WriteAllText(projectFile, contents);
             _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
-            BuildRequestData data = new BuildRequestData(projectFile, new Dictionary<string, string>(), MSBuildDefaultToolsVersion, new string[] { }, null);
+            var data = new BuildRequestData(projectFile, new Dictionary<string, string>(), MSBuildDefaultToolsVersion, new string[] { }, null);
             _buildManager.Build(_parameters, data);
         }
 
@@ -1763,12 +1754,12 @@ public void GhostProjectRootElementCache()
 
             // Create Project 1
             ProjectInstance projectInstance = CreateProjectInstance(contents1, null, _projectCollection, false);
-            BuildRequestData data = new BuildRequestData(projectInstance, new string[0]);
+            var data = new BuildRequestData(projectInstance, new string[0]);
 
             _logger.ClearLog();
 
             // Write the second project to disk and load it into its own project collection
-            ProjectCollection projectCollection2 = new ProjectCollection();
+            var projectCollection2 = new ProjectCollection();
             File.WriteAllText(p2pProject, contents2);
 
             Project project2 = projectCollection2.LoadProject(p2pProject);
@@ -1790,7 +1781,7 @@ public void GhostProjectRootElementCache()
 
             // Create a new build.
             ProjectInstance projectInstance2 = CreateProjectInstance(contents1, null, _projectCollection, false);
-            BuildRequestData data2 = new BuildRequestData(projectInstance2, new string[0]);
+            var data2 = new BuildRequestData(projectInstance2, new string[0]);
 
             // Build again.
             _parameters.ResetCaches = false;
@@ -1830,7 +1821,7 @@ public void VerifyImportedProjectRootElementsInheritExplicitLoadFlag()
             var projectCollection = new ProjectCollection();
 
             // Run a simple build just to prove that nothing is left in the cache.
-            BuildRequestData data = new BuildRequestData(rootProjectPath, ReadOnlyEmptyDictionary<string, string>.Instance, null, new[] { "test" }, null);
+            var data = new BuildRequestData(rootProjectPath, ReadOnlyEmptyDictionary<string, string>.Instance, null, new[] { "test" }, null);
             _parameters.ResetCaches = true;
             _parameters.ProjectRootElementCache = projectCollection.ProjectRootElementCache;
             _buildManager.BeginBuild(_parameters);
@@ -1895,7 +1886,7 @@ public void Regress251333()
             Assert.Equal(result.OverallResult, BuildResultCode.Success);
 
             // Now a build using a different build manager.
-            using (BuildManager newBuildManager = new BuildManager())
+            using (var newBuildManager = new BuildManager())
             {
                 GetBuildRequestData(contents);
                 BuildResult result2 = newBuildManager.Build(_parameters, data);
@@ -1928,7 +1919,7 @@ public void Regress239661()
             
             string fileName = _env.CreateFile(".proj").Path;
             File.WriteAllText(fileName, contents);
-            BuildRequestData data = new BuildRequestData(fileName, _projectCollection.GlobalProperties, MSBuildDefaultToolsVersion, new string[0], null);
+            var data = new BuildRequestData(fileName, _projectCollection.GlobalProperties, MSBuildDefaultToolsVersion, new string[0], null);
             _parameters.DisableInProcNode = true;
             BuildResult result = _buildManager.Build(_parameters, data);
             Assert.Equal(BuildResultCode.Success, result.OverallResult);
@@ -1999,7 +1990,7 @@ public void ProjectInstanceTransfersToOOPNode()
 
             string fileName = _env.CreateFile(".proj").Path;
             File.WriteAllText(fileName, contents);
-            Project project = new Project(fileName);
+            var project = new Project(fileName);
             ProjectInstance instance = project.CreateProjectInstance();
             instance.RemoveProperty("DeleteMe");
             instance.SetProperty("VirtualProp", "overridden");
@@ -2015,7 +2006,7 @@ public void ProjectInstanceTransfersToOOPNode()
                 }
             }
 
-            BuildRequestData data = new BuildRequestData(instance, new string[0]);
+            var data = new BuildRequestData(instance, new string[0]);
 
             // Force this to build out-of-proc
             _parameters.DisableInProcNode = true;
@@ -2059,7 +2050,7 @@ public void ProjectInstanceLimitedTransferToOOPNode()
             instance.SetProperty("VirtualProp", "overridden");
             instance.SetProperty("Unmodified", "changed");
 
-            BuildRequestData data = new BuildRequestData(instance, new string[0], null, BuildRequestDataFlags.None, new string[] { "VirtualProp" });
+            var data = new BuildRequestData(instance, new string[0], null, BuildRequestDataFlags.None, new string[] { "VirtualProp" });
 
             // Force this to build out-of-proc
             _parameters.DisableInProcNode = true;
@@ -2078,12 +2069,10 @@ public void ProjectInstanceLimitedTransferToOOPNode()
         [Trait("Category", "mono-osx-failing")]
         public void CacheLifetime()
         {
-            
             FileUtilities.ClearCacheDirectory();
 
             _env.SetEnvironmentVariable("MSBUILDDEBUGFORCECACHING", "1");
             string outerBuildCacheDirectory;
-            string innerBuildCacheDirectory;
 
             // Do a build with one build manager.
             using (var outerBuildManager = new BuildManager())
@@ -2093,9 +2082,10 @@ public void CacheLifetime()
                 // Do another build with a second build manager while the first still exists.  Since both BuildManagers
                 // share a process-wide cache directory, we want to verify that they don't stomp on each other, either
                 // by accidentally sharing results, or by clearing them away.
+                string innerBuildCacheDirectory;
                 using (var innerBuildManager = new BuildManager())
                 {
-                    innerBuildCacheDirectory = BuildAndCheckCache(innerBuildManager, new string[] { outerBuildCacheDirectory });
+                    innerBuildCacheDirectory = BuildAndCheckCache(innerBuildManager, new[] { outerBuildCacheDirectory });
 
                     // Force the cache for this build manager (and only this build manager) to be cleared.  It should leave 
                     // behind the results from the other one.
@@ -2133,7 +2123,7 @@ public void FailedAfterTargetInP2PShouldCauseOverallBuildFailure()
 </Project>
 ";
 
-            string contentsB = @"
+            const string contentsB = @"
 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
   <Target Name=`Build`>
     <Message Text=`Build` />
@@ -2149,7 +2139,7 @@ public void FailedAfterTargetInP2PShouldCauseOverallBuildFailure()
             File.WriteAllText(projB, CleanupFileContents(contentsB));
 
             _buildManager.BeginBuild(_parameters);
-            BuildRequestData data = new BuildRequestData(projA, new Dictionary<string, string>(), null, new[] { "Build" }, new HostServices());
+            var data = new BuildRequestData(projA, new Dictionary<string, string>(), null, new[] { "Build" }, new HostServices());
             BuildResult result = _buildManager.PendBuildRequest(data).Execute();
 
             Assert.Equal(BuildResultCode.Failure, result.OverallResult);
@@ -2179,7 +2169,7 @@ public void FailedAfterTargetInP2PShouldCauseOverallBuildFailure_MultipleEntrypo
 </Project>
 ";
 
-            string contentsB = @"
+            const string contentsB = @"
 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
   <Target Name=`Build`>
     <Message Text=`[Build]` />
@@ -2207,7 +2197,7 @@ public void FailedAfterTargetInP2PShouldCauseOverallBuildFailure_MultipleEntrypo
             File.WriteAllText(projB, CleanupFileContents(contentsB));
 
             _buildManager.BeginBuild(_parameters);
-            BuildRequestData data = new BuildRequestData(projA, new Dictionary<string, string>(), null, new[] { "Build" }, new HostServices());
+            var data = new BuildRequestData(projA, new Dictionary<string, string>(), null, new[] { "Build" }, new HostServices());
             BuildResult result = _buildManager.PendBuildRequest(data).Execute();
 
             Assert.Equal(BuildResultCode.Failure, result.OverallResult);
@@ -2242,7 +2232,7 @@ public void FailedNestedAfterTargetInP2PShouldCauseOverallBuildFailure()
 </Project>
 ";
 
-            string contentsB = @"
+            const string contentsB = @"
 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
   <Target Name=`Build`>
     <Message Text=`Build` />
@@ -2262,7 +2252,7 @@ public void FailedNestedAfterTargetInP2PShouldCauseOverallBuildFailure()
             File.WriteAllText(projB, CleanupFileContents(contentsB));
 
             _buildManager.BeginBuild(_parameters);
-            BuildRequestData data = new BuildRequestData(projA, new Dictionary<string, string>(), null, new[] { "Build" }, new HostServices());
+            var data = new BuildRequestData(projA, new Dictionary<string, string>(), null, new[] { "Build" }, new HostServices());
             BuildResult result = _buildManager.PendBuildRequest(data).Execute();
 
             Assert.Equal(BuildResultCode.Failure, result.OverallResult);
@@ -2293,7 +2283,7 @@ public void NonOverlappingEnusingTrypointTargetsShouldNotInfluenceEachOthersResu
 </Project>
 ";
 
-            string contentsB = @"
+            const string contentsB = @"
 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
   <Target Name=`Build`>
     <Error Text=`Forced error in Build` />
@@ -2310,7 +2300,7 @@ public void NonOverlappingEnusingTrypointTargetsShouldNotInfluenceEachOthersResu
             File.WriteAllText(projB, CleanupFileContents(contentsB));
 
             _buildManager.BeginBuild(_parameters);
-            BuildRequestData data = new BuildRequestData(projA, new Dictionary<string, string>(), null, new[] { "Build" }, new HostServices());
+            var data = new BuildRequestData(projA, new Dictionary<string, string>(), null, new[] { "Build" }, new HostServices());
             BuildResult result = _buildManager.PendBuildRequest(data).Execute();
 
             Assert.Equal(BuildResultCode.Success, result.OverallResult);
@@ -2401,7 +2391,7 @@ public void Regress473114()
             _parameters.MaxNodeCount = 3;
             _parameters.EnableNodeReuse = false;
             _buildManager.BeginBuild(_parameters);
-            BuildRequestData data = new BuildRequestData(projA, new Dictionary<string, string>(), "4.0", new[] { "Build" }, new HostServices());
+            var data = new BuildRequestData(projA, new Dictionary<string, string>(), "4.0", new[] { "Build" }, new HostServices());
             BuildResult result = _buildManager.PendBuildRequest(data).Execute();
 
             Assert.Equal(BuildResultCode.Success, result.OverallResult);
@@ -2475,7 +2465,7 @@ public void VerifyMultipleRequestForSameProjectWithErrors_Simple()
             _parameters.MaxNodeCount = 2;
             _parameters.EnableNodeReuse = false;
             _buildManager.BeginBuild(_parameters);
-            BuildRequestData data = new BuildRequestData(projA, new Dictionary<string, string>(), null,
+            var data = new BuildRequestData(projA, new Dictionary<string, string>(), null,
                 new[] {"Build"}, new HostServices());
             BuildResult result = _buildManager.PendBuildRequest(data).Execute();
 
@@ -2576,7 +2566,7 @@ public void VerifyMultipleRequestForSameProjectWithErrors_OnErrorChain()
             _parameters.MaxNodeCount = 2;
             _parameters.EnableNodeReuse = false;
             _buildManager.BeginBuild(_parameters);
-            BuildRequestData data = new BuildRequestData(projA, new Dictionary<string, string>(), null,
+            var data = new BuildRequestData(projA, new Dictionary<string, string>(), null,
                 new[] {"Build"}, new HostServices());
             BuildResult result = _buildManager.PendBuildRequest(data).Execute();
 
@@ -2680,7 +2670,7 @@ public void VerifyMultipleRequestForSameProjectWithErrors_ErrorAndContinue()
             _parameters.MaxNodeCount = 2;
             _parameters.EnableNodeReuse = false;
             _buildManager.BeginBuild(_parameters);
-            BuildRequestData data = new BuildRequestData(projA, new Dictionary<string, string>(), null,
+            var data = new BuildRequestData(projA, new Dictionary<string, string>(), null,
                 new[] {"Build"}, new HostServices());
             BuildResult result = _buildManager.PendBuildRequest(data).Execute();
 
@@ -2770,7 +2760,7 @@ public void VerifyMultipleRequestForSameProjectWithErrors_AfterTargets()
             _parameters.MaxNodeCount = 2;
             _parameters.EnableNodeReuse = false;
             _buildManager.BeginBuild(_parameters);
-            BuildRequestData data = new BuildRequestData(projA, new Dictionary<string, string>(), null,
+            var data = new BuildRequestData(projA, new Dictionary<string, string>(), null,
                 new[] {"Build"}, new HostServices());
             BuildResult result = _buildManager.PendBuildRequest(data).Execute();
 
@@ -2812,7 +2802,7 @@ public void VerifyMultipleRequestForSameProjectWithErrors_DifferentEntrypoints()
 </Project>
 ";
 
-            string contentsB = @"
+            const string contentsB = @"
 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
   <Target Name=`Build` DependsOnTargets=`Target1;Error1`>
     <Message Text=`[Build]` />
@@ -2839,7 +2829,7 @@ public void VerifyMultipleRequestForSameProjectWithErrors_DifferentEntrypoints()
             File.WriteAllText(projB, CleanupFileContents(contentsB));
 
             _buildManager.BeginBuild(_parameters);
-            BuildRequestData data = new BuildRequestData(projA, new Dictionary<string, string>(), null,
+            var data = new BuildRequestData(projA, new Dictionary<string, string>(), null,
                 new[] {"Build"}, new HostServices());
             BuildResult result = _buildManager.PendBuildRequest(data).Execute();
 
@@ -2870,20 +2860,23 @@ public void TestSimultaneousSubmissionsWithLegacyThreadingData()
             var projectPath1 = _env.CreateFile(".proj").Path;
             File.WriteAllText(projectPath1, CleanupFileContents(projectContent));
 
-            Project project1 = new Project(projectPath1);
+            var project1 = new Project(projectPath1);
 
             var projectPath2 = _env.CreateFile(".proj").Path;
             File.WriteAllText(projectPath2, CleanupFileContents(projectContent));
 
-            Project project2 = new Project(projectPath2);
+            var project2 = new Project(projectPath2);
 
             ConsoleLogger cl = new ConsoleLogger();
-            BuildParameters buildParameters = new BuildParameters(ProjectCollection.GlobalProjectCollection);
-            buildParameters.Loggers = new ILogger[] { cl };
-            buildParameters.LegacyThreadingSemantics = true;
+            var buildParameters =
+                new BuildParameters(ProjectCollection.GlobalProjectCollection)
+                {
+                    Loggers = new ILogger[] { cl },
+                    LegacyThreadingSemantics = true
+                };
             BuildManager.DefaultBuildManager.BeginBuild(buildParameters);
 
-            AutoResetEvent project1DoneEvent = new AutoResetEvent(false);
+            var project1DoneEvent = new AutoResetEvent(false);
             ThreadPool.QueueUserWorkItem(delegate
             {
                 ProjectInstance pi = BuildManager.DefaultBuildManager.GetProjectInstanceForBuild(project1);
@@ -2894,7 +2887,7 @@ public void TestSimultaneousSubmissionsWithLegacyThreadingData()
                 project1DoneEvent.Set();
             });
 
-            AutoResetEvent project2DoneEvent = new AutoResetEvent(false);
+            var project2DoneEvent = new AutoResetEvent(false);
             ThreadPool.QueueUserWorkItem(delegate
             {
                 ProjectInstance pi = BuildManager.DefaultBuildManager.GetProjectInstanceForBuild(project2);
@@ -2935,7 +2928,7 @@ public void TestSimultaneousSubmissionsWithLegacyThreadingData_P2P()
             var projectPath1 = _env.CreateFile(".proj").Path;
             File.WriteAllText(projectPath1, CleanupFileContents(projectContent1));
 
-            Project project1 = new Project(projectPath1);
+            var project1 = new Project(projectPath1);
 
             string projectContent2 = @"<Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
     <Target Name=`MSDeployPublish` />
@@ -2950,15 +2943,18 @@ public void TestSimultaneousSubmissionsWithLegacyThreadingData_P2P()
             var projectPath2 = _env.CreateFile(".proj").Path;
             File.WriteAllText(projectPath2, CleanupFileContents(projectContent2));
 
-            Project project2 = new Project(projectPath2);
+            var project2 = new Project(projectPath2);
 
-            ConsoleLogger cl = new ConsoleLogger();
-            BuildParameters buildParameters = new BuildParameters(ProjectCollection.GlobalProjectCollection);
-            buildParameters.Loggers = new ILogger[] { cl };
-            buildParameters.LegacyThreadingSemantics = true;
+            var cl = new ConsoleLogger();
+            var buildParameters =
+                new BuildParameters(ProjectCollection.GlobalProjectCollection)
+                {
+                    Loggers = new ILogger[] { cl },
+                    LegacyThreadingSemantics = true
+                };
             BuildManager.DefaultBuildManager.BeginBuild(buildParameters);
 
-            AutoResetEvent project1DoneEvent = new AutoResetEvent(false);
+            var project1DoneEvent = new AutoResetEvent(false);
             ThreadPool.QueueUserWorkItem(delegate
             {
                 // need to kick off project 2 first so that it project 1 can get submitted before the P2P happens
@@ -2971,7 +2967,7 @@ public void TestSimultaneousSubmissionsWithLegacyThreadingData_P2P()
                 project1DoneEvent.Set();
             });
 
-            AutoResetEvent project2DoneEvent = new AutoResetEvent(false);
+            var project2DoneEvent = new AutoResetEvent(false);
             ThreadPool.QueueUserWorkItem(delegate
             {
                 ProjectInstance pi = BuildManager.DefaultBuildManager.GetProjectInstanceForBuild(project1);
@@ -3018,10 +3014,10 @@ public void TestSimultaneousSubmissionsWithLegacyThreadingData_P2P_MP()
 </Project>
 ";
 
-            var projectPath1 = _env.CreateFile(".proj").Path;
+            string projectPath1 = _env.CreateFile(".proj").Path;
             File.WriteAllText(projectPath1, CleanupFileContents(projectContent1));
 
-            Project project1 = new Project(projectPath1);
+            var project1 = new Project(projectPath1);
 
             string projectContent2 = @"<Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
     <Target Name=`MSDeployPublish` />
@@ -3036,17 +3032,20 @@ public void TestSimultaneousSubmissionsWithLegacyThreadingData_P2P_MP()
             var projectPath2 = _env.CreateFile(".proj").Path;
             File.WriteAllText(projectPath2, CleanupFileContents(projectContent2));
 
-            Project project2 = new Project(projectPath2);
+            var project2 = new Project(projectPath2);
 
-            ConsoleLogger cl = new ConsoleLogger();
-            BuildParameters buildParameters = new BuildParameters(ProjectCollection.GlobalProjectCollection);
-            buildParameters.Loggers = new ILogger[] { cl };
-            buildParameters.LegacyThreadingSemantics = true;
-            buildParameters.MaxNodeCount = 2;
-            buildParameters.EnableNodeReuse = false;
+            var cl = new ConsoleLogger();
+            var buildParameters =
+                new BuildParameters(ProjectCollection.GlobalProjectCollection)
+                {
+                    Loggers = new ILogger[] { cl },
+                    LegacyThreadingSemantics = true,
+                    MaxNodeCount = 2,
+                    EnableNodeReuse = false
+                };
             BuildManager.DefaultBuildManager.BeginBuild(buildParameters);
 
-            AutoResetEvent project1DoneEvent = new AutoResetEvent(false);
+            var project1DoneEvent = new AutoResetEvent(false);
             ThreadPool.QueueUserWorkItem(delegate
             {
                 // need to kick off project 2 first so that it project 1 can get submitted before the P2P happens
@@ -3059,7 +3058,7 @@ public void TestSimultaneousSubmissionsWithLegacyThreadingData_P2P_MP()
                 project1DoneEvent.Set();
             });
 
-            AutoResetEvent project2DoneEvent = new AutoResetEvent(false);
+            var project2DoneEvent = new AutoResetEvent(false);
             ThreadPool.QueueUserWorkItem(delegate
             {
                 ProjectInstance pi = BuildManager.DefaultBuildManager.GetProjectInstanceForBuild(project1);
@@ -3118,9 +3117,9 @@ public void Regress265010()
             File.WriteAllText(fileName, contents);
             _buildManager.BeginBuild(_parameters);
 
-            HostServices services = new HostServices();
+            var services = new HostServices();
             services.SetNodeAffinity(fileName, NodeAffinity.OutOfProc);
-            BuildRequestData data = new BuildRequestData(fileName, new Dictionary<string, string>(), MSBuildDefaultToolsVersion, new[] { "BaseTest" }, services);
+            var data = new BuildRequestData(fileName, new Dictionary<string, string>(), MSBuildDefaultToolsVersion, new[] { "BaseTest" }, services);
             _buildManager.PendBuildRequest(data).Execute();
             _logger.AssertLogContains("[BaseValue]");
             _logger.AssertLogContains("[BaseItem]");
@@ -3186,7 +3185,7 @@ public void WarningsAreTreatedAsErrorsSpecific()
             Project project = CreateProject(contents, MSBuildDefaultToolsVersion, _projectCollection, true);
             ProjectInstance instance = _buildManager.GetProjectInstanceForBuild(project);
             _buildManager.BeginBuild(_parameters);
-            BuildResult result1 = _buildManager.BuildRequest(new BuildRequestData(instance, new string[] { "target1" }));
+            BuildResult result1 = _buildManager.BuildRequest(new BuildRequestData(instance, new[] { "target1" }));
             _buildManager.EndBuild();
 
             Assert.Equal(2, _logger.WarningCount);
@@ -3235,7 +3234,7 @@ public void WarningsAreTreatedAsErrorsButTargetsStillSucceed()
         /// <summary>
         /// Helper for cache tests.  Builds a project and verifies the right cache files are created.
         /// </summary>
-        private string BuildAndCheckCache(BuildManager localBuildManager, IEnumerable<string> exceptCacheDirectories)
+        private static string BuildAndCheckCache(BuildManager localBuildManager, IEnumerable<string> exceptCacheDirectories)
         {
             string contents = CleanupFileContents(@"
 <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
@@ -3254,7 +3253,7 @@ private string BuildAndCheckCache(BuildManager localBuildManager, IEnumerable<st
 
             string cacheDirectory = FileUtilities.GetCacheDirectory();
 
-            BuildParameters parameters = new BuildParameters();
+            var parameters = new BuildParameters();
             localBuildManager.BeginBuild(parameters);
             try
             {
@@ -3287,7 +3286,7 @@ private string BuildAndCheckCache(BuildManager localBuildManager, IEnumerable<st
         /// <summary>
         /// Extract a string dictionary from the property enumeration on a project started event.
         /// </summary>
-        private Dictionary<string, string> ExtractProjectStartedPropertyList(IEnumerable properties)
+        private static Dictionary<string, string> ExtractProjectStartedPropertyList(IEnumerable properties)
         {
             // Gather a sorted list of all the properties.
             return properties?.Cast<DictionaryEntry>()
@@ -3307,7 +3306,7 @@ private BuildRequestData GetBuildRequestData(string projectContents)
         /// </summary>
         private BuildRequestData GetBuildRequestData(string projectContents, string[] targets, string toolsVersion = null)
         {
-            BuildRequestData data = new BuildRequestData(
+            var data = new BuildRequestData(
                 CreateProjectInstance(projectContents, toolsVersion, _projectCollection, true), targets,
                 _projectCollection.HostServices);
 
@@ -3328,7 +3327,7 @@ private ProjectInstance CreateProjectInstance(string contents, string toolsVersi
         /// </summary>
         private Project CreateProject(string contents, string toolsVersion, ProjectCollection projectCollection, bool deleteTempProject)
         {
-            Project project = new Project(XmlReader.Create(new StringReader(contents)), null, toolsVersion, projectCollection)
+            var project = new Project(XmlReader.Create(new StringReader(contents)), null, toolsVersion, projectCollection)
             {
                 FullPath = _env.CreateFile().Path
             };
@@ -3349,7 +3348,7 @@ private Project CreateProject(string contents, string toolsVersion, ProjectColle
         /// <summary>
         /// Generate dummy projects
         /// </summary>
-        private ProjectInstance GenerateDummyProjects(string shutdownProjectDirectory, int parallelProjectCount, ProjectCollection projectCollection)
+        private static ProjectInstance GenerateDummyProjects(string shutdownProjectDirectory, int parallelProjectCount, ProjectCollection projectCollection)
         {
             Directory.CreateDirectory(shutdownProjectDirectory);
 
@@ -3372,7 +3371,7 @@ private ProjectInstance GenerateDummyProjects(string shutdownProjectDirectory, i
             //   <Target Name="ChildBuild" />
             // </Project>
             string rootProjectPath = Path.Combine(shutdownProjectDirectory, String.Format(CultureInfo.InvariantCulture, "RootProj_{0}.proj", Guid.NewGuid().ToString("N")));
-            ProjectRootElement rootProject = ProjectRootElement.Create(rootProjectPath, projectCollection);
+            var rootProject = ProjectRootElement.Create(rootProjectPath, projectCollection);
 
             ProjectTargetElement buildTarget = rootProject.AddTarget("Build");
             ProjectTaskElement buildTask = buildTarget.AddTask("MSBuild");
@@ -3398,8 +3397,7 @@ private ProjectInstance GenerateDummyProjects(string shutdownProjectDirectory, i
         [Trait("Category", "mono-osx-failing")] // out-of-proc nodes not working on mono yet
         public void ShouldBuildMutatedProjectInstanceWhoseProjectWasPreviouslyBuiltAsAP2PDependency()
         {
-            var mainProjectContents =
-@"<Project>
+            const string mainProjectContents = @"<Project>
 
   <Target Name=""BuildOther"" Outputs=""@(ReturnValue)"">
     <MSBuild Projects=""{0}"" Targets=""Foo"">
@@ -3493,8 +3491,7 @@ public void ShouldBuildMutatedProjectInstanceWhoseProjectWasPreviouslyBuiltAsAP2
         [Trait("Category", "mono-osx-failing")] // out-of-proc nodes not working on mono yet
         public void OutOfProcFileBasedP2PBuildSucceeds()
         {
-            var mainProject =
-                @"<Project>
+            const string mainProject = @"<Project>
 
   <Target Name=`MainTarget` Returns=`foo;@(P2PReturnValue)`>
     <MSBuild Projects=`{0}` Targets=`P2PTarget`>
@@ -3504,8 +3501,7 @@ public void OutOfProcFileBasedP2PBuildSucceeds()
 
 </Project>";
 
-            var p2pProject =
-                @"<Project>
+            const string p2pProject = @"<Project>
 
   <Target Name=`P2PTarget` Returns=`bar`>
     <Message Text=`Bar` Importance=`High` />
@@ -3533,7 +3529,6 @@ public void OutOfProcFileBasedP2PBuildSucceeds()
                 var cleanedUpMainContents = CleanupFileContents(string.Format(mainProject, p2pProjectPath));
                 File.WriteAllText(mainProjectPath, cleanedUpMainContents);
 
-
                 var buildRequestData = new BuildRequestData(
                     mainProjectPath,
                     new Dictionary<string, string>(),
@@ -3565,8 +3560,7 @@ public void OutOfProcFileBasedP2PBuildSucceeds()
         [Trait("Category", "mono-osx-failing")] // out-of-proc nodes not working on mono yet
         public void OutOfProcProjectInstanceBasedBuildDoesNotReloadFromDisk(bool shouldSerializeEntireState)
         {
-            var mainProject =
-                @"<Project>
+            const string mainProject = @"<Project>
   <PropertyGroup>
     <ImportIt>true</ImportIt>
   </PropertyGroup>
@@ -3575,8 +3569,7 @@ public void OutOfProcProjectInstanceBasedBuildDoesNotReloadFromDisk(bool shouldS
 
 </Project>";
 
-            var importProject =
-                @"<Project>
+            const string importProject = @"<Project>
   <Target Name=""Foo"">
     <Message Text=""Bar"" Importance=""High"" />
   </Target>
@@ -3598,13 +3591,12 @@ public void OutOfProcProjectInstanceBasedBuildDoesNotReloadFromDisk(bool shouldS
 
                 var project = new Project(root, new Dictionary<string, string>(), MSBuildConstants.CurrentToolsVersion,
                     _projectCollection);
-                var instance = project.CreateProjectInstance(ProjectInstanceSettings.Immutable).DeepCopy(false);
+                ProjectInstance instance = project.CreateProjectInstance(ProjectInstanceSettings.Immutable).DeepCopy(false);
 
                 instance.TranslateEntireState = shouldSerializeEntireState;
 
                 var request = new BuildRequestData(instance, new[] {"Foo"});
 
-
                 var parameters = new BuildParameters(_projectCollection)
                 {
                     DisableInProcNode = true,
@@ -3614,21 +3606,16 @@ public void OutOfProcProjectInstanceBasedBuildDoesNotReloadFromDisk(bool shouldS
 
                 _buildManager.BeginBuild(parameters);
 
-
                 var submission = _buildManager.PendBuildRequest(request);
-
                 var results = submission.Execute();
-
                 Assert.True(results.OverallResult == BuildResultCode.Success);
 
                 // reset caches to ensure nothing is reused
-
                 _buildManager.EndBuild();
                 _buildManager.ResetCaches();
 
                 // mutate the file on disk such that the import (containing the target to get executed)
                 // is no longer imported
-
                 project.SetProperty("ImportIt", "false");
                 project.Save();
 
@@ -3637,13 +3624,11 @@ public void OutOfProcProjectInstanceBasedBuildDoesNotReloadFromDisk(bool shouldS
                 // the file does not contain the target Foo, but the project instance does
                 // Building the stale project instance should still succeed when the entire state is translated: MSBuild should use the
                 // in-memory state to build and not reload from disk.
-
                 _buildManager.BeginBuild(parameters);
                 request = new BuildRequestData(instance, new[] {"Foo"}, null,
                     BuildRequestDataFlags.ReplaceExistingProjectInstance);
                 submission = _buildManager.PendBuildRequest(request);
 
-
                 results = submission.Execute();
 
                 if (shouldSerializeEntireState)
@@ -3667,8 +3652,7 @@ public void OutOfProcProjectInstanceBasedBuildDoesNotReloadFromDisk(bool shouldS
         [Trait("Category", "mono-osx-failing")] // out-of-proc nodes not working on mono yet
         public void OutOfProcEvaluationIdsUnique()
         {
-            var mainProject =
-                @"<Project>
+            const string mainProject = @"<Project>
 
   <Target Name=`MainTarget`>
     <MSBuild Projects=`{0};{1}` Targets=`DummyTarget` />
@@ -3676,8 +3660,7 @@ public void OutOfProcEvaluationIdsUnique()
 
 </Project>";
 
-            var childProject =
-                @"<Project>
+            const string childProject = @"<Project>
 
   <Target Name=`DummyTarget`>
     <Message Text=`Bar` Importance=`High` />
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/CallTarget.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/CallTarget.cs
index 16d9f0886f6..14a24a0b55d 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/CallTarget.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/CallTarget.cs
@@ -22,14 +22,7 @@ internal class CallTarget : ITask
         /// <summary>
         /// The task logging helper
         /// </summary>
-        private TaskLoggingHelper _logHelper = null;
-
-        /// <summary>
-        /// Default constructor.
-        /// </summary>
-        public CallTarget()
-        {
-        }
+        private TaskLoggingHelper _logHelper;
 
         #region Properties
 
diff --git a/src/Shared/PropertyParser.cs b/src/Shared/PropertyParser.cs
index f784496d7fd..b795dc8e4a3 100644
--- a/src/Shared/PropertyParser.cs
+++ b/src/Shared/PropertyParser.cs
@@ -5,7 +5,6 @@
 using System.Text;
 using System.Collections;
 using System.Collections.Generic;
-using System.Globalization;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -17,14 +16,14 @@ namespace Microsoft.Build.BackEnd
 namespace Microsoft.Build.Tasks
 #endif
 {
-    static internal class PropertyParser
+    internal static class PropertyParser
     {
         /// <summary>
         /// Given a string of semi-colon delimited name=value pairs, this method parses it and creates 
         /// a hash table containing the property names as keys and the property values as values.  
         /// </summary>
         /// <returns>true on success, false on failure.</returns>
-        static internal bool GetTable(TaskLoggingHelper log, string parameterName, string[] propertyList, out Hashtable propertiesTable)
+        internal static bool GetTable(TaskLoggingHelper log, string parameterName, string[] propertyList, out Hashtable propertiesTable)
         {
             propertiesTable = null;
 
@@ -57,10 +56,7 @@ static internal bool GetTable(TaskLoggingHelper log, string parameterName, strin
                     if (propertyName.Length == 0)
                     {
                         // No equals sign?  No property name?  That's no good to us.
-                        if (log != null)
-                        {
-                            log.LogErrorWithCodeFromResources("General.InvalidPropertyError", parameterName, propertyNameValuePair);
-                        }
+                        log?.LogErrorWithCodeFromResources("General.InvalidPropertyError", parameterName, propertyNameValuePair);
 
                         return false;
                     }
@@ -83,14 +79,14 @@ static internal bool GetTable(TaskLoggingHelper log, string parameterName, strin
         /// already.
         /// </summary>
         /// <returns>true on success, false on failure.</returns>
-        static internal bool GetTableWithEscaping(TaskLoggingHelper log, string parameterName, string syntaxName, string[] propertyNameValueStrings, out Hashtable finalPropertiesTable)
+        internal static bool GetTableWithEscaping(TaskLoggingHelper log, string parameterName, string syntaxName, string[] propertyNameValueStrings, out Hashtable finalPropertiesTable)
         {
             finalPropertiesTable = null;
 
             if (propertyNameValueStrings != null)
             {
                 finalPropertiesTable = new Hashtable(StringComparer.OrdinalIgnoreCase);
-                List<PropertyNameValuePair> finalPropertiesList = new List<PropertyNameValuePair>();
+                var finalPropertiesList = new List<PropertyNameValuePair>();
 
                 // Loop through the array.  Each string in the array should be of the form:
                 //          MyPropName=MyPropValue
@@ -113,10 +109,7 @@ static internal bool GetTableWithEscaping(TaskLoggingHelper log, string paramete
                         if (propertyName.Length == 0)
                         {
                             // No property name?  That's no good to us.
-                            if (log != null)
-                            {
-                                log.LogErrorWithCodeFromResources("General.InvalidPropertyError", syntaxName, propertyNameValueString);
-                            }
+                            log?.LogErrorWithCodeFromResources("General.InvalidPropertyError", syntaxName, propertyNameValueString);
 
                             return false;
                         }
@@ -160,10 +153,7 @@ static internal bool GetTableWithEscaping(TaskLoggingHelper log, string paramete
                         else
                         {
                             // No equals sign in the very first property?  That's a problem.
-                            if (log != null)
-                            {
-                                log.LogErrorWithCodeFromResources("General.InvalidPropertyError", syntaxName, propertyNameValueString);
-                            }
+                            log?.LogErrorWithCodeFromResources("General.InvalidPropertyError", syntaxName, propertyNameValueString);
 
                             return false;
                         }
@@ -172,21 +162,15 @@ static internal bool GetTableWithEscaping(TaskLoggingHelper log, string paramete
 
                 // Convert the data in the List to a Hashtable, because that's what the MSBuild task eventually
                 // needs to pass onto the engine.
-                if (log != null)
-                {
-                    log.LogMessageFromText(parameterName, MessageImportance.Low);
-                }
+                log?.LogMessageFromText(parameterName, MessageImportance.Low);
 
                 foreach (PropertyNameValuePair propertyNameValuePair in finalPropertiesList)
                 {
                     string propertyValue = OpportunisticIntern.StringBuilderToString(propertyNameValuePair.Value);
                     finalPropertiesTable[propertyNameValuePair.Name] = propertyValue;
-                    if (log != null)
-                    {
-                        log.LogMessageFromText(String.Format(CultureInfo.InvariantCulture, "  {0}={1}",
-                            propertyNameValuePair.Name, propertyValue),
-                            MessageImportance.Low);
-                    }
+                    log?.LogMessageFromText(
+                        $"  {propertyNameValuePair.Name}={propertyValue}",
+                        MessageImportance.Low);
                 }
             }
 
@@ -198,59 +182,20 @@ static internal bool GetTableWithEscaping(TaskLoggingHelper log, string paramete
         /// </summary>
         private class PropertyNameValuePair
         {
-            private string _name;
-            private StringBuilder _value;
-
             /// <summary>
             /// Property name
             /// </summary>
-            internal string Name
-            {
-                get
-                {
-                    return _name;
-                }
-
-                set
-                {
-                    _name = value;
-                }
-            }
+            internal string Name { get; }
 
             /// <summary>
             /// Property value
             /// </summary>
-            internal StringBuilder Value
-            {
-                get
-                {
-                    return _value;
-                }
+            internal StringBuilder Value { get; }
 
-                set
-                {
-                    _value = value;
-                }
-            }
-
-            /// <summary>
-            /// Constructor
-            /// </summary>
-            /// <param name="propertyName"></param>
-            /// <param name="propertyValue"></param>
             internal PropertyNameValuePair(string propertyName, string propertyValue)
             {
-                this.Name = propertyName;
-
-                this.Value = new StringBuilder();
-                this.Value.Append(propertyValue);
-            }
-
-            /// <summary>
-            /// Default construction not allowed.
-            /// </summary>
-            private PropertyNameValuePair()
-            {
+                Name = propertyName;
+                Value = new StringBuilder(propertyValue);
             }
         }
     }
diff --git a/src/Shared/UnitTests/TestEnvironment.cs b/src/Shared/UnitTests/TestEnvironment.cs
index 63946d5b6e9..17bde2a2d92 100644
--- a/src/Shared/UnitTests/TestEnvironment.cs
+++ b/src/Shared/UnitTests/TestEnvironment.cs
@@ -1,4 +1,7 @@
-﻿using System;
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
@@ -352,7 +355,7 @@ public override void AssertInvariant(ITestOutputHelper output)
 
     public class EnvironmentInvariant : TestInvariant
     {
-        private IDictionary _initialEnvironment;
+        private readonly IDictionary _initialEnvironment;
 
         public EnvironmentInvariant()
         {
@@ -394,7 +397,7 @@ public override void AssertInvariant(ITestOutputHelper output)
             int newFilesCount = newFiles.Length;
             if (newFilesCount > _originalFiles.Length)
             {
-                foreach (var file in newFiles.Except(_originalFiles).Select(f => new FileInfo(f)))
+                foreach (FileInfo file in newFiles.Except(_originalFiles).Select(f => new FileInfo(f)))
                 {
                     string contents = File.ReadAllText(file.FullName);
 
diff --git a/src/Tasks.UnitTests/GetSDKReference_Tests.cs b/src/Tasks.UnitTests/GetSDKReference_Tests.cs
index b6b7cf8cd99..e312bc6df08 100644
--- a/src/Tasks.UnitTests/GetSDKReference_Tests.cs
+++ b/src/Tasks.UnitTests/GetSDKReference_Tests.cs
@@ -7,14 +7,10 @@
 //-----------------------------------------------------------------------
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
 using System.Linq;
 using System.Threading;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
@@ -125,7 +121,6 @@ private static string CreateFakeSDKReferenceAssemblyDirectory1(out string sdkDir
             string redistCommonConfigurationNeutral = Path.Combine(redistDirectoryCommonConfigNeutral, "D.dll");
             string redistCommonConfigurationNeutralDupe = Path.Combine(redistDirectoryCommonConfigNeutral, "A.dll");
 
-
             File.WriteAllText(testWinMDNeutralWinXML, "TestXml");
             File.WriteAllText(testWinMD, "TestWinmd");
             File.WriteAllText(testWinMD64, "TestWinmd");
@@ -227,8 +222,8 @@ public void Dispose()
         [Fact]
         public void PassReferenceWithNoReferenceDirectory()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             ITaskItem item = new TaskItem("C:\\SDKDoesNotExist");
             item.SetMetadata("ExpandReferenceAssemblies", "true");
@@ -246,7 +241,6 @@ public void PassReferenceWithNoReferenceDirectory()
             Assert.Equal(0, t.RedistFiles.Length);
         }
 
-
         private delegate IList<string> GetSDKFolders(string sdkRoot);
         private delegate IList<string> GetSDKFolders2(string sdkRoot, string configuration, string architecture);
 
@@ -257,8 +251,8 @@ public void PassReferenceWithNoReferenceDirectory()
         [Trait("Category", "mono-osx-failing")]
         public void GetSDKReferenceFolders()
         {
-            GetSDKFolders getReferenceFolders = new GetSDKFolders(ToolLocationHelper.GetSDKReferenceFolders);
-            GetSDKFolders2 getReferenceFolders2 = new GetSDKFolders2(ToolLocationHelper.GetSDKReferenceFolders);
+            var getReferenceFolders = new GetSDKFolders(ToolLocationHelper.GetSDKReferenceFolders);
+            var getReferenceFolders2 = new GetSDKFolders2(ToolLocationHelper.GetSDKReferenceFolders);
 
             VerifySDKFolders(getReferenceFolders, getReferenceFolders2, "References", _sdkDirectory);
         }
@@ -293,8 +287,8 @@ private static void VerifySDKFolders(GetSDKFolders singleParamDelegate, GetSDKFo
         [Trait("Category", "mono-osx-failing")]
         public void GetSDKRedistFolders()
         {
-            GetSDKFolders getRedistFolders = new GetSDKFolders(ToolLocationHelper.GetSDKRedistFolders);
-            GetSDKFolders2 getRedistFolders2 = new GetSDKFolders2(ToolLocationHelper.GetSDKRedistFolders);
+            var getRedistFolders = new GetSDKFolders(ToolLocationHelper.GetSDKRedistFolders);
+            var getRedistFolders2 = new GetSDKFolders2(ToolLocationHelper.GetSDKRedistFolders);
 
             VerifySDKFolders(getRedistFolders, getRedistFolders2, "Redist", _sdkDirectory);
         }
@@ -306,8 +300,8 @@ public void GetSDKRedistFolders()
         [Trait("Category", "mono-osx-failing")]
         public void GetSDKDesignTimeFolders()
         {
-            GetSDKFolders getDesignTimeFolders = new GetSDKFolders(ToolLocationHelper.GetSDKDesignTimeFolders);
-            GetSDKFolders2 getDesignTimeFolders2 = new GetSDKFolders2(ToolLocationHelper.GetSDKDesignTimeFolders);
+            var getDesignTimeFolders = new GetSDKFolders(ToolLocationHelper.GetSDKDesignTimeFolders);
+            var getDesignTimeFolders2 = new GetSDKFolders2(ToolLocationHelper.GetSDKDesignTimeFolders);
 
             VerifySDKFolders(getDesignTimeFolders, getDesignTimeFolders2, "DesignTime", _sdkDirectory);
         }
@@ -318,8 +312,8 @@ public void GetSDKDesignTimeFolders()
         [Fact]
         public void PassNoSDKReferences()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
             bool success = t.Execute(_getAssemblyName, _getAssemblyRuntimeVersion, FileUtilities.FileExistsNoThrow);
@@ -336,8 +330,8 @@ public void PassNoSDKReferences()
         [Fact]
         public void PassReferenceWithExpandFalse()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -361,8 +355,8 @@ public void PassReferenceWithExpandFalse()
         [Fact]
         public void PassReferenceWithCopyRedistFalse()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -388,8 +382,8 @@ public void PassReferenceWithCopyRedistFalse()
         [Trait("Category", "mono-osx-failing")]
         public void GetReferenceAssembliesWhenExpandTrueCopyLocalTrue()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
             ITaskItem item = new TaskItem(_sdkDirectory);
@@ -454,8 +448,8 @@ public void GetReferenceAssembliesWhenExpandTrueCopyLocalTrue()
         [Trait("Category", "mono-osx-failing")]
         public void VerifyNoCopyWhenReferenceOnlyIsTrue()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -512,8 +506,8 @@ public void VerifyNoCopyWhenReferenceOnlyIsTrue()
         [Trait("Category", "mono-windows-failing")]
         public void GetReferenceAssembliesWhenExpandTrueCopyLocalFalse()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -565,8 +559,8 @@ public void GetReferenceAssembliesWhenExpandTrueCopyLocalFalse()
         [Fact]
         public void VerifyCacheFileNames()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -632,8 +626,8 @@ public void VerifyCacheFileNames()
         [Trait("Category", "mono-osx-failing")]
         public void VerifyReferencesLogged()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -681,8 +675,8 @@ public void VerifyReferencesLogged()
         [Trait("Category", "mono-osx-failing")]
         public void VerifyReferencesLoggedFilterOutWinmd()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -727,8 +721,8 @@ public void VerifyReferencesLoggedFilterOutWinmd()
         [Trait("Category", "mono-osx-failing")]
         public void LogErrorWhenNoConfiguration()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -751,8 +745,8 @@ public void LogErrorWhenNoConfiguration()
         [Trait("Category", "mono-osx-failing")]
         public void LogErrorWhenNoArchitecture()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -777,8 +771,8 @@ public void LogErrorWhenNoArchitecture()
         [PlatformSpecific(TestPlatforms.Windows)]
         public void VerifyReferencesLoggedAmd64()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -829,8 +823,8 @@ public void VerifyReferencesLoggedAmd64()
         [Trait("Category", "mono-osx-failing")]
         public void VerifyReferencesLoggedX64()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -881,8 +875,8 @@ public void VerifyReferencesLoggedX64()
         [Trait("Category", "mono-osx-failing")]
         public void VerifyLogReferencesFalse()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -917,8 +911,8 @@ public void VerifyLogReferencesFalse()
         [Trait("Category", "mono-osx-failing")]
         public void VerifyRedistFilesLogRedistFalse()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -983,8 +977,8 @@ public void VerifyRedistFilesLogRedistFalse()
         [Trait("Category", "mono-osx-failing")]
         public void VerifyRedistFilesLogRedistTrue()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -1015,8 +1009,8 @@ public void VerifyRedistFilesLogRedistTrue()
         [Trait("Category", "mono-osx-failing")]
         public void VerifyRedistFilesLogRedistTrueX64()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -1048,8 +1042,8 @@ public void VerifyRedistFilesLogRedistTrueX64()
         [Trait("Category", "mono-osx-failing")]
         public void VerifyRedistFilesLogRedistTrueAmd64()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -1080,8 +1074,8 @@ public void VerifyRedistFilesLogRedistTrueAmd64()
         [Trait("Category", "mono-osx-failing")]
         public void LogNoWarningForReferenceConflictWithinSDK()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -1109,8 +1103,8 @@ public void LogNoWarningForReferenceConflictWithinSDK()
         [Trait("Category", "mono-osx-failing")]
         public void LogWarningForReferenceConflictWithinSDK()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -1139,8 +1133,8 @@ public void LogWarningForReferenceConflictWithinSDK()
         [Trait("Category", "mono-osx-failing")]
         public void LogNoWarningForRedistConflictWithinSDK()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -1167,8 +1161,8 @@ public void LogNoWarningForRedistConflictWithinSDK()
         [Trait("Category", "mono-osx-failing")]
         public void LogWarningForRedistConflictWithinSDK()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -1196,8 +1190,8 @@ public void LogWarningForRedistConflictWithinSDK()
         [Trait("Category", "mono-osx-failing")]
         public void LogReferenceAndRedistConflictBetweenSdks()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -1242,8 +1236,8 @@ public void LogReferenceAndRedistConflictBetweenSdks()
         [Trait("Category", "mono-osx-failing")]
         public void LogReferenceAndRedistConflictBetweenSdksDueToCustomTargetPath()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -1285,8 +1279,8 @@ public void LogReferenceAndRedistConflictBetweenSdksDueToCustomTargetPath()
         [Trait("Category", "mono-osx-failing")]
         public void LogReferenceAndRedistConflictBetweenSdksNowarning()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
@@ -1316,7 +1310,6 @@ public void LogReferenceAndRedistConflictBetweenSdksNowarning()
             Assert.Equal(6, t.RedistFiles.Length);
             Assert.Equal(0, engine.Warnings);
 
-
             string redistWinner = Path.Combine(_sdkDirectory, "Redist\\Retail\\Neutral\\B.pri");
             string redistVictim = Path.Combine(_sdkDirectory2, "Redist\\Retail\\X86\\B.pri");
             string referenceWinner = Path.Combine(_sdkDirectory, "References\\Retail\\Neutral\\B.WinMD");
@@ -1333,8 +1326,8 @@ public void LogReferenceAndRedistConflictBetweenSdksNowarning()
         [Trait("Category", "mono-osx-failing")]
         public void TwoSDKSConflictRedistButDifferentTargetPaths()
         {
-            MockEngine engine = new MockEngine(_output);
-            GetSDKReferenceFiles t = new GetSDKReferenceFiles();
+            var engine = new MockEngine(_output);
+            var t = new GetSDKReferenceFiles();
             t.BuildEngine = engine;
             t.CacheFileFolderPath = _cacheDirectory;
 
diff --git a/src/Tasks/AssemblyDependency/Resolver.cs b/src/Tasks/AssemblyDependency/Resolver.cs
index ef5b4c0ef2f..2604b03189b 100644
--- a/src/Tasks/AssemblyDependency/Resolver.cs
+++ b/src/Tasks/AssemblyDependency/Resolver.cs
@@ -12,7 +12,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Base class for all resolver types.
     /// </summary>
-    abstract internal class Resolver
+    internal abstract class Resolver
     {
         /// <summary>
         /// The corresponding element from the search path.
@@ -37,7 +37,7 @@ abstract internal class Resolver
         /// <summary>
         /// Runtime we are targeting
         /// </summary>
-        protected Version targetedRuntimeVersion = null;
+        protected Version targetedRuntimeVersion;
 
         /// <summary>
         /// Processor architecture we are targeting.
@@ -78,7 +78,7 @@ protected Resolver(string searchPathElement, GetAssemblyName getAssemblyName, Fi
         /// <param name="foundPath">The path where the file was found.</param>
         /// <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
         /// <returns>True if the file was resolved.</returns>
-        abstract public bool Resolve
+        public abstract bool Resolve
         (
             AssemblyNameExtension assemblyName,
             string sdkName,
@@ -97,22 +97,11 @@ out bool userRequestedSpecificFile
         /// <summary>
         /// The search path element that this resolver is based on.
         /// </summary>
-        public string SearchPath
-        {
-            get { return searchPathElement; }
-        }
+        public string SearchPath => searchPathElement;
 
         /// <summary>
         /// Resolve a single file.
         /// </summary>
-        /// <param name="fullPath"></param>
-        /// <param name="assemblyName"></param>
-        /// <param name="isPrimaryProjectReference"></param>
-        /// <param name="wantSpecificVersion"></param>
-        /// <param name="searchPath"></param>
-        /// <param name="assembliesConsideredAndRejected"></param>
-        /// <param name="fileExists"></param>
-        /// <param name="getAssemblyName"></param>
         /// <returns>True if the file was a match, false otherwise.</returns>
         protected bool ResolveAsFile
         (
@@ -127,9 +116,11 @@ ArrayList assembliesConsideredAndRejected
             ResolutionSearchLocation considered = null;
             if (assembliesConsideredAndRejected != null)
             {
-                considered = new ResolutionSearchLocation();
-                considered.FileNameAttempted = fullPath;
-                considered.SearchPath = searchPathElement;
+                considered = new ResolutionSearchLocation
+                {
+                    FileNameAttempted = fullPath,
+                    SearchPath = searchPathElement
+                };
             }
 
             if (FileMatchesAssemblyName(assemblyName, isPrimaryProjectReference, wantSpecificVersion, allowMismatchBetweenFusionNameAndFileName, fullPath, considered))
@@ -138,10 +129,7 @@ ArrayList assembliesConsideredAndRejected
             }
 
             // Record this as a location that was considered.
-            if (assembliesConsideredAndRejected != null)
-            {
-                assembliesConsideredAndRejected.Add(considered);
-            }
+            assembliesConsideredAndRejected?.Add(considered);
 
             return false;
         }
@@ -154,9 +142,6 @@ ArrayList assembliesConsideredAndRejected
         /// <param name="wantSpecificVersion">Whether the version needs to match exactly or loosely.</param>
         /// <param name="pathToCandidateAssembly">Path to a possible file.</param>
         /// <param name="searchLocation">Information about why the candidate file didn't match</param>
-        /// <param name="fileExists">Delegate for File.Exists.</param>
-        /// <param name="getAssemblyName">Delegate for AssemblyName.GetAssemblyName</param>
-        /// <returns></returns>
         protected bool FileMatchesAssemblyName
         (
             AssemblyNameExtension assemblyName,
@@ -194,7 +179,7 @@ ResolutionSearchLocation searchLocation
                 }
             }
 
-            bool isSimpleAssemblyName = assemblyName == null ? false : assemblyName.IsSimpleName;
+            bool isSimpleAssemblyName = assemblyName != null && assemblyName.IsSimpleName;
 
             if (fileExists(pathToCandidateAssembly))
             {
@@ -221,7 +206,7 @@ ResolutionSearchLocation searchLocation
                 {
                     targetAssemblyName = getAssemblyName(pathToCandidateAssembly);
                 }
-                catch (System.IO.FileLoadException)
+                catch (FileLoadException)
                 {
                     // Its pretty hard to get here, you need an assembly that contains a valid reference
                     // to a dependent assembly that, in turn, throws a FileLoadException during GetAssemblyName.
@@ -303,8 +288,6 @@ ResolutionSearchLocation searchLocation
         /// <param name="executableExtensions">The possible filename extensions of the assembly. Must be one of these or its no match.</param>
         /// <param name="directory">the directory to look in</param>
         /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
-        /// <param name="fileExists">Delegate for File.Exists.</param>
-        /// <param name="getAssemblyName">Delegate for AssemblyName.GetAssemblyName</param>
         /// <returns>'null' if the assembly wasn't found.</returns>
         protected string ResolveFromDirectory
         (
@@ -328,10 +311,10 @@ ArrayList assembliesConsideredAndRejected
             if (directory != null)
             {
                 string weakNameBase = assemblyName.Name;
-                for (int i = 0; i < executableExtensions.Length; ++i)
+                foreach (string executableExtension in executableExtensions)
                 {
-                    string baseName = weakNameBase + executableExtensions[i];
-                    string fullPath = null;
+                    string baseName = weakNameBase + executableExtension;
+                    string fullPath;
 
                     try
                     {
@@ -351,7 +334,6 @@ ArrayList assembliesConsideredAndRejected
                             candidateFullPath = fullPath;
                         }
 
-
                         /*
                          * After finding a file we now will check to see if it matches the type of processor architecture we want to return. The rules are as follows
                          * 
@@ -359,7 +341,6 @@ ArrayList assembliesConsideredAndRejected
                          * 
                          * If targeting MSIL we will first look through all of the assemblies, if an MSIL assembly is found we will return that. If no MSIL assembly is found we will return 
                          * the first assembly which matches reguardless of its processor architecture.
-                         
                          */
 
                         if (targetProcessorArchitecture == ProcessorArchitecture.MSIL)
@@ -387,14 +368,14 @@ ArrayList assembliesConsideredAndRejected
                     string weakNameBaseExtension = Path.GetExtension(weakNameBase);
                     string weakNameBaseFileName = Path.GetFileNameWithoutExtension(weakNameBase);
 
-                    if (weakNameBaseExtension != null && weakNameBaseExtension.Length > 0 && weakNameBaseFileName != null && weakNameBaseFileName.Length > 0)
+                    if (!string.IsNullOrEmpty(weakNameBaseExtension) && !string.IsNullOrEmpty(weakNameBaseFileName))
                     {
-                        for (int i = 0; i < executableExtensions.Length; ++i)
+                        foreach (string executableExtension in executableExtensions)
                         {
-                            if (String.Compare(executableExtensions[i], weakNameBaseExtension, StringComparison.CurrentCultureIgnoreCase) == 0)
+                            if (String.Compare(executableExtension, weakNameBaseExtension, StringComparison.CurrentCultureIgnoreCase) == 0)
                             {
                                 string fullPath = Path.Combine(directory, weakNameBase);
-                                AssemblyNameExtension extensionlessAssemblyName = new AssemblyNameExtension(weakNameBaseFileName);
+                                var extensionlessAssemblyName = new AssemblyNameExtension(weakNameBaseFileName);
 
                                 if (ResolveAsFile(fullPath, extensionlessAssemblyName, isPrimaryProjectReference, wantSpecificVersion, false, assembliesConsideredAndRejected))
                                 {
diff --git a/src/Tasks/CallTarget.cs b/src/Tasks/CallTarget.cs
index 7d58eac480c..f08f0d933fa 100644
--- a/src/Tasks/CallTarget.cs
+++ b/src/Tasks/CallTarget.cs
@@ -1,16 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.IO;
-using System.Xml;
-using System.Resources;
-using System.Reflection;
-using System.Collections;
-using System.Diagnostics;
+using System.Collections.Generic;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
 {
@@ -23,95 +15,41 @@ namespace Microsoft.Build.Tasks
     [RunInMTA]
     public class CallTarget : TaskExtension
     {
-        /// <summary>
-        /// Default constructor.
-        /// </summary>
-        public CallTarget()
-        {
-        }
-
         #region Properties
 
-        // A list of targets to build.  This is a required parameter.  If you want to build the 
-        // default targets, use the <MSBuild> task and pass in Projects=$(MSBuildProjectFile).
-        private string[] _targets = null;
-
         // outputs of all built targets
-        private ArrayList _targetOutputs = new ArrayList();
-
-        // When this is true, instead of calling the engine once to build all the targets,
-        // we would call the engine once per target.  The benefit of this is that
-        // if one target fails, you can still continue with the remaining targets.
-        private bool _runEachTargetSeparately = false;
-
-        // If true the cache will be checked for the result and the result will be stored if the operation 
-        // is run
-        private bool _useResultsCache = false;
+        private readonly List<ITaskItem> _targetOutputs = new List<ITaskItem>();
 
         /// <summary>
         /// The targets to build.
         /// </summary>
         /// <value>Array of target names.</value>
-        public string[] Targets
-        {
-            get
-            {
-                return _targets;
-            }
-
-            set
-            {
-                _targets = value;
-            }
-        }
+        /// <remarks>
+        /// This is a required parameter. If you want to build the 
+        /// default targets, use the &lt;MSBuild&gt; task and pass in Projects=$(MSBuildProjectFile).
+        /// </remarks>
+        public string[] Targets { get; set; }
 
         /// <summary>
         /// Outputs of the targets built in each project.
         /// </summary>
         /// <value>Array of output items.</value>
         [Output]
-        public ITaskItem[] TargetOutputs
-        {
-            get
-            {
-                return (ITaskItem[])_targetOutputs.ToArray(typeof(ITaskItem));
-            }
-        }
+        public ITaskItem[] TargetOutputs => _targetOutputs.ToArray();
 
         /// <summary>
         /// When this is true, instead of calling the engine once to build all the targets (for each project),
         /// we would call the engine once per target (for each project).  The benefit of this is that
         /// if one target fails, you can still continue with the remaining targets.
         /// </summary>
-        public bool RunEachTargetSeparately
-        {
-            get
-            {
-                return _runEachTargetSeparately;
-            }
-
-            set
-            {
-                _runEachTargetSeparately = value;
-            }
-        }
+        public bool RunEachTargetSeparately { get; set; }
 
         /// <summary>
         /// If true the cached result will be returned if present and a if MSBuild
         /// task is run its result will be cached in a scope (ProjectFileName, GlobalProperties)[TargetNames]
         /// as a list of build items
         /// </summary>
-        public bool UseResultsCache
-        {
-            get
-            {
-                return _useResultsCache;
-            }
-            set
-            {
-                _useResultsCache = value;
-            }
-        }
+        public bool UseResultsCache { get; set; } = false;
 
         #endregion
 
@@ -133,12 +71,12 @@ public override bool Execute()
             // string[] represents a set of target names to build.  Depending on the value 
             // of the RunEachTargetSeparately parameter, we each just call the engine to run all 
             // the targets together, or we call the engine separately for each target.
-            ArrayList targetLists = Microsoft.Build.Tasks.MSBuild.CreateTargetLists(this.Targets, this.RunEachTargetSeparately);
+            List<string[]> targetLists = MSBuild.CreateTargetLists(Targets, RunEachTargetSeparately);
 
-            ITaskItem[] singleProject = new ITaskItem[1];
+            var singleProject = new ITaskItem[1];
             singleProject[0] = null;
             // Build the specified targets in the current project.
-            return Microsoft.Build.Tasks.MSBuild.ExecuteTargets
+            return MSBuild.ExecuteTargets
                 (
                 singleProject,  // project = null (current project)
                 null,           // propertiesTable = null
@@ -146,10 +84,10 @@ public override bool Execute()
                 targetLists,    // list of targets to build
                 false,          // stopOnFirstFailure = false
                 false,          // rebaseOutputs = false
-                this.BuildEngine3,
-                this.Log,
+                BuildEngine3,
+                Log,
                 _targetOutputs,
-                this.UseResultsCache,
+                UseResultsCache,
                 false,
                 null            // toolsVersion = null
                 );
diff --git a/src/Tasks/ComReference.cs b/src/Tasks/ComReference.cs
index 7c5094b97de..cdd53ef96d5 100644
--- a/src/Tasks/ComReference.cs
+++ b/src/Tasks/ComReference.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Globalization;
 using System.Runtime.InteropServices.ComTypes;
 using System.Text;
 
@@ -14,14 +13,11 @@
 
 namespace Microsoft.Build.Tasks
 {
-    /*
-     * Class:   ComReference
-     * 
-     * Abstract base class for COM reference wrappers providing common functionality. 
-     * This class hierarchy is used by the ResolveComReference task. Every class deriving from ComReference 
-     * provides functionality for wrapping Com type libraries in a given way (for example AxReference, or PiaReference).
-     *
-     */
+    /// <summary>
+    /// Abstract base class for COM reference wrappers providing common functionality. 
+    /// This class hierarchy is used by the ResolveComReference task.Every class deriving from ComReference
+    /// provides functionality for wrapping Com type libraries in a given way(for example AxReference, or PiaReference).
+    /// </summary>
     internal abstract class ComReference
     {
         #region Constructors
@@ -35,10 +31,10 @@ internal abstract class ComReference
         /// <param name="itemName">reference name (for better logging experience)</param>
         internal ComReference(TaskLoggingHelper taskLoggingHelper, bool silent, ComReferenceInfo referenceInfo, string itemName)
         {
-            _referenceInfo = referenceInfo;
-            _itemName = itemName;
-            _log = taskLoggingHelper;
-            _silent = silent;
+            ReferenceInfo = referenceInfo;
+            ItemName = itemName;
+            Log = taskLoggingHelper;
+            Silent = silent;
         }
 
         #endregion
@@ -48,55 +44,23 @@ internal ComReference(TaskLoggingHelper taskLoggingHelper, bool silent, ComRefer
         /// <summary>
         /// various data for this reference (type lib attrs, name, path, ITypeLib pointer etc)
         /// </summary>
-        internal virtual ComReferenceInfo ReferenceInfo
-        {
-            get
-            {
-                return _referenceInfo;
-            }
-        }
-
-        private ComReferenceInfo _referenceInfo;
+        internal virtual ComReferenceInfo ReferenceInfo { get; }
 
         /// <summary>
         /// item name as it appears in the project file
         /// (used for logging purposes, we use the actual typelib name for interesting operations)
         /// </summary>
-        internal virtual string ItemName
-        {
-            get
-            {
-                return _itemName;
-            }
-        }
-
-        private string _itemName;
+        internal virtual string ItemName { get; }
 
         /// <summary>
         /// task used for logging messages
         /// </summary>
-        protected internal TaskLoggingHelper Log
-        {
-            get
-            {
-                return _log;
-            }
-        }
-
-        private TaskLoggingHelper _log;
+        protected internal TaskLoggingHelper Log { get; }
 
         /// <summary>
         /// True if this class should only log errors, but no messages or warnings.  
         /// </summary>
-        protected internal bool Silent
-        {
-            get
-            {
-                return _silent;
-            }
-        }
-
-        private bool _silent;
+        protected internal bool Silent { get; }
 
         /// <summary>
         /// lazy-init property, returns true if ADO 2.7 is installed on the machine
@@ -107,7 +71,9 @@ internal static bool Ado27Installed
             {
                 // if we already know the answer, return it
                 if (ado27PropertyInitialized)
+                {
                     return ado27Installed;
+                }
 
                 // not initialized? Find out if ADO 2.7 is installed
                 ado27Installed = true;
@@ -129,27 +95,23 @@ internal static bool Ado27Installed
                 finally
                 {
                     if (ado27 != null)
+                    {
                         Marshal.ReleaseComObject(ado27);
+                    }
                 }
 
                 return ado27Installed;
             }
         }
 
-        internal static bool ado27PropertyInitialized = false;
+        internal static bool ado27PropertyInitialized;
         internal static bool ado27Installed;
 
         /// <summary>
         /// Error message if Ado27 is not installed on the machine (usually something like "type lib not registered")
         /// Only contains valid data if ADO 2.7 is not installed and Ado27Installed was called before
         /// </summary>
-        internal static string Ado27ErrorMessage
-        {
-            get
-            {
-                return ado27ErrorMessage;
-            }
-        }
+        internal static string Ado27ErrorMessage => ado27ErrorMessage;
 
         internal static string ado27ErrorMessage;
 
@@ -157,21 +119,17 @@ internal static string Ado27ErrorMessage
 
         #region Methods
 
-        /*
-         * Method:  UniqueKeyFromTypeLibAttr
-         * 
-         * Given a TYPELIBATTR structure, generates a key that can be used in hashtables to identify it.
-         */
+        /// <summary>
+        /// Given a TYPELIBATTR structure, generates a key that can be used in hashtables to identify it.
+        /// </summary>
         internal static string UniqueKeyFromTypeLibAttr(TYPELIBATTR attr)
         {
-            return String.Format(CultureInfo.InvariantCulture, @"{0}|{1}.{2}|{3}", attr.guid, attr.wMajorVerNum, attr.wMinorVerNum, attr.lcid);
+            return $@"{attr.guid}|{attr.wMajorVerNum}.{attr.wMinorVerNum}|{attr.lcid}";
         }
 
-        /*
-         * Method:  AreTypeLibAttrEqual
-         * 
-         * Compares two TYPELIBATTR structures
-         */
+        /// <summary>
+        /// Compares two TYPELIBATTR structures
+        /// </summary>
         internal static bool AreTypeLibAttrEqual(TYPELIBATTR attr1, TYPELIBATTR attr2)
         {
             return attr1.wMajorVerNum == attr2.wMajorVerNum &&
@@ -183,13 +141,9 @@ internal static bool AreTypeLibAttrEqual(TYPELIBATTR attr1, TYPELIBATTR attr2)
         /// <summary>
         /// Helper method for retrieving type lib attributes for the given type lib
         /// </summary>
-        /// <param name="typeLib"></param>
-        /// <param name="typeLibAttr"></param>
-        /// <returns></returns>
         internal static void GetTypeLibAttrForTypeLib(ref ITypeLib typeLib, out TYPELIBATTR typeLibAttr)
         {
-            IntPtr pAttrs = IntPtr.Zero;
-            typeLib.GetLibAttr(out pAttrs);
+            typeLib.GetLibAttr(out IntPtr pAttrs);
 
             // GetLibAttr should never return null, this is just to be safe
             if (pAttrs == IntPtr.Zero)
@@ -216,8 +170,7 @@ internal static void GetTypeLibAttrForTypeLib(ref ITypeLib typeLib, out TYPELIBA
         /// <returns></returns>
         internal static void GetTypeAttrForTypeInfo(ITypeInfo typeInfo, out TYPEATTR typeAttr)
         {
-            IntPtr pAttrs = IntPtr.Zero;
-            typeInfo.GetTypeAttr(out pAttrs);
+            typeInfo.GetTypeAttr(out IntPtr pAttrs);
 
             // GetTypeAttr should never return null, this is just to be safe
             if (pAttrs == IntPtr.Zero)
@@ -242,16 +195,9 @@ internal static void GetTypeAttrForTypeInfo(ITypeInfo typeInfo, out TYPEATTR typ
         /// It's not really possible to copy everything to a managed struct and then release the ptr immediately
         /// here, since VARDESCs contain other native pointers we may need to access.
         /// </summary>
-        /// <param name="typeInfo"></param>
-        /// <param name="varIndex"></param>
-        /// <param name="typeAttr"></param>
-        /// <param name="varDesc"></param>
-        /// <param name="varDescHandle"></param>
-        /// <returns></returns>
         internal static void GetVarDescForVarIndex(ITypeInfo typeInfo, int varIndex, out VARDESC varDesc, out IntPtr varDescHandle)
         {
-            IntPtr pVarDesc = IntPtr.Zero;
-            typeInfo.GetVarDesc(varIndex, out pVarDesc);
+            typeInfo.GetVarDesc(varIndex, out IntPtr pVarDesc);
 
             // GetVarDesc should never return null, this is just to be safe
             if (pVarDesc == IntPtr.Zero)
@@ -270,15 +216,9 @@ internal static void GetVarDescForVarIndex(ITypeInfo typeInfo, int varIndex, out
         /// It's not really possible to copy everything to a managed struct and then release the ptr immediately
         /// here, since FUNCDESCs contain other native pointers we may need to access.
         /// </summary>
-        /// <param name="typeInfo"></param>
-        /// <param name="funcIndex"></param>
-        /// <param name="funcDesc"></param>
-        /// <param name="funcDescHandle"></param>
-        /// <returns></returns>
         internal static void GetFuncDescForDescIndex(ITypeInfo typeInfo, int funcIndex, out FUNCDESC funcDesc, out IntPtr funcDescHandle)
         {
-            IntPtr pFuncDesc = IntPtr.Zero;
-            typeInfo.GetFuncDesc(funcIndex, out pFuncDesc);
+            typeInfo.GetFuncDesc(funcIndex, out IntPtr pFuncDesc);
 
             // GetFuncDesc should never return null, this is just to be safe
             if (pFuncDesc == IntPtr.Zero)
@@ -291,19 +231,15 @@ internal static void GetFuncDescForDescIndex(ITypeInfo typeInfo, int funcIndex,
             funcDescHandle = pFuncDesc;
         }
 
-        /*
-         * Method:  GetTypeLibNameForITypeLib
-         * 
-         * Gets the name of given type library. 
-         */
+        /// <summary>
+        /// Gets the name of given type library. 
+        /// </summary>
         internal static bool GetTypeLibNameForITypeLib(TaskLoggingHelper log, bool silent, ITypeLib typeLib, string typeLibId, out string typeLibName)
         {
             typeLibName = "";
 
             // see if the type library supports ITypeLib2
-            ITypeLib2 typeLib2 = typeLib as ITypeLib2;
-
-            if (typeLib2 == null)
+            if (!(typeLib is ITypeLib2 typeLib2))
             {
                 // Looks like the type lib doesn't support it. Let's use the Marshal method.
                 typeLibName = Marshal.GetTypeLibName(typeLib);
@@ -314,9 +250,7 @@ internal static bool GetTypeLibNameForITypeLib(TaskLoggingHelper log, bool silen
             // type library name.  
             try
             {
-                object data = null;
-
-                typeLib2.GetCustData(ref NativeMethods.GUID_TYPELIB_NAMESPACE, out data);
+                typeLib2.GetCustData(ref NativeMethods.GUID_TYPELIB_NAMESPACE, out object data);
 
                 // if returned namespace is null or its type is not System.String, fall back to the default 
                 // way of getting the type lib name (just to be safe)
@@ -351,11 +285,9 @@ internal static bool GetTypeLibNameForITypeLib(TaskLoggingHelper log, bool silen
             return true;
         }
 
-        /*
-         * Method:  GetTypeLibNameForTypeLibAttrs
-         * 
-         * Gets the name of given type library. 
-         */
+        /// <summary>
+        /// Gets the name of given type library.
+        /// </summary>
         internal static bool GetTypeLibNameForTypeLibAttrs(TaskLoggingHelper log, bool silent, TYPELIBATTR typeLibAttr, out string typeLibName)
         {
             typeLibName = "";
@@ -386,7 +318,9 @@ internal static bool GetTypeLibNameForTypeLibAttrs(TaskLoggingHelper log, bool s
             finally
             {
                 if (typeLib != null)
+                {
                     Marshal.ReleaseComObject(typeLib);
+                }
             }
         }
 
@@ -398,7 +332,7 @@ internal static bool GetTypeLibNameForTypeLibAttrs(TaskLoggingHelper log, bool s
         internal static string StripTypeLibNumberFromPath(string typeLibPath, FileExists fileExists)
         {
             bool lastChance = false;
-            if (typeLibPath != null && typeLibPath.Length > 0)
+            if (!string.IsNullOrEmpty(typeLibPath))
             {
                 if (!fileExists(typeLibPath))
                 {
@@ -452,7 +386,7 @@ internal static string StripTypeLibNumberFromPath(string typeLibPath, FileExists
                 {
                     try
                     {
-                        StringBuilder sb = new StringBuilder(NativeMethodsShared.MAX_PATH);
+                        var sb = new StringBuilder(NativeMethodsShared.MAX_PATH);
                         System.Runtime.InteropServices.HandleRef handleRef = new System.Runtime.InteropServices.HandleRef(sb, libraryHandle);
                         int len = NativeMethodsShared.GetModuleFileName(handleRef, sb, sb.Capacity);
                         if ((len != 0) &&
@@ -479,12 +413,10 @@ internal static string StripTypeLibNumberFromPath(string typeLibPath, FileExists
             return typeLibPath;
         }
 
-        /*
-         * Method:  GetPathOfTypeLib
-         * 
-         * Gets the type lib path for given type lib attributes (reused almost verbatim from vsdesigner utils code)
-         * NOTE:  If there's a typelib number at the end of the path, does NOT strip it.  
-         */
+        /// <summary>
+        /// Gets the type lib path for given type lib attributes(reused almost verbatim from vsdesigner utils code)
+        /// NOTE:  If there's a typelib number at the end of the path, does NOT strip it.
+        /// </summary>
         internal static bool GetPathOfTypeLib(TaskLoggingHelper log, bool silent, ref TYPELIBATTR typeLibAttr, out string typeLibPath)
         {
             // Get which file the type library resides in.  If the appropriate
@@ -521,40 +453,36 @@ internal static bool GetPathOfTypeLib(TaskLoggingHelper log, bool silent, ref TY
                 }
             }
 
-            if (typeLibPath != null && typeLibPath.Length > 0)
+            if (!string.IsNullOrEmpty(typeLibPath))
             {
                 return true;
             }
-            else
-            {
-                if (!silent)
-                {
-                    log.LogWarningWithCodeFromResources("ResolveComReference.CannotGetPathForTypeLib", typeLibAttr.guid, typeLibAttr.wMajorVerNum, typeLibAttr.wMinorVerNum, "");
-                }
 
-                return false;
+            if (!silent)
+            {
+                log.LogWarningWithCodeFromResources("ResolveComReference.CannotGetPathForTypeLib", typeLibAttr.guid, typeLibAttr.wMajorVerNum, typeLibAttr.wMinorVerNum, "");
             }
+
+            return false;
         }
 
         #region RemapAdoTypeLib guids
 
         // guids for RemapAdoTypeLib
-        private readonly static Guid s_guidADO20 = new Guid("{00000200-0000-0010-8000-00AA006D2EA4}");
-        private readonly static Guid s_guidADO21 = new Guid("{00000201-0000-0010-8000-00AA006D2EA4}");
-        private readonly static Guid s_guidADO25 = new Guid("{00000205-0000-0010-8000-00AA006D2EA4}");
-        private readonly static Guid s_guidADO26 = new Guid("{00000206-0000-0010-8000-00AA006D2EA4}");
+        private static readonly Guid s_guidADO20 = new Guid("{00000200-0000-0010-8000-00AA006D2EA4}");
+        private static readonly Guid s_guidADO21 = new Guid("{00000201-0000-0010-8000-00AA006D2EA4}");
+        private static readonly Guid s_guidADO25 = new Guid("{00000205-0000-0010-8000-00AA006D2EA4}");
+        private static readonly Guid s_guidADO26 = new Guid("{00000206-0000-0010-8000-00AA006D2EA4}");
         // unfortunately this cannot be readonly, since it's being passed by reference to LoadRegTypeLib
         private static Guid s_guidADO27 = new Guid("{EF53050B-882E-4776-B643-EDA472E8E3F2}");
 
         #endregion
 
-        /*
-         * Method:  RemapAdoTypeLib
-         * 
-         * Tries to remap an ADO type library to ADO 2.7. If the type library passed in is an older ADO tlb,
-         * then remap it to ADO 2.7 if it's registered on the machine (!). Otherwise don't modify the typelib.
-         * Returns true if the type library passed in was successfully remapped.
-         */
+        /// <summary>
+        /// Tries to remap an ADO type library to ADO 2.7. If the type library passed in is an older ADO tlb,
+        /// then remap it to ADO 2.7 if it's registered on the machine (!). Otherwise don't modify the typelib.
+        /// Returns true if the type library passed in was successfully remapped.
+        /// </summary>
         internal static bool RemapAdoTypeLib(TaskLoggingHelper log, bool silent, ref TYPELIBATTR typeLibAttr)
         {
             // we only care about ADO 2.0, 2.1, 2.5 or 2.6 here.
@@ -592,9 +520,6 @@ internal static bool RemapAdoTypeLib(TaskLoggingHelper log, bool silent, ref TYP
         /// <summary>
         /// Finds an existing wrapper for the specified component
         /// </summary>
-        /// <param name="wrapperInfo"></param>
-        /// <param name="componentTimestamp"></param>
-        /// <returns></returns>
         internal abstract bool FindExistingWrapper(out ComReferenceWrapperInfo wrapperInfo, DateTime componentTimestamp);
 
         #endregion
diff --git a/src/Tasks/Error.cs b/src/Tasks/Error.cs
index 184ee13c0c7..cfaa4fcd28a 100644
--- a/src/Tasks/Error.cs
+++ b/src/Tasks/Error.cs
@@ -1,14 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.IO;
-using System.Diagnostics;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
-using System.Globalization;
-using System.Resources;
-
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
@@ -17,76 +9,27 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public sealed class Error : TaskExtension
     {
-        private string _text;
-
         /// <summary>
         /// Error message
         /// </summary>
-        public string Text
-        {
-            get
-            {
-                return _text;
-            }
-
-            set
-            {
-                _text = value;
-            }
-        }
-
-        private string _code;
+        public string Text { get; set; }
 
         /// <summary>
         /// Error code
         /// </summary>
-        public string Code
-        {
-            get
-            {
-                return _code;
-            }
-            set
-            {
-                _code = value;
-            }
-        }
-
-        private string _file;
+        public string Code { get; set; }
 
         /// <summary>
         /// Relevant file if any.
         /// If none is provided, the file containing the Error 
         /// task will be used.
         /// </summary>
-        public string File
-        {
-            get
-            {
-                return _file;
-            }
-            set
-            {
-                _file = value;
-            }
-        }
-
-        private string _helpKeyword;
+        public string File { get; set; }
 
         /// <summary>
         /// Error help keyword
         /// </summary>
-        public string HelpKeyword
-        {
-            get
-            {
-                return _helpKeyword;
-            }
-            set
-            {
-                _helpKeyword = value;
-            }
-        }
+        public string HelpKeyword { get; set; }
 
         /// <summary>
         /// Main task method
diff --git a/src/Tasks/ErrorFromResources.cs b/src/Tasks/ErrorFromResources.cs
index e0267a490f0..69cd64ea727 100644
--- a/src/Tasks/ErrorFromResources.cs
+++ b/src/Tasks/ErrorFromResources.cs
@@ -17,115 +17,33 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public sealed class ErrorFromResources : TaskExtension
     {
-        /// <summary>
-        /// Resource from which error message is extracted
-        /// </summary>
-        private string _resource;
-
-        /// <summary>
-        /// Error code
-        /// </summary>
-        private string _code;
-
-        /// <summary>
-        /// Relevant file if any.
-        /// If none is provided, the file containing the Error 
-        /// task will be used.
-        /// </summary>
-        private string _file;
-
-        /// <summary>
-        /// Error help keyword
-        /// </summary>
-        private string _helpKeyword;
-
-        /// <summary>
-        /// Optional arguments to use when formatting the error message
-        /// </summary>
-        private string[] _arguments;
-
         /// <summary>
         /// Resource from which error message is extracted
         /// </summary>
         [Required]
-        public string Resource
-        {
-            get
-            {
-                return _resource;
-            }
-
-            set
-            {
-                _resource = value;
-            }
-        }
+        public string Resource { get; set; }
 
         /// <summary>
         /// Optional arguments to use when formatting the error message
         /// </summary>
-        public string[] Arguments
-        {
-            get
-            {
-                return _arguments;
-            }
-
-            set
-            {
-                _arguments = value;
-            }
-        }
+        public string[] Arguments { get; set; }
 
         /// <summary>
         /// Error code
         /// </summary>
-        public string Code
-        {
-            get
-            {
-                return _code;
-            }
-
-            set
-            {
-                _code = value;
-            }
-        }
+        public string Code { get; set; }
 
         /// <summary>
         /// Relevant file if any.
         /// If none is provided, the file containing the Error 
         /// task will be used.
         /// </summary>
-        public string File
-        {
-            get
-            {
-                return _file;
-            }
-
-            set
-            {
-                _file = value;
-            }
-        }
+        public string File { get; set; }
 
         /// <summary>
         /// Error help keyword
         /// </summary>
-        public string HelpKeyword
-        {
-            get
-            {
-                return _helpKeyword;
-            }
-
-            set
-            {
-                _helpKeyword = value;
-            }
-        }
+        public string HelpKeyword { get; set; }
 
         /// <summary>
         /// Log the requested error message.
@@ -134,8 +52,7 @@ public override bool Execute()
         {
             try
             {
-                string errorCode;
-                string message = ResourceUtilities.ExtractMessageCode(false /* all codes */, Log.FormatResourceString(Resource, Arguments), out errorCode);
+                string message = ResourceUtilities.ExtractMessageCode(false /* all codes */, Log.FormatResourceString(Resource, Arguments), out string errorCode);
 
                 // If the user specifies a code, that should override. 
                 Code = Code ?? errorCode;
diff --git a/src/Tasks/Exec.cs b/src/Tasks/Exec.cs
index 3d98e10a689..be2734f9bd6 100644
--- a/src/Tasks/Exec.cs
+++ b/src/Tasks/Exec.cs
@@ -54,7 +54,6 @@ public Exec()
         private string _batchFile;
         private string _customErrorRegex;
         private string _customWarningRegex;
-        private bool _ignoreStandardErrorWarningFormat = false; // By default, detect standard-format errors
         private readonly List<ITaskItem> _nonEmptyOutput = new List<ITaskItem>();
         private Encoding _standardErrorEncoding;
         private Encoding _standardOutputEncoding;
@@ -67,7 +66,7 @@ public Exec()
         [Required]
         public string Command
         {
-            get { return _command; }
+            get => _command;
             set
             {
                 _command = value;
@@ -97,8 +96,8 @@ public string Command
         /// </summary>
         public string CustomErrorRegularExpression
         {
-            get { return _customErrorRegex; }
-            set { _customErrorRegex = value; }
+            get => _customErrorRegex;
+            set => _customErrorRegex = value;
         }
 
         /// <summary>
@@ -108,8 +107,8 @@ public string CustomErrorRegularExpression
         /// </summary>
         public string CustomWarningRegularExpression
         {
-            get { return _customWarningRegex; }
-            set { _customWarningRegex = value; }
+            get => _customWarningRegex;
+            set => _customWarningRegex = value;
         }
 
         /// <summary>
@@ -117,27 +116,17 @@ public string CustomWarningRegularExpression
         /// the standard error/warning format, and log them as errors/warnings.
         /// Defaults to false.
         /// </summary>
-        public bool IgnoreStandardErrorWarningFormat
-        {
-            get { return _ignoreStandardErrorWarningFormat; }
-            set { _ignoreStandardErrorWarningFormat = value; }
-        }
+        public bool IgnoreStandardErrorWarningFormat { get; set; }
 
         /// <summary>
         /// Property specifying the encoding of the captured task standard output stream
         /// </summary>
-        protected override Encoding StandardOutputEncoding
-        {
-            get { return _standardOutputEncoding; }
-        }
+        protected override Encoding StandardOutputEncoding => _standardOutputEncoding;
 
         /// <summary>
         /// Property specifying the encoding of the captured task standard error stream
         /// </summary>
-        protected override Encoding StandardErrorEncoding
-        {
-            get { return _standardErrorEncoding; }
-        }
+        protected override Encoding StandardErrorEncoding => _standardErrorEncoding;
 
         /// <summary>
         /// Whether or not to use UTF8 encoding for the cmd file and console window.
@@ -153,7 +142,7 @@ protected override Encoding StandardErrorEncoding
         [Output]
         public string StdOutEncoding
         {
-            get { return StandardOutputEncoding.EncodingName; }
+            get => StandardOutputEncoding.EncodingName;
             set
             {
                 try
@@ -174,7 +163,7 @@ public string StdOutEncoding
         [Output]
         public string StdErrEncoding
         {
-            get { return StandardErrorEncoding.EncodingName; }
+            get => StandardErrorEncoding.EncodingName;
             set
             {
                 try
@@ -192,8 +181,8 @@ public string StdErrEncoding
         [Output]
         public ITaskItem[] Outputs
         {
-            get { return _outputs ?? Array.Empty<ITaskItem>(); }
-            set { _outputs = value; }
+            get => _outputs ?? Array.Empty<ITaskItem>();
+            set => _outputs = value;
         }
 
         /// <summary>
@@ -202,10 +191,7 @@ public ITaskItem[] Outputs
         /// if they aren't used.  ConsoleOutput is a combination of stdout and stderr.
         /// </summary>
         [Output]
-        public ITaskItem[] ConsoleOutput
-        {
-            get { return !ConsoleToMSBuild ? Array.Empty<ITaskItem>(): _nonEmptyOutput.ToArray(); }
-        }
+        public ITaskItem[] ConsoleOutput => !ConsoleToMSBuild ? Array.Empty<ITaskItem>(): _nonEmptyOutput.ToArray();
 
         #endregion
 
@@ -246,16 +232,16 @@ private void CreateTemporaryBatchFile()
                     sw.WriteLine("set errorlevel=dummy");
                     sw.WriteLine("set errorlevel=");
 
-                // We may need to change the code page and console encoding.
-                if (encoding.CodePage != EncodingUtilities.CurrentSystemOemEncoding.CodePage)
-                {
-                    // Output to nul so we don't change output and logs.
-                    sw.WriteLine(string.Format(@"%SystemRoot%\System32\chcp.com {0}>nul", encoding.CodePage));
+                    // We may need to change the code page and console encoding.
+                    if (encoding.CodePage != EncodingUtilities.CurrentSystemOemEncoding.CodePage)
+                    {
+                        // Output to nul so we don't change output and logs.
+                        sw.WriteLine($@"%SystemRoot%\System32\chcp.com {encoding.CodePage}>nul");
 
-                    // Ensure that the console encoding is correct.
-                    _standardOutputEncoding = encoding;
-                    _standardErrorEncoding = encoding;
-                }
+                        // Ensure that the console encoding is correct.
+                        _standardOutputEncoding = encoding;
+                        _standardErrorEncoding = encoding;
+                    }
 
                     // if the working directory is a UNC path, bracket the exec command with pushd and popd, because pushd
                     // automatically maps the network path to a drive letter, and then popd disconnects it.
@@ -412,7 +398,7 @@ protected override void LogEventsFromTextOutput(string singleLine, MessageImport
             {
                 Log.LogWarning(singleLine);
             }
-            else if (_ignoreStandardErrorWarningFormat)
+            else if (IgnoreStandardErrorWarningFormat)
             {
                 // Not detecting regular format errors and warnings, and it didn't
                 // match any regexes either -- log as a regular message
@@ -644,19 +630,13 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens
         /// <summary>
         /// The name of the tool to execute
         /// </summary>
-        protected override string ToolName
-        {
-            get { return NativeMethodsShared.IsWindows ? "cmd.exe" : "sh"; }
-        }
+        protected override string ToolName => NativeMethodsShared.IsWindows ? "cmd.exe" : "sh";
 
         /// <summary>
         /// Importance with which to log ordinary messages in the
         /// standard error stream.
         /// </summary>
-        protected override MessageImportance StandardErrorLoggingImportance
-        {
-            get { return MessageImportance.High; }
-        }
+        protected override MessageImportance StandardErrorLoggingImportance => MessageImportance.High;
 
         /// <summary>
         /// Importance with which to log ordinary messages in the
@@ -665,10 +645,7 @@ protected override MessageImportance StandardErrorLoggingImportance
         /// <remarks>
         /// Overridden to increase from the default "Low" up to "High".
         /// </remarks>
-        protected override MessageImportance StandardOutputLoggingImportance
-        {
-            get { return MessageImportance.High; }
-        }
+        protected override MessageImportance StandardOutputLoggingImportance => MessageImportance.High;
 
         #endregion
 
@@ -717,13 +694,13 @@ private Encoding BatchFileEncoding()
             }
         }
 
-            /// <summary>
-            /// Checks to see if a string can be encoded in a specified code page.
-            /// </summary>
-            /// <remarks>Internal for testing purposes.</remarks>
-            /// <param name="codePage">Code page for encoding.</param>
-            /// <param name="stringToEncode">String to encode.</param>
-            /// <returns>True if the string can be encoded in the specified code page.</returns>
+        /// <summary>
+        /// Checks to see if a string can be encoded in a specified code page.
+        /// </summary>
+        /// <remarks>Internal for testing purposes.</remarks>
+        /// <param name="codePage">Code page for encoding.</param>
+        /// <param name="stringToEncode">String to encode.</param>
+        /// <returns>True if the string can be encoded in the specified code page.</returns>
         internal static bool CanEncodeString(int codePage, string stringToEncode)
         {
             // We have a System.String that contains some characters. Get a lossless representation
diff --git a/src/Tasks/ExtractedClassName.cs b/src/Tasks/ExtractedClassName.cs
index e870a9deada..914b98eb8d7 100644
--- a/src/Tasks/ExtractedClassName.cs
+++ b/src/Tasks/ExtractedClassName.cs
@@ -1,8 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
@@ -10,27 +8,14 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public struct ExtractedClassName
     {
-        // whether or not we found the name inside a block of conditionally compiled code
-        private bool _isInsideConditionalBlock;
-        // the extracted class name
-        private string _name;
-
         /// <summary>
         /// Whether or not we found the name inside a block of conditionally compiled code
         /// </summary>
-        public bool IsInsideConditionalBlock
-        {
-            get { return _isInsideConditionalBlock; }
-            set { _isInsideConditionalBlock = value; }
-        }
+        public bool IsInsideConditionalBlock { get; set; }
 
         /// <summary>
         /// Extracted class name
         /// </summary>
-        public string Name
-        {
-            get { return _name; }
-            set { _name = value; }
-        }
+        public string Name { get; set; }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Tasks/FileState.cs b/src/Tasks/FileState.cs
index 0a6280c7fd4..fca31d87c1a 100644
--- a/src/Tasks/FileState.cs
+++ b/src/Tasks/FileState.cs
@@ -77,7 +77,6 @@ private class FileDirInfo
             /// On Win32 it uses native means. Otherwise,
             /// uses standard .NET FileInfo/DirInfo
             /// </summary>
-            /// <param name="filename"></param>
             public FileDirInfo(string filename)
             {
                 Exists = false;
@@ -190,7 +189,6 @@ public FileDirInfo(string filename)
             /// know that getting the length of a file would
             /// throw exception if there are IO problems
             /// </summary>
-            /// <param name="doThrow"></param>
             public void ThrowFileInfoException(bool doThrow)
             {
                 if (doThrow)
@@ -204,7 +202,6 @@ public void ThrowFileInfoException(bool doThrow)
             /// Throw non-IO-related exception if occurred during creation.
             /// Return true if exception did occur, but was IO-related
             /// </summary>
-            /// <returns></returns>
             public bool ThrowNonIoExceptionIfPending()
             {
                 if (_exceptionThrown != null)
@@ -223,7 +220,6 @@ public bool ThrowNonIoExceptionIfPending()
             /// <summary>
             /// Throw any exception collected during construction
             /// </summary>
-            /// <returns></returns>
             public void ThrowException()
             {
                 if (_exceptionThrown != null)
@@ -241,7 +237,7 @@ public void ThrowException()
         /// <summary>
         /// Actual file or directory information
         /// </summary>
-        Lazy<FileDirInfo> _data;
+        private Lazy<FileDirInfo> _data;
 
         /// <summary>
         /// Constructor.
@@ -249,7 +245,7 @@ public void ThrowException()
         /// </summary>
         internal FileState(string filename)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(filename, "filename");
+            ErrorUtilities.VerifyThrowArgumentLength(filename, nameof(filename));
             _filename = filename;
             _data = new Lazy<FileDirInfo>(() => new FileDirInfo(_filename));
         }
diff --git a/src/Tasks/FindAppConfigFile.cs b/src/Tasks/FindAppConfigFile.cs
index 78a595ab870..5899e06f77f 100644
--- a/src/Tasks/FindAppConfigFile.cs
+++ b/src/Tasks/FindAppConfigFile.cs
@@ -3,9 +3,7 @@
 
 using System;
 using System.IO;
-using System.Resources;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -22,10 +20,8 @@ public class FindAppConfigFile : TaskExtension
         private ITaskItem[] _secondaryList;
 
         // The target path metadata value to add to the found item
-        private string _targetPath;
 
         // The item found, if any
-        private ITaskItem _appConfigFileFound = null;
 
         // What we're looking for
         private const string appConfigFile = "app.config";
@@ -38,10 +34,10 @@ public ITaskItem[] PrimaryList
         {
             get
             {
-                ErrorUtilities.VerifyThrowArgumentNull(_primaryList, "primaryList");
+                ErrorUtilities.VerifyThrowArgumentNull(_primaryList, nameof(PrimaryList));
                 return _primaryList;
             }
-            set { _primaryList = value; }
+            set => _primaryList = value;
         }
 
         /// <summary>
@@ -52,31 +48,23 @@ public ITaskItem[] SecondaryList
         {
             get
             {
-                ErrorUtilities.VerifyThrowArgumentNull(_secondaryList, "secondaryList");
+                ErrorUtilities.VerifyThrowArgumentNull(_secondaryList, nameof(SecondaryList));
                 return _secondaryList;
             }
-            set { _secondaryList = value; }
+            set => _secondaryList = value;
         }
 
         /// <summary>
         /// The value to add as TargetPath metadata
         /// </summary>
         [Required]
-        public string TargetPath
-        {
-            get { return _targetPath; }
-            set { _targetPath = value; }
-        }
+        public string TargetPath { get; set; }
 
         /// <summary>
         /// The first matching item found in the list, if any
         /// </summary>
         [Output]
-        public ITaskItem AppConfigFile
-        {
-            get { return _appConfigFileFound; }
-            set { _appConfigFileFound = value; }
-        }
+        public ITaskItem AppConfigFile { get; set; }
 
         /// <summary>
         /// Find the app config
@@ -129,23 +117,22 @@ private bool ConsultLists(bool matchWholeItemSpec)
         /// </summary>
         private bool IsMatchingItem(ITaskItem item, bool matchWholeItemSpec)
         {
-            string filename;
             try
             {
-                filename = (matchWholeItemSpec ? item.ItemSpec : Path.GetFileName(item.ItemSpec));
+                string filename = (matchWholeItemSpec ? item.ItemSpec : Path.GetFileName(item.ItemSpec));
 
                 if (String.Equals(filename, appConfigFile, StringComparison.OrdinalIgnoreCase))
                 {
-                    _appConfigFileFound = item;
+                    AppConfigFile = item;
 
                     // Originally the app.config was found in such a way that it's "OriginalItemSpec"
                     // metadata was cleared out. Although it doesn't really matter, for compatibility,
                     // we'll clear it out here.
-                    _appConfigFileFound.SetMetadata("OriginalItemSpec", item.ItemSpec);
+                    AppConfigFile.SetMetadata("OriginalItemSpec", item.ItemSpec);
 
-                    _appConfigFileFound.SetMetadata(ItemMetadataNames.targetPath, TargetPath);
+                    AppConfigFile.SetMetadata(ItemMetadataNames.targetPath, TargetPath);
 
-                    Log.LogMessageFromResources(MessageImportance.Low, "FindInList.Found", _appConfigFileFound.ItemSpec);
+                    Log.LogMessageFromResources(MessageImportance.Low, "FindInList.Found", AppConfigFile.ItemSpec);
                     return true;
                 }
             }
diff --git a/src/Tasks/FindInList.cs b/src/Tasks/FindInList.cs
index c37099f2130..65d07b92b9e 100644
--- a/src/Tasks/FindInList.cs
+++ b/src/Tasks/FindInList.cs
@@ -18,17 +18,12 @@ public class FindInList : TaskExtension
         // The list to search through
         private ITaskItem[] _list;
         // Whether to match just the file part, or the full item spec
-        private bool _matchFileNameOnly = false;
         // The item found, if any
-        private ITaskItem _itemFound = null;
         // The itemspec to find
-        private string _itemSpecToFind;
         // Whether to match case sensitively
         // Default is case insensitive
-        private bool _caseSensitive;
         // Whether to return the last match
         // (default is the first match)
-        private bool _findLastMatch = false;
 
         /// <summary>
         /// The list to search through
@@ -38,75 +33,47 @@ public ITaskItem[] List
         {
             get
             {
-                ErrorUtilities.VerifyThrowArgumentNull(_list, "list");
+                ErrorUtilities.VerifyThrowArgumentNull(_list, nameof(List));
                 return _list;
             }
-            set { _list = value; }
+            set => _list = value;
         }
 
         /// <summary>
         /// Whether to match against just the file part of the itemspec,
         /// or the whole itemspec (the default)
         /// </summary>
-        public bool MatchFileNameOnly
-        {
-            get { return _matchFileNameOnly; }
-            set { _matchFileNameOnly = value; }
-        }
+        public bool MatchFileNameOnly { get; set; }
 
         /// <summary>
         /// The first matching item found in the list, if any
         /// </summary>
         [Output]
-        public ITaskItem ItemFound
-        {
-            get { return _itemFound; }
-            set { _itemFound = value; }
-        }
+        public ITaskItem ItemFound { get; set; }
 
         /// <summary>
         /// The itemspec to try to find
         /// </summary>
         [Required]
-        public string ItemSpecToFind
-        {
-            get { return _itemSpecToFind; }
-            set { _itemSpecToFind = value; }
-        }
+        public string ItemSpecToFind { get; set; }
 
         /// <summary>
         /// Whether or not to match case sensitively
         /// </summary>
-        public bool CaseSensitive
-        {
-            get { return _caseSensitive; }
-            set { _caseSensitive = value; }
-        }
+        public bool CaseSensitive { get; set; }
 
         /// <summary>
         /// Whether or not to return the last match, instead of 
         /// the first one
         /// </summary>
-        public bool FindLastMatch
-        {
-            get { return _findLastMatch; }
-            set { _findLastMatch = value; }
-        }
+        public bool FindLastMatch { get; set; }
 
         /// <summary>
         /// Entry point
         /// </summary>
         public override bool Execute()
         {
-            StringComparison comparison;
-            if (_caseSensitive)
-            {
-                comparison = StringComparison.Ordinal;
-            }
-            else
-            {
-                comparison = StringComparison.OrdinalIgnoreCase;
-            }
+            StringComparison comparison = CaseSensitive ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;
 
             if (!FindLastMatch)
             {
@@ -141,13 +108,12 @@ public override bool Execute()
         /// </summary>
         private bool IsMatchingItem(StringComparison comparison, ITaskItem item)
         {
-            string filename;
             try
             {
                 var path = FileUtilities.FixFilePath(item.ItemSpec);
-                filename = (MatchFileNameOnly ? Path.GetFileName(path) : path);
+                string filename = (MatchFileNameOnly ? Path.GetFileName(path) : path);
 
-                if (String.Equals(filename, _itemSpecToFind, comparison))
+                if (String.Equals(filename, ItemSpecToFind, comparison))
                 {
                     ItemFound = item;
                     Log.LogMessageFromResources(MessageImportance.Low, "FindInList.Found", path);
diff --git a/src/Tasks/FindInvalidProjectReferences.cs b/src/Tasks/FindInvalidProjectReferences.cs
index 127a77fbea7..5d2114e455a 100644
--- a/src/Tasks/FindInvalidProjectReferences.cs
+++ b/src/Tasks/FindInvalidProjectReferences.cs
@@ -5,13 +5,8 @@
 //-----------------------------------------------------------------------
 
 using System;
-using System.IO;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
-using Microsoft.Build.Shared;
 using System.Collections.Generic;
-using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
-using SystemProcessorArchitecture = System.Reflection.ProcessorArchitecture;
 using System.Text.RegularExpressions;
 
 namespace Microsoft.Build.Tasks
@@ -36,17 +31,17 @@ public class FindInvalidProjectReferences : TaskExtension
         /// <summary>
         /// Reference moniker metadata
         /// </summary>
-        private static readonly string s_referencePlatformMonikerMetadata = "TargetPlatformMoniker";
+        private const string ReferencePlatformMonikerMetadata = "TargetPlatformMoniker";
 
         /// <summary>
         /// SimpleName group
         /// </summary>
-        private static readonly string s_platformSimpleNameGroup = "PLATFORMIDENTITY";
+        private const string PlatformSimpleNameGroup = "PLATFORMIDENTITY";
 
         /// <summary>
         /// Version group
         /// </summary>
-        private static readonly string s_platformVersionGroup = "PLATFORMVERSION";
+        private const string PlatformVersionGroup = "PLATFORMVERSION";
 
         #endregion
 
@@ -55,41 +50,25 @@ public class FindInvalidProjectReferences : TaskExtension
         /// <summary>
         /// List of Platform monikers for each referenced project
         /// </summary>
-        public ITaskItem[] ProjectReferences
-        {
-            get;
-            set;
-        }
+        public ITaskItem[] ProjectReferences { get; set; }
 
         /// <summary>
         /// Target platform version of the current project
         /// </summary>
         [Required]
-        public string TargetPlatformVersion
-        {
-            get;
-            set;
-        }
+        public string TargetPlatformVersion { get; set; }
 
         /// <summary>
         /// Target platform identifier of the current project
         /// </summary>
         [Required]
-        public string TargetPlatformIdentifier
-        {
-            get;
-            set;
-        }
+        public string TargetPlatformIdentifier { get; set; }
 
         /// <summary>
         /// Invalid references to be unresolved 
         /// </summary>
         [Output]
-        public ITaskItem[] InvalidReferences
-        {
-            get;
-            private set;
-        }
+        public ITaskItem[] InvalidReferences { get; private set; }
 
         #endregion
 
@@ -100,25 +79,21 @@ public ITaskItem[] InvalidReferences
         /// </summary>
         public override bool Execute()
         {
-            Version targetPlatformVersionAsVersion = null;
-            List<ITaskItem> invalidReferences = new List<ITaskItem>();
+            var invalidReferences = new List<ITaskItem>();
 
-            Version.TryParse(TargetPlatformVersion, out targetPlatformVersionAsVersion);
+            Version.TryParse(TargetPlatformVersion, out Version targetPlatformVersionAsVersion);
 
             if (ProjectReferences != null)
             {
                 foreach (ITaskItem item in ProjectReferences)
                 {
                     string referenceIdentity = item.ItemSpec;
-                    string referencePlatformMoniker = item.GetMetadata(s_referencePlatformMonikerMetadata);
-
-                    string platform = null;
-                    Version version = null;
+                    string referencePlatformMoniker = item.GetMetadata(ReferencePlatformMonikerMetadata);
 
                     // For each moniker, compare version, issue localized message if the referenced project targets 
                     // a platform with version higher than the current project and make the reference invalid by adding it to
                     // an invalid reference list output
-                    if (ParseMoniker(referencePlatformMoniker, out platform, out version))
+                    if (ParseMoniker(referencePlatformMoniker, out _, out Version version))
                     {
                         if (targetPlatformVersionAsVersion < version)
                         {
@@ -148,9 +123,9 @@ private static bool ParseMoniker(string reference, out string platformIdentity,
 
             if (match.Success)
             {
-                platformIdentity = match.Groups[s_platformSimpleNameGroup].Value.Trim();
+                platformIdentity = match.Groups[PlatformSimpleNameGroup].Value.Trim();
 
-                string rawVersion = match.Groups[s_platformVersionGroup].Value.Trim();
+                string rawVersion = match.Groups[PlatformVersionGroup].Value.Trim();
                 parsedVersion = Version.TryParse(rawVersion, out platformVersion);
             }
 
diff --git a/src/Tasks/FormatUrl.cs b/src/Tasks/FormatUrl.cs
index c9193d1a5ca..788da79089b 100644
--- a/src/Tasks/FormatUrl.cs
+++ b/src/Tasks/FormatUrl.cs
@@ -2,10 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Diagnostics;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
-using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
 {
@@ -14,30 +12,15 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public sealed class FormatUrl : TaskExtension
     {
-        private string _inputUrl;
-        private string _outputUrl;
-
-        public string InputUrl
-        {
-            get { return _inputUrl; }
-            set { _inputUrl = value; }
-        }
+        public string InputUrl { get; set; }
 
         [Output]
-        public string OutputUrl
-        {
-            get { return _outputUrl; }
-            set { _outputUrl = value; }
-        }
+        public string OutputUrl { get; set; }
 
         public override bool Execute()
         {
-            if (_inputUrl != null)
-                _outputUrl = PathUtil.Format(_inputUrl);
-            else
-                _outputUrl = String.Empty;
+            OutputUrl = InputUrl != null ? PathUtil.Format(InputUrl) : String.Empty;
             return true;
         }
     }
 }
-
diff --git a/src/Tasks/FormatVersion.cs b/src/Tasks/FormatVersion.cs
index 6d1a910d2dc..c3a156d6a9a 100644
--- a/src/Tasks/FormatVersion.cs
+++ b/src/Tasks/FormatVersion.cs
@@ -20,61 +20,50 @@ public sealed class FormatVersion : TaskExtension
         private enum _FormatType { Version, Path }
 
         private _FormatType _formatType = _FormatType.Version;
-        private string _outputVersion;
-        private int _revision;
-        private string _version;
-
-        private string _specifiedFormatType = null;
 
         [Output]
-        public string OutputVersion
-        {
-            get { return _outputVersion; }
-            set { _outputVersion = value; }
-        }
+        public string OutputVersion { get; set; }
 
-        public string FormatType
-        {
-            get { return _specifiedFormatType; }
-            set { _specifiedFormatType = value; }
-        }
+        public string FormatType { get; set; }
 
-        public int Revision
-        {
-            get { return _revision; }
-            set { _revision = value; }
-        }
+        public int Revision { get; set; }
 
-        public string Version
-        {
-            get { return _version; }
-            set { _version = value; }
-        }
+        public string Version { get; set; }
 
         public override bool Execute()
         {
             if (!ValidateInputs())
+            {
                 return false;
+            }
 
             if (String.IsNullOrEmpty(Version))
+            {
                 OutputVersion = "1.0.0.0";
+            }
             else if (Version.EndsWith("*", StringComparison.Ordinal))
+            {
                 OutputVersion = Version.Substring(0, Version.Length - 1) + Revision.ToString("G", CultureInfo.InvariantCulture);
+            }
             else
+            {
                 OutputVersion = Version;
+            }
 
             if (_formatType == _FormatType.Path)
+            {
                 OutputVersion = OutputVersion.Replace('.', '_');
+            }
             return true;
         }
 
         private bool ValidateInputs()
         {
-            if (_specifiedFormatType != null)
+            if (FormatType != null)
             {
                 try
                 {
-                    _formatType = (_FormatType)Enum.Parse(typeof(_FormatType), _specifiedFormatType, true);
+                    _formatType = (_FormatType)Enum.Parse(typeof(_FormatType), FormatType, true);
                 }
                 catch (ArgumentException)
                 {
diff --git a/src/Tasks/GenerateApplicationManifest.cs b/src/Tasks/GenerateApplicationManifest.cs
index 77bb74602ac..69cdab6c19c 100644
--- a/src/Tasks/GenerateApplicationManifest.cs
+++ b/src/Tasks/GenerateApplicationManifest.cs
@@ -19,51 +19,24 @@ public sealed class GenerateApplicationManifest : GenerateManifestBase
     {
         private enum _ManifestType { Native, ClickOnce }
 
-        private string _clrVersion = null;
-        private ITaskItem _configFile = null;
-        private ITaskItem[] _dependencies = null;
-        private string _errorReportUrl = null;
-        private ITaskItem[] _files = null;
-        private ITaskItem _iconFile = null;
-        private ITaskItem[] _isolatedComReferences = null;
+        private ITaskItem[] _dependencies;
+        private ITaskItem[] _files;
+        private ITaskItem[] _isolatedComReferences;
         private _ManifestType _manifestType = _ManifestType.ClickOnce;
-        private string _osVersion = null;
-        private ITaskItem _trustInfoFile = null;
-        private ITaskItem[] _fileAssociations = null;
-        private bool _hostInBrowser = false;
-        private bool _useApplicationTrust = false;
-        private string _product = null;
-        private string _publisher = null;
-        private string _suiteName = null;
-        private string _supportUrl = null;
-        private string _specifiedManifestType = null;
-        private string _targetFrameworkSubset = String.Empty;
-        private string _targetFrameworkProfile = String.Empty;
-        private bool _requiresMinimumFramework35SP1;
-
-        public string ClrVersion
-        {
-            get { return _clrVersion; }
-            set { _clrVersion = value; }
-        }
+        private ITaskItem[] _fileAssociations;
+        private bool _useApplicationTrust;
 
-        public ITaskItem ConfigFile
-        {
-            get { return _configFile; }
-            set { _configFile = value; }
-        }
+        public string ClrVersion { get; set; }
+
+        public ITaskItem ConfigFile { get; set; }
 
         public ITaskItem[] Dependencies
         {
-            get { return _dependencies; }
-            set { _dependencies = Util.SortItems(value); }
+            get => _dependencies;
+            set => _dependencies = Util.SortItems(value);
         }
 
-        public string ErrorReportUrl
-        {
-            get { return _errorReportUrl; }
-            set { _errorReportUrl = value; }
-        }
+        public string ErrorReportUrl { get; set; }
 
         public ITaskItem[] FileAssociations
         {
@@ -71,95 +44,49 @@ public ITaskItem[] FileAssociations
             {
                 // File associations are only valid when targeting 3.5 or later
                 if (Util.CompareFrameworkVersions(TargetFrameworkVersion, Constants.TargetFrameworkVersion35) < 0)
+                {
                     return null;
+                }
                 return _fileAssociations;
             }
-            set { _fileAssociations = value; }
+            set => _fileAssociations = value;
         }
 
         public ITaskItem[] Files
         {
-            get { return _files; }
-            set { _files = Util.SortItems(value); }
+            get => _files;
+            set => _files = Util.SortItems(value);
         }
 
-        public bool HostInBrowser
-        {
-            get { return _hostInBrowser; }
-            set { _hostInBrowser = value; }
-        }
+        public bool HostInBrowser { get; set; }
 
-        public ITaskItem IconFile
-        {
-            get { return _iconFile; }
-            set { _iconFile = value; }
-        }
+        public ITaskItem IconFile { get; set; }
 
         public ITaskItem[] IsolatedComReferences
         {
-            get { return _isolatedComReferences; }
-            set { _isolatedComReferences = Util.SortItems(value); }
+            get => _isolatedComReferences;
+            set => _isolatedComReferences = Util.SortItems(value);
         }
 
-        public string ManifestType
-        {
-            get { return _specifiedManifestType; }
-            set { _specifiedManifestType = value; }
-        }
+        public string ManifestType { get; set; }
 
-        public string OSVersion
-        {
-            get { return _osVersion; }
-            set { _osVersion = value; }
-        }
+        public string OSVersion { get; set; }
 
-        public string Product
-        {
-            get { return _product; }
-            set { _product = value; }
-        }
+        public string Product { get; set; }
 
-        public string Publisher
-        {
-            get { return _publisher; }
-            set { _publisher = value; }
-        }
+        public string Publisher { get; set; }
 
-        public bool RequiresMinimumFramework35SP1
-        {
-            get { return _requiresMinimumFramework35SP1; }
-            set { _requiresMinimumFramework35SP1 = value; }
-        }
+        public bool RequiresMinimumFramework35SP1 { get; set; }
 
-        public string SuiteName
-        {
-            get { return _suiteName; }
-            set { _suiteName = value; }
-        }
+        public string SuiteName { get; set; }
 
-        public string SupportUrl
-        {
-            get { return _supportUrl; }
-            set { _supportUrl = value; }
-        }
+        public string SupportUrl { get; set; }
 
-        public string TargetFrameworkSubset
-        {
-            get { return _targetFrameworkSubset; }
-            set { _targetFrameworkSubset = value; }
-        }
+        public string TargetFrameworkSubset { get; set; } = String.Empty;
 
-        public string TargetFrameworkProfile
-        {
-            get { return _targetFrameworkProfile; }
-            set { _targetFrameworkProfile = value; }
-        }
+        public string TargetFrameworkProfile { get; set; } = String.Empty;
 
-        public ITaskItem TrustInfoFile
-        {
-            get { return _trustInfoFile; }
-            set { _trustInfoFile = value; }
-        }
+        public ITaskItem TrustInfoFile { get; set; }
 
         public bool UseApplicationTrust
         {
@@ -167,10 +94,12 @@ public bool UseApplicationTrust
             {
                 // Use application trust is only used if targeting v3.5 or later
                 if (Util.CompareFrameworkVersions(TargetFrameworkVersion, Constants.TargetFrameworkVersion35) < 0)
+                {
                     return false;
+                }
                 return _useApplicationTrust;
             }
-            set { _useApplicationTrust = value; }
+            set => _useApplicationTrust = value;
         }
 
         protected override Type GetObjectType()
@@ -193,12 +122,20 @@ protected override bool OnManifestResolved(Manifest manifest)
         private bool BuildApplicationManifest(ApplicationManifest manifest)
         {
             if (Dependencies != null)
+            {
                 foreach (ITaskItem item in Dependencies)
+                {
                     AddAssemblyFromItem(item);
+                }
+            }
 
             if (Files != null)
+            {
                 foreach (ITaskItem item in Files)
+                {
                     AddFileFromItem(item);
+                }
+            }
 
             // Build ClickOnce info...
             manifest.IsClickOnceManifest = _manifestType == _ManifestType.ClickOnce;
@@ -211,10 +148,14 @@ private bool BuildApplicationManifest(ApplicationManifest manifest)
                 }
 
                 if (!AddClickOnceFiles(manifest))
+                {
                     return false;
+                }
 
                 if (!AddClickOnceFileAssociations(manifest))
+                {
                     return false;
+                }
             }
 
             if (HostInBrowser && Util.CompareFrameworkVersions(TargetFrameworkVersion, Constants.TargetFrameworkVersion30) < 0)
@@ -225,17 +166,27 @@ private bool BuildApplicationManifest(ApplicationManifest manifest)
 
             // Build isolated COM info...
             if (!AddIsolatedComReferences(manifest))
+            {
                 return false;
+            }
 
             manifest.MaxTargetPath = MaxTargetPath;
             manifest.HostInBrowser = HostInBrowser;
             manifest.UseApplicationTrust = UseApplicationTrust;
             if (UseApplicationTrust && SupportUrl != null)
+            {
                 manifest.SupportUrl = SupportUrl;
+            }
+
             if (UseApplicationTrust && SuiteName != null)
+            {
                 manifest.SuiteName = SuiteName;
+            }
+
             if (UseApplicationTrust && ErrorReportUrl != null)
+            {
                 manifest.ErrorReportUrl = ErrorReportUrl;
+            }
 
             return true;
         }
@@ -245,15 +196,21 @@ private bool AddIsolatedComReferences(ApplicationManifest manifest)
             int t1 = Environment.TickCount;
             bool success = true;
             if (IsolatedComReferences != null)
+            {
                 foreach (ITaskItem item in IsolatedComReferences)
                 {
                     string name = item.GetMetadata("Name");
                     if (String.IsNullOrEmpty(name))
+                    {
                         name = Path.GetFileName(item.ItemSpec);
+                    }
                     FileReference file = AddFileFromItem(item);
                     if (!file.ImportComComponent(item.ItemSpec, manifest.OutputMessages, name))
+                    {
                         success = false;
+                    }
                 }
+            }
 
             Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "GenerateApplicationManifest.AddIsolatedComReferences t={0}", Environment.TickCount - t1));
             return success;
@@ -265,11 +222,13 @@ private bool AddClickOnceFileAssociations(ApplicationManifest manifest)
             {
                 foreach (ITaskItem item in FileAssociations)
                 {
-                    FileAssociation fileAssociation = new FileAssociation();
-                    fileAssociation.DefaultIcon = item.GetMetadata("DefaultIcon");
-                    fileAssociation.Description = item.GetMetadata("Description");
-                    fileAssociation.Extension = item.ItemSpec;
-                    fileAssociation.ProgId = item.GetMetadata("Progid");
+                    var fileAssociation = new FileAssociation
+                    {
+                        DefaultIcon = item.GetMetadata("DefaultIcon"),
+                        Description = item.GetMetadata("Description"),
+                        Extension = item.ItemSpec,
+                        ProgId = item.GetMetadata("Progid")
+                    };
                     manifest.FileAssociations.Add(fileAssociation);
                 }
             }
@@ -281,36 +240,41 @@ private bool AddClickOnceFiles(ApplicationManifest manifest)
         {
             int t1 = Environment.TickCount;
 
-            if (ConfigFile != null && !String.IsNullOrEmpty(ConfigFile.ItemSpec))
+            if (!String.IsNullOrEmpty(ConfigFile?.ItemSpec))
+            {
                 manifest.ConfigFile = FindFileFromItem(ConfigFile).TargetPath;
+            }
 
-            if (IconFile != null && !String.IsNullOrEmpty(IconFile.ItemSpec))
+            if (!String.IsNullOrEmpty(IconFile?.ItemSpec))
+            {
                 manifest.IconFile = FindFileFromItem(IconFile).TargetPath;
+            }
 
-            if (TrustInfoFile != null && !String.IsNullOrEmpty(TrustInfoFile.ItemSpec))
+            if (!String.IsNullOrEmpty(TrustInfoFile?.ItemSpec))
             {
                 manifest.TrustInfo = new TrustInfo();
                 manifest.TrustInfo.Read(TrustInfoFile.ItemSpec);
             }
 
             if (manifest.TrustInfo == null)
+            {
                 manifest.TrustInfo = new TrustInfo();
+            }
 
             if (OSVersion != null)
             {
-                manifest.OSVersion = _osVersion;
+                manifest.OSVersion = OSVersion;
             }
 
             if (ClrVersion != null)
             {
-                AssemblyReference CLRPlatformAssembly = manifest.AssemblyReferences.Find(Constants.CLRPlatformAssemblyName);
-                if (CLRPlatformAssembly == null)
+                AssemblyReference clrPlatformAssembly = manifest.AssemblyReferences.Find(Constants.CLRPlatformAssemblyName);
+                if (clrPlatformAssembly == null)
                 {
-                    CLRPlatformAssembly = new AssemblyReference();
-                    CLRPlatformAssembly.IsPrerequisite = true;
-                    manifest.AssemblyReferences.Add(CLRPlatformAssembly);
+                    clrPlatformAssembly = new AssemblyReference { IsPrerequisite = true };
+                    manifest.AssemblyReferences.Add(clrPlatformAssembly);
                 }
-                CLRPlatformAssembly.AssemblyIdentity = new AssemblyIdentity(Constants.CLRPlatformAssemblyName, ClrVersion);
+                clrPlatformAssembly.AssemblyIdentity = new AssemblyIdentity(Constants.CLRPlatformAssemblyName, ClrVersion);
             }
 
             if (Util.CompareFrameworkVersions(TargetFrameworkVersion, Constants.TargetFrameworkVersion30) == 0)
@@ -323,7 +287,7 @@ private bool AddClickOnceFiles(ApplicationManifest manifest)
                 EnsureAssemblyReferenceExists(manifest, CreateAssemblyIdentity(Constants.NET35AssemblyIdentity));
 
                 if ((!String.IsNullOrEmpty(TargetFrameworkSubset) && TargetFrameworkSubset.Equals(Constants.ClientFrameworkSubset, StringComparison.OrdinalIgnoreCase)) ||
-            (!String.IsNullOrEmpty(TargetFrameworkProfile) && TargetFrameworkProfile.Equals(Constants.ClientFrameworkSubset, StringComparison.OrdinalIgnoreCase)))
+                    (!String.IsNullOrEmpty(TargetFrameworkProfile) && TargetFrameworkProfile.Equals(Constants.ClientFrameworkSubset, StringComparison.OrdinalIgnoreCase)))
                 {
                     EnsureAssemblyReferenceExists(manifest, CreateAssemblyIdentity(Constants.NET35ClientAssemblyIdentity));
                 }
@@ -340,11 +304,11 @@ private bool AddClickOnceFiles(ApplicationManifest manifest)
         protected internal override bool ValidateInputs()
         {
             bool valid = base.ValidateInputs();
-            if (_specifiedManifestType != null)
+            if (ManifestType != null)
             {
                 try
                 {
-                    _manifestType = (_ManifestType)Enum.Parse(typeof(_ManifestType), _specifiedManifestType, true);
+                    _manifestType = (_ManifestType)Enum.Parse(typeof(_ManifestType), ManifestType, true);
                 }
                 catch (FormatException)
                 {
@@ -357,7 +321,9 @@ protected internal override bool ValidateInputs()
                     valid = false;
                 }
                 if (_manifestType == _ManifestType.Native)
+                {
                     EntryPoint = null; // EntryPoint is ignored if ManifestType="Native"
+                }
             }
             if (ClrVersion != null && !Util.IsValidVersion(ClrVersion, 4))
             {
@@ -377,8 +343,7 @@ protected internal override bool ValidateInputs()
             if (_manifestType == _ManifestType.ClickOnce)
             {
                 // ClickOnce supports asInvoker privilege only.
-                string requestedExecutionLevel;
-                if (GetRequestedExecutionLevel(out requestedExecutionLevel) && String.CompareOrdinal(requestedExecutionLevel, Constants.UACAsInvoker) != 0)
+                if (GetRequestedExecutionLevel(out string requestedExecutionLevel) && String.CompareOrdinal(requestedExecutionLevel, Constants.UACAsInvoker) != 0)
                 {
                     Log.LogErrorWithCodeFromResources("GenerateManifest.InvalidRequestedExecutionLevel", requestedExecutionLevel);
                     valid = false;
@@ -392,9 +357,13 @@ private bool BuildResolvedSettings(ApplicationManifest manifest)
             // Note: if changing the logic in this function, please update the logic in 
             //  GenerateDeploymentManifest.BuildResolvedSettings as well.
             if (Product != null)
+            {
                 manifest.Product = Product;
+            }
             else if (String.IsNullOrEmpty(manifest.Product))
+            {
                 manifest.Product = Path.GetFileNameWithoutExtension(manifest.AssemblyIdentity.Name);
+            }
             Debug.Assert(!String.IsNullOrEmpty(manifest.Product));
 
             if (Publisher != null)
@@ -405,29 +374,37 @@ private bool BuildResolvedSettings(ApplicationManifest manifest)
             {
                 string org = Util.GetRegisteredOrganization();
                 if (!String.IsNullOrEmpty(org))
+                {
                     manifest.Publisher = org;
+                }
                 else
+                {
                     manifest.Publisher = manifest.Product;
+                }
             }
             Debug.Assert(!String.IsNullOrEmpty(manifest.Publisher));
 
             return true;
         }
 
-        private AssemblyIdentity CreateAssemblyIdentity(string[] values)
+        private static AssemblyIdentity CreateAssemblyIdentity(string[] values)
         {
             if (values.Length != 5)
+            {
                 return null;
+            }
             return new AssemblyIdentity(values[0], values[1], values[2], values[3], values[4]);
         }
 
-        private void EnsureAssemblyReferenceExists(ApplicationManifest manifest, AssemblyIdentity identity)
+        private static void EnsureAssemblyReferenceExists(ApplicationManifest manifest, AssemblyIdentity identity)
         {
             if (manifest.AssemblyReferences.Find(identity) == null)
             {
-                AssemblyReference assembly = new AssemblyReference();
-                assembly.IsPrerequisite = true;
-                assembly.AssemblyIdentity = identity;
+                var assembly = new AssemblyReference
+                {
+                    IsPrerequisite = true,
+                    AssemblyIdentity = identity
+                };
                 manifest.AssemblyReferences.Add(assembly);
             }
         }
@@ -436,7 +413,7 @@ private bool GetRequestedExecutionLevel(out string requestedExecutionLevel)
         {
             requestedExecutionLevel = Constants.UACAsInvoker;  // For backwards compatibility we assume asInvoker to begin with.
 
-            if (InputManifest == null || String.IsNullOrEmpty(InputManifest.ItemSpec) || String.CompareOrdinal(InputManifest.ItemSpec, "NoManifest") == 0)
+            if (String.IsNullOrEmpty(InputManifest?.ItemSpec) || String.CompareOrdinal(InputManifest.ItemSpec, "NoManifest") == 0)
             {
                 return false;
             }
@@ -445,22 +422,23 @@ private bool GetRequestedExecutionLevel(out string requestedExecutionLevel)
             {
                 using (Stream s = File.Open(InputManifest.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read))
                 {
-                    XmlDocument document = new XmlDocument();
-                    XmlReaderSettings xrSettings = new XmlReaderSettings();
-                    xrSettings.DtdProcessing = DtdProcessing.Ignore;
+                    var document = new XmlDocument();
+                    var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
                     using (XmlReader xr = XmlReader.Create(s, xrSettings))
                     {
                         document.Load(xr);
 
-                        //Create an XmlNamespaceManager for resolving namespaces.
-                        XmlNamespaceManager nsmgr = XmlNamespaces.GetNamespaceManager(document.NameTable);
+                        // Create an XmlNamespaceManager for resolving namespaces.
+                        var nsmgr = XmlNamespaces.GetNamespaceManager(document.NameTable);
 
                         XmlNode node = (XmlElement)document.SelectSingleNode(XPaths.requestedExecutionLevelPath, nsmgr);
                         if (node != null)
                         {
-                            XmlAttribute attr = (XmlAttribute)(node.Attributes.GetNamedItem("level"));
+                            var attr = (XmlAttribute)(node.Attributes.GetNamedItem("level"));
                             if (attr != null)
+                            {
                                 requestedExecutionLevel = attr.Value;
+                            }
                         }
                     }
 
diff --git a/src/Tasks/GenerateBootstrapper.cs b/src/Tasks/GenerateBootstrapper.cs
index 019567df506..34fac6b59cf 100644
--- a/src/Tasks/GenerateBootstrapper.cs
+++ b/src/Tasks/GenerateBootstrapper.cs
@@ -3,14 +3,8 @@
 
 using System;
 using System.IO;
-using System.Resources;
-using System.Reflection;
-using System.Diagnostics;
 using System.Collections;
-using System.Globalization;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks.Deployment.Bootstrapper;
 
 namespace Microsoft.Build.Tasks
@@ -20,134 +14,41 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public sealed class GenerateBootstrapper : TaskExtension
     {
-        private string _applicationFile = null;
-        private string _applicationName = null;
-        private bool _applicationRequiresElevation = false;
-        private string _applicationUrl = null;
-        private ITaskItem[] _bootstrapperItems = null;
-        private string _componentsLocation = null;
-        private string _componentsUrl = null;
-        private bool _copyComponents = true;
-        private string _culture = Util.DefaultCultureInfo.Name;
-        private string _fallbackCulture = Util.DefaultCultureInfo.Name;
-        private string _outputPath = Directory.GetCurrentDirectory();
-        private string _path = null;
-        private string _supportUrl = null;
-        private bool _validate = true;
-        private string[] _bootstrapperComponentFiles = null;
-        private string _bootstrapperKeyFile = null;
-        private string _visualStudioVersion = null;
-
-        public GenerateBootstrapper()
-        {
-        }
+        public string ApplicationName { get; set; }
 
-        public string ApplicationName
-        {
-            get { return _applicationName; }
-            set { _applicationName = value; }
-        }
+        public string ApplicationFile { get; set; }
 
-        public string ApplicationFile
-        {
-            get { return _applicationFile; }
-            set { _applicationFile = value; }
-        }
+        public bool ApplicationRequiresElevation { get; set; }
 
-        public bool ApplicationRequiresElevation
-        {
-            get { return _applicationRequiresElevation; }
-            set { _applicationRequiresElevation = value; }
-        }
+        public string ApplicationUrl { get; set; }
 
-        public string ApplicationUrl
-        {
-            get { return _applicationUrl; }
-            set { _applicationUrl = value; }
-        }
+        public ITaskItem[] BootstrapperItems { get; set; }
 
-        public ITaskItem[] BootstrapperItems
-        {
-            get { return _bootstrapperItems; }
-            set { _bootstrapperItems = value; }
-        }
+        public string ComponentsLocation { get; set; }
 
-        public string ComponentsLocation
-        {
-            get { return _componentsLocation; }
-            set { _componentsLocation = value; }
-        }
-
-        public string ComponentsUrl
-        {
-            get { return _componentsUrl; }
-            set { _componentsUrl = value; }
-        }
+        public string ComponentsUrl { get; set; }
 
-        public bool CopyComponents
-        {
-            get { return _copyComponents; }
-            set
-            {
-                _copyComponents = value;
-            }
-        }
+        public bool CopyComponents { get; set; } = true;
 
-        public string Culture
-        {
-            get { return _culture; }
-            set { _culture = value; }
-        }
+        public string Culture { get; set; } = Util.DefaultCultureInfo.Name;
 
-        public string FallbackCulture
-        {
-            get { return _fallbackCulture; }
-            set { _fallbackCulture = value; }
-        }
+        public string FallbackCulture { get; set; } = Util.DefaultCultureInfo.Name;
 
-        public string OutputPath
-        {
-            get { return _outputPath; }
-            set { _outputPath = value; }
-        }
+        public string OutputPath { get; set; } = Directory.GetCurrentDirectory();
 
-        public string Path
-        {
-            get { return _path; }
-            set { _path = value; }
-        }
+        public string Path { get; set; }
 
-        public string SupportUrl
-        {
-            get { return _supportUrl; }
-            set { _supportUrl = value; }
-        }
+        public string SupportUrl { get; set; }
 
-        public string VisualStudioVersion
-        {
-            get { return _visualStudioVersion; }
-            set { _visualStudioVersion = value; }
-        }
+        public string VisualStudioVersion { get; set; }
 
-        public bool Validate
-        {
-            get { return _validate; }
-            set { _validate = value; }
-        }
+        public bool Validate { get; set; } = true;
 
         [Output]
-        public string BootstrapperKeyFile
-        {
-            get { return _bootstrapperKeyFile; }
-            set { _bootstrapperKeyFile = value; }
-        }
+        public string BootstrapperKeyFile { get; set; }
 
         [Output]
-        public string[] BootstrapperComponentFiles
-        {
-            get { return _bootstrapperComponentFiles; }
-            set { _bootstrapperComponentFiles = value; }
-        }
+        public string[] BootstrapperComponentFiles { get; set; }
 
         /// <summary>
         /// Generate the bootstrapper.
@@ -155,38 +56,40 @@ public string[] BootstrapperComponentFiles
         /// <returns> Return true on success, false on failure.</returns>
         public override bool Execute()
         {
-            if (_path == null)
+            if (Path == null)
             {
-                _path = Util.GetDefaultPath(_visualStudioVersion);
+                Path = Util.GetDefaultPath(VisualStudioVersion);
             }
 
-            BootstrapperBuilder bootstrapperBuilder = new BootstrapperBuilder();
-
-            bootstrapperBuilder.Validate = this.Validate;
-            bootstrapperBuilder.Path = this.Path;
+            var bootstrapperBuilder = new BootstrapperBuilder
+            {
+                Validate = Validate,
+                Path = Path
+            };
 
             ProductCollection products = bootstrapperBuilder.Products;
 
-            BuildSettings settings = new BuildSettings();
-
-            settings.ApplicationFile = ApplicationFile;
-            settings.ApplicationName = ApplicationName;
-            settings.ApplicationRequiresElevation = ApplicationRequiresElevation;
-            settings.ApplicationUrl = ApplicationUrl;
-            settings.ComponentsLocation = ConvertStringToComponentsLocation(this.ComponentsLocation);
-            settings.ComponentsUrl = ComponentsUrl;
-            settings.CopyComponents = CopyComponents;
-            settings.Culture = _culture;
-            settings.FallbackCulture = _fallbackCulture;
-            settings.OutputPath = this.OutputPath;
-            settings.SupportUrl = this.SupportUrl;
+            var settings = new BuildSettings
+            {
+                ApplicationFile = ApplicationFile,
+                ApplicationName = ApplicationName,
+                ApplicationRequiresElevation = ApplicationRequiresElevation,
+                ApplicationUrl = ApplicationUrl,
+                ComponentsLocation = ConvertStringToComponentsLocation(ComponentsLocation),
+                ComponentsUrl = ComponentsUrl,
+                CopyComponents = CopyComponents,
+                Culture = Culture,
+                FallbackCulture = FallbackCulture,
+                OutputPath = OutputPath,
+                SupportUrl = SupportUrl
+            };
 
             if (String.IsNullOrEmpty(settings.Culture) || settings.Culture == "*")
             {
                 settings.Culture = settings.FallbackCulture;
             }
 
-            if (this.BootstrapperItems != null)
+            if (BootstrapperItems != null)
             {
                 // The bootstrapper items may not be in the correct order, because XMake saves 
                 // items in alphabetical order.  So we will attempt to put items into the correct 
@@ -195,9 +98,9 @@ public override bool Execute()
                 // in order, looking to see if the item is built.  If it is, remove the item from 
                 // the hashtable.  All remaining items in the table can not be built, so errors 
                 // will be issued.
-                Hashtable items = new Hashtable(StringComparer.OrdinalIgnoreCase);
+                var items = new Hashtable(StringComparer.OrdinalIgnoreCase);
 
-                foreach (ITaskItem bootstrapperItem in this.BootstrapperItems)
+                foreach (ITaskItem bootstrapperItem in BootstrapperItems)
                 {
                     string installAttribute = bootstrapperItem.GetMetadata("Install");
                     if (String.IsNullOrEmpty(installAttribute) || Shared.ConversionUtilities.ConvertStringToBool(installAttribute))
@@ -236,30 +139,37 @@ public override bool Execute()
                 foreach (BuildMessage message in messages)
                 {
                     if (message.Severity == BuildMessageSeverity.Error)
+                    {
                         Log.LogError(null, message.HelpCode, message.HelpKeyword, null, 0, 0, 0, 0, message.Message);
+                    }
                     else if (message.Severity == BuildMessageSeverity.Warning)
+                    {
                         Log.LogWarning(null, message.HelpCode, message.HelpKeyword, null, 0, 0, 0, 0, message.Message);
+                    }
                 }
             }
 
-            this.BootstrapperKeyFile = results.KeyFile;
-            this.BootstrapperComponentFiles = results.ComponentFiles;
+            BootstrapperKeyFile = results.KeyFile;
+            BootstrapperComponentFiles = results.ComponentFiles;
 
             return results.Succeeded;
         }
 
         private ComponentsLocation ConvertStringToComponentsLocation(string parameterValue)
         {
-            if (parameterValue == null || parameterValue.Length == 0)
-                return Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.HomeSite;
+            if (string.IsNullOrEmpty(parameterValue))
+            {
+                return Deployment.Bootstrapper.ComponentsLocation.HomeSite;
+            }
+
             try
             {
-                return (Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation)Enum.Parse(typeof(Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation), parameterValue, false);
+                return (ComponentsLocation)Enum.Parse(typeof(ComponentsLocation), parameterValue, false);
             }
             catch (FormatException)
             {
                 Log.LogWarningWithCodeFromResources("GenerateBootstrapper.InvalidComponentsLocation", parameterValue);
-                return Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.HomeSite;
+                return Deployment.Bootstrapper.ComponentsLocation.HomeSite;
             }
         }
     }
diff --git a/src/Tasks/GenerateDeploymentManifest.cs b/src/Tasks/GenerateDeploymentManifest.cs
index f65e1860a4c..dceeb90b0ed 100644
--- a/src/Tasks/GenerateDeploymentManifest.cs
+++ b/src/Tasks/GenerateDeploymentManifest.cs
@@ -3,11 +3,8 @@
 
 using System;
 using System.Diagnostics;
-using System.Globalization;
 using System.IO;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
-using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
 {
@@ -16,49 +13,42 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public sealed class GenerateDeploymentManifest : GenerateManifestBase
     {
-        private bool? _createDesktopShortcut = null;
-        private string _deploymentUrl = null;
-        private bool? _disallowUrlActivation = null;
-        private string _errorReportUrl = null;
-        private bool? _install = null;
-        private bool? _mapFileExtensions = null;
-        private string _minimumRequiredVersion = null;
-        private string _product = null;
-        private string _publisher = null;
-        private string _suiteName = null;
-        private string _supportUrl = null;
-        private bool? _trustUrlParameters = null;
-        private bool? _updateEnabled = null;
-        private int? _updateInterval = null;
-        private UpdateMode? _updateMode = null;
-        private UpdateUnit? _updateUnit = null;
-
-        private string _specifiedUpdateMode = null;
-        private string _specifiedUpdateUnit = null;
+        private bool? _createDesktopShortcut;
+        private bool? _disallowUrlActivation;
+        private string _errorReportUrl;
+        private bool? _install;
+        private bool? _mapFileExtensions;
+        private string _suiteName;
+        private bool? _trustUrlParameters;
+        private bool? _updateEnabled;
+        private int? _updateInterval;
+        private UpdateMode? _updateMode;
+        private UpdateUnit? _updateUnit;
 
         public bool CreateDesktopShortcut
         {
             get
             {
                 if (!_createDesktopShortcut.HasValue)
+                {
                     return false;
+                }
+
                 if (Util.CompareFrameworkVersions(TargetFrameworkVersion, Constants.TargetFrameworkVersion35) < 0)
+                {
                     return false;
+                }
                 return (bool)_createDesktopShortcut;
             }
-            set { _createDesktopShortcut = value; }
+            set => _createDesktopShortcut = value;
         }
 
-        public string DeploymentUrl
-        {
-            get { return _deploymentUrl; }
-            set { _deploymentUrl = value; }
-        }
+        public string DeploymentUrl { get; set; }
 
         public bool DisallowUrlActivation
         {
-            get { return (bool)_disallowUrlActivation; }
-            set { _disallowUrlActivation = value; }
+            get => (bool)_disallowUrlActivation;
+            set => _disallowUrlActivation = value;
         }
 
         public string ErrorReportUrl
@@ -66,97 +56,81 @@ public string ErrorReportUrl
             get
             {
                 if (Util.CompareFrameworkVersions(TargetFrameworkVersion, Constants.TargetFrameworkVersion35) < 0)
+                {
                     return null;
+                }
                 return _errorReportUrl;
             }
-            set { _errorReportUrl = value; }
+            set => _errorReportUrl = value;
         }
 
         public bool Install
         {
-            get { return (bool)_install; }
-            set { _install = value; }
+            get => (bool)_install;
+            set => _install = value;
         }
 
-        public string MinimumRequiredVersion
-        {
-            get { return _minimumRequiredVersion; }
-            set { _minimumRequiredVersion = value; }
-        }
+        public string MinimumRequiredVersion { get; set; } = null;
 
         public bool MapFileExtensions
         {
-            get { return (bool)_mapFileExtensions; }
-            set { _mapFileExtensions = value; }
+            get => (bool)_mapFileExtensions;
+            set => _mapFileExtensions = value;
         }
 
-        public string Product
-        {
-            get { return _product; }
-            set { _product = value; }
-        }
+        public string Product { get; set; }
 
-        public string Publisher
-        {
-            get { return _publisher; }
-            set { _publisher = value; }
-        }
+        public string Publisher { get; set; }
 
         public string SuiteName
         {
             get
             {
                 if (Util.CompareFrameworkVersions(TargetFrameworkVersion, Constants.TargetFrameworkVersion35) < 0)
+                {
                     return null;
+                }
                 return _suiteName;
             }
-            set { _suiteName = value; }
+            set => _suiteName = value;
         }
 
-        public string SupportUrl
-        {
-            get { return _supportUrl; }
-            set { _supportUrl = value; }
-        }
+        public string SupportUrl { get; set; } = null;
 
         public bool TrustUrlParameters
         {
-            get { return (bool)_trustUrlParameters; }
-            set { _trustUrlParameters = value; }
+            get => (bool)_trustUrlParameters;
+            set => _trustUrlParameters = value;
         }
 
         public bool UpdateEnabled
         {
-            get { return (bool)_updateEnabled; }
-            set { _updateEnabled = value; }
+            get => (bool)_updateEnabled;
+            set => _updateEnabled = value;
         }
 
         public int UpdateInterval
         {
-            get { return (int)_updateInterval; }
-            set { _updateInterval = value; }
+            get => (int)_updateInterval;
+            set => _updateInterval = value;
         }
 
-        public string UpdateMode
-        {
-            get { return _specifiedUpdateMode; }
-            set { _specifiedUpdateMode = value; }
-        }
+        public string UpdateMode { get; set; }
 
-        public string UpdateUnit
-        {
-            get { return _specifiedUpdateUnit; }
-            set { _specifiedUpdateUnit = value; }
-        }
+        public string UpdateUnit { get; set; }
 
         private bool BuildResolvedSettings(DeployManifest manifest)
         {
             // Note: if changing the logic in this function, please update the logic in 
             //  GenerateApplicationManifest.BuildResolvedSettings as well.
             if (Product != null)
+            {
                 manifest.Product = Product;
+            }
             else if (String.IsNullOrEmpty(manifest.Product))
+            {
                 manifest.Product = Path.GetFileNameWithoutExtension(manifest.AssemblyIdentity.Name);
+            }
             Debug.Assert(!String.IsNullOrEmpty(manifest.Product));
 
             if (Publisher != null)
@@ -166,10 +140,7 @@ private bool BuildResolvedSettings(DeployManifest manifest)
             else if (String.IsNullOrEmpty(manifest.Publisher))
             {
                 string org = Util.GetRegisteredOrganization();
-                if (!String.IsNullOrEmpty(org))
-                    manifest.Publisher = org;
-                else
-                    manifest.Publisher = manifest.Product;
+                manifest.Publisher = !String.IsNullOrEmpty(org) ? org : manifest.Product;
             }
             Debug.Assert(!String.IsNullOrEmpty(manifest.Publisher));
 
@@ -200,47 +171,77 @@ private bool BuildDeployManifest(DeployManifest manifest)
             }
 
             if (SupportUrl != null)
+            {
                 manifest.SupportUrl = SupportUrl;
+            }
 
             if (DeploymentUrl != null)
+            {
                 manifest.DeploymentUrl = DeploymentUrl;
+            }
 
             if (_install.HasValue)
+            {
                 manifest.Install = (bool)_install;
+            }
 
             if (_updateEnabled.HasValue)
+            {
                 manifest.UpdateEnabled = (bool)_updateEnabled;
+            }
 
             if (_updateInterval.HasValue)
+            {
                 manifest.UpdateInterval = (int)_updateInterval;
+            }
 
             if (_updateMode.HasValue)
+            {
                 manifest.UpdateMode = (UpdateMode)_updateMode;
+            }
 
             if (_updateUnit.HasValue)
+            {
                 manifest.UpdateUnit = (UpdateUnit)_updateUnit;
+            }
 
             if (MinimumRequiredVersion != null)
+            {
                 manifest.MinimumRequiredVersion = MinimumRequiredVersion;
+            }
 
             if (manifest.Install) // Ignore DisallowUrlActivation flag for online-only apps
+            {
                 if (_disallowUrlActivation.HasValue)
+                {
                     manifest.DisallowUrlActivation = (bool)_disallowUrlActivation;
+                }
+            }
 
             if (_mapFileExtensions.HasValue)
+            {
                 manifest.MapFileExtensions = (bool)_mapFileExtensions;
+            }
 
             if (_trustUrlParameters.HasValue)
+            {
                 manifest.TrustUrlParameters = (bool)_trustUrlParameters;
+            }
 
             if (_createDesktopShortcut.HasValue)
+            {
                 manifest.CreateDesktopShortcut = CreateDesktopShortcut;
+            }
 
             if (SuiteName != null)
+            {
                 manifest.SuiteName = SuiteName;
+            }
 
             if (ErrorReportUrl != null)
+            {
                 manifest.ErrorReportUrl = ErrorReportUrl;
+            }
 
             return true;
         }
@@ -248,16 +249,16 @@ private bool BuildDeployManifest(DeployManifest manifest)
         protected internal override bool ValidateInputs()
         {
             bool valid = base.ValidateInputs();
-            if (!String.IsNullOrEmpty(_minimumRequiredVersion) && !Util.IsValidVersion(_minimumRequiredVersion, 4))
+            if (!String.IsNullOrEmpty(MinimumRequiredVersion) && !Util.IsValidVersion(MinimumRequiredVersion, 4))
             {
                 Log.LogErrorWithCodeFromResources("GenerateManifest.InvalidValue", "MinimumRequiredVersion");
                 valid = false;
             }
-            if (_specifiedUpdateMode != null)
+            if (UpdateMode != null)
             {
                 try
                 {
-                    _updateMode = (UpdateMode)Enum.Parse(typeof(UpdateMode), _specifiedUpdateMode, true);
+                    _updateMode = (UpdateMode)Enum.Parse(typeof(UpdateMode), UpdateMode, true);
                 }
                 catch (FormatException)
                 {
@@ -270,11 +271,11 @@ protected internal override bool ValidateInputs()
                     valid = false;
                 }
             }
-            if (_specifiedUpdateUnit != null)
+            if (UpdateUnit != null)
             {
                 try
                 {
-                    _updateUnit = (UpdateUnit)Enum.Parse(typeof(UpdateUnit), _specifiedUpdateUnit, true);
+                    _updateUnit = (UpdateUnit)Enum.Parse(typeof(UpdateUnit), UpdateUnit, true);
                 }
                 catch (FormatException)
                 {
diff --git a/src/Tasks/GenerateManifestBase.cs b/src/Tasks/GenerateManifestBase.cs
index a92e14c8af4..379a3c1d833 100644
--- a/src/Tasks/GenerateManifestBase.cs
+++ b/src/Tasks/GenerateManifestBase.cs
@@ -2,15 +2,12 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Diagnostics;
 using System.Globalization;
 using System.IO;
-using System.Collections;
-using System.Security.Cryptography;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
 using Microsoft.Build.Utilities;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
 {
@@ -20,21 +17,11 @@ namespace Microsoft.Build.Tasks
     public abstract class GenerateManifestBase : Task
     {
         private enum AssemblyType { Unspecified, Managed, Native, Satellite };
-        private enum DependencyType { Install, Prerequisite };
-
-        private string _assemblyName = null;
-        private string _assemblyVersion = null;
-        private string _description = null;
-        private ITaskItem _entryPoint = null;
-        private ITaskItem _inputManifest = null;
-        private int _maxTargetPath = 0;
-        private ITaskItem _outputManifest = null;
-        private string _platform = null;
-        private string _processorArchitecture = null;
-        private int _startTime = 0;
-        private string _targetCulture = null;
+        private enum DependencyType { Install };
+
+        private string _processorArchitecture;
+        private int _startTime;
         private string _targetFrameworkVersion = Constants.TargetFrameworkVersion20;
-        private string _targetFrameworkMoniker = null;
 
         private Manifest _manifest;
         protected abstract bool OnManifestLoaded(Manifest manifest);
@@ -46,90 +33,53 @@ protected GenerateManifestBase() : base(AssemblyResources.PrimaryResources, "MSB
         {
         }
 
-        public string AssemblyName
-        {
-            get { return _assemblyName; }
-            set { _assemblyName = value; }
-        }
+        public string AssemblyName { get; set; }
 
-        public string AssemblyVersion
-        {
-            get { return _assemblyVersion; }
-            set { _assemblyVersion = value; }
-        }
+        public string AssemblyVersion { get; set; }
 
-        public string Description
-        {
-            get { return _description; }
-            set { _description = value; }
-        }
+        public string Description { get; set; }
 
-        public ITaskItem EntryPoint
-        {
-            get { return _entryPoint; }
-            set { _entryPoint = value; }
-        }
+        public ITaskItem EntryPoint { get; set; }
 
-        public ITaskItem InputManifest
-        {
-            get { return _inputManifest; }
-            set { _inputManifest = value; }
-        }
+        public ITaskItem InputManifest { get; set; }
 
-        public int MaxTargetPath
-        {
-            get { return _maxTargetPath; }
-            set { _maxTargetPath = value; }
-        }
+        public int MaxTargetPath { get; set; }
 
         [Output]
-        public ITaskItem OutputManifest
-        {
-            get { return _outputManifest; }
-            set { _outputManifest = value; }
-        }
+        public ITaskItem OutputManifest { get; set; }
 
-        public string Platform
-        {
-            get { return _platform; }
-            set { _platform = value; }
-        }
+        public string Platform { get; set; } = null;
 
-        public string TargetCulture
-        {
-            get { return _targetCulture; }
-            set { _targetCulture = value; }
-        }
+        public string TargetCulture { get; set; } = null;
 
         public string TargetFrameworkVersion
         {
             get
             {
                 if (string.IsNullOrEmpty(_targetFrameworkVersion))
+                {
                     return Constants.TargetFrameworkVersion35;
+                }
                 return _targetFrameworkVersion;
             }
-            set { _targetFrameworkVersion = value; }
+            set => _targetFrameworkVersion = value;
         }
 
-        public string TargetFrameworkMoniker
-        {
-            get
-            {
-                return _targetFrameworkMoniker;
-            }
-            set { _targetFrameworkMoniker = value; }
-        }
+        public string TargetFrameworkMoniker { get; set; }
 
         protected internal AssemblyReference AddAssemblyNameFromItem(ITaskItem item, AssemblyReferenceType referenceType)
         {
-            AssemblyReference assembly = new AssemblyReference();
-            assembly.AssemblyIdentity = AssemblyIdentity.FromAssemblyName(item.ItemSpec);
-            assembly.ReferenceType = referenceType;
+            var assembly = new AssemblyReference
+            {
+                AssemblyIdentity = AssemblyIdentity.FromAssemblyName(item.ItemSpec),
+                ReferenceType = referenceType
+            };
             _manifest.AssemblyReferences.Add(assembly);
             string hintPath = item.GetMetadata("HintPath");
             if (!String.IsNullOrEmpty(hintPath))
+            {
                 assembly.SourcePath = hintPath;
+            }
             SetItemAttributes(item, assembly);
             return assembly;
         }
@@ -138,7 +88,9 @@ protected internal AssemblyReference AddAssemblyFromItem(ITaskItem item)
         {
             // if the assembly is a no-pia assembly and embed interop is turned on, then we don't write it to the manifest.
             if (IsEmbedInteropEnabledForAssembly(item))
+            {
                 return null;
+            }
 
             AssemblyReferenceType referenceType;
             AssemblyType assemblyType = GetItemAssemblyType(item);
@@ -171,8 +123,7 @@ protected internal AssemblyReference AddAssemblyFromItem(ITaskItem item)
                 // If we interpreted the item as a strong name, then treat it as a Fusion display name...
                 if (identity.IsStrongName)
                 {
-                    assembly = new AssemblyReference();
-                    assembly.AssemblyIdentity = identity;
+                    assembly = new AssemblyReference { AssemblyIdentity = identity };
                 }
                 else // otherwise treat it as a file path...
                 {
@@ -210,21 +161,27 @@ protected internal FileReference AddFileFromItem(ITaskItem item)
 
         private AssemblyIdentity CreateAssemblyIdentity(AssemblyIdentity baseIdentity, AssemblyIdentity entryPointIdentity)
         {
-            string name = _assemblyName;
-            string version = _assemblyVersion;
+            string name = AssemblyName;
+            string version = AssemblyVersion;
             string publicKeyToken = "0000000000000000";
-            string culture = _targetCulture;
+            string culture = TargetCulture;
 
             if (String.IsNullOrEmpty(name))
             {
-                if (baseIdentity != null && !String.IsNullOrEmpty(baseIdentity.Name))
+                if (!String.IsNullOrEmpty(baseIdentity?.Name))
+                {
                     name = baseIdentity.Name;
-                else if (entryPointIdentity != null && !String.IsNullOrEmpty(entryPointIdentity.Name))
+                }
+                else if (!String.IsNullOrEmpty(entryPointIdentity?.Name))
                 {
                     if (_manifest is DeployManifest)
+                    {
                         name = Path.GetFileNameWithoutExtension(entryPointIdentity.Name) + ".application";
+                    }
                     else if (_manifest is ApplicationManifest)
+                    {
                         name = entryPointIdentity.Name + ".exe";
+                    }
                 }
             }
             if (String.IsNullOrEmpty(name))
@@ -235,50 +192,75 @@ private AssemblyIdentity CreateAssemblyIdentity(AssemblyIdentity baseIdentity, A
 
             if (String.IsNullOrEmpty(version))
             {
-                if (baseIdentity != null && !String.IsNullOrEmpty(baseIdentity.Version))
+                if (!String.IsNullOrEmpty(baseIdentity?.Version))
+                {
                     version = baseIdentity.Version;
-                else if (entryPointIdentity != null && !String.IsNullOrEmpty(entryPointIdentity.Version))
+                }
+                else if (!String.IsNullOrEmpty(entryPointIdentity?.Version))
+                {
                     version = entryPointIdentity.Version;
+                }
             }
+
             if (String.IsNullOrEmpty(version))
+            {
                 version = "1.0.0.0";
+            }
 
             if (String.IsNullOrEmpty(culture))
             {
-                if (baseIdentity != null && !String.IsNullOrEmpty(baseIdentity.Culture))
+                if (!String.IsNullOrEmpty(baseIdentity?.Culture))
+                {
                     culture = baseIdentity.Culture;
-                else if (entryPointIdentity != null && !String.IsNullOrEmpty(entryPointIdentity.Culture))
+                }
+                else if (!String.IsNullOrEmpty(entryPointIdentity?.Culture))
+                {
                     culture = entryPointIdentity.Culture;
+                }
             }
+
             if (String.IsNullOrEmpty(culture)
-             || String.Equals(culture, "neutral", StringComparison.OrdinalIgnoreCase)
-             || String.Equals(culture, "*", StringComparison.OrdinalIgnoreCase))
+                || String.Equals(culture, "neutral", StringComparison.OrdinalIgnoreCase)
+                || String.Equals(culture, "*", StringComparison.OrdinalIgnoreCase))
+            {
                 culture = "neutral";
+            }
 
             if (String.IsNullOrEmpty(_processorArchitecture))
             {
-                if (baseIdentity != null && !String.IsNullOrEmpty(baseIdentity.ProcessorArchitecture))
+                if (!String.IsNullOrEmpty(baseIdentity?.ProcessorArchitecture))
+                {
                     _processorArchitecture = baseIdentity.ProcessorArchitecture;
-                else if (entryPointIdentity != null && !String.IsNullOrEmpty(entryPointIdentity.ProcessorArchitecture))
+                }
+                else if (!String.IsNullOrEmpty(entryPointIdentity?.ProcessorArchitecture))
+                {
                     _processorArchitecture = entryPointIdentity.ProcessorArchitecture;
+                }
             }
+
             if (String.IsNullOrEmpty(_processorArchitecture))
+            {
                 _processorArchitecture = "msil";
+            }
 
             // Fixup for non-ClickOnce case...
             if (_manifest is ApplicationManifest)
             {
-                ApplicationManifest applicationManifest = _manifest as ApplicationManifest;
+                var applicationManifest = _manifest as ApplicationManifest;
                 if (!applicationManifest.IsClickOnceManifest)
                 {
                     // Don't need publicKeyToken attribute for non-ClickOnce case
                     publicKeyToken = null;
                     // Language attribute should be omitted if neutral
                     if (String.Compare(culture, "neutral", StringComparison.OrdinalIgnoreCase) == 0)
+                    {
                         culture = null;
+                    }
                     // WinXP loader doesn't understand "msil"
                     if (String.Compare(_processorArchitecture, "msil", StringComparison.OrdinalIgnoreCase) == 0)
+                    {
                         _processorArchitecture = null;
+                    }
                 }
             }
 
@@ -291,16 +273,22 @@ public override bool Execute()
 
             Type manifestType = GetObjectType();
             if (!InitializeManifest(manifestType))
+            {
                 success = false;
+            }
 
             if (success && !BuildManifest())
+            {
                 success = false;
+            }
 
             if (_manifest != null)
             {
                 _manifest.OutputMessages.LogTaskMessages(this);
                 if (_manifest.OutputMessages.ErrorCount > 0)
+                {
                     success = false;
+                }
             }
 
             return success;
@@ -309,18 +297,26 @@ public override bool Execute()
         private bool BuildManifest()
         {
             if (!OnManifestLoaded(_manifest))
+            {
                 return false;
+            }
 
             if (!ResolveFiles())
+            {
                 return false;
+            }
 
             if (!ResolveIdentity())
+            {
                 return false;
+            }
 
             _manifest.SourcePath = GetOutputPath();
 
             if (!OnManifestResolved(_manifest))
+            {
                 return false;
+            }
 
             return WriteManifest();
         }
@@ -329,19 +325,26 @@ protected internal FileReference FindFileFromItem(ITaskItem item)
         {
             string targetPath = item.GetMetadata(ItemMetadataNames.targetPath);
             if (String.IsNullOrEmpty(targetPath))
+            {
                 targetPath = BaseReference.GetDefaultTargetPath(item.ItemSpec);
+            }
             foreach (FileReference file in _manifest.FileReferences)
+            {
                 if (String.Compare(targetPath, file.TargetPath, StringComparison.OrdinalIgnoreCase) == 0)
+                {
                     return file;
+                }
+            }
             return AddFileFromItem(item);
         }
 
         private string GetDefaultFileName()
         {
             if (_manifest is DeployManifest)
+            {
                 return _manifest.AssemblyIdentity.Name;
-            else
-                return _manifest.AssemblyIdentity.Name + ".manifest";
+            }
+            return _manifest.AssemblyIdentity.Name + ".manifest";
         }
 
         // Returns assembly type (i.e. "Managed", "Native", or "Satellite") as specified by the item.
@@ -351,6 +354,7 @@ private AssemblyType GetItemAssemblyType(ITaskItem item)
         {
             string value = item.GetMetadata("AssemblyType");
             if (!String.IsNullOrEmpty(value))
+            {
                 try
                 {
                     return (AssemblyType)Enum.Parse(typeof(AssemblyType), value, true);
@@ -363,15 +367,14 @@ private AssemblyType GetItemAssemblyType(ITaskItem item)
                 {
                     Log.LogWarningWithCodeFromResources("GenerateManifest.InvalidItemValue", "AssemblyType", item.ItemSpec);
                 }
+            }
             return AssemblyType.Unspecified;
         }
 
-        private bool IsEmbedInteropEnabledForAssembly(ITaskItem item)
+        private static bool IsEmbedInteropEnabledForAssembly(ITaskItem item)
         {
             string value = item.GetMetadata("EmbedInteropTypes");
-            bool result;
-
-            bool.TryParse(value, out result);
+            bool.TryParse(value, out bool result);
             return result;
         }
 
@@ -382,6 +385,7 @@ private DependencyType GetItemDependencyType(ITaskItem item)
         {
             string value = item.GetMetadata("DependencyType");
             if (!String.IsNullOrEmpty(value))
+            {
                 try
                 {
                     return (DependencyType)Enum.Parse(typeof(DependencyType), value, true);
@@ -394,15 +398,17 @@ private DependencyType GetItemDependencyType(ITaskItem item)
                 {
                     Log.LogWarningWithCodeFromResources("GenerateManifest.InvalidItemValue", "DependencyType", item.ItemSpec);
                 }
+            }
             return DependencyType.Install;
         }
 
         private string GetOutputPath()
         {
             if (OutputManifest != null)
+            {
                 return OutputManifest.ItemSpec;
-            else
-                return GetDefaultFileName();
+            }
+            return GetDefaultFileName();
         }
 
         private bool InitializeManifest(Type manifestType)
@@ -410,18 +416,28 @@ private bool InitializeManifest(Type manifestType)
             _startTime = Environment.TickCount;
 
             if (!ValidateInputs())
+            {
                 return false;
+            }
 
             if (manifestType == null)
-                throw new ArgumentNullException("manifestType");
-            if (InputManifest == null || String.IsNullOrEmpty(InputManifest.ItemSpec))
+            {
+                throw new ArgumentNullException(nameof(manifestType));
+            }
+            if (String.IsNullOrEmpty(InputManifest?.ItemSpec))
             {
                 if (manifestType == typeof(ApplicationManifest))
-                    _manifest = new ApplicationManifest(this.TargetFrameworkVersion);
+                {
+                    _manifest = new ApplicationManifest(TargetFrameworkVersion);
+                }
                 else if (manifestType == typeof(DeployManifest))
-                    _manifest = new DeployManifest(this.TargetFrameworkMoniker);
+                {
+                    _manifest = new DeployManifest(TargetFrameworkMoniker);
+                }
                 else
-                    throw new ArgumentException(String.Empty /* no message */, "manifestType");
+                {
+                    throw new ArgumentException(String.Empty /* no message */, nameof(manifestType));
+                }
             }
             else
             {
@@ -442,31 +458,40 @@ private bool InitializeManifest(Type manifestType)
                 return false;
             }
 
-            if (_manifest is DeployManifest)
+            if (_manifest is DeployManifest deployManifest)
             {
-                DeployManifest deployManifest = _manifest as DeployManifest;
                 if (string.IsNullOrEmpty(deployManifest.TargetFrameworkMoniker))
-                    deployManifest.TargetFrameworkMoniker = this.TargetFrameworkMoniker;
+                {
+                    deployManifest.TargetFrameworkMoniker = TargetFrameworkMoniker;
+                }
             }
-            else if (_manifest is ApplicationManifest)
+            else if (_manifest is ApplicationManifest applicationManifest)
             {
-                ApplicationManifest applicationManifest = _manifest as ApplicationManifest;
                 if (string.IsNullOrEmpty(applicationManifest.TargetFrameworkVersion))
-                    applicationManifest.TargetFrameworkVersion = this.TargetFrameworkVersion;
+                {
+                    applicationManifest.TargetFrameworkVersion = TargetFrameworkVersion;
+                }
             }
 
-            if (EntryPoint != null && !String.IsNullOrEmpty(EntryPoint.ItemSpec))
+            if (!String.IsNullOrEmpty(EntryPoint?.ItemSpec))
             {
                 AssemblyReferenceType referenceType = AssemblyReferenceType.Unspecified;
                 if (_manifest is DeployManifest)
+                {
                     referenceType = AssemblyReferenceType.ClickOnceManifest;
+                }
+
                 if (_manifest is ApplicationManifest)
+                {
                     referenceType = AssemblyReferenceType.ManagedAssembly;
+                }
                 _manifest.EntryPoint = AddEntryPointFromItem(EntryPoint, referenceType);
             }
 
             if (Description != null)
+            {
                 _manifest.Description = Description;
+            }
 
             return true;
         }
@@ -477,9 +502,11 @@ private bool ResolveFiles()
 
             string[] searchPaths = { Directory.GetCurrentDirectory() };
             _manifest.ResolveFiles(searchPaths);
-            _manifest.UpdateFileInfo(this.TargetFrameworkVersion);
+            _manifest.UpdateFileInfo(TargetFrameworkVersion);
             if (_manifest.OutputMessages.ErrorCount > 0)
+            {
                 return false;
+            }
 
             Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "GenerateManifestBase.ResolveFiles t={0}", Environment.TickCount - t1));
             return true;
@@ -487,7 +514,7 @@ private bool ResolveFiles()
 
         private bool ResolveIdentity()
         {
-            AssemblyIdentity entryPointIdentity = _manifest.EntryPoint != null ? _manifest.EntryPoint.AssemblyIdentity : null;
+            AssemblyIdentity entryPointIdentity = _manifest.EntryPoint?.AssemblyIdentity;
             _manifest.AssemblyIdentity = CreateAssemblyIdentity(_manifest.AssemblyIdentity, entryPointIdentity);
             return _manifest.AssemblyIdentity != null;
         }
@@ -496,36 +523,42 @@ private void SetItemAttributes(ITaskItem item, BaseReference file)
         {
             string targetPath = item.GetMetadata(ItemMetadataNames.targetPath);
             if (!String.IsNullOrEmpty(targetPath))
+            {
                 file.TargetPath = targetPath;
+            }
             else
+            {
                 file.TargetPath = Path.IsPathRooted(file.SourcePath) || file.SourcePath.StartsWith("..", StringComparison.Ordinal) ? Path.GetFileName(file.SourcePath) : file.SourcePath;
+            }
             file.Group = item.GetMetadata("Group");
             file.IsOptional = !String.IsNullOrEmpty(file.Group);
             if (Util.CompareFrameworkVersions(TargetFrameworkVersion, Constants.TargetFrameworkVersion35) >= 0)
+            {
                 file.IncludeHash = ConvertUtil.ToBoolean(item.GetMetadata("IncludeHash"), true);
+            }
         }
 
         protected internal virtual bool ValidateInputs()
         {
             bool valid = true;
-            if (!String.IsNullOrEmpty(_assemblyName) && !Util.IsValidAssemblyName(_assemblyName))
+            if (!String.IsNullOrEmpty(AssemblyName) && !Util.IsValidAssemblyName(AssemblyName))
             {
                 Log.LogErrorWithCodeFromResources("GenerateManifest.InvalidValue", "AssemblyName");
                 valid = false;
             }
-            if (!String.IsNullOrEmpty(_assemblyVersion) && !Util.IsValidVersion(_assemblyVersion, 4))
+            if (!String.IsNullOrEmpty(AssemblyVersion) && !Util.IsValidVersion(AssemblyVersion, 4))
             {
                 Log.LogErrorWithCodeFromResources("GenerateManifest.InvalidValue", "AssemblyVersion");
                 valid = false;
             }
-            if (!String.IsNullOrEmpty(_targetCulture) && !Util.IsValidCulture(_targetCulture))
+            if (!String.IsNullOrEmpty(TargetCulture) && !Util.IsValidCulture(TargetCulture))
             {
                 Log.LogErrorWithCodeFromResources("GenerateManifest.InvalidValue", "TargetCulture");
                 valid = false;
             }
-            if (!String.IsNullOrEmpty(_platform))
+            if (!String.IsNullOrEmpty(Platform))
             {
-                _processorArchitecture = Util.PlatformToProcessorArchitecture(_platform);
+                _processorArchitecture = Util.PlatformToProcessorArchitecture(Platform);
                 if (String.IsNullOrEmpty(_processorArchitecture))
                 {
                     Log.LogErrorWithCodeFromResources("GenerateManifest.InvalidValue", "Platform");
@@ -539,14 +572,18 @@ protected internal virtual bool ValidateOutput()
         {
             _manifest.Validate();
             if (_manifest.OutputMessages.ErrorCount > 0)
+            {
                 return false;
+            }
 
             // Check length of manifest file name does not exceed maximum...
             if (MaxTargetPath > 0)
             {
                 string manifestFileName = Path.GetFileName(OutputManifest.ItemSpec);
                 if (manifestFileName.Length > MaxTargetPath)
+                {
                     Log.LogWarningWithCodeFromResources("GenerateManifest.TargetPathTooLong", manifestFileName, MaxTargetPath);
+                }
             }
 
             return true;
@@ -555,15 +592,19 @@ protected internal virtual bool ValidateOutput()
         private bool WriteManifest()
         {
             if (OutputManifest == null)
+            {
                 OutputManifest = new TaskItem(GetDefaultFileName());
+            }
 
             if (!ValidateOutput())
+            {
                 return false;
+            }
 
             int t1 = Environment.TickCount;
             try
             {
-                ManifestWriter.WriteManifest(_manifest, OutputManifest.ItemSpec, this.TargetFrameworkVersion);
+                ManifestWriter.WriteManifest(_manifest, OutputManifest.ItemSpec, TargetFrameworkVersion);
             }
             catch (Exception ex)
             {
diff --git a/src/Tasks/GenerateTrustInfo.cs b/src/Tasks/GenerateTrustInfo.cs
index f0d675aa5ea..434d7ef1616 100644
--- a/src/Tasks/GenerateTrustInfo.cs
+++ b/src/Tasks/GenerateTrustInfo.cs
@@ -2,14 +2,9 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Globalization;
 using System.IO;
-using System.Resources;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
-using Microsoft.Build.Utilities;
-using Microsoft.Build.Shared;
 using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
 
 namespace Microsoft.Build.Tasks
@@ -20,65 +15,29 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public sealed class GenerateTrustInfo : TaskExtension
     {
-        private ITaskItem _baseManifest = null;
-        private string _excludedPermissions = null;
-        private string _targetFrameworkMoniker;
-        private string _targetZone;
-        private ITaskItem _trustInfoFile;
-        private ITaskItem[] _applicationDependencies;
         private const string Custom = "Custom";
 
-        public ITaskItem BaseManifest
-        {
-            get { return _baseManifest; }
-            set { _baseManifest = value; }
-        }
+        public ITaskItem BaseManifest { get; set; }
 
-        public string ExcludedPermissions
-        {
-            get { return _excludedPermissions; }
-            set { _excludedPermissions = value; }
-        }
+        public string ExcludedPermissions { get; set; }
 
-        public string TargetFrameworkMoniker
-        {
-            get { return _targetFrameworkMoniker; }
-            set { _targetFrameworkMoniker = value; }
-        }
+        public string TargetFrameworkMoniker { get; set; }
 
-        public string TargetZone
-        {
-            get { return _targetZone; }
-            set { _targetZone = value; }
-        }
+        public string TargetZone { get; set; }
 
-        public ITaskItem[] ApplicationDependencies
-        {
-            get { return _applicationDependencies; }
-            set { _applicationDependencies = value; }
-        }
+        public ITaskItem[] ApplicationDependencies { get; set; }
 
         [Output]
         [Required]
-        public ITaskItem TrustInfoFile
-        {
-            get { return _trustInfoFile; }
-            set { _trustInfoFile = value; }
-        }
-
-        public GenerateTrustInfo()
-        {
-        }
+        public ITaskItem TrustInfoFile { get; set; }
 
         public override bool Execute()
         {
-            TrustInfo trustInfo = new TrustInfo();
-            trustInfo.IsFullTrust = false;
-            FrameworkNameVersioning fn = null;
+            var trustInfo = new TrustInfo { IsFullTrust = false };
             string dotNetVersion = string.Empty;
             if (!string.IsNullOrEmpty(TargetFrameworkMoniker))
             {
-                fn = new FrameworkNameVersioning(TargetFrameworkMoniker);
+                var fn = new FrameworkNameVersioning(TargetFrameworkMoniker);
                 dotNetVersion = fn.Version.ToString();
             }
 
@@ -97,21 +56,23 @@ public override bool Execute()
             }
 
             if (!String.IsNullOrEmpty(ExcludedPermissions))
+            {
                 Log.LogWarningFromResources("GenerateManifest.ExcludedPermissionsNotSupported");
+            }
 
             try
             {
                 // If it's a known zone and the user add additional permission to it.
-                if (!String.IsNullOrEmpty(_targetZone)
+                if (!String.IsNullOrEmpty(TargetZone)
                     && trustInfo.PermissionSet != null && trustInfo.PermissionSet.Count > 0
-                    && !String.Equals(_targetZone, Custom, StringComparison.OrdinalIgnoreCase))
+                    && !String.Equals(TargetZone, Custom, StringComparison.OrdinalIgnoreCase))
                 {
                     Log.LogErrorFromResources("GenerateManifest.KnownTargetZoneCannotHaveAdditionalPermissionType");
                     return false;
                 }
                 else
                 {
-                    trustInfo.PermissionSet = SecurityUtilities.ComputeZonePermissionSetHelper(TargetZone, trustInfo.PermissionSet, _applicationDependencies, TargetFrameworkMoniker);
+                    trustInfo.PermissionSet = SecurityUtilities.ComputeZonePermissionSetHelper(TargetZone, trustInfo.PermissionSet, ApplicationDependencies, TargetFrameworkMoniker);
                     if (trustInfo.PermissionSet == null)
                     {
                         Log.LogErrorWithCodeFromResources("GenerateManifest.NoPermissionSetForTargetZone", dotNetVersion);
@@ -127,9 +88,13 @@ public override bool Execute()
             catch (ArgumentException ex)
             {
                 if (String.Equals(ex.ParamName, "TargetZone", StringComparison.OrdinalIgnoreCase))
+                {
                     Log.LogWarningWithCodeFromResources("GenerateManifest.InvalidItemValue", "TargetZone", TargetZone);
+                }
                 else
+                {
                     throw;
+                }
             }
 
             // Write trust-info back to a stand-alone trust file
@@ -137,13 +102,5 @@ public override bool Execute()
 
             return true;
         }
-
-        private static string[] StringToIdentityList(string s)
-        {
-            string[] a = s.Split(';');
-            for (int i = 0; i < a.Length; ++i)
-                a[i] = a[i].Trim();
-            return a;
-        }
     }
 }
diff --git a/src/Tasks/GetAssemblyIdentity.cs b/src/Tasks/GetAssemblyIdentity.cs
index 184a1f7a2ef..a59a980cc30 100644
--- a/src/Tasks/GetAssemblyIdentity.cs
+++ b/src/Tasks/GetAssemblyIdentity.cs
@@ -2,14 +2,13 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Diagnostics;
+using System.Collections.Generic;
 using System.Globalization;
 using System.Reflection;
 using System.Text;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
 {
@@ -23,39 +22,38 @@ namespace Microsoft.Build.Tasks
     public class GetAssemblyIdentity : TaskExtension
     {
         private ITaskItem[] _assemblyFiles;
-        private ITaskItem[] _assemblies;
 
         [Required]
         public ITaskItem[] AssemblyFiles
         {
             get
             {
-                ErrorUtilities.VerifyThrowArgumentNull(_assemblyFiles, "assemblyFiles");
+                ErrorUtilities.VerifyThrowArgumentNull(_assemblyFiles, nameof(AssemblyFiles));
                 return _assemblyFiles;
             }
-            set { _assemblyFiles = value; }
+            set => _assemblyFiles = value;
         }
 
         [Output]
-        public ITaskItem[] Assemblies
-        {
-            get { return _assemblies; }
-            set { _assemblies = value; }
-        }
+        public ITaskItem[] Assemblies { get; set; }
 
         private static string ByteArrayToHex(Byte[] a)
         {
             if (a == null)
+            {
                 return null;
-            StringBuilder s = new StringBuilder(a.Length);
+            }
+            var s = new StringBuilder(a.Length * 2);
             foreach (Byte b in a)
+            {
                 s.Append(b.ToString("X02", CultureInfo.InvariantCulture));
+            }
             return s.ToString();
         }
 
         public override bool Execute()
         {
-            ArrayList list = new ArrayList();
+            var list = new List<ITaskItem>();
             foreach (ITaskItem item in AssemblyFiles)
             {
                 AssemblyName an;
@@ -77,15 +75,23 @@ public override bool Execute()
                 ITaskItem newItem = new TaskItem(an.FullName);
                 newItem.SetMetadata("Name", an.Name);
                 if (an.Version != null)
+                {
                     newItem.SetMetadata("Version", an.Version.ToString());
+                }
+
                 if (an.GetPublicKeyToken() != null)
+                {
                     newItem.SetMetadata("PublicKeyToken", ByteArrayToHex(an.GetPublicKeyToken()));
+                }
+
                 if (an.CultureInfo != null)
+                {
                     newItem.SetMetadata("Culture", an.CultureInfo.ToString());
+                }
                 item.CopyMetadataTo(newItem);
                 list.Add(newItem);
             }
-            Assemblies = (ITaskItem[])list.ToArray(typeof(ITaskItem));
+            Assemblies = list.ToArray();
             return !Log.HasLoggedErrors;
         }
     }
diff --git a/src/Tasks/GetFrameworkPath.cs b/src/Tasks/GetFrameworkPath.cs
index e0794af9e9b..c5a560ec525 100644
--- a/src/Tasks/GetFrameworkPath.cs
+++ b/src/Tasks/GetFrameworkPath.cs
@@ -50,21 +50,21 @@ public override bool Execute()
         // In a large build, this adds up.
         // PERF NOTE: We also only find paths we are actually asked for (via <Output> tags)
 
-        private static Lazy<string> s_path;
-        private static Lazy<string> s_version11Path;
-        private static Lazy<string> s_version20Path;
-        private static Lazy<string> s_version30Path;
-        private static Lazy<string> s_version35Path;
-        private static Lazy<string> s_version40Path;
-        private static Lazy<string> s_version45Path;
-        private static Lazy<string> s_version451Path;
-        private static Lazy<string> s_version452Path;
-        private static Lazy<string> s_version46Path;
-        private static Lazy<string> s_version461Path;
-        private static Lazy<string> s_version462Path;
-        private static Lazy<string> s_version47Path;
-        private static Lazy<string> s_version471Path;
-        private static Lazy<string> s_version472Path;
+        private static readonly Lazy<string> s_path;
+        private static readonly Lazy<string> s_version11Path;
+        private static readonly Lazy<string> s_version20Path;
+        private static readonly Lazy<string> s_version30Path;
+        private static readonly Lazy<string> s_version35Path;
+        private static readonly Lazy<string> s_version40Path;
+        private static readonly Lazy<string> s_version45Path;
+        private static readonly Lazy<string> s_version451Path;
+        private static readonly Lazy<string> s_version452Path;
+        private static readonly Lazy<string> s_version46Path;
+        private static readonly Lazy<string> s_version461Path;
+        private static readonly Lazy<string> s_version462Path;
+        private static readonly Lazy<string> s_version47Path;
+        private static readonly Lazy<string> s_version471Path;
+        private static readonly Lazy<string> s_version472Path;
 
         /// <summary>
         /// Path to the latest framework, whatever version it happens to be
diff --git a/src/Tasks/GetFrameworkSDKPath.cs b/src/Tasks/GetFrameworkSDKPath.cs
index 71c0443b89c..bff7ee77f87 100644
--- a/src/Tasks/GetFrameworkSDKPath.cs
+++ b/src/Tasks/GetFrameworkSDKPath.cs
@@ -2,10 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
-using System.Diagnostics;
-using System.Resources;
-using System.Reflection;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
diff --git a/src/Tasks/GetInstalledSDKLocations.cs b/src/Tasks/GetInstalledSDKLocations.cs
index fc0e4abf4cf..cf65a1954a0 100644
--- a/src/Tasks/GetInstalledSDKLocations.cs
+++ b/src/Tasks/GetInstalledSDKLocations.cs
@@ -9,11 +9,11 @@
 //-----------------------------------------------------------------------
 
 using System;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
 
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
@@ -67,14 +67,11 @@ public class GetInstalledSDKLocations : TaskExtension
         [Required]
         public string TargetPlatformVersion
         {
-            get
-            {
-                return _targetPlatformVersion;
-            }
+            get => _targetPlatformVersion;
 
             set
             {
-                ErrorUtilities.VerifyThrowArgumentNull(value, "TargetPlatformVersion");
+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(TargetPlatformVersion));
                 _targetPlatformVersion = value;
             }
         }
@@ -85,14 +82,11 @@ public string TargetPlatformVersion
         [Required]
         public string TargetPlatformIdentifier
         {
-            get
-            {
-                return _targetPlatformIdentifier;
-            }
+            get => _targetPlatformIdentifier;
 
             set
             {
-                ErrorUtilities.VerifyThrowArgumentNull(value, "TargetPlatformIdentifier");
+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(TargetPlatformIdentifier));
                 _targetPlatformIdentifier = value;
             }
         }
@@ -100,30 +94,18 @@ public string TargetPlatformIdentifier
         /// <summary>
         /// Root registry root to look for SDKs
         /// </summary>
-        public string SDKRegistryRoot
-        {
-            get;
-            set;
-        }
+        public string SDKRegistryRoot { get; set; }
 
         /// <summary>
         /// Root directory on disk to look for SDKs
         /// </summary>
         [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "SDK", Justification = "Shipped this way in Dev11 Beta (go-live)")]
-        public string[] SDKDirectoryRoots
-        {
-            get;
-            set;
-        }
+        public string[] SDKDirectoryRoots { get; set; }
 
         /// <summary>
         /// Root directories on disk to look for new style extension SDKs
         /// </summary>
-        public string[] SDKExtensionDirectoryRoots
-        {
-            get;
-            set;
-        }
+        public string[] SDKExtensionDirectoryRoots { get; set; }
 
         /// <summary>
         /// When set to true, the task will produce a warning if there were no SDKs found.
@@ -135,11 +117,7 @@ public string[] SDKExtensionDirectoryRoots
         /// The itemspec is the SDK install location. There is a piece of metadata called SDKName which contains the name of the SDK.
         /// </summary>
         [Output]
-        public ITaskItem[] InstalledSDKs
-        {
-            get;
-            set;
-        }
+        public ITaskItem[] InstalledSDKs { get; set; }
         #endregion
 
         #region ITask Members
@@ -147,7 +125,6 @@ public ITaskItem[] InstalledSDKs
         /// <summary>
         /// Get the SDK.
         /// </summary>
-        /// <returns>true</returns>
         public override bool Execute()
         {
             // TargetPlatformVersion and TargetPlatformIdentifier are requried to correctly look for SDKs.
@@ -177,7 +154,7 @@ public override bool Execute()
                 Log.LogErrorWithCodeFromResources("GetInstalledSDKs.CouldNotGetSDKList", e.Message);
             }
 
-            List<ITaskItem> outputItems = new List<ITaskItem>();
+            var outputItems = new List<ITaskItem>();
 
             if (installedSDKs != null && installedSDKs.Count > 0)
             {
@@ -189,7 +166,7 @@ public override bool Execute()
                     string sdkInfo = ResourceUtilities.FormatResourceString("GetInstalledSDKs.SDKNameAndLocation", sdk.Key, sdk.Value.Item1);
                     Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", sdkInfo);
 
-                    TaskItem item = new TaskItem(sdk.Value.Item1);
+                    var item = new TaskItem(sdk.Value.Item1);
                     item.SetMetadata("SDKName", sdk.Key);
                     item.SetMetadata("PlatformVersion", sdk.Value.Item2);
 
@@ -214,13 +191,12 @@ public override bool Execute()
             // We need to register an object so that at the end of the build we will clear the static toolLocationhelper caches.
             // this is important because if someone adds an SDK between builds we would not know about it and not be able to use it.
             // This code is mainly used to deal with the case where msbuild nodes hang around between builds.
-            IBuildEngine4 buildEngine4 = BuildEngine as IBuildEngine4;
-            if (buildEngine4 != null)
+            if (BuildEngine is IBuildEngine4 buildEngine4)
             {
                 object staticCacheDisposer = buildEngine4.GetRegisteredTaskObject(StaticSDKCacheKey, RegisteredTaskObjectLifetime.Build);
                 if (staticCacheDisposer == null)
                 {
-                    BuildCacheDisposeWrapper staticDisposer = new BuildCacheDisposeWrapper(new BuildCacheDisposeWrapper.CallDuringDispose(ToolLocationHelper.ClearSDKStaticCache));
+                    BuildCacheDisposeWrapper staticDisposer = new BuildCacheDisposeWrapper(ToolLocationHelper.ClearSDKStaticCache);
                     buildEngine4.RegisterTaskObject(StaticSDKCacheKey, staticDisposer, RegisteredTaskObjectLifetime.Build, allowEarlyCollection: false);
                 }
             }
diff --git a/src/Tasks/GetReferenceAssemblyPaths.cs b/src/Tasks/GetReferenceAssemblyPaths.cs
index 0bf16635354..0e2c8bd306e 100644
--- a/src/Tasks/GetReferenceAssemblyPaths.cs
+++ b/src/Tasks/GetReferenceAssemblyPaths.cs
@@ -5,11 +5,10 @@
 //-----------------------------------------------------------------------
 
 using System;
-using System.IO;
+using System.Collections.Generic;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
-using System.Collections.Generic;
+using Microsoft.Build.Utilities;
 using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
 using SystemProcessorArchitecture = System.Reflection.ProcessorArchitecture;
 
@@ -26,7 +25,7 @@ public class GetReferenceAssemblyPaths : TaskExtension
         /// This is the sentinel assembly for .NET FX 3.5 SP1
         /// Used to determine if SP1 of 3.5 is installed
         /// </summary>
-        private static readonly string s_NET35SP1SentinelAssemblyName = "System.Data.Entity, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL";
+        private const string NET35SP1SentinelAssemblyName = "System.Data.Entity, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL";
 
         /// <summary>
         /// Cache in a static whether or not we have found the 35sp1sentinel assembly.
@@ -44,24 +43,6 @@ public class GetReferenceAssemblyPaths : TaskExtension
         /// </summary>
         private IList<string> _tfmPathsNoProfile;
 
-        /// <summary>
-        /// Target framework moniker string passed into the task
-        /// </summary>
-        private string _targetFrameworkMoniker;
-
-        /// <summary>
-        /// The root path to use to generate the reference assemblyPaths
-        /// </summary>
-        private string _rootPath;
-
-        /// <summary>
-        /// By default GetReferenceAssemblyPaths performs simple checks
-        /// to ensure that certain runtime frameworks are installed depending on the
-        /// target framework.
-        /// set bypassFrameworkInstallChecks to true in order to bypass those checks.
-        /// </summary>
-        private bool _bypassFrameworkInstallChecks;
-
         #endregion
 
         #region Properties
@@ -77,7 +58,7 @@ public string[] ReferenceAssemblyPaths
             {
                 if (_tfmPaths != null)
                 {
-                    string[] pathsToReturn = new string[_tfmPaths.Count];
+                    var pathsToReturn = new string[_tfmPaths.Count];
                     _tfmPaths.CopyTo(pathsToReturn, 0);
                     return pathsToReturn;
                 }
@@ -113,34 +94,12 @@ public string[] FullFrameworkReferenceAssemblyPaths
         /// <summary>
         /// The target framework moniker to get the reference assembly paths for
         /// </summary>
-        public string TargetFrameworkMoniker
-        {
-            get
-            {
-                return _targetFrameworkMoniker;
-            }
-
-            set
-            {
-                _targetFrameworkMoniker = value;
-            }
-        }
+        public string TargetFrameworkMoniker { get; set; }
 
         /// <summary>
         /// The root path to use to generate the reference assembly path
         /// </summary>
-        public string RootPath
-        {
-            get
-            {
-                return _rootPath;
-            }
-
-            set
-            {
-                _rootPath = value;
-            }
-        }
+        public string RootPath { get; set; }
 
         /// <summary>
         /// By default GetReferenceAssemblyPaths performs simple checks
@@ -148,18 +107,7 @@ public string RootPath
         /// target framework.
         /// set BypassFrameworkInstallChecks to true in order to bypass those checks.
         /// </summary>        
-        public bool BypassFrameworkInstallChecks
-        {
-            get
-            {
-                return _bypassFrameworkInstallChecks;
-            }
-
-            set
-            {
-                _bypassFrameworkInstallChecks = value;
-            }
-        }
+        public bool BypassFrameworkInstallChecks { get; set; }
 
         /// <summary>
         /// If set to true, the task will not generate an error (or a warning) if the reference assemblies cannot be found.
@@ -171,11 +119,7 @@ public bool BypassFrameworkInstallChecks
         /// Gets the display name for the targetframeworkmoniker
         /// </summary>
         [Output]
-        public string TargetFrameworkMonikerDisplayName
-        {
-            get;
-            set;
-        }
+        public string TargetFrameworkMonikerDisplayName { get; set; }
 
         #endregion
 
@@ -186,11 +130,11 @@ public string TargetFrameworkMonikerDisplayName
         /// </summary>
         public override bool Execute()
         {
-            FrameworkNameVersioning moniker = null;
+            FrameworkNameVersioning moniker;
             FrameworkNameVersioning monikerWithNoProfile = null;
 
             // Are we targeting a profile. 
-            bool targetingProfile = false;
+            bool targetingProfile;
 
             try
             {
@@ -208,14 +152,14 @@ public override bool Execute()
                 // This is a very specific "hack" to ensure that when we're targeting certain .NET Framework versions that
                 // WPF gets to rely on .NET FX 3.5 SP1 being installed on the build machine.
                 // This only needs to occur when we are targeting a .NET FX prior to v4.0
-                if (!_bypassFrameworkInstallChecks && moniker.Identifier.Equals(".NETFramework", StringComparison.OrdinalIgnoreCase) &&
+                if (!BypassFrameworkInstallChecks && moniker.Identifier.Equals(".NETFramework", StringComparison.OrdinalIgnoreCase) &&
                     moniker.Version.Major < 4)
                 {
                     // We have not got a value for whether or not the 35 sentinel assembly has been found
                     if (!s_net35SP1SentinelAssemblyFound.HasValue)
                     {
                         // get an assemblyname from the string representation of the sentinel assembly name
-                        AssemblyNameExtension sentinelAssemblyName = new AssemblyNameExtension(s_NET35SP1SentinelAssemblyName);
+                        var sentinelAssemblyName = new AssemblyNameExtension(NET35SP1SentinelAssemblyName);
 
                         string path = GlobalAssemblyCache.GetLocation(sentinelAssemblyName, SystemProcessorArchitecture.MSIL, runtimeVersion => "v2.0.50727", new Version("2.0.57027"), false, new FileExists(FileUtilities.FileExistsNoThrow), GlobalAssemblyCache.pathFromFusionName, GlobalAssemblyCache.gacEnumerator, false);
                         s_net35SP1SentinelAssemblyFound = !String.IsNullOrEmpty(path);
@@ -237,7 +181,7 @@ public override bool Execute()
 
             try
             {
-                _tfmPaths = GetPaths(_rootPath, moniker);
+                _tfmPaths = GetPaths(RootPath, moniker);
 
                 if (_tfmPaths != null && _tfmPaths.Count > 0)
                 {
@@ -248,7 +192,7 @@ public override bool Execute()
                 // There is no point in generating the full framework paths if profile path could not be found.
                 if (targetingProfile && _tfmPaths != null)
                 {
-                    _tfmPathsNoProfile = GetPaths(_rootPath, monikerWithNoProfile);
+                    _tfmPathsNoProfile = GetPaths(RootPath, monikerWithNoProfile);
                 }
 
                 // The path with out the profile is just the reference assembly paths.
@@ -280,16 +224,9 @@ public override bool Execute()
         /// </summary>
         private IList<String> GetPaths(string rootPath, FrameworkNameVersioning frameworkmoniker)
         {
-            IList<String> pathsToReturn = null;
-
-            if (String.IsNullOrEmpty(rootPath))
-            {
-                pathsToReturn = ToolLocationHelper.GetPathToReferenceAssemblies(frameworkmoniker);
-            }
-            else
-            {
-                pathsToReturn = ToolLocationHelper.GetPathToReferenceAssemblies(rootPath, frameworkmoniker);
-            }
+            IList<string> pathsToReturn = String.IsNullOrEmpty(rootPath) ?
+                ToolLocationHelper.GetPathToReferenceAssemblies(frameworkmoniker) :
+                ToolLocationHelper.GetPathToReferenceAssemblies(rootPath, frameworkmoniker);
 
             if (!SuppressNotFoundError)
             {
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index ce56c3042b0..b4e22251e24 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -30,52 +30,32 @@ public class GetSDKReferenceFiles : TaskExtension
         /// <summary>
         /// Set of resolvedSDK references which we will use to find the reference assemblies.
         /// </summary>
-        private ITaskItem[] _resolvedSDKReferences = Array.Empty<TaskItem>();
-
-        /// <summary>
-        /// Set of the redist files for the resolved sdks
-        /// </summary>
-        private ITaskItem[] _sdkRedistFiles = Array.Empty<TaskItem>();
-
-        /// <summary>
-        /// Resolved reference assemblies from the SDK
-        /// </summary>
-        private ITaskItem[] _references = Array.Empty<TaskItem>();
-
-        /// <summary>
-        /// Redist files from the SDKs
-        /// </summary>
-        private ITaskItem[] _redistFiles = Array.Empty<TaskItem>();
+        private ITaskItem[] _resolvedSDKReferences = Array.Empty<ITaskItem>();
 
         /// <summary>
         /// Set of resolved reference assemblies. This removes any duplicate ones between sdks.
         /// </summary>
-        private HashSet<ResolvedReferenceAssembly> _resolvedReferences = new HashSet<ResolvedReferenceAssembly>();
+        private readonly HashSet<ResolvedReferenceAssembly> _resolvedReferences = new HashSet<ResolvedReferenceAssembly>();
 
         /// <summary>
         /// Set of resolved reference assemblies. This removes any duplicate ones between sdks.
         /// </summary>
-        private HashSet<ResolvedRedistFile> _resolveRedistFiles = new HashSet<ResolvedRedistFile>();
-
-        /// <summary>
-        /// Files to be copied locally
-        /// </summary>
-        private ITaskItem[] _copyLocalFiles = Array.Empty<TaskItem>();
+        private readonly HashSet<ResolvedRedistFile> _resolveRedistFiles = new HashSet<ResolvedRedistFile>();
 
         /// <summary>
         /// Set of reference assembly extensions to look for.
         /// </summary>
-        private string[] _referenceExtensions = new string[] { ".winmd", ".dll" };
+        private string[] _referenceExtensions = { ".winmd", ".dll" };
 
         /// <summary>
         /// Dictionary of SDK Identity to the cache file that contains the file information for it.
         /// </summary>
-        private ConcurrentDictionary<string, SDKInfo> _cacheFileForSDKs = new ConcurrentDictionary<string, SDKInfo>(StringComparer.OrdinalIgnoreCase);
+        private readonly ConcurrentDictionary<string, SDKInfo> _cacheFileForSDKs = new ConcurrentDictionary<string, SDKInfo>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// Set of exceptions which were thrown while reading or writing to the cache file, this needs to be thread safe since TPL code will add exceptions into this structure at the same time.
         /// </summary>
-        private ConcurrentQueue<string> _exceptions = new ConcurrentQueue<string>();
+        private readonly ConcurrentQueue<string> _exceptions = new ConcurrentQueue<string>();
 
         /// <summary>
         /// Delegate to get the assembly name
@@ -118,14 +98,11 @@ public GetSDKReferenceFiles()
         /// </summary>
         public string CacheFileFolderPath
         {
-            get
-            {
-                return _cacheFilePath;
-            }
+            get => _cacheFilePath;
 
             set
             {
-                ErrorUtilities.VerifyThrowArgumentNull(value, "CacheFileFolderPath");
+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(CacheFileFolderPath));
                 _cacheFilePath = value;
             }
         }
@@ -135,14 +112,11 @@ public string CacheFileFolderPath
         /// </summary>
         public ITaskItem[] ResolvedSDKReferences
         {
-            get
-            {
-                return _resolvedSDKReferences;
-            }
+            get => _resolvedSDKReferences;
 
             set
             {
-                ErrorUtilities.VerifyThrowArgumentNull(value, "ResolvedSDKReferences");
+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(ResolvedSDKReferences));
                 _resolvedSDKReferences = value;
             }
         }
@@ -153,14 +127,11 @@ public ITaskItem[] ResolvedSDKReferences
         /// </summary>
         public string[] ReferenceExtensions
         {
-            get
-            {
-                return _referenceExtensions;
-            }
+            get => _referenceExtensions;
 
             set
             {
-                ErrorUtilities.VerifyThrowArgumentNull(value, "ReferenceExtensions");
+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(ReferenceExtensions));
                 _referenceExtensions = value;
             }
         }
@@ -169,84 +140,51 @@ public string[] ReferenceExtensions
         /// Should the references found as part of resolving the sdk be logged.
         /// The default is true
         /// </summary>
-        public bool LogReferencesList
-        {
-            get;
-            set;
-        }
+        public bool LogReferencesList { get; set; }
 
         /// <summary>
         /// Should the redist files found as part of resolving the sdk be logged.
         /// The default is true
         /// </summary>
-        public bool LogRedistFilesList
-        {
-            get;
-            set;
-        }
+        public bool LogRedistFilesList { get; set; }
 
         /// <summary>
         /// The targetted SDK identifier.
         /// </summary>
-        public string TargetSDKIdentifier
-        {
-            get;
-            set;
-        }
+        public string TargetSDKIdentifier { get; set; }
 
         /// <summary>
         /// The targeted SDK version.
         /// </summary>
-        public string TargetSDKVersion
-        {
-            get;
-            set;
-        }
+        public string TargetSDKVersion { get; set; }
 
         /// <summary>
         /// The targetted platform identifier.
         /// </summary>
-        public string TargetPlatformIdentifier
-        {
-            get;
-            set;
-        }
+        public string TargetPlatformIdentifier { get; set; }
 
         /// <summary>
         /// The targeted platform version.
         /// </summary>
-        public string TargetPlatformVersion
-        {
-            get;
-            set;
-        }
+        public string TargetPlatformVersion { get; set; }
 
         /// <summary>
         /// Resolved reference items.
         /// </summary>
         [Output]
-        public ITaskItem[] References
-        {
-            get { return _references; }
-        }
+        public ITaskItem[] References { get; private set; } = Array.Empty<ITaskItem>();
 
         /// <summary>
         /// Resolved redist files.
         /// </summary>
         [Output]
-        public ITaskItem[] RedistFiles
-        {
-            get { return _redistFiles; }
-        }
+        public ITaskItem[] RedistFiles { get; private set; } = Array.Empty<ITaskItem>();
 
         /// <summary>
         /// Files that need to be copied locally, this is the reference assemblies and the xml intellisense files.
         /// </summary>
         [Output]
-        public ITaskItem[] CopyLocalFiles
-        {
-            get { return _copyLocalFiles; }
-        }
+        public ITaskItem[] CopyLocalFiles { get; private set; } = Array.Empty<ITaskItem>();
 
         /// <summary>
         /// Should conflicts between redist files within an SDK be logged as a message or a warning.
@@ -254,22 +192,14 @@ public ITaskItem[] CopyLocalFiles
         /// </summary>
         [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "SDKAs", Justification = "Shipped this way in Dev11 Beta (go-live)")]
         [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "SDKAs", Justification = "SDK and As are two different words")]
-        public bool LogRedistConflictWithinSDKAsWarning
-        {
-            get;
-            set;
-        }
+        public bool LogRedistConflictWithinSDKAsWarning { get; set; }
 
         /// <summary>
         /// Should conflicts between redist files across different referenced SDKs be logged as a message or a warning.
         /// The default is to log them as a warning.
         /// </summary>
         [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "SDKs", Justification = "Shipped this way in Dev11 Beta (go-live)")]
-        public bool LogRedistConflictBetweenSDKsAsWarning
-        {
-            get;
-            set;
-        }
+        public bool LogRedistConflictBetweenSDKsAsWarning { get; set; }
 
         /// <summary>
         /// Should conflicts between reference files within an SDK be logged as a message or a warning.
@@ -277,31 +207,19 @@ public bool LogRedistConflictBetweenSDKsAsWarning
         /// </summary>
         [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "SDKAs", Justification = "Shipped this way in Dev11 Beta (go-live)")]
         [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "SDKAs", Justification = "SDK and As are two different words")]
-        public bool LogReferenceConflictWithinSDKAsWarning
-        {
-            get;
-            set;
-        }
+        public bool LogReferenceConflictWithinSDKAsWarning { get; set; }
 
         /// <summary>
         /// Should conflicts between reference files across different referenced SDKs be logged as a message or a warning.
         /// The default is to log them as a warning.
         /// </summary>
         [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "SDKs", Justification = "Shipped this way in Dev11 Beta (go-live)")]
-        public bool LogReferenceConflictBetweenSDKsAsWarning
-        {
-            get;
-            set;
-        }
+        public bool LogReferenceConflictBetweenSDKsAsWarning { get; set; }
 
         /// <summary>
         /// Should we log exceptions which were hit when the cache file is being read and written to
         /// </summary>
-        public bool LogCacheFileExceptions
-        {
-            get;
-            set;
-        }
+        public bool LogCacheFileExceptions { get; set; }
         #endregion
 
         /// <summary>
@@ -309,7 +227,7 @@ public bool LogCacheFileExceptions
         /// </summary>
         public override bool Execute()
         {
-            return Execute(new GetAssemblyName(AssemblyNameExtension.GetAssemblyNameEx), new GetAssemblyRuntimeVersion(AssemblyInformation.GetRuntimeVersion), new FileExists(FileUtilities.FileExistsNoThrow));
+            return Execute(AssemblyNameExtension.GetAssemblyNameEx, AssemblyInformation.GetRuntimeVersion, FileUtilities.FileExistsNoThrow);
         }
 
         /// <summary>
@@ -383,7 +301,7 @@ internal bool Execute(GetAssemblyName getAssemblyName, GetAssemblyRuntimeVersion
         private void FindRedistFiles(ITaskItem resolvedSDKReference, string sdkIdentity, string targetedConfiguration, string targetedArchitecture)
         {
             // Gather the redist files, order is important because we want the most specific match of config and architecture to be the file that returns if there is a collision in destination paths
-            HashSet<ResolvedRedistFile> resolvedRedistFileSet = new HashSet<ResolvedRedistFile>();
+            var resolvedRedistFileSet = new HashSet<ResolvedRedistFile>();
             IList<string> redistPaths = new List<string>();
 
             if (targetedConfiguration.Length > 0 && targetedArchitecture.Length > 0)
@@ -399,8 +317,7 @@ private void FindRedistFiles(ITaskItem resolvedSDKReference, string sdkIdentity,
                 }
             }
 
-            SDKInfo sdkCacheInfo = null;
-            if (_cacheFileForSDKs.TryGetValue(sdkIdentity, out sdkCacheInfo) && sdkCacheInfo != null)
+            if (_cacheFileForSDKs.TryGetValue(sdkIdentity, out SDKInfo sdkCacheInfo) && sdkCacheInfo != null)
             {
                 foreach (string path in redistPaths)
                 {
@@ -422,7 +339,7 @@ private void FindRedistFiles(ITaskItem resolvedSDKReference, string sdkIdentity,
                 }
                 else
                 {
-                    ResolvedRedistFile winner = _resolveRedistFiles.First<ResolvedRedistFile>(x => x.Equals(redist));
+                    ResolvedRedistFile winner = _resolveRedistFiles.First(x => x.Equals(redist));
 
                     if (!LogRedistConflictBetweenSDKsAsWarning)
                     {
@@ -442,18 +359,16 @@ private void FindRedistFiles(ITaskItem resolvedSDKReference, string sdkIdentity,
         /// </summary>
         private void FindReferences(ITaskItem resolvedSDKReference, string sdkIdentity, string sdkName, string rootDirectory, string targetedConfiguration, string targetedArchitecture)
         {
-            bool expandSDK = false;
-
-            if (bool.TryParse(resolvedSDKReference.GetMetadata("ExpandReferenceAssemblies"), out expandSDK) && expandSDK)
+            if (bool.TryParse(resolvedSDKReference.GetMetadata("ExpandReferenceAssemblies"), out bool expandSDK) && expandSDK)
             {
                 Log.LogMessageFromResources("GetSDKReferenceFiles.GetSDKReferences", sdkName, rootDirectory);
 
                 // Gather the reference assemblies, order is important because we want the most specific match of config and architecture to be searched for last
                 // so it can overwrite any less specific matches.
-                HashSet<ResolvedReferenceAssembly> resolvedReferenceAssemblies = new HashSet<ResolvedReferenceAssembly>();
+                var resolvedReferenceAssemblies = new HashSet<ResolvedReferenceAssembly>();
 
                 // If the SDK is manifest driven we want to grab them from the ApiContracts in the manifest if possible- will only happen if TargetSdk is identified
-                string[] manifestReferencePaths = this.GetReferencePathsFromManifest(resolvedSDKReference);
+                string[] manifestReferencePaths = GetReferencePathsFromManifest(resolvedSDKReference);
 
                 if (manifestReferencePaths != null && manifestReferencePaths.Length > 0)
                 {
@@ -466,8 +381,7 @@ private void FindReferences(ITaskItem resolvedSDKReference, string sdkIdentity,
                 else if (targetedConfiguration.Length > 0 && targetedArchitecture.Length > 0)
                 {
                     // Couldn't find any valid ApiContracts, look up references the traditional way
-                    IList<string> referencePaths = new List<string>();
-                    referencePaths = ToolLocationHelper.GetSDKReferenceFolders(resolvedSDKReference.ItemSpec, targetedConfiguration, targetedArchitecture);
+                    IList<string> referencePaths = ToolLocationHelper.GetSDKReferenceFolders(resolvedSDKReference.ItemSpec, targetedConfiguration, targetedArchitecture);
 
                     if (LogReferencesList)
                     {
@@ -477,8 +391,7 @@ private void FindReferences(ITaskItem resolvedSDKReference, string sdkIdentity,
                         }
                     }
 
-                    SDKInfo sdkCacheInfo = null;
-                    if (_cacheFileForSDKs.TryGetValue(sdkIdentity, out sdkCacheInfo) && sdkCacheInfo != null)
+                    if (_cacheFileForSDKs.TryGetValue(sdkIdentity, out SDKInfo sdkCacheInfo) && sdkCacheInfo != null)
                     {
                         foreach (string path in referencePaths)
                         {
@@ -507,7 +420,7 @@ private void FindReferences(ITaskItem resolvedSDKReference, string sdkIdentity,
                             continue;
                         }
 
-                        ResolvedReferenceAssembly winner = _resolvedReferences.First<ResolvedReferenceAssembly>(x => x.Equals(reference));
+                        ResolvedReferenceAssembly winner = _resolvedReferences.First(x => x.Equals(reference));
 
                         if (!LogReferenceConflictBetweenSDKsAsWarning)
                         {
@@ -533,13 +446,13 @@ private void FindReferences(ITaskItem resolvedSDKReference, string sdkIdentity,
         /// </summary>
         private void GenerateOutputItems()
         {
-            List<ITaskItem> resolvedReferenceAssemblies = new List<ITaskItem>();
-            List<ITaskItem> copyLocalReferenceAssemblies = new List<ITaskItem>();
-            List<ITaskItem> redistReferenceItems = new List<ITaskItem>();
+            var resolvedReferenceAssemblies = new List<ITaskItem>();
+            var copyLocalReferenceAssemblies = new List<ITaskItem>();
+            var redistReferenceItems = new List<ITaskItem>();
 
             foreach (ResolvedReferenceAssembly reference in _resolvedReferences)
             {
-                ITaskItem outputItem = new TaskItem(reference.AssemblyLocation);
+                var outputItem = new TaskItem(reference.AssemblyLocation);
                 resolvedReferenceAssemblies.Add(outputItem);
 
                 if (outputItem.GetMetadata(ItemMetadataNames.msbuildReferenceSourceTarget).Length == 0)
@@ -557,18 +470,16 @@ private void GenerateOutputItems()
                 outputItem.SetMetadata("SDKRootPath", reference.SDKReferenceItem.ItemSpec);
                 outputItem.SetMetadata("ResolvedFrom", "GetSDKReferenceFiles");
 
-                SDKInfo sdkInfo = null;
-                if (_cacheFileForSDKs.TryGetValue(sdkIdentity, out sdkInfo) && sdkInfo != null)
+                if (_cacheFileForSDKs.TryGetValue(sdkIdentity, out SDKInfo sdkInfo) && sdkInfo != null)
                 {
-                    SdkReferenceInfo referenceInfo = null;
-                    if (sdkInfo.PathToReferenceMetadata != null && sdkInfo.PathToReferenceMetadata.TryGetValue(reference.AssemblyLocation, out referenceInfo))
+                    if (sdkInfo.PathToReferenceMetadata != null && sdkInfo.PathToReferenceMetadata.TryGetValue(reference.AssemblyLocation, out SdkReferenceInfo referenceInfo))
                     {
-                        if (referenceInfo != null && referenceInfo.FusionName != null)
+                        if (referenceInfo?.FusionName != null)
                         {
                             outputItem.SetMetadata(ItemMetadataNames.fusionName, referenceInfo.FusionName);
                         }
 
-                        if (referenceInfo != null && referenceInfo.ImageRuntime != null)
+                        if (referenceInfo?.ImageRuntime != null)
                         {
                             outputItem.SetMetadata(ItemMetadataNames.imageRuntime, referenceInfo.ImageRuntime);
                         }
@@ -604,7 +515,7 @@ private void GenerateOutputItems()
 
                     if (FileUtilities.FileExistsNoThrow(xmlFile))
                     {
-                        ITaskItem item = new TaskItem(xmlFile);
+                        var item = new TaskItem(xmlFile);
 
                         // Add the related item.
                         copyLocalReferenceAssemblies.Add(item);
@@ -619,12 +530,12 @@ private void GenerateOutputItems()
             resolvedReferenceAssemblies.Sort(TaskItemSpecFilenameComparer.GenericComparer);
             copyLocalReferenceAssemblies.Sort(TaskItemSpecFilenameComparer.GenericComparer);
 
-            _references = resolvedReferenceAssemblies.ToArray();
-            _copyLocalFiles = copyLocalReferenceAssemblies.ToArray();
+            References = resolvedReferenceAssemblies.ToArray();
+            CopyLocalFiles = copyLocalReferenceAssemblies.ToArray();
 
             foreach (ResolvedRedistFile file in _resolveRedistFiles)
             {
-                ITaskItem outputItem = new TaskItem(file.RedistFile);
+                var outputItem = new TaskItem(file.RedistFile);
 
                 if (outputItem.GetMetadata(ItemMetadataNames.msbuildReferenceSourceTarget).Length == 0)
                 {
@@ -648,7 +559,7 @@ private void GenerateOutputItems()
             }
 
             redistReferenceItems.Sort(TaskItemSpecFilenameComparer.GenericComparer);
-            _redistFiles = redistReferenceItems.ToArray();
+            RedistFiles = redistReferenceItems.ToArray();
         }
 
         /// <summary>
@@ -656,10 +567,9 @@ private void GenerateOutputItems()
         /// </summary>
         private void GatherReferenceAssemblies(HashSet<ResolvedReferenceAssembly> resolvedFiles, ITaskItem sdkReference, string path, SDKInfo info)
         {
-            List<string> referenceFiles = null;
-            if (info.DirectoryToFileList != null && info.DirectoryToFileList.TryGetValue(FileUtilities.EnsureNoTrailingSlash(path), out referenceFiles) && referenceFiles != null)
+            if (info.DirectoryToFileList != null && info.DirectoryToFileList.TryGetValue(FileUtilities.EnsureNoTrailingSlash(path), out List<string> referenceFiles) && referenceFiles != null)
             {
-                foreach (var file in referenceFiles)
+                foreach (string file in referenceFiles)
                 {
                     // We only want to find files which match the extensions the user has asked for, this will usually be dll or winmd.
                     bool matchesExtension = false;
@@ -678,11 +588,11 @@ private void GatherReferenceAssemblies(HashSet<ResolvedReferenceAssembly> resolv
                         continue;
                     }
 
-                    ResolvedReferenceAssembly resolvedReference = new ResolvedReferenceAssembly(sdkReference, file);
+                    var resolvedReference = new ResolvedReferenceAssembly(sdkReference, file);
                     bool success = resolvedFiles.Add(resolvedReference);
                     if (!success)
                     {
-                        ResolvedReferenceAssembly winner = resolvedFiles.First<ResolvedReferenceAssembly>(x => x.Equals(resolvedReference));
+                        ResolvedReferenceAssembly winner = resolvedFiles.First(x => x.Equals(resolvedReference));
 
                         if (!LogReferenceConflictWithinSDKAsWarning)
                         {
@@ -719,10 +629,10 @@ private void GatherRedistFiles(HashSet<ResolvedRedistFile> resolvedRedistFiles,
                             string relativeToBase = FileUtilities.MakeRelative(redistFilePath, file);
                             string targetPath = Path.Combine(targetPathRoot, relativeToBase);
 
-                            ResolvedRedistFile redistFile = new ResolvedRedistFile(sdkReference, file, targetPath, targetPathRoot);
+                            var redistFile = new ResolvedRedistFile(sdkReference, file, targetPath, targetPathRoot);
                             if (!resolvedRedistFiles.Add(redistFile))
                             {
-                                ResolvedRedistFile winner = resolvedRedistFiles.First<ResolvedRedistFile>(x => x.Equals(redistFile));
+                                ResolvedRedistFile winner = resolvedRedistFiles.First(x => x.Equals(redistFile));
 
                                 if (!LogRedistConflictWithinSDKAsWarning)
                                 {
@@ -745,7 +655,7 @@ private void GatherRedistFiles(HashSet<ResolvedRedistFile> resolvedRedistFiles,
         /// </summary>
         private void PopulateReferencesForSDK(IEnumerable<ITaskItem> sdks)
         {
-            SDKFilesCache sdkFilesCache = new SDKFilesCache(_exceptions, _cacheFilePath, _getAssemblyName, _getRuntimeVersion, _fileExists);
+            var sdkFilesCache = new SDKFilesCache(_exceptions, _cacheFilePath, _getAssemblyName, _getRuntimeVersion, _fileExists);
 
             // Go through each sdk which has been resolved in this project
             foreach (ITaskItem sdk in sdks)
@@ -759,11 +669,11 @@ private void PopulateReferencesForSDK(IEnumerable<ITaskItem> sdks)
 
                 if (info == null || !sdkFilesCache.IsAssemblyListCacheFileUpToDate(sdkIdentity, sdkRoot, _cacheFilePath))
                 {
-                    info = sdkFilesCache.GetCacheFileInfoFromSDK(sdkIdentity, sdkRoot, this.GetReferencePathsFromManifest(sdk));
+                    info = sdkFilesCache.GetCacheFileInfoFromSDK(sdkIdentity, sdkRoot, GetReferencePathsFromManifest(sdk));
 
                     // On a background thread save the file to disk
-                    SaveContext saveContext = new SaveContext(sdkIdentity, sdkRoot, info);
-                    ThreadPool.QueueUserWorkItem(new WaitCallback(sdkFilesCache.SaveAssemblyListToCacheFile), saveContext);
+                    var saveContext = new SaveContext(sdkIdentity, sdkRoot, info);
+                    ThreadPool.QueueUserWorkItem(sdkFilesCache.SaveAssemblyListToCacheFile, saveContext);
                 }
 
                 _cacheFileForSDKs.TryAdd(sdkIdentity, info);
@@ -802,7 +712,7 @@ private class ResolvedReferenceAssembly : IEquatable<ResolvedReferenceAssembly>
             /// <summary>
             ///  Is the reference copy local
             /// </summary>
-            private bool _copyLocal = false;
+            private readonly bool _copyLocal;
 
             /// <summary>
             /// Constructor
@@ -816,50 +726,31 @@ public ResolvedReferenceAssembly(ITaskItem sdkReferenceItem, string assemblyLoca
             }
 
             /// <summary>
-            ///  What is the file name
+            /// What is the file name
             /// </summary>
-            public string FileName
-            {
-                get;
-                private set;
-            }
+            private string FileName { get; }
 
             /// <summary>
             /// What is the location of the assembly on disk.
             /// </summary>
-            public string AssemblyLocation
-            {
-                get;
-                private set;
-            }
+            public string AssemblyLocation { get; }
 
             /// <summary>
             /// Is the assembly copy local or not.
             /// </summary>
-            public bool CopyLocal
-            {
-                get
-                {
-                    return _copyLocal;
-                }
-            }
+            public bool CopyLocal => _copyLocal;
 
             /// <summary>
             /// Original resolved SDK reference item passed in.
             /// </summary>
-            public ITaskItem SDKReferenceItem
-            {
-                get;
-                private set;
-            }
+            public ITaskItem SDKReferenceItem { get; }
 
             /// <summary>
             /// Override object equals to use the equals redist in this object.
             /// </summary>
             public override bool Equals(object obj)
             {
-                ResolvedReferenceAssembly reference = obj as ResolvedReferenceAssembly;
-                if (reference == null)
+                if (!(obj is ResolvedReferenceAssembly reference))
                 {
                     return false;
                 }
@@ -885,7 +776,7 @@ public bool Equals(ResolvedReferenceAssembly other)
                     return false;
                 }
 
-                if (Object.ReferenceEquals(other, this))
+                if (ReferenceEquals(other, this))
                 {
                     return true;
                 }
@@ -893,7 +784,7 @@ public bool Equals(ResolvedReferenceAssembly other)
                 // We only care about the file name and not the path because if they have the same file name but different paths then they will likely contain
                 // the same namespaces and the compiler does not like to have two references with the same namespace passed at once without aliasing and 
                 // we have no way to do aliasing per assembly since we are grabbing a bunch of files at once.)
-                return String.Equals(this.FileName, other.FileName, StringComparison.OrdinalIgnoreCase);
+                return String.Equals(FileName, other.FileName, StringComparison.OrdinalIgnoreCase);
             }
         }
 
@@ -916,46 +807,29 @@ public ResolvedRedistFile(ITaskItem sdkReferenceItem, string redistFile, string
             /// <summary>
             ///  What is the file name
             /// </summary>
-            public string RedistFile
-            {
-                get;
-                private set;
-            }
+            public string RedistFile { get; }
 
             /// <summary>
             /// What is the targetPath for the redist file.
             /// </summary>
-            public string TargetPath
-            {
-                get;
-                private set;
-            }
+            public string TargetPath { get; }
 
             /// <summary>
             /// What is the root directory of the target path
             /// </summary>
-            public string TargetRoot
-            {
-                get;
-                private set;
-            }
+            public string TargetRoot { get; }
 
             /// <summary>
             /// Original resolved SDK reference item passed in.
             /// </summary>
-            public ITaskItem SDKReferenceItem
-            {
-                get;
-                private set;
-            }
+            public ITaskItem SDKReferenceItem { get; }
 
             /// <summary>
             /// Override object equals to use the equals redist in this object.
             /// </summary>
             public override bool Equals(object obj)
             {
-                ResolvedReferenceAssembly reference = obj as ResolvedReferenceAssembly;
-                if (reference == null)
+                if (!(obj is ResolvedReferenceAssembly reference))
                 {
                     return false;
                 }
@@ -981,14 +855,14 @@ public bool Equals(ResolvedRedistFile other)
                     return false;
                 }
 
-                if (Object.ReferenceEquals(other, this))
+                if (ReferenceEquals(other, this))
                 {
                     return true;
                 }
 
                 // We only care about the target path since that is the location relative to the package root where the redist file
                 // will be copied.
-                return String.Equals(this.TargetPath, other.TargetPath, StringComparison.OrdinalIgnoreCase);
+                return String.Equals(TargetPath, other.TargetPath, StringComparison.OrdinalIgnoreCase);
             }
         }
 
@@ -1002,27 +876,27 @@ private class SDKFilesCache
             /// <summary>
             ///  Thread-safe queue which contains exceptions throws during cache file reading and writing.
             /// </summary>
-            private ConcurrentQueue<string> _exceptionMessages;
+            private readonly ConcurrentQueue<string> _exceptionMessages;
 
             /// <summary>
             /// Delegate to get the assembly name
             /// </summary>
-            private GetAssemblyName _getAssemblyName;
+            private readonly GetAssemblyName _getAssemblyName;
 
             /// <summary>
             /// Get the image runtime version from a afile
             /// </summary>
-            private GetAssemblyRuntimeVersion _getRuntimeVersion;
+            private readonly GetAssemblyRuntimeVersion _getRuntimeVersion;
 
             /// <summary>
             /// File exists delegate
             /// </summary>
-            private FileExists _fileExists;
+            private readonly FileExists _fileExists;
 
             /// <summary>
             /// Location for the cache files to be written to
             /// </summary>
-            private string _cacheFileDirectory;
+            private readonly string _cacheFileDirectory;
 
             /// <summary>
             /// Constructor
@@ -1041,7 +915,7 @@ internal SDKFilesCache(ConcurrentQueue<string> exceptionQueue, string cacheFileD
             /// </summary>
             internal SDKInfo LoadAssemblyListFromCacheFile(string sdkIdentity, string sdkRoot)
             {
-                var cacheFile = Directory.GetFiles(_cacheFileDirectory, GetCacheFileName(sdkIdentity, sdkRoot, "*")).FirstOrDefault();
+                string cacheFile = Directory.EnumerateFiles(_cacheFileDirectory, GetCacheFileName(sdkIdentity, sdkRoot, "*")).FirstOrDefault();
 
                 try
                 {
@@ -1097,8 +971,8 @@ internal void SaveAssemblyListToCacheFile(object data)
                         }
                     }
 
-                    BinaryFormatter formatter = new BinaryFormatter();
-                    using (FileStream fs = new FileStream(referencesCacheFile, FileMode.Create))
+                    var formatter = new BinaryFormatter();
+                    using (var fs = new FileStream(referencesCacheFile, FileMode.Create))
                     {
                         formatter.Serialize(fs, cacheFileInfo);
                     }
@@ -1120,10 +994,10 @@ internal void SaveAssemblyListToCacheFile(object data)
             /// </summary>
             internal SDKInfo GetCacheFileInfoFromSDK(string sdkIdentity, string sdkRootDirectory, string[] sdkManifestReferences)
             {
-                ConcurrentDictionary<string, SdkReferenceInfo> references = new ConcurrentDictionary<string, SdkReferenceInfo>(StringComparer.OrdinalIgnoreCase);
-                ConcurrentDictionary<string, List<string>> directoryToFileList = new ConcurrentDictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
+                var references = new ConcurrentDictionary<string, SdkReferenceInfo>(StringComparer.OrdinalIgnoreCase);
+                var directoryToFileList = new ConcurrentDictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
 
-                List<string> directoriesToHash = new List<string>();
+                var directoriesToHash = new List<string>();
 
                 var referenceDirectories = GetAllReferenceDirectories(sdkRootDirectory);
                 var redistDirectories = GetAllRedistDirectories(sdkRootDirectory);
@@ -1143,14 +1017,14 @@ internal SDKInfo GetCacheFileInfoFromSDK(string sdkIdentity, string sdkRootDirec
 
                 PopulateRedistDictionaryFromPaths(directoryToFileList, redistDirectories);
 
-                SDKInfo cacheInfo = new SDKInfo(references, directoryToFileList, FileUtilities.GetHexHash(sdkIdentity), FileUtilities.GetPathsHash(directoriesToHash));
+                var cacheInfo = new SDKInfo(references, directoryToFileList, FileUtilities.GetHexHash(sdkIdentity), FileUtilities.GetPathsHash(directoriesToHash));
                 return cacheInfo;
             }
 
             /// <summary>
             /// Populate an existing assembly dictionary for the given framework moniker utilizing provided manifest reference information
             /// </summary>
-            internal void PopulateReferencesDictionaryFromManifestPaths(ConcurrentDictionary<string, List<string>> referencesByDirectory, ConcurrentDictionary<string, SdkReferenceInfo> references, string[] sdkManifestReferences)
+            private void PopulateReferencesDictionaryFromManifestPaths(ConcurrentDictionary<string, List<string>> referencesByDirectory, ConcurrentDictionary<string, SdkReferenceInfo> references, string[] sdkManifestReferences)
             {
                 // Sort by directory
                 var groupedByDirectory =
@@ -1162,37 +1036,37 @@ from reference in sdkManifestReferences
                     referencesByDirectory.TryAdd(group.Key, group.ToList());
                 }
 
-                Parallel.ForEach<string>(sdkManifestReferences, reference => { references.TryAdd(reference, GetSDKReferenceInfo(reference)); });
+                Parallel.ForEach(sdkManifestReferences, reference => { references.TryAdd(reference, GetSDKReferenceInfo(reference)); });
             }
 
             /// <summary>
             /// Populate an existing assembly dictionary for the given framework moniker
             /// </summary>
-            internal void PopulateReferencesDictionaryFromPaths(ConcurrentDictionary<string, List<string>> referencesByDirectory, ConcurrentDictionary<string, SdkReferenceInfo> references, IEnumerable<string> referenceDirectories)
+            private void PopulateReferencesDictionaryFromPaths(ConcurrentDictionary<string, List<string>> referencesByDirectory, ConcurrentDictionary<string, SdkReferenceInfo> references, IEnumerable<string> referenceDirectories)
             {
                 // Add each folder to the dictionary along with a list of all of files inside of it
-                Parallel.ForEach<string>(
+                Parallel.ForEach(
                 referenceDirectories,
                 path =>
                 {
                     List<string> files = Directory.GetFiles(path, "*", SearchOption.TopDirectoryOnly).ToList<string>();
                     referencesByDirectory.TryAdd(path, files);
 
-                    Parallel.ForEach<string>(files, filePath => { references.TryAdd(filePath, GetSDKReferenceInfo(filePath)); });
+                    Parallel.ForEach(files, filePath => { references.TryAdd(filePath, GetSDKReferenceInfo(filePath)); });
                 });
             }
 
             /// <summary>
             /// Populate an existing assembly dictionary for the given framework moniker
             /// </summary>
-            internal void PopulateRedistDictionaryFromPaths(ConcurrentDictionary<string, List<string>> redistFilesByDirectory, IEnumerable<string> redistDirectories)
+            private static void PopulateRedistDictionaryFromPaths(ConcurrentDictionary<string, List<string>> redistFilesByDirectory, IEnumerable<string> redistDirectories)
             {
                 // Add each folder to the dictionary along with a list of all of files inside of it
-                Parallel.ForEach<string>(
+                Parallel.ForEach(
                 redistDirectories,
                 path =>
                 {
-                    List<string> files = Directory.GetFiles(path, "*", SearchOption.TopDirectoryOnly).ToList<string>();
+                    List<string> files = Directory.GetFiles(path, "*", SearchOption.TopDirectoryOnly).ToList();
                     redistFilesByDirectory.TryAdd(path, files);
                 });
             }
@@ -1205,7 +1079,7 @@ internal void PopulateRedistDictionaryFromPaths(ConcurrentDictionary<string, Lis
             internal bool IsAssemblyListCacheFileUpToDate(string sdkIdentity, string sdkRoot, string cacheFileFolder)
             {
                 // The hash is the hash of last modified times for the passed in reference paths. A directory gets modified if a file is added, deleted, or modified  inside of the inside of the directory itself (modifications to child folders are not seen however).
-                List<string> directoriesToHash = new List<string>();
+                var directoriesToHash = new List<string>();
                 directoriesToHash.AddRange(GetAllReferenceDirectories(sdkRoot));
                 directoriesToHash.AddRange(GetAllRedistDirectories(sdkRoot));
 
@@ -1219,7 +1093,7 @@ internal bool IsAssemblyListCacheFileUpToDate(string sdkIdentity, string sdkRoot
                 try
                 {
                     currentAssembly = Assembly.GetExecutingAssembly().CodeBase;
-                    Uri codeBase = new Uri(currentAssembly);
+                    var codeBase = new Uri(currentAssembly);
                     DateTime currentCodeLastWriteTime = File.GetLastWriteTimeUtc(codeBase.LocalPath);
                     if (File.Exists(referencesCacheFile) && currentCodeLastWriteTime < referencesCacheFileLastWriteTimeUtc)
                     {
@@ -1245,7 +1119,7 @@ internal bool IsAssemblyListCacheFileUpToDate(string sdkIdentity, string sdkRoot
             /// <summary>
             /// Generate an SDKReferenceInfo object
             /// </summary>
-            internal SdkReferenceInfo GetSDKReferenceInfo(string referencePath)
+            private SdkReferenceInfo GetSDKReferenceInfo(string referencePath)
             {
                 string imageRuntimeVersion = null;
                 bool isManagedWinMD = false;
@@ -1276,7 +1150,7 @@ internal SdkReferenceInfo GetSDKReferenceInfo(string referencePath)
                     _exceptionMessages.Enqueue(ResourceUtilities.FormatResourceString("GetSDKReferenceFiles.ProblemGettingAssemblyMetadata", referencePath, e.Message));
                 }
 
-                SdkReferenceInfo referenceInfo = new SdkReferenceInfo(fusionName, imageRuntimeVersion, isWinMDFile, isManagedWinMD);
+                var referenceInfo = new SdkReferenceInfo(fusionName, imageRuntimeVersion, isWinMDFile, isManagedWinMD);
                 return referenceInfo;
             }
 
@@ -1294,35 +1168,36 @@ private static string GetCacheFileName(string sdkIdentity, string sdkRoot, strin
             /// <summary>
             /// Get all redist subdirectories under the given path
             /// </summary>
-            private IEnumerable<string> GetAllRedistDirectories(string sdkRoot)
+            private static IEnumerable<string> GetAllRedistDirectories(string sdkRoot)
             {
                 string redistPath = Path.Combine(sdkRoot, "Redist");
                 if (FileUtilities.DirectoryExistsNoThrow(redistPath))
                 {
-                    return Directory.GetDirectories(redistPath, "*", SearchOption.AllDirectories).ToList<string>();
+                    return Directory.GetDirectories(redistPath, "*", SearchOption.AllDirectories);
                 }
 
-                return Array.Empty<string>();
+                return Enumerable.Empty<string>();
             }
 
             /// <summary>
             /// Get all reference subdirectories under the given path
             /// </summary>
-            private IEnumerable<string> GetAllReferenceDirectories(string sdkRoot)
+            private static IEnumerable<string> GetAllReferenceDirectories(string sdkRoot)
             {
                 string referencesPath = Path.Combine(sdkRoot, "References");
                 if (FileUtilities.DirectoryExistsNoThrow(referencesPath))
                 {
-                    return Directory.GetDirectories(referencesPath, "*", SearchOption.AllDirectories).ToList<string>();
+                    return Directory.GetDirectories(referencesPath, "*", SearchOption.AllDirectories);
                 }
 
-                return Array.Empty<string>();
+                return Enumerable.Empty<string>();
             }
         }
 
         /// <summary>
         /// Class to contain some identity information about a file in an sdk
         /// </summary>
+        /// <remarks>This is a serialization format. Do not change member naming.</remarks>
         [Serializable]
         private class SdkReferenceInfo
         {
@@ -1331,55 +1206,40 @@ private class SdkReferenceInfo
             /// </summary>
             public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bool isManagedWinmd)
             {
-                this.FusionName = fusionName;
-                this.ImageRuntime = imageRuntime;
-                this.IsWinMD = isWinMD;
-                this.IsManagedWinmd = isManagedWinmd;
+                FusionName = fusionName;
+                ImageRuntime = imageRuntime;
+                IsWinMD = isWinMD;
+                IsManagedWinmd = isManagedWinmd;
             }
 
             #region Properties
             /// <summary>
             /// The fusionName
             /// </summary>
-            public string FusionName
-            {
-                get;
-                private set;
-            }
+            public string FusionName { get; private set; }
 
             /// <summary>
             /// Is the file a winmd or not
             /// </summary>
-            public bool IsWinMD
-            {
-                get;
-                private set;
-            }
+            public bool IsWinMD { get; private set; }
 
             /// <summary>
             /// Is the file a managed winmd or not
             /// </summary>
-            public bool IsManagedWinmd
-            {
-                get;
-                private set;
-            }
+            public bool IsManagedWinmd { get; private set; }
 
             /// <summary>
             /// What is the imageruntime information on it.
             /// </summary>
-            public string ImageRuntime
-            {
-                get;
-                private set;
-            }
+            public string ImageRuntime { get; private set; }
 
             #endregion
         }
 
         /// <summary>
-        /// Structure that contains the on disk representation of the SDK in memory
+        /// Structure that contains the on disk representation of the SDK in memory.
         /// </summary>
+        /// <remarks>This is a serialization format. Do not change member naming.</remarks>
         [Serializable]
         private class SDKInfo
         {
@@ -1423,14 +1283,16 @@ public SDKInfo(ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMet
 
             public static SDKInfo Deserialize(string cacheFile)
             {
-                using (FileStream fs = new FileStream(cacheFile, FileMode.Open))
+                using (var fs = new FileStream(cacheFile, FileMode.Open))
                 {
-                    BinaryFormatter formatter = new BinaryFormatter();
+                    var formatter = new BinaryFormatter();
                     var info = (SDKInfo)formatter.Deserialize(fs);
 
                     // If the serialization versions don't match, don't use the cache
                     if (info != null && info._serializedVersion != CurrentSerializationVersion)
+                    {
                         return null;
+                    }
 
                     return info;
                 }
@@ -1447,25 +1309,25 @@ private class SaveContext
             /// </summary>
             public SaveContext(string sdkIdentity, string sdkRoot, SDKInfo assemblies)
             {
-                this.SdkIdentity = sdkIdentity;
-                this.SdkRoot = sdkRoot;
-                this.Assemblies = assemblies;
+                SdkIdentity = sdkIdentity;
+                SdkRoot = sdkRoot;
+                Assemblies = assemblies;
             }
 
             /// <summary>
             /// Identity of the sdk
             /// </summary>
-            public string SdkIdentity { get; private set; }
+            public string SdkIdentity { get; }
 
             /// <summary>
             /// Root path of the sdk
             /// </summary>
-            public string SdkRoot { get; private set; }
+            public string SdkRoot { get; }
 
             /// <summary>
             /// Assembly metadata information
             /// </summary>
-            public SDKInfo Assemblies { get; private set; }
+            public SDKInfo Assemblies { get; }
         }
         #endregion
     }
diff --git a/src/Tasks/Hash.cs b/src/Tasks/Hash.cs
index 0a2fa42b326..d5f0f9bf49e 100644
--- a/src/Tasks/Hash.cs
+++ b/src/Tasks/Hash.cs
@@ -1,4 +1,7 @@
-﻿using System.Security.Cryptography;
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System.Security.Cryptography;
 using System.Text;
 using Microsoft.Build.Framework;
 
diff --git a/src/Tasks/IAnalyzerHostObject.cs b/src/Tasks/IAnalyzerHostObject.cs
index c34d279509a..4bd45dcc42d 100644
--- a/src/Tasks/IAnalyzerHostObject.cs
+++ b/src/Tasks/IAnalyzerHostObject.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Runtime.InteropServices;
 using Microsoft.Build.Framework;
 
@@ -20,4 +19,4 @@ public interface IAnalyzerHostObject
         bool SetRuleSet(string ruleSetFile);
         bool SetAdditionalFiles(ITaskItem[] additionalFiles);
     }
-}
\ No newline at end of file
+}
diff --git a/src/Tasks/IComReferenceResolver.cs b/src/Tasks/IComReferenceResolver.cs
index 6ff2365942b..af69306d2c1 100644
--- a/src/Tasks/IComReferenceResolver.cs
+++ b/src/Tasks/IComReferenceResolver.cs
@@ -1,51 +1,44 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Runtime.InteropServices;
-using System.Runtime.InteropServices.ComTypes;
-
 // TYPELIBATTR clashes with the one in InteropServices.
 using TYPELIBATTR = System.Runtime.InteropServices.ComTypes.TYPELIBATTR;
 
 namespace Microsoft.Build.Tasks
 {
-    /*
-     * Interface:   IComReferenceResolver
-     * 
-     * Callback interface for COM references to resolve their dependencies
-     */
+    /// <summary>
+    /// Callback interface for COM references to resolve their dependencies
+    /// </summary>
     internal interface IComReferenceResolver
     {
-        /*
-         * Method:  ResolveComClassicReference
-         * 
-         * Resolves a COM classic reference given the type library attributes and the type of wrapper to use.
-         * If wrapper type is not specified, this method will first look for an existing reference in the project,
-         * fall back to looking for a PIA and finally try to generate a regular tlbimp wrapper.
-         *
-         * This method is available for references to call back to resolve their dependencies
-         */
+        /// <summary>
+        /// Resolves a COM classic reference given the type library attributes and the type of wrapper to use.
+        /// If wrapper type is not specified, this method will first look for an existing reference in the project,
+        /// fall back to looking for a PIA and finally try to generate a regular tlbimp wrapper.
+        ///
+        /// This method is available for references to call back to resolve their dependencies
+        /// </summary>
         bool ResolveComClassicReference(TYPELIBATTR typeLibAttr, string outputDirectory, string wrapperType, string refName, out ComReferenceWrapperInfo wrapperInfo);
 
-        /*
-         * Method:  ResolveNetAssemblyReference
-         * 
-         * Resolves a .NET assembly reference using the list of resolved managed references supplied to the task.
-         *
-         * This method is available for references to call back to resolve their dependencies
-         */
+        /// <summary>
+        /// Resolves a .NET assembly reference using the list of resolved managed references supplied to the task.
+        ///
+        /// This method is available for references to call back to resolve their dependencies
+        /// </summary>
         bool ResolveNetAssemblyReference(string assemblyName, out string assemblyPath);
 
         /*
          * Method:  ResolveComAssemblyReference
          * 
-         * Resolves a COM wrapper assembly reference based on the COM references resolved so far. This method is necessary
-         * for Ax wrappers only, so all necessary references will be resolved by then (since we resolve them in 
-         * the following order: pia, tlbimp, aximp)
-         *
-         * This method is available for references to call back to resolve their dependencies
+         * 
          */
+        /// <summary>
+        /// Resolves a COM wrapper assembly reference based on the COM references resolved so far. This method is necessary
+        /// for Ax wrappers only, so all necessary references will be resolved by then(since we resolve them in
+        /// the following order: pia, tlbimp, aximp)
+        ///
+        /// This method is available for references to call back to resolve their dependencies
+        /// </summary>
         bool ResolveComAssemblyReference(string assemblyName, out string assemblyPath);
     }
 }
diff --git a/src/Tasks/ICscHostObject.cs b/src/Tasks/ICscHostObject.cs
index 03194abe4d1..b7a64be43ae 100644
--- a/src/Tasks/ICscHostObject.cs
+++ b/src/Tasks/ICscHostObject.cs
@@ -1,21 +1,16 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Text;
 using System.Runtime.InteropServices;
 using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Tasks.Hosting
 {
-    /*
-     * Interface:       ICscHostObject
-     *
-     * Defines an interface for the Csc task to communicate with the IDE.  In particular,
-     * the Csc task will delegate the actual compilation to the IDE, rather than shelling
-     * out to the command-line compilers.
-     *
-     */
+    /// <summary>
+    /// Defines an interface for the Csc task to communicate with the IDE.  In particular,
+    /// the Csc task will delegate the actual compilation to the IDE, rather than shelling
+    /// out to the command-line compilers.
+    /// </summary>
     [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
     [ComVisible(true)]
     [Guid("8520CC4D-64DC-4855-BE3F-4C28CCE048EE")]
diff --git a/src/Tasks/ICscHostObject2.cs b/src/Tasks/ICscHostObject2.cs
index e243bda6eb2..fe8373dc102 100644
--- a/src/Tasks/ICscHostObject2.cs
+++ b/src/Tasks/ICscHostObject2.cs
@@ -1,20 +1,15 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Runtime.InteropServices;
-using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Tasks.Hosting
 {
-    /*
-     * Interface:       ICscHostObject2
-     *
-     * Defines an interface for the Csc task to communicate with the IDE.  In particular,
-     * the Csc task will delegate the actual compilation to the IDE, rather than shelling
-     * out to the command-line compilers.
-     *
-     */
+    /// <summary>
+    /// Defines an interface for the Csc task to communicate with the IDE.  In particular,
+    /// the Csc task will delegate the actual compilation to the IDE, rather than shelling
+    /// out to the command-line compilers.
+    /// </summary>
     [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
     [ComVisible(true)]
     [Guid("D6D4E228-259A-4076-B5D0-0627338BCC10")]
diff --git a/src/Tasks/ICscHostObject3.cs b/src/Tasks/ICscHostObject3.cs
index 2502953beb6..3c6f41be6b2 100644
--- a/src/Tasks/ICscHostObject3.cs
+++ b/src/Tasks/ICscHostObject3.cs
@@ -1,20 +1,15 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Runtime.InteropServices;
-using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Tasks.Hosting
 {
-    /*
-     * Interface:       ICscHostObject3
-     *
-     * Defines an interface for the Csc task to communicate with the IDE.  In particular,
-     * the Csc task will delegate the actual compilation to the IDE, rather than shelling
-     * out to the command-line compilers.
-     *
-     */
+    /// <summary>
+    /// Defines an interface for the Csc task to communicate with the IDE.  In particular,
+    /// the Csc task will delegate the actual compilation to the IDE, rather than shelling
+    /// out to the command-line compilers.
+    /// </summary>
     [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
     [ComVisible(true)]
     [Guid("F9353662-F1ED-4a23-A323-5F5047E85F5D")]
diff --git a/src/Tasks/ICscHostObject4.cs b/src/Tasks/ICscHostObject4.cs
index 1a88692c404..61a0746ccab 100644
--- a/src/Tasks/ICscHostObject4.cs
+++ b/src/Tasks/ICscHostObject4.cs
@@ -1,20 +1,15 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Runtime.InteropServices;
-using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Tasks.Hosting
 {
-    /*
-     * Interface:       ICscHostObject4
-     *
-     * Defines an interface for the Csc task to communicate with the IDE.  In particular,
-     * the Csc task will delegate the actual compilation to the IDE, rather than shelling
-     * out to the command-line compilers.
-     *
-     */
+    /// <summary>
+    /// Defines an interface for the Csc task to communicate with the IDE.  In particular,
+    /// the Csc task will delegate the actual compilation to the IDE, rather than shelling
+    /// out to the command-line compilers.
+    /// </summary>
     [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
     [ComVisible(true)]
     [Guid("0DDB496F-C93C-492C-87F1-90B6FDBAA833")]
diff --git a/src/Tasks/IVbcHostObject.cs b/src/Tasks/IVbcHostObject.cs
index 1802a636b1b..9a1873d6442 100644
--- a/src/Tasks/IVbcHostObject.cs
+++ b/src/Tasks/IVbcHostObject.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Runtime.InteropServices;
 using Microsoft.Build.Framework;
 
diff --git a/src/Tasks/IVbcHostObject2.cs b/src/Tasks/IVbcHostObject2.cs
index 27703a1cb77..2c255ad86a8 100644
--- a/src/Tasks/IVbcHostObject2.cs
+++ b/src/Tasks/IVbcHostObject2.cs
@@ -1,9 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Runtime.InteropServices;
-using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Tasks.Hosting
 {
diff --git a/src/Tasks/IVbcHostObject3.cs b/src/Tasks/IVbcHostObject3.cs
index e2703a173e7..a76134d0746 100644
--- a/src/Tasks/IVbcHostObject3.cs
+++ b/src/Tasks/IVbcHostObject3.cs
@@ -1,9 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Runtime.InteropServices;
-using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Tasks.Hosting
 {
diff --git a/src/Tasks/IVbcHostObject4.cs b/src/Tasks/IVbcHostObject4.cs
index 6cfb5cdc4fd..eff3f3777f7 100644
--- a/src/Tasks/IVbcHostObject4.cs
+++ b/src/Tasks/IVbcHostObject4.cs
@@ -1,9 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Runtime.InteropServices;
-using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Tasks.Hosting
 {
diff --git a/src/Tasks/IVbcHostObject5.cs b/src/Tasks/IVbcHostObject5.cs
index d20292d6bb1..4c2efaab1fb 100644
--- a/src/Tasks/IVbcHostObject5.cs
+++ b/src/Tasks/IVbcHostObject5.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Runtime.InteropServices;
-using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Tasks.Hosting
 {
@@ -18,9 +17,9 @@ namespace Microsoft.Build.Tasks.Hosting
     public interface IVbcHostObject5 : IVbcHostObject4
     {
         IVbcHostObjectFreeThreaded GetFreeThreadedHostObject();
-        [PreserveSig()]
+        [PreserveSig]
         int CompileAsync(out IntPtr buildSucceededEvent, out IntPtr buildFailedEvent);
-        [PreserveSig()]
+        [PreserveSig]
         int EndCompile(bool buildSuccess);
 
         bool SetPlatformWith32BitPreference(string platformWith32BitPreference);
diff --git a/src/Tasks/IVbcHostObjectFreeThreaded.cs b/src/Tasks/IVbcHostObjectFreeThreaded.cs
index d78cb42b509..bf1b5cf5c69 100644
--- a/src/Tasks/IVbcHostObjectFreeThreaded.cs
+++ b/src/Tasks/IVbcHostObjectFreeThreaded.cs
@@ -1,11 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Linq;
 using System.Runtime.InteropServices;
-using System.Text;
 
 namespace Microsoft.Build.Tasks.Hosting
 {
diff --git a/src/Tasks/InstalledSDKResolver.cs b/src/Tasks/InstalledSDKResolver.cs
index 673d19c925b..a33f9d35fb1 100644
--- a/src/Tasks/InstalledSDKResolver.cs
+++ b/src/Tasks/InstalledSDKResolver.cs
@@ -6,12 +6,11 @@
 //-----------------------------------------------------------------------
 
 using System;
-using System.Reflection;
 using System.Collections;
-using Microsoft.Build.Shared;
 using System.Collections.Generic;
 using System.IO;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
 {
@@ -23,7 +22,7 @@ internal class InstalledSDKResolver : Resolver
         /// <summary>
         ///  Resolved SDKs
         /// </summary>
-        private Dictionary<string, ITaskItem> _resolvedSDKs;
+        private readonly Dictionary<string, ITaskItem> _resolvedSDKs;
 
         /// <summary>
         /// Construct.
@@ -80,12 +79,11 @@ out bool userRequestedSpecificFile
                     };
 
                     // Lets try and resovle from the windowsmetadata directory first
-                    string resolvedPath = null;
 
                     // Go through the search locations and find the assembly
                     foreach (string searchLocation in searchLocations)
                     {
-                        resolvedPath = ResolveFromDirectory(assemblyName, isPrimaryProjectReference, wantSpecificVersion, executableExtensions, searchLocation, assembliesConsideredAndRejected);
+                        string resolvedPath = ResolveFromDirectory(assemblyName, isPrimaryProjectReference, wantSpecificVersion, executableExtensions, searchLocation, assembliesConsideredAndRejected);
 
                         if (resolvedPath != null)
                         {
diff --git a/src/Tasks/InvalidParameterValueException.cs b/src/Tasks/InvalidParameterValueException.cs
index 43d5e23147e..de281e01cf6 100644
--- a/src/Tasks/InvalidParameterValueException.cs
+++ b/src/Tasks/InvalidParameterValueException.cs
@@ -2,15 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
-using System.Collections;
-using System.Globalization;
-using System.Runtime.InteropServices;
-using System.Diagnostics;
-using System.Reflection;
 using System.Runtime.Serialization;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
 {
@@ -23,13 +15,6 @@ namespace Microsoft.Build.Tasks
     [Serializable]
     internal sealed class InvalidParameterValueException : Exception
     {
-        /// <summary>
-        /// Don't allow default construction.
-        /// </summary>
-        private InvalidParameterValueException()
-        {
-        }
-
         /// <summary>
         /// Constructor
         /// </summary>
@@ -56,26 +41,14 @@ private InvalidParameterValueException(SerializationInfo info, StreamingContext
         {
         }
 
-        private string paramName;
-
         /// <summary>
         /// The name of the parameter.
         /// </summary>
-        public string ParamName
-        {
-            get { return paramName; }
-            set { paramName = value; }
-        }
-
-        private string actualValue;
+        public string ParamName { get; set; }
 
         /// <summary>
         /// The value supplied, that was bad.
         /// </summary>
-        public string ActualValue
-        {
-            get { return actualValue; }
-            set { actualValue = value; }
-        }
+        public string ActualValue { get; set; }
     }
 }
diff --git a/src/Tasks/LC.cs b/src/Tasks/LC.cs
index 6970637c375..ba7f7271ec5 100644
--- a/src/Tasks/LC.cs
+++ b/src/Tasks/LC.cs
@@ -5,7 +5,6 @@
 using System.IO;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
 
 namespace Microsoft.Build.Tasks
@@ -15,18 +14,6 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public class LC : ToolTaskExtension
     {
-        #region Constructors
-
-        /// <summary>
-        /// public constructor
-        /// </summary>
-        public LC()
-        {
-            // do nothing
-        }
-
-        #endregion
-
         #region Input/output properties
 
         /// <summary>
@@ -35,8 +22,8 @@ public LC()
         [Required]
         public ITaskItem[] Sources
         {
-            set { Bag["Sources"] = value; }
-            get { return (ITaskItem[])Bag["Sources"]; }
+            set => Bag[nameof(Sources)] = value;
+            get => (ITaskItem[])Bag[nameof(Sources)];
         }
 
         /// <summary>
@@ -45,8 +32,8 @@ public ITaskItem[] Sources
         [Output]
         public ITaskItem OutputLicense
         {
-            set { Bag["OutputLicense"] = value; }
-            get { return (ITaskItem)Bag["OutputLicense"]; }
+            set => Bag[nameof(OutputLicense)] = value;
+            get => (ITaskItem)Bag[nameof(OutputLicense)];
         }
 
         /// <summary>
@@ -55,8 +42,8 @@ public ITaskItem OutputLicense
         [Required]
         public ITaskItem LicenseTarget
         {
-            set { Bag["LicenseTarget"] = value; }
-            get { return (ITaskItem)Bag["LicenseTarget"]; }
+            set => Bag[nameof(LicenseTarget)] = value;
+            get => (ITaskItem)Bag[nameof(LicenseTarget)];
         }
 
         /// <summary>
@@ -65,8 +52,8 @@ public ITaskItem LicenseTarget
         /// <value></value>
         public string OutputDirectory
         {
-            set { Bag["OutputDirectory"] = value; }
-            get { return (string)Bag["OutputDirectory"]; }
+            set => Bag[nameof(OutputDirectory)] = value;
+            get => (string)Bag[nameof(OutputDirectory)];
         }
 
         /// <summary>
@@ -75,8 +62,8 @@ public string OutputDirectory
         /// </summary>
         public ITaskItem[] ReferencedAssemblies
         {
-            set { Bag["ReferencedAssemblies"] = value; }
-            get { return (ITaskItem[])Bag["ReferencedAssemblies"]; }
+            set => Bag[nameof(ReferencedAssemblies)] = value;
+            get => (ITaskItem[])Bag[nameof(ReferencedAssemblies)];
         }
 
         /// <summary>
@@ -84,24 +71,21 @@ public ITaskItem[] ReferencedAssemblies
         /// </summary>
         public bool NoLogo
         {
-            set { Bag["NoLogo"] = value; }
-            get { return GetBoolParameterWithDefault("NoLogo", false); }
+            set => Bag[nameof(NoLogo)] = value;
+            get => GetBoolParameterWithDefault(nameof(NoLogo), false);
         }
 
         public string SdkToolsPath
         {
-            set { Bag["SdkToolsPath"] = value; }
-            get { return (string)Bag["SdkToolsPath"]; }
+            set => Bag[nameof(SdkToolsPath)] = value;
+            get => (string)Bag[nameof(SdkToolsPath)];
         }
 
         /// <summary>
         /// Targeted version of the framework (i.e. 4.5 or 2.0, etc.)
         /// </summary>
         [Required]
-        public string TargetFrameworkVersion
-        {
-            get; set;
-        }
+        public string TargetFrameworkVersion { get; set; }
         #endregion
 
         #region Class properties
@@ -109,13 +93,7 @@ public string TargetFrameworkVersion
         /// <summary>
         /// The name of the tool to execute
         /// </summary>
-        protected override string ToolName
-        {
-            get
-            {
-                return "lc.exe";
-            }
-        }
+        protected override string ToolName => "lc.exe";
 
         #endregion
 
@@ -137,7 +115,7 @@ protected override bool ValidateParameters()
         /// <returns>path to lc.exe, null if not found</returns>
         protected override string GenerateFullPathToTool()
         {
-            string pathToTool = SdkToolsPathUtility.GeneratePathToTool(SdkToolsPathUtility.FileInfoExists, Microsoft.Build.Utilities.ProcessorArchitecture.CurrentProcessArchitecture, SdkToolsPath, ToolExe, Log, true);
+            string pathToTool = SdkToolsPathUtility.GeneratePathToTool(SdkToolsPathUtility.FileInfoExists, ProcessorArchitecture.CurrentProcessArchitecture, SdkToolsPath, ToolExe, Log, true);
             return pathToTool;
         }
 
@@ -170,12 +148,13 @@ private void AddCommands(CommandLineBuilderExtension commandLine)
             string outputPath = LicenseTarget.ItemSpec + ".licenses";
 
             if (OutputDirectory != null)
+            {
                 outputPath = Path.Combine(OutputDirectory, outputPath);
+            }
 
             OutputLicense = new TaskItem(outputPath);
         }
 
-
         /// <summary>
         /// Generates response file with arguments for lc.exe
         /// Used when targeting framework version is 4.6 or later
diff --git a/src/Tasks/LockCheck.cs b/src/Tasks/LockCheck.cs
index 2dd8e658786..9b343227cef 100644
--- a/src/Tasks/LockCheck.cs
+++ b/src/Tasks/LockCheck.cs
@@ -42,10 +42,10 @@ internal enum ApplicationType
             Critical = 1000
         }
 
-        const string RestartManagerDll = "rstrtmgr.dll";
+        private const string RestartManagerDll = "rstrtmgr.dll";
 
         [DllImport(RestartManagerDll, CharSet = CharSet.Unicode)]
-        static extern int RmRegisterResources(uint pSessionHandle,
+        private static extern int RmRegisterResources(uint pSessionHandle,
             uint nFiles,
             string[] rgsFilenames,
             uint nApplications,
@@ -54,14 +54,14 @@ static extern int RmRegisterResources(uint pSessionHandle,
             string[] rgsServiceNames);
 
         [DllImport(RestartManagerDll, CharSet = CharSet.Unicode)]
-        static extern int RmStartSession(out uint pSessionHandle,
+        private static extern int RmStartSession(out uint pSessionHandle,
             int dwSessionFlags, StringBuilder strSessionKey);
 
         [DllImport(RestartManagerDll)]
-        static extern int RmEndSession(uint pSessionHandle);
+        private static extern int RmEndSession(uint pSessionHandle);
 
         [DllImport(RestartManagerDll, CharSet = CharSet.Unicode)]
-        static extern int RmGetList(uint dwSessionHandle,
+        public static extern int RmGetList(uint dwSessionHandle,
             out uint pnProcInfoNeeded,
             ref uint pnProcInfo,
             [In, Out] RM_PROCESS_INFO[] rgAffectedApps,
@@ -163,14 +163,14 @@ internal ProcessInfo(RM_PROCESS_INFO processInfo)
                 TerminalServicesSessionId = (int)processInfo.TSSessionId;
             }
 
-            public int ProcessId { get; private set; }
-            public DateTime StartTime { get; private set; }
-            public string ApplicationName { get; private set; }
-            public string ServiceShortName { get; private set; }
-            public ApplicationType ApplicationType { get; private set; }
-            public ApplicationStatus ApplicationStatus { get; private set; }
-            public int TerminalServicesSessionId { get; private set; }
-            public bool Restartable { get; private set; }
+            public int ProcessId { get; }
+            public DateTime StartTime { get; }
+            public string ApplicationName { get; }
+            public string ServiceShortName { get; }
+            public ApplicationType ApplicationType { get; }
+            public ApplicationStatus ApplicationStatus { get; }
+            public int TerminalServicesSessionId { get; }
+            public bool Restartable { get; }
 
             public override int GetHashCode()
             {
@@ -181,8 +181,7 @@ public override int GetHashCode()
 
             public override bool Equals(object obj)
             {
-                var other = obj as ProcessInfo;
-                if (other != null)
+                if (obj is ProcessInfo other)
                 {
                     return other.ProcessId == ProcessId && other.StartTime == StartTime;
                 }
@@ -203,24 +202,29 @@ internal static string GetProcessesLockingFile(string filePath)
         internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[] paths)
         {
             if (paths == null)
-                throw new ArgumentNullException("paths");
+            {
+                throw new ArgumentNullException(nameof(paths));
+            }
 
             const int maxRetries = 6;
 
             // See http://blogs.msdn.com/b/oldnewthing/archive/2012/02/17/10268840.aspx.
             var key = new StringBuilder(new string('\0', CCH_RM_SESSION_KEY + 1));
 
-            uint handle;
-            int res = RmStartSession(out handle, 0, key);
+            int res = RmStartSession(out uint handle, 0, key);
             if (res != 0)
+            {
                 throw GetException(res, "RmStartSession", "Failed to begin restart manager session.");
+            }
 
             try
             {
                 string[] resources = paths;
                 res = RmRegisterResources(handle, (uint)resources.Length, resources, 0, null, 0, null);
                 if (res != 0)
+                {
                     throw GetException(res, "RmRegisterResources", "Could not register resources.");
+                }
 
                 //
                 // Obtain the list of affected applications/services.
@@ -242,13 +246,14 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]
                 do
                 {
                     uint lpdwRebootReasons = (uint)RM_REBOOT_REASON.RmRebootReasonNone;
-                    uint pnProcInfoNeeded;
-                    res = RmGetList(handle, out pnProcInfoNeeded, ref pnProcInfo, rgAffectedApps, ref lpdwRebootReasons);
+                    res = RmGetList(handle, out uint pnProcInfoNeeded, ref pnProcInfo, rgAffectedApps, ref lpdwRebootReasons);
                     if (res == 0)
                     {
                         // If pnProcInfo == 0, then there is simply no locking process (found), in this case rgAffectedApps is "null".
                         if (pnProcInfo == 0)
+                        {
                             return Enumerable.Empty<ProcessInfo>();
+                        }
 
                         var lockInfos = new List<ProcessInfo>((int)pnProcInfo);
                         for (int i = 0; i < pnProcInfo; i++)
@@ -259,7 +264,9 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]
                     }
 
                     if (res != ERROR_MORE_DATA)
-                        throw GetException(res, "RmGetList", string.Format("Failed to get entries (retry {0}).", retry));
+                    {
+                        throw GetException(res, "RmGetList", $"Failed to get entries (retry {retry}).");
+                    }
 
                     pnProcInfo = pnProcInfoNeeded;
                     rgAffectedApps = new RM_PROCESS_INFO[pnProcInfo];
@@ -310,13 +317,13 @@ private static Exception GetException(int res, string apiName, string message)
                     reason = "No Restart Manager session exists for the handle supplied.";
                     break;
                 default:
-                    reason = string.Format("0x{0:x8}", res);
+                    reason = $"0x{res:x8}";
                     break;
             }
 
-            throw new Win32Exception(res, string.Format("{0} ({1}() error {2}: {3})", message, apiName, res, reason));
+            throw new Win32Exception(res, $"{message} ({apiName}() error {res}: {reason})");
         }
     }
 }
 
-#endif
\ No newline at end of file
+#endif
diff --git a/src/Tasks/MSBuild.cs b/src/Tasks/MSBuild.cs
index 09ed534b762..a77a49035cc 100644
--- a/src/Tasks/MSBuild.cs
+++ b/src/Tasks/MSBuild.cs
@@ -5,7 +5,6 @@
 using System.IO;
 using System.Collections;
 using System.Collections.Generic;
-using System.Globalization;
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -42,54 +41,13 @@ private enum SkipNonexistentProjectsBehavior
             Build
         }
 
-        /// <summary>
-        /// Default constructor.
-        /// </summary>
-        public MSBuild()
-        {
-        }
-
         #region Properties
 
-        // projects to build
-        private ITaskItem[] _projects = null;
-        // A list of targets to build.  This is an optional parameter.  If it's omitted,
-        // the default targets are built.
-        private string[] _targets = null;
-        // A list of property name/value pairs to apply as global properties to the child project.
-        // Each string in this array should be of the form:  "propname=propvalue"
-        private string[] _properties = null;
-
-        /// <summary>
-        /// A semicolon-delimited list of global properties to undefine
-        /// </summary>
-        private string _undefineProperties = null;
-
         // outputs of all built targets
-        private ArrayList _targetOutputs = new ArrayList();
-        // indicates if the paths of target output items should be rebased relative to the calling project
-        private bool _rebaseOutputs = false;
-        // Indicates that we should stop building remaining projects as soon as one fails to build.
-        // The default is that we chug ahead despite failures.
-        private bool _stopOnFirstFailure = false;
-        // When this is true, instead of calling the engine once to build all the targets (for each project),
-        // we would call the engine once per target (for each project).  The benefit of this is that
-        // if one target fails, you can still continue with the remaining targets.
-        private bool _runEachTargetSeparately = false;
-        // When this is true we call the engine with all the projects at once instead of
-        // calling the engine once per project
-        private bool _buildInParallel = false;
-        // If true the project will be unloaded once the  operation is completed
-        private bool _unloadProjectsOnCompletion = false;
-        // If true the cache will be checked for the result and the result will be stored if the operation 
-        // is run
-        private bool _useResultsCache = true;
+        private readonly List<ITaskItem> _targetOutputs = new List<ITaskItem>();
+
         // Whether to skip project files that don't exist on disk. By default we error for such projects.
         private SkipNonexistentProjectsBehavior _skipNonexistentProjects = SkipNonexistentProjectsBehavior.Error;
-        // Value of ToolsVersion to use when building projects passed to this task.
-        private string _toolsVersion = null;
-        // Should Targets, Properties (+ properties as project metadata) be un-escaped before processing
-        private string[] _targetAndPropertyListSeparators = null;
 
         /// <summary>
         /// A list of property name/value pairs to apply as global properties to 
@@ -106,198 +64,74 @@ public MSBuild()
         ///     <MSBuild
         ///         Properties="@(OutputPathItem->'TargetPath=%(Identity)')" />
         /// </remarks>
-        public string[] Properties
-        {
-            get
-            {
-                return _properties;
-            }
-
-            set
-            {
-                _properties = value;
-            }
-        }
+        public string[] Properties { get; set; }
 
         /// <summary>
         /// Gets or sets the set of global properties to remove.
         /// </summary>
-        public string RemoveProperties
-        {
-            get
-            {
-                return _undefineProperties;
-            }
-
-            set
-            {
-                _undefineProperties = value;
-            }
-        }
+        public string RemoveProperties { get; set; }
 
         /// <summary>
         /// The targets to build in each project specified by the <see cref="Projects"/> property.
         /// </summary>
         /// <value>Array of target names.</value>
-        public string[] Targets
-        {
-            get
-            {
-                return _targets;
-            }
-
-            set
-            {
-                _targets = value;
-            }
-        }
+        public string[] Targets { get; set; }
 
         /// <summary>
         /// The projects to build.
         /// </summary>
         /// <value>Array of project items.</value>
         [Required]
-        public ITaskItem[] Projects
-        {
-            get
-            {
-                return _projects;
-            }
-
-            set
-            {
-                _projects = value;
-            }
-        }
+        public ITaskItem[] Projects { get; set; }
 
         /// <summary>
         /// Outputs of the targets built in each project.
         /// </summary>
         /// <value>Array of output items.</value>
         [Output]
-        public ITaskItem[] TargetOutputs
-        {
-            get
-            {
-                return (ITaskItem[])_targetOutputs.ToArray(typeof(ITaskItem));
-            }
-        }
+        public ITaskItem[] TargetOutputs => _targetOutputs.ToArray();
 
         /// <summary>
         /// Indicates if the paths of target output items should be rebased relative to the calling project.
         /// </summary>
         /// <value>true, if target output item paths should be rebased</value>
-        public bool RebaseOutputs
-        {
-            get
-            {
-                return _rebaseOutputs;
-            }
-
-            set
-            {
-                _rebaseOutputs = value;
-            }
-        }
+        public bool RebaseOutputs { get; set; }
 
         /// <summary>
         /// Forces the task to stop building the remaining projects as soon as any of
         /// them fail.
         /// </summary>
-        public bool StopOnFirstFailure
-        {
-            get
-            {
-                return _stopOnFirstFailure;
-            }
-
-            set
-            {
-                _stopOnFirstFailure = value;
-            }
-        }
+        public bool StopOnFirstFailure { get; set; }
 
         /// <summary>
         /// When this is true, instead of calling the engine once to build all the targets (for each project),
         /// we would call the engine once per target (for each project).  The benefit of this is that
         /// if one target fails, you can still continue with the remaining targets.
         /// </summary>
-        public bool RunEachTargetSeparately
-        {
-            get
-            {
-                return _runEachTargetSeparately;
-            }
-
-            set
-            {
-                _runEachTargetSeparately = value;
-            }
-        }
+        public bool RunEachTargetSeparately { get; set; }
 
         /// <summary>
         /// Value of ToolsVersion to use when building projects passed to this task.
         /// </summary>
-        public string ToolsVersion
-        {
-            get
-            {
-                return _toolsVersion;
-            }
-
-            set
-            {
-                _toolsVersion = value;
-            }
-        }
+        public string ToolsVersion { get; set; }
 
         /// <summary>
         /// When this is true we call the engine with all the projects at once instead of 
         /// calling the engine once per project
         /// </summary>
-        public bool BuildInParallel
-        {
-            get
-            {
-                return _buildInParallel;
-            }
-            set
-            {
-                _buildInParallel = value;
-            }
-        }
+        public bool BuildInParallel { get; set; }
 
         /// <summary>
         /// If true the project will be unloaded once the operation is completed
         /// </summary>
-        public bool UnloadProjectsOnCompletion
-        {
-            get
-            {
-                return _unloadProjectsOnCompletion;
-            }
-            set
-            {
-                _unloadProjectsOnCompletion = value;
-            }
-        }
+        public bool UnloadProjectsOnCompletion { get; set; }
 
         /// <summary>
         /// If true the cached result will be returned if present and a if MSBuild
         /// task is run its result will be cached in a scope (ProjectFileName, GlobalProperties)[TargetNames]
         /// as a list of build items
         /// </summary>
-        public bool UseResultsCache
-        {
-            get
-            {
-                return _useResultsCache;
-            }
-            set
-            {
-                _useResultsCache = value;
-            }
-        }
+        public bool UseResultsCache { get; set; } = true;
 
         /// <summary>
         /// When this is true, project files that do not exist on the disk will be skipped. By default,
@@ -337,14 +171,7 @@ public string SkipNonexistentProjects
                 {
                     ErrorUtilities.VerifyThrowArgument(ConversionUtilities.CanConvertStringToBool(value), "MSBuild.InvalidSkipNonexistentProjectValue");
                     bool originalSkipValue = ConversionUtilities.ConvertStringToBool(value);
-                    if (originalSkipValue)
-                    {
-                        _skipNonexistentProjects = SkipNonexistentProjectsBehavior.Skip;
-                    }
-                    else
-                    {
-                        _skipNonexistentProjects = SkipNonexistentProjectsBehavior.Error;
-                    }
+                    _skipNonexistentProjects = originalSkipValue ? SkipNonexistentProjectsBehavior.Skip : SkipNonexistentProjectsBehavior.Error;
                 }
             }
         }
@@ -354,17 +181,7 @@ public string SkipNonexistentProjects
         /// will be un-escaped before processing. e.g. %3B (an escaped ';') in the string for any of them will 
         /// be treated as if it were an un-escaped ';'
         /// </summary>
-        public string[] TargetAndPropertyListSeparators
-        {
-            get
-            {
-                return _targetAndPropertyListSeparators;
-            }
-            set
-            {
-                _targetAndPropertyListSeparators = value;
-            }
-        }
+        public string[] TargetAndPropertyListSeparators { get; set; }
 
         #endregion
 
@@ -384,27 +201,26 @@ public override bool Execute()
             }
 
             // We have been asked to unescape all escaped characters before processing
-            if (this.TargetAndPropertyListSeparators != null && this.TargetAndPropertyListSeparators.Length > 0)
+            if (TargetAndPropertyListSeparators != null && TargetAndPropertyListSeparators.Length > 0)
             {
                 ExpandAllTargetsAndProperties();
             }
 
             // Parse the global properties into a hashtable.
-            Hashtable propertiesTable;
-            if (!PropertyParser.GetTableWithEscaping(Log, ResourceUtilities.GetResourceString("General.GlobalProperties"), "Properties", this.Properties, out propertiesTable))
+            if (!PropertyParser.GetTableWithEscaping(Log, ResourceUtilities.GetResourceString("General.GlobalProperties"), "Properties", Properties, out Hashtable propertiesTable))
             {
                 return false;
             }
 
             // Parse out the properties to undefine, if any.
             string[] undefinePropertiesArray = null;
-            if (!String.IsNullOrEmpty(_undefineProperties))
+            if (!String.IsNullOrEmpty(RemoveProperties))
             {
                 Log.LogMessageFromResources(MessageImportance.Low, "General.UndefineProperties");
-                undefinePropertiesArray = _undefineProperties.Split(new char[] { ';' });
+                undefinePropertiesArray = RemoveProperties.Split(';');
                 foreach (string property in undefinePropertiesArray)
                 {
-                    Log.LogMessageFromText(String.Format(CultureInfo.InvariantCulture, "  {0}", property), MessageImportance.Low);
+                    Log.LogMessageFromText($"  {property}", MessageImportance.Low);
                 }
             }
 
@@ -412,9 +228,9 @@ public override bool Execute()
             // If we are in single proc mode and stopOnFirstFailure is true, we cannot build in parallel because 
             // building in parallel sends all of the projects to the engine at once preventing us from not sending
             // any more projects after the first failure. Therefore, to preserve compatibility with whidbey if we are in this situation disable buildInParallel.
-            if (!isRunningMultipleNodes && _stopOnFirstFailure && _buildInParallel)
+            if (!isRunningMultipleNodes && StopOnFirstFailure && BuildInParallel)
             {
-                _buildInParallel = false;
+                BuildInParallel = false;
                 Log.LogMessageFromResources(MessageImportance.Low, "MSBuild.NotBuildingInParallel");
             }
 
@@ -423,7 +239,7 @@ public override bool Execute()
             // All project files will be submitted to the engine all at once, this mean there is no stopping for failures between projects.
             // When RunEachTargetSeparately is false, all targets will be submitted to the engine at once, this means there is no way to stop between target failures.
             // therefore the first failure seen will be the only failure seen.
-            if (isRunningMultipleNodes && _buildInParallel && _stopOnFirstFailure && !_runEachTargetSeparately)
+            if (isRunningMultipleNodes && BuildInParallel && StopOnFirstFailure && !RunEachTargetSeparately)
             {
                 Log.LogMessageFromResources(MessageImportance.Low, "MSBuild.NoStopOnFirstFailure");
             }
@@ -432,15 +248,13 @@ public override bool Execute()
             // string[] represents a set of target names to build.  Depending on the value 
             // of the RunEachTargetSeparately parameter, we each just call the engine to run all 
             // the targets together, or we call the engine separately for each target.
-            ArrayList targetLists = CreateTargetLists(this.Targets, this.RunEachTargetSeparately);
-
+            List<string[]> targetLists = CreateTargetLists(Targets, RunEachTargetSeparately);
 
             bool success = true;
             ITaskItem[] singleProject = null;
             bool[] skipProjects = null;
 
-
-            if (_buildInParallel)
+            if (BuildInParallel)
             {
                 skipProjects = new bool[Projects.Length];
                 for (int i = 0; i < skipProjects.Length; i++)
@@ -463,7 +277,7 @@ public override bool Execute()
 
                 string projectPath = FileUtilities.AttemptToShortenPath(project.ItemSpec);
 
-                if (_stopOnFirstFailure && !success)
+                if (StopOnFirstFailure && !success)
                 {
                     // Inform the user that we skipped the remaining projects because StopOnFirstFailure=true.
                     Log.LogMessageFromResources(MessageImportance.Low, "MSBuild.SkippingRemainingProjects");
@@ -484,7 +298,7 @@ public override bool Execute()
 
                     // If we are building in parallel we want to only make one call to
                     // ExecuteTargets once we verified that all projects exist
-                    if (!_buildInParallel)
+                    if (!BuildInParallel)
                     {
                         singleProject[0] = project;
 
@@ -499,8 +313,8 @@ public override bool Execute()
                                 BuildEngine3,
                                 Log,
                                 _targetOutputs,
-                                _useResultsCache,
-                                _unloadProjectsOnCompletion,
+                                UseResultsCache,
+                                UnloadProjectsOnCompletion,
                                 ToolsVersion
                                 )
                            )
@@ -529,7 +343,7 @@ public override bool Execute()
             }
 
             // We need to build all the projects that were not skipped
-            if (_buildInParallel)
+            if (BuildInParallel)
             {
                 success = BuildProjectsInParallel(propertiesTable, undefinePropertiesArray, targetLists, success, skipProjects);
             }
@@ -540,12 +354,11 @@ public override bool Execute()
         /// <summary>
         /// Build projects which have not been skipped. This will be done in parallel
         /// </summary>
-        private bool BuildProjectsInParallel(Hashtable propertiesTable, string[] undefinePropertiesArray, ArrayList targetLists, bool success, bool[] skipProjects)
+        private bool BuildProjectsInParallel(Hashtable propertiesTable, string[] undefinePropertiesArray, List<string[]> targetLists, bool success, bool[] skipProjects)
         {
-            ITaskItem[] projectToBuildInParallel = Projects;
             // There were some projects that were skipped so we need to recreate the
             // project array with those projects removed
-            List<ITaskItem> projectsToBuildArrayList = new List<ITaskItem>();
+            var projectsToBuildArrayList = new List<ITaskItem>();
             for (int i = 0; i < Projects.Length; i++)
             {
                 if (!skipProjects[i])
@@ -553,7 +366,7 @@ private bool BuildProjectsInParallel(Hashtable propertiesTable, string[] undefin
                     projectsToBuildArrayList.Add(Projects[i]);
                 }
             }
-            projectToBuildInParallel = projectsToBuildArrayList.ToArray();
+            ITaskItem[] projectToBuildInParallel = projectsToBuildArrayList.ToArray();
 
             // Make the call to build the projects
             if (projectToBuildInParallel.Length > 0)
@@ -569,8 +382,8 @@ private bool BuildProjectsInParallel(Hashtable propertiesTable, string[] undefin
                                 BuildEngine3,
                                 Log,
                                 _targetOutputs,
-                                _useResultsCache,
-                                _unloadProjectsOnCompletion,
+                                UseResultsCache,
+                                UnloadProjectsOnCompletion,
                                 ToolsVersion
                                 )
                            )
@@ -586,65 +399,59 @@ private bool BuildProjectsInParallel(Hashtable propertiesTable, string[] undefin
         /// </summary>
         private void ExpandAllTargetsAndProperties()
         {
-            List<string> expandedProperties = new List<string>();
-            List<string> expandedTargets = new List<string>();
+            var expandedProperties = new List<string>();
+            var expandedTargets = new List<string>();
 
-            if (this.Properties != null)
+            if (Properties != null)
             {
                 // Expand all properties
-                for (int n = 0; n < this.Properties.Length; n++)
+                foreach (string t in Properties)
                 {
                     // Split each property according to the separators
-                    string[] expandedPropertyValues = this.Properties[n].Split(this.TargetAndPropertyListSeparators, StringSplitOptions.RemoveEmptyEntries);
+                    string[] expandedPropertyValues = t.Split(TargetAndPropertyListSeparators, StringSplitOptions.RemoveEmptyEntries);
+
                     // Add the resultant properties to the final list
                     foreach (string property in expandedPropertyValues)
                     {
                         expandedProperties.Add(property);
                     }
                 }
-                this.Properties = expandedProperties.ToArray();
+
+                Properties = expandedProperties.ToArray();
             }
 
-            if (this.Targets != null)
+            if (Targets != null)
             {
                 // Expand all targets
-                for (int n = 0; n < this.Targets.Length; n++)
+                foreach (string t in Targets)
                 {
                     // Split each target according to the separators
-                    string[] expandedTargetValues = this.Targets[n].Split(this.TargetAndPropertyListSeparators, StringSplitOptions.RemoveEmptyEntries);
+                    string[] expandedTargetValues = t.Split(TargetAndPropertyListSeparators, StringSplitOptions.RemoveEmptyEntries);
+
                     // Add the resultant targets to the final list
                     foreach (string target in expandedTargetValues)
                     {
                         expandedTargets.Add(target);
                     }
                 }
-                this.Targets = expandedTargets.ToArray();
+
+                Targets = expandedTargets.ToArray();
             }
         }
 
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="targets"></param>
-        /// <param name="runEachTargetSeparately"></param>
-        /// <returns></returns>
-        internal static ArrayList CreateTargetLists
-            (
-            string[] targets,
-            bool runEachTargetSeparately
-            )
+        internal static List<string[]> CreateTargetLists(string[] targets, bool runEachTargetSeparately)
         {
             // This is a list of string[].  That is, each element in the list is a string[].  Each
             // string[] represents a set of target names to build.  Depending on the value 
             // of the RunEachTargetSeparately parameter, we each just call the engine to run all 
             // the targets together, or we call the engine separately for each target.
-            ArrayList targetLists = new ArrayList();
-            if ((runEachTargetSeparately) && (targets != null) && (targets.Length > 0))
+            var targetLists = new List<string[]>(runEachTargetSeparately ? targets.Length : 1);
+            if (runEachTargetSeparately && targets.Length > 0)
             {
                 // Separate target invocations for each individual target.
                 foreach (string targetName in targets)
                 {
-                    targetLists.Add(new string[1] { targetName });
+                    targetLists.Add(new[] { targetName });
                 }
             }
             else
@@ -657,21 +464,18 @@ bool runEachTargetSeparately
             return targetLists;
         }
 
-        /// <summary>
-        /// 
-        /// </summary>
         /// <returns>True if the operation was successful</returns>
         internal static bool ExecuteTargets
             (
             ITaskItem[] projects,
             Hashtable propertiesTable,
             string[] undefineProperties,
-            ArrayList targetLists,
+            List<string[]> targetLists,
             bool stopOnFirstFailure,
             bool rebaseOutputs,
             IBuildEngine3 buildEngine,
             TaskLoggingHelper log,
-            ArrayList targetOutputs,
+            List<ITaskItem> targetOutputs,
             bool useResultsCache,
             bool unloadProjectsOnCompletion,
             string toolsVersion
@@ -682,12 +486,11 @@ string toolsVersion
             // We don't log a message about the project and targets we're going to
             // build, because it'll all be in the immediately subsequent ProjectStarted event.
 
-            string[] projectDirectory = new string[projects.Length];
-            string[] projectNames = new string[projects.Length];
-            string[] toolsVersions = new string[projects.Length];
-            IList<IDictionary<string, ITaskItem[]>> targetOutputsPerProject = null;
-            IDictionary[] projectProperties = new IDictionary[projects.Length];
-            List<string>[] undefinePropertiesPerProject = new List<string>[projects.Length];
+            var projectDirectory = new string[projects.Length];
+            var projectNames = new string[projects.Length];
+            var toolsVersions = new string[projects.Length];
+            var projectProperties = new IDictionary[projects.Length];
+            var undefinePropertiesPerProject = new IList<string>[projects.Length];
 
             for (int i = 0; i < projectNames.Length; i++)
             {
@@ -702,15 +505,13 @@ string toolsVersion
                     projectNames[i] = projects[i].ItemSpec;
                     toolsVersions[i] = toolsVersion;
 
-
                     // If the user specified a different set of global properties for this project, then
                     // parse the string containing the properties
                     if (!String.IsNullOrEmpty(projects[i].GetMetadata("Properties")))
                     {
-                        Hashtable preProjectPropertiesTable;
                         if (!PropertyParser.GetTableWithEscaping
                              (log, ResourceUtilities.FormatResourceString("General.OverridingProperties", projectNames[i]), "Properties", projects[i].GetMetadata("Properties").Split(';'),
-                              out preProjectPropertiesTable)
+                              out Hashtable preProjectPropertiesTable)
                            )
                         {
                             return false;
@@ -728,7 +529,7 @@ string toolsVersion
                     string projectUndefineProperties = projects[i].GetMetadata("UndefineProperties");
                     if (!String.IsNullOrEmpty(projectUndefineProperties))
                     {
-                        string[] propertiesToUndefine = projectUndefineProperties.Split(new char[] { ';' });
+                        string[] propertiesToUndefine = projectUndefineProperties.Split(';');
                         if (undefinePropertiesPerProject[i] == null)
                         {
                             undefinePropertiesPerProject[i] = new List<string>(propertiesToUndefine.Length);
@@ -740,7 +541,7 @@ string toolsVersion
                             foreach (string property in propertiesToUndefine)
                             {
                                 undefinePropertiesPerProject[i].Add(property);
-                                log.LogMessageFromText(String.Format(CultureInfo.InvariantCulture, "  {0}", property), MessageImportance.Low);
+                                log.LogMessageFromText($"  {property}", MessageImportance.Low);
                             }
                         }
                     }
@@ -749,10 +550,9 @@ string toolsVersion
                     // parse the string containing the properties
                     if (!String.IsNullOrEmpty(projects[i].GetMetadata("AdditionalProperties")))
                     {
-                        Hashtable additionalProjectPropertiesTable;
                         if (!PropertyParser.GetTableWithEscaping
                              (log, ResourceUtilities.FormatResourceString("General.AdditionalProperties", projectNames[i]), "AdditionalProperties", projects[i].GetMetadata("AdditionalProperties").Split(';'),
-                              out additionalProjectPropertiesTable)
+                              out Hashtable additionalProjectPropertiesTable)
                            )
                         {
                             return false;
@@ -800,13 +600,12 @@ string toolsVersion
                 // Send the project off to the build engine.  By passing in null to the 
                 // first param, we are indicating that the project to build is the same
                 // as the *calling* project file.
-                bool currentTargetResult = true;
 
                 BuildEngineResult result =
                     buildEngine.BuildProjectFilesInParallel(projectNames, targetList, projectProperties, undefinePropertiesPerProject, toolsVersions, true /* ask that target outputs are returned in the buildengineresult */);
 
-                currentTargetResult = result.Result;
-                targetOutputsPerProject = result.TargetOutputsPerProject;
+                bool currentTargetResult = result.Result;
+                IList<IDictionary<string, ITaskItem[]>> targetOutputsPerProject = result.TargetOutputsPerProject;
                 success = success && currentTargetResult;
 
                 // If the engine was able to satisfy the build request
@@ -814,13 +613,13 @@ string toolsVersion
                 {
                     for (int i = 0; i < projects.Length; i++)
                     {
-                        IEnumerable nonNullTargetList = (targetList != null) ? targetList : targetOutputsPerProject[i].Keys;
+                        IEnumerable nonNullTargetList = targetList ?? targetOutputsPerProject[i].Keys;
 
                         foreach (string targetName in nonNullTargetList)
                         {
                             if (targetOutputsPerProject[i].ContainsKey(targetName))
                             {
-                                ITaskItem[] outputItemsFromTarget = (ITaskItem[])targetOutputsPerProject[i][targetName];
+                                ITaskItem[] outputItemsFromTarget = targetOutputsPerProject[i][targetName];
 
                                 foreach (ITaskItem outputItemFromTarget in outputItemsFromTarget)
                                 {
diff --git a/src/Tasks/MakeDir.cs b/src/Tasks/MakeDir.cs
index 5e06f98e899..e08133fe6ae 100644
--- a/src/Tasks/MakeDir.cs
+++ b/src/Tasks/MakeDir.cs
@@ -3,14 +3,9 @@
 
 using System;
 using System.IO;
-using System.Diagnostics;
-using System.Resources;
-using System.Reflection;
-using System.Collections;
+using System.Collections.Generic;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
-using System.Collections.Generic;
 
 namespace Microsoft.Build.Tasks
 {
@@ -19,39 +14,22 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public class MakeDir : TaskExtension
     {
-        /// <summary>
-        /// Constructor
-        /// </summary>
-        public MakeDir()
-        {
-        }
-
         [Required]
         public ITaskItem[] Directories
         {
             get
             {
-                ErrorUtilities.VerifyThrowArgumentNull(_directories, "directories");
+                ErrorUtilities.VerifyThrowArgumentNull(_directories, nameof(Directories));
                 return _directories;
             }
 
-            set
-            {
-                _directories = value;
-            }
+            set => _directories = value;
         }
 
         [Output]
-        public ITaskItem[] DirectoriesCreated
-        {
-            get
-            {
-                return _directoriesCreated;
-            }
-        }
+        public ITaskItem[] DirectoriesCreated { get; private set; }
 
         private ITaskItem[] _directories;
-        private ITaskItem[] _directoriesCreated;
 
         #region ITask Members
 
@@ -60,8 +38,8 @@ public ITaskItem[] DirectoriesCreated
         /// </summary>
         public override bool Execute()
         {
-            ArrayList items = new ArrayList();
-            HashSet<string> directoriesSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+            var items = new List<ITaskItem>();
+            var directoriesSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
             foreach (ITaskItem directory in Directories)
             {
@@ -98,7 +76,7 @@ public override bool Execute()
                 }
             }
 
-            _directoriesCreated = (ITaskItem[])items.ToArray(typeof(ITaskItem));
+            DirectoriesCreated = items.ToArray();
 
             return !Log.HasLoggedErrors;
         }
diff --git a/src/Tasks/Message.cs b/src/Tasks/Message.cs
index 8e6d3758966..0d6fc93f403 100644
--- a/src/Tasks/Message.cs
+++ b/src/Tasks/Message.cs
@@ -2,12 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
-using System.Diagnostics;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
-using System.Globalization;
-using System.Resources;
 
 namespace Microsoft.Build.Tasks
 {
@@ -16,111 +11,37 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public sealed class Message : TaskExtension
     {
-        private string _text;
-
         /// <summary>
         /// Text to log.
         /// </summary>
-        public string Text
-        {
-            get
-            {
-                return _text;
-            }
-
-            set
-            {
-                _text = value;
-            }
-        }
-
-        private string _importance;
+        public string Text { get; set; }
 
         /// <summary>
         /// Importance: high, normal, low (default normal)
         /// </summary>
-        public string Importance
-        {
-            get
-            {
-                return _importance;
-            }
-
-            set
-            {
-                _importance = value;
-            }
-        }
-
-        private string _code;
+        public string Importance { get; set; }
 
         /// <summary>
         /// Message code
         /// </summary>
-        public string Code
-        {
-            get
-            {
-                return _code;
-            }
-            set
-            {
-                _code = value;
-            }
-        }
-
-        private string _file;
+        public string Code { get; set; }
 
         /// <summary>
         /// Relevant file if any.
         /// If none is provided and this is a critical message, the file containing the Message
         /// task will be used.
         /// </summary>
-        public string File
-        {
-            get
-            {
-                return _file;
-            }
-            set
-            {
-                _file = value;
-            }
-        }
-
-        private string _helpKeyword;
+        public string File { get; set; }
 
         /// <summary>
         /// Message help keyword
         /// </summary>
-        public string HelpKeyword
-        {
-            get
-            {
-                return _helpKeyword;
-            }
-            set
-            {
-                _helpKeyword = value;
-            }
-        }
-
-        private bool _isCritical;
+        public string HelpKeyword { get; set; }
 
         /// <summary>
         /// Indicates if this is a critical message
         /// </summary>
-        public bool IsCritical
-        {
-            get
-            {
-                return _isCritical;
-            }
-            set
-            {
-                _isCritical = value;
-            }
-        }
+        public bool IsCritical { get; set; }
 
         public override bool Execute()
         {
diff --git a/src/Tasks/Move.cs b/src/Tasks/Move.cs
index 1c9cec9c9af..9595157fc24 100644
--- a/src/Tasks/Move.cs
+++ b/src/Tasks/Move.cs
@@ -6,13 +6,12 @@
 //-----------------------------------------------------------------------
 
 using System;
-using System.Collections;
+using System.Collections.Generic;
 using System.IO;
+using System.Runtime.InteropServices;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
-using System.Runtime.InteropServices;
-using System.ComponentModel;
 
 namespace Microsoft.Build.Tasks
 {
@@ -34,11 +33,6 @@ public class Move : TaskExtension, ICancelableTask
                                                           NativeMethods.MoveFileFlags.MOVEFILE_REPLACE_EXISTING | // Replace any existing target
                                                           NativeMethods.MoveFileFlags.MOVEFILE_COPY_ALLOWED;      // Moving across volumes is allowed
 
-        /// <summary>
-        /// Subset of specified files that were actually moved
-        /// </summary>
-        private ITaskItem[] _movedFiles;
-
         /// <summary>
         /// Whether we should cancel.
         /// </summary>
@@ -48,50 +42,31 @@ public class Move : TaskExtension, ICancelableTask
         /// List of files to move.
         /// </summary>
         [Required]
-        public ITaskItem[] SourceFiles
-        {
-            get;
-            set;
-        }
+        public ITaskItem[] SourceFiles { get; set; }
 
         /// <summary>
         /// Destination folder for all the source files.
         /// </summary>
-        public ITaskItem DestinationFolder
-        {
-            get;
-            set;
-        }
+        public ITaskItem DestinationFolder { get; set; }
 
         /// <summary>
         /// Whether to overwrite files in the destination
         /// that have the read-only attribute set.
         /// Default is to not overwrite.
         /// </summary>
-        public bool OverwriteReadOnlyFiles
-        {
-            get;
-            set;
-        }
+        public bool OverwriteReadOnlyFiles { get; set; }
 
         /// <summary>
         /// Destination files matching each of the source files.
         /// </summary>
         [Output]
-        public ITaskItem[] DestinationFiles
-        {
-            get;
-            set;
-        }
+        public ITaskItem[] DestinationFiles { get; set; }
 
         /// <summary>
         /// Subset that were successfully moved 
         /// </summary>
         [Output]
-        public ITaskItem[] MovedFiles
-        {
-            get { return _movedFiles; }
-        }
+        public ITaskItem[] MovedFiles { get; private set; }
 
         /// <summary>
         /// Stop and return (in an undefined state) as soon as possible.
@@ -111,8 +86,8 @@ public override bool Execute()
             // If there are no source files then just return success.
             if (SourceFiles == null || SourceFiles.Length == 0)
             {
-                DestinationFiles = Array.Empty<TaskItem>();
-                _movedFiles = Array.Empty<TaskItem>();
+                DestinationFiles = Array.Empty<ITaskItem>();
+                MovedFiles = Array.Empty<ITaskItem>();
                 return true;
             }
 
@@ -165,7 +140,7 @@ public override bool Execute()
             }
 
             // Build up the sucessfully moved subset
-            ArrayList destinationFilesSuccessfullyMoved = new ArrayList();
+            var destinationFilesSuccessfullyMoved = new List<ITaskItem>();
 
             // Now that we have a list of DestinationFolder files, move from source to DestinationFolder.
             for (int i = 0; i < SourceFiles.Length && !_canceling; ++i)
@@ -195,7 +170,7 @@ public override bool Execute()
             }
 
             // MovedFiles contains only the copies that were successful.
-            _movedFiles = (ITaskItem[])destinationFilesSuccessfullyMoved.ToArray(typeof(ITaskItem));
+            MovedFiles = destinationFilesSuccessfullyMoved.ToArray();
 
             return success && !_canceling;
         }
@@ -205,7 +180,7 @@ public override bool Execute()
         /// </summary>
         private static void MakeWriteableIfReadOnly(string file)
         {
-            FileInfo info = new FileInfo(file);
+            var info = new FileInfo(file);
             if ((info.Attributes & FileAttributes.ReadOnly) != 0)
             {
                 info.Attributes = info.Attributes & ~FileAttributes.ReadOnly;
@@ -252,7 +227,7 @@ string destinationFile
 
             string destinationFolder = Path.GetDirectoryName(destinationFile);
 
-            if (destinationFolder != null && destinationFolder.Length > 0 && !Directory.Exists(destinationFolder))
+            if (!string.IsNullOrEmpty(destinationFolder) && !Directory.Exists(destinationFolder))
             {
                 Log.LogMessageFromResources(MessageImportance.Normal, "Move.CreatesDirectory", destinationFolder);
                 Directory.CreateDirectory(destinationFolder);
@@ -278,7 +253,7 @@ string destinationFile
                 // which is unfortunately internal.
                 // So try to get a nice message by using the BCL Move(), which will likely fail
                 // and throw. Otherwise use the "correct" method.
-                System.IO.File.Move(sourceFile, destinationFile);
+                File.Move(sourceFile, destinationFile);
 
                 // Apparently that didn't throw, so..
                 Marshal.ThrowExceptionForHR(Marshal.GetHRForLastWin32Error());
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index ac8d9168410..dddb4c473b8 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -23,7 +23,7 @@ namespace Microsoft.Build.Tasks
     /// for use until the one in the CLR is fixed. When it is we can go back to using ITypeInfo.
     /// </summary>
     [Guid("00020401-0000-0000-C000-000000000046")]
-    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
+    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
     [ComImport]
     public interface IFixedTypeInfo
     {
@@ -101,7 +101,7 @@ internal interface IMetaDataImport
         // actually returns void, not HRESULT.
         [PreserveSig]
         void CloseEnum();
-        void CountEnum(IntPtr iRef, ref System.UInt32 ulCount);
+        void CountEnum(IntPtr iRef, ref UInt32 ulCount);
         void ResetEnum();
         void EnumTypeDefs();
         void EnumInterfaceImpls();
@@ -261,8 +261,8 @@ internal interface IMetaDataAssemblyImport
         void GetFileProps([In] UInt32 mdFile, [MarshalAs(UnmanagedType.LPArray)] char[] strName, UInt32 cchName, out UInt32 cchNameRequired, out IntPtr bHashData, out UInt32 cchHashBytes, out UInt32 dwFileFlags);
         void GetExportedTypeProps();
         void GetManifestResourceProps();
-        void EnumAssemblyRefs([In, Out] ref IntPtr phEnum, [MarshalAs(UnmanagedType.LPArray), Out] UInt32[] asmRefs, System.UInt32 asmRefCount, out System.UInt32 iFetched);
-        void EnumFiles([In, Out] ref IntPtr phEnum, [MarshalAs(UnmanagedType.LPArray), Out] UInt32[] fileRefs, System.UInt32 fileRefCount, out System.UInt32 iFetched);
+        void EnumAssemblyRefs([In, Out] ref IntPtr phEnum, [MarshalAs(UnmanagedType.LPArray), Out] UInt32[] asmRefs, UInt32 asmRefCount, out UInt32 iFetched);
+        void EnumFiles([In, Out] ref IntPtr phEnum, [MarshalAs(UnmanagedType.LPArray), Out] UInt32[] fileRefs, UInt32 fileRefCount, out UInt32 iFetched);
         void EnumExportedTypes();
         void EnumManifestResources();
         void GetAssemblyFromScope(out UInt32 mdAsm);
@@ -340,32 +340,32 @@ internal struct ASSEMBLY_INFO
         public uint cchBuf;
     }
 
-    [ComImport(), Guid("E707DCDE-D1CD-11D2-BAB9-00C04F8ECEAE"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
+    [ComImport, Guid("E707DCDE-D1CD-11D2-BAB9-00C04F8ECEAE"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
     internal interface IAssemblyCache
     {
         /* Unused.
-        [PreserveSig()]
+        [PreserveSig]
         int UninstallAssembly(uint dwFlags, [MarshalAs(UnmanagedType.LPWStr)] string pszAssemblyName, IntPtr pvReserved, int pulDisposition);
          */
         int UninstallAssembly();
 
-        [PreserveSig()]
+        [PreserveSig]
         uint QueryAssemblyInfo(uint dwFlags, [MarshalAs(UnmanagedType.LPWStr)] string pszAssemblyName, ref ASSEMBLY_INFO pAsmInfo);
 
         /* Unused.
-        [PreserveSig()]
+        [PreserveSig]
         int CreateAssemblyCacheItem(uint dwFlags, IntPtr pvReserved, out object ppAsmItem, [MarshalAs(UnmanagedType.LPWStr)] string pszAssemblyName);
          */
         int CreateAssemblyCacheItem();
 
         /* Unused.
-        [PreserveSig()]
+        [PreserveSig]
         int CreateAssemblyScavenger(out object ppAsmScavenger);
          */
         int CreateAssemblyScavenger();
 
         /* Unused.
-        [PreserveSig()]
+        [PreserveSig]
         int InstallAssembly(uint dwFlags, [MarshalAs(UnmanagedType.LPWStr)] string pszManifestFilePath, IntPtr pvReserved);
          */
         int InstallAssembly();
@@ -382,28 +382,28 @@ internal enum AssemblyCacheFlags
     [ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("CD193BC0-B4BC-11d2-9833-00C04FC31D2E")]
     internal interface IAssemblyName
     {
-        [PreserveSig()]
+        [PreserveSig]
         int SetProperty(
                 int PropertyId,
                 IntPtr pvProperty,
                 int cbProperty);
 
-        [PreserveSig()]
+        [PreserveSig]
         int GetProperty(
                 int PropertyId,
                 IntPtr pvProperty,
                 ref int pcbProperty);
 
-        [PreserveSig()]
+        [PreserveSig]
         int Finalize();
 
-        [PreserveSig()]
+        [PreserveSig]
         int GetDisplayName(
                 StringBuilder pDisplayName,
                 ref int pccDisplayName,
                 int displayFlags);
 
-        [PreserveSig()]
+        [PreserveSig]
         int Reserved(ref Guid guid,
             Object obj1,
             Object obj2,
@@ -413,35 +413,35 @@ int Reserved(ref Guid guid,
             int cbReserved,
             out IntPtr ppv);
 
-        [PreserveSig()]
+        [PreserveSig]
         int GetName(
                 ref int pccBuffer,
                 StringBuilder pwzName);
 
-        [PreserveSig()]
+        [PreserveSig]
         int GetVersion(
                 out int versionHi,
                 out int versionLow);
-        [PreserveSig()]
+        [PreserveSig]
         int IsEqual(
                 IAssemblyName pAsmName,
                 int cmpFlags);
 
-        [PreserveSig()]
+        [PreserveSig]
         int Clone(out IAssemblyName pAsmName);
     }// IAssemblyName
 
     [ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("21b8916c-f28e-11d2-a473-00c04f8ef448")]
     internal interface IAssemblyEnum
     {
-        [PreserveSig()]
+        [PreserveSig]
         int GetNextAssembly(
                 IntPtr pvReserved,
                 out IAssemblyName ppName,
                 int flags);
-        [PreserveSig()]
+        [PreserveSig]
         int Reset();
-        [PreserveSig()]
+        [PreserveSig]
         int Clone(out IAssemblyEnum ppEnum);
     }// IAssemblyEnum
 
@@ -516,7 +516,7 @@ internal static class NativeMethods
         #region Constants
 
         internal static readonly IntPtr NullPtr = IntPtr.Zero;
-        internal static readonly IntPtr InvalidIntPtr = new IntPtr((int)-1);
+        internal static readonly IntPtr InvalidIntPtr = new IntPtr(-1);
 
         internal const uint NORMAL_PRIORITY_CLASS = 0x0020;
         internal const uint CREATE_NO_WINDOW = 0x08000000;
@@ -870,7 +870,7 @@ internal static bool MoveFileEx(string existingFileName, string newFileName, Mov
 
             if (targetExists && (File.GetAttributes(newFileName) & FileAttributes.ReadOnly) == FileAttributes.ReadOnly)
             {
-                throw new System.IO.IOException("Moving target is read-only");
+                throw new IOException("Moving target is read-only");
             }
 
             if (string.Equals(existingFileName, newFileName, StringComparison.Ordinal))
@@ -1295,7 +1295,7 @@ internal enum AssemblyComparisonResult
         //------------------------------------------------------------------------------
         [DllImport(Advapi32DLL, SetLastError = true)]
         [return: MarshalAs(UnmanagedType.Bool)]
-        internal extern static bool CryptReleaseContext([In] IntPtr Prov, [In] uint Flags);
+        internal static extern bool CryptReleaseContext([In] IntPtr Prov, [In] uint Flags);
 
         //------------------------------------------------------------------------------
         // CertFreeCertificateContext
@@ -1452,12 +1452,12 @@ internal class AssemblyCacheEnum : IEnumerable<AssemblyNameExtension>
             /// <summary>
             /// Path to the gac
             /// </summary>
-            private static string s_gacPath = Path.Combine(NativeMethodsShared.FrameworkBasePath, "gac");
+            private static readonly string s_gacPath = Path.Combine(NativeMethodsShared.FrameworkBasePath, "gac");
 
             /// <summary>
             /// Regex for directory version parsing
             /// </summary>
-            private static Regex s_assemblyVersionRegex = new Regex(
+            private static readonly Regex s_assemblyVersionRegex = new Regex(
                 @"^([.\d]+)_([^_]*)_([a-fA-F\d]{16})$",
                 RegexOptions.CultureInvariant | RegexOptions.Compiled);
 
@@ -1555,9 +1555,6 @@ public IEnumerator<AssemblyNameExtension> GetEnumerator()
             {
                 if (NativeMethodsShared.IsWindows)
                 {
-                    int hr = 0;
-                    IAssemblyName fusionName = null;
-
                     if (_assemblyEnum == null)
                     {
                         yield break;
@@ -1571,7 +1568,7 @@ public IEnumerator<AssemblyNameExtension> GetEnumerator()
                     while (!_done)
                     {
                         // Now get next IAssemblyName from m_AssemblyEnum
-                        hr = _assemblyEnum.GetNextAssembly((IntPtr)0, out fusionName, 0);
+                        int hr = _assemblyEnum.GetNextAssembly((IntPtr)0, out IAssemblyName fusionName, 0);
 
                         if (hr < 0)
                         {
@@ -1652,7 +1649,7 @@ private static string GetFullName(IAssemblyName fusionAsmName)
 
             IEnumerator IEnumerable.GetEnumerator()
             {
-                return (IEnumerator)GetEnumerator();
+                return GetEnumerator();
             }
 
             public static string AssemblyPathFromStrongName(string strongName)
diff --git a/src/Tasks/ParserState.cs b/src/Tasks/ParserState.cs
index 80148a3affe..618da02cd24 100644
--- a/src/Tasks/ParserState.cs
+++ b/src/Tasks/ParserState.cs
@@ -2,134 +2,85 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
 using System.Text;
-using System.Resources;
-using System.Reflection;
 using System.Collections;
 
 namespace Microsoft.Build.Tasks
 {
-    /*
-    * Class:   ParseState
-    *
-    * State used by the c# and vb parsers. Maintains information about
-    * what's being parsed and what has been seen so far.
-    *
-    */
-    sealed internal class ParseState
+    /// <summary>
+    /// State used by the c# and vb parsers. Maintains information about
+    /// what's being parsed and what has been seen so far.
+    /// </summary>
+    internal sealed class ParseState
     {
-        // Currently resolving a namespace name?
-        private bool _resolvingNamespace;
-        // Currently resolving a class name?
-        private bool _resolvingClass;
         // Currently inside an open conditional preprocessor directive?
-        private int _openConditionalDirectives = 0;
-        // The current namespace name as its being resolved.
-        private string _namespaceName;
+        private int _openConditionalDirectives;
+
         // A stack of namespaces so that nested namespaces can be supported.
-        private Stack _namespaceStack = new Stack();
+        private readonly Stack _namespaceStack = new Stack();
 
-        /*
-        * Method:  ParseState
-        * 
-        * Construct.
-        */
         internal ParseState()
         {
             Reset();
         }
 
-        /*
-        * Method:  ResolvingNamespace
-        * 
-        * Get or set the ResolvingNamespace property.
-        */
-        internal bool ResolvingNamespace
-        {
-            get { return _resolvingNamespace; }
-            set { _resolvingNamespace = value; }
-        }
+        /// <summary>
+        /// Are we resolving a namespace?
+        /// </summary>
+        internal bool ResolvingNamespace { get; set; }
 
-        /*
-        * Method:  ResolvingClass
-        * 
-        * Get or set the ResolvingClass property.
-        */
-        internal bool ResolvingClass
-        {
-            get { return _resolvingClass; }
-            set { _resolvingClass = value; }
-        }
+        /// <summary>
+        /// Are we resolving a class?
+        /// </summary>
+        internal bool ResolvingClass { get; set; }
 
-        /*
-        * Method:  InsideConditionalDirective
-        * 
-        * Get the InsideConditionalDirective property.
-        */
-        internal bool InsideConditionalDirective
-        {
-            get { return _openConditionalDirectives > 0; }
-        }
+        /// <summary>
+        /// Are we inside a conditional directive?
+        /// </summary>
+        internal bool InsideConditionalDirective => _openConditionalDirectives > 0;
 
-        /*
-        * Method:  Namespace
-        * 
-        * Get or set the Namespace property.
-        */
-        internal string Namespace
-        {
-            get { return _namespaceName; }
-            set { _namespaceName = value; }
-        }
+        /// <summary>
+        /// The current namespace name as its being resolved.
+        /// </summary>
+        internal string Namespace { get; set; }
 
-        /*
-        * Method:  Reset
-        * 
-        * Reset the state, but don't throw away namespace stack information.
-        */
+        /// <summary>
+        /// Reset the state, but don't throw away namespace stack information.
+        /// </summary>
         internal void Reset()
         {
-            _resolvingNamespace = false;
-            _resolvingClass = false;
-            _namespaceName = String.Empty;
+            ResolvingNamespace = false;
+            ResolvingClass = false;
+            Namespace = String.Empty;
         }
 
-        /*
-         * Method:  OpenConditionalDirective
-         * 
-         * Note that we've entered a conditional directive
-         */
+        /// <summary>
+        /// Note that we've entered a conditional directive
+        /// </summary>
         internal void OpenConditionalDirective()
         {
             _openConditionalDirectives++;
         }
 
-        /*
-         * Method:  CloseConditionalDirective
-         * 
-         * Note that we've exited a conditional directive
-         */
+        /// <summary>
+        /// Note that we've exited a conditional directive
+        /// </summary>
         internal void CloseConditionalDirective()
         {
             _openConditionalDirectives--;
         }
 
-        /*
-        * Method:  PushNamespacePart
-        * 
-        * Push a namespace element onto the stack. May be null.
-        */
+        /// <summary>
+        /// Push a namespace element onto the stack. May be null.
+        /// </summary>
         internal void PushNamespacePart(string namespacePart)
         {
             _namespaceStack.Push(namespacePart);
         }
 
-        /*
-        * Method:  PopNamespacePart
-        * 
-        * Pop a namespace element from the stack. May be null.
-        */
+        /// <summary>
+        /// Pop a namespace element from the stack. May be null.
+        /// </summary>
         internal string PopNamespacePart()
         {
             if (_namespaceStack.Count == 0)
@@ -140,18 +91,15 @@ internal string PopNamespacePart()
             return (string)_namespaceStack.Pop();
         }
 
-        /*
-        * Method:  ComposeQualifiedClassName
-        * 
-        * Build a fully qualified (i.e. with the namespace) class name
-        * base on the contents of the stack.
-        */
+        /// <summary>
+        /// Build a fully qualified (i.e. with the namespace) class name based on the contents of the stack.
+        /// </summary>
         internal string ComposeQualifiedClassName(string className)
         {
-            StringBuilder fullClass = new StringBuilder(1024);
+            var fullClass = new StringBuilder(1024);
             foreach (string namespacePiece in _namespaceStack)
             {
-                if (null != namespacePiece && namespacePiece.Length > 0)
+                if (!string.IsNullOrEmpty(namespacePiece))
                 {
                     fullClass.Insert(0, '.');
                     fullClass.Insert(0, namespacePiece);
diff --git a/src/Tasks/PiaReference.cs b/src/Tasks/PiaReference.cs
index 890ca60c5e9..2b7f06b86ca 100644
--- a/src/Tasks/PiaReference.cs
+++ b/src/Tasks/PiaReference.cs
@@ -11,20 +11,13 @@
 
 namespace Microsoft.Build.Tasks
 {
-    /*
-     * Class:   PiaReference
-     * 
-     * COM reference wrapper class for the tlbimp tool using a PIA.
-     *
-     */
+    /// <summary>
+    /// COM reference wrapper class for the tlbimp tool using a PIA. 
+    /// </summary>
     internal sealed class PiaReference : ComReference
     {
         #region Constructors
 
-        /*
-         * Method:  PiaReference constructor
-         * 
-         */
         internal PiaReference(TaskLoggingHelper taskLoggingHelper, bool silent, ComReferenceInfo referenceInfo, string itemName)
             : base(taskLoggingHelper, silent, referenceInfo, itemName)
         {
@@ -35,21 +28,18 @@ internal PiaReference(TaskLoggingHelper taskLoggingHelper, bool silent, ComRefer
 
         #region Methods
 
-        /*
-         * Method:  Resolve
-         * 
-         * Gets the resolved assembly path for the typelib wrapper.
-         */
+        /// <summary>
+        /// Gets the resolved assembly path for the typelib wrapper.
+        /// </summary>
         internal override bool FindExistingWrapper(out ComReferenceWrapperInfo wrapperInfo, DateTime componentTimestamp)
         {
             wrapperInfo = null;
 
             // Let NDP do the dirty work...
             TypeLibConverter converter = new TypeLibConverter();
-            string asmName, asmCodeBase;
 
             if (!converter.GetPrimaryInteropAssembly(ReferenceInfo.attr.guid, ReferenceInfo.attr.wMajorVerNum, ReferenceInfo.attr.wMinorVerNum, ReferenceInfo.attr.lcid,
-                out asmName, out asmCodeBase))
+                out string asmName, out string asmCodeBase))
             {
                 return false;
             }
@@ -57,35 +47,39 @@ internal override bool FindExistingWrapper(out ComReferenceWrapperInfo wrapperIn
             // let's try to load the assembly to determine its path and if it's there
             try
             {
-                if (asmCodeBase != null && asmCodeBase.Length > 0)
+                if (!string.IsNullOrEmpty(asmCodeBase))
                 {
-                    Uri uri = new Uri(asmCodeBase);
+                    var uri = new Uri(asmCodeBase);
 
                     // make sure the PIA can be loaded
                     Assembly assembly = Assembly.UnsafeLoadFrom(uri.LocalPath);
 
                     // got here? then assembly must have been loaded successfully.
-                    wrapperInfo = new ComReferenceWrapperInfo();
-                    wrapperInfo.path = uri.LocalPath;
-                    wrapperInfo.assembly = assembly;
-
-                    // We need to remember the original assembly name of this PIA in case it gets redirected to a newer 
-                    // version and other COM components use that name to reference the PIA. assembly.FullName wouldn't
-                    // work here since we'd get the redirected assembly name.
-                    wrapperInfo.originalPiaName = new AssemblyNameExtension(AssemblyName.GetAssemblyName(uri.LocalPath));
+                    wrapperInfo = new ComReferenceWrapperInfo
+                    {
+                        path = uri.LocalPath,
+                        assembly = assembly,
+
+                        // We need to remember the original assembly name of this PIA in case it gets redirected to a newer 
+                        // version and other COM components use that name to reference the PIA. assembly.FullName wouldn't
+                        // work here since we'd get the redirected assembly name.
+                        originalPiaName = new AssemblyNameExtension(AssemblyName.GetAssemblyName(uri.LocalPath))
+                    };
                 }
                 else
                 {
                     Assembly assembly = Assembly.Load(asmName);
 
                     // got here? then assembly must have been loaded successfully.
-                    wrapperInfo = new ComReferenceWrapperInfo();
-                    wrapperInfo.path = assembly.Location;
-                    wrapperInfo.assembly = assembly;
-
-                    // We need to remember the original assembly name of this PIA in case it gets redirected to a newer 
-                    // version and other COM components use that name to reference the PIA. 
-                    wrapperInfo.originalPiaName = new AssemblyNameExtension(asmName, true);
+                    wrapperInfo = new ComReferenceWrapperInfo
+                    {
+                        path = assembly.Location,
+                        assembly = assembly,
+
+                        // We need to remember the original assembly name of this PIA in case it gets redirected to a newer 
+                        // version and other COM components use that name to reference the PIA. 
+                        originalPiaName = new AssemblyNameExtension(asmName, true)
+                    };
                 }
             }
             catch (FileNotFoundException)
