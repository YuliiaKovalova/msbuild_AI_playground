diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 1f773903ed9..a554ecfd951 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -357,10 +357,6 @@
     <Compile Include="..\Shared\CollectionHelpers.cs" />
     <Compile Include="Collections\ConvertingEnumerable.cs" />
     <Compile Include="Collections\CopyOnReadEnumerable.cs" />
-    <Compile Include="..\Shared\IInternable.cs" />
-    <Compile Include="..\Shared\WeakStringCache.cs" />
-    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs" />
-    <Compile Include="..\Shared\OpportunisticIntern.cs" />
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs">
       <Link>Collections\CopyOnWriteDictionary.cs</Link>
     </Compile>
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index a75bbeff256..98f08298b0b 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -133,10 +133,6 @@
     <Compile Include="..\Shared\BinaryTranslator.cs" />
     <Compile Include="..\Shared\CommunicationsUtilities.cs" />
     <Compile Include="..\Shared\InterningBinaryReader.cs" />
-    <Compile Include="..\Shared\IInternable.cs" />
-    <Compile Include="..\Shared\WeakStringCache.cs" />
-    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs" />
-    <Compile Include="..\Shared\OpportunisticIntern.cs" />
     <Compile Include="..\Shared\TaskHostConfiguration.cs" />
     <Compile Include="..\Shared\TaskHostTaskComplete.cs" />
     <Compile Include="..\Shared\OutOfProcTaskHostTaskResult.cs" />
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 901c6a53a8e..0437fdcbb36 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -129,15 +129,6 @@
     <Compile Include="..\Shared\NodeShutdown.cs">
       <Link>NodeShutdown.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\IInternable.cs">
-      <Link>IInternable.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\WeakStringCache.cs">
-      <Link>WeakStringCache.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\OpportunisticIntern.cs">
-      <Link>OpportunisticIntern.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\ReadOnlyEmptyCollection.cs">
       <Link>ReadOnlyEmptyCollection.cs</Link>
     </Compile>
@@ -169,7 +160,6 @@
     <Compile Include="Immutable\ImmutableDictionary.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
     <Compile Include="TypeLoader.cs" />
-    <Compile Include="WeakStringCache.Locking.cs" />
     <Compile Include="..\MSBuild\LogMessagePacket.cs">
       <Link>LogMessagePacket.cs</Link>
     </Compile>
diff --git a/src/MSBuildTaskHost/WeakStringCache.Locking.cs b/src/MSBuildTaskHost/WeakStringCache.Locking.cs
deleted file mode 100644
index d26dd984963..00000000000
--- a/src/MSBuildTaskHost/WeakStringCache.Locking.cs
+++ /dev/null
@@ -1,125 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-using System.Collections.Generic;
-
-namespace Microsoft.Build
-{
-    /// <summary>
-    /// Implements the WeakStringCache functionality on .NET Framework 3.5 where ConcurrentDictionary is not available.
-    /// </summary>
-    internal sealed partial class WeakStringCache : IDisposable
-    {
-        private readonly Dictionary<int, StringWeakHandle> _stringsByHashCode;
-
-        public WeakStringCache()
-        {
-            _stringsByHashCode = new Dictionary<int, StringWeakHandle>(_initialCapacity);
-        }
-
-        /// <summary>
-        /// Main entrypoint of this cache. Tries to look up a string that matches the given internable. If it succeeds, returns
-        /// the string and sets cacheHit to true. If the string is not found, calls ExpensiveConvertToString on the internable,
-        /// adds the resulting string to the cache, and returns it, setting cacheHit to false.
-        /// </summary>
-        /// <param name="internable">The internable describing the string we're looking for.</param>
-        /// <returns>A string matching the given internable.</returns>
-        public string GetOrCreateEntry<T>(T internable, out bool cacheHit) where T : IInternable
-        {
-            int hashCode = GetInternableHashCode(internable);
-
-            StringWeakHandle handle;
-            string result;
-            bool addingNewHandle = false;
-
-            lock (_stringsByHashCode)
-            {
-                if (_stringsByHashCode.TryGetValue(hashCode, out handle))
-                {
-                    result = handle.GetString(internable);
-                    if (result != null)
-                    {
-                        cacheHit = true;
-                        return result;
-                    }
-                }
-                else
-                {
-                    handle = new StringWeakHandle();
-                    addingNewHandle = true;
-                }
-
-                // We don't have the string in the cache - create it.
-                result = internable.ExpensiveConvertToString();
-
-                // Set the handle to reference the new string.
-                handle.SetString(result);
-
-                if (addingNewHandle)
-                {
-                    // Prevent the dictionary from growing forever with GC handles that don't reference live strings anymore.
-                    if (_stringsByHashCode.Count >= _scavengeThreshold)
-                    {
-                        // Get rid of unused handles.
-                        ScavengeNoLock();
-                        // And do this again when the number of handles reaches double the current after-scavenge number.
-                        _scavengeThreshold = _stringsByHashCode.Count * 2;
-                    }
-                }
-                _stringsByHashCode[hashCode] = handle;
-            }
-
-            cacheHit = false;
-            return result;
-        }
-
-        /// <summary>
-        /// Iterates over the cache and removes unused GC handles, i.e. handles that don't reference live strings.
-        /// This is expensive so try to call such that the cost is amortized to O(1) per GetOrCreateEntry() invocation.
-        /// Assumes the lock is taken by the caller.
-        /// </summary>
-        private void ScavengeNoLock()
-        {
-            List<int> keysToRemove = null;
-            foreach (KeyValuePair<int, StringWeakHandle> entry in _stringsByHashCode)
-            {
-                if (!entry.Value.IsUsed)
-                {
-                    entry.Value.Free();
-                    keysToRemove ??= new List<int>();
-                    keysToRemove.Add(entry.Key);
-                }
-            }
-            if (keysToRemove != null)
-            {
-                for (int i = 0; i < keysToRemove.Count; i++)
-                {
-                    _stringsByHashCode.Remove(keysToRemove[i]);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Public version of ScavengeUnderLock() which takes the lock.
-        /// </summary>
-        public void Scavenge()
-        {
-            lock (_stringsByHashCode)
-            {
-                ScavengeNoLock();
-            }
-        }
-
-        /// <summary>
-        /// Returns internal debug counters calculated based on the current state of the cache.
-        /// </summary>
-        public DebugInfo GetDebugInfo()
-        {
-            lock (_stringsByHashCode)
-            {
-                return GetDebugInfoImpl();
-            }
-        }
-    }
-}
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index 42f82771737..d8b2c66c98d 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -60,8 +60,6 @@ internal static class MSBuildConstants
         /// </summary>
         internal const string CurrentToolsVersion = "Current";
 
-        // if you change the key also change the following clones
-        // Microsoft.Build.OpportunisticIntern.BucketedPrioritizedStringList.TryIntern
         internal const string MSBuildDummyGlobalPropertyHeader = "MSBuildProjectInstance";
 
         /// <summary>
diff --git a/src/Shared/IInternable.cs b/src/Shared/IInternable.cs
deleted file mode 100644
index 9bfa741e097..00000000000
--- a/src/Shared/IInternable.cs
+++ /dev/null
@@ -1,341 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-using System.Text;
-using Microsoft.Build.Shared;
-
-namespace Microsoft.Build
-{
-    #region IInternable
-    /// <summary>
-    /// Define the methods needed to intern something.
-    /// </summary>
-    internal interface IInternable
-    {
-        /// <summary>
-        /// The length of the target.
-        /// </summary>
-        int Length { get; }
-
-        /// <summary>
-        /// Indexer into the target. Presumed to be fast.
-        /// </summary>
-        char this[int index] { get; }
-
-        /// <summary>
-        /// Convert target to string. Presumed to be slow (and will be called just once).
-        /// </summary>
-        string ExpensiveConvertToString();
-
-        /// <summary>
-        /// Compare target to string. Assumes string is of equal or smaller length than target.
-        /// </summary>
-        bool StartsWithStringByOrdinalComparison(string other);
-
-        /// <summary>
-        /// Reference compare target to string. If target is non-string this should return false.
-        /// </summary>
-        bool ReferenceEquals(string other);
-    }
-    #endregion
-
-
-    #region IInternable Implementations
-    /// <summary>
-    /// A wrapper over StringBuilder.
-    /// </summary>
-    internal readonly struct StringBuilderInternTarget : IInternable
-    {
-        /// <summary>
-        /// The held StringBuilder
-        /// </summary>
-        private readonly StringBuilder _target;
-
-        /// <summary>
-        /// Pointless comment about constructor.
-        /// </summary>
-        internal StringBuilderInternTarget(StringBuilder target)
-        {
-            _target = target;
-        }
-
-        /// <summary>
-        /// The length of the target.
-        /// </summary>
-        public int Length => _target.Length;
-
-        /// <summary>
-        /// Indexer into the target. Presumed to be fast.
-        /// </summary>
-        public char this[int index] => _target[index];
-
-        /// <summary>
-        /// Never reference equals to string.
-        /// </summary>
-        public bool ReferenceEquals(string other) => false;
-
-        /// <summary>
-        /// Convert target to string. Presumed to be slow (and will be called just once).
-        /// </summary>
-        public string ExpensiveConvertToString()
-        {
-            // PERF NOTE: This will be an allocation hot-spot because the StringBuilder is finally determined to
-            // not be internable. There is still only one conversion of StringBuilder into string it has just
-            // moved into this single spot.
-            return _target.ToString();
-        }
-
-        /// <summary>
-        /// Compare target to string. Assumes string is of equal or smaller length than target.
-        /// </summary>
-        public bool StartsWithStringByOrdinalComparison(string other)
-        {
-#if DEBUG
-            ErrorUtilities.VerifyThrow(other.Length <= _target.Length, "should be at most as long as target");
-#endif
-            int length = other.Length;
-
-            // Backwards because the end of the string is more likely to be different earlier in the loop.
-            // For example, C:\project1, C:\project2
-            for (int i = length - 1; i >= 0; --i)
-            {
-                if (_target[i] != other[i])
-                {
-                    return false;
-                }
-            }
-
-            return true;
-        }
-
-        /// <summary>
-        /// Don't use this function. Use ExpensiveConvertToString
-        /// </summary>
-        public override string ToString() => throw new InvalidOperationException();
-    }
-
-    /// <summary>
-    /// A wrapper over char[].
-    /// </summary>
-    internal readonly struct CharArrayInternTarget : IInternable
-    {
-        /// <summary>
-        /// Start index for the string
-        /// </summary>
-        private readonly int _startIndex;
-
-        /// <summary>
-        /// The held array
-        /// </summary>
-        private readonly char[] _target;
-
-        /// <summary>
-        /// Pointless comment about constructor.
-        /// </summary>
-        internal CharArrayInternTarget(char[] target, int count)
-            : this(target, 0, count)
-        {
-        }
-
-        /// <summary>
-        /// Pointless comment about constructor.
-        /// </summary>
-        internal CharArrayInternTarget(char[] target, int startIndex, int count)
-        {
-#if DEBUG
-            if (startIndex + count > target.Length)
-            {
-                ErrorUtilities.ThrowInternalError("wrong length");
-            }
-#endif
-            _target = target;
-            _startIndex = startIndex;
-            Length = count;
-        }
-
-        /// <summary>
-        /// The length of the target.
-        /// </summary>
-        public int Length { get; }
-
-        /// <summary>
-        /// Indexer into the target. Presumed to be fast.
-        /// </summary>
-        public char this[int index]
-        {
-            get
-            {
-                return _target[index + _startIndex];
-            }
-        }
-
-        /// <summary>
-        /// Convert target to string. Presumed to be slow (and will be called just once).
-        /// </summary>
-        public bool ReferenceEquals(string other)
-        {
-            return false;
-        }
-
-        /// <summary>
-        /// Convert target to string. Presumed to be slow (and will be called just once).
-        /// </summary>
-        public string ExpensiveConvertToString()
-        {
-            // PERF NOTE: This will be an allocation hot-spot because the char[] is finally determined to
-            // not be internable. There is still only one conversion of char[] into string it has just
-            // moved into this single spot.
-            return new string(_target, _startIndex, Length);
-        }
-
-        /// <summary>
-        /// Compare target to string. Assumes string is of equal or smaller length than target.
-        /// </summary>
-        public bool StartsWithStringByOrdinalComparison(string other)
-        {
-#if DEBUG
-            ErrorUtilities.VerifyThrow(other.Length <= Length, "should be at most as long as target");
-#endif
-            // Backwards because the end of the string is (by observation of Australian Government build) more likely to be different earlier in the loop.
-            // For example, C:\project1, C:\project2
-            for (int i = other.Length - 1; i >= 0; --i)
-            {
-                if (_target[i + _startIndex] != other[i])
-                {
-                    return false;
-                }
-            }
-
-            return true;
-        }
-
-        /// <summary>
-        /// Don't use this function. Use ExpensiveConvertToString
-        /// </summary>
-        public override string ToString()
-        {
-            throw new InvalidOperationException();
-        }
-    }
-
-    /// <summary>
-    /// Wrapper over a string.
-    /// </summary>
-    internal readonly struct StringInternTarget : IInternable
-    {
-        /// <summary>
-        /// Stores the wrapped string.
-        /// </summary>
-        private readonly string _target;
-
-        /// <summary>
-        /// Constructor of the class
-        /// </summary>
-        /// <param name="target">The string to wrap</param>
-        internal StringInternTarget(string target)
-        {
-            ErrorUtilities.VerifyThrowArgumentLength(target, nameof(target));
-            _target = target;
-        }
-
-        /// <summary>
-        /// Gets the length of the target string.
-        /// </summary>
-        public int Length => _target.Length;
-
-        /// <summary>
-        /// Gets the n character in the target string.
-        /// </summary>
-        /// <param name="index">Index of the character to gather.</param>
-        /// <returns>The character in the position marked by index.</returns>
-        public char this[int index] => _target[index];
-
-        /// <summary>
-        /// Returns the target which is already a string.
-        /// </summary>
-        /// <returns>The target string.</returns>
-        public string ExpensiveConvertToString() => _target;
-
-        /// <summary>
-        /// Compare target to string. Assumes string is of equal or smaller length than target.
-        /// </summary>
-        /// <param name="other">The string to compare with the target.</param>
-        /// <returns>True if target starts with <paramref name="other"/>, false otherwise.</returns>
-        public bool StartsWithStringByOrdinalComparison(string other) => _target.StartsWith(other, StringComparison.Ordinal);
-
-        /// <summary>
-        /// Verifies if the reference of the target string is the same of the given string.
-        /// </summary>
-        /// <param name="other">The string reference to compare to.</param>
-        /// <returns>True if both references are equal, false otherwise.</returns>
-        public bool ReferenceEquals(string other) => ReferenceEquals(_target, other);
-    }
-
-    /// <summary>
-    /// Wrapper over a substring of a string.
-    /// </summary>
-    internal readonly struct SubstringInternTarget : IInternable
-    {
-        /// <summary>
-        /// Stores the wrapped string.
-        /// </summary>
-        private readonly string _target;
-
-        /// <summary>
-        /// Start index of the substring within the wrapped string.
-        /// </summary>
-        private readonly int _startIndex;
-
-        /// <summary>
-        /// Constructor of the class
-        /// </summary>
-        /// <param name="target">The string to wrap.</param>
-        /// <param name="startIndex">Start index of the substring within <paramref name="target"/>.</param>
-        /// <param name="length">Length of the substring.</param>
-        internal SubstringInternTarget(string target, int startIndex, int length)
-        {
-#if DEBUG
-            if (startIndex + length > target.Length)
-            {
-                ErrorUtilities.ThrowInternalError("wrong length");
-            }
-#endif
-            _target = target;
-            _startIndex = startIndex;
-            Length = length;
-        }
-
-        /// <summary>
-        /// Gets the length of the target substring.
-        /// </summary>
-        public int Length { get; }
-
-        /// <summary>
-        /// Gets the n character in the target substring.
-        /// </summary>
-        /// <param name="index">Index of the character to gather.</param>
-        /// <returns>The character in the position marked by index.</returns>
-        public char this[int index] => _target[index + _startIndex];
-
-        /// <summary>
-        /// Returns the target substring as a string.
-        /// </summary>
-        /// <returns>The substring.</returns>
-        public string ExpensiveConvertToString() => _target.Substring(_startIndex, Length);
-
-        /// <summary>
-        /// Compare target substring to a string. Assumes string is of equal or smaller length than the target substring.
-        /// </summary>
-        /// <param name="other">The string to compare with the target substring.</param>
-        /// <returns>True if target substring starts with <paramref name="other"/>, false otherwise.</returns>
-        public bool StartsWithStringByOrdinalComparison(string other) => String.CompareOrdinal(_target, _startIndex, other, 0, other.Length) == 0;
-
-        /// <summary>
-        /// Never reference equals to string.
-        /// </summary>
-        public bool ReferenceEquals(string other) => false;
-    }
-
-    #endregion
-}
diff --git a/src/Shared/OpportunisticIntern.cs b/src/Shared/OpportunisticIntern.cs
deleted file mode 100644
index 48d5d407c7c..00000000000
--- a/src/Shared/OpportunisticIntern.cs
+++ /dev/null
@@ -1,1093 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-#if !CLR2COMPATIBILITY
-using System.Collections.Concurrent;
-#endif
-using System.Text;
-using System.Linq;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Globalization;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
-
-namespace Microsoft.Build
-{
-    /// <summary>
-    /// This class is used to selectively intern strings. It should be used at the point of new string creation.
-    /// For example,
-    ///
-    ///     string interned = OpportunisticIntern.Intern(String.Join(",",someStrings));
-    ///
-    /// There are currently two underlying implementations. The new default one in WeakStringCacheInterner is based on weak GC handles.
-    /// The legacy one in BucketedPrioritizedStringList is available only as an escape hatch by setting an environment variable.
-    ///
-    /// The legacy implementation uses heuristics to decide whether it will be efficient to intern a string or not. There is no
-    /// guarantee that a string will intern.
-    ///
-    /// The thresholds and sizes were determined by experimentation to give the best number of bytes saved
-    /// at reasonable elapsed time cost.
-    ///
-    /// The new implementation interns all strings but maintains only weak references so it doesn't keep the strings alive.
-    /// </summary>
-    internal sealed class OpportunisticIntern
-    {
-        /// <summary>
-        /// Defines the interner interface as we currently implement more than one.
-        /// </summary>
-        private interface IInternerImplementation
-        {
-            /// <summary>
-            /// Converts the given internable candidate to its string representation. Efficient implementions have side-effects
-            /// of caching the results to end up with as few duplicates on the managed heap as practical.
-            /// </summary>
-            string InterningToString<T>(T candidate) where T : IInternable;
-
-            /// <summary>
-            /// Prints implementation specific interning statistics to the console.
-            /// </summary>
-            /// <param name="heading">A string identifying the interner in the output.</param>
-            void ReportStatistics(string heading);
-        }
-
-        /// <summary>
-        /// The singleton instance of OpportunisticIntern.
-        /// </summary>
-        private static OpportunisticIntern _instance = new OpportunisticIntern();
-        internal static OpportunisticIntern Instance => _instance;
-
-        private readonly bool _useLegacyInterner = Traits.Instance.UseLegacyStringInterner;
-        private readonly bool _useSimpleConcurrency = Traits.Instance.UseSimpleInternConcurrency;
-
-        /// <summary>
-        /// The size of the small mru list.
-        /// </summary>
-        private readonly int _smallMruSize;
-
-        /// <summary>
-        /// The size of the large mru list.
-        /// </summary>
-        private readonly int _largeMruSize;
-
-        /// <summary>
-        /// The size of the huge mru list.
-        /// </summary>
-        private readonly int _hugeMruSize;
-
-        /// <summary>
-        /// The smallest size a string can be to be considered small.
-        /// </summary>
-        private readonly int _smallMruThreshold;
-
-        /// <summary>
-        /// The smallest size a string can be to be considered large.
-        /// </summary>
-        private readonly int _largeMruThreshold;
-
-        /// <summary>
-        /// The smallest size a string can be to be considered huge.
-        /// </summary>
-        private readonly int _hugeMruThreshold;
-
-        /// <summary>
-        /// The smallest size a string can be to be ginormous.
-        /// 8K for large object heap.
-        /// </summary>
-        private readonly int _ginormousThreshold;
-
-        /// <summary>
-        /// The interner implementation in use.
-        /// </summary>
-        private IInternerImplementation _interner;
-
-        #region Statistics
-        /// <summary>
-        /// What if Mru lists were infinitely long?
-        /// </summary>
-        private BucketedPrioritizedStringList _whatIfInfinite;
-
-        /// <summary>
-        /// What if we doubled the size of the Mru lists?
-        /// </summary>
-        private BucketedPrioritizedStringList _whatIfDoubled;
-
-        /// <summary>
-        /// What if we halved the size of the Mru lists?
-        /// </summary>
-        private BucketedPrioritizedStringList _whatIfHalved;
-
-        /// <summary>
-        /// What if the size of Mru lists was zero? (We still intern tiny strings in this case)
-        /// </summary>
-        private BucketedPrioritizedStringList _whatIfZero;
-        #endregion
-
-        private OpportunisticIntern()
-        {
-            _smallMruSize = AssignViaEnvironment("MSBUILDSMALLINTERNSIZE", 50);
-            _largeMruSize = AssignViaEnvironment("MSBUILDLARGEINTERNSIZE", 100);
-            _hugeMruSize = AssignViaEnvironment("MSBUILDHUGEINTERNSIZE", 100);
-            _smallMruThreshold = AssignViaEnvironment("MSBUILDSMALLINTERNTHRESHOLD", 50);
-            _largeMruThreshold = AssignViaEnvironment("MSBUILDLARGEINTERNTHRESHOLD", 70);
-            _hugeMruThreshold = AssignViaEnvironment("MSBUILDHUGEINTERNTHRESHOLD", 200);
-            _ginormousThreshold = AssignViaEnvironment("MSBUILDGINORMOUSINTERNTHRESHOLD", 8000);
-
-            _interner = _useLegacyInterner
-               ? (IInternerImplementation)new BucketedPrioritizedStringList(gatherStatistics: false, _smallMruSize, _largeMruSize, _hugeMruSize,
-                    _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency)
-               : (IInternerImplementation)new WeakStringCacheInterner(gatherStatistics: false);
-        }
-
-        /// <summary>
-        /// Recreates the singleton instance based on the current environment (test only).
-        /// </summary>
-        internal static void ResetForTests()
-        {
-            Debug.Assert(BuildEnvironmentHelper.Instance.RunningTests);
-            _instance = new OpportunisticIntern();
-        }
-
-        /// <summary>
-        /// Assign an int from an environment variable. If its not present, use the default.
-        /// </summary>
-        private int AssignViaEnvironment(string env, int @default)
-        {
-            string threshold = Environment.GetEnvironmentVariable(env);
-            if (!string.IsNullOrEmpty(threshold))
-            {
-                if (int.TryParse(threshold, out int result))
-                {
-                    return result;
-                }
-            }
-
-            return @default;
-        }
-
-        /// <summary>
-        /// Turn on statistics gathering.
-        /// </summary>
-        internal void EnableStatisticsGathering()
-        {
-            if (_useLegacyInterner)
-            {
-                // Statistics include several 'what if' scenarios such as doubling the size of the MRU lists.
-                _interner = new BucketedPrioritizedStringList(gatherStatistics: true, _smallMruSize, _largeMruSize, _hugeMruSize, _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency);
-                _whatIfInfinite = new BucketedPrioritizedStringList(gatherStatistics: true, int.MaxValue, int.MaxValue, int.MaxValue, _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency);
-                _whatIfDoubled = new BucketedPrioritizedStringList(gatherStatistics: true, _smallMruSize * 2, _largeMruSize * 2, _hugeMruSize * 2, _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency);
-                _whatIfHalved = new BucketedPrioritizedStringList(gatherStatistics: true, _smallMruSize / 2, _largeMruSize / 2, _hugeMruSize / 2, _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency);
-                _whatIfZero = new BucketedPrioritizedStringList(gatherStatistics: true, 0, 0, 0, _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency);
-            }
-            else
-            {
-                _interner = new WeakStringCacheInterner(gatherStatistics: true);
-            }
-        }
-
-        /// <summary>
-        /// Intern the given internable.
-        /// </summary>
-        internal static string InternableToString<T>(T candidate) where T : IInternable
-        {
-            return Instance.InternableToStringImpl(candidate);
-        }
-
-        /// <summary>
-        /// Potentially Intern the given string builder.
-        /// </summary>
-        internal static string StringBuilderToString(StringBuilder candidate)
-        {
-            return Instance.InternableToStringImpl(new StringBuilderInternTarget(candidate));
-        }
-
-        /// <summary>
-        /// Potentially Intern the given char array.
-        /// </summary>
-        internal static string CharArrayToString(char[] candidate, int count)
-        {
-            return Instance.InternableToStringImpl(new CharArrayInternTarget(candidate, count));
-        }
-
-        /// <summary>
-        /// Potentially Intern the given char array.
-        /// </summary>
-        internal static string CharArrayToString(char[] candidate, int startIndex, int count)
-        {
-            return Instance.InternableToStringImpl(new CharArrayInternTarget(candidate, startIndex, count));
-        }
-
-        /// <summary>
-        /// Potentially Intern the given string.
-        /// </summary>
-        /// <param name="candidate">The string to intern.</param>
-        /// <returns>The interned string, or the same string if it could not be interned.</returns>
-        internal static string InternStringIfPossible(string candidate)
-        {
-            return Instance.InternableToStringImpl(new StringInternTarget(candidate));
-        }
-
-        /// <summary>
-        /// Intern the given internable.
-        /// </summary>
-        private string InternableToStringImpl<T>(T candidate) where T : IInternable
-        {
-            if (candidate.Length == 0)
-            {
-                // As in the case that a property or itemlist has evaluated to empty.
-                return string.Empty;
-            }
-
-            if (_whatIfInfinite != null)
-            {
-                _whatIfInfinite.InterningToString(candidate);
-                _whatIfDoubled.InterningToString(candidate);
-                _whatIfHalved.InterningToString(candidate);
-                _whatIfZero.InterningToString(candidate);
-            }
-
-            string result = _interner.InterningToString(candidate);
-#if DEBUG
-            string expected = candidate.ExpensiveConvertToString();
-            if (!String.Equals(result, expected))
-            {
-                ErrorUtilities.ThrowInternalError("Interned string {0} should have been {1}", result, expected);
-            }
-#endif
-            return result;
-        }
-
-        /// <summary>
-        /// Report statistics about interning. Don't call unless GatherStatistics has been called beforehand.
-        /// </summary>
-        internal void ReportStatistics()
-        {
-            _interner.ReportStatistics("Main");
-            if (_useLegacyInterner)
-            {
-                _whatIfInfinite.ReportStatistics("if Infinite");
-                _whatIfDoubled.ReportStatistics("if Doubled");
-                _whatIfHalved.ReportStatistics("if Halved");
-                _whatIfZero.ReportStatistics("if Zero");
-                Console.WriteLine(" * Even for MRU size of zero there will still be some intern hits because of the tiny ");
-                Console.WriteLine("   string matching (eg. 'true')");
-            }
-        }
-
-        private static bool TryInternHardcodedString<T>(T candidate, string str, ref string interned) where T : IInternable
-        {
-            Debug.Assert(candidate.Length == str.Length);
-
-            if (candidate.StartsWithStringByOrdinalComparison(str))
-            {
-                interned = str;
-                return true;
-            }
-            return false;
-        }
-
-        /// <summary>
-        /// Try to match the candidate with small number of hardcoded interned string literals.
-        /// The return value indicates how the string was interned (if at all).
-        /// </summary>
-        /// <returns>
-        /// True if the candidate matched a hardcoded literal, null if it matched a "do not intern" string, false otherwise.
-        /// </returns>
-        private static bool? TryMatchHardcodedStrings<T>(T candidate, out string interned) where T : IInternable
-        {
-            int length = candidate.Length;
-            interned = null;
-
-            // Each of the hard-coded small strings below showed up in a profile run with considerable duplication in memory.
-            if (length == 2)
-            {
-                if (candidate[1] == '#')
-                {
-                    if (candidate[0] == 'C')
-                    {
-                        interned = "C#";
-                        return true;
-                    }
-
-                    if (candidate[0] == 'F')
-                    {
-                        interned = "F#";
-                        return true;
-                    }
-                }
-
-                if (candidate[0] == 'V' && candidate[1] == 'B')
-                {
-                    interned = "VB";
-                    return true;
-                }
-            }
-            else if (length == 4)
-            {
-                if (TryInternHardcodedString(candidate, "TRUE", ref interned) ||
-                    TryInternHardcodedString(candidate, "True", ref interned) ||
-                    TryInternHardcodedString(candidate, "Copy", ref interned) ||
-                    TryInternHardcodedString(candidate, "true", ref interned) ||
-                    TryInternHardcodedString(candidate, "v4.0", ref interned))
-                {
-                    return true;
-                }
-            }
-            else if (length == 5)
-            {
-                if (TryInternHardcodedString(candidate, "FALSE", ref interned) ||
-                    TryInternHardcodedString(candidate, "false", ref interned) ||
-                    TryInternHardcodedString(candidate, "Debug", ref interned) ||
-                    TryInternHardcodedString(candidate, "Build", ref interned) ||
-                    TryInternHardcodedString(candidate, "Win32", ref interned))
-                {
-                    return true;
-                }
-            }
-            else if (length == 6)
-            {
-                if (TryInternHardcodedString(candidate, "''!=''", ref interned) ||
-                    TryInternHardcodedString(candidate, "AnyCPU", ref interned))
-                {
-                    return true;
-                }
-            }
-            else if (length == 7)
-            {
-                if (TryInternHardcodedString(candidate, "Library", ref interned) ||
-                    TryInternHardcodedString(candidate, "MSBuild", ref interned) ||
-                    TryInternHardcodedString(candidate, "Release", ref interned))
-                {
-                    return true;
-                }
-            }
-            // see Microsoft.Build.BackEnd.BuildRequestConfiguration.CreateUniqueGlobalProperty
-            else if (length > MSBuildConstants.MSBuildDummyGlobalPropertyHeader.Length &&
-                    candidate.StartsWithStringByOrdinalComparison(MSBuildConstants.MSBuildDummyGlobalPropertyHeader))
-            {
-                // don't want to leak unique strings into the cache
-                interned = candidate.ExpensiveConvertToString();
-                return null;
-            }
-            else if (length == 24)
-            {
-                if (TryInternHardcodedString(candidate, "ResolveAssemblyReference", ref interned))
-                {
-                    return true;
-                }
-            }
-            return false;
-        }
-
-        /// <summary>
-        /// Implements interning based on a WeakStringCache (new implementation).
-        /// </summary>
-        private class WeakStringCacheInterner : IInternerImplementation
-        {
-            /// <summary>
-            /// Enumerates the possible interning results.
-            /// </summary>
-            private enum InternResult
-            {
-                MatchedHardcodedString,
-                FoundInWeakStringCache,
-                AddedToWeakStringCache,
-                RejectedFromInterning
-            }
-
-            /// <summary>
-            /// The cache to keep strings in.
-            /// </summary>
-            private readonly WeakStringCache _weakStringCache = new WeakStringCache();
-
-#region Statistics
-            /// <summary>
-            /// Whether or not to gather statistics.
-            /// </summary>
-            private readonly bool _gatherStatistics;
-
-            /// <summary>
-            /// Number of times interning with hardcoded string literals worked.
-            /// </summary>
-            private int _hardcodedInternHits;
-
-            /// <summary>
-            /// Number of times the regular interning path found the string in the cache.
-            /// </summary>
-            private int _regularInternHits;
-
-            /// <summary>
-            /// Number of times the regular interning path added the string to the cache.
-            /// </summary>
-            private int _regularInternMisses;
-
-            /// <summary>
-            /// Number of times interning wasn't attempted.
-            /// </summary>
-            private int _rejectedStrings;
-
-            /// <summary>
-            /// Total number of strings eliminated by interning.
-            /// </summary>
-            private int _internEliminatedStrings;
-
-            /// <summary>
-            /// Total number of chars eliminated across all strings.
-            /// </summary>
-            private int _internEliminatedChars;
-
-            /// <summary>
-            /// Maps strings that went though the regular (i.e. not hardcoded) interning path to the number of times they have been
-            /// seen. The higher the number the better the payoff if the string had been hardcoded.
-            /// </summary>
-            private Dictionary<string, int> _missedHardcodedStrings;
-
-#endregion
-
-            public WeakStringCacheInterner(bool gatherStatistics)
-            {
-                if (gatherStatistics)
-                {
-                    _missedHardcodedStrings = new Dictionary<string, int>();
-                }
-                _gatherStatistics = gatherStatistics;
-            }
-
-            /// <summary>
-            /// Intern the given internable.
-            /// </summary>
-            public string InterningToString<T>(T candidate) where T : IInternable
-            {
-                if (_gatherStatistics)
-                {
-                    return InternWithStatistics(candidate);
-                }
-                else
-                {
-                    TryIntern(candidate, out string result);
-                    return result;
-                }
-            }
-
-            /// <summary>
-            /// Report statistics to the console.
-            /// </summary>
-            public void ReportStatistics(string heading)
-            {
-                string title = "Opportunistic Intern (" + heading + ")";
-                Console.WriteLine("\n{0}{1}{0}", new string('=', 41 - (title.Length / 2)), title);
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Hardcoded Hits", _hardcodedInternHits, "hits");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Hardcoded Rejects", _rejectedStrings, "rejects");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "WeakStringCache Hits", _regularInternHits, "hits");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "WeakStringCache Misses", _regularInternMisses, "misses");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Strings*", _internEliminatedStrings, "strings");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Chars", _internEliminatedChars, "chars");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Estimated Eliminated Bytes", _internEliminatedChars * 2, "bytes");
-                Console.WriteLine("Elimination assumes that strings provided were unique objects.");
-                Console.WriteLine("|---------------------------------------------------------------------------------|");
-
-                IEnumerable<string> topMissingHardcodedString =
-                    _missedHardcodedStrings
-                    .OrderByDescending(kv => kv.Value * kv.Key.Length)
-                    .Take(15)
-                    .Where(kv => kv.Value > 1)
-                    .Select(kv => string.Format(CultureInfo.InvariantCulture, "({1} instances x each {2} chars)\n{0}", kv.Key, kv.Value, kv.Key.Length));
-
-                Console.WriteLine("##########Top Missing Hardcoded Strings:  \n{0} ", string.Join("\n==============\n", topMissingHardcodedString.ToArray()));
-                Console.WriteLine();
-
-                WeakStringCache.DebugInfo debugInfo = _weakStringCache.GetDebugInfo();
-                Console.WriteLine("WeakStringCache statistics:");
-                Console.WriteLine("String count live/collected/total = {0}/{1}/{2}", debugInfo.LiveStringCount, debugInfo.CollectedStringCount, debugInfo.LiveStringCount + debugInfo.CollectedStringCount);
-            }
-
-            /// <summary>
-            /// Try to intern the string.
-            /// The return value indicates the how the string was interned (if at all).
-            /// </summary>
-            private InternResult TryIntern<T>(T candidate, out string interned) where T : IInternable
-            {
-                // First, try the hard coded intern strings.
-                bool? hardcodedMatchResult = TryMatchHardcodedStrings(candidate, out interned);
-                if (hardcodedMatchResult != false)
-                {
-                    // Either matched a hardcoded string or is explicitly not to be interned.
-                    return hardcodedMatchResult.HasValue ? InternResult.MatchedHardcodedString : InternResult.RejectedFromInterning;
-                }
-
-                interned = _weakStringCache.GetOrCreateEntry(candidate, out bool cacheHit);
-                return cacheHit ? InternResult.FoundInWeakStringCache : InternResult.AddedToWeakStringCache;
-            }
-
-            /// <summary>
-            /// Version of Intern that gathers statistics
-            /// </summary>
-            private string InternWithStatistics<T>(T candidate) where T : IInternable
-            {
-                lock (_missedHardcodedStrings)
-                {
-                    InternResult internResult = TryIntern(candidate, out string result);
-
-                    switch (internResult)
-                    {
-                        case InternResult.MatchedHardcodedString:
-                            _hardcodedInternHits++;
-                            break;
-                        case InternResult.FoundInWeakStringCache:
-                            _regularInternHits++;
-                            break;
-                        case InternResult.AddedToWeakStringCache:
-                            _regularInternMisses++;
-                            break;
-                        case InternResult.RejectedFromInterning:
-                            _rejectedStrings++;
-                            break;
-                    }
-
-                    if (internResult != InternResult.MatchedHardcodedString && internResult != InternResult.RejectedFromInterning)
-                    {
-                        _missedHardcodedStrings.TryGetValue(result, out int priorCount);
-                        _missedHardcodedStrings[result] = priorCount + 1;
-                    }
-
-                    if (!candidate.ReferenceEquals(result))
-                    {
-                        // Reference changed so 'candidate' is now released and should save memory.
-                        _internEliminatedStrings++;
-                        _internEliminatedChars += candidate.Length;
-                    }
-
-                    return result;
-                }
-            }
-        }
-
-        /// <summary>
-        /// Manages a set of mru lists that hold strings in varying size ranges (legacy implementation).
-        /// </summary>
-        private class BucketedPrioritizedStringList : IInternerImplementation
-        {
-            /// <summary>
-            /// The small string Mru list.
-            /// </summary>
-            private readonly PrioritizedStringList _smallMru;
-
-            /// <summary>
-            /// The large string Mru list.
-            /// </summary>
-            private readonly PrioritizedStringList _largeMru;
-
-            /// <summary>
-            /// The huge string Mru list.
-            /// </summary>
-            private readonly PrioritizedStringList _hugeMru;
-
-            /// <summary>
-            /// Three most recently used strings over 8K.
-            /// </summary>
-            private readonly LinkedList<WeakReference> _ginormous = new LinkedList<WeakReference>();
-
-            /// <summary>
-            /// The smallest size a string can be to be considered small.
-            /// </summary>
-            private readonly int _smallMruThreshold;
-
-            /// <summary>
-            /// The smallest size a string can be to be considered large.
-            /// </summary>
-            private readonly int _largeMruThreshold;
-
-            /// <summary>
-            /// The smallest size a string can be to be considered huge.
-            /// </summary>
-            private readonly int _hugeMruThreshold;
-
-            /// <summary>
-            /// The smallest size a string can be to be ginormous.
-            /// </summary>
-            private readonly int _ginormousThreshold;
-
-            private readonly bool _useSimpleConcurrency;
-
-#if !CLR2COMPATIBILITY
-            // ConcurrentDictionary starts with capacity 31 but we're usually adding far more than that. Make a better first capacity guess to reduce
-            // ConcurrentDictionary having to take all internal locks to upgrade its bucket list. Note that the number should be prime per the
-            // comments on the code at https://referencesource.microsoft.com/#mscorlib/system/Collections/Concurrent/ConcurrentDictionary.cs,122 
-            // Also note default lock count is NativeMethodsShared.GetLogicalCoreCount() from the same code.
-            private const int InitialCapacity = 2053;
-            private readonly ConcurrentDictionary<string, string> _internedStrings = new ConcurrentDictionary<string, string>(NativeMethodsShared.GetLogicalCoreCount(), InitialCapacity, StringComparer.Ordinal);
-#endif
-
-#region Statistics
-            /// <summary>
-            /// Whether or not to gather statistics
-            /// </summary>
-            private readonly bool _gatherStatistics;
-
-            /// <summary>
-            /// Number of times interning worked.
-            /// </summary>
-            private int _internHits;
-
-            /// <summary>
-            /// Number of times interning didn't work.
-            /// </summary>
-            private int _internMisses;
-
-            /// <summary>
-            /// Number of times interning wasn't attempted.
-            /// </summary>
-            private int _internRejects;
-
-            /// <summary>
-            /// Total number of strings eliminated by interning.
-            /// </summary>
-            private int _internEliminatedStrings;
-
-            /// <summary>
-            /// Total number of chars eliminated across all strings.
-            /// </summary>
-            private int _internEliminatedChars;
-
-            /// <summary>
-            /// Number of times the ginourmous string hit.
-            /// </summary>
-            private int _ginormousHits;
-
-            /// <summary>
-            /// Number of times the ginourmous string missed.
-            /// </summary>
-            private int _ginormousMisses;
-
-            /// <summary>
-            /// Chars interned for ginormous range.
-            /// </summary>
-            private int _ginormousCharsSaved;
-
-            /// <summary>
-            /// Whether or not to track ginormous strings.
-            /// </summary>
-            private readonly bool _dontTrack;
-
-            /// <summary>
-            /// The time spent interning.
-            /// </summary>
-            private readonly Stopwatch _stopwatch;
-
-            /// <summary>
-            /// Strings which did not intern
-            /// </summary>
-            private readonly Dictionary<string, int> _missedStrings;
-
-            /// <summary>
-            /// Strings which we didn't attempt to intern
-            /// </summary>
-            private readonly Dictionary<string, int> _rejectedStrings;
-
-            /// <summary>
-            /// Number of ginormous strings to keep
-            /// By observation of Auto7, there are about three variations of the huge solution config blob
-            /// There aren't really any other strings of this size, but make it 10 to be sure. (There will barely be any misses)
-            /// </summary>
-            private const int GinormousSize = 10;
-
-#endregion
-
-            /// <summary>
-            /// Construct.
-            /// </summary>
-            internal BucketedPrioritizedStringList(bool gatherStatistics, int smallMruSize, int largeMruSize, int hugeMruSize, int smallMruThreshold, int largeMruThreshold, int hugeMruThreshold, int ginormousThreshold, bool useSimpleConcurrency)
-            {
-                if (smallMruSize == 0 && largeMruSize == 0 && hugeMruSize == 0)
-                {
-                    _dontTrack = true;
-                }
-
-                _smallMru = new PrioritizedStringList(smallMruSize);
-                _largeMru = new PrioritizedStringList(largeMruSize);
-                _hugeMru = new PrioritizedStringList(hugeMruSize);
-                _smallMruThreshold = smallMruThreshold;
-                _largeMruThreshold = largeMruThreshold;
-                _hugeMruThreshold = hugeMruThreshold;
-                _ginormousThreshold = ginormousThreshold;
-                _useSimpleConcurrency = useSimpleConcurrency;
-
-                for (int i = 0; i < GinormousSize; i++)
-                {
-                    _ginormous.AddFirst(new WeakReference(string.Empty));
-                }
-
-                _gatherStatistics = gatherStatistics;
-                if (gatherStatistics)
-                {
-                    _stopwatch = new Stopwatch();
-                    _missedStrings = new Dictionary<string, int>(StringComparer.Ordinal);
-                    _rejectedStrings = new Dictionary<string, int>(StringComparer.Ordinal);
-                }
-            }
-
-            /// <summary>
-            /// Intern the given internable.
-            /// </summary>
-            public string InterningToString<T>(T candidate) where T : IInternable
-            {
-                if (_gatherStatistics)
-                {
-                    return InternWithStatistics(candidate);
-                }
-                else
-                {
-                    TryIntern(candidate, out string result);
-                    return result;
-                }
-            }
-
-            /// <summary>
-            /// Report statistics to the console.
-            /// </summary>
-            public void ReportStatistics(string heading)
-            {
-                string title = "Opportunistic Intern (" + heading + ")";
-                Console.WriteLine("\n{0}{1}{0}", new string('=', 41 - (title.Length / 2)), title);
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Intern Hits", _internHits, "hits");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Intern Misses", _internMisses, "misses");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Intern Rejects (as shorter than " + _smallMruThreshold + " bytes)", _internRejects, "rejects");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Strings*", _internEliminatedStrings, "strings");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Chars", _internEliminatedChars, "chars");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Estimated Eliminated Bytes", _internEliminatedChars * 2, "bytes");
-                Console.WriteLine("Elimination assumes that strings provided were unique objects.");
-                Console.WriteLine("|---------------------------------------------------------------------------------|");
-                KeyValuePair<int, int> held = _smallMru.Statistics();
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Small Strings MRU Size", Instance._smallMruSize, "strings");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Small Strings (>=" + _smallMruThreshold + " chars) Held", held.Key, "strings");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Small Estimated Bytes Held", held.Value * 2, "bytes");
-                Console.WriteLine("|---------------------------------------------------------------------------------|");
-                held = _largeMru.Statistics();
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Large Strings MRU Size", Instance._largeMruSize, "strings");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Large Strings  (>=" + _largeMruThreshold + " chars) Held", held.Key, "strings");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Large Estimated Bytes Held", held.Value * 2, "bytes");
-                Console.WriteLine("|---------------------------------------------------------------------------------|");
-                held = _hugeMru.Statistics();
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Huge Strings MRU Size", Instance._hugeMruSize, "strings");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Huge Strings  (>=" + _hugeMruThreshold + " chars) Held", held.Key, "strings");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Huge Estimated Bytes Held", held.Value * 2, "bytes");
-                Console.WriteLine("|---------------------------------------------------------------------------------|");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Ginormous Strings MRU Size", GinormousSize, "strings");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Ginormous (>=" + _ginormousThreshold + " chars)  Hits", _ginormousHits, "hits");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Ginormous Misses", _ginormousMisses, "misses");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Ginormous Chars Saved", _ginormousCharsSaved, "chars");
-                Console.WriteLine("|---------------------------------------------------------------------------------|");
-
-                // There's no point in reporting the ginormous string because it will have evaporated by now.
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Time Spent Interning", _stopwatch.ElapsedMilliseconds, "ms");
-                Console.WriteLine("{0}{0}", new string('=', 41));
-
-                IEnumerable<string> topMissingString =
-                    _missedStrings
-                    .OrderByDescending(kv => kv.Value * kv.Key.Length)
-                    .Take(15)
-                    .Where(kv => kv.Value > 1)
-                    .Select(kv => string.Format(CultureInfo.InvariantCulture, "({1} instances x each {2} chars = {3}KB wasted)\n{0}", kv.Key, kv.Value, kv.Key.Length, (kv.Value - 1) * kv.Key.Length * 2 / 1024));
-
-                Console.WriteLine("##########Top Missed Strings:  \n{0} ", string.Join("\n==============\n", topMissingString.ToArray()));
-                Console.WriteLine();
-
-                IEnumerable<string> topRejectedString =
-                    _rejectedStrings
-                    .OrderByDescending(kv => kv.Value * kv.Key.Length)
-                    .Take(15)
-                    .Where(kv => kv.Value > 1)
-                    .Select(kv => string.Format(CultureInfo.InvariantCulture, "({1} instances x each {2} chars = {3}KB wasted)\n{0}", kv.Key, kv.Value, kv.Key.Length, (kv.Value - 1) * kv.Key.Length * 2 / 1024));
-
-                Console.WriteLine("##########Top Rejected Strings: \n{0} ", string.Join("\n==============\n", topRejectedString.ToArray()));
-            }
-
-            /// <summary>
-            /// Try to intern the string.
-            /// Return true if an interned value could be returned.
-            /// Return false if it was added to the intern list, but wasn't there already.
-            /// Return null if it didn't meet the length criteria for any of the buckets. Interning was rejected
-            /// </summary>
-            private bool? TryIntern<T>(T candidate, out string interned) where T : IInternable
-            {
-                int length = candidate.Length;
-                interned = null;
-
-                // First, try the hard coded intern strings.
-                // Each of the hard-coded small strings below showed up in a profile run with considerable duplication in memory.
-                if (!_dontTrack)
-                {
-                    bool? hardcodedMatchResult = TryMatchHardcodedStrings(candidate, out interned);
-                    if (hardcodedMatchResult != false)
-                    {
-                        // Either matched a hardcoded string or is explicitly not to be interned.
-                        return hardcodedMatchResult;
-                    }
-
-                    if (length > _ginormousThreshold)
-                    {
-                        lock (_ginormous)
-                        {
-                            LinkedListNode<WeakReference> current = _ginormous.First;
-
-                            while (current != null)
-                            {
-                                if (current.Value.Target is string last && last.Length == candidate.Length && candidate.StartsWithStringByOrdinalComparison(last))
-                                {
-                                    interned = last;
-                                    _ginormousHits++;
-                                    _ginormousCharsSaved += last.Length;
-
-                                    _ginormous.Remove(current);
-                                    _ginormous.AddFirst(current);
-
-                                    return true;
-                                }
-
-                                current = current.Next;
-                            }
-
-                            _ginormousMisses++;
-                            interned = candidate.ExpensiveConvertToString();
-
-                            LinkedListNode<WeakReference> lastNode = _ginormous.Last;
-                            _ginormous.RemoveLast();
-                            _ginormous.AddFirst(lastNode);
-                            lastNode.Value.Target = interned;
-
-                            return false;
-                        }
-                    }
-#if !CLR2COMPATIBILITY
-                    else if (_useSimpleConcurrency)
-                    {
-                        var stringified = candidate.ExpensiveConvertToString();
-                        interned = _internedStrings.GetOrAdd(stringified, stringified);
-                        return true;
-                    }
-#endif
-                    else if (length >= _hugeMruThreshold)
-                    {
-                        lock (_hugeMru)
-                        {
-                            return _hugeMru.TryGet(candidate, out interned);
-                        }
-                    }
-                    else if (length >= _largeMruThreshold)
-                    {
-                        lock (_largeMru)
-                        {
-                            return _largeMru.TryGet(candidate, out interned);
-                        }
-                    }
-                    else if (length >= _smallMruThreshold)
-                    {
-                        lock (_smallMru)
-                        {
-                            return _smallMru.TryGet(candidate, out interned);
-                        }
-                    }
-                }
-
-                interned = candidate.ExpensiveConvertToString();
-                return null;
-            }
-
-            /// <summary>
-            /// Version of Intern that gathers statistics
-            /// </summary>
-            private string InternWithStatistics<T>(T candidate) where T : IInternable
-            {
-                lock (_missedStrings)
-                {
-                    _stopwatch.Start();
-                    bool? interned = TryIntern(candidate, out string result);
-                    _stopwatch.Stop();
-
-                    if (interned.HasValue && !interned.Value)
-                    {
-                        // Could not intern.
-                        _internMisses++;
-
-                        _missedStrings.TryGetValue(result, out int priorCount);
-                        _missedStrings[result] = priorCount + 1;
-
-                        return result;
-                    }
-                    else if (interned == null)
-                    {
-                        // Decided not to attempt interning
-                        _internRejects++;
-
-                        _rejectedStrings.TryGetValue(result, out int priorCount);
-                        _rejectedStrings[result] = priorCount + 1;
-
-                        return result;
-                    }
-
-                    _internHits++;
-                    if (!candidate.ReferenceEquals(result))
-                    {
-                        // Reference changed so 'candidate' is now released and should save memory.
-                        _internEliminatedStrings++;
-                        _internEliminatedChars += candidate.Length;
-                    }
-
-                    return result;
-                }
-            }
-
-            /// <summary>
-            /// A singly linked list of strings where the most recently accessed string is at the top.
-            /// Size expands up to a fixed number of strings.
-            /// </summary>
-            private class PrioritizedStringList
-            {
-                /// <summary>
-                /// Maximum size of the mru list.
-                /// </summary>
-                private readonly int _size;
-
-                /// <summary>
-                /// Head of the mru list.
-                /// </summary>
-                private Node _mru;
-
-                /// <summary>
-                /// Construct an Mru list with a fixed maximum size.
-                /// </summary>
-                internal PrioritizedStringList(int size)
-                {
-                    _size = size;
-                }
-
-                /// <summary>
-                /// Try to get one element from the list. Upon leaving the function 'candidate' will be at the head of the Mru list.
-                /// This function is not thread-safe.
-                /// </summary>
-                internal bool TryGet<T>(T candidate, out string interned) where T : IInternable
-                {
-                    if (_size == 0)
-                    {
-                        interned = candidate.ExpensiveConvertToString();
-                        return false;
-                    }
-
-                    int length = candidate.Length;
-                    Node secondPrior = null;
-                    Node prior = null;
-                    Node head = _mru;
-                    bool found = false;
-                    int itemCount = 0;
-
-                    while (head != null && !found)
-                    {
-                        if (head.Value.Length == length)
-                        {
-                            if (candidate.StartsWithStringByOrdinalComparison(head.Value))
-                            {
-                                found = true;
-                            }
-                        }
-
-                        if (!found)
-                        {
-                            secondPrior = prior;
-                            prior = head;
-                            head = head.Next;
-                        }
-
-                        itemCount++;
-                    }
-
-                    if (found)
-                    {
-                        // Move it to the top and return the interned version.
-                        if (prior != null)
-                        {
-                            if (!candidate.ReferenceEquals(head.Value))
-                            {
-                                // Wasn't at the top already, so move it there.
-                                prior.Next = head.Next;
-                                head.Next = _mru;
-                                _mru = head;
-                                interned = _mru.Value;
-                                return true;
-                            }
-                            else
-                            {
-                                // But don't move it up if there is reference equality so that multiple calls to Intern don't redundantly emphasize a string.
-                                interned = head.Value;
-                                return true;
-                            }
-                        }
-                        else
-                        {
-                            // Found the item in the top spot. No need to move anything.
-                            interned = _mru.Value;
-                            return true;
-                        }
-                    }
-                    else
-                    {
-                        // Not found. Create a new entry and place it at the top.
-                        Node old = _mru;
-                        _mru = new Node(candidate.ExpensiveConvertToString()) { Next = old };
-
-                        // Cache miss. Use this opportunity to discard any element over the max size.
-                        if (itemCount >= _size && secondPrior != null)
-                        {
-                            secondPrior.Next = null;
-                        }
-
-                        interned = _mru.Value;
-                        return false;
-                    }
-                }
-
-                /// <summary>
-                /// Returns the number of strings held and the total number of chars held.
-                /// </summary>
-                internal KeyValuePair<int, int> Statistics()
-                {
-                    Node head = _mru;
-                    int chars = 0;
-                    int strings = 0;
-                    while (head != null)
-                    {
-                        chars += head.Value.Length;
-                        strings++;
-                        head = head.Next;
-                    }
-
-                    return new KeyValuePair<int, int>(strings, chars);
-                }
-
-                /// <summary>
-                /// Singly linked list node.
-                /// </summary>
-                private class Node
-                {
-                    /// <summary>
-                    /// Construct a Node
-                    /// </summary>
-                    internal Node(string value)
-                    {
-                        Value = value;
-                    }
-
-                    /// <summary>
-                    /// The next node in the list.
-                    /// </summary>
-                    internal Node Next { get; set; }
-
-                    /// <summary>
-                    /// The held string.
-                    /// </summary>
-                    internal string Value { get; }
-                }
-            }
-        }
-    }
-}
diff --git a/src/Shared/Traits.cs b/src/Shared/Traits.cs
index 3522c0972c1..7aa78f0bbeb 100644
--- a/src/Shared/Traits.cs
+++ b/src/Shared/Traits.cs
@@ -44,16 +44,6 @@ public Traits()
         /// </summary>
         public readonly bool CacheFileExistence = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MsBuildCacheFileExistence"));
 
-        /// <summary>
-        /// Use the legacy string interning implementation based on MRU lists.
-        /// </summary>
-        public readonly bool UseLegacyStringInterner = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildUseLegacyStringInterner"));
-
-        /// <summary>
-        /// Eliminate locking in OpportunisticIntern at the expense of memory (in effect only if UseLegacyStringInterner is set).
-        /// </summary>
-        public readonly bool UseSimpleInternConcurrency = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildUseSimpleInternConcurrency"));
-
         public readonly bool UseSimpleProjectRootElementCacheConcurrency = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MsBuildUseSimpleProjectRootElementCacheConcurrency"));
 
         /// <summary>
diff --git a/src/Shared/WeakStringCache.Concurrent.cs b/src/Shared/WeakStringCache.Concurrent.cs
deleted file mode 100644
index 318aeafc131..00000000000
--- a/src/Shared/WeakStringCache.Concurrent.cs
+++ /dev/null
@@ -1,137 +0,0 @@
-﻿
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-using System.Collections.Concurrent;
-using System.Collections.Generic;
-using Microsoft.Build.Shared;
-
-namespace Microsoft.Build
-{
-    /// <summary>
-    /// Implements the WeakStringCache functionality on modern .NET versions where ConcurrentDictionary is available.
-    /// </summary>
-    internal sealed partial class WeakStringCache : IDisposable
-    {
-        private readonly ConcurrentDictionary<int, StringWeakHandle> _stringsByHashCode;
-
-        public WeakStringCache()
-        {
-            _stringsByHashCode = new ConcurrentDictionary<int, StringWeakHandle>(NativeMethodsShared.GetLogicalCoreCount(), _initialCapacity);
-        }
-
-        /// <summary>
-        /// Main entrypoint of this cache. Tries to look up a string that matches the given internable. If it succeeds, returns
-        /// the string and sets cacheHit to true. If the string is not found, calls ExpensiveConvertToString on the internable,
-        /// adds the resulting string to the cache, and returns it, setting cacheHit to false.
-        /// </summary>
-        /// <param name="internable">The internable describing the string we're looking for.</param>
-        /// <param name="cacheHit">true if match found in cache, false otherwise.</param>
-        /// <returns>A string matching the given internable.</returns>
-        /// <remarks>
-        /// This method performs two operations on the underlying ConcurrentDictionary on both cache hit and cache miss.
-        /// 1. It checks whether the dictionary has a matching entry. The entry is temporarily removed from the cache so it doesn't
-        ///    race with Scavenge() freeing GC handles. This is the first operation.
-        /// 2a. If there is a matching entry, we extract the string out of it and put it back in the cache (the second operation).
-        /// 2b. If there is an entry but it doesn't match, or there is no entry for the given hash code, we extract the string from
-        ///     the internable, set it on the entry, and add the entry (back) in the cache.
-        /// </remarks>
-        public string GetOrCreateEntry<T>(T internable, out bool cacheHit) where T : IInternable
-        {
-            int hashCode = GetInternableHashCode(internable);
-
-            StringWeakHandle handle;
-            string result;
-            bool addingNewHandle = false;
-
-            // Get the existing handle from the cache and assume ownership by removing it. We can't use the simple TryGetValue() here because
-            // the Scavenge method running on another thread could free the handle from underneath us.
-            if (_stringsByHashCode.TryRemove(hashCode, out handle))
-            {
-                result = handle.GetString(internable);
-                if (result != null)
-                {
-                    // We have a hit, put the handle back in the cache.
-                    if (!_stringsByHashCode.TryAdd(hashCode, handle))
-                    {
-                        // Another thread has managed to add a handle for the same hash code, so the one we got can be freed.
-                        handle.Free();
-                    }
-                    cacheHit = true;
-                    return result;
-                }
-            }
-            else
-            {
-                handle = new StringWeakHandle();
-                addingNewHandle = true;
-            }
-
-            // We don't have the string in the cache - create it.
-            result = internable.ExpensiveConvertToString();
-
-            // Set the handle to reference the new string and put it in the cache.
-            handle.SetString(result);
-            if (!_stringsByHashCode.TryAdd(hashCode, handle))
-            {
-                // Another thread has managed to add a handle for the same hash code, so the one we got can be freed.
-                handle.Free();
-            }
-
-            // Remove unused handles if our heuristic indicates that it would be productive. Note that the _scavengeThreshold field
-            // accesses are not protected from races. Being atomic (as guaranteed by the 32-bit data type) is enough here.
-            if (addingNewHandle)
-            {
-                // Prevent the dictionary from growing forever with GC handles that don't reference live strings anymore.
-                if (_stringsByHashCode.Count >= _scavengeThreshold)
-                {
-                    // Before we start scavenging set _scavengeThreshold to a high value to effectively lock other threads from
-                    // running Scavenge at the same time (minus rare races).
-                    _scavengeThreshold = int.MaxValue;
-                    try
-                    {
-                        // Get rid of unused handles.
-                        Scavenge();
-                    }
-                    finally
-                    {
-                        // And do this again when the number of handles reaches double the current after-scavenge number.
-                        _scavengeThreshold = _stringsByHashCode.Count * 2;
-                    }
-                }
-            }
-
-            cacheHit = false;
-            return result;
-        }
-
-        /// <summary>
-        /// Iterates over the cache and removes unused GC handles, i.e. handles that don't reference live strings.
-        /// This is expensive so try to call such that the cost is amortized to O(1) per GetOrCreateEntry() invocation.
-        /// </summary>
-        public void Scavenge()
-        {
-            foreach (KeyValuePair<int, StringWeakHandle> entry in _stringsByHashCode)
-            {
-                if (!entry.Value.IsUsed && _stringsByHashCode.TryRemove(entry.Key, out StringWeakHandle removedHandle))
-                {
-                    // Note that the removed handle may be different from the one we got from the enumerator so check again
-                    // and try to put it back if it's still in use.
-                    if (!removedHandle.IsUsed || !_stringsByHashCode.TryAdd(entry.Key, removedHandle))
-                    {
-                        removedHandle.Free();
-                    }
-                }
-            }
-        }
-
-        /// <summary>
-        /// Returns internal debug counters calculated based on the current state of the cache.
-        /// </summary>
-        public DebugInfo GetDebugInfo()
-        {
-            return GetDebugInfoImpl();
-        }
-    }
-}
diff --git a/src/Shared/WeakStringCache.cs b/src/Shared/WeakStringCache.cs
deleted file mode 100644
index 22021e1a08a..00000000000
--- a/src/Shared/WeakStringCache.cs
+++ /dev/null
@@ -1,149 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-using System.Collections.Generic;
-using System.Runtime.InteropServices;
-
-namespace Microsoft.Build
-{
-    /// <summary>
-    /// A cache of weak GC handles pointing to strings. Weak GC handles are functionally equivalent to WeakReference's but have less overhead
-    /// (they're a struct as opposed to WR which is a finalizable class) at the expense of requiring manual lifetime management. As long as
-    /// a string has an ordinary strong GC root elsewhere in the process and another string with the same hashcode hasn't reused the entry,
-    /// the cache has a reference to it and can match it to an internable. When the string is collected, it is also automatically "removed"
-    /// from the cache by becoming unrecoverable from the GC handle. GC handles that do not reference a live string anymore are freed lazily.
-    /// </summary>
-    internal sealed partial class WeakStringCache : IDisposable
-    {
-        /// <summary>
-        /// Debug stats returned by GetDebugInfo().
-        /// </summary>
-        public struct DebugInfo
-        {
-            public int LiveStringCount;
-            public int CollectedStringCount;
-        }
-
-        /// <summary>
-        /// Holds a weak GC handle to a string. Shared by all strings with the same hash code and referencing the last such string we've seen.
-        /// </summary>
-        private struct StringWeakHandle
-        {
-            /// <summary>
-            /// Weak GC handle to the last string of the given hashcode we've seen.
-            /// </summary>
-            public GCHandle WeakHandle;
-
-            /// <summary>
-            /// Returns true if the string referenced by the handle is still alive.
-            /// </summary>
-            public bool IsUsed => WeakHandle.Target != null;
-
-            /// <summary>
-            /// Returns the string referenced by this handle if it is equal to the given internable.
-            /// </summary>
-            /// <param name="internable">The internable describing the string we're looking for.</param>
-            /// <returns>The string matching the internable or null if the handle is referencing a collected string or the string is different.</returns>
-            public string GetString<T>(T internable) where T : IInternable
-            {
-                if (WeakHandle.IsAllocated && WeakHandle.Target is string str)
-                {
-                    if (internable.Length == str.Length &&
-                        internable.StartsWithStringByOrdinalComparison(str))
-                    {
-                        return str;
-                    }
-                }
-                return null;
-            }
-
-            /// <summary>
-            /// Sets the handle to the given string. If the handle is still referencing another live string, that string is effectively forgotten.
-            /// </summary>
-            /// <param name="str">The string to set.</param>
-            public void SetString(string str)
-            {
-                if (!WeakHandle.IsAllocated)
-                {
-                    // The handle is not allocated - allocate it.
-                    WeakHandle = GCHandle.Alloc(str, GCHandleType.Weak);
-                }
-                else
-                {
-                    WeakHandle.Target = str;
-                }
-            }
-
-            /// <summary>
-            /// Frees the GC handle.
-            /// </summary>
-            public void Free()
-            {
-                WeakHandle.Free();
-            }
-        }
-
-        /// <summary>
-        /// Initial capacity of the underlying dictionary.
-        /// </summary>
-        private const int _initialCapacity = 503;
-
-        /// <summary>
-        /// The maximum size we let the collection grow before scavenging unused entries.
-        /// </summary>
-        private int _scavengeThreshold = _initialCapacity;
-
-        /// <summary>
-        /// Implements the simple yet very decently performing djb2 hash function (xor version).
-        /// </summary>
-        /// <param name="internable">The internable to compute the hash code for.</param>
-        /// <returns>The 32-bit hash code.</returns>
-        internal static int GetInternableHashCode<T>(T internable) where T : IInternable
-        {
-            int hashCode = 5381;
-            for (int i = 0; i < internable.Length; i++)
-            {
-                unchecked
-                {
-                    hashCode = hashCode * 33 ^ internable[i];
-                }
-            }
-            return hashCode;
-        }
-
-        /// <summary>
-        /// Frees all GC handles and clears the cache.
-        /// </summary>
-        public void Dispose()
-        {
-            foreach (KeyValuePair<int, StringWeakHandle> entry in _stringsByHashCode)
-            {
-                entry.Value.Free();
-            }
-            _stringsByHashCode.Clear();
-        }
-
-        /// <summary>
-        /// Returns internal debug counters calculated based on the current state of the cache.
-        /// </summary>
-        private DebugInfo GetDebugInfoImpl()
-        {
-            DebugInfo debugInfo = new DebugInfo();
-
-            foreach (KeyValuePair<int, StringWeakHandle> entry in _stringsByHashCode)
-            {
-                if (entry.Value.IsUsed)
-                {
-                    debugInfo.LiveStringCount++;
-                }
-                else
-                {
-                    debugInfo.CollectedStringCount++;
-                }
-            }
-
-            return debugInfo;
-        }
-    }
-}
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index b5200e1248b..97daccd3aae 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -82,18 +82,6 @@
       <Link>NGen.cs</Link>
     </Compile>
     <Compile Include="..\Shared\IConstrainedEqualityComparer.cs"/>
-    <Compile Include="..\Shared\IInternable.cs">
-      <Link>IInternable.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\WeakStringCache.cs">
-      <Link>WeakStringCache.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs">
-      <Link>WeakStringCache.Concurrent.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\OpportunisticIntern.cs">
-      <Link>OpportunisticIntern.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\PropertyParser.cs">
       <Link>PropertyParser.cs</Link>
       <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index 2b851f4526a..2fdd06afdd6 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -125,18 +125,6 @@
     <Compile Include="..\Shared\InprocTrackingNativeMethods.cs">
       <Link>Shared\InprocTrackingNativeMethods.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\IInternable.cs">
-      <Link>Shared\IInternable.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\WeakStringCache.cs">
-      <Link>Shared\WeakStringCache.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs">
-      <Link>Shared\WeakStringCache.Concurrent.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\OpportunisticIntern.cs">
-      <Link>Shared\OpportunisticIntern.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\ReadOnlyEmptyCollection.cs">
       <Link>Shared\ReadOnlyEmptyCollection.cs</Link>
     </Compile>
