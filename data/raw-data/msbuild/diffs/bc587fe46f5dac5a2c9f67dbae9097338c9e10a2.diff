diff --git a/Directory.Build.props b/Directory.Build.props
index 21b6d6694f2..ffdf91c5c7d 100644
--- a/Directory.Build.props
+++ b/Directory.Build.props
@@ -14,8 +14,8 @@
 
   <PropertyGroup>
     <FullFrameworkTFM>net472</FullFrameworkTFM>
-    
-    <!-- 
+
+    <!--
         When updating the version of .NET Core for MSBuild, this property is the 'source of truth'.
         Other locations to update the version number:
           global.json
@@ -43,8 +43,10 @@
   <PropertyGroup>
     <GenerateNeutralResourcesLanguageAttribute>false</GenerateNeutralResourcesLanguageAttribute>
 
-    <!-- NU1603: Microsoft.xunit.netcore.extensions package has dependencies to versions which aren't published, so ignore those warnings
-         NU5105: we're explicitly opting in to semver2, as is most of .NET Core
+    <!--
+        NU1507: ManagePackageVersionsCentrally implies source mapping, which we should consider turning on but it's nontrivial
+        NU1603: Microsoft.xunit.netcore.extensions package has dependencies to versions which aren't published, so ignore those warnings
+        NU5105: we're explicitly opting in to semver2, as is most of .NET Core
         CS1701 and CS1702 are by default ignored by Microsoft.NET.Sdk, but if you define the NoWarn property in Directory.Build.props,
         you don't get those defaults.
         SYSLIB0011: Removing binary formatter will happen as part of a larger .NET-wide effort.
@@ -52,7 +54,7 @@
         RS0016 & RS0017: Roslyn analyzers seem to be bugged, claiming that API's that exist don't and vise-versa: https://github.com/dotnet/msbuild/issues/7903
     -->
 
-    <NoWarn>$(NoWarn);NU1603;NU5105;1701;1702;SYSLIB0011;SYSLIB0037;SYSLIB0044;RS0016;RS0017;</NoWarn>
+    <NoWarn>$(NoWarn);NU1507;NU1603;NU5105;1701;1702;SYSLIB0011;SYSLIB0037;SYSLIB0044;RS0016;RS0017;</NoWarn>
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(Configuration)' == 'Debug-MONO'">
@@ -84,11 +86,15 @@
     <DefaultItemExcludes>$(DefaultItemExcludes);*.binlog</DefaultItemExcludes>
 
     <DisableImplicitNuGetFallbackFolder>true</DisableImplicitNuGetFallbackFolder>
+
+    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
+    <CentralPackageTransitivePinningEnabled>true</CentralPackageTransitivePinningEnabled>
+    <DirectoryPackagesPropsPath>$([MSBuild]::NormalizePath('$(MSBuildThisFileDirectory)', 'eng', 'Packages.props'))</DirectoryPackagesPropsPath>
   </PropertyGroup>
 
   <!-- Enable SDK supplied netanalyzers for all target frameworks -->
   <PropertyGroup>
     <EnableNETAnalyzers>true</EnableNETAnalyzers>
   </PropertyGroup>
-  
+
 </Project>
diff --git a/Directory.Build.targets b/Directory.Build.targets
index 3a0e383282a..b57a232300f 100644
--- a/Directory.Build.targets
+++ b/Directory.Build.targets
@@ -24,10 +24,6 @@
     <EditorConfigFiles Include="$(MSBuildThisFileDirectory)eng/Common.Test.globalconfig" />
   </ItemGroup>
 
-  <PropertyGroup>
-    <CentralPackagesFile>$(MSBuildThisFileDirectory)eng/Packages.props</CentralPackagesFile>
-  </PropertyGroup>
-  <Import Project="Sdk.targets" Sdk="Microsoft.Build.CentralPackageVersions" />
   <Import Project="Sdk.targets" Sdk="Microsoft.DotNet.Arcade.Sdk" />
 
   <Target Name="DeleteDevPackage" AfterTargets="GenerateNuspec">
diff --git a/eng/Packages.props b/eng/Packages.props
index bce1a6ee70a..5623df27263 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -8,29 +8,28 @@
     the list of assemblies redistributed by MSBuild (non-MSBuild assemblies in the .vsix package).
      -->
   <ItemGroup>
-    <PackageReference Update="Microsoft.Build.NuGetSdkResolver" Version="$(NuGetBuildTasksVersion)" />
-    <PackageReference Update="Microsoft.CodeAnalysis.Build.Tasks" Version="$(MicrosoftNetCompilersToolsetVersion)" />
-    <PackageReference Update="Microsoft.CodeAnalysis.Collections" Version="$(MicrosoftCodeAnalysisCollectionsVersion)" />
-    <PackageReference Update="Microsoft.DotNet.XUnitExtensions" Version="$(MicrosoftDotNetXUnitExtensionsVersion)" />
-    <PackageReference Update="Microsoft.IO.Redist" Version="$(MicrosoftIORedistVersion)" />
-    <PackageReference Update="Microsoft.Net.Compilers.Toolset" Version="$(MicrosoftNetCompilersToolsetVersion)" />
-    <PackageReference Update="NuGet.Build.Tasks" Version="$(NuGetBuildTasksVersion)" />
-    <PackageReference Update="NuGet.Frameworks" Version="$(NuGetBuildTasksVersion)" />
-    <PackageReference Update="System.Collections.Immutable" Version="$(SystemCollectionsImmutableVersion)" />
-    <PackageReference Update="System.Configuration.ConfigurationManager" Version="$(SystemConfigurationConfigurationManagerVersion)" />
-    <PackageReference Update="System.Memory" Version="$(SystemMemoryVersion)" />
-    <PackageReference Update="System.Net.Http" Version="$(SystemNetHttpVersion)" />
-    <PackageReference Update="System.Reflection.Metadata" Version="$(SystemReflectionMetadataVersion)" />
-    <PackageReference Update="System.Reflection.MetadataLoadContext" Version="$(SystemReflectionMetadataLoadContextVersion)" />
-    <PackageReference Update="System.Resources.Extensions" Version="$(SystemResourcesExtensionsPackageVersion)" />
-    <PackageReference Update="System.Runtime.CompilerServices.Unsafe" Version="$(SystemRuntimeCompilerServicesUnsafeVersion)" />
-    <PackageReference Update="System.Security.Permissions" Version="$(SystemSecurityPermissionsVersion)" />
-    <PackageReference Update="System.Security.Principal.Windows" Version="$(SystemSecurityPrincipalWindowsVersion)" />
-    <PackageReference Update="System.Text.Encoding.CodePages" Version="$(SystemTextEncodingCodePagesVersion)" />
-    <PackageReference Update="System.Text.Json" Version="$(SystemTextJsonVersion)" />
-    <PackageReference Update="System.Threading.Tasks.Dataflow" Version="$(SystemThreadingTasksDataflowVersion)" />
-    <PackageReference Update="xunit.assert" Version="$(XUnitVersion)" />
-    <PackageReference Update="xunit.console" Version="$(XUnitVersion)" />
-    <PackageReference Update="xunit.core" Version="$(XUnitVersion)" />
+    <PackageVersion Include="Microsoft.Build.NuGetSdkResolver" Version="$(NuGetBuildTasksVersion)" />
+    <PackageVersion Include="Microsoft.CodeAnalysis.Build.Tasks" Version="$(MicrosoftNetCompilersToolsetVersion)" />
+    <PackageVersion Include="Microsoft.CodeAnalysis.Collections" Version="$(MicrosoftCodeAnalysisCollectionsVersion)" />
+    <PackageVersion Include="Microsoft.DotNet.XUnitExtensions" Version="$(MicrosoftDotNetXUnitExtensionsVersion)" />
+    <PackageVersion Include="Microsoft.IO.Redist" Version="$(MicrosoftIORedistVersion)" />
+    <PackageVersion Include="NuGet.Build.Tasks" Version="$(NuGetBuildTasksVersion)" />
+    <PackageVersion Include="NuGet.Frameworks" Version="$(NuGetBuildTasksVersion)" />
+    <PackageVersion Include="System.Collections.Immutable" Version="$(SystemCollectionsImmutableVersion)" />
+    <PackageVersion Include="System.Configuration.ConfigurationManager" Version="$(SystemConfigurationConfigurationManagerVersion)" />
+    <PackageVersion Include="System.Memory" Version="$(SystemMemoryVersion)" />
+    <PackageVersion Include="System.Net.Http" Version="$(SystemNetHttpVersion)" />
+    <PackageVersion Include="System.Reflection.Metadata" Version="$(SystemReflectionMetadataVersion)" />
+    <PackageVersion Include="System.Reflection.MetadataLoadContext" Version="$(SystemReflectionMetadataLoadContextVersion)" />
+    <PackageVersion Include="System.Resources.Extensions" Version="$(SystemResourcesExtensionsPackageVersion)" />
+    <PackageVersion Include="System.Runtime.CompilerServices.Unsafe" Version="$(SystemRuntimeCompilerServicesUnsafeVersion)" />
+    <PackageVersion Include="System.Security.Permissions" Version="$(SystemSecurityPermissionsVersion)" />
+    <PackageVersion Include="System.Security.Principal.Windows" Version="$(SystemSecurityPrincipalWindowsVersion)" />
+    <PackageVersion Include="System.Text.Encoding.CodePages" Version="$(SystemTextEncodingCodePagesVersion)" />
+    <PackageVersion Include="System.Text.Json" Version="$(SystemTextJsonVersion)" />
+    <PackageVersion Include="System.Threading.Tasks.Dataflow" Version="$(SystemThreadingTasksDataflowVersion)" />
+    <PackageVersion Include="xunit.assert" Version="$(XUnitVersion)" />
+    <PackageVersion Include="xunit.console" Version="$(XUnitVersion)" />
+    <PackageVersion Include="xunit.core" Version="$(XUnitVersion)" />
   </ItemGroup>
 </Project>
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index cdd69e6ed40..46cbbad9917 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -10,47 +10,44 @@
   these properties to override package versions if necessary. -->
 
   <ItemGroup>
-    <PackageReference Update="BenchmarkDotNet" Version="0.13.1" />
-    <PackageReference Update="BenchmarkDotNet" Condition="'$(BenchmarkDotNetVersion)' != ''" Version="$(BenchmarkDotNetVersion)" />
+    <PackageVersion Include="BenchmarkDotNet" Version="0.13.1" />
+    <PackageVersion Update="BenchmarkDotNet" Condition="'$(BenchmarkDotNetVersion)' != ''" Version="$(BenchmarkDotNetVersion)" />
 
-    <PackageReference Update="LargeAddressAware" Version="1.0.5" />
-    <PackageReference Update="LargeAddressAware" Condition="'$(LargeAddressAwareVersion)' != ''" Version="$(LargeAddressAwareVersion)" />
+    <PackageVersion Include="LargeAddressAware" Version="1.0.5" />
+    <PackageVersion Update="LargeAddressAware" Condition="'$(LargeAddressAwareVersion)' != ''" Version="$(LargeAddressAwareVersion)" />
 
-    <PackageReference Update="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.36" />
-    <PackageReference Update="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Condition="'$(MicrosoftVisualStudioSDKEmbedInteropTypesVersion)' != ''" Version="$(MicrosoftVisualStudioSDKEmbedInteropTypesVersion)" />
+    <PackageVersion Include="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="3.2.2146" PrivateAssets="All" />
+    <PackageVersion Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Condition="'$(MicrosoftVisualStudioSetupConfigurationInteropVersion)' != ''" Version="$(MicrosoftVisualStudioSetupConfigurationInteropVersion)" PrivateAssets="All" />
 
-    <PackageReference Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="3.2.2146" PrivateAssets="All" />
-    <PackageReference Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Condition="'$(MicrosoftVisualStudioSetupConfigurationInteropVersion)' != ''" Version="$(MicrosoftVisualStudioSetupConfigurationInteropVersion)" PrivateAssets="All" />
+    <PackageVersion Include="Microsoft.Win32.Registry" Version="5.0.0" />
+    <PackageVersion Update="Microsoft.Win32.Registry" Condition="'$(MicrosoftWin32RegistryVersion)' != ''" Version="$(MicrosoftWin32RegistryVersion)" />
 
-    <PackageReference Update="Microsoft.Win32.Registry" Version="5.0.0" />
-    <PackageReference Update="Microsoft.Win32.Registry" Condition="'$(MicrosoftWin32RegistryVersion)' != ''" Version="$(MicrosoftWin32RegistryVersion)" />
+    <PackageVersion Include="Newtonsoft.Json" Version="13.0.2" />
+    <PackageVersion Update="Newtonsoft.Json" Condition="'$(NewtonsoftJsonVersion)' != ''" Version="$(NewtonsoftJsonVersion)" />
 
-    <PackageReference Update="Newtonsoft.Json" Version="13.0.2" />
-    <PackageReference Update="Newtonsoft.Json" Condition="'$(NewtonsoftJsonVersion)' != ''" Version="$(NewtonsoftJsonVersion)" />
+    <PackageVersion Include="PdbGit" Version="3.0.41" />
+    <PackageVersion Update="PdbGit" Condition="'$(PdbGitVersion)' != ''" Version="$(PdbGitVersion)" />
 
-    <PackageReference Update="PdbGit" Version="3.0.41" />
-    <PackageReference Update="PdbGit" Condition="'$(PdbGitVersion)' != ''" Version="$(PdbGitVersion)" />
+    <PackageVersion Include="Shouldly" Version="3.0.0" />
+    <PackageVersion Update="Shouldly" Condition="'$(ShouldlyVersion)' != ''" Version="$(ShouldlyVersion)" />
 
-    <PackageReference Update="Shouldly" Version="3.0.0" />
-    <PackageReference Update="Shouldly" Condition="'$(ShouldlyVersion)' != ''" Version="$(ShouldlyVersion)" />
+    <PackageVersion Include="System.CodeDom" Version="7.0.0" />
+    <PackageVersion Update="System.CodeDom" Condition="'$(SystemCodeDomVersion)' != ''" Version="$(SystemCodeDomVersion)" />
 
-    <PackageReference Update="System.CodeDom" Version="7.0.0" />
-    <PackageReference Update="System.CodeDom" Condition="'$(SystemCodeDomVersion)' != ''" Version="$(SystemCodeDomVersion)" />
+    <PackageVersion Include="System.Private.Uri" Version="4.3.2" />
+    <PackageVersion Update="System.Private.Uri" Condition="'$(SystemPrivateUriVersion)' != ''" Version="$(SystemPrivateUriVersion)" />
 
-    <PackageReference Update="System.Private.Uri" Version="4.3.2" />
-    <PackageReference Update="System.Private.Uri" Condition="'$(SystemPrivateUriVersion)' != ''" Version="$(SystemPrivateUriVersion)" />
+    <PackageVersion Include="System.Runtime" Version="4.3.1" />
+    <PackageVersion Update="System.Runtime" Condition="'$(SystemRuntimeVersion)' != ''" Version="$(SystemRuntimeVersion)" />
 
-    <PackageReference Update="System.Runtime" Version="4.3.1" />
-    <PackageReference Update="System.Runtime" Condition="'$(SystemRuntimeVersion)' != ''" Version="$(SystemRuntimeVersion)" />
+    <PackageVersion Include="System.Security.Cryptography.Pkcs" Version="7.0.0" />
+    <PackageVersion Update="System.Security.Cryptography.Pkcs" Condition="'$(SystemSecurityCryptographyPkcsVersion)' != ''" Version="$(SystemSecurityCryptographyPkcsVersion)" />
 
-    <PackageReference Update="System.Security.Cryptography.Pkcs" Version="7.0.0" />
-    <PackageReference Update="System.Security.Cryptography.Pkcs" Condition="'$(SystemSecurityCryptographyPkcsVersion)' != ''" Version="$(SystemSecurityCryptographyPkcsVersion)" />
+    <PackageVersion Include="System.Security.Cryptography.Xml" Version="7.0.1" />
+    <PackageVersion Update="System.Security.Cryptography.Xml" Condition="'$(SystemSecurityCryptographyXmlVersion)' != ''" Version="$(SystemSecurityCryptographyXmlVersion)" />
 
-    <PackageReference Update="System.Security.Cryptography.Xml" Version="7.0.1" />
-    <PackageReference Update="System.Security.Cryptography.Xml" Condition="'$(SystemSecurityCryptographyXmlVersion)' != ''" Version="$(SystemSecurityCryptographyXmlVersion)" />
-
-    <PackageReference Update="System.Security.Cryptography.X509Certificates" Version="4.3.2" />
-    <PackageReference Update="System.Security.Cryptography.X509Certificates" Condition="'$(SystemSecurityCryptographyX509CertificatesVersion)' != ''" Version="$(SystemSecurityCryptographyX509CertificatesVersion)" />
+    <PackageVersion Include="System.Security.Cryptography.X509Certificates" Version="4.3.2" />
+    <PackageVersion Update="System.Security.Cryptography.X509Certificates" Condition="'$(SystemSecurityCryptographyX509CertificatesVersion)' != ''" Version="$(SystemSecurityCryptographyX509CertificatesVersion)" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true' AND $(ProjectIsDeprecated) != 'true'">
diff --git a/global.json b/global.json
index 39c8c57a412..c809c9cec27 100644
--- a/global.json
+++ b/global.json
@@ -10,7 +10,6 @@
     "xcopy-msbuild": "17.4.1"
   },
   "msbuild-sdks": {
-    "Microsoft.Build.CentralPackageVersions": "2.0.1",
     "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.23060.6"
   }
 }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index eec69a986ff..6e13af19356 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -160,7 +160,6 @@
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverException.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
     <Compile Include="FileSystem\*.cs" />
-    <Compile Include="Logging\LiveLogger\*.cs" />
     <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
     <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
     <Compile Include="BackEnd\Node\PartialBuildTelemetry.cs" />
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index 4028d29f846..c9785c3b3fe 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -48,7 +48,6 @@ internal enum ParameterlessSwitch
             FileLogger9,
             DistributedFileLogger,
             FancyLogger,
-            LiveLogger,
 #if DEBUG
             WaitForDebugger,
 #endif
@@ -219,7 +218,6 @@ internal ParameterizedSwitchInfo(
             new ParameterlessSwitchInfo(  new string[] { "filelogger9", "fl9" },            ParameterlessSwitch.FileLogger9,           null),
             new ParameterlessSwitchInfo(  new string[] { "distributedfilelogger", "dfl" },  ParameterlessSwitch.DistributedFileLogger, null),
             new ParameterlessSwitchInfo(  new string[] { "fancylogger", "flg" },            ParameterlessSwitch.FancyLogger,           null),
-            new ParameterlessSwitchInfo(  new string[] { "livelogger", "lvl" },            ParameterlessSwitch.LiveLogger,           null),
 #if DEBUG
             new ParameterlessSwitchInfo(  new string[] { "waitfordebugger", "wfd" },        ParameterlessSwitch.WaitForDebugger,       null),
 #endif
diff --git a/src/MSBuild/FancyLogger/ANSIBuilder.cs b/src/MSBuild/FancyLogger/ANSIBuilder.cs
new file mode 100644
index 00000000000..b735859d666
--- /dev/null
+++ b/src/MSBuild/FancyLogger/ANSIBuilder.cs
@@ -0,0 +1,462 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Text.RegularExpressions;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{
+    internal static class ANSIBuilder
+    {
+        public static string ANSIRegex = @"\x1b(?:[@-Z\-_]|\[[0-?]*[ -\/]*[@-~])";
+        // TODO: This should replace ANSIRegex once FancyLogger's API is internal
+        public static Regex ANSIRegexRegex = new Regex(ANSIRegex);
+        public static string ANSIRemove(string text)
+        {
+            return ANSIRegexRegex.Replace(text, "");
+        }
+
+        // TODO: This should be an optional parameter for ANSIBreakpoint(string text, int positioon, int initialPosition = 0)
+        public static int ANSIBreakpoint(string text, int position)
+        {
+            return ANSIBreakpoint(text, position, 0);
+        }
+        public static int ANSIBreakpoint(string text, int position, int initialPosition)
+        {
+            if (position >= text.Length)
+            {
+                return text.Length;
+            }
+            int nonAnsiIndex = 0;
+            // Match nextMatch = Regex.Match(text, ANSIRegex);
+            Match nextMatch = ANSIRegexRegex.Match(text, initialPosition);
+            int i = 0;
+            while (i < text.Length && nonAnsiIndex != position)
+            {
+                // Jump over ansi codes
+                if (i == nextMatch.Index && nextMatch.Length > 0)
+                {
+                    i += nextMatch.Length;
+                    nextMatch = nextMatch.NextMatch();
+                }
+                // Increment non ansi index
+                nonAnsiIndex++;
+                i++;
+            }
+            return i;
+        }
+
+        public static List<string> ANSIWrap(string text, int position)
+        {
+            ReadOnlySpan<char> textSpan = text.AsSpan();
+            List<string> result = new();
+            int breakpoint = ANSIBreakpoint(text, position);
+            while (textSpan.Length > breakpoint)
+            {
+                result.Add(textSpan.Slice(0, breakpoint).ToString());
+                textSpan = textSpan.Slice(breakpoint);
+                breakpoint = ANSIBreakpoint(text, position, breakpoint);
+            }
+            result.Add(textSpan.ToString());
+            return result;
+        }
+
+        public static class Alignment
+        {
+            public static string Center(string text)
+            {
+                string result = String.Empty;
+                string noFormatString = ANSIRemove(text);
+                if (noFormatString.Length > Console.BufferWidth)
+                {
+                    return text;
+                }
+
+                int space = (Console.BufferWidth - noFormatString.Length) / 2;
+                result += new string(' ', space);
+                result += text;
+                result += new string(' ', space);
+                return result;
+            }
+
+            public static string Right(string text)
+            {
+                string result = String.Empty;
+                string noFormatString = ANSIRemove(text);
+                if (noFormatString.Length > Console.BufferWidth)
+                {
+                    return text;
+                }
+
+                int space = Console.BufferWidth - noFormatString.Length;
+                result += new string(' ', space);
+                result += text;
+                return result;
+            }
+
+            public static string Left(string text)
+            {
+                string result = String.Empty;
+                string noFormatString = ANSIRemove(text);
+                if (noFormatString.Length > Console.BufferWidth)
+                {
+                    return text;
+                }
+
+                int space = Console.BufferWidth - noFormatString.Length;
+                result += text;
+                result += new string(' ', space);
+                return result;
+            }
+
+            public static string SpaceBetween(string leftText, string rightText, int width)
+            {
+                string result = String.Empty;
+                string leftNoFormatString = ANSIRemove(leftText);
+                string rightNoFormatString = ANSIRemove(rightText);
+                if (leftNoFormatString.Length + rightNoFormatString.Length > Console.BufferWidth)
+                {
+                    return leftText + rightText;
+                }
+
+                int space = Console.BufferWidth - (leftNoFormatString.Length + rightNoFormatString.Length);
+                result += leftText;
+                result += new string(' ', space - 1);
+                result += rightText;
+                return result;
+            }
+        }
+
+        public static class Formatting
+        {
+            public enum ForegroundColor
+            {
+                Black = 30,
+                Red = 31,
+                Green = 32,
+                Yellow = 33,
+                Blue = 34,
+                Magenta = 35,
+                Cyan = 36,
+                White = 37,
+                Default = 39
+            };
+
+            public enum BackgroundColor
+            {
+                Black = 40,
+                Red = 41,
+                Green = 42,
+                Yellow = 43,
+                Blue = 44,
+                Magenta = 45,
+                Cyan = 46,
+                White = 47,
+                Default = 49
+            }
+
+            public static string Color(string text, ForegroundColor color)
+            {
+                return String.Format("\x1b[{0}m{1}\x1b[0m", (int)color, text);
+            }
+
+            public static string Color(string text, BackgroundColor color)
+            {
+                return String.Format("\x1b[{0}m{1}\x1b[0m", (int)color, text);
+            }
+
+            public static string Color(string text, BackgroundColor backgrdoundColor, ForegroundColor foregroundColor)
+            {
+                return String.Format("\x1b[{0};{1}m{2}\x1b[0m", (int)backgrdoundColor, (int)foregroundColor, text);
+            }
+
+            public static string Bold(string text)
+            {
+                return String.Format("\x1b[1m{0}\x1b[22m", text);
+            }
+
+            public static string Dim(string text)
+            {
+                return String.Format("\x1b[2m{0}\x1b[22m", text);
+            }
+
+            public static string Italic(string text)
+            {
+                return String.Format("\x1b[3m{0}\x1b[23m", text);
+            }
+
+            public static string Underlined(string text)
+            {
+                return String.Format("\x1b[4m{0}\x1b[24m", text);
+            }
+
+            public static string DoubleUnderlined(string text)
+            {
+                return String.Format("\x1b[21m{0}\x1b[24m", text);
+            }
+
+            public static string Blinking(string text)
+            {
+                return String.Format("\x1b[5m{0}\x1b[25m", text);
+            }
+
+            public static string Inverse(string text)
+            {
+                return String.Format("\x1b[7m{0}\x1b[27m", text);
+            }
+
+            public static string Invisible(string text)
+            {
+                return String.Format("\x1b[8m{0}\x1b[28m", text);
+            }
+
+            public static string CrossedOut(string text)
+            {
+                return String.Format("\x1b[9m{0}\x1b[29m", text);
+            }
+
+            public static string Overlined(string text)
+            {
+                return String.Format("\x1b[53m{0}\x1b[55m", text);
+            }
+
+            // TODO: Right now only replaces \ with /. Needs review to make sure it works on all or most terminal emulators.
+            public static string Hyperlink(string text, string url)
+            {
+                // return String.Format("\x1b[]8;;{0}\x1b\\{1}\x1b[]8;\x1b\\", text, url);
+                return url.Replace("\\", "/");
+            }
+
+            public static string DECLineDrawing(string text)
+            {
+                return String.Format("\x1b(0{0}\x1b(B", text);
+            }
+        }
+
+        public static class Cursor
+        {
+            public enum CursorStyle
+            {
+                Default = 0,
+                BlockBlinking = 1,
+                BlockSteady = 2,
+                UnderlineBlinking = 3,
+                UnderlineSteady = 4,
+                BarBlinking = 5,
+                BarSteady = 6,
+            }
+
+            public static string Style(CursorStyle style)
+            {
+                return String.Format("\x1b[{0} q", (int)style);
+            }
+
+            public static string Up(int n = 1)
+            {
+                return String.Format("\x1b[{0}A", n);
+            }
+
+            public static string UpAndScroll(int n)
+            {
+                string result = "";
+                for (int i = 0; i < n; i++)
+                {
+                    result += "\x1bM";
+                }
+                return result;
+            }
+
+            public static string Down(int n = 1)
+            {
+                return String.Format("\x1b[{0}B", n);
+            }
+
+            public static string Forward(int n = 1)
+            {
+                return String.Format("\x1b[{0}C", n);
+            }
+
+            public static string Backward(int n = 1)
+            {
+                return String.Format("\x1b[{0}D", n);
+            }
+
+            public static string Home()
+            {
+                return String.Format("\x1b[H");
+            }
+
+            public static string Position(int row, int column)
+            {
+                return String.Format("\x1b[{0};{1}H", row, column);
+            }
+
+            public static string SavePosition()
+            {
+                return String.Format("\x1b[s");
+            }
+
+            public static string RestorePosition()
+            {
+                return String.Format("\x1b[u");
+            }
+
+            public static string Invisible()
+            {
+                return "\x1b[?25l";
+            }
+
+            public static string Visible()
+            {
+                return "\x1b[?25h";
+            }
+        }
+
+        public static class Tabulator
+        {
+            public static string SetStop()
+            {
+                return String.Format("\x1bH");
+            }
+
+            public static string ForwardTab(int n)
+            {
+                if (n == 0)
+                {
+                    return "";
+                }
+
+                return String.Format("\x1b[{0}I", n);
+            }
+
+            public static string BackwardTab(int n)
+            {
+                return String.Format("\x1b[{0}Z", n);
+            }
+
+            public static string UnsetStop()
+            {
+                return String.Format("\x1b[0g");
+            }
+
+            public static string UnserAlStops()
+            {
+                return String.Format("\x1b[3g");
+            }
+        }
+
+        public static class Viewport
+        {
+            public static string ScrollDown(int n)
+            {
+                return String.Format("\x1b[{0}T", n);
+            }
+
+            public static string ScrollUp(int n)
+            {
+                return String.Format("\x1b[{0}S", n);
+            }
+
+            public static string SetScrollingRegion(int start, int end)
+            {
+                return String.Format("\x1b[{0};{1}r", start, end);
+            }
+
+            public static string PrependLines(int n)
+            {
+                return String.Format("\x1b[{0}L", n);
+            }
+
+            public static string DeleteLines(int n)
+            {
+                return String.Format("\x1b[{0}M", n);
+            }
+        }
+
+        public static class Eraser
+        {
+            public static string DisplayCursorToEnd()
+            {
+                return String.Format("\x1b[0J");
+            }
+
+            public static string DisplayStartToCursor()
+            {
+                return String.Format("\x1b[1J");
+            }
+
+            public static string Display()
+            {
+                return String.Format("\x1b[2J");
+            }
+
+            public static string LineCursorToEnd()
+            {
+                return String.Format("\x1b[0K");
+            }
+
+            public static string LineStartToCursor()
+            {
+                return String.Format("\x1b[1K");
+            }
+
+            public static string Line()
+            {
+                return String.Format("\x1b[2k");
+            }
+        }
+
+        public static class Graphics
+        {
+            private static int spinnerCounter = 0;
+            public static string Spinner()
+            {
+                return Spinner(spinnerCounter++);
+            }
+
+            public static string Spinner(int n)
+            {
+                char[] chars = { '\\', '|', '/', '-' };
+                return chars[n % (chars.Length - 1)].ToString();
+            }
+
+            public static string ProgressBar(float percentage, int width = 10, char completedChar = '█', char remainingChar = '░')
+            {
+                string result = String.Empty;
+                for (int i = 0; i < (int)Math.Floor(width * percentage); i++)
+                {
+                    result += completedChar;
+                }
+                for (int i = (int)Math.Floor(width * percentage); i < width; i++)
+                {
+                    result += remainingChar;
+                }
+                return result;
+            }
+
+            public static string Bell()
+            {
+                return String.Format("\x07");
+            }
+        }
+
+        public static class Buffer
+        {
+            public static string Fill()
+            {
+                return String.Format("\x1b#8");
+            }
+
+            public static string UseAlternateBuffer()
+            {
+                return "\x1b[?1049h";
+            }
+
+            public static string UseMainBuffer()
+            {
+                return "\x1b[?1049l";
+            }
+        }
+    }
+}
diff --git a/src/MSBuild/FancyLogger/FancyLogger.cs b/src/MSBuild/FancyLogger/FancyLogger.cs
new file mode 100644
index 00000000000..28008e2699b
--- /dev/null
+++ b/src/MSBuild/FancyLogger/FancyLogger.cs
@@ -0,0 +1,281 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Threading.Tasks;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{
+    internal class FancyLogger : ILogger
+    {
+        private Dictionary<int, FancyLoggerProjectNode> projects = new Dictionary<int, FancyLoggerProjectNode>();
+
+        private bool Succeeded;
+
+        private float existingTasks = 1;
+        private float completedTasks = 0;
+
+        public string Parameters { get; set; }
+
+        public LoggerVerbosity Verbosity { get; set; }
+
+        public FancyLogger()
+        {
+            Parameters = "";
+        }
+
+        public void Initialize(IEventSource eventSource)
+        {
+            // Register for different events
+            // Started
+            eventSource.BuildStarted += new BuildStartedEventHandler(eventSource_BuildStarted);
+            eventSource.ProjectStarted += new ProjectStartedEventHandler(eventSource_ProjectStarted);
+            eventSource.TargetStarted += new TargetStartedEventHandler(eventSource_TargetStarted);
+            eventSource.TaskStarted += new TaskStartedEventHandler(eventSource_TaskStarted);
+            // Finished
+            eventSource.BuildFinished += new BuildFinishedEventHandler(eventSource_BuildFinished);
+            eventSource.ProjectFinished += new ProjectFinishedEventHandler(eventSource_ProjectFinished);
+            eventSource.TargetFinished += new TargetFinishedEventHandler(eventSource_TargetFinished);
+            // eventSource.TaskFinished += new TaskFinishedEventHandler(eventSource_TaskFinished);
+            // Raised
+            eventSource.MessageRaised += new BuildMessageEventHandler(eventSource_MessageRaised);
+            eventSource.WarningRaised += new BuildWarningEventHandler(eventSource_WarningRaised);
+            eventSource.ErrorRaised += new BuildErrorEventHandler(eventSource_ErrorRaised);
+            // Cancelled
+            Console.CancelKeyPress += new ConsoleCancelEventHandler(console_CancelKeyPressed);
+
+            Task.Run(() =>
+            {
+                Render();
+            });
+        }
+
+        private void Render()
+        {
+            // Initialize FancyLoggerBuffer
+            FancyLoggerBuffer.Initialize();
+            // TODO: Fix. First line does not appear at top. Leaving empty line for now
+            FancyLoggerBuffer.WriteNewLine(string.Empty);
+            // First render
+            FancyLoggerBuffer.Render();
+            int i = 0;
+            // Rerender periodically
+            while (!FancyLoggerBuffer.IsTerminated)
+            {
+                i++;
+                // Delay by 1/60 seconds
+                // Use task delay to avoid blocking the task, so that keyboard input is listened continously
+                Task.Delay((i / 60) * 1_000).ContinueWith((t) =>
+                {
+                    // Rerender projects only when needed
+                    foreach (var project in projects)
+                    {
+                        project.Value.Log();
+                    }
+                    // Rerender buffer
+                    FancyLoggerBuffer.Render();
+                });
+                // Handle keyboard input
+                if (Console.KeyAvailable)
+                {
+                    ConsoleKey key = Console.ReadKey().Key;
+                    switch (key)
+                    {
+                        case ConsoleKey.UpArrow:
+                            if (FancyLoggerBuffer.TopLineIndex > 0)
+                            {
+                                FancyLoggerBuffer.TopLineIndex--;
+                            }
+                            FancyLoggerBuffer.ShouldRerender = true;
+                            break;
+                        case ConsoleKey.DownArrow:
+                            FancyLoggerBuffer.TopLineIndex++;
+                            FancyLoggerBuffer.ShouldRerender = true;
+                            break;
+                        default:
+                            break;
+                    }
+                }
+            }
+        }
+
+        // Build
+        private void eventSource_BuildStarted(object sender, BuildStartedEventArgs e)
+        {
+        }
+
+        private void eventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
+        {
+            Succeeded = e.Succeeded;
+        }
+
+        // Project
+        private void eventSource_ProjectStarted(object sender, ProjectStartedEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            // If id already exists...
+            if (projects.ContainsKey(id))
+            {
+                return;
+            }
+            // Add project
+            FancyLoggerProjectNode node = new FancyLoggerProjectNode(e);
+            projects[id] = node;
+            // Log
+            node.ShouldRerender = true;
+        }
+
+        private void eventSource_ProjectFinished(object sender, ProjectFinishedEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node))
+            {
+                return;
+            }
+            // Update line
+            node.Finished = true;
+            // Log
+            node.ShouldRerender = true;
+        }
+
+        // Target
+        private void eventSource_TargetStarted(object sender, TargetStartedEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node))
+            {
+                return;
+            }
+            // Update
+            node.AddTarget(e);
+            // Log
+            node.ShouldRerender = true;
+        }
+
+        private void eventSource_TargetFinished(object sender, TargetFinishedEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node))
+            {
+                return;
+            }
+            // Update
+            node.FinishedTargets++;
+            // Log
+            node.ShouldRerender = true;
+        }
+
+        // Task
+        private void eventSource_TaskStarted(object sender, TaskStartedEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node))
+            {
+                return;
+            }
+            // Update
+            node.AddTask(e);
+            existingTasks++;
+            // Log
+            node.ShouldRerender = true;
+        }
+
+        private void eventSource_TaskFinished(object sender, TaskFinishedEventArgs e)
+        {
+            completedTasks++;
+        }
+
+        // Raised messages, warnings and errors
+        private void eventSource_MessageRaised(object sender, BuildMessageEventArgs e)
+        {
+            if (e is TaskCommandLineEventArgs)
+            {
+                return;
+            }
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node))
+            {
+                return;
+            }
+            // Update
+            node.AddMessage(e);
+            // Log
+            node.ShouldRerender = true;
+        }
+
+        private void eventSource_WarningRaised(object sender, BuildWarningEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node))
+            {
+                return;
+            }
+            // Update
+            node.AddWarning(e);
+            // Log
+            node.ShouldRerender = true;
+        }
+
+        private void eventSource_ErrorRaised(object sender, BuildErrorEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node))
+            {
+                return;
+            }
+            // Update
+            node.AddError(e);
+            // Log
+            node.ShouldRerender = true;
+        }
+
+        private void console_CancelKeyPressed(object? sender, ConsoleCancelEventArgs eventArgs)
+        {
+            // Shutdown logger
+            Shutdown();
+        }
+
+        public void Shutdown()
+        {
+            FancyLoggerBuffer.Terminate();
+            // TODO: Remove. There is a bug that causes switching to main buffer without deleting the contents of the alternate buffer
+            Console.Clear();
+            int errorCount = 0;
+            int warningCount = 0;
+            foreach (var project in projects)
+            {
+                errorCount += project.Value.ErrorCount;
+                warningCount += project.Value.WarningCount;
+                foreach (var message in project.Value.AdditionalDetails)
+                {
+                    Console.WriteLine(message.ToANSIString());
+                }
+            }
+
+            // Emmpty line
+            Console.WriteLine();
+            if (Succeeded)
+            {
+                Console.WriteLine(ANSIBuilder.Formatting.Color("Build succeeded.", ANSIBuilder.Formatting.ForegroundColor.Green));
+                Console.WriteLine($"\t{warningCount} Warning(s)");
+                Console.WriteLine($"\t{errorCount} Error(s)");
+            }
+            else
+            {
+                Console.WriteLine(ANSIBuilder.Formatting.Color("Build failed.", ANSIBuilder.Formatting.ForegroundColor.Red));
+                Console.WriteLine($"\t{warningCount} Warnings(s)");
+                Console.WriteLine($"\t{errorCount} Errors(s)");
+            }
+        }
+    }
+}
diff --git a/src/MSBuild/FancyLogger/FancyLoggerBuffer.cs b/src/MSBuild/FancyLogger/FancyLoggerBuffer.cs
new file mode 100644
index 00000000000..95f4283b8fd
--- /dev/null
+++ b/src/MSBuild/FancyLogger/FancyLoggerBuffer.cs
@@ -0,0 +1,239 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{
+    internal class FancyLoggerBufferLine
+    {
+        private static int Counter = 0;
+        private string _text = string.Empty;
+        public List<string> WrappedText { get; private set; } = new();
+        public int Id;
+        public bool ShouldWrapLines;
+        public string Text
+        {
+            get => _text;
+            set
+            {
+                // Set text value and get wrapped lines
+                _text = value;
+                if (ShouldWrapLines)
+                {
+                    WrappedText = ANSIBuilder.ANSIWrap(value, Console.BufferWidth);
+                }
+                else
+                {
+                    WrappedText = new List<string> { value };
+                }
+                // Buffer should rerender
+                FancyLoggerBuffer.ShouldRerender = true;
+            }
+        }
+
+        public FancyLoggerBufferLine()
+        {
+            Id = Counter++;
+            Text = string.Empty;
+            ShouldWrapLines = false;
+        }
+        public FancyLoggerBufferLine(string text)
+            : this()
+        {
+            Text = text;
+        }
+        public FancyLoggerBufferLine(string text, bool shouldWrapLines)
+            : this()
+        {
+            ShouldWrapLines = shouldWrapLines;
+            Text = text;
+        }
+    }
+
+    internal class FancyLoggerBuffer
+    {
+        private static List<FancyLoggerBufferLine> Lines = new();
+        public static int TopLineIndex = 0;
+        public static string Footer = string.Empty;
+        internal static bool IsTerminated = false;
+        internal static bool ShouldRerender = true;
+        internal static int ScrollableAreaHeight
+        {
+            get
+            {
+                // Height of the buffer -3 (titlebar, footer, and footer line)
+                return Console.BufferHeight - 3;
+            }
+        }
+        public static void Initialize()
+        {
+            // Configure buffer, encoding and cursor
+            Console.OutputEncoding = Encoding.UTF8;
+            Console.Write(ANSIBuilder.Buffer.UseAlternateBuffer());
+            Console.Write(ANSIBuilder.Cursor.Invisible());
+        }
+
+        public static void Terminate()
+        {
+            IsTerminated = true;
+            // Reset configuration for buffer and cursor, and clear screen
+            Console.Write(ANSIBuilder.Buffer.UseMainBuffer());
+            Console.Write(ANSIBuilder.Eraser.Display());
+            Console.Clear();
+            Console.Write(ANSIBuilder.Cursor.Visible());
+            Lines = new();
+        }
+
+        #region Rendering
+        public static void Render()
+        {
+            if (IsTerminated || !ShouldRerender)
+            {
+                return;
+            }
+
+            ShouldRerender = false;
+            Console.Write(
+                // Write header
+                ANSIBuilder.Cursor.Home() +
+                ANSIBuilder.Eraser.LineCursorToEnd() + ANSIBuilder.Formatting.Inverse(ANSIBuilder.Alignment.Center("MSBuild - Build in progress")) +
+                // Write footer
+                ANSIBuilder.Eraser.LineCursorToEnd() + ANSIBuilder.Cursor.Position(Console.BufferHeight - 1, 0) +
+                // TODO: Remove and replace with actual footer
+                new string('-', Console.BufferWidth) + $"\nBuild progress: XX%\tTopLineIndex={TopLineIndex}");
+
+            if (Lines.Count == 0)
+            {
+                return;
+            }
+
+            // Iterate over lines and display on terminal
+            string contents = string.Empty;
+            int accumulatedLineCount = 0;
+            int lineIndex = 0;
+            foreach (FancyLoggerBufferLine line in Lines)
+            {
+                // Continue if accum line count + next lines < scrolling area
+                if (accumulatedLineCount + line.WrappedText.Count < TopLineIndex)
+                {
+                    accumulatedLineCount += line.WrappedText.Count;
+                    continue;
+                }
+
+                // Break if exceeds scrolling area
+                if (accumulatedLineCount - TopLineIndex > ScrollableAreaHeight)
+                {
+                    break;
+                }
+
+                foreach (string s in line.WrappedText)
+                {
+                    // Get line index relative to scroll area
+                    lineIndex = accumulatedLineCount - TopLineIndex;
+                    // Print if line in scrolling area
+                    if (lineIndex >= 0 && lineIndex < ScrollableAreaHeight)
+                    {
+                        contents += ANSIBuilder.Cursor.Position(lineIndex + 2, 0) + ANSIBuilder.Eraser.LineCursorToEnd() + s;
+                    }
+
+                    accumulatedLineCount++;
+                }
+            }
+            // Iterate for the rest of the screen
+            for (int i = lineIndex + 1; i < ScrollableAreaHeight; i++)
+            {
+                contents += ANSIBuilder.Cursor.Position(i + 2, 0) + ANSIBuilder.Eraser.LineCursorToEnd();
+            }
+            Console.Write(contents);
+        }
+        #endregion
+        #region Line identification
+        public static int GetLineIndexById(int lineId)
+        {
+            return Lines.FindIndex(x => x.Id == lineId);
+        }
+
+        public static FancyLoggerBufferLine? GetLineById(int lineId)
+        {
+            int index = GetLineIndexById(lineId);
+            if (index == -1)
+            {
+                return null;
+            }
+
+            return Lines[index];
+        }
+        #endregion
+
+        #region Line create, update and delete
+        // Write new line
+        public static FancyLoggerBufferLine? WriteNewLineAfter(int lineId, string text)
+        {
+            return WriteNewLineAfter(lineId, text, true);
+        }
+        public static FancyLoggerBufferLine? WriteNewLineAfter(int lineId, string text, bool shouldWrapLines)
+        {
+            FancyLoggerBufferLine line = new FancyLoggerBufferLine(text, shouldWrapLines);
+            return WriteNewLineAfter(lineId, line);
+        }
+        public static FancyLoggerBufferLine? WriteNewLineAfter(int lineId, FancyLoggerBufferLine line)
+        {
+            if (lineId != -1)
+            {
+                // Get line index
+                int lineIndex = GetLineIndexById(lineId);
+                if (lineIndex == -1)
+                {
+                    return null;
+                }
+                // Get line end index
+                Lines.Insert(lineIndex, line);
+            }
+            else
+            {
+                Lines.Add(line);
+            }
+            return line;
+        }
+
+        public static FancyLoggerBufferLine? WriteNewLine(string text)
+        {
+            return WriteNewLine(text, true);
+        }
+        public static FancyLoggerBufferLine? WriteNewLine(string text, bool shouldWrapLines)
+        {
+            FancyLoggerBufferLine line = new FancyLoggerBufferLine(text, shouldWrapLines);
+            return WriteNewLine(line);
+        }
+        public static FancyLoggerBufferLine? WriteNewLine(FancyLoggerBufferLine line)
+        {
+            return WriteNewLineAfter(Lines.Count > 0 ? Lines.Last().Id : -1, line);
+        }
+
+        // Update line
+        // TODO: Remove. Use line.Text instead
+        public static FancyLoggerBufferLine? UpdateLine(int lineId, string text)
+        {
+            return null;
+        }
+
+        // Delete line
+        public static void DeleteLine(int lineId)
+        {
+            // Get line index
+            int lineIndex = GetLineIndexById(lineId);
+            if (lineIndex == -1)
+            {
+                return;
+            }
+            // Delete
+            Lines.RemoveAt(lineIndex);
+            ShouldRerender = true;
+        }
+        #endregion
+    }
+}
diff --git a/src/MSBuild/FancyLogger/FancyLoggerMessageNode.cs b/src/MSBuild/FancyLogger/FancyLoggerMessageNode.cs
new file mode 100644
index 00000000000..73ce25f47d2
--- /dev/null
+++ b/src/MSBuild/FancyLogger/FancyLoggerMessageNode.cs
@@ -0,0 +1,86 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{
+
+    internal class FancyLoggerMessageNode
+    {
+        // Use this to change the max lenngth (relative to screen size) of messages
+        private static int MAX_LENGTH = 3 * Console.BufferWidth;
+        public enum MessageType
+        {
+            HighPriorityMessage,
+            Warning,
+            Error
+        }
+        public string Message;
+        public FancyLoggerBufferLine? Line;
+        public MessageType Type;
+        public string? Code;
+        public string? FilePath;
+        public int? LineNumber;
+        public int? ColumnNumber;
+        public FancyLoggerMessageNode(LazyFormattedBuildEventArgs args)
+        {
+            Message = args.Message ?? string.Empty;
+            if (Message.Length > MAX_LENGTH)
+            {
+                Message = Message.Substring(0, MAX_LENGTH - 1) + "…";
+            }
+            // Get type
+            switch (args)
+            {
+                case BuildMessageEventArgs:
+                    Type = MessageType.HighPriorityMessage;
+                    break;
+                case BuildWarningEventArgs warning:
+                    Type = MessageType.Warning;
+                    Code = warning.Code;
+                    FilePath = warning.File;
+                    LineNumber = warning.LineNumber;
+                    ColumnNumber = warning.ColumnNumber;
+                    break;
+                case BuildErrorEventArgs error:
+                    Type = MessageType.Error;
+                    Code = error.Code;
+                    FilePath = error.File;
+                    LineNumber = error.LineNumber;
+                    ColumnNumber = error.ColumnNumber;
+                    break;
+            }
+        }
+
+        public string ToANSIString()
+        {
+            switch (Type)
+            {
+                case MessageType.Warning:
+                    return $"⚠️ {ANSIBuilder.Formatting.Color(
+                        $"Warning {Code}: {FilePath}({LineNumber},{ColumnNumber}) {Message}",
+                        ANSIBuilder.Formatting.ForegroundColor.Yellow)}";
+                case MessageType.Error:
+                    return $"❌ {ANSIBuilder.Formatting.Color(
+                        $"Error {Code}: {FilePath}({LineNumber},{ColumnNumber}) {Message}",
+                        ANSIBuilder.Formatting.ForegroundColor.Red)}";
+                case MessageType.HighPriorityMessage:
+                default:
+                    return $"ℹ️ {ANSIBuilder.Formatting.Italic(Message)}";
+            }
+        }
+
+        // TODO: Rename to Log after FancyLogger's API becomes internal
+        public void Log()
+        {
+            if (Line == null)
+            {
+                return;
+            }
+
+            Line.Text = $"    └── {ToANSIString()}";
+        }
+    }
+}
diff --git a/src/MSBuild/FancyLogger/FancyLoggerProjectNode.cs b/src/MSBuild/FancyLogger/FancyLoggerProjectNode.cs
new file mode 100644
index 00000000000..00e1cd8090a
--- /dev/null
+++ b/src/MSBuild/FancyLogger/FancyLoggerProjectNode.cs
@@ -0,0 +1,189 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{
+    internal class FancyLoggerProjectNode
+    {
+        /// <summary>
+        /// Given a list of paths, this method will get the shortest not ambiguous path for a project.
+        /// Example: for `/users/documents/foo/project.csproj` and `/users/documents/bar/project.csproj`, the respective non ambiguous paths would be `foo/project.csproj` and `bar/project.csproj`
+        /// Still work in progress...
+        /// </summary>
+        private static string GetUnambiguousPath(string path)
+        {
+            return Path.GetFileName(path);
+        }
+
+        public int Id;
+        public string ProjectPath;
+        public string TargetFramework;
+        public bool Finished;
+        // Line to display project info
+        public FancyLoggerBufferLine? Line;
+        // Targets
+        public int FinishedTargets;
+        public FancyLoggerBufferLine? CurrentTargetLine;
+        public FancyLoggerTargetNode? CurrentTargetNode;
+        // Messages, errors and warnings
+        public List<FancyLoggerMessageNode> AdditionalDetails = new();
+        // Count messages, warnings and errors
+        public int MessageCount = 0;
+        public int WarningCount = 0;
+        public int ErrorCount = 0;
+        // Bool if node should rerender
+        internal bool ShouldRerender = true;
+        public FancyLoggerProjectNode(ProjectStartedEventArgs args)
+        {
+            Id = args.ProjectId;
+            ProjectPath = args.ProjectFile!;
+            Finished = false;
+            FinishedTargets = 0;
+            if (args.GlobalProperties != null && args.GlobalProperties.ContainsKey("TargetFramework"))
+            {
+                TargetFramework = args.GlobalProperties["TargetFramework"];
+            }
+            else
+            {
+                TargetFramework = "";
+            }
+        }
+
+        // TODO: Rename to Render() after FancyLogger's API becomes internal
+        public void Log()
+        {
+            if (!ShouldRerender)
+            {
+                return;
+            }
+
+            ShouldRerender = false;
+            // Project details
+            string lineContents = ANSIBuilder.Alignment.SpaceBetween(
+                // Show indicator
+                (Finished ? ANSIBuilder.Formatting.Color("✓", ANSIBuilder.Formatting.ForegroundColor.Green) : ANSIBuilder.Formatting.Blinking(ANSIBuilder.Graphics.Spinner())) +
+                // Project
+                ANSIBuilder.Formatting.Dim("Project: ") +
+                // Project file path with color
+                $"{ANSIBuilder.Formatting.Color(ANSIBuilder.Formatting.Bold(GetUnambiguousPath(ProjectPath)), Finished ? ANSIBuilder.Formatting.ForegroundColor.Green : ANSIBuilder.Formatting.ForegroundColor.Default)} [{TargetFramework ?? "*"}]",
+                $"({MessageCount} Messages, {WarningCount} Warnings, {ErrorCount} Errors)",
+                Console.WindowWidth);
+
+            // Create or update line
+            if (Line is null)
+            {
+                Line = FancyLoggerBuffer.WriteNewLine(lineContents, false);
+            }
+            else
+            {
+                Line.Text = lineContents;
+            }
+
+            // For finished projects
+            if (Finished)
+            {
+                if (CurrentTargetLine is not null)
+                {
+                    FancyLoggerBuffer.DeleteLine(CurrentTargetLine.Id);
+                }
+
+                foreach (FancyLoggerMessageNode node in AdditionalDetails.ToList())
+                {
+                    // Only delete high priority messages
+                    if (node.Type != FancyLoggerMessageNode.MessageType.HighPriorityMessage)
+                    {
+                        continue;
+                    }
+
+                    if (node.Line is not null)
+                    {
+                        FancyLoggerBuffer.DeleteLine(node.Line.Id);
+                    }
+                }
+            }
+
+            // Current target details
+            if (CurrentTargetNode is null)
+            {
+                return;
+            }
+
+            string currentTargetLineContents = $"    └── {CurrentTargetNode.TargetName} : {CurrentTargetNode.CurrentTaskNode?.TaskName ?? String.Empty}";
+            if (CurrentTargetLine is null)
+            {
+                CurrentTargetLine = FancyLoggerBuffer.WriteNewLineAfter(Line!.Id, currentTargetLineContents);
+            }
+            else
+            {
+                CurrentTargetLine.Text = currentTargetLineContents;
+            }
+
+            // Messages, warnings and errors
+            foreach (FancyLoggerMessageNode node in AdditionalDetails)
+            {
+                if (Finished && node.Type == FancyLoggerMessageNode.MessageType.HighPriorityMessage)
+                {
+                    continue;
+                }
+
+                if (node.Line is null)
+                {
+                    node.Line = FancyLoggerBuffer.WriteNewLineAfter(Line!.Id, "Message");
+                }
+
+                node.Log();
+            }
+        }
+
+        public FancyLoggerTargetNode AddTarget(TargetStartedEventArgs args)
+        {
+            CurrentTargetNode = new FancyLoggerTargetNode(args);
+            return CurrentTargetNode;
+        }
+        public FancyLoggerTaskNode? AddTask(TaskStartedEventArgs args)
+        {
+            // Get target id
+            int targetId = args.BuildEventContext!.TargetId;
+            if (CurrentTargetNode?.Id == targetId)
+            {
+                return CurrentTargetNode.AddTask(args);
+            }
+            else
+            {
+                return null;
+            }
+        }
+        public FancyLoggerMessageNode? AddMessage(BuildMessageEventArgs args)
+        {
+            if (args.Importance != MessageImportance.High)
+            {
+                return null;
+            }
+
+            MessageCount++;
+            FancyLoggerMessageNode node = new FancyLoggerMessageNode(args);
+            AdditionalDetails.Add(node);
+            return node;
+        }
+        public FancyLoggerMessageNode? AddWarning(BuildWarningEventArgs args)
+        {
+            WarningCount++;
+            FancyLoggerMessageNode node = new FancyLoggerMessageNode(args);
+            AdditionalDetails.Add(node);
+            return node;
+        }
+        public FancyLoggerMessageNode? AddError(BuildErrorEventArgs args)
+        {
+            ErrorCount++;
+            FancyLoggerMessageNode node = new FancyLoggerMessageNode(args);
+            AdditionalDetails.Add(node);
+            return node;
+        }
+    }
+}
diff --git a/src/MSBuild/FancyLogger/FancyLoggerTargetNode.cs b/src/MSBuild/FancyLogger/FancyLoggerTargetNode.cs
new file mode 100644
index 00000000000..21430209d83
--- /dev/null
+++ b/src/MSBuild/FancyLogger/FancyLoggerTargetNode.cs
@@ -0,0 +1,25 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{
+
+    internal class FancyLoggerTargetNode
+    {
+        public int Id;
+        public string TargetName;
+        public FancyLoggerTaskNode? CurrentTaskNode;
+        public FancyLoggerTargetNode(TargetStartedEventArgs args)
+        {
+            Id = args.BuildEventContext!.TargetId;
+            TargetName = args.TargetName;
+        }
+        public FancyLoggerTaskNode AddTask(TaskStartedEventArgs args)
+        {
+            CurrentTaskNode = new FancyLoggerTaskNode(args);
+            return CurrentTaskNode;
+        }
+    }
+}
diff --git a/src/MSBuild/FancyLogger/FancyLoggerTaskNode.cs b/src/MSBuild/FancyLogger/FancyLoggerTaskNode.cs
new file mode 100644
index 00000000000..7ad82beca4a
--- /dev/null
+++ b/src/MSBuild/FancyLogger/FancyLoggerTaskNode.cs
@@ -0,0 +1,19 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{
+
+    internal class FancyLoggerTaskNode
+    {
+        public int Id;
+        public string TaskName;
+        public FancyLoggerTaskNode(TaskStartedEventArgs args)
+        {
+            Id = args.BuildEventContext!.TaskId;
+            TaskName = args.TaskName;
+        }
+    }
+}
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 95bc896aa7c..f2ef7143789 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -17,6 +17,7 @@
 using System.Text;
 using System.Text.RegularExpressions;
 using System.Threading;
+
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
@@ -27,6 +28,7 @@
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
+
 using FileLogger = Microsoft.Build.Logging.FileLogger;
 using ConsoleLogger = Microsoft.Build.Logging.ConsoleLogger;
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
@@ -36,7 +38,7 @@
 using Microsoft.Build.Experimental;
 using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Internal;
-using Microsoft.Build.Logging.LiveLogger;
+using Microsoft.Build.Logging.FancyLogger;
 using System.Runtime.InteropServices;
 
 #nullable disable
@@ -2405,7 +2407,6 @@ private static bool ProcessCommandLineSwitches(
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoConsoleLogger],
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.DistributedFileLogger],
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.FancyLogger],
-                        commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.LiveLogger],
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.FileLoggerParameters], // used by DistributedFileLogger
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ConsoleLoggerParameters],
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.BinaryLogger],
@@ -3187,7 +3188,6 @@ private static ILogger[] ProcessLoggingSwitches(
             bool noConsoleLogger,
             bool distributedFileLogger,
             bool fancyLoggerCommandLineOptIn,
-            bool liveLoggerCommandLineOptIn,
             string[] fileLoggerParameters,
             string[] consoleLoggerParameters,
             string[] binaryLoggerParameters,
@@ -3217,11 +3217,9 @@ private static ILogger[] ProcessLoggingSwitches(
             distributedLoggerRecords = ProcessDistributedLoggerSwitch(distributedLoggerSwitchParameters, verbosity);
 
             // Choose default console logger
-            if (
-                (fancyLoggerCommandLineOptIn || liveLoggerCommandLineOptIn || Environment.GetEnvironmentVariable("MSBUILDFANCYLOGGER") == "true" || Environment.GetEnvironmentVariable("MSBUILDLIVELOGGER") == "true")
-                && DoesEnvironmentSupportLiveLogger())
+            if ((fancyLoggerCommandLineOptIn || Environment.GetEnvironmentVariable("MSBUILDFANCYLOGGER") == "true") && DoesEnvironmentSupportFancyLogger())
             {
-                ProcessLiveLogger(noConsoleLogger, loggers);
+                ProcessFancyLogger(noConsoleLogger, loggers);
             }
             else
             {
@@ -3400,13 +3398,13 @@ internal static void ProcessConsoleLoggerSwitch(
             }
         }
 
-        private static bool DoesEnvironmentSupportLiveLogger()
+        private static bool DoesEnvironmentSupportFancyLogger()
         {
             // If output is redirected
             if (Console.IsOutputRedirected)
             {
                 messagesToLogInBuildLoggers.Add(
-                    new BuildManager.DeferredBuildMessage("LiveLogger was not used because the output is being redirected to a file.", MessageImportance.Low));
+                    new BuildManager.DeferredBuildMessage("FancyLogger was not used because the output is being redirected to a file.", MessageImportance.Low));
                 return false;
             }
             // If terminal is dumb
@@ -3415,20 +3413,20 @@ private static bool DoesEnvironmentSupportLiveLogger()
                 || Environment.GetEnvironmentVariable("TERM") == "dumb")
             {
                 messagesToLogInBuildLoggers.Add(
-                    new BuildManager.DeferredBuildMessage("LiveLogger was not used because the output is not supported.", MessageImportance.Low));
+                    new BuildManager.DeferredBuildMessage("FancyLogger was not used because the output is not supported.", MessageImportance.Low));
                 return false;
             }
             return true;
         }
 
-        private static void ProcessLiveLogger(
+        private static void ProcessFancyLogger(
             bool noConsoleLogger,
             List<ILogger> loggers)
         {
             // Check for flags and env variables
             if (!noConsoleLogger)
             {
-                LiveLogger l = new LiveLogger();
+                FancyLogger l = new FancyLogger();
                 loggers.Add(l);
             }
         }
diff --git a/src/Samples/Directory.Build.props b/src/Samples/Directory.Build.props
index 317ef14a6bb..69f108f98e7 100644
--- a/src/Samples/Directory.Build.props
+++ b/src/Samples/Directory.Build.props
@@ -5,7 +5,8 @@
     <OutDirName>Samples\$(MSBuildProjectName)</OutDirName>
 
     <!-- Don't regulate package versions for samples -->
-    <EnableCentralPackageVersions>false</EnableCentralPackageVersions>
+    <ManagePackageVersionsCentrally>false</ManagePackageVersionsCentrally>
+    <ImportDirectoryPackagesProps>false</ImportDirectoryPackagesProps>
 
     <IsShipping>false</IsShipping>
     <ExcludeFromSourceBuild>true</ExcludeFromSourceBuild>
