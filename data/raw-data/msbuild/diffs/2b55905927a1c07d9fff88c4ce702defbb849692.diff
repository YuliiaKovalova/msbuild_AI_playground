diff --git a/eng/Packages.props b/eng/Packages.props
index b6e51805983..7334fbeb8d7 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -10,7 +10,7 @@
   <ItemGroup>
     <PackageReference Update="Microsoft.Build.NuGetSdkResolver" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="Microsoft.CodeAnalysis.Build.Tasks" Version="$(MicrosoftNetCompilersToolsetVersion)" />
-    <PackageReference Update="Microsoft.CodeAnalysis.Collections" Version="4.0.0-4.21379.20" />
+    <PackageReference Update="Microsoft.CodeAnalysis.Collections" Version="4.2.0-1.22102.8" />
     <PackageReference Update="Microsoft.DotNet.XUnitExtensions" Version="$(MicrosoftDotNetXUnitExtensionsVersion)" />
     <PackageReference Update="Microsoft.IO.Redist" Version="6.0.0" />
     <PackageReference Update="Microsoft.Net.Compilers.Toolset" Version="$(MicrosoftNetCompilersToolsetVersion)" />
diff --git a/global.json b/global.json
index 67c77c202c4..853a648e358 100644
--- a/global.json
+++ b/global.json
@@ -3,7 +3,7 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "6.0.101",
+    "dotnet": "6.0.200",
     "vs": {
       "version": "17.0"
     }
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index 42ff3d408de..c39946e0c80 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -7,9 +7,11 @@
 using System.Linq;
 using System.Xml;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Definition;
 using Microsoft.Build.Engine.UnitTests.Globbing;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Shouldly;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
@@ -31,6 +33,7 @@ public class ProjectItem_Tests : IDisposable
                         </ItemGroup>
                     </Project>
                 ";
+
         internal const string ItemWithIncludeUpdateAndRemove = @"
                     <Project>
                         <ItemGroup>
@@ -45,6 +48,12 @@ public class ProjectItem_Tests : IDisposable
                     </Project>
                 ";
 
+        internal const string ImportProjectElement = @"
+                    <Project>
+                        <Import Project='{0}'/>
+                    </Project>
+                ";
+
         protected TestEnvironment _env;
 
         public ProjectItem_Tests()
@@ -755,6 +764,220 @@ public void IncludeWithWildcardShouldNotPreserveUserSlashesInFixedDirectoryPart(
             TestIncludeExclude(projectContents, inputFiles, expectedInclude, includeString, "");
         }
 
+        /// <summary>
+        /// Project getter that renames an item to a drive enumerating wildcard that results in an exception.
+        /// </summary>
+        [Theory]
+        [InlineData(@"\**\*.log")]
+        [InlineData(@"$(empty)\**\*.log")]
+        [InlineData(@"\$(empty)**\*.log")]
+        [InlineData(@"\*$(empty)*\*.log")]
+        public void ProjectGetterResultsInDriveEnumerationException(string unevaluatedInclude)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                try
+                {
+                    // Setup
+                    Helpers.ResetStateForDriveEnumeratingWildcardTests(env, "1");
+                    Project project = new Project();
+
+                    // Add item and verify
+                    Should.Throw<InvalidProjectFileException>(() => { _ = project.AddItem("i", unevaluatedInclude); });
+                }
+                finally
+                {
+                    ChangeWaves.ResetStateForTests();
+                }
+            }
+        }
+
+        /// <summary>
+        /// Project getter that renames an item to a drive enumerating wildcard that results in a logged warning.
+        /// </summary>
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(@"z:\**\*.log")]
+        [InlineData(@"z:$(empty)\**\*.log")]
+        [InlineData(@"z:\**")]
+        [InlineData(@"z:\\**")]
+        [InlineData(@"z:\\\\\\\\**")]
+        [InlineData(@"z:\**\*.cs")]
+        public void ProjectGetterResultsInWindowsDriveEnumerationWarning(string unevaluatedInclude)
+        {
+            ProjectGetterResultsInDriveEnumerationWarning(unevaluatedInclude);
+        }
+
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [Theory]
+        [InlineData(@"/**/*.log")]
+        [InlineData(@"$(empty)/**/*.log")]
+        [InlineData(@"/$(empty)**/*.log")]
+        [InlineData(@"/*$(empty)*/*.log")]
+        public void ProjectGetterResultsInUnixDriveEnumerationWarning(string unevaluatedInclude)
+        {
+            ProjectGetterResultsInDriveEnumerationWarning(unevaluatedInclude);
+        }
+
+        private static void ProjectGetterResultsInDriveEnumerationWarning(string unevaluatedInclude)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                try
+                {
+                    // Reset state
+                    Helpers.ResetStateForDriveEnumeratingWildcardTests(env, "0");
+
+                    // Setup
+                    ProjectCollection projectCollection = new ProjectCollection();
+                    MockLogger collectionLogger = new MockLogger();
+                    projectCollection.RegisterLogger(collectionLogger);
+                    Project project = new Project(projectCollection);
+
+                    // Add item
+                    _= project.AddItem("i", unevaluatedInclude);
+
+                    // Verify
+                    collectionLogger.WarningCount.ShouldBe(1);
+                    collectionLogger.AssertLogContains("MSB5029");
+                    projectCollection.UnregisterAllLoggers();
+                }
+                finally
+                {
+                    ChangeWaves.ResetStateForTests();
+                }
+            }
+        }
+
+        /// <summary>
+        /// Project instance created from a file that contains a drive enumerating wildcard results in a thrown exception.
+        /// </summary>
+        [Theory]
+        [InlineData(
+            ImportProjectElement,
+            @"$(Microsoft_WindowsAzure_EngSys)\**\*",
+            null)]
+
+        // LazyItem.IncludeOperation
+        [InlineData(
+            ItemWithIncludeAndExclude,
+            @"$(Microsoft_WindowsAzure_EngSys)\**\*",
+            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb;$(Microsoft_WindowsAzure_EngSys)\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\Certificates\**\*")]
+
+        // LazyItem.IncludeOperation for Exclude
+        [InlineData(
+            ItemWithIncludeAndExclude,
+            @"$(EmptyProperty)\*.cs",
+            @"$(Microsoft_WindowsAzure_EngSys)\**")]
+        public void ThrowExceptionUponProjectInstanceCreationFromDriveEnumeratingContent(string content, string placeHolder, string excludePlaceHolder = null)
+        {
+            content = string.Format(content, placeHolder, excludePlaceHolder);
+            CleanContentsAndCreateProjectInstanceFromFileWithDriveEnumeratingWildcard(content, true);
+        }
+
+        /// <summary>
+        /// Project instance created from a file that contains a drive enumerating wildcard results in a logged warning on the Windows platform.
+        /// </summary>
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(
+            ImportProjectElement,
+            @"z:\**\*.targets",
+            null)]
+
+        // LazyItem.IncludeOperation
+        [InlineData(
+            ItemWithIncludeAndExclude,
+            @"z:$(Microsoft_WindowsAzure_EngSys)\**\*",
+            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb;$(Microsoft_WindowsAzure_EngSys)\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\Certificates\**\*")]
+
+        // LazyItem.IncludeOperation for Exclude
+        [InlineData(
+            ItemWithIncludeAndExclude,
+            @"$(EmptyProperty)\*.cs",
+            @"z:\$(Microsoft_WindowsAzure_EngSys)**")]
+        public void LogWindowsWarningUponProjectInstanceCreationFromDriveEnumeratingContent(string content, string placeHolder, string excludePlaceHolder = null)
+        {
+            content = string.Format(content, placeHolder, excludePlaceHolder);
+            CleanContentsAndCreateProjectInstanceFromFileWithDriveEnumeratingWildcard(content, false);
+        }
+
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [Theory]
+        [InlineData(
+            ImportProjectElement,
+            @"\**\*.targets",
+            null)]
+
+        // LazyItem.IncludeOperation
+        [InlineData(
+            ItemWithIncludeAndExclude,
+            @"$(Microsoft_WindowsAzure_EngSys)\**\*",
+            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb;$(Microsoft_WindowsAzure_EngSys)\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\Certificates\**\*")]
+
+        // LazyItem.IncludeOperation for Exclude
+        [InlineData(
+            ItemWithIncludeAndExclude,
+            @"$(EmptyProperty)\*.cs",
+            @"$(Microsoft_WindowsAzure_EngSys)\**")]
+        public void LogWarningUponProjectInstanceCreationFromDriveEnumeratingContent(string content, string placeHolder, string excludePlaceHolder = null)
+        {
+            content = string.Format(content, placeHolder, excludePlaceHolder);
+                CleanContentsAndCreateProjectInstanceFromFileWithDriveEnumeratingWildcard(content, false);
+        }
+
+        private static void CleanContentsAndCreateProjectInstanceFromFileWithDriveEnumeratingWildcard(string content, bool throwException)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                // Clean file contents by replacing single quotes with double quotes, etc.
+                content = ObjectModelHelpers.CleanupFileContents(content);
+                var testProject = env.CreateTestProjectWithFiles(content.Cleanup());
+
+                // Setup and create project instance from file
+                CreateProjectInstanceFromFileWithDriveEnumeratingWildcard(env, testProject.ProjectFile, throwException);
+            }
+        }
+
+        private static void CreateProjectInstanceFromFileWithDriveEnumeratingWildcard(TestEnvironment env, string testProjectFile, bool throwException)
+        {
+            try
+            {
+                // Reset state 
+                Helpers.ResetStateForDriveEnumeratingWildcardTests(env, throwException ? "1" : "0");
+
+                if (throwException)
+                {
+                    // Verify
+                    Should.Throw<InvalidProjectFileException>(() => { ProjectInstance.FromFile(testProjectFile, new ProjectOptions()); });
+                }
+                else
+                {
+                    // Setup
+                    MockLogger collectionLogger = new MockLogger();
+                    ProjectOptions options = new ProjectOptions();
+                    options.ProjectCollection = new ProjectCollection();
+                    options.ProjectCollection.RegisterLogger(collectionLogger);
+
+                    // Action
+                    ProjectInstance.FromFile(testProjectFile, options);
+
+                    // Verify
+                    collectionLogger.WarningCount.ShouldBe(1);
+                    collectionLogger.AssertLogContains("MSB5029");
+                    options.ProjectCollection.UnregisterAllLoggers();
+                }
+            }
+            finally
+            {
+                ChangeWaves.ResetStateForTests();
+            }
+        }
+
         private static void TestIncludeExcludeWithDifferentSlashes(string projectContents, string includeString, string excludeString, string[] inputFiles, string[] expectedInclude, bool makeExpectedIncludeAbsolute = false)
         {
             Action<string, string> runTest = (include, exclude) =>
@@ -909,7 +1132,7 @@ public void IncludeAndExcludeWorkWithRelativeAndAbsolutePaths(
         [InlineData(
             "../a.cs;b.cs", // include string
             "**/*.cs", // exclude string
-            new[] { "a.cs", "ProjectDir/b.cs" }, // files to create relative to the test root dir
+            new[] {"a.cs", "ProjectDir/b.cs"}, // files to create relative to the test root dir
             "ProjectDir", // relative path from test root to project
             new[] { "../a.cs" } // expected items
             )]
diff --git a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
index 02e91aa5a06..c3316bb2267 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
@@ -7,6 +7,7 @@
 using System.Xml;
 
 using Microsoft.Build.Construction;
+using Microsoft.Build.Definition;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -14,6 +15,7 @@
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
+using Shouldly;
 using System.Linq;
 
 #nullable disable
@@ -30,6 +32,39 @@ public class ProjectItemInstance_Tests
         /// </summary>
         public const int BuiltInMetadataCount = 15;
 
+        internal const string TargetItemWithInclude = @"
+            <Project>
+                <Target Name='TestTarget'>
+                    <ItemGroup>
+                        <i Include='{0}'/>
+                    </ItemGroup>
+                </Target>
+            </Project>
+            ";
+
+        internal const string TargetItemWithIncludeAndExclude = @"
+            <Project>
+                <Target Name='TestTarget'>
+                    <ItemGroup>
+                        <i Include='{0}' Exclude='{1}'/>
+                    </ItemGroup>
+                </Target>
+            </Project>
+            ";
+
+        internal const string TargetWithDefinedPropertyAndItemWithInclude = @"
+            <Project>
+                <PropertyGroup>
+                    <{0}>{1}</{0}>
+                </PropertyGroup>
+                <Target Name='TestTarget'>
+                    <ItemGroup>
+                        <i Include='{2}' />
+                    </ItemGroup>
+                </Target>
+            </Project>
+            ";
+
         /// <summary>
         /// Basic ProjectItemInstance without metadata
         /// </summary>
@@ -837,6 +872,162 @@ public void MetadataConditionReferringToMetadataOnSameItem()
             Assert.Equal(String.Empty, items[0].GetMetadataValue("m2"));
         }
 
+        /// <summary>
+        /// Fail build for drive enumerating wildcards that exist in projects on any platform.
+        /// </summary>
+        [Theory]
+        [InlineData(
+            TargetItemWithIncludeAndExclude,
+            @"$(Microsoft_WindowsAzure_EngSys)\**\*",
+            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb;$(Microsoft_WindowsAzure_EngSys)\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\Certificates\**\*")]
+
+        [InlineData(
+            TargetItemWithIncludeAndExclude,
+            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb",
+            @"$(Microsoft_WindowsAzure_EngSys)\**\*")]
+
+        [InlineData(
+            TargetItemWithInclude,
+            @"$(Microsoft_WindowsAzure_EngSys)\**\*")]
+
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            "$(Microsoft_WindowsAzure_EngSys)**",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"\")]
+        public void ThrowExceptionUponBuildingProjectWithDriveEnumeration(string content, string include, string exclude = null, string property = null, string propertyValue = null)
+        {
+            content = (string.IsNullOrEmpty(property) && string.IsNullOrEmpty(propertyValue)) ?
+                string.Format(content, include, exclude) :
+                string.Format(content, property, propertyValue, include);
+
+            Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
+                content,
+                "1",
+                "TestTarget",
+                Helpers.ExpectedBuildResult.FailWithError);
+        }
+
+        /// <summary>
+        /// Log warning for drive enumerating wildcards that exist in projects on Windows platform.
+        /// </summary>
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(
+            TargetItemWithIncludeAndExclude,
+            @"z:$(Microsoft_WindowsAzure_EngSys)\**\*",
+            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb;$(Microsoft_WindowsAzure_EngSys)\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\Certificates\**\*")]
+
+        [InlineData(
+            TargetItemWithIncludeAndExclude,
+            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb",
+            @"z:$(Microsoft_WindowsAzure_EngSys)\**\*")]
+
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @"$(Microsoft_WindowsAzure_EngSys)**",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"z:\")]
+
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @"$(Microsoft_WindowsAzure_EngSys)\**\*",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"z:")]
+        public void LogWindowsWarningUponBuildingProjectWithDriveEnumeration(string content, string include, string exclude = null, string property = null, string propertyValue = null)
+        {
+            content = (string.IsNullOrEmpty(property) && string.IsNullOrEmpty(propertyValue)) ?
+                string.Format(content, include, exclude) :
+                string.Format(content, property, propertyValue, include);
+
+            Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
+                content,
+                "0",
+                "TestTarget",
+                Helpers.ExpectedBuildResult.SucceedWithWarning);
+        }
+
+        /// <summary>
+        /// Log warning for drive enumerating wildcards that exist in projects on Unix platform.
+        /// </summary>
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [Theory]
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @"$(Microsoft_WindowsAzure_EngSys)**",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"/")]
+
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @"$(Microsoft_WindowsAzure_EngSys)*/*.log",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"/*")]
+        public void LogUnixWarningUponBuildingProjectWithDriveEnumeration(string content, string include, string exclude = null, string property = null, string propertyValue = null)
+        {
+            content = (string.IsNullOrEmpty(property) && string.IsNullOrEmpty(propertyValue)) ?
+                    string.Format(content, include, exclude) :
+                    string.Format(content, property, propertyValue, include);
+
+            Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
+                    content,
+                    "0",
+                    "TestTarget",
+                    Helpers.ExpectedBuildResult.SucceedWithWarning);
+        }
+
+        /// <summary>
+        /// Tests target item evaluation resulting in no build failures.
+        /// </summary>
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @"$(Microsoft_WindowsAzure_EngSys)*.cs",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"c:\*\")]
+
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @"\$(Microsoft_WindowsAzure_EngSys)*\*.cs",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"c:")]
+
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @":\$(Microsoft_WindowsAzure_EngSys)*\*.log",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"c")]
+
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @"$(Microsoft_WindowsAzure_EngSys)*\*.log",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"\")]
+        public void NoErrorsAndWarningsUponBuildingProject(string content, string include, string exclude = null, string property = null, string propertyValue = null)
+        {
+            content = (string.IsNullOrEmpty(property) && string.IsNullOrEmpty(propertyValue)) ?
+                    string.Format(content, include, exclude) :
+                    string.Format(content, property, propertyValue, include);
+
+            Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
+                content,
+                "0",
+                "TestTarget",
+                Helpers.ExpectedBuildResult.SucceedWithNoErrorsAndWarnings);
+        }
+
         [Fact]
         public void UpdateShouldRespectConditions()
         {
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index 95001217b5d..8ddca6108ac 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -36,9 +36,9 @@
     <ProjectReference Include="..\Samples\TaskWithDependency\TaskWithDependency.csproj" Private="false" ReferenceOutputAssembly="false" OutputItemType="TaskWithDependencyResolvedProjectReferencePath">
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">TargetFramework=$(FullFrameworkTFM)</SetTargetFramework>
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MonoBuild)' == 'true'">TargetFramework=$(FullFrameworkTFM)</SetTargetFramework>
-      <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">TargetFramework=netstandard2.0</SetTargetFramework>
+      <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">TargetFramework=net6.0</SetTargetFramework>
     </ProjectReference>
-    <ProjectReference Include="..\Samples\PortableTask\PortableTask.csproj" Private="false" ReferenceOutputAssembly="false" OutputItemType="PortableTaskResolvedProjectReferencePath" SetTargetFramework="TargetFramework=netstandard2.0" />
+    <ProjectReference Include="..\Samples\PortableTask\PortableTask.csproj" Private="false" ReferenceOutputAssembly="false" OutputItemType="PortableTaskResolvedProjectReferencePath" />
 
     <ProjectReference Include="..\Samples\ProjectCachePlugin\ProjectCachePlugin.csproj" Private="false" ReferenceOutputAssembly="false">
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">TargetFramework=$(FullFrameworkTFM)</SetTargetFramework>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index d39ce74cb49..505bc1d2df1 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -372,7 +372,6 @@ ISet<string> removeMetadata
         )
         {
             // todo this is duplicated logic with the item computation logic from evaluation (in LazyIncludeOperation.SelectItems)
-
             ProjectErrorUtilities.VerifyThrowInvalidProject(!(keepMetadata != null && removeMetadata != null), originalItem.KeepMetadataLocation, "KeepAndRemoveMetadataMutuallyExclusive");
             List<ProjectItemInstance> items = new List<ProjectItemInstance>();
 
@@ -433,7 +432,11 @@ ISet<string> removeMetadata
                     string[] includeSplitFiles = EngineFileUtilities.GetFileListEscaped(
                         Project.Directory,
                         includeSplit,
-                        excludes);
+                        excludes,
+                        loggingMechanism: LoggingContext,
+                        includeLocation: originalItem.IncludeLocation,
+                        excludeLocation: originalItem.ExcludeLocation,
+                        disableExcludeDriveEnumerationWarning: true);
 
                     foreach (string includeSplitFile in includeSplitFiles)
                     {
@@ -454,7 +457,11 @@ ISet<string> removeMetadata
 
             foreach (string excludeSplit in excludes)
             {
-                string[] excludeSplitFiles = EngineFileUtilities.GetFileListUnescaped(Project.Directory, excludeSplit);
+                string[] excludeSplitFiles = EngineFileUtilities.GetFileListUnescaped(
+                    Project.Directory,
+                    excludeSplit,
+                    loggingMechanism: LoggingContext,
+                    excludeLocation: originalItem.ExcludeLocation);
 
                 foreach (string excludeSplitFile in excludeSplitFiles)
                 {
@@ -539,7 +546,12 @@ Expander<ProjectPropertyInstance, ProjectItemInstance> expander
                 // Don't unescape wildcards just yet - if there were any escaped, the caller wants to treat them
                 // as literals. Everything else is safe to unescape at this point, since we're only matching
                 // against the file system.
-                string[] fileList = EngineFileUtilities.GetFileListEscaped(Project.Directory, piece);
+                string[] fileList = EngineFileUtilities.GetFileListEscaped(
+                    Project.Directory,
+                    piece,
+                    loggingMechanism: LoggingContext,
+                    includeLocation: specificationLocation,
+                    excludeLocation: specificationLocation);
 
                 foreach (string file in fileList)
                 {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index b5c40b3cc79..ec05dfd174f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -399,8 +399,19 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
             // If this is an Intrinsic task, it gets handled in a special fashion.
             if (_taskNode == null)
             {
-                ExecuteIntrinsicTask(bucket);
-                taskResult = new WorkUnitResult(WorkUnitResultCode.Success, WorkUnitActionCode.Continue, null);
+                try
+                {
+                    ExecuteIntrinsicTask(bucket);
+                    taskResult = new WorkUnitResult(WorkUnitResultCode.Success, WorkUnitActionCode.Continue, null);
+                }
+                catch (InvalidProjectFileException e)
+                {
+                    // Make sure the Invalid Project error gets logged *before* TaskFinished.  Otherwise,
+                    // the log is confusing.
+                    _targetLoggingContext.LogInvalidProjectFileError(e);
+                    _continueOnError = ContinueOnError.ErrorAndStop;
+                    taskResult = new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, e);
+                }
             }
             else
             {
@@ -461,6 +472,7 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                             // the log is confusing.
                             taskLoggingContext.LogInvalidProjectFileError(e);
                             _continueOnError = ContinueOnError.ErrorAndStop;
+                            taskResult = new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, e);
                         }
                         finally
                         {
diff --git a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
index 3d35548d260..04b7ad67ed0 100644
--- a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
@@ -7,10 +7,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using System;
-using System.Collections.Concurrent;
 using System.Collections.Generic;
-using System.Threading;
-using System.Threading.Tasks;
 
 #nullable disable
 
@@ -18,7 +15,7 @@ namespace Microsoft.Build.BackEnd.SdkResolution
 {
     /// <summary>
     /// An implementation of <see cref="ISdkResolverService"/> that is hosted in the main node for multi-proc builds.  This instance of the service
-    /// listens for requests from out-of-proc nodes so that SDK resolution is handled in a central location.  This instance is registered in <see cref="BuildComponentFactoryCollection.RegisterDefaultFactories"/>
+    /// handles requests from out-of-proc nodes so that SDK resolution is handled in a central location.  This instance is registered in <see cref="BuildComponentFactoryCollection.RegisterDefaultFactories"/>
     /// and can be overridden for different contexts.  This service calls the <see cref="SdkResolverService"/> to do any actual SDK resolution
     /// because the <see cref="SdkResolverService"/> is used for stand-alone evaluations where there is no build context available so caching
     /// is not an option.
@@ -28,26 +25,6 @@ namespace Microsoft.Build.BackEnd.SdkResolution
     /// </summary>
     internal sealed class MainNodeSdkResolverService : HostedSdkResolverServiceBase
     {
-        /// <summary>
-        /// An object used for locking in this class instance.
-        /// </summary>
-        private readonly object _lockObject = new object();
-
-        /// <summary>
-        /// A <see cref="Task"/> running in the background which handles requests from remote nodes.
-        /// </summary>
-        private Task _requestHandler;
-
-        /// <summary>
-        /// An event which is signaled when a request is received from a remote host.
-        /// </summary>
-        private ManualResetEvent _requestReceivedEvent;
-
-        /// <summary>
-        /// A list of requests from remote hosts which need to be processed.
-        /// </summary>
-        private ConcurrentQueue<SdkResolverRequest> _requests;
-
         private readonly ISdkResolverService _cachedSdkResolver = new CachingSdkResolverService();
 
         /// <summary>
@@ -55,6 +32,8 @@ internal sealed class MainNodeSdkResolverService : HostedSdkResolverServiceBase
         /// </summary>
         public static IBuildComponent CreateComponent(BuildComponentType type)
         {
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.SdkResolverService, nameof(type));
+
             return new MainNodeSdkResolverService();
         }
 
@@ -78,148 +57,52 @@ public override void ClearCaches()
         /// <inheritdoc cref="INodePacketHandler.PacketReceived"/>
         public override void PacketReceived(int node, INodePacket packet)
         {
-            switch (packet.Type)
-            {
-                case NodePacketType.ResolveSdkRequest:
-                    HandleRequest(node, packet as SdkResolverRequest);
-                    break;
-            }
-        }
-
-        /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
-        {
-            ErrorUtilities.VerifyThrowInternalNull(sdk, nameof(sdk));
-            ErrorUtilities.VerifyThrowInternalNull(loggingContext, nameof(loggingContext));
-            ErrorUtilities.VerifyThrowInternalNull(sdkReferenceLocation, nameof(sdkReferenceLocation));
-            ErrorUtilities.VerifyThrowInternalLength(projectPath, nameof(projectPath));
-
-            return _cachedSdkResolver.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
-        }
-
-        /// <summary>
-        /// Handles a request from a remote node.
-        /// </summary>
-        /// <param name="node">The ID of the remote node.</param>
-        /// <param name="request">The <see cref="SdkResolverRequest"/> containing information about the SDK to resolve.</param>
-        /// <remarks>This method must not directly handle requests because it would block requests from other nodes.  Instead, it simply
-        /// adds requests to a queue which are processed by a background thread.</remarks>
-        private void HandleRequest(int node, SdkResolverRequest request)
-        {
-            if (_requestHandler == null)
+            if (packet is not SdkResolverRequest request)
             {
-                // Start the background thread which will process queued requests if it has not already been started.
-                lock (_lockObject)
-                {
-                    if (_requestHandler == null)
-                    {
-                        // Create the event used to signal that a request was received
-                        _requestReceivedEvent = new ManualResetEvent(initialState: false);
-
-                        // Create the queue used to store requests that need to be processed
-                        _requests = new ConcurrentQueue<SdkResolverRequest>();
-
-                        // Create the thread which processes requests
-                        _requestHandler = Task.Factory.StartNew(RequestHandlerPumpProc, TaskCreationOptions.LongRunning);
-                    }
-                }
+                return;
             }
 
             // Associate the node with the request
             request.NodeId = node;
 
-            _requests.Enqueue(request);
+            SdkResult response = null;
 
-            // Signal that one or more requests have been received
-            _requestReceivedEvent.Set();
-        }
-
-        /// <summary>
-        /// Processes all requests that are currently in the queue.
-        /// </summary>
-        private void ProcessRequests()
-        {
-            // Store a list of threads which are resolving SDKs
-            List<Task> tasks = new List<Task>(_requests.Count);
-
-            SdkResolverRequest item;
-
-            while (_requests.TryDequeue(out item))
-            {
-                SdkResolverRequest request = item;
-
-                // Start a thread to resolve an SDK and add it to the list of threads
-                tasks.Add(Task.Run(() =>
-                {
-                    SdkResult response = null;
-                    try
-                    {
-                        // Create an SdkReference from the request
-                        SdkReference sdkReference = new SdkReference(request.Name, request.Version, request.MinimumVersion);
-
-                        ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;
-
-                        // This call is usually cached so is very fast but can take longer for a new SDK that is downloaded.  Other queued threads for different SDKs will complete sooner and continue on which unblocks evaluations
-                        response = ResolveSdk(request.SubmissionId, sdkReference, new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath), request.ElementLocation, request.SolutionPath, request.ProjectPath, request.Interactive, request.IsRunningInVisualStudio);
-                    }
-                    catch (Exception e)
-                    {
-                        ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;
-
-                        EvaluationLoggingContext loggingContext = new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath);
-
-                        loggingService.LogFatalBuildError(loggingContext.BuildEventContext, e, new BuildEventFileInfo(request.ElementLocation));
-                    }
-                    finally
-                    {
-                        // Get the node manager and send the response back to the node that requested the SDK
-                        INodeManager nodeManager = Host.GetComponent(BuildComponentType.NodeManager) as INodeManager;
-
-                        nodeManager.SendData(request.NodeId, response);
-                    }
-                }));
-            }
-
-            // Wait for all tasks to complete
-            Task.WaitAll(tasks.ToArray());
-        }
-
-        /// <summary>
-        /// A background thread that waits for requests to be received.
-        /// </summary>
-        private void RequestHandlerPumpProc()
-        {
             try
             {
-                Thread.CurrentThread.Name = "MSBuild SDK Resolver";
+                // Create an SdkReference from the request
+                SdkReference sdkReference = new SdkReference(request.Name, request.Version, request.MinimumVersion);
 
-                while (true)
-                {
-                    WaitHandle[] handles = new WaitHandle[] { ShutdownEvent, _requestReceivedEvent };
+                ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;
 
-                    int waitId = WaitHandle.WaitAny(handles);
-                    switch (waitId)
-                    {
-                        case 0:
-                            return;
-
-                        case 1:
-                            _requestReceivedEvent.Reset();
+                // This call is usually cached so is very fast but can take longer for a new SDK that is downloaded.  Other queued threads for different SDKs will complete sooner and continue on which unblocks evaluations
+                response = ResolveSdk(request.SubmissionId, sdkReference, new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath), request.ElementLocation, request.SolutionPath, request.ProjectPath, request.Interactive, request.IsRunningInVisualStudio);
+            }
+            catch (Exception e)
+            {
+                ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;
 
-                            ProcessRequests();
-                            break;
+                EvaluationLoggingContext loggingContext = new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath);
 
-                        default:
-                            ErrorUtilities.ThrowInternalError("waitId {0} out of range.", waitId);
-                            break;
-                    }
-                }
+                loggingService.LogFatalBuildError(loggingContext.BuildEventContext, e, new BuildEventFileInfo(request.ElementLocation));
             }
-            catch (Exception e)
+            finally
             {
-                ExceptionHandling.DumpExceptionToFile(e);
-                throw;
+                // Get the node manager and send the response back to the node that requested the SDK
+                INodeManager nodeManager = Host.GetComponent(BuildComponentType.NodeManager) as INodeManager;
+
+                nodeManager.SendData(request.NodeId, response);
             }
         }
+
+        /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
+        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        {
+            ErrorUtilities.VerifyThrowInternalNull(sdk, nameof(sdk));
+            ErrorUtilities.VerifyThrowInternalNull(loggingContext, nameof(loggingContext));
+            ErrorUtilities.VerifyThrowInternalNull(sdkReferenceLocation, nameof(sdkReferenceLocation));
+            ErrorUtilities.VerifyThrowInternalLength(projectPath, nameof(projectPath));
+
+            return _cachedSdkResolver.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+        }
     }
 }
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 661397bad26..0adf9e61756 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -3477,7 +3477,15 @@ public string ExpandItemIncludeBestEffortLeaveEscaped(ProjectItemElement renamed
 
                 var itemFactory = new ProjectItemFactory(Owner, renamedItemElement);
 
-                List<ProjectItem> items = Evaluator<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.CreateItemsFromInclude(DirectoryPath, renamedItemElement, itemFactory, renamedItemElement.Include, _data.Expander);
+                List<ProjectItem> items = Evaluator<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.CreateItemsFromInclude(
+                    DirectoryPath,
+                    renamedItemElement,
+                    itemFactory,
+                    renamedItemElement.Include,
+                    _data.Expander,
+                    LoggingService,
+                    FullPath,
+                    s_buildEventContext);
 
                 if (items.Count != 1)
                 {
@@ -3537,7 +3545,15 @@ private List<ProjectItem> AddItemHelper(ProjectItemElement itemElement, string u
             {
                 var itemFactory = new ProjectItemFactory(Owner, itemElement);
 
-                List<ProjectItem> items = Evaluator<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.CreateItemsFromInclude(DirectoryPath, itemElement, itemFactory, unevaluatedInclude, _data.Expander);
+                List<ProjectItem> items = Evaluator<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.CreateItemsFromInclude(
+                    DirectoryPath,
+                    itemElement,
+                    itemFactory,
+                    unevaluatedInclude,
+                    _data.Expander,
+                    LoggingService,
+                    FullPath,
+                    s_buildEventContext);
 
                 foreach (ProjectItem item in items)
                 {
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 19f4c800414..147d7cfb5ba 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -341,7 +341,7 @@ internal static void Evaluate(
         /// Helper that creates a list of ProjectItem's given an unevaluated Include and a ProjectRootElement.
         /// Used by both Evaluator.EvaluateItemElement and by Project.AddItem.
         /// </summary>
-        internal static List<I> CreateItemsFromInclude(string rootDirectory, ProjectItemElement itemElement, IItemFactory<I, I> itemFactory, string unevaluatedIncludeEscaped, Expander<P, I> expander)
+        internal static List<I> CreateItemsFromInclude(string rootDirectory, ProjectItemElement itemElement, IItemFactory<I, I> itemFactory, string unevaluatedIncludeEscaped, Expander<P, I> expander, ILoggingService loggingService, string buildEventFileInfoFullPath, BuildEventContext buildEventContext)
         {
             ErrorUtilities.VerifyThrowArgumentLength(unevaluatedIncludeEscaped, nameof(unevaluatedIncludeEscaped));
 
@@ -373,7 +373,16 @@ internal static List<I> CreateItemsFromInclude(string rootDirectory, ProjectItem
                     else
                     {
                         // The expression is not of the form "@(X)". Treat as string
-                        string[] includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(rootDirectory, includeSplitEscaped, excludeSpecsEscaped: null, forceEvaluate: false, fileMatcher: expander.EvaluationContext?.FileMatcher);
+                        string[] includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(
+                            rootDirectory,
+                            includeSplitEscaped,
+                            excludeSpecsEscaped: null,
+                            forceEvaluate: false,
+                            fileMatcher: expander.EvaluationContext?.FileMatcher,
+                            loggingMechanism: loggingService,
+                            includeLocation: itemElement.IncludeLocation,
+                            buildEventFileInfoFullPath: buildEventFileInfoFullPath,
+                            buildEventContext: buildEventContext);
 
                         if (includeSplitFilesEscaped.Length > 0)
                         {
@@ -2042,7 +2051,13 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
                     }
 
                     // Expand the wildcards and provide an alphabetical order list of import statements.
-                    importFilesEscaped = EngineFileUtilities.GetFileListEscaped(directoryOfImportingFile, importExpressionEscapedItem, forceEvaluate: true, fileMatcher: _evaluationContext.FileMatcher);
+                    importFilesEscaped = EngineFileUtilities.GetFileListEscaped(
+                        directoryOfImportingFile,
+                        importExpressionEscapedItem,
+                        forceEvaluate: true,
+                        fileMatcher: _evaluationContext.FileMatcher,
+                        loggingMechanism: _evaluationLoggingContext,
+                        importLocation: importLocationInProject);
                 }
                 catch (Exception ex) when (ExceptionHandling.IsIoRelatedException(ex))
                 {
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 88d911a7b4a..1bacf84bbe7 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -2241,8 +2241,7 @@ internal static IEnumerable<Pair<string, S>> GetItemPairEnumerable(IEnumerable<S
                     {
                         if (Traits.Instance.UseLazyWildCardEvaluation)
                         {
-                            foreach (
-                                var resultantItem in
+                            foreach (var resultantItem in
                                 EngineFileUtilities.GetFileListEscaped(
                                     item.ProjectDirectory,
                                     item.EvaluatedIncludeEscaped,
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index 0fe765844fa..ce0dc977426 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -111,15 +111,19 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde
                             {
                                 MSBuildEventSource.Log.ExpandGlobStart(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
                             }
+
                             using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))
                             {
                                 includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(
                                     _rootDirectory,
                                     glob,
                                     excludePatternsForGlobs,
-                                    fileMatcher: FileMatcher
-                                );
+                                    fileMatcher: FileMatcher,
+                                    loggingMechanism: _lazyEvaluator._loggingContext,
+                                    includeLocation: _itemElement.IncludeLocation,
+                                    excludeLocation: _itemElement.ExcludeLocation);
                             }
+
                             if (MSBuildEventSource.Log.IsEnabled())
                             {
                                 MSBuildEventSource.Log.ExpandGlobStop(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 4043f931854..bc4f28a26e1 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
-        <target state="new">MSB4275: Attempted to create multiple overrides of the same task: {0}</target>
+        <target state="translated">MSB4275: Došlo k pokusu o vytvoření více přepsání stejné úlohy: {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
@@ -226,7 +226,7 @@
       </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
-        <target state="new">Created an override using task: {0} at {1}</target>
+        <target state="translated">Vytvořilo se přepsání pomocí úlohy: {0} v {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheBeginBuild">
@@ -432,7 +432,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
     {0}</source>
-        <target state="new">This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <target state="translated">Jedná se o neošetřenou výjimku v MSBuildu – HLASUJTE PROSÍM PRO EXISTUJÍCÍ PROBLÉM NEBO VYTVOŘTE NOVÝ NA https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 6b035bde1f8..2d5371cd4e4 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
-        <target state="new">MSB4275: Attempted to create multiple overrides of the same task: {0}</target>
+        <target state="translated">MSB4275: Es wurde versucht, mehrere Außerkraftsetzungen derselben Aufgabe zu erstellen: {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
@@ -226,7 +226,7 @@
       </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
-        <target state="new">Created an override using task: {0} at {1}</target>
+        <target state="translated">Außerkraftsetzung mit Task erstellt: {0} bei {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheBeginBuild">
@@ -432,7 +432,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
     {0}</source>
-        <target state="new">This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <target state="translated">Dies ist eine nicht behandelte Ausnahme in MSBuild. RUFEN SIE EIN VORHANDENES PROBLEM AUF, ODER ERSTELLEN SIE EIN NEUES UNTER https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 09cc68eb3a7..ae8a6a1e189 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
-        <target state="new">MSB4275: Attempted to create multiple overrides of the same task: {0}</target>
+        <target state="translated">MSB4275: Se intentaron crear varias invalidaciones de la misma tarea: {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
@@ -226,7 +226,7 @@
       </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
-        <target state="new">Created an override using task: {0} at {1}</target>
+        <target state="translated">Se creó una invalidación mediante la tarea: {0} en {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheBeginBuild">
@@ -432,7 +432,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
     {0}</source>
-        <target state="new">This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <target state="translated">Esta es una excepción no controlada en MSBuild. VOTE POR UN PROBLEMA EXISTENTE O PRESENTE UNO NUEVO EN https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 38ce28929da..0ffddfbe011 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
-        <target state="new">MSB4275: Attempted to create multiple overrides of the same task: {0}</target>
+        <target state="translated">MSB4275: Tentative de création de plusieurs remplacements de la même tâche : {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
@@ -226,7 +226,7 @@
       </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
-        <target state="new">Created an override using task: {0} at {1}</target>
+        <target state="translated">Remplacement créé à l’aide de la tâche : {0} au {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheBeginBuild">
@@ -432,7 +432,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
     {0}</source>
-        <target state="new">This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <target state="translated">Il s’agit d’une exception non gérée dans MSBuild -- VOTEZ POUR UN PROBLÈME EXISTANT OU ENTREZ UN NOUVEAU FICHIER À https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index abfcf608a12..11aec49efc6 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
-        <target state="new">MSB4275: Attempted to create multiple overrides of the same task: {0}</target>
+        <target state="translated">MSB4275: tentativo di creare più sostituzioni della stessa attività: {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
@@ -226,7 +226,7 @@
       </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
-        <target state="new">Created an override using task: {0} at {1}</target>
+        <target state="translated">È stata creata una sostituzione con l'attività: {0} in {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheBeginBuild">
@@ -432,7 +432,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
     {0}</source>
-        <target state="new">This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <target state="translated">Si tratta di un'eccezione non gestita in MSBuild-- ESEGUIRE L'UPVOTE DI UN PROBLEMA ESISTENTE O DI UN FILE NUOVO IN https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index a609a92f4c5..1bf7a2f0d24 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
-        <target state="new">MSB4275: Attempted to create multiple overrides of the same task: {0}</target>
+        <target state="translated">MSB4275: 同じタスクの複数のオーバーライドを作成しようとしました: {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
@@ -226,7 +226,7 @@
       </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
-        <target state="new">Created an override using task: {0} at {1}</target>
+        <target state="translated">タスクを使用してオーバーライドを作成しました: {1} の {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheBeginBuild">
@@ -432,7 +432,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
     {0}</source>
-        <target state="new">This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <target state="translated">これは MSBuild でハンドルされない例外です -- 既存の問題に賛成票を投じるか、https://aka.ms/msbuild/unhandled で新しい問題を提起してください。
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 168d3129afc..8f5d34f5cce 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
-        <target state="new">MSB4275: Attempted to create multiple overrides of the same task: {0}</target>
+        <target state="translated">MSB4275: 동일한 작업의 여러 재정의를 만들려고 했습니다. {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
@@ -226,7 +226,7 @@
       </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
-        <target state="new">Created an override using task: {0} at {1}</target>
+        <target state="translated">다음 작업을 사용하여 재정의를 만들었습니다. {1}의 {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheBeginBuild">
@@ -432,8 +432,8 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
     {0}</source>
-        <target state="new">This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
-    {0}</target>
+        <target state="translated">MSBuild에서 처리되지 않은 예외입니다. https://aka.ms/msbuild/unhandled에서 기존 문제에 찬성 투표하거나 새 문제를 제출하세요.
+ {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="UninitializedPropertyRead">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 7e69028c66e..b893482a44e 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
-        <target state="new">MSB4275: Attempted to create multiple overrides of the same task: {0}</target>
+        <target state="translated">MSB4275: Podjęto próbę utworzenia wielu zastąpień tego samego zadania: {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
@@ -226,7 +226,7 @@
       </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
-        <target state="new">Created an override using task: {0} at {1}</target>
+        <target state="translated">Utworzono zastąpienie przy użyciu zadania: {0} o {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheBeginBuild">
@@ -432,7 +432,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
     {0}</source>
-        <target state="new">This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <target state="translated">To jest nieobsługiwany wyjątek w programie MSBuild — POPRZYJ ISTNIEJĄCY PROBLEM LUB ZAREJESTRUJ NOWY NA https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 1bc25d198f2..ad14ba37ca1 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
-        <target state="new">MSB4275: Attempted to create multiple overrides of the same task: {0}</target>
+        <target state="translated">MSB4275: tentativa de criar várias substituições da mesma tarefa: {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
@@ -226,7 +226,7 @@
       </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
-        <target state="new">Created an override using task: {0} at {1}</target>
+        <target state="translated">Criou uma substituição usando a tarefa: {0} em {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheBeginBuild">
@@ -432,7 +432,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
     {0}</source>
-        <target state="new">This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <target state="translated">Esta é uma exceção sem tratamento no MSBuild -- VOTE A FAVOR DE UM PROBLEMA EXISTENTE OU REGISTRE UM NOVO EM https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 883f9984beb..04004fbdfe1 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
-        <target state="new">MSB4275: Attempted to create multiple overrides of the same task: {0}</target>
+        <target state="translated">MSB4275: попытка создать несколько переопределений одной задачи: {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
@@ -226,7 +226,7 @@
       </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
-        <target state="new">Created an override using task: {0} at {1}</target>
+        <target state="translated">Создано переопределение с помощью задачи {0} в {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheBeginBuild">
@@ -432,7 +432,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
     {0}</source>
-        <target state="new">This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <target state="translated">Это необработанное исключение в MSBuild — ПРОГОЛОСУЙТЕ ЗА СУЩЕСТВУЮЩУЮ ПРОБЛЕМУ ИЛИ СОЗДАЙТЕ НОВУЮ на сайте https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 4b61a9f80be..5fc8f54ba4e 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
-        <target state="new">MSB4275: Attempted to create multiple overrides of the same task: {0}</target>
+        <target state="translated">MSB4275: Aynı {0} görevi için birden çok geçersiz kılma işlemi oluşturulmaya çalışıldı</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
@@ -226,7 +226,7 @@
       </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
-        <target state="new">Created an override using task: {0} at {1}</target>
+        <target state="translated">{0} görevi kullanılarak geçersiz kılma işlemi oluşturuldu, saat: {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheBeginBuild">
@@ -432,7 +432,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
     {0}</source>
-        <target state="new">This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <target state="translated">Bu, MSBuild'de işlenmeyen bir özel durumdur -- LÜTFEN MEVCUT BIR SORUNA DESTEK OYU VERIN VEYA MEVCUT BIR SORUNU BİLDİRİN: https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 3d8fdf8c70b..4a9d18a374e 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
-        <target state="new">MSB4275: Attempted to create multiple overrides of the same task: {0}</target>
+        <target state="translated">MSB4275: 已尝试创建同一任务的多个重写: {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
@@ -226,7 +226,7 @@
       </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
-        <target state="new">Created an override using task: {0} at {1}</target>
+        <target state="translated">已使用任务创建替代: {0} 位于 {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheBeginBuild">
@@ -432,7 +432,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
     {0}</source>
-        <target state="new">This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <target state="translated">这是 MSBuild 中未经处理的异常 -- 请对现有问题投赞成票或在 https://aka.ms/msbuild/unhandled 上提交新问题。
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 7c4850b32df..214240db01c 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
-        <target state="new">MSB4275: Attempted to create multiple overrides of the same task: {0}</target>
+        <target state="translated">MSB4275: 已嘗試建立相同工作的多個覆寫: {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
@@ -226,7 +226,7 @@
       </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
-        <target state="new">Created an override using task: {0} at {1}</target>
+        <target state="translated">已使用下列工作建立覆寫: 於 {1} 的 {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheBeginBuild">
@@ -432,7 +432,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
     {0}</source>
-        <target state="new">This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <target state="translated">這是 MSBuild 中未處理的例外狀況 -- 請針對現有的問題附議，或在 https://aka.ms/msbuild/unhandled 提交新的問題。
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index 2f53f2b6a71..9fc047c95c1 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -6,10 +6,11 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
+using Microsoft.Build.BackEnd.Components.Logging;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using System.Text.RegularExpressions;
-using Microsoft.Build.Utilities;
 
 #nullable disable
 
@@ -17,6 +18,8 @@ namespace Microsoft.Build.Internal
 {
     internal static class EngineFileUtilities
     {
+        private const string DriveEnumeratingWildcardMessageResourceName = "WildcardResultsInDriveEnumeration";
+
         // Regexes for wildcard filespecs that should not get expanded
         // By default all wildcards are expanded.
         private static List<Regex> s_lazyWildCardExpansionRegexes;
@@ -47,14 +50,27 @@ internal static void CaptureLazyWildcardRegexes()
         /// </summary>
         /// <param name="directoryEscaped">The directory to evaluate, escaped.</param>
         /// <param name="filespecEscaped">The filespec to evaluate, escaped.</param>
+        /// <param name="loggingMechanism">Accepted loggers for drive enumeration: TargetLoggingContext, ILoggingService,
+        /// and EvaluationLoggingContext.</param>
+        /// <param name="excludeLocation">Location of Exclude element in file, used after drive enumeration detection.</param>
         /// <returns>Array of file paths, unescaped.</returns>
         internal static string[] GetFileListUnescaped
             (
             string directoryEscaped,
-            string filespecEscaped
+            string filespecEscaped,
+            object loggingMechanism = null,
+            IElementLocation excludeLocation = null
             )
         {
-            return GetFileList(directoryEscaped, filespecEscaped, returnEscaped: false, forceEvaluateWildCards: false, excludeSpecsEscaped: null, fileMatcher: FileMatcher.Default);
+            return GetFileList(
+                directoryEscaped,
+                filespecEscaped,
+                returnEscaped: false,
+                forceEvaluateWildCards: false,
+                excludeSpecsEscaped: null,
+                fileMatcher: FileMatcher.Default,
+                loggingMechanism: loggingMechanism,
+                excludeLocation: excludeLocation);
         }
 
         /// <summary>
@@ -70,8 +86,18 @@ string filespecEscaped
         /// <param name="directoryEscaped">The directory to evaluate, escaped.</param>
         /// <param name="filespecEscaped">The filespec to evaluate, escaped.</param>
         /// <param name="excludeSpecsEscaped">Filespecs to exclude, escaped.</param>
-        /// <param name="forceEvaluate">Whether to force file glob expansion when eager expansion is turned off</param>
-        /// <param name="fileMatcher"></param>
+        /// <param name="forceEvaluate">Whether to force file glob expansion when eager expansion is turned off.</param>
+        /// <param name="fileMatcher">Class that contains functions for matching filenames with patterns.</param>
+        /// <param name="loggingMechanism">Accepted loggers for drive enumeration: TargetLoggingContext, ILoggingService,
+        /// and EvaluationLoggingContext.</param>
+        /// <param name="includeLocation">Location of Include element in file, used after drive enumeration detection.</param>
+        /// <param name="excludeLocation">Location of Exclude element in file, used after drive enumeration detection.</param>
+        /// <param name="importLocation">Location of Import element in file, used after drive enumeration detection.</param>
+        /// <param name="buildEventContext">Context to log a warning, used after drive enumeration detection.</param>
+        /// <param name="buildEventFileInfoFullPath">Full path to project file to create BuildEventFileInfo,
+        /// used after drive enumeration detection.</param>
+        /// <param name="disableExcludeDriveEnumerationWarning">Flag used to detect when to properly log a warning
+        /// for the Exclude attribute after detecting a drive enumerating wildcard.</param>
         /// <returns>Array of file paths, escaped.</returns>
         internal static string[] GetFileListEscaped
             (
@@ -79,10 +105,30 @@ internal static string[] GetFileListEscaped
             string filespecEscaped,
             IEnumerable<string> excludeSpecsEscaped = null,
             bool forceEvaluate = false,
-            FileMatcher fileMatcher = null
+            FileMatcher fileMatcher = null,
+            object loggingMechanism = null,
+            IElementLocation includeLocation = null,
+            IElementLocation excludeLocation = null,
+            IElementLocation importLocation = null,
+            BuildEventContext buildEventContext = null,
+            string buildEventFileInfoFullPath = null,
+            bool disableExcludeDriveEnumerationWarning = false
             )
         {
-            return GetFileList(directoryEscaped, filespecEscaped, returnEscaped: true, forceEvaluate, excludeSpecsEscaped, fileMatcher ?? FileMatcher.Default);
+            return GetFileList(
+                directoryEscaped,
+                filespecEscaped,
+                returnEscaped: true,
+                forceEvaluate,
+                excludeSpecsEscaped,
+                fileMatcher ?? FileMatcher.Default,
+                loggingMechanism: loggingMechanism,
+                includeLocation: includeLocation,
+                excludeLocation: excludeLocation,
+                importLocation: importLocation,
+                buildEventFileInfoFullPath: buildEventFileInfoFullPath,
+                buildEventContext: buildEventContext,
+                disableExcludeDriveEnumerationWarning: disableExcludeDriveEnumerationWarning);
         }
 
         internal static bool FilespecHasWildcards(string filespecEscaped)
@@ -112,9 +158,19 @@ internal static bool FilespecHasWildcards(string filespecEscaped)
         /// <param name="directoryEscaped">The directory to evaluate, escaped.</param>
         /// <param name="filespecEscaped">The filespec to evaluate, escaped.</param>
         /// <param name="returnEscaped"><code>true</code> to return escaped specs.</param>
-        /// <param name="forceEvaluateWildCards">Whether to force file glob expansion when eager expansion is turned off</param>
+        /// <param name="forceEvaluateWildCards">Whether to force file glob expansion when eager expansion is turned off.</param>
         /// <param name="excludeSpecsEscaped">The exclude specification, escaped.</param>
-        /// <param name="fileMatcher"></param>
+        /// <param name="fileMatcher">Class that contains functions for matching filenames with patterns.</param>
+        /// <param name="loggingMechanism">Accepted loggers for drive enumeration: TargetLoggingContext, ILoggingService,
+        /// and EvaluationLoggingContext.</param>
+        /// <param name="includeLocation">Location of Include element in file, used after drive enumeration detection.</param>
+        /// <param name="excludeLocation">Location of Exclude element in file, used after drive enumeration detection.</param>
+        /// <param name="importLocation">Location of Import element in file, used after drive enumeration detection.</param>
+        /// <param name="buildEventContext">Context to log a warning, used after drive enumeration detection.</param>
+        /// <param name="buildEventFileInfoFullPath">Full path to project file to create BuildEventFileInfo,
+        /// used after drive enumeration detection.</param>
+        /// <param name="disableExcludeDriveEnumerationWarning">Flag used to detect when to properly log a warning
+        /// for the Exclude attribute after detecting a drive enumerating wildcard.</param>
         /// <returns>Array of file paths.</returns>
         private static string[] GetFileList
             (
@@ -123,13 +179,24 @@ private static string[] GetFileList
             bool returnEscaped,
             bool forceEvaluateWildCards,
             IEnumerable<string> excludeSpecsEscaped,
-            FileMatcher fileMatcher
+            FileMatcher fileMatcher,
+            object loggingMechanism = null,
+            IElementLocation includeLocation = null,
+            IElementLocation excludeLocation = null,
+            IElementLocation importLocation = null,
+            BuildEventContext buildEventContext = null,
+            string buildEventFileInfoFullPath = null,
+            bool disableExcludeDriveEnumerationWarning = false
             )
         {
             ErrorUtilities.VerifyThrowInternalLength(filespecEscaped, nameof(filespecEscaped));
 
             string[] fileList;
 
+            // Used to properly detect and log drive enumerating wildcards when applicable.
+            FileMatcher.SearchAction action = FileMatcher.SearchAction.None;
+            string excludeFileSpec = string.Empty;
+
             if (!FilespecHasWildcards(filespecEscaped) ||
                 FilespecMatchesLazyWildcard(filespecEscaped, forceEvaluateWildCards))
             {
@@ -152,8 +219,98 @@ FileMatcher fileMatcher
                 // the list into a string array.  If the filespec started out
                 // as a relative path, we will get back a bunch of relative paths.
                 // If the filespec started out as an absolute path, we will get
-                // back a bunch of absolute paths.
-                fileList = fileMatcher.GetFiles(directoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);
+                // back a bunch of absolute paths. Also retrieves the search action
+                // and relevant Exclude filespec for drive enumerating wildcard detection.
+                (fileList, action, excludeFileSpec) = fileMatcher.GetFiles(directoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);
+
+                // Determines whether Exclude filespec or passed in file spec should be
+                // used in drive enumeration warning or exception.
+                bool excludeFileSpecIsEmpty = string.IsNullOrWhiteSpace(excludeFileSpec);
+                string fileSpec = excludeFileSpecIsEmpty ? filespecUnescaped : excludeFileSpec;
+
+                switch (action)
+                {
+                    case (FileMatcher.SearchAction.LogDriveEnumeratingWildcard):
+                        switch (loggingMechanism)
+                        {
+                            // Logging mechanism received from ItemGroupIntrinsicTask.
+                            case TargetLoggingContext targetLoggingContext:
+                                LogDriveEnumerationWarningWithTargetLoggingContext(
+                                    targetLoggingContext,
+                                    includeLocation,
+                                    excludeFileSpecIsEmpty,
+                                    disableExcludeDriveEnumerationWarning,                                
+                                    fileSpec);
+
+                                break;
+
+                            // Logging mechanism received from Evaluator.
+                            case ILoggingService loggingService:
+                                LogDriveEnumerationWarningWithLoggingService(
+                                    loggingService,
+                                    buildEventContext,
+                                    buildEventFileInfoFullPath,
+                                    filespecUnescaped);
+
+                                break;
+
+                            // Logging mechanism received from Evaluator and LazyItemEvaluator.IncludeOperation.
+                            case EvaluationLoggingContext evaluationLoggingContext:
+                                LogDriveEnumerationWarningWithEvaluationLoggingContext(
+                                    evaluationLoggingContext,
+                                    importLocation,
+                                    excludeFileSpecIsEmpty,
+                                    filespecUnescaped,
+                                    fileSpec);
+
+                                break;
+
+                            default:
+                                throw new InternalErrorException($"Logging type {loggingMechanism.GetType()} is not understood by {nameof(GetFileList)}.");
+                        }
+
+                        break;
+
+                    case (FileMatcher.SearchAction.FailOnDriveEnumeratingWildcard):
+                        switch (loggingMechanism)
+                        {
+                            // Logging mechanism received from ItemGroupIntrinsicTask.
+                            case TargetLoggingContext targetLoggingContext:
+                                ThrowDriveEnumerationExceptionWithTargetLoggingContext(
+                                    includeLocation,
+                                    excludeLocation,
+                                    excludeFileSpecIsEmpty,
+                                    filespecUnescaped,
+                                    fileSpec);
+
+                                break;
+
+                            // Logging mechanism received from Evaluator.
+                            case ILoggingService loggingService:
+                                ThrowDriveEnumerationExceptionWithLoggingService(includeLocation, filespecUnescaped);
+
+                                break;
+
+                            // Logging mechanism received from Evaluator and LazyItemEvaluator.IncludeOperation.
+                            case EvaluationLoggingContext evaluationLoggingContext:
+                                ThrowDriveEnumerationExceptionWithEvaluationLoggingContext(
+                                    importLocation,
+                                    includeLocation,
+                                    excludeLocation,
+                                    filespecUnescaped,
+                                    fileSpec,
+                                    excludeFileSpecIsEmpty);
+
+                                break;
+
+                            default:
+                                throw new InternalErrorException($"Logging type {loggingMechanism.GetType()} is not understood by {nameof(GetFileList)}.");
+                        }
+
+                        break;
+
+                    default: break;
+                }
 
                 ErrorUtilities.VerifyThrow(fileList != null, "We must have a list of files here, even if it's empty.");
 
@@ -179,6 +336,152 @@ FileMatcher fileMatcher
             return fileList;
         }
 
+        private static void LogDriveEnumerationWarningWithTargetLoggingContext(TargetLoggingContext targetLoggingContext, IElementLocation includeLocation, bool excludeFileSpecIsEmpty, bool disableExcludeDriveEnumerationWarning, string fileSpec)
+        {
+            // Both condition lines are necessary to skip for the first GetFileListEscaped call
+            // and reach for the GetFileListUnescaped call when the wildcarded Exclude attribute results
+            // in a drive enumeration. Since we only want to check for the Exclude
+            // attribute here, we want to ensure that includeLocation is null - otherwise,
+            // Include wildcard attributes for the GetFileListEscaped calls would falsely appear
+            // with the Exclude attribute in the logged warning.
+            if (((!excludeFileSpecIsEmpty) && (!disableExcludeDriveEnumerationWarning)) ||
+                (includeLocation == null))
+            {
+                targetLoggingContext.LogWarning(
+                        DriveEnumeratingWildcardMessageResourceName,
+                        fileSpec,
+                        XMakeAttributes.exclude,
+                        XMakeElements.itemGroup);
+            }
+
+            // Both conditions are necessary to reach for both GetFileListEscaped calls
+            // and skip for the GetFileListUnescaped call when the wildcarded Include attribute
+            // results in drive enumeration.
+            else if (excludeFileSpecIsEmpty && (includeLocation != null))
+            {
+                targetLoggingContext.LogWarning(
+                    DriveEnumeratingWildcardMessageResourceName,
+                    fileSpec,
+                    XMakeAttributes.include,
+                    XMakeElements.itemGroup);
+            }
+        }
+
+        private static void LogDriveEnumerationWarningWithLoggingService(ILoggingService loggingService, BuildEventContext buildEventContext, string buildEventFileInfoFullPath, string filespecUnescaped)
+        {
+            if (buildEventContext != null)
+            {
+                loggingService.LogWarning(
+                    buildEventContext,
+                    string.Empty,
+                    new BuildEventFileInfo(buildEventFileInfoFullPath),
+                    DriveEnumeratingWildcardMessageResourceName,
+                    filespecUnescaped,
+                    XMakeAttributes.include,
+                    XMakeElements.itemGroup);
+            }
+        }
+
+        private static void LogDriveEnumerationWarningWithEvaluationLoggingContext(EvaluationLoggingContext evaluationLoggingContext, IElementLocation importLocation, bool excludeFileSpecIsEmpty, string filespecUnescaped, string fileSpec)
+        {
+            if (importLocation != null)
+            {
+                evaluationLoggingContext.LogWarning(
+                    DriveEnumeratingWildcardMessageResourceName,
+                    filespecUnescaped,
+                    XMakeAttributes.project,
+                    XMakeElements.import);
+            }
+            else if (excludeFileSpecIsEmpty)
+            {
+                evaluationLoggingContext.LogWarning(
+                    DriveEnumeratingWildcardMessageResourceName,
+                    fileSpec,
+                    XMakeAttributes.include,
+                    XMakeElements.itemGroup);
+            }
+            else
+            {
+                evaluationLoggingContext.LogWarning(
+                    DriveEnumeratingWildcardMessageResourceName,
+                    fileSpec,
+                    XMakeAttributes.exclude,
+                    XMakeElements.itemGroup);
+            }
+        }
+
+        private static void ThrowDriveEnumerationExceptionWithTargetLoggingContext(IElementLocation includeLocation, IElementLocation excludeLocation, bool excludeFileSpecIsEmpty, string filespecUnescaped, string fileSpec)
+        {
+            // The first condition is necessary to reach for both GetFileListEscaped calls
+            // whenever the wildcarded Include attribute results in drive enumeration, and
+            // the second condition is necessary to skip for the GetFileListUnescaped call
+            // whenever the wildcarded Exclude attribute results in drive enumeration.
+            if (excludeFileSpecIsEmpty && (includeLocation != null))
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    includeLocation,
+                    DriveEnumeratingWildcardMessageResourceName,
+                    filespecUnescaped,
+                    XMakeAttributes.include,
+                    XMakeElements.itemGroup);
+            }
+
+            // The first condition is necessary to reach for both GetFileListEscaped calls
+            // whenever the wildcarded Exclude attribute results in drive enumeration, and
+            // the second condition is necessary to reach for the GetFileListUnescaped call
+            // (also when the wildcarded Exclude attribute results in drive enumeration).
+            else if ((!excludeFileSpecIsEmpty) || (includeLocation == null))
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                        excludeLocation,
+                        DriveEnumeratingWildcardMessageResourceName,
+                        fileSpec,
+                        XMakeAttributes.exclude,
+                        XMakeElements.itemGroup);
+            }
+        }
+
+        private static void ThrowDriveEnumerationExceptionWithLoggingService(IElementLocation includeLocation, string filespecUnescaped)
+        {
+            ProjectErrorUtilities.ThrowInvalidProject(
+                includeLocation,
+                DriveEnumeratingWildcardMessageResourceName,
+                filespecUnescaped,
+                XMakeAttributes.include,
+                XMakeElements.itemGroup);
+        }
+
+        private static void ThrowDriveEnumerationExceptionWithEvaluationLoggingContext(IElementLocation importLocation, IElementLocation includeLocation, IElementLocation excludeLocation, string filespecUnescaped, string fileSpec, bool excludeFileSpecIsEmpty)
+        {
+            if (importLocation != null)
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    importLocation,
+                    DriveEnumeratingWildcardMessageResourceName,
+                    filespecUnescaped,
+                    XMakeAttributes.project,
+                    XMakeElements.import);
+            }
+            else if (excludeFileSpecIsEmpty)
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    includeLocation,
+                    DriveEnumeratingWildcardMessageResourceName,
+                    fileSpec,
+                    XMakeAttributes.include,
+                    XMakeElements.itemGroup);
+            }
+            else
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    excludeLocation,
+                    DriveEnumeratingWildcardMessageResourceName,
+                    fileSpec,
+                    XMakeAttributes.exclude,
+                    XMakeElements.itemGroup);
+            }
+        }
+
         private static bool FilespecMatchesLazyWildcard(string filespecEscaped, bool forceEvaluateWildCards)
         {
             return Traits.Instance.UseLazyWildCardEvaluation && !forceEvaluateWildCards && MatchesLazyWildcard(filespecEscaped);
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index 81b11a5b4ed..e238270ae6a 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -82,7 +82,7 @@
 
   <PropertyGroup Condition="'$(MonoBuild)' != 'true' and ($([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETCoreApp' or $([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETStandard')">
     <NetCoreBuild>true</NetCoreBuild>
-    <DefineConstants>$(DefineConstants);RUNTIME_TYPE_NETCORE</DefineConstants>
+    <DefineConstants>$(DefineConstants);RUNTIME_TYPE_NETCORE;FEATURE_FASTSPAN</DefineConstants>
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(NetCoreBuild)'=='true'">
diff --git a/src/Directory.Build.props b/src/Directory.Build.props
index dad17637aba..de2ef19eb31 100644
--- a/src/Directory.Build.props
+++ b/src/Directory.Build.props
@@ -15,6 +15,9 @@
     <!-- Ensure that compiler errors emit full paths so that files
          can be correctly annotated in GitHub. -->
     <GenerateFullPaths>true</GenerateFullPaths>
+    
+    <!-- https://github.com/NuGet/Home/issues/8684 -->
+    <NoWarn>$(NoWarn);NU5131</NoWarn>
 
     <!-- Do not mangle paths for test assemblies, because Shoudly assertions want actual on-disk paths. -->
     <DeterministicSourcePaths Condition="'$(IsTestProject)' == 'true'">false</DeterministicSourcePaths>
@@ -27,8 +30,9 @@
     <Platforms>AnyCPU;x64</Platforms>
 
     <!-- Defaults for target frameworks and architecture -->
-    <LibraryTargetFrameworks>$(FullFrameworkTFM);netstandard2.0</LibraryTargetFrameworks>
-    <LibraryTargetFrameworks Condition="'$(MonoBuild)'=='true'">$(FullFrameworkTFM)</LibraryTargetFrameworks>
+    <LibraryTargetFrameworks>$(FullFrameworkTFM);net6.0;netstandard2.0</LibraryTargetFrameworks>
+    <LibraryTargetFrameworks Condition="'$(DotNetBuildFromSource)' == 'true'">net6.0;netstandard2.0</LibraryTargetFrameworks>
+    <LibraryTargetFrameworks Condition="'$(MonoBuild)'=='true'">$(FullFrameworkTFM);netstandard2.0</LibraryTargetFrameworks>
     <PlatformTarget>AnyCPU</PlatformTarget>
 
     <!-- Target frameworks for Exe and unit test projects (ie projects with runtime output) -->
@@ -71,4 +75,34 @@
     <!-- When targeting .NET Core, Exe and unit tests projects always use AnyCPU architecture -->
     <RuntimeOutputPlatformTarget>AnyCPU</RuntimeOutputPlatformTarget>
   </PropertyGroup>
+
+  <PropertyGroup>
+    <TargetsForTfmSpecificBuildOutput>$(TargetsForTfmSpecificContentInPackage);ShipRefAssembliesToNuGetPackage</TargetsForTfmSpecificBuildOutput>
+  </PropertyGroup>
+
+  <!-- Produce ONLY reference assemblies and SKIP roslyn analyzers for netstandard2.0 builds. -->
+  <PropertyGroup Condition="'$(TargetFramework)' == 'netstandard2.0' and '$(MSBuildProjectFile)' != 'PortableTask.csproj'">
+    <!-- ProduceOnlyReferenceAssembly and ProduceReferenceAssembly are mutually exclusive compiler flags. -->
+    <ProduceOnlyReferenceAssembly>true</ProduceOnlyReferenceAssembly>
+    <ProduceReferenceAssembly>false</ProduceReferenceAssembly>
+    <RunAnalyzers>false</RunAnalyzers>
+    <TargetsForTfmSpecificBuildOutput>$(TargetsForTfmSpecificContentInPackage);ShipRefAssembliesToNuGetPackage</TargetsForTfmSpecificBuildOutput>
+    <IncludeBuildOutput>false</IncludeBuildOutput>
+    <!-- pdb publishing fails builds for reference-only assemblies. -->
+    <!-- https://github.com/dotnet/msbuild/pull/6148. -->
+    <PublishWindowsPdb>false</PublishWindowsPdb>
+  </PropertyGroup>
+
+  <!-- Ensure ref assemblies are placed under `ref/$(TargetFramework)` in the NuGet package -->
+  <Target Name="ShipRefAssembliesToNuGetPackage" BeforeTargets="Pack" Condition="$(IsInnerBuild) == true">
+    <ItemGroup>
+      <TfmSpecificPackageFile Include="$(TargetRefPath);@(FinalDocFile)">
+          <PackagePath>ref\$(TargetFramework)</PackagePath>
+      </TfmSpecificPackageFile>
+      <!-- ns2.0 builds use `BuiltProjectOutputGroupOutput` for output ref assemblies -->
+      <TfmSpecificPackageFile Include="@(BuiltProjectOutputGroupOutput)" Condition="'$(TargetFramework)' == 'netstandard2.0'">
+          <PackagePath>ref\$(TargetFramework)</PackagePath>
+      </TfmSpecificPackageFile>
+    </ItemGroup>
+  </Target>
 </Project>
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index 37d12cf7268..44670733c34 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -9,6 +9,7 @@
 using System.IO;
 using System.Reflection;
 using System.Runtime.InteropServices;
+using System.Runtime.Versioning;
 using System.Text;
 using System.Threading;
 
@@ -21,9 +22,10 @@
 #nullable disable
 
 namespace Microsoft.Build.Framework;
+
 internal static class NativeMethods
 {
-    #region Constants
+#region Constants
 
     internal const uint ERROR_INSUFFICIENT_BUFFER = 0x8007007A;
     internal const uint STARTUP_LOADER_SAFEMODE = 0x10;
@@ -70,9 +72,9 @@ internal static class NativeMethods
     internal const uint WAIT_OBJECT_0 = 0x00000000;
     internal const uint WAIT_TIMEOUT = 0x00000102;
 
-    #endregion
+#endregion
 
-    #region Enums
+#region Enums
 
     private enum PROCESSINFOCLASS : int
     {
@@ -197,9 +199,9 @@ internal enum ProcessorArchitectures
         Unknown
     }
 
-    #endregion
+#endregion
 
-    #region Structs
+#region Structs
 
     /// <summary>
     /// Structure that contain information about the system on which we are running
@@ -567,9 +569,9 @@ private unsafe static int GetLogicalCoreCountOnWindows()
         return -1;
     }
 
-    #endregion
+#endregion
 
-    #region Member data
+#region Member data
 
     internal static bool HasMaxPath => MaxPath == MAX_PATH;
 
@@ -708,10 +710,10 @@ internal static bool IsMono
 #if !CLR2COMPATIBILITY
     private static bool? _isWindows;
 #endif
-
     /// <summary>
     /// Gets a flag indicating if we are running under some version of Windows
     /// </summary>
+    [SupportedOSPlatformGuard("windows")]
     internal static bool IsWindows
     {
 #if CLR2COMPATIBILITY
@@ -866,9 +868,9 @@ private static SystemInformationData SystemInformation
     /// </summary>
     internal static ProcessorArchitectures ProcessorArchitectureNative => SystemInformation.ProcessorArchitectureTypeNative;
 
-    #endregion
+#endregion
 
-    #region Wrapper methods
+#region Wrapper methods
 
     /// <summary>
     /// Really truly non pumping wait.
@@ -1450,9 +1452,9 @@ internal static void VerifyThrowWin32Result(int result)
         }
     }
 
-    #endregion
+#endregion
 
-    #region PInvoke
+#region PInvoke
 
     /// <summary>
     /// Gets the current OEM code page which is used by console apps
@@ -1585,9 +1587,9 @@ out FILETIME lpLastWriteTime
     [DllImport("kernel32.dll", SetLastError = true)]
     internal static extern bool SetThreadErrorMode(int newMode, out int oldMode);
 
-    #endregion
+#endregion
 
-    #region Extensions
+#region Extensions
 
     /// <summary>
     /// Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
@@ -1630,9 +1632,9 @@ internal static bool MsgWaitOne(this WaitHandle handle, int timeout)
         return returnValue == 0;
     }
 
-    #endregion
+#endregion
 
-    #region helper methods
+#region helper methods
 
     internal static bool DirectoryExists(string fullPath)
     {
@@ -1675,6 +1677,6 @@ internal static bool FileOrDirectoryExistsWindows(string path)
         return GetFileAttributesEx(path, 0, ref data);
     }
 
-    #endregion
+#endregion
 
 }
diff --git a/src/Framework/README.md b/src/Framework/README.md
index 32c4e063b2b..1b72454f526 100644
--- a/src/Framework/README.md
+++ b/src/Framework/README.md
@@ -4,3 +4,8 @@ This package contains `Microsoft.Build.Framework.dll`, which defines [fundamenta
 
 The items in this namespace are primarily base-level classes and interfaces shared across MSBuild's object model.  MSBuild task or extension developers can reference this package to implement interfaces such as
 [`ITask`](https://docs.microsoft.com/dotnet/api/microsoft.build.framework.itask), and [`ILogger`](https://docs.microsoft.com/dotnet/api/microsoft.build.framework.ilogger).
+
+### netstandard2.0 target
+The `netstandard2.0` target of this build is configured only to output reference assemblies; at runtime MSBuild will be `net6.0` or `net472`. Please use the `net6.0`-targeted assemblies for .NET Core 6+ scenarios.
+
+For context, see https://github.com/dotnet/msbuild/pull/6148
\ No newline at end of file
diff --git a/src/Framework/Sdk/SdkResultItem.cs b/src/Framework/Sdk/SdkResultItem.cs
index cff07bb8bf7..febbbeffabc 100644
--- a/src/Framework/Sdk/SdkResultItem.cs
+++ b/src/Framework/Sdk/SdkResultItem.cs
@@ -36,7 +36,7 @@ public SdkResultItem(string itemSpec, Dictionary<string, string>? metadata)
             Metadata = metadata;
         }
 
-        public override bool Equals(object obj)
+        public override bool Equals(object? obj)
         {
             if (obj is SdkResultItem item &&
                    ItemSpec == item.ItemSpec &&
diff --git a/src/Framework/SupportedOSPlatform.cs b/src/Framework/SupportedOSPlatform.cs
new file mode 100644
index 00000000000..8a50d7c82f0
--- /dev/null
+++ b/src/Framework/SupportedOSPlatform.cs
@@ -0,0 +1,27 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#if !NET6_0_OR_GREATER
+namespace System.Runtime.Versioning
+{
+    /// <summary>
+    /// SupportedOSPlatform is a net5.0+ Attribute.
+    /// Create the same type only in full-framework and netstandard2.0 builds
+    /// to prevent many #if RUNTIME_TYPE_NETCORE checks.
+    /// </summary>
+    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property)]
+    internal class SupportedOSPlatformGuard : Attribute
+    {
+        internal SupportedOSPlatformGuard(string platformName)
+        {
+        }
+    }
+    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Class)]
+    internal class SupportedOSPlatform : Attribute
+    {
+        internal SupportedOSPlatform(string platformName)
+        {
+        }
+    }
+}
+#endif
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 3c3d850d7c6..2cea08d2ad3 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -43,6 +43,7 @@ public Traits()
         /// </summary>
         public readonly bool UseLazyWildCardEvaluation = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MsBuildSkipEagerWildCardEvaluationRegexes"));
         public readonly bool LogExpandedWildcards = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGEXPANDEDWILDCARDS"));
+        public readonly bool ThrowOnDriveEnumeratingWildcard = Environment.GetEnvironmentVariable("MSBUILDFAILONDRIVEENUMERATINGWILDCARD") == "1";
 
         /// <summary>
         /// Cache file existence for the entire process
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 803083dd1fc..337e3260d18 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -211,6 +211,13 @@
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
   </ItemGroup>
+    <!-- Manually download this library for RoslynCodeTaskFactory.
+           See target AddRefAssemblies below. -->
+    <ItemGroup>
+      <PackageDownload Include="netstandard.library">
+        <Version>[2.0.3]</Version>
+      </PackageDownload>
+    </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <!-- File for Assemblies we depend on -->
     <Reference Include="System" />
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index eb722c34566..c44516a6bf5 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -57,7 +57,7 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
       </trans-unit>
       <trans-unit id="EnvironmentVariableAsSwitch">
         <source>MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: Nedefinovaná proměnná prostředí předaná jako přepínač.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This error is shown when a user passes in an environment variable (including from a response file)
@@ -270,14 +270,14 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">
+        <target state="translated">
       -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+                     Seznam kódů upozornění, které se nemají považovat za chyby.
+                     Pomocí středníku nebo čárky oddělte
+                     více kódů upozornění. Nemá žádný vliv, pokud přepínač -warnaserror
+                     není nastavený.
 
-                     Example:
+                     Příklad:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -1250,7 +1250,7 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
       </trans-unit>
       <trans-unit id="MissingWarnNotAsErrorParameterError">
         <source>MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: Při použití přepínače -warnNotAsError zadejte jeden nebo více kódů upozornění.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This happens if the user does something like "msbuild.exe -warnNotAsError:" without any codes.
@@ -1267,7 +1267,7 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
         <source>MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</source>
-        <target state="new">MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</target>
+        <target state="translated">MSBUILD : error MSB1062: Přepínač -warnnotaserror nelze zadat, pokud není zadán také přepínač -warnaserror a není prázdný.</target>
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
@@ -1335,7 +1335,7 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
       </trans-unit>
       <trans-unit id="ResponseFileSwitchFromLocation">
         <source>'{0}' came from '{1}'</source>
-        <target state="new">'{0}' came from '{1}'</target>
+        <target state="translated">{0} přišla z {1}</target>
         <note>
       These are response file switches with the location of the response file on disk.
     </note>
@@ -1371,9 +1371,9 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
         <source>{0}
     Full command line: '{1}'
   Switches appended by response files:{2}</source>
-        <target state="new">{0}
-    Full command line: '{1}'
-  Switches appended by response files:{2}</target>
+        <target state="translated">{0}
+    Úplný příkazový řádek:{1}
+  Přepínače připojené pomocí souborů odpovědí:{2}</target>
         <note />
       </trans-unit>
       <trans-unit id="TargetsCouldNotBePrinted">
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 8d327b858f6..f79253774c2 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -57,7 +57,7 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
       </trans-unit>
       <trans-unit id="EnvironmentVariableAsSwitch">
         <source>MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: Nicht definierte Umgebungsvariable, die als Switch übergeben wurde.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This error is shown when a user passes in an environment variable (including from a response file)
@@ -270,14 +270,14 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">
+        <target state="translated">
       -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+                     Liste der Warnungscodes, die nicht als Fehler behandelt werden sollen.
+                     Semikolon oder Komma zum Trennen verwenden
+                     mehrere Warnungscodes. Hat keine Auswirkungen, wenn der -warnaserror
+                     Switch nicht festgelegt ist.
 
-                     Example:
+Beispiel:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -1242,7 +1242,7 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
       </trans-unit>
       <trans-unit id="MissingWarnNotAsErrorParameterError">
         <source>MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: Geben Sie mindestens einen Warnungscode an, wenn Sie den „-warnNotAsError“-Switch verwenden.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This happens if the user does something like "msbuild.exe -warnNotAsError:" without any codes.
@@ -1259,7 +1259,7 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
         <source>MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</source>
-        <target state="new">MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</target>
+        <target state="translated">MSBUILD : error MSB1062: Der „-warnnotaserror“-Switch kann nur angegeben werden, wenn auch der „-warnaserror“-Switch angegeben wurde und leer gelassen wird.</target>
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
@@ -1327,7 +1327,7 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
       </trans-unit>
       <trans-unit id="ResponseFileSwitchFromLocation">
         <source>'{0}' came from '{1}'</source>
-        <target state="new">'{0}' came from '{1}'</target>
+        <target state="translated">„{0}“ stammt aus „{1}“</target>
         <note>
       These are response file switches with the location of the response file on disk.
     </note>
@@ -1363,9 +1363,9 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
         <source>{0}
     Full command line: '{1}'
   Switches appended by response files:{2}</source>
-        <target state="new">{0}
-    Full command line: '{1}'
-  Switches appended by response files:{2}</target>
+        <target state="translated">{0}
+    Vollständige Befehlszeile: „{1}“
+  Switches, die von Antwortdateien angefügt werden:{2}</target>
         <note />
       </trans-unit>
       <trans-unit id="TargetsCouldNotBePrinted">
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index fb05178d9c1..5c04132fae5 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -57,7 +57,7 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
       </trans-unit>
       <trans-unit id="EnvironmentVariableAsSwitch">
         <source>MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: Variable de entorno no definida pasada como modificador.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This error is shown when a user passes in an environment variable (including from a response file)
@@ -270,14 +270,14 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">
+        <target state="translated">
       -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+                     Lista de códigos de advertencia para que no se traten como errores.
+                     Use un punto y coma o una coma para separar
+                     varios códigos de advertencia. No tiene efecto si el modificador -warnaserror
+                     no se ha establecido.
 
-                     Example:
+                     Ejemplo:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -1251,7 +1251,7 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
       </trans-unit>
       <trans-unit id="MissingWarnNotAsErrorParameterError">
         <source>MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: Especifique uno o varios códigos de advertencia al usar el modificador -warnNotAsError.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This happens if the user does something like "msbuild.exe -warnNotAsError:" without any codes.
@@ -1268,7 +1268,7 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
         <source>MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</source>
-        <target state="new">MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</target>
+        <target state="translated">MSBUILD : error MSB1062: No se puede especificar el modificador -warnnotaserror a menos que también se especifique el modificador -warnaserror y se deje vacío.</target>
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
@@ -1336,7 +1336,7 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
       </trans-unit>
       <trans-unit id="ResponseFileSwitchFromLocation">
         <source>'{0}' came from '{1}'</source>
-        <target state="new">'{0}' came from '{1}'</target>
+        <target state="translated">'{0}' procedía de '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
     </note>
@@ -1372,9 +1372,9 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
         <source>{0}
     Full command line: '{1}'
   Switches appended by response files:{2}</source>
-        <target state="new">{0}
-    Full command line: '{1}'
-  Switches appended by response files:{2}</target>
+        <target state="translated">{0}
+    Línea de comandos completa: '{1}'
+  Modificadores anexados por archivos de respuesta: {2}</target>
         <note />
       </trans-unit>
       <trans-unit id="TargetsCouldNotBePrinted">
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 948ad72833b..995bffa6350 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -57,7 +57,7 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
       </trans-unit>
       <trans-unit id="EnvironmentVariableAsSwitch">
         <source>MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: variable d’environnement non définie passée en tant que commutateur.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This error is shown when a user passes in an environment variable (including from a response file)
@@ -270,16 +270,16 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">
-      -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+        <target state="translated">
+     -warnNotAsError[:code[;code2]]
+                     Liste des codes d’avertissement à traiter non comme des erreurs.
+                     Utiliser un point-virgule ou une virgule pour séparer
+                     plusieurs codes d’avertissement. N’a aucun effet si -warnaserror
+                     n’est pas défini.
 
-                     Example:
+                     Exemple:
                        -warnNotAsError:MSB3026
-    </target>
+   </target>
         <note>
       LOCALIZATION: "-warnNotAsError" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -1242,7 +1242,7 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
       </trans-unit>
       <trans-unit id="MissingWarnNotAsErrorParameterError">
         <source>MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: Spécifiez un ou plusieurs codes d’avertissement lors de l’utilisation du commutateur -warnNotAsError.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This happens if the user does something like "msbuild.exe -warnNotAsError:" without any codes.
@@ -1259,7 +1259,7 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
         <source>MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</source>
-        <target state="new">MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</target>
+        <target state="translated">MSBUILD : error MSB1062: Impossible de spécifier le commutateur -warnnotaserror, sauf si le commutateur -warnaserror est également spécifié et laissé vide.</target>
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
@@ -1327,7 +1327,7 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
       </trans-unit>
       <trans-unit id="ResponseFileSwitchFromLocation">
         <source>'{0}' came from '{1}'</source>
-        <target state="new">'{0}' came from '{1}'</target>
+        <target state="translated">'{0}' provient de '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
     </note>
@@ -1363,9 +1363,9 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
         <source>{0}
     Full command line: '{1}'
   Switches appended by response files:{2}</source>
-        <target state="new">{0}
-    Full command line: '{1}'
-  Switches appended by response files:{2}</target>
+        <target state="translated">{0}
+ ligne de commande complète : «{1}»
+ Commutateurs ajoutés par les fichiers réponse :{2}</target>
         <note />
       </trans-unit>
       <trans-unit id="TargetsCouldNotBePrinted">
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 9c477e9ecde..ab0acb73e22 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -57,7 +57,7 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
       </trans-unit>
       <trans-unit id="EnvironmentVariableAsSwitch">
         <source>MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: variabile di ambiente non definita passata come opzione.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This error is shown when a user passes in an environment variable (including from a response file)
@@ -277,14 +277,14 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">
+        <target state="translated">
       -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+                     Elenco di codici di avviso da non considerare come errori.
+                     Usare un punto e virgola o una virgola per separare
+                     più codici di avviso. Non ha alcun effetto se l’opzione -warnaserror
+                     non è impostata.
 
-                     Example:
+Esempio:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -1264,7 +1264,7 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
       </trans-unit>
       <trans-unit id="MissingWarnNotAsErrorParameterError">
         <source>MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: specificare uno o più codici di avviso quando si usa l'opzione -warnNotAsError.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This happens if the user does something like "msbuild.exe -warnNotAsError:" without any codes.
@@ -1281,7 +1281,7 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
         <source>MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</source>
-        <target state="new">MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</target>
+        <target state="translated">MSBUILD : error MSB1062: non è possibile specificare l'opzione -warnnotaserror a meno che non venga specificata e lasciata vuota anche l'opzione -warnaserror.</target>
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
@@ -1349,7 +1349,7 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
       </trans-unit>
       <trans-unit id="ResponseFileSwitchFromLocation">
         <source>'{0}' came from '{1}'</source>
-        <target state="new">'{0}' came from '{1}'</target>
+        <target state="translated">'{0}' proviene da '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
     </note>
@@ -1385,9 +1385,9 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
         <source>{0}
     Full command line: '{1}'
   Switches appended by response files:{2}</source>
-        <target state="new">{0}
-    Full command line: '{1}'
-  Switches appended by response files:{2}</target>
+        <target state="translated">{0}
+    Riga di comando completa: '{1}'
+  Opzioni accodate da file di risposta:{2}</target>
         <note />
       </trans-unit>
       <trans-unit id="TargetsCouldNotBePrinted">
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index a0b7493db5b..41444e220b0 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -57,7 +57,7 @@ Copyright (C) Microsoft Corporation.All rights reserved.
       </trans-unit>
       <trans-unit id="EnvironmentVariableAsSwitch">
         <source>MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: 未定義の環境変数が切り替えとして渡されました。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This error is shown when a user passes in an environment variable (including from a response file)
@@ -270,14 +270,14 @@ Copyright (C) Microsoft Corporation.All rights reserved.
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">
+        <target state="translated">
       -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+                     エラーとして扱わない警告コードのリスト.
+                     セミコロンまたはコンマを使用して、複数の警告コード
+                     区切ります。-warnaserror スイッチが設定されていない場合
+                     効果はありません。
 
-                     Example:
+                     例:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -1242,7 +1242,7 @@ Copyright (C) Microsoft Corporation.All rights reserved.
       </trans-unit>
       <trans-unit id="MissingWarnNotAsErrorParameterError">
         <source>MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: -warnNotAsError スイッチを使用する場合は、1 つ以上の警告コードを指定してください。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This happens if the user does something like "msbuild.exe -warnNotAsError:" without any codes.
@@ -1259,7 +1259,7 @@ Copyright (C) Microsoft Corporation.All rights reserved.
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
         <source>MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</source>
-        <target state="new">MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</target>
+        <target state="translated">MSBUILD : error MSB1062: -war nullerror スイッチも指定され、空のままにしない限り、-warnnotaserror スイッチを指定できません。</target>
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
@@ -1327,7 +1327,7 @@ Copyright (C) Microsoft Corporation.All rights reserved.
       </trans-unit>
       <trans-unit id="ResponseFileSwitchFromLocation">
         <source>'{0}' came from '{1}'</source>
-        <target state="new">'{0}' came from '{1}'</target>
+        <target state="translated">`{0}`からの `{1}`</target>
         <note>
       These are response file switches with the location of the response file on disk.
     </note>
@@ -1363,9 +1363,9 @@ Copyright (C) Microsoft Corporation.All rights reserved.
         <source>{0}
     Full command line: '{1}'
   Switches appended by response files:{2}</source>
-        <target state="new">{0}
-    Full command line: '{1}'
-  Switches appended by response files:{2}</target>
+        <target state="translated">{0}
+    完全なコマンド ライン: `{1}`
+ 応答ファイルによって追加されたスイッチ:{2}</target>
         <note />
       </trans-unit>
       <trans-unit id="TargetsCouldNotBePrinted">
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 97fd6ebcca1..38e5e44c459 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -57,7 +57,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="EnvironmentVariableAsSwitch">
         <source>MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: 정의되지 않은 환경 변수가 스위치로 전달되었습니다.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This error is shown when a user passes in an environment variable (including from a response file)
@@ -270,16 +270,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">
-      -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+        <target state="translated">
+       -warnNotAsError[:code[;code2]]
+                     오류로 처리하지 않을 경고 코드 목록입니다.
+                     세미콜론이나 쉼표를 사용하여 구분하세요.
+                     여러 경고 코드. -warnaserror
+ 스위치가 설정되어 있지 않으면 효과가 없습니다.
 
-                     Example:
-                       -warnNotAsError:MSB3026
-    </target>
+                     예:
+                     -warnNotAsError:MSB3026
+   </target>
         <note>
       LOCALIZATION: "-warnNotAsError" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -1242,7 +1242,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="MissingWarnNotAsErrorParameterError">
         <source>MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: -warnNotAsError 스위치를 사용할 때 하나 이상의 경고 코드를 지정하세요.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This happens if the user does something like "msbuild.exe -warnNotAsError:" without any codes.
@@ -1259,7 +1259,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
         <source>MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</source>
-        <target state="new">MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</target>
+        <target state="translated">MSBUILD : error MSB1062: -warnaserror 스위치도 지정하고 비어 있지 않으면 -warnnotaserror 스위치를 지정할 수 없습니다.</target>
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
@@ -1327,7 +1327,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="ResponseFileSwitchFromLocation">
         <source>'{0}' came from '{1}'</source>
-        <target state="new">'{0}' came from '{1}'</target>
+        <target state="translated">'{0}'은(는) '{1}'에서 제공되었습니다.</target>
         <note>
       These are response file switches with the location of the response file on disk.
     </note>
@@ -1363,9 +1363,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <source>{0}
     Full command line: '{1}'
   Switches appended by response files:{2}</source>
-        <target state="new">{0}
-    Full command line: '{1}'
-  Switches appended by response files:{2}</target>
+        <target state="translated">{0}
+   전체 명령줄: '{1}'
+  응답 파일에 의해 추가된 스위치:{2}</target>
         <note />
       </trans-unit>
       <trans-unit id="TargetsCouldNotBePrinted">
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index 2a3609c667f..a0301139fb7 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -57,7 +57,7 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
       </trans-unit>
       <trans-unit id="EnvironmentVariableAsSwitch">
         <source>MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: Niezdefiniowana zmienna środowiskowa przekazana jako przełącznik.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This error is shown when a user passes in an environment variable (including from a response file)
@@ -277,11 +277,11 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">
-      -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
+        <target state="translated">
+ -warnNotAsError[:code[;code2]]
+ Lista kodów ostrzeżeń, które mają być traktowane jako błędy. 
+ Rozdziel średnik lub przecinek
+ wiele kodów ostrzeżeń. Nie ma żadnego efektu, jeśli przełącznik -warnaserror
                      switch is not set.
 
                      Example:
@@ -1256,7 +1256,7 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
       </trans-unit>
       <trans-unit id="MissingWarnNotAsErrorParameterError">
         <source>MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: Określ co najmniej jeden kod ostrzeżenia podczas korzystania z przełącznika –warnNotAsError.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This happens if the user does something like "msbuild.exe -warnNotAsError:" without any codes.
@@ -1273,7 +1273,7 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
         <source>MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</source>
-        <target state="new">MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</target>
+        <target state="translated">MSBUILD : error MSB1062: Nie można określić przełącznika –warnnotaserror, chyba że przełącznik –warnaserror również jest określony i pozostanie pusty.</target>
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
@@ -1341,7 +1341,7 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
       </trans-unit>
       <trans-unit id="ResponseFileSwitchFromLocation">
         <source>'{0}' came from '{1}'</source>
-        <target state="new">'{0}' came from '{1}'</target>
+        <target state="translated">Element „{0}“ pochodzi z „{1}“</target>
         <note>
       These are response file switches with the location of the response file on disk.
     </note>
@@ -1377,9 +1377,9 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
         <source>{0}
     Full command line: '{1}'
   Switches appended by response files:{2}</source>
-        <target state="new">{0}
-    Full command line: '{1}'
-  Switches appended by response files:{2}</target>
+        <target state="translated">{0}
+ Pełny wiersz polecenia: „{1}“
+ Przełączniki dołączane przez pliki odpowiedzi: {2}</target>
         <note />
       </trans-unit>
       <trans-unit id="TargetsCouldNotBePrinted">
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 9cc07ad04be..65bb4fa8ef0 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -57,7 +57,7 @@ Copyright (C) Microsoft Corporation. Todos os direitos reservados.
       </trans-unit>
       <trans-unit id="EnvironmentVariableAsSwitch">
         <source>MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: variável de ambiente indefinida passada como comutador.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This error is shown when a user passes in an environment variable (including from a response file)
@@ -271,14 +271,14 @@ isoladamente.
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">
+        <target state="translated">
       -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+                     Lista de códigos de aviso para tratar e não tratar como erros.
+                     Use ponto e vírgula ou vírgula para separar
+                     vários códigos de aviso. Não tem efeito se o -warnaserror
+                     interruptor não está definido.
 
-                     Example:
+                     Examplo:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -1243,7 +1243,7 @@ isoladamente.
       </trans-unit>
       <trans-unit id="MissingWarnNotAsErrorParameterError">
         <source>MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: especifique um ou mais códigos de aviso ao usar a opção -warnNotAsError.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This happens if the user does something like "msbuild.exe -warnNotAsError:" without any codes.
@@ -1260,7 +1260,7 @@ isoladamente.
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
         <source>MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</source>
-        <target state="new">MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</target>
+        <target state="translated">MSBUILD : error MSB1062: A opção -warnnotaserror não pode ser especificada, a menos que a opção -warnaserror também seja especificada e deixada em branco.</target>
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
@@ -1328,7 +1328,7 @@ isoladamente.
       </trans-unit>
       <trans-unit id="ResponseFileSwitchFromLocation">
         <source>'{0}' came from '{1}'</source>
-        <target state="new">'{0}' came from '{1}'</target>
+        <target state="translated">'{0}' proveniente de '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
     </note>
@@ -1364,9 +1364,9 @@ isoladamente.
         <source>{0}
     Full command line: '{1}'
   Switches appended by response files:{2}</source>
-        <target state="new">{0}
-    Full command line: '{1}'
-  Switches appended by response files:{2}</target>
+        <target state="translated">{0}
+    Linha de comando completa: '{1}'
+  Comutadores acrescentados por arquivos de resposta:{2}</target>
         <note />
       </trans-unit>
       <trans-unit id="TargetsCouldNotBePrinted">
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index f6b73ec7a63..afe39bd1474 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -57,7 +57,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="EnvironmentVariableAsSwitch">
         <source>MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: в качестве параметра передана неопределенная переменная среды.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This error is shown when a user passes in an environment variable (including from a response file)
@@ -269,14 +269,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">
+        <target state="translated">
       -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+                     Список кодов предупреждений, которые не будут рассматриваться как ошибки.
+                     Используйте точку с запятой или запятую для разделения
+                     нескольких кодов предупреждения. Не действует, если параметр -warnaserror
+                     не задан.
 
-                     Example:
+                     Пример:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -1241,7 +1241,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="MissingWarnNotAsErrorParameterError">
         <source>MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: укажите один или несколько кодов предупреждений при использовании параметра -warnNotAsError.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This happens if the user does something like "msbuild.exe -warnNotAsError:" without any codes.
@@ -1258,7 +1258,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
         <source>MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</source>
-        <target state="new">MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</target>
+        <target state="translated">MSBUILD : error MSB1062: невозможно задать параметр -warnnotaserror, если параметр -warnaserror также не задан и не оставлен пустым.</target>
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
@@ -1326,7 +1326,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="ResponseFileSwitchFromLocation">
         <source>'{0}' came from '{1}'</source>
-        <target state="new">'{0}' came from '{1}'</target>
+        <target state="translated">\"{0}\" получен из \"{1}\"</target>
         <note>
       These are response file switches with the location of the response file on disk.
     </note>
@@ -1362,9 +1362,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <source>{0}
     Full command line: '{1}'
   Switches appended by response files:{2}</source>
-        <target state="new">{0}
-    Full command line: '{1}'
-  Switches appended by response files:{2}</target>
+        <target state="translated">{0}
+    Полная командная строка: '{1}'
+  Параметры, добавленные файлами откликов:{2}</target>
         <note />
       </trans-unit>
       <trans-unit id="TargetsCouldNotBePrinted">
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 6f3327051c3..f0d21717f61 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -57,7 +57,7 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
       </trans-unit>
       <trans-unit id="EnvironmentVariableAsSwitch">
         <source>MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: Tanımlanmamış ortam değişkeni anahtar olarak geçirildi.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This error is shown when a user passes in an environment variable (including from a response file)
@@ -270,14 +270,14 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">
-      -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+        <target state="translated">
+-warnNotAsError[:code[;code2]]
+                     Hata olarak kabul edilmeyen uyarı kodlarının listesi.
+                     Ayırmak için noktalı virgül veya virgül kullanın
+                    çoklu uyarı kodları -warnaserror ise hiçbir etkisi yoktur
+                     anahtarı ayarlanmadı.
 
-                     Example:
+Örnek:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -1246,7 +1246,7 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
       </trans-unit>
       <trans-unit id="MissingWarnNotAsErrorParameterError">
         <source>MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: -warnNotAsError anahtarını kullanırken bir veya daha fazla uyarı kodu belirtin.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This happens if the user does something like "msbuild.exe -warnNotAsError:" without any codes.
@@ -1263,7 +1263,7 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
         <source>MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</source>
-        <target state="new">MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</target>
+        <target state="translated">MSBUILD : error MSB1062: -warnnotaserror anahtarı, -warnaserror anahtarı da belirtilmedikçe ve boş bırakılmadıkça belirtilemez.</target>
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
@@ -1331,7 +1331,7 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
       </trans-unit>
       <trans-unit id="ResponseFileSwitchFromLocation">
         <source>'{0}' came from '{1}'</source>
-        <target state="new">'{0}' came from '{1}'</target>
+        <target state="translated">'{0}', '{1}' kaynağından geldi</target>
         <note>
       These are response file switches with the location of the response file on disk.
     </note>
@@ -1367,9 +1367,9 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
         <source>{0}
     Full command line: '{1}'
   Switches appended by response files:{2}</source>
-        <target state="new">{0}
-    Full command line: '{1}'
-  Switches appended by response files:{2}</target>
+        <target state="translated">{0}
+    Tam komut satırı: '{1}'
+  Yanıt dosyaları tarafından eklenen anahtarlar:{2}</target>
         <note />
       </trans-unit>
       <trans-unit id="TargetsCouldNotBePrinted">
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 58c2ad54fcd..71e98f61fd7 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -57,7 +57,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="EnvironmentVariableAsSwitch">
         <source>MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: 未定义的环境变量作为开关传入。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This error is shown when a user passes in an environment variable (including from a response file)
@@ -270,14 +270,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">
+        <target state="translated">
       -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+                     不视为错误的警告代码列表.
+                     使用分号或逗号分隔
+                     多个警告代码。如果未设置 -warnaserror
+                     开关，则不会产生任何影响。
 
-                     Example:
+                     示例:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -1242,7 +1242,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="MissingWarnNotAsErrorParameterError">
         <source>MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: 使用 -warnNotAsError 开关时指定一个或多个警告代码。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This happens if the user does something like "msbuild.exe -warnNotAsError:" without any codes.
@@ -1259,7 +1259,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
         <source>MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</source>
-        <target state="new">MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</target>
+        <target state="translated">MSBUILD : error MSB1062: 除非还指定了 -warnaserror 开关并将其留空，否则无法指定 -warnnotaserror 开关。</target>
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
@@ -1327,7 +1327,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="ResponseFileSwitchFromLocation">
         <source>'{0}' came from '{1}'</source>
-        <target state="new">'{0}' came from '{1}'</target>
+        <target state="translated">“{0}”来自“{1}”</target>
         <note>
       These are response file switches with the location of the response file on disk.
     </note>
@@ -1363,9 +1363,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <source>{0}
     Full command line: '{1}'
   Switches appended by response files:{2}</source>
-        <target state="new">{0}
-    Full command line: '{1}'
-  Switches appended by response files:{2}</target>
+        <target state="translated">{0}
+    完整命令行:“{1}”
+  响应文件追加的开关: {2}</target>
         <note />
       </trans-unit>
       <trans-unit id="TargetsCouldNotBePrinted">
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 5273b8d77a8..cf86b834dd9 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -57,7 +57,7 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
       </trans-unit>
       <trans-unit id="EnvironmentVariableAsSwitch">
         <source>MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Undefined environment variable passed in as switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: 以切換參數傳入未定義的環境變數。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This error is shown when a user passes in an environment variable (including from a response file)
@@ -270,14 +270,14 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">
+        <target state="translated">
       -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+                     要視為不視為錯誤的警告碼清單。
+                     使用分號或逗號分隔
+                     多個警告碼。如果 -warnaserror 沒有作用
+                     未設定切換參數。
 
-                     Example:
+範例:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -1242,7 +1242,7 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
       </trans-unit>
       <trans-unit id="MissingWarnNotAsErrorParameterError">
         <source>MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</source>
-        <target state="new">MSBUILD : error MSB1060: Specify one or more warning codes when using the -warnNotAsError switch.</target>
+        <target state="translated">MSBUILD : error MSB1060: 使用 -warnNotAsError 切換參數時，請指定一或多個警告碼。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1060: "}
       UE: This happens if the user does something like "msbuild.exe -warnNotAsError:" without any codes.
@@ -1259,7 +1259,7 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
         <source>MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</source>
-        <target state="new">MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</target>
+        <target state="translated">MSBUILD : error MSB1062: 除非同時指定 -warnaserror 切換參數且保留空白，否則無法指定 -warnnotaserror 切換參數。</target>
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
@@ -1327,7 +1327,7 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
       </trans-unit>
       <trans-unit id="ResponseFileSwitchFromLocation">
         <source>'{0}' came from '{1}'</source>
-        <target state="new">'{0}' came from '{1}'</target>
+        <target state="translated">'{0}' 來自 '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
     </note>
@@ -1363,9 +1363,9 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
         <source>{0}
     Full command line: '{1}'
   Switches appended by response files:{2}</source>
-        <target state="new">{0}
-    Full command line: '{1}'
-  Switches appended by response files:{2}</target>
+        <target state="translated">{0}
+    完整命令列: '{1}'
+  回應檔案附加的切換參數:{2}</target>
         <note />
       </trans-unit>
       <trans-unit id="TargetsCouldNotBePrinted">
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index f56435ec284..e7dba840e1a 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -142,6 +142,9 @@
     <Compile Include="..\Framework\StringBuilderCache.cs">
       <Link>StringBuilderCache.cs</Link>
     </Compile>
+    <Compile Include="..\Framework\SupportedOSPlatform.cs">
+      <Link>SupportedOSPlatform.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\TaskEngineAssemblyResolver.cs">
       <Link>TaskEngineAssemblyResolver.cs</Link>
     </Compile>
diff --git a/src/Samples/PortableTask/PortableTask.csproj b/src/Samples/PortableTask/PortableTask.csproj
index 6a4541787a1..a497a305fb2 100644
--- a/src/Samples/PortableTask/PortableTask.csproj
+++ b/src/Samples/PortableTask/PortableTask.csproj
@@ -3,7 +3,7 @@
     <UseProductOutputPath>true</UseProductOutputPath>
     <CopyNuGetImplementations>false</CopyNuGetImplementations>
     <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
-    <TargetFrameworks>netstandard2.0</TargetFrameworks>
+    <TargetFramework>netstandard2.0</TargetFramework>
   </PropertyGroup>
   <ItemGroup>
     <Content Include="portableTaskTest.proj">
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 7af174db82b..e837e1435fe 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -857,7 +857,7 @@ private void GetFilesRecursive(
             Dictionary<string, List<RecursionState>> searchesToExcludeInSubdirs,
             TaskOptions taskOptions)
         {
-            ErrorUtilities.VerifyThrow((recursionState.SearchData.Filespec== null) || (recursionState.SearchData.RegexFileMatch == null),
+            ErrorUtilities.VerifyThrow((recursionState.SearchData.Filespec == null) || (recursionState.SearchData.RegexFileMatch == null),
                 "File-spec overrides the regular expression -- pass null for file-spec if you want to use the regular expression.");
 
             ErrorUtilities.VerifyThrow((recursionState.SearchData.Filespec != null) || (recursionState.SearchData.RegexFileMatch != null),
@@ -1034,7 +1034,7 @@ private void GetFilesRecursive(
             {
                 Parallel.ForEach(
                     _getFileSystemEntries(FileSystemEntity.Directories, recursionState.BaseDirectory, nextStep.DirectoryPattern, null, false),
-                    new ParallelOptions {MaxDegreeOfParallelism = dop},
+                    new ParallelOptions { MaxDegreeOfParallelism = dop },
                     processSubdirectory);
             }
             if (dop <= 0)
@@ -1941,8 +1941,8 @@ public TaskOptions(int maxTasks)
         /// <param name="projectDirectoryUnescaped">The project directory.</param>
         /// <param name="filespecUnescaped">Get files that match the given file spec.</param>
         /// <param name="excludeSpecsUnescaped">Exclude files that match this file spec.</param>
-        /// <returns>The array of files.</returns>
-        internal string[] GetFiles
+        /// <returns>The search action, array of files, and Exclude file spec (if applicable).</returns>
+        internal (string[] FileList, SearchAction Action, string ExcludeFileSpec) GetFiles
             (
             string projectDirectoryUnescaped,
             string filespecUnescaped,
@@ -1952,7 +1952,7 @@ internal string[] GetFiles
             // For performance. Short-circuit iff there is no wildcard.
             if (!HasWildcards(filespecUnescaped))
             {
-                return CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped);
+                return (CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped), SearchAction.None, string.Empty);
             }
 
             if (_cachedGlobExpansions == null)
@@ -1966,6 +1966,9 @@ internal string[] GetFiles
             var enumerationKey = ComputeFileEnumerationCacheKey(projectDirectoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);
 
             IReadOnlyList<string> files;
+            string[] fileList;
+            SearchAction action = SearchAction.None;
+            string excludeFileSpec = string.Empty;
             if (!_cachedGlobExpansions.TryGetValue(enumerationKey, out files))
             {
                 // avoid parallel evaluations of the same wildcard by using a unique lock for each wildcard
@@ -1974,14 +1977,17 @@ internal string[] GetFiles
                 {
                     if (!_cachedGlobExpansions.TryGetValue(enumerationKey, out files))
                     {
-                        files =
-                            _cachedGlobExpansions.GetOrAdd(
+                        files = _cachedGlobExpansions.GetOrAdd(
                                 enumerationKey,
                                 (_) =>
-                                    GetFilesImplementation(
+                                {
+                                    (fileList, action, excludeFileSpec) = GetFilesImplementation(
                                         projectDirectoryUnescaped,
                                         filespecUnescaped,
-                                        excludeSpecsUnescaped));
+                                        excludeSpecsUnescaped);
+
+                                    return fileList;
+                                });
                     }
                 }
             }
@@ -1989,7 +1995,7 @@ internal string[] GetFiles
             // Copy the file enumerations to prevent outside modifications of the cache (e.g. sorting, escaping) and to maintain the original method contract that a new array is created on each call.
             var filesToReturn = files.ToArray();
 
-            return filesToReturn;
+            return (filesToReturn, action, excludeFileSpec);
         }
 
         private static string ComputeFileEnumerationCacheKey(string projectDirectoryUnescaped, string filespecUnescaped, List<string> excludes)
@@ -2067,11 +2073,14 @@ private static string ComputeFileEnumerationCacheKey(string projectDirectoryUnes
             }
         }
 
-        enum SearchAction
+        public enum SearchAction
         {
+            None,
             RunSearch,
             ReturnFileSpec,
             ReturnEmptyList,
+            FailOnDriveEnumeratingWildcard,
+            LogDriveEnumeratingWildcard
         }
 
         private SearchAction GetFileSearchData(
@@ -2135,6 +2144,16 @@ out bool isLegalFileSpec
                 return SearchAction.ReturnEmptyList;
             }
 
+            /*
+             * If a drive enumerating wildcard pattern is detected with the fixed directory and wildcard parts, then
+             * this should either be logged or an exception should be thrown.
+             */
+            bool logDriveEnumeratingWildcard = IsDriveEnumeratingWildcardPattern(fixedDirectoryPart, wildcardDirectoryPart);
+            if (logDriveEnumeratingWildcard && Traits.Instance.ThrowOnDriveEnumeratingWildcard)
+            {
+                return SearchAction.FailOnDriveEnumeratingWildcard;
+            }
+
             string directoryPattern = null;
             if (wildcardDirectoryPart.Length > 0)
             {
@@ -2143,6 +2162,7 @@ out bool isLegalFileSpec
                 // "**/.*/**" for example, and is worth special-casing so it doesn't fall into the slow regex logic.
                 string wildcard = wildcardDirectoryPart.TrimTrailingSlashes();
                 int wildcardLength = wildcard.Length;
+
                 if (wildcardLength > 6 &&
                     wildcard[0] == '*' &&
                     wildcard[1] == '*' &&
@@ -2182,6 +2202,11 @@ out bool isLegalFileSpec
             result.BaseDirectory = Normalize(fixedDirectoryPart);
             result.RemainingWildcardDirectory = Normalize(wildcardDirectoryPart);
 
+            if (logDriveEnumeratingWildcard)
+            {
+                return SearchAction.LogDriveEnumeratingWildcard;
+            }
+
             return SearchAction.RunSearch;
         }
 
@@ -2258,6 +2283,76 @@ internal static string Normalize(string aString)
             return sb.ToString();
         }
 
+        /// <summary>
+        /// Returns true if drive enumerating wildcard patterns are detected using the directory and wildcard parts.
+        /// </summary>
+        /// <param name="directoryPart">Fixed directory string, portion of file spec info.</param>
+        /// <param name="wildcardPart">Wildcard string, portion of file spec info.</param>
+        internal static bool IsDriveEnumeratingWildcardPattern(string directoryPart, string wildcardPart)
+        {
+            int directoryPartLength = directoryPart.Length;
+            int wildcardPartLength = wildcardPart.Length;
+
+            // Handles detection of <drive letter>:<slashes>** pattern for Windows.
+            if (NativeMethodsShared.IsWindows &&
+                directoryPartLength >= 3 &&
+                wildcardPartLength >= 2 &&
+                IsDrivePatternWithoutSlash(directoryPart[0], directoryPart[1]))
+            {
+                return IsFullFileSystemScan(2, directoryPartLength, directoryPart, wildcardPart);
+            }
+
+            // Handles detection of <slashes>** pattern for any platform.
+            else if (directoryPartLength >= 1 &&
+                     wildcardPartLength >= 2)
+            {
+                return IsFullFileSystemScan(0, directoryPartLength, directoryPart, wildcardPart);
+            }
+
+            return false;
+        }
+
+        /// <summary>
+        /// Returns true if given characters follow a drive pattern without the slash (ex: C:).
+        /// </summary>
+        /// <param name="firstValue">First char from directory part of file spec string.</param>
+        /// <param name="secondValue">Second char from directory part of file spec string.</param>
+        private static bool IsDrivePatternWithoutSlash(char firstValue, char secondValue)
+        {
+            return IsValidDriveChar(firstValue) && (secondValue == ':');
+        }
+
+        /// <summary>
+        /// Returns true if selected characters from the fixed directory and wildcard pattern make up the "{any number of slashes}**" pattern.
+        /// </summary>
+        /// <param name="directoryPartIndex">Starting index to begin detecting slashes in directory part of file spec string.</param>
+        /// <param name="directoryPartLength">Length of directory part of file spec string.</param>
+        /// <param name="directoryPart">Fixed directory string, portion of file spec info.</param>
+        /// <param name="wildcardPart">Wildcard string, portion of file spec info.</param>
+        private static bool IsFullFileSystemScan(int directoryPartIndex, int directoryPartLength, string directoryPart, string wildcardPart)
+        {
+            for (int i = directoryPartIndex; i < directoryPartLength; i++)
+            {
+                if (!FileUtilities.IsAnySlash(directoryPart[i]))
+                {
+                    return false;
+                }
+            }
+
+            return (wildcardPart[0] == '*') && (wildcardPart[1] == '*');
+        }
+
+        /// <summary>
+        /// Returns true if the given character is a valid drive letter.
+        /// </summary>
+        /// <remarks>
+        /// Copied from https://github.com/dotnet/corefx/blob/master/src/Common/src/System/IO/PathInternal.Windows.cs#L77-L83
+        /// </remarks>
+        private static bool IsValidDriveChar(char value)
+        {
+            return (value >= 'A' && value <= 'Z') || (value >= 'a' && value <= 'z');
+        }
+
         /// <summary>
         /// Skips slash characters in a string.
         /// </summary>
@@ -2276,15 +2371,6 @@ private static int SkipSlashes(string aString, int startingIndex)
             return index;
         }
 
-        // copied from https://github.com/dotnet/corefx/blob/master/src/Common/src/System/IO/PathInternal.Windows.cs#L77-L83
-        /// <summary>
-        /// Returns true if the given character is a valid drive letter
-        /// </summary>
-        private static bool IsValidDriveChar(char value)
-        {
-            return (value >= 'A' && value <= 'Z') || (value >= 'a' && value <= 'z');
-        }
-
         private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUnescaped, List<string> excludeSpecsUnescaped)
         {
             if (excludeSpecsUnescaped != null)
@@ -2317,8 +2403,8 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
         /// <param name="projectDirectoryUnescaped">The project directory.</param>
         /// <param name="filespecUnescaped">Get files that match the given file spec.</param>
         /// <param name="excludeSpecsUnescaped">Exclude files that match this file spec.</param>
-        /// <returns>The array of files.</returns>
-        private string[] GetFilesImplementation(
+        /// <returns>The search action, array of files, and Exclude file spec (if applicable).</returns>
+        private (string[] FileList, SearchAction Action, string ExcludeFileSpec) GetFilesImplementation(
             string projectDirectoryUnescaped,
             string filespecUnescaped,
             List<string> excludeSpecsUnescaped)
@@ -2333,13 +2419,17 @@ private string[] GetFilesImplementation(
 
             if (action == SearchAction.ReturnEmptyList)
             {
-                return Array.Empty<string>();
+                return (Array.Empty<string>(), action, string.Empty);
             }
             else if (action == SearchAction.ReturnFileSpec)
             {
-                return CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped);
+                return (CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped), action, string.Empty);
+            }
+            else if (action == SearchAction.FailOnDriveEnumeratingWildcard)
+            {
+                return (Array.Empty<string>(), action, string.Empty);
             }
-            else if (action != SearchAction.RunSearch)
+            else if ((action != SearchAction.RunSearch) && (action != SearchAction.LogDriveEnumeratingWildcard))
             {
                 // This means the enum value wasn't valid (or a new one was added without updating code correctly)
                 throw new NotSupportedException(action.ToString());
@@ -2351,6 +2441,10 @@ private string[] GetFilesImplementation(
             //  The BaseDirectory of the exclude search is the key for this dictionary.
             Dictionary<string, List<RecursionState>> searchesToExcludeInSubdirs = null;
 
+            // Track the search action and exclude file spec for proper detection and logging of drive enumerating wildcards.
+            SearchAction trackSearchAction = action;
+            string trackExcludeFileSpec = string.Empty;
+
             HashSet<string> resultsToExclude = null;
             if (excludeSpecsUnescaped != null)
             {
@@ -2376,7 +2470,16 @@ private string[] GetFilesImplementation(
                         // Nothing to do
                         continue;
                     }
-                    else if (excludeAction != SearchAction.RunSearch)
+                    else if (excludeAction == SearchAction.FailOnDriveEnumeratingWildcard)
+                    {
+                        return (Array.Empty<string>(), excludeAction, excludeSpec);
+                    }
+                    else if (excludeAction == SearchAction.LogDriveEnumeratingWildcard)
+                    {
+                        trackSearchAction = excludeAction;
+                        trackExcludeFileSpec = excludeSpec;
+                    }
+                    else if ((excludeAction != SearchAction.RunSearch) && (excludeAction != SearchAction.LogDriveEnumeratingWildcard))
                     {
                         // This means the enum value wasn't valid (or a new one was added without updating code correctly)
                         throw new NotSupportedException(excludeAction.ToString());
@@ -2530,12 +2633,17 @@ private string[] GetFilesImplementation(
             // Catch exceptions that are thrown inside the Parallel.ForEach
             catch (AggregateException ex) when (InnerExceptionsAreAllIoRelated(ex))
             {
-                return CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped);
+                // Flatten to get exceptions than are thrown inside a nested Parallel.ForEach
+                if (ex.Flatten().InnerExceptions.All(ExceptionHandling.IsIoRelatedException))
+                {
+                    return (CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped), trackSearchAction, trackExcludeFileSpec);
+                }
+                throw;
             }
             catch (Exception ex) when (ExceptionHandling.IsIoRelatedException(ex))
             {
                 // Assume it's not meant to be a path
-                return CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped);
+                return (CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped), trackSearchAction, trackExcludeFileSpec);
             }
 
             /*
@@ -2545,7 +2653,7 @@ private string[] GetFilesImplementation(
                 ? listOfFiles.SelectMany(list => list).Where(f => !resultsToExclude.Contains(f)).ToArray()
                 : listOfFiles.SelectMany(list => list).ToArray();
 
-            return files;
+            return (files, trackSearchAction, trackExcludeFileSpec);
         }
 
         private bool InnerExceptionsAreAllIoRelated(AggregateException ex)
diff --git a/src/Shared/Resources/Strings.shared.resx b/src/Shared/Resources/Strings.shared.resx
index 4a2ab0dd185..b1c884da6fd 100644
--- a/src/Shared/Resources/Strings.shared.resx
+++ b/src/Shared/Resources/Strings.shared.resx
@@ -278,10 +278,15 @@
     <value>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</value>
     <comment>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</comment>
   </data>
+  <data name="WildcardResultsInDriveEnumeration" xml:space="preserve">
+    <value>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</value>
+    <comment>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</comment>
+  </data>
   <!--
         The shared message bucket is: MSB5001 - MSB5999
 
-        Next message code should be MSB5029
+        Next message code should be MSB5030
 
         Some unused codes which can also be reused (because their messages were deleted, and UE hasn't indexed the codes yet):
             <none>
diff --git a/src/Shared/Resources/xlf/Strings.shared.cs.xlf b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
index 80de31cf354..2ae3ccc1cd9 100644
--- a/src/Shared/Resources/xlf/Strings.shared.cs.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
@@ -308,6 +308,12 @@
         <target state="translated">Parametr {0} s přiřazenou hodnotou {1} nesmí obsahovat neplatnou cestu nebo neplatné znaky souboru.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.de.xlf b/src/Shared/Resources/xlf/Strings.shared.de.xlf
index 28e73b49c1a..12ae56e9f4a 100644
--- a/src/Shared/Resources/xlf/Strings.shared.de.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.de.xlf
@@ -308,6 +308,12 @@
         <target state="translated">Der Parameter "{0}" mit dem zugewiesenen Wert "{1}" darf keinen ungültigen Pfad und keine ungültigen Dateizeichen haben.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.es.xlf b/src/Shared/Resources/xlf/Strings.shared.es.xlf
index 332d51f7961..3c8570e8e88 100644
--- a/src/Shared/Resources/xlf/Strings.shared.es.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.es.xlf
@@ -308,6 +308,12 @@
         <target state="translated">El parámetro "{0}" con el valor asignado "{1}" no puede tener una ruta de acceso no válida o caracteres de archivo no válidos.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.fr.xlf b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
index 98d0ecd2344..53bf871cc4e 100644
--- a/src/Shared/Resources/xlf/Strings.shared.fr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
@@ -308,6 +308,12 @@
         <target state="translated">Le paramètre "{0}" avec la valeur assignée "{1}" ne peut pas avoir un chemin non valide ou des caractères de fichier non valides.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.it.xlf b/src/Shared/Resources/xlf/Strings.shared.it.xlf
index 31c10bd56ca..da4df2e58a7 100644
--- a/src/Shared/Resources/xlf/Strings.shared.it.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.it.xlf
@@ -308,6 +308,12 @@
         <target state="translated">Il parametro "{0}" con valore assegnato "{1}" non può contenere un percorso non valido o caratteri di file non validi.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.ja.xlf b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
index 762d7780a9b..734c1003330 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ja.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
@@ -308,6 +308,12 @@
         <target state="translated">値 "{1}" が割り当てられたパラメーター "{0}" には、無効なパスまたは無効なファイル内の文字を指定することはできません。</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.ko.xlf b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
index 7cd5d631a66..3f41262d271 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ko.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
@@ -308,6 +308,12 @@
         <target state="translated">"{1}" 값이 할당된 "{0}" 매개 변수는 유효하지 않은 경로 또는 파일 문자를 포함할 수 없습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.pl.xlf b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
index 3755284c24a..3b400e189a6 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pl.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
@@ -308,6 +308,12 @@
         <target state="translated">Parametr „{0}” z przypisaną wartością „{1}” nie może mieć nieprawidłowej ścieżki ani zawierać nieprawidłowych znaków w pliku.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
index 6fd1b77903b..3db1eecab19 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
@@ -308,6 +308,12 @@
         <target state="translated">O parâmetro "{0}" com o valor "{1}" atribuído não pode ter um caminho inválido ou caracteres de arquivo inválidos.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.ru.xlf b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
index 3570539b1f8..f93ae4dddea 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ru.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
@@ -308,6 +308,12 @@
         <target state="translated">Параметр "{0}" с назначенным значением "{1}" не может иметь недопустимый путь или недопустимые символы файлов.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.tr.xlf b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
index d6831788b90..a630c160819 100644
--- a/src/Shared/Resources/xlf/Strings.shared.tr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
@@ -308,6 +308,12 @@
         <target state="translated">"{1}" değeri atanan "{0}" parametresinde geçersiz yol veya geçersiz dosya karakterleri bulunamaz.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
index b5468e75bcb..44151824d95 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
@@ -308,6 +308,12 @@
         <target state="translated">分配有值“{1}”的参数“{0}”不可具有无效路径或无效的文件字符。</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
index 893e286184a..6ea33bb0148 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
@@ -308,6 +308,12 @@
         <target state="translated">指派值為 "{1}" 的參數 "{0}" 不得具有無效的路徑或檔案字元。</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index bca3773e17a..e83e0c56d1b 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -62,7 +62,7 @@ public void GetFilesPatternMatching(string pattern, int expectedMatchCount)
                 File.WriteAllBytes(Path.Combine(testFolder.Path, file), new byte[1]);
             }
 
-            string[] fileMatches = FileMatcher.Default.GetFiles(testFolder.Path, pattern);
+            string[] fileMatches = FileMatcher.Default.GetFiles(testFolder.Path, pattern).FileList;
 
             fileMatches.Length.ShouldBe(expectedMatchCount, $"Matches: '{String.Join("', '", fileMatches)}'");
         }
@@ -83,7 +83,7 @@ public void GetFilesComplexGlobbingMatching(GetFilesComplexGlobbingMatchingInfo
 
             void VerifyImpl(FileMatcher fileMatcher, string include, string[] excludes, bool shouldHaveNoMatches = false, string customMessage = null)
             {
-                string[] matchedFiles = fileMatcher.GetFiles(testFolder.Path, include, excludes?.ToList());
+                string[] matchedFiles = fileMatcher.GetFiles(testFolder.Path, include, excludes?.ToList()).FileList;
 
                 if (shouldHaveNoMatches)
                 {
@@ -1042,8 +1042,8 @@ public void DotDotForParentDirectory()
                 // On Linux *. * does not pick up files with no extension
                 ValidateFileMatch(Path.Combine("..", "..", "*.*"), Path.Combine("..", "..", "File"), false);
             }
-            ValidateNoFileMatch(Path.Combine("..", "..", "*.*"), Path.Combine(new [] {"..", "..", "dir1", "dir2", "File.txt"}), false);
-            ValidateNoFileMatch(Path.Combine("..", "..", "*.*"), Path.Combine(new [] {"..", "..", "dir1", "dir2", "File"}), false);
+            ValidateNoFileMatch(Path.Combine("..", "..", "*.*"), Path.Combine(new[] { "..", "..", "dir1", "dir2", "File.txt" }), false);
+            ValidateNoFileMatch(Path.Combine("..", "..", "*.*"), Path.Combine(new[] { "..", "..", "dir1", "dir2", "File" }), false);
         }
 
         [Fact]
@@ -1256,7 +1256,7 @@ public void IllegalTooLongPathOptOutWave17_0()
                 BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
 
                 string longString = new string('X', 500) + "*"; // need a wildcard to do anything
-                string[] result = FileMatcher.Default.GetFiles(@"c:\", longString);
+                string[] result = FileMatcher.Default.GetFiles(@"c:\", longString).FileList;
 
                 Assert.Equal(longString, result[0]); // Does not throw
                 ChangeWaves.ResetStateForTests();
@@ -1298,7 +1298,7 @@ public void Regress367780_CrashOnStarDotDot()
             Directory.CreateDirectory(workingPath);
             Directory.CreateDirectory(workingPathSubfolder);
 
-            files = FileMatcher.Default.GetFiles(workingPath, offendingPattern);
+            files = FileMatcher.Default.GetFiles(workingPath, offendingPattern).FileList;
         }
 
         [Fact]
@@ -1310,7 +1310,7 @@ public void Regress141071_StarStarSlashStarStarIsLiteral()
 
             Directory.CreateDirectory(workingPath);
             File.WriteAllText(fileName, "Hello there.");
-            var files = FileMatcher.Default.GetFiles(workingPath, offendingPattern);
+            var files = FileMatcher.Default.GetFiles(workingPath, offendingPattern).FileList;
 
             string result = String.Join(", ", files);
             Console.WriteLine(result);
@@ -1330,7 +1330,7 @@ public void Regress14090_TrailingDotMatchesNoExtension()
             Directory.CreateDirectory(workingPath);
             Directory.CreateDirectory(workingPathSubdir);
             File.AppendAllText(workingPathSubdirBing, "y");
-            var files = FileMatcher.Default.GetFiles(workingPath, offendingPattern);
+            var files = FileMatcher.Default.GetFiles(workingPath, offendingPattern).FileList;
 
             string result = String.Join(", ", files);
             Console.WriteLine(result);
@@ -1353,19 +1353,19 @@ public void FileEnumerationCacheTakesExcludesIntoAccount()
                 {
                     env.SetEnvironmentVariable("MsBuildCacheFileEnumerations", "1");
 
-                    var testProject = env.CreateTestProjectWithFiles(string.Empty, new[] {"a.cs", "b.cs", "c.cs"});
+                    var testProject = env.CreateTestProjectWithFiles(string.Empty, new[] { "a.cs", "b.cs", "c.cs" });
 
-                    var files = FileMatcher.Default.GetFiles(testProject.TestRoot, "**/*.cs");
+                    var files = FileMatcher.Default.GetFiles(testProject.TestRoot, "**/*.cs").FileList;
                     Array.Sort(files);
-                    Assert.Equal(new []{"a.cs", "b.cs", "c.cs"}, files);
+                    Assert.Equal(new[] { "a.cs", "b.cs", "c.cs" }, files);
 
-                    files = FileMatcher.Default.GetFiles(testProject.TestRoot, "**/*.cs", new List<string> {"a.cs"});
+                    files = FileMatcher.Default.GetFiles(testProject.TestRoot, "**/*.cs", new List<string> { "a.cs" }).FileList;
                     Array.Sort(files);
-                    Assert.Equal(new[] {"b.cs", "c.cs" }, files);
+                    Assert.Equal(new[] { "b.cs", "c.cs" }, files);
 
-                    files = FileMatcher.Default.GetFiles(testProject.TestRoot, "**/*.cs", new List<string> {"a.cs", "c.cs"});
+                    files = FileMatcher.Default.GetFiles(testProject.TestRoot, "**/*.cs", new List<string> { "a.cs", "c.cs" }).FileList;
                     Array.Sort(files);
-                    Assert.Equal(new[] {"b.cs" }, files);
+                    Assert.Equal(new[] { "b.cs" }, files);
                 }
             }
             finally
@@ -1374,6 +1374,146 @@ public void FileEnumerationCacheTakesExcludesIntoAccount()
             }
         }
 
+        [PlatformSpecific(TestPlatforms.Any)]
+        [Theory]
+        [InlineData(@"\", "**")]
+        [InlineData(@"\\", "**")]
+        [InlineData(@"\\\\\\\\", "**")]
+        [InlineData("/", "**/*.cs")]
+        [InlineData("/", "**")]
+        [InlineData("//", "**")]
+        [InlineData("////////", "**")]
+        public void DriveEnumeratingWildcardIsObservedOnAnyPlatform(string directoryPart, string wildcardPart) =>
+            DriveEnumeratingWildcardIsObserved(directoryPart, wildcardPart);
+
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(@"\", "**")]
+        [InlineData(@"c:\", "**")]
+        [InlineData(@"c:\\", "**")]
+        [InlineData(@"c:\\\\\\\\", "**")]
+        [InlineData(@"c:\", @"**\*.cs")]
+        public void DriveEnumeratingWildcardIsObservedOnWindows(string directoryPart, string wildcardPart)
+        {
+            DriveEnumeratingWildcardIsObserved(directoryPart, wildcardPart);
+            DriveEnumeratingWildcardFailsAndReturns(directoryPart, wildcardPart);
+        }
+
+        private void DriveEnumeratingWildcardIsObserved(string directoryPart, string wildcardPart) =>
+            FileMatcher.IsDriveEnumeratingWildcardPattern(directoryPart, wildcardPart).ShouldBeTrue();
+
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [Theory]
+        [InlineData(@"\", "**")]
+        [InlineData("/", "**/*.cs")]
+        [InlineData("/", "**")]
+        [InlineData("//", "**")]
+        [InlineData("////////", "**")]
+        public void DriveEnumeratingWildcardFailsAndReturnsOnUnix(string directoryPart, string wildcardPart)
+        {
+            DriveEnumeratingWildcardFailsAndReturns(directoryPart, wildcardPart);
+        }
+
+        private void DriveEnumeratingWildcardFailsAndReturns(string directoryPart, string wildcardPart)
+        {
+            string driveEnumeratingWildcard = string.Concat(directoryPart, wildcardPart);
+
+            using (var env = TestEnvironment.Create())
+            {
+                try
+                {
+                    // Set env var to fail on drive enumerating wildcard detection
+                    Helpers.ResetStateForDriveEnumeratingWildcardTests(env, "1");
+
+                    (string[] fileList, FileMatcher.SearchAction action, string excludeFileSpec) = FileMatcher.Default.GetFiles(
+                        string.Empty,
+                        driveEnumeratingWildcard);
+
+                    action.ShouldBe(FileMatcher.SearchAction.FailOnDriveEnumeratingWildcard);
+                    fileList.ShouldBeEmpty();
+                    excludeFileSpec.ShouldBe(string.Empty);
+
+                    // Handle failing with drive enumerating exclude
+                    (fileList, action, excludeFileSpec) = FileMatcher.Default.GetFiles(
+                        string.Empty,
+                        @"/*/*.cs",
+                        new List<string> { driveEnumeratingWildcard });
+
+                    action.ShouldBe(FileMatcher.SearchAction.FailOnDriveEnumeratingWildcard);
+                    fileList.ShouldBeEmpty();
+                    excludeFileSpec.ShouldBe(driveEnumeratingWildcard);
+                }
+                finally
+                {
+                    ChangeWaves.ResetStateForTests();
+                }
+            }
+        }
+
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(@"z:\**")]
+        [InlineData(@"z:\\**")]
+        [InlineData(@"z:\\\\\\\\**")]
+        [InlineData(@"z:\**\*.cs")]
+        public void DriveEnumeratingWildcardIsLoggedOnWindows(string driveEnumeratingWildcard)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                try
+                {
+                    // Set env var to log on drive enumerating wildcard detection
+                    Helpers.ResetStateForDriveEnumeratingWildcardTests(env, "0");
+
+                    (_, FileMatcher.SearchAction action, string excludeFileSpec) = FileMatcher.Default.GetFiles(
+                        string.Empty,
+                        driveEnumeratingWildcard);
+
+                    action.ShouldBe(FileMatcher.SearchAction.LogDriveEnumeratingWildcard);
+                    excludeFileSpec.ShouldBe(string.Empty);
+
+                    // Handle logging with drive enumerating exclude
+                    (_, action, excludeFileSpec) = FileMatcher.Default.GetFiles(
+                        string.Empty,
+                        @"/*/*.cs",
+                        new List<string> { driveEnumeratingWildcard });
+
+                    action.ShouldBe(FileMatcher.SearchAction.LogDriveEnumeratingWildcard);
+                    excludeFileSpec.ShouldBe(driveEnumeratingWildcard);
+                }
+                finally
+                {
+                    ChangeWaves.ResetStateForTests();
+                }
+            }
+        }
+
+        [PlatformSpecific(TestPlatforms.Any)]
+        [Theory]
+        [InlineData(@"\", @"*\*.cs")]
+        [InlineData(@"\\", @"*\*.cs")]
+        [InlineData(@"\", @"*\*.*")]
+        [InlineData(@"/", @"*/*.cs")]
+        [InlineData(@"//", @"*/*.cs")]
+        [InlineData(@"/", @"*/*.*")]
+        public void DriveEnumeratingWildcardIsNotObservedOnAnyPlatform(string directoryPart, string wildcardPart) =>
+            DriveEnumeratingWildcardIsNotObserved(directoryPart, wildcardPart);
+
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [Theory]
+        [InlineData(@"c:\", "**")]
+        [InlineData(@"c:\\", "**")]
+        [InlineData(@"c:\\\\\\\\", "**")]
+        [InlineData(@"c:\", @"**\*.cs")]
+        public void DriveEnumeratingWildcardIsNotObservedOnUnix(string directoryPart, string wildcardPart)
+        {
+            DriveEnumeratingWildcardIsNotObserved(directoryPart, wildcardPart);
+        }
+
+        private void DriveEnumeratingWildcardIsNotObserved(string directoryPart, string wildcardPart) =>
+            FileMatcher.IsDriveEnumeratingWildcardPattern(directoryPart, wildcardPart).ShouldBeFalse();
+
         [Fact]
         public void RemoveProjectDirectory()
         {
@@ -2383,7 +2523,7 @@ private static void MatchDriver(string filespec, string[] excludeFilespecs, stri
                 String.Empty, /* we don't need project directory as we use mock filesystem */
                 filespec,
                 excludeFilespecs?.ToList()
-            );
+            ).FileList;
 
             Func<string[], string[]> normalizeAllFunc = (paths => normalizeAllPaths ? paths.Select(MockFileSystem.Normalize).ToArray() : paths);
             Func<string[], string[]> normalizeMatching = (paths => normalizeExpectedMatchingFiles ? paths.Select(MockFileSystem.Normalize).ToArray() : paths);
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index d6c10b453e0..d4d5b8e3d1e 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -13,7 +13,9 @@
 using System.Threading.Tasks;
 using System.Xml;
 
+using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Definition;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.FileSystem;
@@ -1403,6 +1405,107 @@ public static BuildResult BuildProjectFileUsingBuildManager(string projectFile,
             }
         }
 
+        internal enum ExpectedBuildResult
+        {
+            // The build should fail with a logged error upon drive enumerationg wildcard detection and setting of environment variable.
+            FailWithError,
+            // The build should succeed with a logged warning upon drive enumerating wildcard detection (regardless of environment variable value).
+            SucceedWithWarning,
+            // The build should succeed with no logged warnings and errors, as there are no drive enumerating wildcards.
+            SucceedWithNoErrorsAndWarnings
+        }
+
+        /// <summary>
+        /// Verify that a drive enumerating wildcard warning is logged or exception is thrown. 
+        /// </summary>
+        internal static void CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(string content, string failOnDriveEnumerationEnvVar, string targetName, ExpectedBuildResult expectedBuildResult, ITestOutputHelper testOutput = null)
+        {
+            using (var env = TestEnvironment.Create(testOutput))
+            {
+                // Clean file contents by replacing single quotes with double quotes, etc.
+                content = ObjectModelHelpers.CleanupFileContents(content);
+                var testProject = env.CreateTestProjectWithFiles(content.Cleanup());
+
+                // Reset state
+                ResetStateForDriveEnumeratingWildcardTests(env, failOnDriveEnumerationEnvVar);
+
+                // Setup and build test target
+                BuildTargetWithDriveEnumeratingWildcardUsingBuildManager(env, testProject.ProjectFile, targetName, expectedBuildResult, testOutput);
+            }
+        }
+
+        internal static void ResetStateForDriveEnumeratingWildcardTests(TestEnvironment env, string setEnvVar)
+        {
+            ChangeWaves.ResetStateForTests();
+            env.SetEnvironmentVariable("MSBUILDFAILONDRIVEENUMERATINGWILDCARD", setEnvVar);
+            BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+        }
+
+        internal static void BuildTargetWithDriveEnumeratingWildcardUsingBuildManager(TestEnvironment env, string testProjectFile, string targetName, ExpectedBuildResult expectedBuildResult, ITestOutputHelper testOutput = null)
+        {
+            try
+            {
+                // Setup build
+                MockLogger mockLogger = (testOutput == null) ? new MockLogger() : new MockLogger(testOutput);
+                var p = ProjectInstance.FromFile(testProjectFile, new ProjectOptions());
+                BuildManager buildManager = BuildManager.DefaultBuildManager;
+                BuildRequestData data = new BuildRequestData(p, new[] { targetName });
+                BuildParameters parameters = new BuildParameters()
+                {
+                    Loggers = new ILogger[] { mockLogger },
+                };
+
+                // Perform build using build manager
+                BuildResult buildResult = buildManager.Build(parameters, data);
+
+                // Verify result based on value of ExpectedBuildResult
+                if (expectedBuildResult == ExpectedBuildResult.FailWithError)
+                {
+                    VerifyErrorLoggedForDriveEnumeratingWildcard(buildResult, mockLogger, targetName);
+                }
+                else if (expectedBuildResult == ExpectedBuildResult.SucceedWithWarning)
+                {
+                    VerifyWarningLoggedForDriveEnumeratingWildcard(buildResult, mockLogger, targetName);
+                }
+                else if (expectedBuildResult == ExpectedBuildResult.SucceedWithNoErrorsAndWarnings)
+                {
+                    VerifyNoErrorsAndWarningsForDriveEnumeratingWildcard(buildResult, mockLogger, targetName);
+                }
+            }
+            finally
+            {
+                ChangeWaves.ResetStateForTests();
+            }
+        }
+
+        private static void VerifyErrorLoggedForDriveEnumeratingWildcard(BuildResult buildResult, MockLogger mockLogger, string targetName)
+        {
+            buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
+            buildResult[targetName].ResultCode.ShouldBe(TargetResultCode.Failure);
+            mockLogger.ErrorCount.ShouldBe(1);
+            mockLogger.Errors[0].Code.ShouldBe("MSB5029");
+        }
+
+        private static void VerifyWarningLoggedForDriveEnumeratingWildcard(BuildResult buildResult, MockLogger mockLogger, string targetName)
+        {
+            VerifySuccessOfBuildAndTargetResults(buildResult, targetName);
+            mockLogger.WarningCount.ShouldBe(1);
+            mockLogger.Warnings[0].Code.ShouldBe("MSB5029");
+        }
+
+        private static void VerifyNoErrorsAndWarningsForDriveEnumeratingWildcard(BuildResult buildResult, MockLogger mockLogger, string targetName)
+        {
+            VerifySuccessOfBuildAndTargetResults(buildResult, targetName);
+            mockLogger.WarningCount.ShouldBe(0);
+            mockLogger.ErrorCount.ShouldBe(0);
+        }
+
+        private static void VerifySuccessOfBuildAndTargetResults(BuildResult buildResult, string targetName)
+        {
+            buildResult.OverallResult.ShouldBe(BuildResultCode.Success);
+            buildResult[targetName].ResultCode.ShouldBe(TargetResultCode.Success);
+        }
+
         /// <summary>
         /// Build a project with the provided content in memory.
         /// Assert that it fails, and return the mock logger with the output.
diff --git a/src/StringTools/InternableString.cs b/src/StringTools/InternableString.cs
index 302d50bfd6c..f04d2a9e931 100644
--- a/src/StringTools/InternableString.cs
+++ b/src/StringTools/InternableString.cs
@@ -96,7 +96,7 @@ public bool MoveNext()
         /// </summary>
         private readonly ReadOnlySpan<char> _inlineSpan;
 
-#if NETSTANDARD
+#if FEATURE_FASTSPAN
         /// <summary>
         /// .NET Core does not keep a reference to the containing object in <see cref="ReadOnlySpan{T}"/>. In particular,
         /// it cannot recover the string if the span represents one. We have to hold the reference separately to be able to
@@ -122,7 +122,7 @@ internal InternableString(ReadOnlySpan<char> span)
             _inlineSpan = span;
             _spans = null;
             Length = span.Length;
-#if NETSTANDARD
+#if FEATURE_FASTSPAN
             _inlineSpanString = null;
 #endif
         }
@@ -141,7 +141,7 @@ internal InternableString(string str)
             _inlineSpan = str.AsSpan();
             _spans = null;
             Length = str.Length;
-#if NETSTANDARD
+#if FEATURE_FASTSPAN
             _inlineSpanString = str;
 #endif
         }
@@ -154,7 +154,7 @@ internal InternableString(SpanBasedStringBuilder stringBuilder)
             _inlineSpan = default(ReadOnlySpan<char>);
             _spans = stringBuilder.Spans;
             Length = stringBuilder.Length;
-#if NETSTANDARD
+#if FEATURE_FASTSPAN
             _inlineSpanString = null;
 #endif
         }
@@ -220,7 +220,7 @@ public unsafe string ExpensiveConvertToString()
             // Special case: if we hold just one string, we can directly return it.
             if (_inlineSpan.Length == Length)
             {
-#if NETSTANDARD
+#if FEATURE_FASTSPAN
                 if (_inlineSpanString != null)
                 {
                     return _inlineSpanString;
diff --git a/src/StringTools/WeakStringCache.Concurrent.cs b/src/StringTools/WeakStringCache.Concurrent.cs
index 6110475e946..3261141fcbf 100644
--- a/src/StringTools/WeakStringCache.Concurrent.cs
+++ b/src/StringTools/WeakStringCache.Concurrent.cs
@@ -32,7 +32,7 @@ public string GetOrCreateEntry(ref InternableString internable, out bool cacheHi
         {
             int hashCode = internable.GetHashCode();
 
-            StringWeakHandle handle;
+            StringWeakHandle? handle;
             string? result;
 
             // Get the existing handle from the cache and lock it while we're dereferencing it to prevent a race with the Scavenge
@@ -98,7 +98,7 @@ public void Scavenge()
             foreach (KeyValuePair<int, StringWeakHandle> entry in _stringsByHashCode)
             {
                 // We can safely dereference entry.Value as the caller guarantees that Scavenge runs only on one thread.
-                if (!entry.Value.IsUsed && _stringsByHashCode.TryRemove(entry.Key, out StringWeakHandle removedHandle))
+                if (!entry.Value.IsUsed && _stringsByHashCode.TryRemove(entry.Key, out StringWeakHandle? removedHandle))
                 {
                     lock (removedHandle)
                     {
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index 9fe18eaef93..beec4a1d226 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -14,7 +14,6 @@
 using SystemProcessorArchitecture = System.Reflection.ProcessorArchitecture;
 using Xunit.Abstractions;
 using Shouldly;
-using System.Text;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/CreateItem_Tests.cs b/src/Tasks.UnitTests/CreateItem_Tests.cs
index 0c422b67892..3092c041e8a 100644
--- a/src/Tasks.UnitTests/CreateItem_Tests.cs
+++ b/src/Tasks.UnitTests/CreateItem_Tests.cs
@@ -3,8 +3,11 @@
 
 using System.IO;
 using System.Collections.Generic;
+using Microsoft.Build.Definition;
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Xunit;
@@ -17,6 +20,16 @@ namespace Microsoft.Build.UnitTests
 {
     sealed public class CreateItem_Tests
     {
+        internal const string CreateItemWithInclude = @"
+            <Project>
+                <Target Name='TestTarget' Returns='@(Text)'>
+                    <CreateItem Include='{0}'>
+                        <Output TaskParameter='Include' ItemName='Text'/>
+                    </CreateItem>
+                </Target>
+            </Project>
+            ";
+
         private readonly ITestOutputHelper _testOutput;
 
         public CreateItem_Tests(ITestOutputHelper output)
@@ -261,8 +274,173 @@ public void AdditionalMetaDataOverwriteExisting()
             Assert.True(success);
             Assert.Equal("SomeOverwriteValue", t.Include[0].GetMetadata("MyMetaData"));
         }
-    }
-}
 
+        /// <summary>
+        /// Logs error when encountering wildcard drive enumeration during task item creation.
+        /// </summary>
+        [Theory]
+        [InlineData(@"/**")]
+        [InlineData(@"/**/*.cs")]
+        [InlineData(@"/**/*/*.cs")]
+        public void WildcardDriveEnumerationTaskItemLogsError(string itemSpec)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                Helpers.ResetStateForDriveEnumeratingWildcardTests(env, "1");
+
+                try
+                {
+                    MockEngine engine = new MockEngine();
+                    CreateItem t = new CreateItem()
+                    {
+                        BuildEngine = engine,
+                        Include = new ITaskItem[] { new TaskItem(itemSpec) },
+                    };
+
+                    t.Execute().ShouldBeFalse();
+                    engine.Errors.ShouldBe(1);
+                    engine.AssertLogContains("MSB5029");
+                }
+                finally
+                {
+                    ChangeWaves.ResetStateForTests();
+                }
+            }
+        }
+
+        /// <summary>
+        /// Logs warning when encountering wildcard drive enumeration during task item creation on Windows platform.
+        /// </summary>
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(@"z:\**")]
+        [InlineData(@"z:\**\*.log")]
+        [InlineData(@"z:\\\\**\*.log")]
+        public void LogWindowsWarningUponCreateItemExecution(string itemSpec)
+        {
+            VerifyDriveEnumerationWarningLoggedUponCreateItemExecution(itemSpec);
+        }
+
+        /// <summary>
+        /// Logs warning when encountering wildcard drive enumeration during task item creation on Unix platform.
+        /// </summary>
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [Theory]
+        [InlineData(@"\**")]
+        [InlineData(@"\**\*.log")]
+        public void LogUnixWarningUponCreateItemExecution(string itemSpec)
+        {
+            VerifyDriveEnumerationWarningLoggedUponCreateItemExecution(itemSpec);
+        }
+
+        private static void VerifyDriveEnumerationWarningLoggedUponCreateItemExecution(string itemSpec)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                Helpers.ResetStateForDriveEnumeratingWildcardTests(env, "0");
+
+                try
+                {
+                    MockEngine engine = new MockEngine();
+                    CreateItem t = new CreateItem()
+                    {
+                        BuildEngine = engine,
+                        Include = new ITaskItem[] { new TaskItem(itemSpec) },
+                    };
+
+                    t.Execute().ShouldBeTrue();
+                    engine.Warnings.ShouldBe(1);
+                    engine.AssertLogContains("MSB5029");
+                }
+                finally
+                {
+                    ChangeWaves.ResetStateForTests();
+                }
+            }
+        }
 
+        /// <summary>
+        /// Throws exception when encountering wildcard drive enumeration during CreateItem task execution.
+        /// </summary>
+        [Theory]
+        [InlineData(
+            CreateItemWithInclude,
+            @"\**")]
+
+        [InlineData(
+            CreateItemWithInclude,
+            @"\**\*.txt")]
+
+        [InlineData(
+            CreateItemWithInclude,
+            @"$(empty)\**\*.cs")]
+        public void ThrowExceptionUponItemCreationWithDriveEnumeration(string content, string include)
+        {
+            content = string.Format(content, include);
+            Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
+                content,
+                "1",
+                "TestTarget",
+                Helpers.ExpectedBuildResult.FailWithError,
+                _testOutput);
+        }
 
+        /// <summary>
+        /// Logs warning when encountering wildcard drive enumeration during CreateItem task execution on Windows platform.
+        /// </summary>
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(
+            CreateItemWithInclude,
+            @"z:\**")]
+
+        [InlineData(
+            CreateItemWithInclude,
+            @"z:\**\*.txt")]
+
+        [InlineData(
+            CreateItemWithInclude,
+            @"z:$(empty)\**\*.cs")]
+        public void LogWindowsWarningUponItemCreationWithDriveEnumeration(string content, string include)
+        {
+            content = string.Format(content, include);
+            Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
+                content,
+                "0",
+                "TestTarget",
+                Helpers.ExpectedBuildResult.SucceedWithWarning,
+                _testOutput);
+        }
+
+        /// <summary>
+        /// Logs warning when encountering wildcard drive enumeration during CreateItem task execution on Unix platform.
+        /// </summary>
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [Theory]
+        [InlineData(
+            CreateItemWithInclude,
+            @"\**")]
+
+        [InlineData(
+            CreateItemWithInclude,
+            @"\**\*.txt")]
+
+        [InlineData(
+            CreateItemWithInclude,
+            @"$(empty)\**\*.cs")]
+        public void LogUnixWarningUponItemCreationWithDriveEnumeration(string content, string include)
+        {
+            content = string.Format(content, include);
+            Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
+                    content,
+                    "0",
+                    "TestTarget",
+                    Helpers.ExpectedBuildResult.SucceedWithWarning,
+                    _testOutput);
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index 9d9813898bc..4bf53a812a9 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -25,7 +25,7 @@
     <ProjectReference Include="..\Tasks\Microsoft.Build.Tasks.csproj" />
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
     <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
-    <ProjectReference Include="..\Samples\PortableTask\PortableTask.csproj" ReferenceOutputAssembly="false" Private="false" SetTargetFramework="TargetFramework=netstandard2.0" />
+    <ProjectReference Include="..\Samples\PortableTask\PortableTask.csproj" ReferenceOutputAssembly="false" Private="false" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index 39469981e66..b8960252b8a 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -17,6 +17,7 @@
 using System.Xml.XPath;
 using System.Xml.Xsl;
 using Microsoft.Build.Shared.FileSystem;
+using System.Runtime.Versioning;
 
 #nullable disable
 
@@ -28,6 +29,7 @@ namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
     [ComVisible(true)]
     [Guid("1D9FE38A-0226-4b95-9C6B-6DFFA2236270")]
     [ClassInterface(ClassInterfaceType.None)]
+    [SupportedOSPlatform("windows")]
     public class BootstrapperBuilder : IBootstrapperBuilder
     {
         private static readonly bool s_logging = !String.IsNullOrEmpty(Environment.GetEnvironmentVariable("VSPLOG"));
@@ -1643,7 +1645,7 @@ private static string GetFileHash(string filePath)
             // the .NET Framework we are targeting.  In ideal situations, bootstrapper files will be
             // pre-signed anwyay; this is a fallback in case we ever encounter a bootstrapper that is
             // not signed.  
-            System.Security.Cryptography.SHA256CryptoServiceProvider sha = new System.Security.Cryptography.SHA256CryptoServiceProvider();
+            System.Security.Cryptography.SHA256 sha = System.Security.Cryptography.SHA256.Create("System.Security.Cryptography.SHA256CryptoServiceProvider");
 
             using (Stream s = fi.OpenRead())
             {
@@ -1906,7 +1908,7 @@ private static XmlElement CreateApplicationElement(XmlElement configElement, Bui
                     XmlElement filesNode = applicationElement.OwnerDocument.CreateElement("Files");
                     XmlElement fileNode = filesNode.OwnerDocument.CreateElement("File");
                     AddAttribute(fileNode, "Name", settings.ApplicationFile);
-                    AddAttribute(fileNode, URLNAME_ATTRIBUTE, Uri.EscapeUriString(settings.ApplicationFile));
+                    AddAttribute(fileNode, URLNAME_ATTRIBUTE, Uri.EscapeDataString(settings.ApplicationFile));
                     filesNode.AppendChild(fileNode);
                     applicationElement.AppendChild(filesNode);
                 }
diff --git a/src/Tasks/BootstrapperUtil/Util.cs b/src/Tasks/BootstrapperUtil/Util.cs
index 0ed5be1dea0..d62c8247070 100644
--- a/src/Tasks/BootstrapperUtil/Util.cs
+++ b/src/Tasks/BootstrapperUtil/Util.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.Globalization;
 using System.IO;
+using System.Runtime.Versioning;
 using Microsoft.Build.Shared;
 using Microsoft.Win32;
 
@@ -75,6 +76,7 @@ public static CultureInfo GetCultureInfoFromString(string cultureName)
 
         public static CultureInfo DefaultCultureInfo => System.Threading.Thread.CurrentThread.CurrentUICulture;
 
+        [SupportedOSPlatform("windows")]
         // This is the 4.0 property and will always point to the Dev10 registry key so that we don't break backwards compatibility.
         // Applications relying on 4.5 will need to use the new method that is introduced in 4.5.
         public static string DefaultPath
@@ -102,6 +104,7 @@ public static string DefaultPath
             }
         }
 
+        [SupportedOSPlatform("windows")]
         // A new method in 4.5 to get the default path for bootstrapper packages.
         // This method is not going to cache the path as it could be different depending on the Visual Studio version.
         public static string GetDefaultPath(string visualStudioVersion)
@@ -153,6 +156,7 @@ public static string GetDefaultPath(string visualStudioVersion)
             return Directory.GetCurrentDirectory();
         }
 
+        [SupportedOSPlatform("windows")]
         // Gets the list of additional paths to inspect for packages as defined in the registry
         public static List<string> AdditionalPackagePaths
         {
@@ -202,6 +206,7 @@ public static List<string> AdditionalPackagePaths
             }
         }
 
+        [SupportedOSPlatform("windows")]
         private static string ReadRegistryString(RegistryKey key, string path, string registryValue)
         {
             RegistryKey subKey = key.OpenSubKey(path, false);
diff --git a/src/Tasks/CreateItem.cs b/src/Tasks/CreateItem.cs
index f386549f525..8f2ef0163ff 100644
--- a/src/Tasks/CreateItem.cs
+++ b/src/Tasks/CreateItem.cs
@@ -61,8 +61,14 @@ public override bool Execute()
             }
 
             // Expand wild cards.
-            Include = ExpandWildcards(Include);
-            Exclude = ExpandWildcards(Exclude);
+            (Include, bool expandedInclude) = TryExpandingWildcards(Include, XMakeAttributes.include);
+            (Exclude, bool expandedExclude) = TryExpandingWildcards(Exclude, XMakeAttributes.exclude);
+
+            // Execution stops if wildcard expansion fails due to drive enumeration and related env var is set.
+            if (!(expandedInclude && expandedExclude))
+            {
+                return false;
+            }
 
             // Simple case:  no additional attribute to add and no Exclude.  In this case the
             // ouptuts are simply the inputs.
@@ -128,14 +134,52 @@ private List<ITaskItem> CreateOutputItems(Dictionary<string, string> metadataTab
             return outputItems;
         }
 
+        /// <summary>
+        /// Attempts to expand wildcards and logs warnings or errors for attempted drive enumeration.
+        /// </summary>
+        private (ITaskItem[] Element, bool NoLoggedErrors) TryExpandingWildcards(ITaskItem[] expand, string attributeType)
+        {
+            const string CreateItemTask = nameof(CreateItem);
+
+            string fileSpec;
+            FileMatcher.SearchAction searchAction;
+
+            (expand, searchAction, fileSpec) = ExpandWildcards(expand);
+
+            // Log potential drive enumeration glob anomalies when applicable.
+            if (searchAction == FileMatcher.SearchAction.LogDriveEnumeratingWildcard)
+            {
+                Log.LogWarningWithCodeFromResources(
+                    "WildcardResultsInDriveEnumeration",
+                    EscapingUtilities.UnescapeAll(fileSpec),
+                    attributeType,
+                    CreateItemTask);
+            }
+            else if (searchAction == FileMatcher.SearchAction.FailOnDriveEnumeratingWildcard)
+            {
+                Log.LogErrorWithCodeFromResources(
+                    "WildcardResultsInDriveEnumeration",
+                    EscapingUtilities.UnescapeAll(fileSpec),
+                    attributeType,
+                    CreateItemTask);
+            }
+
+            return (expand, !Log.HasLoggedErrors);
+        }
+
         /// <summary>
         /// Expand wildcards in the item list.
         /// </summary>
-        private static ITaskItem[] ExpandWildcards(ITaskItem[] expand)
+        private static (ITaskItem[] Element, FileMatcher.SearchAction Action, string FileSpec) ExpandWildcards(ITaskItem[] expand)
         {
+            // Used to detect and log drive enumerating wildcard patterns.
+            string[] files;
+            FileMatcher.SearchAction action = FileMatcher.SearchAction.None;
+            string itemSpec = string.Empty;
+
             if (expand == null)
             {
-                return null;
+                return (null, action, itemSpec);
             }
             else
             {
@@ -144,7 +188,13 @@ private static ITaskItem[] ExpandWildcards(ITaskItem[] expand)
                 {
                     if (FileMatcher.HasWildcards(i.ItemSpec))
                     {
-                        string[] files = FileMatcher.Default.GetFiles(null /* use current directory */, i.ItemSpec);
+                        (files, action, _) = FileMatcher.Default.GetFiles(null /* use current directory */, i.ItemSpec);
+                        itemSpec = i.ItemSpec;
+                        if (action == FileMatcher.SearchAction.FailOnDriveEnumeratingWildcard)
+                        {
+                            return (expanded.ToArray(), action, itemSpec);
+                        }
+
                         foreach (string file in files)
                         {
                             TaskItem newItem = new TaskItem(i) { ItemSpec = file };
@@ -167,7 +217,7 @@ private static ITaskItem[] ExpandWildcards(ITaskItem[] expand)
                         expanded.Add(i);
                     }
                 }
-                return expanded.ToArray();
+                return (expanded.ToArray(), action, itemSpec);
             }
         }
 
diff --git a/src/Tasks/DownloadFile.cs b/src/Tasks/DownloadFile.cs
index c55eedb3974..5192719aa13 100644
--- a/src/Tasks/DownloadFile.cs
+++ b/src/Tasks/DownloadFile.cs
@@ -146,11 +146,17 @@ private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)
                     {
                         response.EnsureSuccessStatusCode();
                     }
+#if NET6_0_OR_GREATER
+                    catch (HttpRequestException)
+                    {
+                        throw;
+#else
                     catch (HttpRequestException e)
                     {
-                        // HttpRequestException does not have the status code so its wrapped and thrown here so that later on we can determine
-                        // if a retry is possible based on the status code
+                        // MSBuild History: CustomHttpRequestException was created as a wrapper over HttpRequestException
+                        // so it could include the StatusCode. As of net5.0, the statuscode is now in HttpRequestException.
                         throw new CustomHttpRequestException(e.Message, e.InnerException, response.StatusCode);
+#endif
                     }
 
                     if (!TryGetFileName(response, out string filename))
@@ -181,7 +187,11 @@ private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)
                         {
                             Log.LogMessageFromResources(MessageImportance.High, "DownloadFile.Downloading", SourceUrl, destinationFile.FullName, response.Content.Headers.ContentLength);
 
-                            using (Stream responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
+                            using (Stream responseStream = await response.Content.ReadAsStreamAsync(
+#if NET6_0_OR_GREATER
+                            cancellationToken
+#endif
+                            ).ConfigureAwait(false))
                             {
                                 await responseStream.CopyToAsync(target, 1024, cancellationToken).ConfigureAwait(false);
                             }
@@ -220,20 +230,34 @@ private static bool IsRetriable(Exception exception, out Exception actualExcepti
             }
 
             // Some HttpRequestException have an inner exception that has the real error
-            if (actualException is HttpRequestException httpRequestException && httpRequestException.InnerException != null)
+            if (actualException is HttpRequestException httpRequestException)
             {
-                actualException = httpRequestException.InnerException;
+                if (httpRequestException.InnerException != null)
+                {
+                    actualException = httpRequestException.InnerException;
 
-                // An IOException inside of a HttpRequestException means that something went wrong while downloading
-                if (actualException is IOException)
+                    // An IOException inside of a HttpRequestException means that something went wrong while downloading
+                    if (actualException is IOException)
+                    {
+                        return true;
+                    }
+                }
+
+#if NET6_0_OR_GREATER
+                // net5.0 included StatusCode in the HttpRequestException.
+                switch (httpRequestException.StatusCode)
                 {
-                    return true;
+                    case HttpStatusCode.InternalServerError:
+                    case HttpStatusCode.RequestTimeout:
+                        return true;
                 }
             }
+#else
+            }
 
+            // framework workaround for HttpRequestException not containing StatusCode
             if (actualException is CustomHttpRequestException customHttpRequestException)
             {
-                // A wrapped CustomHttpRequestException has the status code from the error
                 switch (customHttpRequestException.StatusCode)
                 {
                     case HttpStatusCode.InternalServerError:
@@ -241,6 +265,7 @@ private static bool IsRetriable(Exception exception, out Exception actualExcepti
                         return true;
                 }
             }
+#endif
 
             if (actualException is WebException webException)
             {
@@ -287,8 +312,10 @@ private bool TryGetFileName(HttpResponseMessage response, out string filename)
             return !String.IsNullOrWhiteSpace(filename);
         }
 
+#if !NET6_0_OR_GREATER
         /// <summary>
         /// Represents a wrapper around the <see cref="HttpRequestException"/> that also contains the <see cref="HttpStatusCode"/>.
+        /// DEPRECATED as of net5.0, which included the StatusCode in the HttpRequestException class.
         /// </summary>
         private sealed class CustomHttpRequestException : HttpRequestException
         {
@@ -300,6 +327,7 @@ public CustomHttpRequestException(string message, Exception inner, HttpStatusCod
 
             public HttpStatusCode StatusCode { get; }
         }
+#endif
 
         private bool ShouldSkip(HttpResponseMessage response, FileInfo destinationFile)
         {
diff --git a/src/Tasks/FormatUrl.cs b/src/Tasks/FormatUrl.cs
index f742f4d238b..4b600c49ef9 100644
--- a/src/Tasks/FormatUrl.cs
+++ b/src/Tasks/FormatUrl.cs
@@ -1,9 +1,11 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if !RUNTIME_TYPE_NETCORE
 using System;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
+#endif
+using Microsoft.Build.Framework;
 
 #nullable disable
 
diff --git a/src/Tasks/GenerateApplicationManifest.cs b/src/Tasks/GenerateApplicationManifest.cs
index bece4016d94..a6361b25472 100644
--- a/src/Tasks/GenerateApplicationManifest.cs
+++ b/src/Tasks/GenerateApplicationManifest.cs
@@ -5,6 +5,7 @@
 using System.Diagnostics;
 using System.Globalization;
 using System.IO;
+using System.Runtime.Versioning;
 using System.Xml;
 
 using Microsoft.Build.Framework;
@@ -17,6 +18,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Generates an application manifest for ClickOnce projects.
     /// </summary>
+    [SupportedOSPlatform("windows")]
     public sealed class GenerateApplicationManifest : GenerateManifestBase
     {
         private enum _ManifestType
@@ -108,6 +110,16 @@ public bool UseApplicationTrust
             set => _useApplicationTrust = value;
         }
 
+        public override bool Execute()
+        {
+            if (!NativeMethodsShared.IsWindows)
+            {
+                Log.LogErrorWithCodeFromResources("General.TaskRequiresWindows", nameof(GenerateApplicationManifest));
+                return false;
+            }
+            return base.Execute();
+        }
+
         protected override Type GetObjectType()
         {
             return typeof(ApplicationManifest);
diff --git a/src/Tasks/GenerateDeploymentManifest.cs b/src/Tasks/GenerateDeploymentManifest.cs
index d4ff40421a4..6867f27717b 100644
--- a/src/Tasks/GenerateDeploymentManifest.cs
+++ b/src/Tasks/GenerateDeploymentManifest.cs
@@ -5,6 +5,7 @@
 using System.Diagnostics;
 using System.IO;
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
+using System.Runtime.Versioning;
 
 #nullable disable
 
@@ -13,6 +14,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Generates a deploy manifest for ClickOnce projects.
     /// </summary>
+    [SupportedOSPlatform("windows")]
     public sealed class GenerateDeploymentManifest : GenerateManifestBase
     {
         private bool? _createDesktopShortcut;
@@ -142,6 +144,7 @@ private bool BuildResolvedSettings(DeployManifest manifest)
             else if (String.IsNullOrEmpty(manifest.Publisher))
             {
                 string org = Util.GetRegisteredOrganization();
+
                 manifest.Publisher = !String.IsNullOrEmpty(org) ? org : manifest.Product;
             }
             Debug.Assert(!String.IsNullOrEmpty(manifest.Publisher));
@@ -149,6 +152,16 @@ private bool BuildResolvedSettings(DeployManifest manifest)
             return true;
         }
 
+        public override bool Execute()
+        {
+            if (!NativeMethodsShared.IsWindows)
+            {
+                Log.LogErrorWithCodeFromResources("General.TaskRequiresWindows", nameof(GenerateDeploymentManifest));
+                return false;
+            }
+            return base.Execute();
+        }
+
         protected override Type GetObjectType()
         {
             return typeof(DeployManifest);
diff --git a/src/Tasks/GenerateLauncher.cs b/src/Tasks/GenerateLauncher.cs
index 6bedd918410..683736168cc 100644
--- a/src/Tasks/GenerateLauncher.cs
+++ b/src/Tasks/GenerateLauncher.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.IO;
+using System.Runtime.Versioning;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks.Deployment.Bootstrapper;
@@ -16,6 +17,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Generates a bootstrapper for ClickOnce deployment projects.
     /// </summary>
+    [SupportedOSPlatform("windows")]
     public sealed class GenerateLauncher : TaskExtension
     {
         private const string LAUNCHER_EXE = "Launcher.exe";
@@ -39,6 +41,12 @@ public sealed class GenerateLauncher : TaskExtension
 
         public override bool Execute()
         {
+            if (!NativeMethodsShared.IsWindows)
+            {
+                Log.LogErrorWithCodeFromResources("General.TaskRequiresWindows", nameof(GenerateLauncher));
+                return false;
+            }
+
             if (LauncherPath == null)
             {
                 // Launcher lives next to ClickOnce bootstrapper.
@@ -57,17 +65,17 @@ public override bool Execute()
 
             var launcherBuilder = new LauncherBuilder(LauncherPath);
             string entryPointFileName = Path.GetFileName(EntryPoint.ItemSpec);
-            //
+
             // If the EntryPoint specified is apphost.exe or singlefilehost.exe, we need to replace the EntryPoint
             // with the AssemblyName instead since apphost.exe/singlefilehost.exe is an intermediate file for
             // for final published {assemblyname}.exe.
-            //
             if ((entryPointFileName.Equals(Constants.AppHostExe, StringComparison.InvariantCultureIgnoreCase) || 
                 entryPointFileName.Equals(Constants.SingleFileHostExe, StringComparison.InvariantCultureIgnoreCase)) &&
-                !String.IsNullOrEmpty(AssemblyName))
+                !string.IsNullOrEmpty(AssemblyName))
             {
                 entryPointFileName = AssemblyName;
             }
+
             BuildResults results = launcherBuilder.Build(entryPointFileName, OutputPath);
 
             BuildMessage[] messages = results.Messages;
diff --git a/src/Tasks/GenerateManifestBase.cs b/src/Tasks/GenerateManifestBase.cs
index 65ea58c62b0..ef8aed08163 100644
--- a/src/Tasks/GenerateManifestBase.cs
+++ b/src/Tasks/GenerateManifestBase.cs
@@ -272,6 +272,12 @@ private AssemblyIdentity CreateAssemblyIdentity(AssemblyIdentity baseIdentity, A
 
         public override bool Execute()
         {
+            if (!NativeMethodsShared.IsWindows)
+            {
+                Log.LogErrorWithCodeFromResources("General.TaskRequiresWindows", nameof(GenerateManifestBase));
+                return false;
+            }
+
             bool success = true;
 
             Type manifestType = GetObjectType();
diff --git a/src/Tasks/ManifestUtil/ComImporter.cs b/src/Tasks/ManifestUtil/ComImporter.cs
index 86e28d204d0..96a941a43e0 100644
--- a/src/Tasks/ManifestUtil/ComImporter.cs
+++ b/src/Tasks/ManifestUtil/ComImporter.cs
@@ -10,11 +10,13 @@
 #if RUNTIME_TYPE_NETCORE
 using System.Runtime.InteropServices.ComTypes;
 #endif
+using System.Runtime.Versioning;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
 {
+    [SupportedOSPlatform("windows")]
     internal class ComImporter
     {
         private readonly OutputMessageCollection _outputMessages;
diff --git a/src/Tasks/ManifestUtil/FileReference.cs b/src/Tasks/ManifestUtil/FileReference.cs
index e2e0f6b75d8..e13dad0af4f 100644
--- a/src/Tasks/ManifestUtil/FileReference.cs
+++ b/src/Tasks/ManifestUtil/FileReference.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.ComponentModel;
 using System.Runtime.InteropServices;
+using System.Runtime.Versioning;
 using System.Text;
 using System.Xml.Serialization;
 
@@ -44,6 +45,7 @@ public FileReference(string path) : base(path)
         [XmlIgnore]
         public ComClass[] ComClasses => _comClasses;
 
+        [SupportedOSPlatform("windows")]
         internal bool ImportComComponent(string path, OutputMessageCollection outputMessages, string outputDisplayName)
         {
             var importer = new ComImporter(path, outputMessages, outputDisplayName);
@@ -103,7 +105,7 @@ public bool IsDataFile
         [XmlIgnore]
         public TypeLib[] TypeLibs => _typeLibs;
 
-        #region " XmlSerializer "
+#region " XmlSerializer "
 
         [Browsable(false)]
         [EditorBrowsable(EditorBrowsableState.Never)]
@@ -141,7 +143,7 @@ public string XmlWriteableType
             set => _writeableType = value;
         }
 
-        #endregion
+#endregion
     }
 
     [ComVisible(false)]
@@ -181,7 +183,7 @@ internal ComClass(Guid tlbId, Guid clsId, string progId, string threadingModel,
         [XmlIgnore]
         public string TlbId => _tlbid;
 
-        #region " XmlSerializer "
+#region " XmlSerializer "
 
         [Browsable(false)]
         [EditorBrowsable(EditorBrowsableState.Never)]
@@ -228,7 +230,7 @@ public string XmlTlbId
             set => _tlbid = value;
         }
 
-        #endregion
+#endregion
     }
 
     [ComVisible(false)]
@@ -293,7 +295,7 @@ private static string FlagsFromInt(int flags)
         [XmlIgnore]
         public string Version => _version;
 
-        #region " XmlSerializer "
+#region " XmlSerializer "
 
         [Browsable(false)]
         [EditorBrowsable(EditorBrowsableState.Never)]
@@ -340,7 +342,7 @@ public string XmlVersion
             set => _version = value;
         }
 
-        #endregion
+#endregion
     }
 
     [ComVisible(false)]
@@ -380,7 +382,7 @@ public bool Versioned
             }
         }
 
-        #region " XmlSerializer "
+#region " XmlSerializer "
 
         [Browsable(false)]
         [EditorBrowsable(EditorBrowsableState.Never)]
@@ -400,7 +402,7 @@ public string XmlVersioned
             set => _versioned = value;
         }
 
-        #endregion
+#endregion
     }
 
     [ComVisible(false)]
@@ -427,7 +429,7 @@ public class ProxyStub
         [XmlIgnore]
         public string TlbId => _tlbid;
 
-        #region " XmlSerializer "
+#region " XmlSerializer "
 
         [Browsable(false)]
         [EditorBrowsable(EditorBrowsableState.Never)]
@@ -474,6 +476,6 @@ public string XmlTlbId
             set => _tlbid = value;
         }
 
-        #endregion
+#endregion
     }
 }
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index 54a9221d899..986370caf84 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -1,9 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#if !RUNTIME_TYPE_NETCORE
 using Microsoft.Build.Framework;
-#endif
 using Microsoft.Build.Utilities;
 using Microsoft.Win32;
 using System;
@@ -22,6 +20,7 @@
 using System.Reflection;
 #endif
 using System.Runtime.InteropServices;
+using System.Runtime.Versioning;
 using System.Security;
 using System.Security.Cryptography;
 using System.Security.Cryptography.X509Certificates;
@@ -32,9 +31,6 @@
 using System.Text;
 using System.Xml;
 using Microsoft.Build.Shared.FileSystem;
-#if !RUNTIME_TYPE_NETCORE
-using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
-#endif
 
 #nullable disable
 
@@ -143,15 +139,15 @@ private static PermissionSet GetNamedPermissionSetFromZone(string targetZone, st
 
         private static PermissionSet GetNamedPermissionSet(string targetZone, string targetFrameworkMoniker)
         {
-            FrameworkNameVersioning fn;
+            FrameworkName fn;
 
             if (!string.IsNullOrEmpty(targetFrameworkMoniker))
             {
-                fn = new FrameworkNameVersioning(targetFrameworkMoniker);
+                fn = new FrameworkName(targetFrameworkMoniker);
             }
             else
             {
-                fn = new FrameworkNameVersioning(".NETFramework", s_dotNet40Version);
+                fn = new FrameworkName(".NETFramework", s_dotNet40Version);
             }
 
             int majorVersion = fn.Version.Major;
@@ -170,7 +166,7 @@ private static PermissionSet GetNamedPermissionSet(string targetZone, string tar
             }
         }
 
-        private static XmlElement GetXmlElement(string targetZone, FrameworkNameVersioning fn)
+        private static XmlElement GetXmlElement(string targetZone, FrameworkName fn)
         {
             IList<string> paths = ToolLocationHelper.GetPathToReferenceAssemblies(fn);
 
@@ -495,6 +491,7 @@ public static PermissionSet XmlToPermissionSet(XmlElement element)
         /// <param name="certThumbprint">Hexadecimal string that contains the SHA-1 hash of the certificate.</param>
         /// <param name="timestampUrl">URL that specifies an address of a time stamping server.</param>
         /// <param name="path">Path of the file to sign with the certificate.</param>
+        [SupportedOSPlatform("windows")]
         public static void SignFile(string certThumbprint, Uri timestampUrl, string path)
         {
             SignFile(certThumbprint, timestampUrl, path, null, null);
@@ -507,6 +504,7 @@ public static void SignFile(string certThumbprint, Uri timestampUrl, string path
         /// <param name="timestampUrl">URL that specifies an address of a time stamping server.</param>
         /// <param name="path">Path of the file to sign with the certificate.</param>
         /// <param name="targetFrameworkVersion">Version of the .NET Framework for the target.</param>
+        [SupportedOSPlatform("windows")]
         public static void SignFile(string certThumbprint,
                                     Uri timestampUrl,
                                     string path,
@@ -523,6 +521,7 @@ public static void SignFile(string certThumbprint,
         /// <param name="path">Path of the file to sign with the certificate.</param>
         /// <param name="targetFrameworkVersion">Version of the .NET Framework for the target.</param>
         /// <param name="targetFrameworkIdentifier">.NET Framework identifier for the target.</param>
+        [SupportedOSPlatform("windows")]
         public static void SignFile(string certThumbprint,
                                     Uri timestampUrl,
                                     string path,
@@ -541,6 +540,7 @@ public static void SignFile(string certThumbprint,
         /// <param name="targetFrameworkVersion">Version of the .NET Framework for the target.</param>
         /// <param name="targetFrameworkIdentifier">.NET Framework identifier for the target.</param>
         /// <param name="disallowMansignTimestampFallback">Disallow fallback to legacy timestamping when RFC3161 timestamping fails during manifest signing</param>
+        [SupportedOSPlatform("windows")]
         public static void SignFile(string certThumbprint,
                                     Uri timestampUrl,
                                     string path,
@@ -599,6 +599,7 @@ public static void SignFile(string certThumbprint,
         /// <param name="timestampUrl">URL that specifies an address of a time stamping server.</param>
         /// <param name="path">Path of the file to sign with the certificate.</param>
         /// <remarks>This function is only for signing a manifest, not a PE file.</remarks>
+        [SupportedOSPlatform("windows")]
         public static void SignFile(string certPath, SecureString certPassword, Uri timestampUrl, string path)
         {
             X509Certificate2 cert = new X509Certificate2(certPath, certPassword, X509KeyStorageFlags.PersistKeySet);
@@ -623,6 +624,7 @@ private static bool UseSha256Algorithm(X509Certificate2 cert)
         /// <param name="path">Path of the file to sign with the certificate.</param>
         /// <remarks>This function can only sign a PE file if the X509Certificate2 parameter represents a certificate in the
         /// current user's personal certificate store.</remarks>
+        [SupportedOSPlatform("windows")]
         public static void SignFile(X509Certificate2 cert, Uri timestampUrl, string path)
         {
             // setup resources
@@ -630,6 +632,7 @@ public static void SignFile(X509Certificate2 cert, Uri timestampUrl, string path
             SignFileInternal(cert, timestampUrl, path, true, resources);
         }
 
+        [SupportedOSPlatform("windows")]
         private static void SignFileInternal(X509Certificate2 cert,
                                             Uri timestampUrl,
                                             string path,
@@ -839,7 +842,7 @@ internal static string GetPathToTool(System.Resources.ResourceManager resources)
                     toolPath = Path.Combine(pathToDotNetFrameworkSdk, "bin", ToolName);
                 }
             }
-            if (toolPath == null || !FileSystems.Default.FileExists(toolPath))
+            if (NativeMethodsShared.IsWindows && (toolPath == null || !FileSystems.Default.FileExists(toolPath)))
             {
                 toolPath = GetVersionIndependentToolPath(ToolName);
             }
@@ -893,6 +896,7 @@ private static bool IsCertInStore(X509Certificate2 cert)
             return false;
         }
 
+        [SupportedOSPlatform("windows")]
         private static string GetVersionIndependentToolPath(string toolName)
         {
             const string versionIndependentToolKeyName = @"Software\Microsoft\ClickOnce\SignTool";
diff --git a/src/Tasks/ManifestUtil/Util.cs b/src/Tasks/ManifestUtil/Util.cs
index 4f098df2091..56ba265c495 100644
--- a/src/Tasks/ManifestUtil/Util.cs
+++ b/src/Tasks/ManifestUtil/Util.cs
@@ -13,6 +13,7 @@
 using System.IO;
 using System.Linq;
 using System.Reflection;
+using System.Runtime.Versioning;
 using System.Security;
 using System.Security.Cryptography;
 using System.Text;
@@ -226,11 +227,11 @@ private static void GetFileInfoImpl(string path, string targetFrameWorkVersion,
 
                 if (string.IsNullOrEmpty(targetFrameWorkVersion) || CompareFrameworkVersions(targetFrameWorkVersion, Constants.TargetFrameworkVersion40) <= 0)
                 {
-                    hashAlg = new SHA1CryptoServiceProvider();
+                    hashAlg = SHA1.Create("System.Security.Cryptography.SHA1CryptoServiceProvider");
                 }
                 else
                 {
-                    hashAlg = new SHA256CryptoServiceProvider();
+                    hashAlg = SHA256.Create("System.Security.Cryptography.SHA256CryptoServiceProvider");
                 }
                 byte[] hashBytes = hashAlg.ComputeHash(s);
                 hash = Convert.ToBase64String(hashBytes);
@@ -250,6 +251,7 @@ private static string GetLogPath()
             return logPath;
         }
 
+        [SupportedOSPlatform("windows")]
         public static string GetRegisteredOrganization()
         {
             RegistryKey key = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", false);
@@ -515,7 +517,7 @@ public static string WriteTempFile(string s)
             return path;
         }
 
-        #region ItemComparer 
+#region ItemComparer 
         private static readonly ItemComparer s_itemComparer = new ItemComparer();
         private class ItemComparer : IComparer
         {
@@ -541,7 +543,7 @@ int IComparer.Compare(object obj1, object obj2)
                 return String.Compare(item1.ItemSpec, item2.ItemSpec, StringComparison.Ordinal);
             }
         }
-        #endregion
+#endregion
 
         public static Version ConvertFrameworkVersionToString(string version)
         {
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index d94b4f12a9a..8d0d9fbf267 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -12,6 +12,7 @@
 using System.Text;
 using System.Xml;
 using System.Runtime.InteropServices;
+using System.Runtime.Versioning;
 
 using _FILETIME = System.Runtime.InteropServices.ComTypes.FILETIME;
 
@@ -273,7 +274,7 @@ private void init()
                                Sha256SignatureMethodUri);
 
 #if RUNTIME_TYPE_NETCORE
-            CryptoConfig.AddAlgorithm(typeof(SHA256Managed),
+            CryptoConfig.AddAlgorithm(typeof(SHA256),
                                Sha256DigestMethod);
 #else
             CryptoConfig.AddAlgorithm(typeof(System.Security.Cryptography.SHA256Cng),
@@ -294,6 +295,7 @@ public override XmlElement GetIdElement(XmlDocument document, string idValue)
         }
     }
 
+    [SupportedOSPlatform("windows")]
     internal class SignedCmiManifest2
     {
         private XmlDocument _manifestDom = null;
@@ -553,7 +555,7 @@ private static byte[] ComputeHashFromManifest(XmlDocument manifestDom, bool oldF
 
                 if (useSha256)
                 {
-                    using (SHA256CryptoServiceProvider sha2 = new SHA256CryptoServiceProvider())
+                    using (SHA256 sha2 = SHA256.Create("System.Security.Cryptography.SHA256CryptoServiceProvider"))
                     {
                         byte[] hash = sha2.ComputeHash(exc.GetOutput() as MemoryStream);
                         if (hash == null)
@@ -566,7 +568,7 @@ private static byte[] ComputeHashFromManifest(XmlDocument manifestDom, bool oldF
                 }
                 else
                 {
-                    using (SHA1CryptoServiceProvider sha1 = new SHA1CryptoServiceProvider())
+                    using (SHA1 sha1 = SHA1.Create("System.Security.Cryptography.SHA1CryptoServiceProvider"))
                     {
                         byte[] hash = sha1.ComputeHash(exc.GetOutput() as MemoryStream);
                         if (hash == null)
@@ -601,7 +603,7 @@ private static byte[] ComputeHashFromManifest(XmlDocument manifestDom, bool oldF
 
                 if (useSha256)
                 {
-                    using (SHA256CryptoServiceProvider sha2 = new SHA256CryptoServiceProvider())
+                    using (SHA256 sha2 = SHA256.Create("System.Security.Cryptography.SHA256CryptoServiceProvider"))
                     {
                         byte[] hash = sha2.ComputeHash(exc.GetOutput() as MemoryStream);
                         if (hash == null)
@@ -614,7 +616,7 @@ private static byte[] ComputeHashFromManifest(XmlDocument manifestDom, bool oldF
                 }
                 else
                 {
-                    using (SHA1CryptoServiceProvider sha1 = new SHA1CryptoServiceProvider())
+                    using (SHA1 sha1 = SHA1.Create("System.Security.Cryptography.SHA1CryptoServiceProvider"))
                     {
                         byte[] hash = sha1.ComputeHash(exc.GetOutput() as MemoryStream);
                         if (hash == null)
@@ -1206,6 +1208,7 @@ internal AsymmetricAlgorithm PublicKey
         }
     }
 
+    [SupportedOSPlatform("windows")]
     internal class CmiAuthenticodeSignerInfo
     {
         private int _error = 0;
@@ -1332,6 +1335,7 @@ internal X509Chain SignerChain
         }
     }
 
+    [SupportedOSPlatform("windows")]
     internal class CmiAuthenticodeTimestamperInfo
     {
         private int _error = 0;
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 29e5289bca5..96ff4e3a91b 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -191,6 +191,12 @@
     <Compile Include="..\Shared\LanguageParser\VisualBasictokenizer.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Shared\XMakeAttributes.cs">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
+    <Compile Include="..\Shared\XMakeElements.cs">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="AppConfig\*.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -956,8 +962,10 @@
     <Reference Include="System.Xaml" />
   </ItemGroup>
   <ItemGroup>
-    <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
-    <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
+    <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" SetTargetFramework="TargetFramework=netstandard2.0" OutputItemType="NetstandardRefAssemblies" />
+    <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" SetTargetFramework="TargetFramework=netstandard2.0" OutputItemType="NetstandardRefAssemblies" />
+    <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj"/>
+    <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj"/>
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
   </ItemGroup>
   <ItemGroup>
@@ -967,6 +975,15 @@
     <PackageReference Include="System.Resources.Extensions" />
   </ItemGroup>
 
+  <!-- Mimics AddRefAssemblies from MSBuild.csproj -->
+  <Target Name="AddRefAssemblies" 
+          DependsOnTargets="ResolveAssemblyReferences"
+          BeforeTargets="AssignTargetPaths">
+    <ItemGroup>
+      <Content Include="@(NetstandardRefAssemblies)" CopyToOutputDirectory="PreserveNewest" Link="ref\%(Filename)%(Extension)"/>
+    </ItemGroup>
+  </Target>
+
   <!-- Tasks need to mimic redistributing the compilers, so add references to both full framework and .net core -->
   <ItemGroup>
     <!-- Reference this package to get binaries at runtime even when Arcade is not adding compiler references -->
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index 54b21a7a904..42368e48d88 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -3,9 +3,12 @@
 
 using System;
 using System.IO;
+using System.Runtime.InteropServices;
+using Microsoft.Build.Shared.FileSystem;
+
+#if FEATURE_COM_INTEROP
 using System.Text;
 using System.Reflection;
-using System.Runtime.InteropServices;
 using Microsoft.Build.Shared;
 using System.Collections.Generic;
 using System.Collections;
@@ -13,7 +16,7 @@
 using System.Linq;
 using System.Runtime.ExceptionServices;
 using System.Text.RegularExpressions;
-using Microsoft.Build.Shared.FileSystem;
+#endif
 
 #nullable disable
 
@@ -522,7 +525,7 @@ internal enum SymbolicLink
     /// </summary>
     internal static class NativeMethods
     {
-        #region Constants
+#region Constants
 
         internal static readonly IntPtr NullPtr = IntPtr.Zero;
         internal static readonly IntPtr InvalidIntPtr = new IntPtr(-1);
@@ -627,9 +630,9 @@ internal enum MoveFileFlags
             MOVEFILE_FAIL_IF_NOT_TRACKABLE = 0x00000020
         }
 
-        #endregion
+#endregion
 
-        #region NT header stuff
+#region NT header stuff
 
         internal const uint IMAGE_NT_OPTIONAL_HDR32_MAGIC = 0x10b;
         internal const uint IMAGE_NT_OPTIONAL_HDR64_MAGIC = 0x20b;
@@ -780,9 +783,9 @@ internal struct CRYPTOAPI_BLOB
             internal IntPtr pbData;
         }
 
-        #endregion
+#endregion
 
-        #region PInvoke
+#region PInvoke
         private const string Crypt32DLL = "crypt32.dll";
         private const string Advapi32DLL = "advapi32.dll";
 #if !RUNTIME_TYPE_NETCORE
diff --git a/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
index 78e394ce7bc..5f9ec5dc2a5 100644
--- a/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
+++ b/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
@@ -1,3 +1,5 @@
 Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.get -> bool
 Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.set -> void
+override Microsoft.Build.Tasks.GenerateApplicationManifest.Execute() -> bool
+override Microsoft.Build.Tasks.GenerateDeploymentManifest.Execute() -> bool
 static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier, bool disallowMansignTimestampFallback) -> void
diff --git a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index 78e394ce7bc..5f9ec5dc2a5 100644
--- a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -1,3 +1,5 @@
 Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.get -> bool
 Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.set -> void
+override Microsoft.Build.Tasks.GenerateApplicationManifest.Execute() -> bool
+override Microsoft.Build.Tasks.GenerateDeploymentManifest.Execute() -> bool
 static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier, bool disallowMansignTimestampFallback) -> void
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index 07b5097294d..d0dd9311e15 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -571,6 +571,10 @@
     <value>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</value>
     <comment>{StrBegin="MSB3094: "}</comment>
   </data>
+  <data name="General.TaskRequiresWindows">
+    <value>MSB3096: Task "{0}" is only supported when building on Windows.</value>
+    <comment>{StrBegin="MSB3096: "}</comment>
+  </data>
   <!--
         The GenerateBindingRedirects message bucket is: MSB3831 - MSB3840
 
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 6d8a68b4bb2..632d5d42323 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -514,6 +514,11 @@
         <target state="translated">MSB3667: V {0} už nějaký soubor existuje. Pokud se pokoušíte vytvořit předvypočítanou mezipaměť, ujistěte se, že sestavujete jeden projekt, který závisí na sestaveních, nikoli sestavení samotná. Pokud spouštíte úlohu ResolveAssemblyReference běžným způsobem, nenastavujte v úloze ResolveAssemblyReference parametr AssemblyInformationCacheOutputPath.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
+      <trans-unit id="General.TaskRequiresWindows">
+        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
+        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <note>{StrBegin="MSB3096: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Odstraňování vlastností:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 2b9789a8096..81c057f5e8e 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -514,6 +514,11 @@
         <target state="translated">MSB3667: Unter "{0}" ist bereits eine Datei vorhanden. Wenn Sie einen vorab berechneten Cache erstellen möchten, stellen Sie sicher, dass Sie ein einzelnes Projekt erstellen, das von Ihren Assemblys abhängt, statt Ihre Assemblys selbst zu erstellen. Wenn Sie die Aufgabe "ResolveAssemblyReference" normal ausführen, legen Sie den Parameter "AssemblyInformationCacheOutputPath" der Aufgabe "ResolveAssemblyReference" nicht fest.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
+      <trans-unit id="General.TaskRequiresWindows">
+        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
+        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <note>{StrBegin="MSB3096: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Eigenschaften werden entfernt:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 614f167e8d3..e270e6039eb 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -514,6 +514,11 @@
         <target state="translated">MSB3667: Ya hay un archivo en "{0}". Si está intentando crear una memoria caché precalculada, asegúrese de estar compilando un solo proyecto que dependa de sus ensamblados, en lugar de compilar los ensamblados en sí. Si está ejecutando la tarea ResolveAssemblyReference normalmente, no establezca el parámetro "AssemblyInformationCacheOutputPath" de la tarea ResolveAssemblyReference.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
+      <trans-unit id="General.TaskRequiresWindows">
+        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
+        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <note>{StrBegin="MSB3096: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Quitando propiedades:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index fd0b120daf9..401d40dffdb 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -514,6 +514,11 @@
         <target state="translated">MSB3667: il existe déjà un fichier sur "{0}". Si vous essayez de créer un cache précalculé, vérifiez que vous générez un seul projet qui dépend de vos assemblys au lieu de générer les assemblys eux-mêmes. Si vous exécutez la tâche ResolveAssemblyReference normalement, ne définissez pas le paramètre "AssemblyInformationCacheOutputPath" de la tâche ResolveAssemblyReference.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
+      <trans-unit id="General.TaskRequiresWindows">
+        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
+        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <note>{StrBegin="MSB3096: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Suppression des propriétés :</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index a1eecfebd2f..40a44c86be9 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -514,6 +514,11 @@
         <target state="translated">MSB3667: alla posizione "{0}" esiste già un file. Se si prova a creare una cache precalcolata, assicurarsi di compilare un singolo progetto che dipende dagli assembly invece di compilare gli assembly stessi. Se si esegue normalmente l'attività ResolveAssemblyReference, non impostare il parametro "AssemblyInformationCacheOutputPath" dell'attività ResolveAssemblyReference.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
+      <trans-unit id="General.TaskRequiresWindows">
+        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
+        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <note>{StrBegin="MSB3096: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Rimozione proprietà:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index f8741ff1fec..2fa257164bb 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -514,6 +514,11 @@
         <target state="translated">MSB3667: "{0}" には既にファイルが存在します。事前計算済みキャッシュを作成しようとしている場合は、アセンブリ自体をビルドするのではなく、アセンブリに依存する単一のプロジェクトをビルドしてください。ResolveAssemblyReference タスクを正常に実行している場合は、ResolveAssemblyReference タスクの "AssemblyInformationCacheOutputPath" パラメーターを設定しないでください。</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
+      <trans-unit id="General.TaskRequiresWindows">
+        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
+        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <note>{StrBegin="MSB3096: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">プロパティの削除:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index c8f09c65f9f..ee1ea74d0d1 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -514,6 +514,11 @@
         <target state="translated">MSB3667: "{0}"에 파일이 이미 있습니다. 사전 계산 캐시를 만들려면 어셈블리 자체를 빌드하는 대신 어셈블리에 종속되는 단일 프로젝트를 빌드하고 있는지 확인하세요. ResolveAssemblyReference 작업을 정상적으로 실행 중인 경우 ResolveAssemblyReference 작업의 "AssemblyInformationCacheOutputPath" 매개 변수를 설정하지 마세요.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
+      <trans-unit id="General.TaskRequiresWindows">
+        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
+        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <note>{StrBegin="MSB3096: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">속성 제거:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 01c5946d62b..bb801b70a60 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -514,6 +514,11 @@
         <target state="translated">MSB3667: W lokalizacji „{0}” już istnieje plik. Jeśli próbujesz utworzyć wstępnie obliczoną pamięć podręczną, upewnij się, że kompilujesz pojedynczy projekt zależący od zestawów, a nie same zestawy. Jeśli uruchamiasz zadanie ResolveAssemblyReference w normalny sposób, nie ustawiaj parametru „AssemblyInformationCacheOutputPath” zadania ResolveAssemblyReference.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
+      <trans-unit id="General.TaskRequiresWindows">
+        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
+        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <note>{StrBegin="MSB3096: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Usuwanie właściwości:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index f2a99ffe115..47364541ad1 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -514,6 +514,11 @@
         <target state="translated">MSB3667: já existe um arquivo em "{0}". Se você está tentando criar um cache pré-computado, crie um projeto que dependa dos assemblies em vez de criar seus assemblies sozinhos. Se você está executando a tarefa ResolveAssemblyReference normalmente, não defina o parâmetro "AssemblyInformationCacheOutputPath" da tarefa ResolveAssemblyReference.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
+      <trans-unit id="General.TaskRequiresWindows">
+        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
+        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <note>{StrBegin="MSB3096: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Removendo Propriedades:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index c8a5ab425e4..74137408038 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -514,6 +514,11 @@
         <target state="translated">MSB3667: в "{0}" уже существует файл. Если вы пытаетесь создать предварительно вычисляемый кэш, убедитесь, что выполняется сборка отдельного проекта, который зависит от ваших сборок, а не создание самих сборок. Если вы выполняете задачу ResolveAssemblyReference обычным образом, не устанавливайте параметр "AssemblyInformationCacheOutputPath" задачи ResolveAssemblyReference.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
+      <trans-unit id="General.TaskRequiresWindows">
+        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
+        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <note>{StrBegin="MSB3096: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Удаление свойств:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 64ba0d8599b..0ed6814b589 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -514,6 +514,11 @@
         <target state="translated">MSB3667: "{0}" konumunda zaten bir dosya var. Önceden hesaplanan bir önbellek oluşturmayı deniyorsanız bütünleştirilmiş kodlarınızı derlemek yerine bütünleştirilmiş kodlarınızı temel alan tek bir proje derlediğinizden emin olun. ResolveAssemblyReference görevini normal bir şekilde çalıştırıyorsanız ResolveAssemblyReference görevinin "AssemblyInformationCacheOutputPath" parametresini ayarlamayın.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
+      <trans-unit id="General.TaskRequiresWindows">
+        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
+        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <note>{StrBegin="MSB3096: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Özellikler kaldırılıyor:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 4e9da2c3e45..ac772ecf0bf 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -514,6 +514,11 @@
         <target state="translated">MSB3667: “{0}”处已存在文件。若要尝试创建预计算缓存，请务必生成单个依赖于程序集的项目，而不是生成程序集本身。如果在正常运行 ResolveAssemblyReference 任务，请不要设置 ResolveAssemblyReference 任务的 "AssemblyInformationCacheOutputPath" 参数。</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
+      <trans-unit id="General.TaskRequiresWindows">
+        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
+        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <note>{StrBegin="MSB3096: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">移除属性:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 182b61ffc4c..3ba672a7452 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -514,6 +514,11 @@
         <target state="translated">MSB3667: "{0}" 上已有檔案。若要嘗試建立預先計算的快取，請務必建立一個需要使用組件的專案，而非建立組件本身。若是正常執行 ResolveAssemblyReference 工作，請勿為 ResolveAssemblyReference 工作設定 "AssemblyInformationCacheOutputPath" 參數。</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
+      <trans-unit id="General.TaskRequiresWindows">
+        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
+        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <note>{StrBegin="MSB3096: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">正在移除屬性:</target>
diff --git a/src/Tasks/SignFile.cs b/src/Tasks/SignFile.cs
index 2c346a29487..379fe059587 100644
--- a/src/Tasks/SignFile.cs
+++ b/src/Tasks/SignFile.cs
@@ -4,6 +4,7 @@
 using System;
 using System.ComponentModel;
 using System.IO;
+using System.Runtime.Versioning;
 using System.Security.Cryptography;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -19,6 +20,7 @@ namespace Microsoft.Build.Tasks
     /// provided and optionally uses a timestamp if a URL is provided.
     /// It can sign ClickOnce manifests as well as exe's.
     /// </summary>
+    [SupportedOSPlatform("windows")]
     public sealed class SignFile : Task
     {
         public SignFile()
@@ -37,11 +39,15 @@ public SignFile()
         public String TargetFrameworkVersion { get; set; }
 
         public string TimestampUrl { get; set; }
-
         public bool DisallowMansignTimestampFallback { get; set; } = false;
 
         public override bool Execute()
         {
+            if (!NativeMethodsShared.IsWindows)
+            {
+                Log.LogErrorWithCodeFromResources("General.TaskRequiresWindows", nameof(SignFile));
+                return false;
+            }
             try
             {
                 SecurityUtilities.SignFile(
diff --git a/src/Utilities/README.md b/src/Utilities/README.md
index 16961c90367..a85d56e11cc 100644
--- a/src/Utilities/README.md
+++ b/src/Utilities/README.md
@@ -5,3 +5,8 @@ This package contains `Microsoft.Build.Utilities.Core.dll`, which defines helper
 * [`Task`](https://docs.microsoft.com/dotnet/api/microsoft.build.utilities.task), a base class for custom tasks,
 * [`ToolTask`](https://docs.microsoft.com/dotnet/api/microsoft.build.utilities.tooltask), a base class for tasks that run a command-line tool, and
 * [`Logger`](https://docs.microsoft.com/dotnet/api/microsoft.build.utilities.logger), a base class for custom logging functionality.
+
+### netstandard2.0 target
+The `netstandard2.0` target of this build is configured only to output reference assemblies; at runtime MSBuild will be `net6.0` or `net472`. Please use the `net6.0`-targeted assemblies for .NET Core 6+ scenarios.
+
+For context, see https://github.com/dotnet/msbuild/pull/6148
\ No newline at end of file
diff --git a/src/Utilities/TrackedDependencies/TrackedDependencies.cs b/src/Utilities/TrackedDependencies/TrackedDependencies.cs
index de261ee538e..ccc53acd3ae 100644
--- a/src/Utilities/TrackedDependencies/TrackedDependencies.cs
+++ b/src/Utilities/TrackedDependencies/TrackedDependencies.cs
@@ -48,7 +48,7 @@ public static ITaskItem[] ExpandWildcards(ITaskItem[] expand)
                     }
                     else
                     {
-                        files = FileMatcher.Default.GetFiles(null, item.ItemSpec);
+                        files = FileMatcher.Default.GetFiles(null, item.ItemSpec).FileList;
                     }
 
                     foreach (string file in files)
