diff --git a/src/Build.OM.UnitTests/Construction/ElementLocationPublic_Tests.cs b/src/Build.OM.UnitTests/Construction/ElementLocationPublic_Tests.cs
index a9af67129a5..28a8a1d6313 100644
--- a/src/Build.OM.UnitTests/Construction/ElementLocationPublic_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ElementLocationPublic_Tests.cs
@@ -16,6 +16,7 @@
 using System.Linq;
 using System.Reflection;
 using Xunit;
+using Shouldly;
 
 namespace Microsoft.Build.UnitTests.Construction
 {
@@ -125,6 +126,8 @@ public void LocationStringsMedley()
 
             string locations = project.Xml.Location.LocationString + "\r\n";
 
+            List<string> attributeLocations = new List<string>(2);
+
             foreach (var element in project.Xml.AllChildren)
             {
                 foreach (var property in element.GetType().GetProperties(BindingFlags.Public | BindingFlags.Instance))
@@ -135,7 +138,7 @@ public void LocationStringsMedley()
                         {
                             var values = new List<KeyValuePair<string, ElementLocation>>((ICollection<KeyValuePair<string, ElementLocation>>)property.GetValue(element, null));
 
-                            values.ForEach((value) => locations += value.Key + ":" + value.Value.LocationString + "\r\n");
+                            values.ForEach(value => attributeLocations.Add(value.Key + ":" + value.Value.LocationString));
                         }
                         else
                         {
@@ -194,8 +197,6 @@ public void LocationStringsMedley()
 c:\foo\bar.csproj (23,25)
 c:\foo\bar.csproj (24,32)
 c:\foo\bar.csproj (24,29)
-Text: (26,32)
-Importance: (26,66)
 c:\foo\bar.csproj (26,43)
 c:\foo\bar.csproj (26,25)
 c:\foo\bar.csproj (28,29)
@@ -204,6 +205,9 @@ public void LocationStringsMedley()
 ";
 
             Helpers.VerifyAssertLineByLine(expected, locations);
+
+            // attribute order depends on dictionary internals
+            attributeLocations.ShouldBe(new[] { "Text: (26,32)", "Importance: (26,66)" }, ignoreOrder: true);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
index 0b8fc55697a..e1ddcb897b8 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
@@ -14,6 +14,7 @@
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
+using System.Linq;
 
 namespace Microsoft.Build.UnitTests.OM.Instance
 {
@@ -342,6 +343,9 @@ public void ReadMetadata()
             ProjectItemInstance item = GetOneItem(content);
 
             var itemMetadata = Helpers.MakeList(item.Metadata);
+
+            itemMetadata = itemMetadata.OrderBy(pmi => pmi.Name).ToList();
+
             Assert.Equal(2, itemMetadata.Count);
             Assert.Equal("m1", itemMetadata[0].Name);
             Assert.Equal("m2", itemMetadata[1].Name);
diff --git a/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs b/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs
index 5dd66b6e929..83e60f427af 100644
--- a/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs
+++ b/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs
@@ -92,7 +92,7 @@ public Task<WorkUnitResult> ExecuteTask(TargetLoggingContext targetLoggingContex
             }
 
             ProjectOnErrorInstance errorTask = task as ProjectOnErrorInstance;
-            if (null != errorTask)
+            if (errorTask != null)
             {
                 ErrorTasks.Add(errorTask);
             }
diff --git a/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
index ea23951d312..5e68ff11991 100644
--- a/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
@@ -373,7 +373,7 @@ public Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext, Buil
                 return Task<BuildResult>.FromResult(result);
             }
 
-            if (null != _newRequests)
+            if (_newRequests != null)
             {
                 string[] projectFiles = new string[_newRequests.Length];
                 PropertyDictionary<ProjectPropertyInstance>[] properties = new PropertyDictionary<ProjectPropertyInstance>[_newRequests.Length];
diff --git a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
index 5af65de88f9..1804b8157ca 100644
--- a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
@@ -922,6 +922,26 @@ public void TestAfterTargetsWithTransitiveFailure()
             result.ResultsByTarget["Build"].AfterTargetsHaveFailed.ShouldBe(true);
         }
 
+        /// <summary>
+        /// Test a project that has a cycle in AfterTargets
+        /// </summary>
+        [Fact]
+        public void TestAfterTargetsWithCycleDoesNotHang()
+        {
+            string projectBody = @"
+<Target Name='Build' AfterTargets='After2' />
+
+<Target Name='After1' AfterTargets='Build' />
+
+<Target Name='After2' AfterTargets='After1' />
+";
+
+            BuildResult result = BuildSimpleProject(projectBody, new string[] { "Build" }, failTaskNumber: int.MaxValue /* no task failure needed here */);
+            result.ResultsByTarget["Build"].ResultCode.ShouldBe(TargetResultCode.Success);
+            result.ResultsByTarget["Build"].AfterTargetsHaveFailed.ShouldBe(false);
+        }
+
+
         /// <summary>
         /// Test after target on a skipped target
         /// </summary>
diff --git a/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs b/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
index 660f95455c2..920b2b13a58 100644
--- a/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
@@ -442,7 +442,7 @@ private void VerifySplitSemiColonSeparatedList(string input, params string[] exp
             var actual = ExpressionShredder.SplitSemiColonSeparatedList(input);
             Console.WriteLine(input);
 
-            if (null == expected)
+            if (expected == null)
             {
                 // passing "null" means you expect an empty array back
                 expected = new string[] { };
diff --git a/src/Build.UnitTests/FileLogger_Tests.cs b/src/Build.UnitTests/FileLogger_Tests.cs
index 0fefab60bc5..e06c154ba57 100644
--- a/src/Build.UnitTests/FileLogger_Tests.cs
+++ b/src/Build.UnitTests/FileLogger_Tests.cs
@@ -69,7 +69,7 @@ public void BasicNoExistingFile()
             }
             finally
             {
-                if (null != log) File.Delete(log);
+                if (log != null) File.Delete(log);
             }
         }
 
@@ -92,7 +92,7 @@ public void InvalidFile()
                 }
                 finally
                 {
-                    if (null != log) File.Delete(log);
+                    if (log != null) File.Delete(log);
                 }
             }
            );
@@ -121,7 +121,7 @@ public void SpecificVerbosity()
             }
             finally
             {
-                if (null != log) File.Delete(log);
+                if (log != null) File.Delete(log);
             }
         }
 
@@ -194,7 +194,7 @@ public void InvalidEncoding()
                 }
                 finally
                 {
-                    if (null != log) File.Delete(log);
+                    if (log != null) File.Delete(log);
                 }
             }
            );
@@ -220,7 +220,7 @@ public void ValidEncoding()
             }
             finally
             {
-                if (null != log) File.Delete(log);
+                if (log != null) File.Delete(log);
             }
         }
 
@@ -245,7 +245,7 @@ public void ValidEncoding2()
             }
             finally
             {
-                if (null != log) File.Delete(log);
+                if (log != null) File.Delete(log);
             }
         }
 
@@ -287,7 +287,7 @@ public void BasicExistingFileNoAppend()
             }
             finally
             {
-                if (null != log) File.Delete(log);
+                if (log != null) File.Delete(log);
             }
         }
 
@@ -308,7 +308,7 @@ public void BasicExistingFileAppend()
             }
             finally
             {
-                if (null != log) File.Delete(log);
+                if (log != null) File.Delete(log);
             }
         }
 
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index c36a51b66b8..fdeaf730a1b 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -28,8 +28,7 @@
     <ProjectReference Include="..\MSBuild\MSBuild.csproj" />
     <ProjectReference Include="..\MSBuildTaskHost\MSBuildTaskHost.csproj"
                       Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MonoBuild)' != 'true'"
-                      ReferenceOutputAssembly="false"
-                      OutputItemType="Content" />
+                      Aliases="MSBuildTaskHost" />
     <ProjectReference Include="..\Tasks\Microsoft.Build.Tasks.csproj" />
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
     <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
@@ -117,6 +116,9 @@
     <Compile Include="..\Shared\UnitTests\TestData\GlobbingTestData.cs">
       <Link>TestData\GlobbingTestData.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\UnitTests\ImmutableDictionary_Tests.cs" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MSBuildRuntimeType)' == 'Full' and '$(MonoBuild)' != 'true'">
+      <Link>ImmutableDictionary_Tests.cs</Link>
+    </Compile>
 
     <None Include="..\Shared\UnitTests\App.config">
       <Link>App.config</Link>
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 9223ab23002..df18a3eee4e 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -891,7 +891,7 @@ public GraphBuildResult Build(BuildParameters parameters, GraphBuildRequestData
         /// </summary>
         public void ShutdownAllNodes()
         {
-            if (null == _nodeManager)
+            if (_nodeManager == null)
             {
                 _nodeManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.NodeManager) as INodeManager;
             }
@@ -1971,7 +1971,7 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)
                         {
                             NodeInfo createdNode = _nodeManager.CreateNode(GetNodeConfiguration(), response.RequiredNodeType);
 
-                            if (null != createdNode)
+                            if (createdNode != null)
                             {
                                 _noNodesActiveEvent.Reset();
                                 _activeNodes.Add(createdNode.NodeId);
@@ -2166,7 +2166,7 @@ private void CheckAllSubmissionsComplete(BuildRequestDataFlags? flags)
         /// </summary>
         private NodeConfiguration GetNodeConfiguration()
         {
-            if (null == _nodeConfiguration)
+            if (_nodeConfiguration == null)
             {
                 // Get the remote loggers
                 ILoggingService loggingService = ((IBuildComponentHost)this).GetComponent(BuildComponentType.LoggingService) as ILoggingService;
diff --git a/src/Build/BackEnd/BuildManager/BuildSubmission.cs b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
index d6a02bd3650..3a53fbbf3ee 100644
--- a/src/Build/BackEnd/BuildManager/BuildSubmission.cs
+++ b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
@@ -200,7 +200,7 @@ private void CheckForCompletion()
                 {
                     _completionEvent.Set();
 
-                    if (null != _completionCallback)
+                    if (_completionCallback != null)
                     {
                         void Callback(object state)
                         {
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index 2cf6ea5f8ed..bd5d8815eb6 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -615,7 +615,7 @@ private void BuildRequestEntry_StateChanged(BuildRequestEntry entry, BuildReques
         private void RaiseRequestComplete(BuildRequest request, BuildResult result)
         {
             RequestCompleteDelegate requestComplete = OnRequestComplete;
-            if (null != requestComplete)
+            if (requestComplete != null)
             {
                 TraceEngine("RRC: Reporting result for request {0}({1}) (nr {2}).", request.GlobalRequestId, request.ConfigurationId, request.NodeRequestId);
                 requestComplete(request, result);
@@ -718,7 +718,7 @@ private void EvaluateRequestStates()
 
                     // This request is ready to be built
                     case BuildRequestEntryState.Ready:
-                        if (null == firstReadyEntry)
+                        if (firstReadyEntry == null)
                         {
                             firstReadyEntry = currentEntry;
                         }
@@ -747,9 +747,9 @@ private void EvaluateRequestStates()
             }
 
             // Update current engine status and start the next request, if applicable.
-            if (null == activeEntry)
+            if (activeEntry == null)
             {
-                if (null != firstReadyEntry)
+                if (firstReadyEntry != null)
                 {
                     // We are now active because we have an entry which is building.
                     ChangeStatus(BuildRequestEngineStatus.Active);
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index cfbcaff2aeb..9ba79433501 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -312,7 +312,7 @@ private static bool CheckResults(BuildResult result, List<string> targets, HashS
             {
                 if (!result.HasResultsForTarget(target) || (result[target].ResultCode == TargetResultCode.Skipped && !skippedResultsAreOK))
                 {
-                    if (null != targetsMissingResults)
+                    if (targetsMissingResults != null)
                     {
                         targetsMissingResults.Add(target);
                         returnValue = false;
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
index 956a7f080f6..a8f9f39b37d 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
@@ -252,7 +252,7 @@ internal static EndpointPair CreateInProcEndpoints(EndpointMode mode, IBuildComp
         /// <param name="newStatus">The new status of the endpoint link.</param>
         private void RaiseLinkStatusChanged(LinkStatus newStatus)
         {
-            if (null != OnLinkStatusChanged)
+            if (OnLinkStatusChanged != null)
             {
                 LinkStatusChangedDelegate linkStatusDelegate = OnLinkStatusChanged;
                 linkStatusDelegate(this, newStatus);
@@ -326,8 +326,8 @@ private void EnqueuePacket(INodePacket packet)
         {
             ErrorUtilities.VerifyThrowArgumentNull(packet, nameof(packet));
             ErrorUtilities.VerifyThrow(_mode == EndpointMode.Asynchronous, "EndPoint mode is synchronous, should be asynchronous");
-            ErrorUtilities.VerifyThrow(null != _packetQueue, "packetQueue is null");
-            ErrorUtilities.VerifyThrow(null != _packetAvailable, "packetAvailable is null");
+            ErrorUtilities.VerifyThrow(_packetQueue != null, "packetQueue is null");
+            ErrorUtilities.VerifyThrow(_packetAvailable != null, "packetAvailable is null");
 
             _packetQueue.Enqueue(packet);
             _packetAvailable.Set();
@@ -340,10 +340,10 @@ private void InitializeAsyncPacketThread()
         {
             lock (_asyncDataMonitor)
             {
-                ErrorUtilities.VerifyThrow(null == _packetPump, "packetPump != null");
-                ErrorUtilities.VerifyThrow(null == _packetAvailable, "packetAvailable != null");
-                ErrorUtilities.VerifyThrow(null == _terminatePacketPump, "terminatePacketPump != null");
-                ErrorUtilities.VerifyThrow(null == _packetQueue, "packetQueue != null");
+                ErrorUtilities.VerifyThrow(_packetPump == null, "packetPump != null");
+                ErrorUtilities.VerifyThrow(_packetAvailable == null, "packetAvailable != null");
+                ErrorUtilities.VerifyThrow(_terminatePacketPump == null, "terminatePacketPump != null");
+                ErrorUtilities.VerifyThrow(_packetQueue == null, "packetQueue != null");
 
 #if FEATURE_THREAD_CULTURE
                 _packetPump = new Thread(PacketPumpProc);
@@ -377,10 +377,10 @@ private void TerminateAsyncPacketThread()
         {
             lock (_asyncDataMonitor)
             {
-                ErrorUtilities.VerifyThrow(null != _packetPump, "packetPump == null");
-                ErrorUtilities.VerifyThrow(null != _packetAvailable, "packetAvailable == null");
-                ErrorUtilities.VerifyThrow(null != _terminatePacketPump, "terminatePacketPump == null");
-                ErrorUtilities.VerifyThrow(null != _packetQueue, "packetQueue == null");
+                ErrorUtilities.VerifyThrow(_packetPump != null, "packetPump == null");
+                ErrorUtilities.VerifyThrow(_packetAvailable != null, "packetAvailable == null");
+                ErrorUtilities.VerifyThrow(_terminatePacketPump != null, "terminatePacketPump == null");
+                ErrorUtilities.VerifyThrow(_packetQueue != null, "packetQueue == null");
 
                 _terminatePacketPump.Set();
                 if (!_packetPump.Join((int)new TimeSpan(0, 0, BuildParameters.EndpointShutdownTimeout).TotalMilliseconds))
diff --git a/src/Build/BackEnd/Components/Communications/NodeManager.cs b/src/Build/BackEnd/Components/Communications/NodeManager.cs
index 2ad71da07f0..79358a223fb 100644
--- a/src/Build/BackEnd/Components/Communications/NodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeManager.cs
@@ -156,9 +156,7 @@ public void ShutdownConnectedNodes(bool enableReuse)
             }
 
             _nodesShutdown = true;
-
             _inProcNodeProvider?.ShutdownConnectedNodes(enableReuse);
-
             _outOfProcNodeProvider?.ShutdownConnectedNodes(enableReuse);
         }
 
@@ -316,7 +314,7 @@ private void RemoveNodeFromMapping(int nodeId)
         private int AttemptCreateNode(INodeProvider nodeProvider, NodeConfiguration nodeConfiguration)
         {
             // If no provider was passed in, we obviously can't create a node.
-            if (null == nodeProvider)
+            if (nodeProvider == null)
             {
                 ErrorUtilities.ThrowInternalError("No node provider provided.");
                 return InvalidNodeId;
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
index 49cca2f7e4d..0081265b99c 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
@@ -153,7 +153,7 @@ public void SendData(int nodeId, INodePacket packet)
             ErrorUtilities.VerifyThrowArgumentOutOfRange(nodeId == _inProcNodeId, "node");
             ErrorUtilities.VerifyThrowArgumentNull(packet, nameof(packet));
 
-            if (null == _inProcNode)
+            if (_inProcNode == null)
             {
                 return;
             }
@@ -167,7 +167,7 @@ public void SendData(int nodeId, INodePacket packet)
         /// <param name="enableReuse">Flag indicating if the nodes should prepare for reuse.</param>
         public void ShutdownConnectedNodes(bool enableReuse)
         {
-            if (null != _inProcNode)
+            if (_inProcNode != null)
             {
                 _inProcNodeEndpoint.SendData(new NodeBuildComplete(enableReuse));
             }
@@ -333,8 +333,8 @@ static internal IBuildComponent CreateComponent(BuildComponentType type)
         /// </summary>
         private bool InstantiateNode(INodePacketFactory factory)
         {
-            ErrorUtilities.VerifyThrow(null == _inProcNode, "In Proc node already instantiated.");
-            ErrorUtilities.VerifyThrow(null == _inProcNodeEndpoint, "In Proc node endpoint already instantiated.");
+            ErrorUtilities.VerifyThrow(_inProcNode == null, "In Proc node already instantiated.");
+            ErrorUtilities.VerifyThrow(_inProcNodeEndpoint == null, "In Proc node endpoint already instantiated.");
 
             NodeEndpointInProc.EndpointPair endpoints = NodeEndpointInProc.CreateInProcEndpoints(NodeEndpointInProc.EndpointMode.Synchronous, _componentHost);
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
index 44a070ac3db..50ca0c90a01 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
@@ -95,7 +95,7 @@ public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration
             Handshake hostHandshake = new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: ComponentHost.BuildParameters.EnableNodeReuse, lowPriority: ComponentHost.BuildParameters.LowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
             NodeContext context = GetNode(null, commandLineArgs, nodeId, factory, hostHandshake, NodeContextTerminated);
 
-            if (null != context)
+            if (context != null)
             {
                 _nodeContexts[nodeId] = context;
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index 418ce50329e..ef746ed27d7 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -529,7 +529,7 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor
                                         NodeContextTerminated
                                     );
 
-            if (null != context)
+            if (context != null)
             {
                 _nodeContexts[hostContext] = context;
 
diff --git a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
index 5ec101d68a5..949c39b4720 100644
--- a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
@@ -73,7 +73,6 @@ public void SendData(int node, INodePacket packet)
         public void ShutdownConnectedNodes(bool enableReuse)
         {
             ErrorUtilities.VerifyThrow(!_componentShutdown, "We should never be calling ShutdownNodes after ShutdownComponent has been called");
-
             _outOfProcTaskHostNodeProvider?.ShutdownConnectedNodes(enableReuse);
         }
 
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 93cbaff924a..f426366b7b1 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -1457,7 +1457,7 @@ private void InitializeLogger(ILogger logger, IEventSource sourceForLogger)
             try
             {
                 INodeLogger nodeLogger = logger as INodeLogger;
-                if (null != nodeLogger)
+                if (nodeLogger != null)
                 {
                     nodeLogger.Initialize(sourceForLogger, _maxCPUCount);
                 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
index f0485c1d0eb..3e676950ea5 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
@@ -335,7 +335,7 @@ ElementLocation elementLocation
 
                         // If we didn't find a bucket that matches this item, create a new one, adding
                         // this item to the bucket.
-                        if (null == matchingBucket)
+                        if (matchingBucket == null)
                         {
                             matchingBucket = new ItemBucket(itemListsToBeBatched.Keys, itemMetadataValues, lookup, buckets.Count);
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 15b97e6a83d..31318d664b1 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -680,7 +680,7 @@ public string GetEscapedValue(string specifiedItemType, string name)
             public string GetEscapedValueIfPresent(string specifiedItemType, string name)
             {
                 string value = null;
-                if (null == specifiedItemType || specifiedItemType == _itemType)
+                if (specifiedItemType == null || specifiedItemType == _itemType)
                 {
                     // Look in the addTable
                     if (_addTable.TryGetValue(name, out value))
@@ -690,17 +690,17 @@ public string GetEscapedValueIfPresent(string specifiedItemType, string name)
                 }
 
                 // Look in the bucket table
-                if (null != _bucketTable)
+                if (_bucketTable != null)
                 {
                     value = _bucketTable.GetEscapedValueIfPresent(specifiedItemType, name);
-                    if (null != value)
+                    if (value != null)
                     {
                         return value;
                     }
                 }
 
                 // Look in the item definition table
-                if (null != _itemDefinitionTable)
+                if (_itemDefinitionTable != null)
                 {
                     value = _itemDefinitionTable.GetEscapedValueIfPresent(specifiedItemType, name);
                 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 8551bc19c43..00512fc9c9b 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -183,7 +183,7 @@ public void BuildRequest(NodeLoggingContext loggingContext, BuildRequestEntry en
         {
             ErrorUtilities.VerifyThrowArgumentNull(loggingContext, nameof(loggingContext));
             ErrorUtilities.VerifyThrowArgumentNull(entry, nameof(entry));
-            ErrorUtilities.VerifyThrow(null != _componentHost, "Host not set.");
+            ErrorUtilities.VerifyThrow(_componentHost != null, "Host not set.");
             ErrorUtilities.VerifyThrow(_targetBuilder == null, "targetBuilder not null");
             ErrorUtilities.VerifyThrow(_nodeLoggingContext == null, "nodeLoggingContext not null");
             ErrorUtilities.VerifyThrow(_requestEntry == null, "requestEntry not null");
@@ -726,7 +726,7 @@ private async Task BuildAndReport()
             }
             catch (InvalidProjectFileException ex)
             {
-                if (null != _projectLoggingContext)
+                if (_projectLoggingContext != null)
                 {
                     _projectLoggingContext.LogInvalidProjectFileError(ex);
                 }
@@ -764,7 +764,7 @@ private async Task BuildAndReport()
             {
                 _blockType = BlockType.Unblocked;
 
-                if (null != thrownException)
+                if (thrownException != null)
                 {
                     ErrorUtilities.VerifyThrow(result == null, "Result already set when exception was thrown.");
                     result = new BuildResult(_requestEntry.Request, thrownException);
@@ -781,7 +781,7 @@ private async Task BuildAndReport()
         /// </summary>
         private void ReportResultAndCleanUp(BuildResult result)
         {
-            if (null != _projectLoggingContext)
+            if (_projectLoggingContext != null)
             {
                 try
                 {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index d105588c94d..834d87e57b2 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -439,7 +439,7 @@ private async Task ProcessTargetStack(ITaskBuilder taskBuilder)
                             }
 
                             // And if we have dependencies to run, push them now.
-                            if (null != dependencies)
+                            if (dependencies != null)
                             {
                                 await PushTargets(dependencies, currentTargetEntry, currentTargetEntry.Lookup, false, false, TargetBuiltReason.DependsOn);
                             }
@@ -777,6 +777,10 @@ private void ComputeAfterTargetFailures(string[] targetNames)
                     var targetsToCheckForAfterTargets = new Queue<string>();
                     targetsToCheckForAfterTargets.Enqueue(targetName);
 
+                    // Set of targets already processed, to break cycles of AfterTargets.
+                    // Initialized lazily when needed below.
+                    HashSet<string> targetsChecked = null;
+
                     while (targetsToCheckForAfterTargets?.Count > 0)
                     {
                         string targetToCheck = targetsToCheckForAfterTargets.Dequeue();
@@ -793,8 +797,16 @@ private void ComputeAfterTargetFailures(string[] targetNames)
                                 break;
                             }
 
-                            // We haven't seen this target yet, add it to the list to check.
-                            targetsToCheckForAfterTargets.Enqueue(afterTarget.TargetName);
+                            targetsChecked ??= new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default)
+                                {
+                                    targetName
+                                };
+
+                            // If we haven't seen this target yet, add it to the list to check.
+                            if (targetsChecked.Add(afterTarget.TargetName))
+                            {
+                                targetsToCheckForAfterTargets.Enqueue(afterTarget.TargetName);
+                            }
                         }
                     }
                 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index 6e7c3e077aa..98acfa7cee3 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -546,11 +546,8 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                         // Make sure the Invalid Project error gets logged *before* TargetFinished.  Otherwise,
                         // the log is confusing.
                         targetLoggingContext.LogInvalidProjectFileError(e);
-
                         entryForInference?.LeaveScope();
-
                         entryForExecution?.LeaveScope();
-
                         aggregateResult = aggregateResult.AggregateResult(new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, null));
                     }
                     finally
@@ -718,7 +715,7 @@ internal List<TargetSpecification> GetErrorTargets(ProjectLoggingContext project
 
             // If this target never executed (for instance, because one of its dependencies errored) then we need to
             // create a result for this target to report when it gets to the Completed state.
-            if (null == _targetResult)
+            if (_targetResult == null)
             {
                 _targetResult = new TargetResult(Array.Empty<TaskItem>(), new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, null));
             }
@@ -747,7 +744,7 @@ internal TargetResult GatherResults()
         /// <param name="lookup">The lookup to enter with.</param>
         internal void EnterLegacyCallTargetScope(Lookup lookup)
         {
-            if (null == _legacyCallTargetScopes)
+            if (_legacyCallTargetScopes == null)
             {
                 _legacyCallTargetScopes = new Stack<Lookup.Scope>();
             }
@@ -783,7 +780,7 @@ internal void MarkForStop()
         /// </summary>
         internal void LeaveLegacyCallTargetScopes()
         {
-            if (null != _legacyCallTargetScopes)
+            if (_legacyCallTargetScopes != null)
             {
                 while (_legacyCallTargetScopes.Count != 0)
                 {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 9d3bcc3e05f..d3431b4bf8c 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -1179,7 +1179,7 @@ ItemBucket bucket
         {
             string taskParameterAttribute = _taskNode.GetParameter(taskParameterName);
 
-            if (null != taskParameterAttribute)
+            if (taskParameterAttribute != null)
             {
                 ProjectTaskOutputItemInstance taskItemInstance = taskOutputSpecification as ProjectTaskOutputItemInstance;
                 if (taskItemInstance != null)
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index b357b6149ce..4dc54d08360 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -1552,7 +1552,7 @@ private void HandleRequestBlockedByNewRequests(SchedulableRequest parentRequest,
                 // directly here.  We COULD simply report these as blocking the parent request and let the scheduler pick them up later when the parent
                 // comes back up as schedulable, but we prefer to send the results back immediately so this request can (potentially) continue uninterrupted.
                 ScheduleResponse response = TrySatisfyRequestFromCache(nodeForResults, request, skippedResultsDoNotCauseCacheMiss: _componentHost.BuildParameters.SkippedResultsDoNotCauseCacheMiss());
-                if (null != response)
+                if (response != null)
                 {
                     TraceScheduler("Request {0} (node request {1}) satisfied from the cache.", request.GlobalRequestId, request.NodeRequestId);
 
diff --git a/src/Build/BackEnd/Node/InProcNode.cs b/src/Build/BackEnd/Node/InProcNode.cs
index 580187c97f4..0a5db6abbb2 100644
--- a/src/Build/BackEnd/Node/InProcNode.cs
+++ b/src/Build/BackEnd/Node/InProcNode.cs
@@ -287,7 +287,7 @@ private NodeEngineShutdownReason HandleShutdown(out Exception exception)
             try
             {
                 // Clean up the engine
-                if (null != _buildRequestEngine && _buildRequestEngine.Status != BuildRequestEngineStatus.Uninitialized)
+                if (_buildRequestEngine != null && _buildRequestEngine.Status != BuildRequestEngineStatus.Uninitialized)
                 {
                     _buildRequestEngine.CleanupForBuild();
                 }
@@ -338,7 +338,7 @@ private NodeEngineShutdownReason HandleShutdown(out Exception exception)
 
             exception = _shutdownException;
 
-            if (null != _loggingContext)
+            if (_loggingContext != null)
             {
                 _loggingContext.LoggingService.OnLoggingThreadException -= OnLoggingThreadException;
                 _loggingContext = null;
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 28b6bbabc77..a4451a7560d 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -429,7 +429,7 @@ private NodeEngineShutdownReason HandleShutdown(out Exception exception)
             CommunicationsUtilities.Trace("Shutting down with reason: {0}, and exception: {1}.", _shutdownReason, _shutdownException);
 
             // Clean up the engine
-            if (null != _buildRequestEngine && _buildRequestEngine.Status != BuildRequestEngineStatus.Uninitialized)
+            if (_buildRequestEngine != null && _buildRequestEngine.Status != BuildRequestEngineStatus.Uninitialized)
             {
                 _buildRequestEngine.CleanupForBuild();
 
@@ -480,7 +480,7 @@ private NodeEngineShutdownReason HandleShutdown(out Exception exception)
             try
             {
                 // Shut down logging, which will cause all queued logging messages to be sent.
-                if (null != _loggingContext && null != _loggingService)
+                if (_loggingContext != null && _loggingService != null)
                 {
                     _loggingContext.LogBuildFinished(true);
                     ((IBuildComponent)_loggingService).ShutdownComponent();
@@ -489,7 +489,7 @@ private NodeEngineShutdownReason HandleShutdown(out Exception exception)
             finally
             {
                 // Shut down logging, which will cause all queued logging messages to be sent.
-                if (null != _loggingContext && null != _loggingService)
+                if (_loggingContext != null && _loggingService != null)
                 {
                     _loggingContext.LoggingService.OnLoggingThreadException -= OnLoggingThreadException;
                     _loggingContext = null;
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index ec0d6b998c9..b5bf9d3706d 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -334,7 +334,7 @@ public BuildResultCode OverallResult
         {
             get
             {
-                if (null != _requestException || _circularDependency || !_baseOverallResult)
+                if (_requestException != null || _circularDependency || !_baseOverallResult)
                 {
                     return BuildResultCode.Failure;
                 }
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index ae92de6ace9..26759da6f92 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -294,7 +294,7 @@ bool ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, It
             // here. Instead, NDP will try to Load (not LoadFrom!) the task assembly into our AppDomain, and since
             // we originally used LoadFrom, it will fail miserably not knowing where to find it.
             // We need to temporarily subscribe to the AppDomain.AssemblyResolve event to fix it.
-            if (null == _resolver)
+            if (_resolver == null)
             {
                 _resolver = new TaskEngineAssemblyResolver();
                 _resolver.Initialize(_taskFactoryWrapper.TaskFactoryLoadedType.Assembly.AssemblyFile);
@@ -865,19 +865,19 @@ private TaskFactoryWrapper FindTaskInRegistry(IDictionary<string, string> taskId
             if (!_intrinsicTasks.TryGetValue(_taskName, out TaskFactoryWrapper returnClass))
             {
                 returnClass = _projectInstance.TaskRegistry.GetRegisteredTask(_taskName, null, taskIdentityParameters, true /* exact match */, _targetLoggingContext, _taskLocation);
-                if (null == returnClass)
+                if (returnClass == null)
                 {
                     returnClass = _projectInstance.TaskRegistry.GetRegisteredTask(_taskName, null, taskIdentityParameters, false /* fuzzy match */, _targetLoggingContext, _taskLocation);
 
-                    if (null == returnClass)
+                    if (returnClass == null)
                     {
                         returnClass = _projectInstance.TaskRegistry.GetRegisteredTask(_taskName, null, null, true /* exact match */, _targetLoggingContext, _taskLocation);
 
-                        if (null == returnClass)
+                        if (returnClass == null)
                         {
                             returnClass = _projectInstance.TaskRegistry.GetRegisteredTask(_taskName, null, null, false /* fuzzy match */, _targetLoggingContext, _taskLocation);
 
-                            if (null == returnClass)
+                            if (returnClass == null)
                             {
                                 _targetLoggingContext.LogError
                                     (
diff --git a/src/Build/Collections/CopyOnWritePropertyDictionary.cs b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
index 68f6cf3eaef..67ab4344b9a 100644
--- a/src/Build/Collections/CopyOnWritePropertyDictionary.cs
+++ b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
@@ -251,7 +251,7 @@ IEnumerator IEnumerable.GetEnumerator()
         /// <returns>True if they are equivalent, false otherwise.</returns>
         public bool Equals(CopyOnWritePropertyDictionary<T> other)
         {
-            if (null == other)
+            if (other == null)
             {
                 return false;
             }
diff --git a/src/Build/Collections/PropertyDictionary.cs b/src/Build/Collections/PropertyDictionary.cs
index f9d871cc8f9..e3c17b24fae 100644
--- a/src/Build/Collections/PropertyDictionary.cs
+++ b/src/Build/Collections/PropertyDictionary.cs
@@ -264,7 +264,7 @@ IEnumerator IEnumerable.GetEnumerator()
         /// <returns>True if they are equivalent, false otherwise.</returns>
         public bool Equals(PropertyDictionary<T> other)
         {
-            if (null == other)
+            if (other == null)
             {
                 return false;
             }
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 4b9c602b48b..8869625cae4 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -875,11 +875,11 @@ internal PropertyDictionary<ProjectPropertyInstance> EnvironmentProperties
                     // This is only done once, when the project collection is created. Any subsequent
                     // environment changes will be ignored. Child nodes will be passed this set
                     // of properties in their build parameters.
-                    if (null == _environmentProperties)
+                    if (_environmentProperties == null)
                     {
                         using (_locker.EnterWriteLock())
                         {
-                            if (null == _environmentProperties)
+                            if (_environmentProperties == null)
                             {
                                 _environmentProperties = Utilities.GetEnvironmentProperties();
                             }
diff --git a/src/Build/Definition/ProjectItem.cs b/src/Build/Definition/ProjectItem.cs
index dc2d645a580..40b7b40eed9 100644
--- a/src/Build/Definition/ProjectItem.cs
+++ b/src/Build/Definition/ProjectItem.cs
@@ -344,7 +344,7 @@ internal ICollection<ProjectMetadata> MetadataCollection
                 }
 
                 // Finally any direct metadata win.
-                if (null != _directMetadata)
+                if (_directMetadata != null)
                 {
                     foreach (ProjectMetadata metadatum in _directMetadata)
                     {
@@ -452,7 +452,7 @@ public bool HasMetadata(string name)
             }
 
             ProjectMetadata metadatum = GetItemDefinitionMetadata(name);
-            if (null != metadatum)
+            if (metadatum != null)
             {
                 return true;
             }
@@ -488,13 +488,13 @@ string IItem.GetMetadataValueEscaped(string name)
             {
                 ProjectMetadata metadatum = GetItemDefinitionMetadata(name);
 
-                if (null != metadatum && Expander<ProjectProperty, ProjectItem>.ExpressionMayContainExpandableExpressions(metadatum.EvaluatedValueEscaped))
+                if (metadatum != null && Expander<ProjectProperty, ProjectItem>.ExpressionMayContainExpandableExpressions(metadatum.EvaluatedValueEscaped))
                 {
                     Expander<ProjectProperty, ProjectItem> expander = new Expander<ProjectProperty, ProjectItem>(null, null, new BuiltInMetadataTable(this), FileSystems.Default);
 
                     value = expander.ExpandIntoStringLeaveEscaped(metadatum.EvaluatedValueEscaped, ExpanderOptions.ExpandBuiltInMetadata, metadatum.Location);
                 }
-                else if (null != metadatum)
+                else if (metadatum != null)
                 {
                     return metadatum.EvaluatedValueEscaped;
                 }
diff --git a/src/Build/Definition/ProjectProperty.cs b/src/Build/Definition/ProjectProperty.cs
index 86006ce707a..a8e6b32e4a3 100644
--- a/src/Build/Definition/ProjectProperty.cs
+++ b/src/Build/Definition/ProjectProperty.cs
@@ -218,7 +218,7 @@ bool IEquatable<ProjectProperty>.Equals(ProjectProperty other)
                 return true;
             }
 
-            if (null == other)
+            if (other == null)
             {
                 return false;
             }
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index d4319af557f..fc08972debb 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -253,7 +253,7 @@ public Toolset(string toolsVersion, string toolsPath, IDictionary<string, string
             : this(toolsVersion, toolsPath, null, projectCollection.EnvironmentProperties, projectCollection.GlobalPropertiesCollection, subToolsets, msbuildOverrideTasksPath, defaultOverrideToolsVersion: null)
         {
             _properties = new PropertyDictionary<ProjectPropertyInstance>();
-            if (null != buildProperties)
+            if (buildProperties != null)
             {
                 foreach (KeyValuePair<string, string> keyValuePair in buildProperties)
                 {
@@ -701,7 +701,7 @@ internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, ILoggingServic
 
             try
             {
-                if (null != getFiles)
+                if (getFiles != null)
                 {
                     defaultTasksFiles = getFiles(searchPath, taskPattern);
                 }
@@ -997,7 +997,7 @@ private void RegisterOverrideTasks(ILoggingService loggingServices, BuildEventCo
                         {
                             if (Path.IsPathRooted(_overrideTasksPath))
                             {
-                                if (null != _directoryExists)
+                                if (_directoryExists != null)
                                 {
                                     overrideDirectoryExists = _directoryExists(_overrideTasksPath);
                                 }
@@ -1063,7 +1063,7 @@ private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, ILoggingSer
                     {
                         ProjectUsingTaskElement usingTask = elementXml as ProjectUsingTaskElement;
 
-                        if (null == usingTask)
+                        if (usingTask == null)
                         {
                             ProjectErrorUtilities.ThrowInvalidProject
                                 (
diff --git a/src/Build/Definition/ToolsetConfigurationReader.cs b/src/Build/Definition/ToolsetConfigurationReader.cs
index 8f7e7744551..9023f575257 100644
--- a/src/Build/Definition/ToolsetConfigurationReader.cs
+++ b/src/Build/Definition/ToolsetConfigurationReader.cs
@@ -119,7 +119,7 @@ private ToolsetConfigurationSection ConfigurationSection
         {
             get
             {
-                if (null == _configurationSection && !_configurationReadAttempted)
+                if (_configurationSection == null && !_configurationReadAttempted)
                 {
                     try
                     {
diff --git a/src/Build/Evaluation/Conditionals/Parser.cs b/src/Build/Evaluation/Conditionals/Parser.cs
index 3255b2b6d8a..ac231b18964 100644
--- a/src/Build/Evaluation/Conditionals/Parser.cs
+++ b/src/Build/Evaluation/Conditionals/Parser.cs
@@ -174,7 +174,7 @@ private GenericExpressionNode ExprPrime(string expression, GenericExpressionNode
         private GenericExpressionNode BooleanTerm(string expression)
         {
             GenericExpressionNode node = RelationalExpr(expression);
-            if (null == node)
+            if (node == null)
             {
                 errorPosition = _lexer.GetErrorPosition();
                 ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
@@ -196,7 +196,7 @@ private GenericExpressionNode BooleanTermPrime(string expression, GenericExpress
             else if (Same(expression, Token.TokenType.And))
             {
                 GenericExpressionNode rhs = RelationalExpr(expression);
-                if (null == rhs)
+                if (rhs == null)
                 {
                     errorPosition = _lexer.GetErrorPosition();
                     ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
@@ -218,7 +218,7 @@ private GenericExpressionNode RelationalExpr(string expression)
         {
             {
                 GenericExpressionNode lhs = Factor(expression);
-                if (null == lhs)
+                if (lhs == null)
                 {
                     errorPosition = _lexer.GetErrorPosition();
                     ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
@@ -382,7 +382,7 @@ private bool Same(string expression, Token.TokenType token)
                 if (!_lexer.Advance())
                 {
                     errorPosition = _lexer.GetErrorPosition();
-                    if (null != _lexer.UnexpectedlyFound)
+                    if (_lexer.UnexpectedlyFound != null)
                     {
                         ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, _lexer.GetErrorResource(), expression, errorPosition, _lexer.UnexpectedlyFound);
                     }
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index cf6f39fac6c..4322d3fcaa2 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -1559,7 +1559,7 @@ private static string ExpandRegistryValue(string registryExpression, IElementLoc
 
                         object valueFromRegistry = Registry.GetValue(registryKeyName, valueName, null /* default if key or value name is not found */);
 
-                        if (null != valueFromRegistry)
+                        if (valueFromRegistry != null)
                         {
                             // Convert the result to a string that is reasonable for MSBuild
                             result = ConvertToString(valueFromRegistry);
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 8c268c88cc5..f6de1df07f3 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -2215,7 +2215,7 @@ internal bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<
         {
             VerifyThrowNotImmutable();
 
-            if (null == targets)
+            if (targets == null)
             {
                 targets = Array.Empty<string>();
             }
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 247b999052e..716439edbf7 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -1253,14 +1253,14 @@ public string GetMetadataEscaped(string metadataName)
 
                 metadatum = GetItemDefinitionMetadata(metadataName);
 
-                if (null != metadatum && Expander<ProjectProperty, ProjectItem>.ExpressionMayContainExpandableExpressions(metadatum.EvaluatedValueEscaped))
+                if (metadatum != null && Expander<ProjectProperty, ProjectItem>.ExpressionMayContainExpandableExpressions(metadatum.EvaluatedValueEscaped))
                 {
                     Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(null, null, new BuiltInMetadataTable(null, this), FileSystems.Default);
 
                     // We don't have a location to use, but this is very unlikely to error
                     return expander.ExpandIntoStringLeaveEscaped(metadatum.EvaluatedValueEscaped, ExpanderOptions.ExpandBuiltInMetadata, ElementLocation.EmptyLocation);
                 }
-                else if (null != metadatum)
+                else if (metadatum != null)
                 {
                     return metadatum.EvaluatedValueEscaped;
                 }
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 0886986ce08..ef40362e4eb 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -198,7 +198,7 @@ internal IDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> TaskReg
         {
             get
             {
-                if (null == _taskRegistrations)
+                if (_taskRegistrations == null)
                 {
                     _taskRegistrations = CreateRegisteredTaskDictionary();
                 }
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index fd92582d161..755391e0e38 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -530,12 +530,12 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
                 {
                     DisplayDeferredProjectStartedEvent(e.BuildEventContext);
                 }
-                if (null != e.Properties)
+                if (e.Properties != null)
                 {
                     WriteProperties(e, e.Properties);
                 }
 
-                if (null != e.Items)
+                if (e.Items != null)
                 {
                     WriteItems(e, e.Items);
                 }
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index 31a0cd14deb..1f38a87c5e8 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -265,13 +265,13 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
 
             if (Verbosity == LoggerVerbosity.Diagnostic && showItemAndPropertyList)
             {
-                if (null != e.Properties)
+                if (e.Properties != null)
                 {
                     var propertyList = ExtractPropertyList(e.Properties);
                     WriteProperties(propertyList);
                 }
 
-                if (null != e.Items)
+                if (e.Items != null)
                 {
                     SortedList itemList = ExtractItemList(e.Items);
                     WriteItems(itemList);
diff --git a/src/Build/Utilities/RegistryKeyWrapper.cs b/src/Build/Utilities/RegistryKeyWrapper.cs
index 6aefdb6e990..5db9a22e37c 100644
--- a/src/Build/Utilities/RegistryKeyWrapper.cs
+++ b/src/Build/Utilities/RegistryKeyWrapper.cs
@@ -202,7 +202,7 @@ public virtual RegistryKeyWrapper OpenSubKey(string name)
         /// <returns></returns>
         public virtual bool Exists()
         {
-            return null != WrappedKey;
+            return WrappedKey != null;
         }
 
         /// <summary>
diff --git a/src/Deprecated/Conversion/AdditionalOptionsParser.cs b/src/Deprecated/Conversion/AdditionalOptionsParser.cs
index 6edd700bbd5..1695918ddb2 100644
--- a/src/Deprecated/Conversion/AdditionalOptionsParser.cs
+++ b/src/Deprecated/Conversion/AdditionalOptionsParser.cs
@@ -208,7 +208,7 @@ ProjectPropertyGroupElement configPropertyGroup
         )
         {
             // Trivial case
-            if (null == additionalOptionsValue)
+            if (additionalOptionsValue == null)
             {
                 return;
             }
@@ -300,7 +300,7 @@ private bool ExtractSwitchInfo(CompSwitchInfo compSwitchInfo, string compSwitch)
                 }
             }
             // No no... we arent dealing with the correct switchInfo
-            if (null == matchedID)
+            if (matchedID == null)
             {
                 return false;
             }
@@ -325,7 +325,7 @@ private bool ExtractSwitchInfo(CompSwitchInfo compSwitchInfo, string compSwitch)
                             switchVal = false;
                         }
                     }
-                    if (null != switchVal)
+                    if (switchVal != null)
                     {
                         compSwitchInfo.SwitchValue = switchVal;
                     }
@@ -340,7 +340,7 @@ private bool ExtractSwitchInfo(CompSwitchInfo compSwitchInfo, string compSwitch)
                     {
                         switchVal = compSwitch.Substring(matchedID.Length);
                     }
-                    if (null != switchVal)
+                    if (switchVal != null)
                     {
                         compSwitchInfo.SwitchValue = switchVal;
                     }
@@ -352,7 +352,7 @@ private bool ExtractSwitchInfo(CompSwitchInfo compSwitchInfo, string compSwitch)
 
                 case SwitchValueType.SVT_MultiString:
                     Debug.Assert(
-                        null != compSwitchInfo.SwitchValue,
+                        compSwitchInfo.SwitchValue != null,
                         "Non null switch value expected for a multistring switch: " + matchedID
                     );
 
@@ -360,7 +360,7 @@ private bool ExtractSwitchInfo(CompSwitchInfo compSwitchInfo, string compSwitch)
                     {
                         switchVal = compSwitch.Substring(matchedID.Length);
                     }
-                    if (null != switchVal)
+                    if (switchVal != null)
                     {
                         ((StringBuilder)(compSwitchInfo.SwitchValue)).Append(switchVal);
                         ((StringBuilder)(compSwitchInfo.SwitchValue)).Append(";");
@@ -398,7 +398,7 @@ private void PopulatePropertyGroup(ProjectPropertyGroupElement configPropertyGro
                 switch (compSwitchInfo.SwitchValueType)
                 {
                     case SwitchValueType.SVT_Boolean:
-                        if (null != compSwitchInfo.SwitchValue)
+                        if (compSwitchInfo.SwitchValue != null)
                         {
                             configPropertyGroup.AddProperty(
                                 propertyName,
@@ -408,7 +408,7 @@ private void PopulatePropertyGroup(ProjectPropertyGroupElement configPropertyGro
                     break;
 
                     case SwitchValueType.SVT_String:
-                        if (null != compSwitchInfo.SwitchValue)
+                        if (compSwitchInfo.SwitchValue != null)
                         {
                             configPropertyGroup.AddProperty(
                                 propertyName,
@@ -418,7 +418,7 @@ private void PopulatePropertyGroup(ProjectPropertyGroupElement configPropertyGro
                     break;
 
                     case SwitchValueType.SVT_MultiString:
-                        Debug.Assert(null != compSwitchInfo.SwitchValue, "Expected non null value for multistring switch");
+                        Debug.Assert(compSwitchInfo.SwitchValue != null, "Expected non null value for multistring switch");
                         if (0 != ((StringBuilder)(compSwitchInfo.SwitchValue)).Length)
                         {
                             configPropertyGroup.AddProperty(
diff --git a/src/Deprecated/Engine/Conditionals/Parser.cs b/src/Deprecated/Engine/Conditionals/Parser.cs
index f42eecf7285..685b1e08d1c 100644
--- a/src/Deprecated/Engine/Conditionals/Parser.cs
+++ b/src/Deprecated/Engine/Conditionals/Parser.cs
@@ -176,7 +176,7 @@ private GenericExpressionNode ExprPrime(string expression, GenericExpressionNode
         private GenericExpressionNode BooleanTerm(string expression)
         {
             GenericExpressionNode node = RelationalExpr(expression);
-            if (null == node)
+            if (node == null)
             {
                 errorPosition = lexer.GetErrorPosition();
                 ProjectErrorUtilities.VerifyThrowInvalidProject(false, this.conditionAttribute, "UnexpectedTokenInCondition", expression, lexer.IsNextString(), errorPosition);
@@ -198,7 +198,7 @@ private GenericExpressionNode BooleanTermPrime(string expression, GenericExpress
             else if (Same(expression, Token.TokenType.And))
             {
                 GenericExpressionNode rhs = RelationalExpr(expression);
-                if (null == rhs)
+                if (rhs == null)
                 {
                     errorPosition = lexer.GetErrorPosition();
                     ProjectErrorUtilities.VerifyThrowInvalidProject(false, this.conditionAttribute, "UnexpectedTokenInCondition", expression, lexer.IsNextString(), errorPosition);
@@ -220,7 +220,7 @@ private GenericExpressionNode RelationalExpr(string expression)
         {
          {
                 GenericExpressionNode lhs = Factor(expression);
-                if (null == lhs)
+                if (lhs == null)
                 {
                     errorPosition = lexer.GetErrorPosition();
                     ProjectErrorUtilities.VerifyThrowInvalidProject(false, this.conditionAttribute, "UnexpectedTokenInCondition", expression, lexer.IsNextString(), errorPosition);
@@ -382,7 +382,7 @@ private bool Same(string expression, Token.TokenType token)
                 if (!lexer.Advance())
                 {
                     errorPosition = lexer.GetErrorPosition();
-                    if (null != lexer.UnexpectedlyFound)
+                    if (lexer.UnexpectedlyFound != null)
                     {
                         ProjectErrorUtilities.VerifyThrowInvalidProject(false, this.conditionAttribute, lexer.GetErrorResource(), expression, errorPosition, lexer.UnexpectedlyFound);
                     }
diff --git a/src/Deprecated/Engine/Engine/BatchingEngine.cs b/src/Deprecated/Engine/Engine/BatchingEngine.cs
index f7665e917bc..e904d7978df 100644
--- a/src/Deprecated/Engine/Engine/BatchingEngine.cs
+++ b/src/Deprecated/Engine/Engine/BatchingEngine.cs
@@ -337,7 +337,7 @@ Dictionary<string, MetadataReference> consumedMetadataReferences
 
                         // If we didn't find a bucket that matches this item, create a new one, adding
                         // this item to the bucket.
-                        if (null == matchingBucket)
+                        if (matchingBucket == null)
                         {
                             matchingBucket = new ItemBucket(itemListsToBeBatched.Keys, itemMetadataValues, lookup, buckets.Count);
 
diff --git a/src/Deprecated/Engine/Engine/BuildResult.cs b/src/Deprecated/Engine/Engine/BuildResult.cs
index a76383ad0e9..2e09508f9b9 100644
--- a/src/Deprecated/Engine/Engine/BuildResult.cs
+++ b/src/Deprecated/Engine/Engine/BuildResult.cs
@@ -232,7 +232,7 @@ internal int TaskTime
         internal void ConvertToTaskItems()
         {
             // If outputsByTarget was null then we dont have to re-create anything as nothing was passed over
-            if (null != outputsByTarget)
+            if (outputsByTarget != null)
             {
                 string[] keys = new string[outputsByTarget.Count];
                 outputsByTarget.Keys.CopyTo(keys, 0);
diff --git a/src/Deprecated/Engine/Engine/Engine.cs b/src/Deprecated/Engine/Engine/Engine.cs
index 17c9eebaee8..7b90112b51b 100644
--- a/src/Deprecated/Engine/Engine/Engine.cs
+++ b/src/Deprecated/Engine/Engine/Engine.cs
@@ -2080,7 +2080,7 @@ private void StartRootProjectBuild(BuildRequest buildRequest, Project project)
                 // There should be no projects in the ProjectManager with the same full path, global properties and tools version
                 // as any of the loaded projects.  If there are, something went badly awry, because
                 // we were supposed to have deleted them after the last build.
-                ErrorUtilities.VerifyThrow(null == this.cacheOfBuildingProjects.GetProject(loadedProject.FullFileName, loadedProject.GlobalProperties, loadedProject.ToolsVersion),
+                ErrorUtilities.VerifyThrow(this.cacheOfBuildingProjects.GetProject(loadedProject.FullFileName, loadedProject.GlobalProperties, loadedProject.ToolsVersion) == null,
                     "Project shouldn't be in ProjectManager already.");
 
                 // Add the loaded project to the list of projects being built, just
diff --git a/src/Deprecated/Engine/Engine/Expander.cs b/src/Deprecated/Engine/Engine/Expander.cs
index 1b383e90847..0b277a679bf 100644
--- a/src/Deprecated/Engine/Engine/Expander.cs
+++ b/src/Deprecated/Engine/Engine/Expander.cs
@@ -906,7 +906,7 @@ private string ExpandRegistryValue(string registryExpression, XmlNode node)
                     object valueFromRegistry = Registry.GetValue(registryKeyName,
                                                                  valueName,
                                                                  null /* default if key or value name is not found */);
-                    if (null != valueFromRegistry)
+                    if (valueFromRegistry != null)
                     {
                         // Convert the result to a string that is reasonable for MSBuild
                         result = ConvertToString(valueFromRegistry);
diff --git a/src/Deprecated/Engine/Engine/Project.cs b/src/Deprecated/Engine/Engine/Project.cs
index 0fd05ada9a1..da38c4e5831 100644
--- a/src/Deprecated/Engine/Engine/Project.cs
+++ b/src/Deprecated/Engine/Engine/Project.cs
@@ -426,7 +426,7 @@ string toolsVersion
                 // If the toolsVersion is null, we will use the value specified in
                 // the Project element's ToolsVersion attribute, or else the default if that
                 // attribute is not present.
-                if (null != toolsVersion)
+                if (toolsVersion != null)
                 {
                     this.ToolsVersion = toolsVersion;
                 }
@@ -3973,7 +3973,7 @@ bool importedProject
                         case XMakeElements.projectExtensions:
                             if (!importedProject)
                             {
-                                ProjectErrorUtilities.VerifyThrowInvalidProject(null == this.projectExtensionsNode, childElement,
+                                ProjectErrorUtilities.VerifyThrowInvalidProject(this.projectExtensionsNode == null, childElement,
                                     "DuplicateProjectExtensions");
                                 this.projectExtensionsNode = childElement;
 
diff --git a/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs b/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
index 1f2265708cb..e6e4d42be8e 100644
--- a/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
+++ b/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
@@ -179,7 +179,7 @@ public virtual RegistryKeyWrapper OpenSubKey(string name)
         /// <returns></returns>
         public virtual bool Exists()
         {
-            return null != WrappedKey;
+            return WrappedKey != null;
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Engine/TaskEngine.cs b/src/Deprecated/Engine/Engine/TaskEngine.cs
index 87c4b14d9b6..50618e45403 100644
--- a/src/Deprecated/Engine/Engine/TaskEngine.cs
+++ b/src/Deprecated/Engine/Engine/TaskEngine.cs
@@ -203,7 +203,7 @@ private AppDomain PrepareAppDomain()
             // here. Instead, NDP will try to Load (not LoadFrom!) the task assembly into our AppDomain, and since
             // we originally used LoadFrom, it will fail miserably not knowing where to find it.
             // We need to temporarily subscribe to the AppDomain.AssemblyResolve event to fix it.
-            if (null == resolver)
+            if (resolver == null)
             {
                 resolver = new TaskEngineAssemblyResolver();
                 resolver.Initialize(TaskClass.Assembly.AssemblyFile);
diff --git a/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs b/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
index c9408a24eff..4b129cf256b 100644
--- a/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
@@ -131,7 +131,7 @@ private ToolsetConfigurationSection ConfigurationSection
         {
             get
             {
-                if (null == configurationSection && !configurationReadAttempted)
+                if (configurationSection == null && !configurationReadAttempted)
                 {
                     try
                     {
@@ -148,7 +148,7 @@ private ToolsetConfigurationSection ConfigurationSection
                         // If section definition is not present and section is also not present, this value is null
                         // If the section definition is not present and section is present, then this value is null
 
-                        if (null != configuration)
+                        if (configuration != null)
                         {
                             configurationSection = configuration.GetSection("msbuildToolsets") as ToolsetConfigurationSection;
                         }
diff --git a/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs b/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
index da82e751c59..f7fe92fa404 100644
--- a/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
@@ -173,7 +173,7 @@ public int Compare(Object a, Object b)
         internal string IndentString(string s, int indent)
         {
             // It's possible the event has a null message
-            if (null == s)
+            if (s == null)
             {
                 s = String.Empty;
             }
diff --git a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 254a37d2b70..4aa273db8c9 100644
--- a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -499,12 +499,12 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
                 {
                     DisplayDeferredProjectStartedEvent(e.BuildEventContext);
                 }
-                if (null != e.Properties)
+                if (e.Properties != null)
                 {
                     WriteProperties(e, e.Properties);          
                 }
 
-                if (null != e.Items)
+                if (e.Items != null)
                 {
                     WriteItems(e, e.Items);
                 }
diff --git a/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs b/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
index e31ed6ddc4b..751e4b0717b 100644
--- a/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
@@ -267,13 +267,13 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
 
             if (Verbosity == LoggerVerbosity.Diagnostic && showItemAndPropertyList)
             {
-                if (null != e.Properties)
+                if (e.Properties != null)
                 {
                     ArrayList propertyList = ExtractPropertyList(e.Properties);
                     WriteProperties(propertyList);
                 }
 
-                if (null != e.Items)
+                if (e.Items != null)
                 {
                     SortedList itemList = ExtractItemList(e.Items);
                     WriteItems(itemList);
diff --git a/src/Deprecated/Engine/Shared/EventArgsFormatting.cs b/src/Deprecated/Engine/Shared/EventArgsFormatting.cs
index 98ef3cf76bb..9a9623e2303 100644
--- a/src/Deprecated/Engine/Shared/EventArgsFormatting.cs
+++ b/src/Deprecated/Engine/Shared/EventArgsFormatting.cs
@@ -207,7 +207,7 @@ int threadId
             }
 
             // A null message is allowed and is to be treated as a blank line.
-            if (null == message)
+            if (message == null)
             {
                 message = String.Empty;
             }
diff --git a/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs b/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
index fb7f123ac0f..156bc7a8437 100644
--- a/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
+++ b/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
@@ -429,14 +429,14 @@ string registryKeyName
                 .LocalMachine
                 .OpenSubKey(registryBaseKeyName);
 
-            if (null == baseKey)
+            if (baseKey == null)
             {
                 return null;
             }
 
             object keyValue = baseKey.GetValue(registryKeyName);
 
-            if (null == keyValue)
+            if (keyValue == null)
             {
                 return null;
             }
diff --git a/src/Deprecated/Engine/Solution/VCWrapperProject.cs b/src/Deprecated/Engine/Solution/VCWrapperProject.cs
index d3f285613c1..fe252f31141 100644
--- a/src/Deprecated/Engine/Solution/VCWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/VCWrapperProject.cs
@@ -265,7 +265,7 @@ private static string GenerateFullPathToTool(RegistryView registryView)
                 string location = TryLocationFromRegistry(baseKey, vs9RegKey, vs9InstallDirValueName,
                     vs9RelativePathToVCBuildLayouts, vs9RelativePathToVCBuildBatch);
 
-                if (null != location)
+                if (location != null)
                 {
                     return location;
                 }
@@ -274,7 +274,7 @@ private static string GenerateFullPathToTool(RegistryView registryView)
                 location = TryLocationFromRegistry(baseKey, vc9RegKey, vc9InstallDirValueName,
                     vc9RelativePathToVCBuildLayouts, vc9RelativePathToVCBuildBatch);
 
-                if (null != location)
+                if (location != null)
                 {
                     return location;
                 }
@@ -325,7 +325,7 @@ private static string TryLocationFromRegistry(RegistryKey root, string subKeyNam
 
                         // if not found in layouts location, try the alternate dir if any,
                         // which contains vcbuild for batch installs
-                        if (null != relativePathFromValueOnBatch)
+                        if (relativePathFromValueOnBatch != null)
                         {
                             vcBuildPath = Path.Combine(rootDir, relativePathFromValueOnBatch);
                             if (File.Exists(vcBuildPath))
diff --git a/src/Framework/XamlTypes/Rule.cs b/src/Framework/XamlTypes/Rule.cs
index caac61eec3a..5893a27acf7 100644
--- a/src/Framework/XamlTypes/Rule.cs
+++ b/src/Framework/XamlTypes/Rule.cs
@@ -422,7 +422,7 @@ public List<Category> EvaluatedCategories
                 // check-lock-check pattern DOESN'T work here because two fields get initialized within this lazy initialization method.
                 lock (_syncObject)
                 {
-                    if (null == _evaluatedCategories)
+                    if (_evaluatedCategories == null)
                     {
                         CreateCategoryNamePropertyListMap();
                     }
@@ -453,7 +453,7 @@ public OrderedDictionary GetPropertiesByCategory()
             // check-lock-check pattern DOESN'T work here because two fields get initialized within this lazy initialization method.
             lock (_syncObject)
             {
-                if (null == _categoryNamePropertyListMap)
+                if (_categoryNamePropertyListMap == null)
                 {
                     CreateCategoryNamePropertyListMap();
                 }
@@ -471,7 +471,7 @@ public IList<BaseProperty> GetPropertiesInCategory(string categoryName)
             // check-lock-check pattern DOESN'T work here because two fields get initialized within this lazy initialization method.
             lock (_syncObject)
             {
-                if (null == _categoryNamePropertyListMap)
+                if (_categoryNamePropertyListMap == null)
                 {
                     CreateCategoryNamePropertyListMap();
                 }
@@ -557,7 +557,7 @@ public IEnumerable<object> GetSchemaObjects(Type type)
         /// </summary>
         private void Initialize()
         {
-            if (null != Properties)
+            if (Properties != null)
             {
                 // Set parent pointers on all containing properties.
                 foreach (BaseProperty property in Properties)
@@ -577,7 +577,7 @@ private void CreateCategoryNamePropertyListMap()
             {
                 _evaluatedCategories = new List<Category>();
 
-                if (null != Categories)
+                if (Categories != null)
                 {
                     _evaluatedCategories.AddRange(Categories);
                 }
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index fdfc6edbf08..1c1f5da8281 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -1816,7 +1816,7 @@ elementFormDefault="qualified">
     <xs:element name="VSTO_TrustAssembliesLocation" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="WarningLevel" type="msb:StringPropertyType" substitutionGroup="msb:Property">
         <xs:annotation>
-            <xs:documentation><!-- _locID_text="WarningLevel" _locComment="" -->integer between 0 and 4 inclusive</xs:documentation>
+            <xs:documentation><!-- _locID_text="WarningLevel" _locComment="" -->integer between 0 and 5 inclusive</xs:documentation>
         </xs:annotation>
     </xs:element>
     <xs:element name="WarningsAsErrors" type="msb:StringPropertyType" substitutionGroup="msb:Property">
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 9c30cde8405..b38501a705f 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -752,7 +752,7 @@ string [] commandLine
             catch (LoggerException e)
             {
                 // display the localized message from the outer exception in canonical format
-                if (null != e.ErrorCode)
+                if (e.ErrorCode != null)
                 {
                     // Brief prefix to indicate that it's a logger failure, and provide the "error" indication
                     Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("LoggerFailurePrefixNoErrorCode", e.ErrorCode, e.Message));
@@ -764,7 +764,7 @@ string [] commandLine
                     Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("LoggerFailurePrefixWithErrorCode", e.Message));
                 }
 
-                if (null != e.InnerException)
+                if (e.InnerException != null)
                 {
                     // write out exception details -- don't bother triggering Watson, because most of these exceptions will be coming
                     // from buggy loggers written by users
diff --git a/src/MSBuildTaskHost/AssemblyInfo.cs b/src/MSBuildTaskHost/AssemblyInfo.cs
index bf85c36e740..34783459140 100644
--- a/src/MSBuildTaskHost/AssemblyInfo.cs
+++ b/src/MSBuildTaskHost/AssemblyInfo.cs
@@ -2,4 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Reflection;
+using System.Runtime.CompilerServices;
 
+[assembly: InternalsVisibleTo("Microsoft.Build.Engine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
diff --git a/src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs b/src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs
new file mode 100644
index 00000000000..e4e16592ca2
--- /dev/null
+++ b/src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs
@@ -0,0 +1,273 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace System.Collections.Immutable
+{
+    static class ImmutableExtensions
+    {
+        public static ImmutableDictionary<K,V> ToImmutableDictionary<K,V>(this IDictionary<K,V> dictionary)
+        {
+            return new ImmutableDictionary<K, V>(dictionary);
+        }
+    }
+
+    static class ImmutableDictionary
+    {
+        internal static ImmutableDictionary<K, V> Create<K, V>(IEqualityComparer<K> comparer)
+        {
+            return new ImmutableDictionary<K, V>(comparer);
+        }
+    }
+
+    /// <summary>
+    /// Inefficient ImmutableDictionary implementation: keep a mutable dictionary and wrap all operations.
+    /// </summary>
+    /// <typeparam name="K"></typeparam>
+    /// <typeparam name="V"></typeparam>
+    sealed class ImmutableDictionary<K, V> : IDictionary<K, V>, IDictionary
+    {
+        /// <summary>
+        /// The underlying dictionary.
+        /// </summary>
+        private Dictionary<K, V> _backing;
+
+        #region Read-only Operations
+
+        public ICollection<K> Keys => _backing.Keys;
+        public ICollection<V> Values => _backing.Values;
+
+        ICollection IDictionary.Keys => _backing.Keys;
+        ICollection IDictionary.Values => _backing.Values;
+
+        public int Count => _backing.Count;
+
+        public V this[K key] => _backing[key];
+
+        public bool IsReadOnly => true;
+        public bool IsFixedSize => true;
+        public bool IsSynchronized => true;
+
+        public object SyncRoot => this;
+
+        public bool TryGetValue(K key, out V value)
+        {
+            return _backing.TryGetValue(key, out value);
+        }
+
+        public bool Contains(KeyValuePair<K, V> item)
+        {
+            return _backing.Contains(item);
+        }
+
+        bool IDictionary.Contains(object key)
+        {
+            return ((IDictionary)_backing).Contains(key);
+        }
+
+        public bool ContainsKey(K key)
+        {
+            return _backing.ContainsKey(key);
+        }
+
+        public IEnumerator<KeyValuePair<K, V>> GetEnumerator()
+        {
+            return _backing.GetEnumerator();
+        }
+
+        IDictionaryEnumerator IDictionary.GetEnumerator()
+        {
+            return _backing.GetEnumerator();
+        }
+
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            return _backing.GetEnumerator();
+        }
+
+        void ICollection<KeyValuePair<K, V>>.CopyTo(KeyValuePair<K, V>[] array, int arrayIndex)
+        {
+            CheckCopyToArguments(array, arrayIndex);
+            foreach (var item in this)
+            {
+                array[arrayIndex++] = item;
+            }
+        }
+
+        void ICollection.CopyTo(Array array, int arrayIndex)
+        {
+            CheckCopyToArguments(array, arrayIndex);
+            foreach (var item in this)
+            {
+                array.SetValue(new DictionaryEntry(item.Key, item.Value), arrayIndex++);
+            }
+        }
+
+        private void CheckCopyToArguments(Array array, int arrayIndex)
+        {
+            if (array == null)
+            {
+                throw new ArgumentNullException(nameof(array));
+            }
+            if (arrayIndex < 0)
+            {
+                throw new ArgumentOutOfRangeException(nameof(arrayIndex));
+            }
+            if (arrayIndex + Count > array.Length)
+            {
+                throw new ArgumentException(nameof(arrayIndex));
+            }
+        }
+
+        #endregion
+
+        #region Write Operations
+
+        internal ImmutableDictionary<K, V> SetItem(K key, V value)
+        {
+            if (TryGetValue(key, out V existingValue) && Object.Equals(existingValue, value))
+            {
+                return this;
+            }
+
+            var clone = new ImmutableDictionary<K, V>(_backing);
+            clone._backing[key] = value;
+
+            return clone;
+        }
+
+        internal ImmutableDictionary<K, V> Remove(K key)
+        {
+            if (!ContainsKey(key))
+            {
+                return this;
+            }
+
+            var clone = new ImmutableDictionary<K, V>(_backing);
+            clone._backing.Remove(key);
+
+            return clone;
+        }
+
+        internal ImmutableDictionary<K, V> Clear()
+        {
+            return new ImmutableDictionary<K, V>(_backing.Comparer);
+        }
+
+        internal ImmutableDictionary()
+        {
+            _backing = new Dictionary<K, V>();
+        }
+
+        internal ImmutableDictionary(IEqualityComparer<K> comparer)
+        {
+            _backing = new Dictionary<K, V>(comparer);
+        }
+
+        internal ImmutableDictionary(IDictionary<K, V> source, IEqualityComparer<K> keyComparer = null)
+        {
+            if (source is ImmutableDictionary<K, V> imm)
+            {
+                _backing = new Dictionary<K, V>(imm._backing, keyComparer ?? imm._backing.Comparer);
+            }
+            else
+            {
+                _backing = new Dictionary<K, V>(source, keyComparer);
+            }
+        }
+
+        internal static ImmutableDictionary<K, V> Empty
+        {
+            get
+            {
+                return new ImmutableDictionary<K, V>();
+            }
+        }
+
+        public IEqualityComparer<K> KeyComparer { get => _backing.Comparer; internal set => throw new NotSupportedException(); }
+
+        internal KeyValuePair<K, V>[] ToArray()
+        {
+            return _backing.ToArray();
+        }
+
+        internal ImmutableDictionary<K, V> AddRange(KeyValuePair<K, V>[] v)
+        {
+            var n = new Dictionary<K, V>(_backing, _backing.Comparer);
+
+            foreach (var item in v)
+            {
+                n.Add(item.Key, item.Value);
+            }
+
+            return new ImmutableDictionary<K, V>(n);
+        }
+
+        internal ImmutableDictionary<K, V> WithComparers(IEqualityComparer<K> keyComparer)
+        {
+            return new ImmutableDictionary<K, V>(_backing, keyComparer);
+        }
+
+        #endregion
+
+        #region Unsupported Operations
+
+        object IDictionary.this[object key]
+        {
+            get { return _backing[(K)key]; }
+            set { throw new NotSupportedException(); }
+        }
+
+        void IDictionary.Add(object key, object value)
+        {
+            throw new NotSupportedException();
+        }
+
+        void IDictionary.Remove(object key)
+        {
+            throw new NotSupportedException();
+        }
+
+        void IDictionary.Clear()
+        {
+            throw new NotSupportedException();
+        }
+
+        V IDictionary<K, V>.this[K key]
+        {
+            get { return _backing[key]; }
+            set { throw new NotSupportedException(); }
+        }
+
+        void IDictionary<K, V>.Add(K key, V value)
+        {
+            throw new NotSupportedException();
+        }
+
+        bool IDictionary<K, V>.Remove(K key)
+        {
+            throw new NotSupportedException();
+        }
+
+        void ICollection<KeyValuePair<K, V>>.Add(KeyValuePair<K, V> item)
+        {
+            throw new NotSupportedException();
+        }
+
+        void ICollection<KeyValuePair<K, V>>.Clear()
+        {
+            throw new NotSupportedException();
+        }
+
+        bool ICollection<KeyValuePair<K, V>>.Remove(KeyValuePair<K, V> item)
+        {
+            throw new NotSupportedException();
+        }
+
+        #endregion
+    }
+}
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index e1639a3ebe1..577b7b4c1d4 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -167,6 +167,7 @@
     <Compile Include="AssemblyResources.cs" />
     <Compile Include="Concurrent\ConcurrentDictionary.cs" />
     <Compile Include="Concurrent\ConcurrentQueue.cs" />
+    <Compile Include="Immutable\ImmutableDictionary.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
     <Compile Include="TypeLoader.cs" />
     <Compile Include="WeakStringCache.Locking.cs" />
@@ -198,7 +199,6 @@
     </Compile>
     <Compile Include="OutOfProcTaskAppDomainWrapper.cs" />
   </ItemGroup>
-  <ItemGroup />
   <ItemGroup>
     <None Include="app.config" />
   </ItemGroup>
diff --git a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
index f2132af28e6..3539d5f540d 100644
--- a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
+++ b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
@@ -40,6 +40,10 @@
     <file src="$X86BinPath$/System.Resources.Extensions.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Runtime.CompilerServices.Unsafe.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Threading.Tasks.Dataflow.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/StreamJson.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/Nerdbank.Streams.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/System.IO.Pipelines.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/Microsoft.VisualStudio.Threading.dll" target="v15.0/bin" />
 
     <file src="$X86BinPath$/MSBuild/Microsoft.Build.Core.xsd" target="v15.0/bin/MSBuild" />
     <file src="$X86BinPath$/MSBuild/Microsoft.Build.CommonTypes.xsd" target="v15.0/bin/MSBuild" />
@@ -94,6 +98,10 @@
     <file src="$X86BinPath$/System.Resources.Extensions.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Runtime.CompilerServices.Unsafe.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Threading.Tasks.Dataflow.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/StreamJson.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/Nerdbank.Streams.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/System.IO.Pipelines.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/Microsoft.VisualStudio.Threading.dll" target="v15.0/bin/amd64" />
 
     <file src="$X86BinPath$/MSBuild/Microsoft.Build.Core.xsd" target="v15.0/bin/amd64/MSBuild" />
     <file src="$X86BinPath$/MSBuild/Microsoft.Build.CommonTypes.xsd" target="v15.0/bin/amd64/MSBuild" />
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 44277b783c7..74b440353ff 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -48,6 +48,10 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Threading.Tasks.Dataflow.dll vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Collections.Immutable.dll vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)StreamJsonRpc.dll vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Nerdbank.Streams.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.IO.Pipelines.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Microsoft.VisualStudio.Threading.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Common.CurrentVersion.targets
   file source=$(X86BinPath)Microsoft.Common.CrossTargeting.targets
   file source=$(X86BinPath)Microsoft.Common.overridetasks
@@ -197,6 +201,10 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Threading.Tasks.Dataflow.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Collections.Immutable.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)StreamJsonRpc.dll vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Nerdbank.Streams.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.IO.Pipelines.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Microsoft.VisualStudio.Threading.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Common.CurrentVersion.targets
   file source=$(X86BinPath)Microsoft.Common.CrossTargeting.targets
   file source=$(X86BinPath)Microsoft.Common.overridetasks
diff --git a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
index cc6b96b05ce..da266d8220e 100644
--- a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
+++ b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
@@ -261,7 +261,7 @@ OpenBaseKey openBaseKey
 
                     string directoryName = getRegistrySubKeyDefaultValue(baseKey, directoryKey.RegistryKey);
 
-                    if (null != directoryName)
+                    if (directoryName != null)
                     {
                         _uniqueDirectoryPaths.Add(directoryName);
                         _directoryNames.Add(new AssemblyFoldersExInfo(hive, view, directoryKey.RegistryKey, directoryName, directoryKey.TargetFrameworkVersion));
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 26da01129da..a2a4dafbf2e 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -657,7 +657,7 @@ internal static int AvoidEndOfHandshakeSignal(int x)
 
         internal static string GetRarPipeName(bool nodeReuse, bool lowPriority)
         {
-            var context = GetHandshakeOptions(true);
+            var context = GetHandshakeOptions(taskHost: true, nodeReuse: nodeReuse, lowPriority: lowPriority, specialNode: true);
             var userName = $"{Environment.UserDomainName}.{Environment.UserName}";
             return $"MSBuild.RAR.{userName}.{(int)context}";
         }
diff --git a/src/Shared/CopyOnWriteDictionary.cs b/src/Shared/CopyOnWriteDictionary.cs
index b884ff4389c..1aec0557596 100644
--- a/src/Shared/CopyOnWriteDictionary.cs
+++ b/src/Shared/CopyOnWriteDictionary.cs
@@ -4,10 +4,14 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using System.Collections.Immutable;
 using System.Diagnostics.CodeAnalysis;
+using System.Linq;
 using System.Runtime.Serialization;
 using Microsoft.Build.Shared;
 
+#nullable enable
+
 namespace Microsoft.Build.Collections
 {
     /// <summary>
@@ -17,14 +21,6 @@ namespace Microsoft.Build.Collections
     /// <typeparam name="K">The key type.</typeparam>
     /// <typeparam name="V">The value type.</typeparam>
     /// <remarks>
-    /// This dictionary works by having a backing dictionary which is ref-counted for each
-    /// COWDictionary which references it.  When a write operation is performed on any
-    /// COWDictionary, we check the reference count on the backing dictionary.  If it is 
-    /// greater than 1, it means any changes we make to it would be visible to other readers.
-    /// Therefore, we clone the backing dictionary and decrement the reference count on the
-    /// original.  From there on we use the cloned dictionary, which now has a reference count
-    /// of 1.
-    ///
     /// Thread safety: for all users, this class is as thread safe as the underlying Dictionary implementation, that is,
     /// safe for concurrent readers or one writer from EACH user. It achieves this by locking itself and cloning before
     /// any write, if it is being shared - i.e., stopping sharing before any writes occur.
@@ -34,31 +30,20 @@ namespace Microsoft.Build.Collections
     /// be run in a separate appdomain.
     /// </comment>
     [Serializable]
-    internal class CopyOnWriteDictionary<K, V> : IDictionary<K, V>, IDictionary
+    internal class CopyOnWriteDictionary<K, V> : IDictionary<K, V>, IDictionary, ISerializable
     {
-#if DEBUG
-        /// <summary>
-        /// When set forces immediate copy
-        /// </summary>
-        private static readonly bool s_forceWrite = (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDFORCECOWCOPY")));
-#endif
-
-        /// <summary>
-        /// The default capacity.
-        /// </summary>
-        private readonly int capacity;
-
         /// <summary>
         /// The backing dictionary.
         /// Lazily created.
         /// </summary>
-        private CopyOnWriteBackingDictionary<K, V> backing;
+        private ImmutableDictionary<K, V> _backing;
 
         /// <summary>
         /// Constructor. Consider supplying a comparer instead.
         /// </summary>
         internal CopyOnWriteDictionary()
         {
+            _backing = ImmutableDictionary<K, V>.Empty;
         }
 
         /// <summary>
@@ -80,19 +65,24 @@ internal CopyOnWriteDictionary(IEqualityComparer<K> keyComparer)
         /// <summary>
         /// Constructor taking a specified comparer for the keys and an initial capacity
         /// </summary>
-        internal CopyOnWriteDictionary(int capacity, IEqualityComparer<K> keyComparer)
+        internal CopyOnWriteDictionary(int capacity, IEqualityComparer<K>? keyComparer)
         {
-            this.capacity = capacity;
-            Comparer = keyComparer;
+            _backing = ImmutableDictionary.Create<K, V>(keyComparer);
         }
 
         /// <summary>
         /// Serialization constructor, for crossing appdomain boundaries
         /// </summary>
-        [SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "info", Justification = "Not needed")]
         [SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "context", Justification = "Not needed")]
         protected CopyOnWriteDictionary(SerializationInfo info, StreamingContext context)
         {
+            object v = info.GetValue(nameof(_backing), typeof(KeyValuePair<K, V>[]));
+
+            object comparer = info.GetValue(nameof(Comparer), typeof(IEqualityComparer<K>));
+
+            var b = ImmutableDictionary.Create<K, V>((IEqualityComparer<K>)comparer);
+
+            _backing = b.AddRange((KeyValuePair<K, V>[])v);
         }
 
         /// <summary>
@@ -100,44 +90,33 @@ protected CopyOnWriteDictionary(SerializationInfo info, StreamingContext context
         /// </summary>
         private CopyOnWriteDictionary(CopyOnWriteDictionary<K, V> that)
         {
-            Comparer = that.Comparer;
-            backing = that.backing;
-            if (backing != null)
-            {
-                lock (((ICollection)backing).SyncRoot)
-                {
-                    backing.AddRef();
-                }
-            }
+            _backing = that._backing;
         }
 
         public CopyOnWriteDictionary(IDictionary<K, V> dictionary)
         {
-            foreach (KeyValuePair<K, V> pair in dictionary)
-            {
-                this[pair.Key] = pair.Value;
-            }
+            _backing = dictionary.ToImmutableDictionary();
         }
 
         /// <summary>
         /// Returns the collection of keys in the dictionary.
         /// </summary>
-        public ICollection<K> Keys => ReadOperation.Keys;
+        public ICollection<K> Keys => ((IDictionary<K, V>)_backing).Keys;
 
         /// <summary>
         /// Returns the collection of values in the dictionary.
         /// </summary>
-        public ICollection<V> Values => ReadOperation.Values;
+        public ICollection<V> Values => ((IDictionary<K, V>)_backing).Values;
 
         /// <summary>
         /// Returns the number of items in the collection.
         /// </summary>
-        public int Count => ReadOperation.Count;
+        public int Count => _backing.Count;
 
         /// <summary>
         /// Returns true if the collection is read-only.
         /// </summary>
-        public bool IsReadOnly => ((IDictionary<K, V>)ReadOperation).IsReadOnly;
+        public bool IsReadOnly => ((IDictionary<K, V>)_backing).IsReadOnly;
 
         /// <summary>
         /// IDictionary implementation
@@ -174,83 +153,13 @@ public CopyOnWriteDictionary(IDictionary<K, V> dictionary)
         /// </summary>
         object ICollection.SyncRoot => this;
 
-        /// <summary>
-        /// A special single dummy instance that always appears empty.
-        /// </summary>
-        internal static CopyOnWriteDictionary<K, V> Dummy { get; } = new CopyOnWriteDictionary<K, V> { _isDummy = true };
-
-        /// <summary>
-        /// Whether this is a dummy instance that always appears empty.
-        /// </summary>
-        internal bool IsDummy
-        {
-            get
-            {
-                if (_isDummy)
-                {
-                    ErrorUtilities.VerifyThrow(backing == null || backing.Count == 0, "count"); // check count without recursion
-                }
-
-                return _isDummy;
-            }
-        }
-
-        private bool _isDummy;
-
         /// <summary>
         /// Comparer used for keys
         /// </summary>
-        internal IEqualityComparer<K> Comparer { get; private set; }
-
-        /// <summary>
-        /// Gets the backing dictionary for reading.
-        /// </summary>
-        private CopyOnWriteBackingDictionary<K, V> ReadOperation
+        internal IEqualityComparer<K> Comparer
         {
-            get
-            {
-                ErrorUtilities.VerifyThrow(!IsDummy || backing == null || backing.Count == 0, "count"); // check count without recursion
-#if DEBUG
-                if (s_forceWrite)
-                {
-                    if (!IsDummy)
-                    {
-                        return WriteOperation;
-                    }
-                }
-#endif
-                if (backing == null)
-                {
-                    return CopyOnWriteBackingDictionary<K, V>.ReadOnlyEmptyInstance;
-                }
-
-                return backing;
-            }
-        }
-
-        /// <summary>
-        /// Gets the backing dictionary for writing.
-        /// </summary>
-        private CopyOnWriteBackingDictionary<K, V> WriteOperation
-        {
-            get
-            {
-                ErrorUtilities.VerifyThrow(!IsDummy, "dummy");
-
-                if (backing == null)
-                {
-                    backing = new CopyOnWriteBackingDictionary<K, V>(capacity, Comparer);
-                }
-                else
-                {
-                    lock (((ICollection)backing).SyncRoot)
-                    {
-                        backing = backing.CloneForWriteIfNecessary();
-                    }
-                }
-
-                return backing;
-            }
+            get => _backing.KeyComparer;
+            private set => _backing = _backing.WithComparers(keyComparer: value);
         }
 
         /// <summary>
@@ -258,28 +167,15 @@ private CopyOnWriteBackingDictionary<K, V> WriteOperation
         /// </summary>
         public V this[K key]
         {
-            get => ReadOperation[key];
+            get => _backing[key];
 
             set
             {
-                if (!IsDummy)
-                {
-                    if (ReadOperation.HasNoClones)
-                    {
-                        WriteOperation[key] = value;
-                    }
-                    else
-                    {
-                        // Try to avoid a clone if it already is present with the same value
-                        if (!ReadOperation.TryGetValue(key, out V existingValue) || !EqualityComparer<V>.Default.Equals(existingValue, value))
-                        {
-                            WriteOperation[key] = value;
-                        }
-                    }
-                }
+                _backing = _backing.SetItem(key, value);
             }
         }
 
+#nullable disable
         /// <summary>
         /// IDictionary implementation
         /// </summary>
@@ -293,16 +189,14 @@ object IDictionary.this[object key]
 
             set => this[(K)key] = (V)value;
         }
+#nullable restore
 
         /// <summary>
         /// Adds a value to the dictionary.
         /// </summary>
         public void Add(K key, V value)
         {
-            if (!IsDummy)
-            {
-                WriteOperation.Add(key, value);
-            }
+            _backing = _backing.SetItem(key, value);
         }
 
         /// <summary>
@@ -310,7 +204,7 @@ public void Add(K key, V value)
         /// </summary>
         public bool ContainsKey(K key)
         {
-            return ReadOperation.ContainsKey(key);
+            return _backing.ContainsKey(key);
         }
 
         /// <summary>
@@ -318,16 +212,11 @@ public bool ContainsKey(K key)
         /// </summary>
         public bool Remove(K key)
         {
-            // Avoid a clone if it's not present
-            if (ReadOperation.HasNoClones || ReadOperation.ContainsKey(key))
-            {
-                if (!IsDummy)
-                {
-                    return WriteOperation.Remove(key);
-                }
-            }
+            ImmutableDictionary<K, V> initial = _backing;
 
-            return false;
+            _backing = _backing.Remove(key);
+
+            return initial != _backing; // whether the removal occured
         }
 
         /// <summary>
@@ -335,7 +224,7 @@ public bool Remove(K key)
         /// </summary>
         public bool TryGetValue(K key, out V value)
         {
-            return ReadOperation.TryGetValue(key, out value);
+            return _backing.TryGetValue(key, out value);
         }
 
         /// <summary>
@@ -343,10 +232,7 @@ public bool TryGetValue(K key, out V value)
         /// </summary>
         public void Add(KeyValuePair<K, V> item)
         {
-            if (!IsDummy)
-            {
-                ((IDictionary<K, V>)WriteOperation).Add(item);
-            }
+            _backing = _backing.SetItem(item.Key, item.Value);
         }
 
         /// <summary>
@@ -354,13 +240,7 @@ public void Add(KeyValuePair<K, V> item)
         /// </summary>
         public void Clear()
         {
-            if (ReadOperation.Count > 0)
-            {
-                if (!IsDummy)
-                {
-                    WriteOperation.Clear();
-                }
-            }
+            _backing = _backing.Clear();
         }
 
         /// <summary>
@@ -368,7 +248,7 @@ public void Clear()
         /// </summary>
         public bool Contains(KeyValuePair<K, V> item)
         {
-            return ((IDictionary<K, V>)ReadOperation).Contains(item);
+            return _backing.Contains(item);
         }
 
         /// <summary>
@@ -376,7 +256,7 @@ public bool Contains(KeyValuePair<K, V> item)
         /// </summary>
         public void CopyTo(KeyValuePair<K, V>[] array, int arrayIndex)
         {
-            ((IDictionary<K, V>)ReadOperation).CopyTo(array, arrayIndex);
+            ((IDictionary<K, V>)_backing).CopyTo(array, arrayIndex);
         }
 
         /// <summary>
@@ -384,16 +264,11 @@ public void CopyTo(KeyValuePair<K, V>[] array, int arrayIndex)
         /// </summary>
         public bool Remove(KeyValuePair<K, V> item)
         {
-            // If it doesn't already contain the key, avoid copying the dictionary.
-            if (ReadOperation.HasNoClones || ReadOperation.ContainsKey(item.Key))
-            {
-                if (!IsDummy)
-                {
-                    return ((IDictionary<K, V>)WriteOperation).Remove(item);
-                }
-            }
+            ImmutableDictionary<K, V> initial = _backing;
+
+            _backing = _backing.Remove(item.Key);
 
-            return false;
+            return initial != _backing; // whether the removal occured
         }
 
         /// <summary>
@@ -401,7 +276,7 @@ public bool Remove(KeyValuePair<K, V> item)
         /// </summary>
         public IEnumerator<KeyValuePair<K, V>> GetEnumerator()
         {
-            return ReadOperation.GetEnumerator();
+            return _backing.GetEnumerator();
         }
 
         /// <summary>
@@ -441,7 +316,7 @@ bool IDictionary.Contains(object key)
         /// </summary>
         IDictionaryEnumerator IDictionary.GetEnumerator()
         {
-            return ((IDictionary)ReadOperation).GetEnumerator();
+            return ((IDictionary)_backing).GetEnumerator();
         }
 
         /// <summary>
@@ -478,113 +353,16 @@ internal CopyOnWriteDictionary<K, V> Clone()
         /// </summary>
         internal bool HasSameBacking(CopyOnWriteDictionary<K, V> other)
         {
-            return ReferenceEquals(other.backing, backing);
+            return ReferenceEquals(other._backing, _backing);
         }
 
-        /// <summary>
-        /// A dictionary which is reference counted to allow several references for read operations, but knows when to clone for
-        /// write operations.
-        /// </summary>
-        /// <typeparam name="K1">The key type.</typeparam>
-        /// <typeparam name="V1">The value type.</typeparam>
-        [Serializable]
-        private class CopyOnWriteBackingDictionary<K1, V1> : Dictionary<K1, V1>
+        public void GetObjectData(SerializationInfo info, StreamingContext context)
         {
-            /// <summary>
-            /// An empty dictionary 
-            /// </summary>
-            [SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Justification = "Error in code analysis.")]
-            private static readonly CopyOnWriteBackingDictionary<K1, V1> s_readOnlyEmptyDictionary = new CopyOnWriteBackingDictionary<K1, V1>();
-
-            /// <summary>
-            /// The reference count. 
-            /// </summary>
-            [SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Justification = "Error in code analysis.")]
-            [NonSerialized]
-            private int _refCount = 1;
-
-            /// <summary>
-            /// Constructor.
-            /// </summary>
-            public CopyOnWriteBackingDictionary(int capacity, IEqualityComparer<K1> comparer)
-                : base(capacity, comparer)
-            {
-                // Tracing.Record("New COWBD");
-            }
-
-            /// <summary>
-            /// Serialization constructor, for crossing appdomain boundaries
-            /// </summary>
-            protected CopyOnWriteBackingDictionary(SerializationInfo info, StreamingContext context)
-                : base(info, context)
-            {
-            }
+            ImmutableDictionary<K, V> snapshot = _backing;
+            KeyValuePair<K, V>[] array = snapshot.ToArray();
 
-            /// <summary>
-            /// Empty constructor.
-            /// </summary>
-            private CopyOnWriteBackingDictionary()
-            {
-            }
-
-            /// <summary>
-            /// Cloning constructor.
-            /// </summary>
-            private CopyOnWriteBackingDictionary(CopyOnWriteBackingDictionary<K1, V1> that)
-                : base(that, that.Comparer)
-            {
-                // Tracing.Record("New COWBD-clone");
-            }
-
-            /// <summary>
-            /// Returns a read-only empty instance.
-            /// </summary>
-            public static CopyOnWriteBackingDictionary<K1, V1> ReadOnlyEmptyInstance => s_readOnlyEmptyDictionary;
-
-            /// <summary>
-            /// Returns true if this collection has no clones.
-            /// </summary>
-            public bool HasNoClones
-            {
-                get
-                {
-                    ErrorUtilities.VerifyThrow(_refCount >= 1, "refCount should not be less than 1.");
-                    return _refCount == 1;
-                }
-            }
-
-            /// <summary>
-            /// Clones backing dictionary if necessary for a write operation.
-            /// </summary>
-            public CopyOnWriteBackingDictionary<K1, V1> CloneForWriteIfNecessary()
-            {
-                if (!HasNoClones)
-                {
-                    _refCount--;
-                    return new CopyOnWriteBackingDictionary<K1, V1>(this);
-                }
-
-                return this;
-            }
-
-            /// <summary>
-            /// Adds a reader-reference to this backing dictionary.
-            /// </summary>
-            public int AddRef()
-            {
-                return ++_refCount;
-            }
-
-            /// <summary>
-            /// Deserialization does not call any constructors, not even
-            /// the parameterless constructor. Therefore since we do not serialize
-            /// this field, we must populate it here.
-            /// </summary>
-            [OnDeserialized]
-            private void OnDeserialized(StreamingContext context)
-            {
-                _refCount = 1;
-            }
+            info.AddValue(nameof(_backing), array);
+            info.AddValue(nameof(Comparer), Comparer);
         }
     }
 }
diff --git a/src/Shared/EventArgsFormatting.cs b/src/Shared/EventArgsFormatting.cs
index a3556a8cc07..f23ffcf69f1 100644
--- a/src/Shared/EventArgsFormatting.cs
+++ b/src/Shared/EventArgsFormatting.cs
@@ -320,7 +320,7 @@ string logOutputProperties
             }
 
             // A null message is allowed and is to be treated as a blank line.
-            if (null == message)
+            if (message == null)
             {
                 message = String.Empty;
             }
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 0b2c088cf98..9d75da4dbab 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -247,9 +247,8 @@ private void InternalDisconnect()
         private void EnqueuePacket(INodePacket packet)
         {
             ErrorUtilities.VerifyThrowArgumentNull(packet, nameof(packet));
-            ErrorUtilities.VerifyThrow(null != _packetQueue, "packetQueue is null");
-            ErrorUtilities.VerifyThrow(null != _packetAvailable, "packetAvailable is null");
-
+            ErrorUtilities.VerifyThrow(_packetQueue != null, "packetQueue is null");
+            ErrorUtilities.VerifyThrow(_packetAvailable != null, "packetAvailable is null");
             _packetQueue.Enqueue(packet);
             _packetAvailable.Set();
         }
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index fe6d67f1c8c..7e27f0e68a2 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -1313,7 +1313,7 @@ public bool LogMessageFromText(string lineOfText, MessageImportance messageImpor
             bool isError = false;
             CanonicalError.Parts messageParts = CanonicalError.Parse(lineOfText);
 
-            if (null == messageParts)
+            if (messageParts == null)
             {
                 // Line was not recognized as a canonical error. Log it as a message.
                 LogMessage(messageImportance, lineOfText);
diff --git a/src/Shared/ToolsetElement.cs b/src/Shared/ToolsetElement.cs
index e08128daad5..4f8451872ab 100644
--- a/src/Shared/ToolsetElement.cs
+++ b/src/Shared/ToolsetElement.cs
@@ -36,7 +36,7 @@ internal static ToolsetConfigurationSection ReadToolsetConfigurationSection(Conf
             // If section definition is present and section is not present, this value is not null
             // If section definition is not present and section is also not present, this value is null
             // If the section definition is not present and section is present, then this value is null
-            if (null != configuration)
+            if (configuration != null)
             {
                 ConfigurationSection msbuildSection = configuration.GetSection("msbuildToolsets");
                 configurationSection = msbuildSection as ToolsetConfigurationSection;
diff --git a/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs b/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
index 22e8352e0f0..3299e18f99f 100644
--- a/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
+++ b/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Construction;
 using Xunit;
+using Shouldly;
 
 namespace Microsoft.Build.UnitTests.OM.Collections
 {
@@ -148,22 +149,22 @@ public void OriginalWritesNotVisibleToClones()
         {
             var dictionary = new CopyOnWriteDictionary<string, string>();
             dictionary["test"] = "1";
-            Assert.Equal("1", dictionary["test"]);
+            dictionary["test"].ShouldBe("1");
 
             var clone = dictionary.Clone();
             var clone2 = dictionary.Clone();
 
-            Assert.True(dictionary.HasSameBacking(clone));
-            Assert.True(dictionary.HasSameBacking(clone2));
+            dictionary.HasSameBacking(clone).ShouldBeTrue();
+            dictionary.HasSameBacking(clone2).ShouldBeTrue();
 
             dictionary["test"] = "2";
 
-            Assert.False(dictionary.HasSameBacking(clone));
-            Assert.False(dictionary.HasSameBacking(clone2));
-            Assert.True(clone.HasSameBacking(clone2));
+            dictionary.HasSameBacking(clone).ShouldBeFalse();
+            dictionary.HasSameBacking(clone2).ShouldBeFalse();
+            clone.HasSameBacking(clone2).ShouldBeTrue();
 
-            Assert.Equal("1", clone["test"]);
-            Assert.Equal("1", clone2["test"]);
+            clone["test"].ShouldBe("1");
+            clone2["test"].ShouldBe("1");
         }
 
         /// <summary>
@@ -235,10 +236,10 @@ public void SerializeDeserialize2()
                 formatter.Serialize(stream, dictionary);
                 stream.Position = 0;
 
-                CopyOnWriteDictionary<string, string> dictionary2 = (CopyOnWriteDictionary<string, string>)formatter.Deserialize(stream);
+                CopyOnWriteDictionary<string, string> deserialized = (CopyOnWriteDictionary<string, string>)formatter.Deserialize(stream);
 
-                Assert.Equal(dictionary.Count, dictionary2.Count);
-                Assert.IsType<MSBuildNameIgnoreCaseComparer>(dictionary2.Comparer);
+                deserialized.Count.ShouldBe(dictionary.Count);
+                deserialized.Comparer.ShouldBeOfType<MSBuildNameIgnoreCaseComparer>();
             }
         }
     }
diff --git a/src/Shared/UnitTests/ImmutableDictionary_Tests.cs b/src/Shared/UnitTests/ImmutableDictionary_Tests.cs
new file mode 100644
index 00000000000..e30a8cc75d1
--- /dev/null
+++ b/src/Shared/UnitTests/ImmutableDictionary_Tests.cs
@@ -0,0 +1,258 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+// We don't automatically run these tests against the BCL implementation of ImmutableDictionary as it would require dual-compiling
+// this file. When making changes to this test, though, it is recommended to run them manually by uncommenting the following line.
+// This helps ensure that the real thing has the same behavior that we expect in our implementation.
+//#define _TEST_BCL_IMMUTABLE_DICTIONARY
+
+extern alias MSBuildTaskHost;
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+
+using Shouldly;
+using Xunit;
+
+#if _TEST_BCL_IMMUTABLE_DICTIONARY
+using ImmutableDictionary = System.Collections.Immutable.ImmutableDictionary<string, string>;
+#else
+using ImmutableDictionary = MSBuildTaskHost::System.Collections.Immutable.ImmutableDictionary<string, string>;
+#endif
+
+namespace Microsoft.Build.UnitTests
+{
+    public class ImmutableDictionary_Tests
+    {
+        private readonly ImmutableDictionary _emptyDict = ImmutableDictionary.Empty;
+
+        [Fact]
+        public void SimplesBoolPropertiesReturnExpectedValues()
+        {
+            ((IDictionary)_emptyDict).IsFixedSize.ShouldBeTrue();
+            ((IDictionary)_emptyDict).IsReadOnly.ShouldBeTrue();
+            ((IDictionary)_emptyDict).IsSynchronized.ShouldBeTrue();
+        }
+
+        [Fact]
+        public void CountReturnsExpectedValue()
+        {
+            _emptyDict.Count.ShouldBe(0);
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+            dict.Count.ShouldBe(1);
+            dict = dict.SetItem("Key2", "Value2");
+            dict.Count.ShouldBe(2);
+            dict = dict.Clear();
+            dict.Count.ShouldBe(0);
+        }
+
+        [Fact]
+        public void IndexerReturnsPreviouslySetItem()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+            dict["Key1"].ShouldBe("Value1");
+            ((IDictionary)dict)["Key1"].ShouldBe("Value1");
+            ((IDictionary<string, string>)dict)["Key1"].ShouldBe("Value1");
+        }
+
+        [Fact]
+        public void IndexerThrowsForItemNotPreviouslySet()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+            Should.Throw<KeyNotFoundException>(() => _ = dict["Key2"]);
+            Should.Throw<KeyNotFoundException>(() => _ = ((IDictionary)dict)["Key2"]);
+            Should.Throw<KeyNotFoundException>(() => _ = ((IDictionary<string, string>)dict)["Key2"]);
+        }
+
+        [Fact]
+        public void ContainsReturnsTrueForPeviouslySetItem()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+            dict.Contains(new KeyValuePair<string, string>("Key1", "Value1")).ShouldBeTrue();
+            dict.ContainsKey("Key1").ShouldBeTrue();
+            ((IDictionary)dict).Contains("Key1").ShouldBeTrue();
+        }
+
+        [Fact]
+        public void ContainsReturnsFalseForItemNotPeviouslySet()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+            dict.Contains(new KeyValuePair<string, string>("Key2", "Value2")).ShouldBeFalse();
+            dict.ContainsKey("Key2").ShouldBeFalse();
+            ((IDictionary)dict).Contains("Key2").ShouldBeFalse();
+        }
+
+        [Fact]
+        public void EnumeratorEnumeratesItems()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+
+            IEnumerator<KeyValuePair<string, string>> enumerator1 = dict.GetEnumerator();
+            int i = 0;
+            while (enumerator1.MoveNext())
+            {
+                i++;
+                enumerator1.Current.Key.ShouldBe("Key1");
+                enumerator1.Current.Value.ShouldBe("Value1");
+            }
+            i.ShouldBe(dict.Count);
+
+            IDictionaryEnumerator enumerator2 = ((IDictionary)dict).GetEnumerator();
+            i = 0;
+            while (enumerator2.MoveNext())
+            {
+                i++;
+                enumerator2.Key.ShouldBe("Key1");
+                enumerator2.Value.ShouldBe("Value1");
+            }
+            i.ShouldBe(dict.Count);
+
+            IEnumerator enumerator3 = ((IEnumerable)dict).GetEnumerator();
+            i = 0;
+            while (enumerator3.MoveNext())
+            {
+                i++;
+                KeyValuePair<string, string> entry = (KeyValuePair<string, string>)enumerator3.Current;
+                entry.Key.ShouldBe("Key1");
+                entry.Value.ShouldBe("Value1");
+            }
+            i.ShouldBe(dict.Count);
+        }
+
+        [Fact]
+        public void CopyToCopiesItemsToArray()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+
+            KeyValuePair<string, string>[] array1 = new KeyValuePair<string, string>[1];
+            ((ICollection<KeyValuePair<string, string>>)dict).CopyTo(array1, 0);
+            array1[0].Key.ShouldBe("Key1");
+            array1[0].Value.ShouldBe("Value1");
+
+            array1 = new KeyValuePair<string, string>[2];
+            ((ICollection<KeyValuePair<string, string>>)dict).CopyTo(array1, 1);
+            array1[1].Key.ShouldBe("Key1");
+            array1[1].Value.ShouldBe("Value1");
+
+            DictionaryEntry[] array2 = new DictionaryEntry[1];
+            ((ICollection)dict).CopyTo(array2, 0);
+            array2[0].Key.ShouldBe("Key1");
+            array2[0].Value.ShouldBe("Value1");
+
+            array2 = new DictionaryEntry[2];
+            ((ICollection)dict).CopyTo(array2, 1);
+            array2[1].Key.ShouldBe("Key1");
+            array2[1].Value.ShouldBe("Value1");
+        }
+
+        [Fact]
+        public void CopyToThrowsOnInvalidInput()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+
+            Should.Throw<ArgumentNullException>(() => ((ICollection<KeyValuePair<string, string>>)dict).CopyTo(null, 0));
+            Should.Throw<ArgumentNullException>(() => ((ICollection)dict).CopyTo(null, 0));
+
+            KeyValuePair<string, string>[] array1 = new KeyValuePair<string, string>[1];
+            DictionaryEntry[] array2 = new DictionaryEntry[1];
+            Should.Throw<ArgumentOutOfRangeException>(() => ((ICollection<KeyValuePair<string, string>>)dict).CopyTo(array1, -1));
+            Should.Throw<ArgumentOutOfRangeException>(() => ((ICollection)dict).CopyTo(array1, -1));
+
+            Should.Throw<ArgumentException>(() => ((ICollection<KeyValuePair<string, string>>)dict).CopyTo(array1, 1));
+            Should.Throw<ArgumentException>(() => ((ICollection)dict).CopyTo(array1, 1));
+        }
+
+        [Fact]
+        public void KeysReturnsKeys()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+
+            ICollection<string> keys1 = ((IDictionary<string, string>)dict).Keys;
+            keys1.ShouldBe(new string[] { "Key1" });
+
+            ICollection keys2 = ((IDictionary)dict).Keys;
+            keys2.ShouldBe(new string[] { "Key1" });
+        }
+
+        [Fact]
+        public void ValuesReturnsValues()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+
+            ICollection<string> values1 = ((IDictionary<string, string>)dict).Values;
+            values1.ShouldBe(new string[] { "Value1" });
+
+            ICollection values2 = ((IDictionary)dict).Values;
+            values2.ShouldBe(new string[] { "Value1" });
+        }
+
+        [Fact]
+        public void SetItemReturnsNewInstanceAfterAdding()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+            dict.ShouldNotBeSameAs(_emptyDict);
+        }
+
+        [Fact]
+        public void SetItemReturnsNewInstanceAfterUpdating()
+        {
+            ImmutableDictionary dict1 = _emptyDict.SetItem("Key1", "Value1");
+            ImmutableDictionary dict2 = dict1.SetItem("Key1", "Value2");
+            dict2.ShouldNotBeSameAs(dict1);
+        }
+
+        [Fact]
+        public void SetItemReturnsSameInstanceWhenItemAlreadyExists()
+        {
+            ImmutableDictionary dict1 = _emptyDict.SetItem("Key1", "Value1");
+            ImmutableDictionary dict2 = dict1.SetItem("Key1", "Value1");
+            dict2.ShouldBeSameAs(dict1);
+        }
+
+        [Fact]
+        public void RemoveReturnsNewInstanceAfterDeleting()
+        {
+            ImmutableDictionary dict1 = _emptyDict.SetItem("Key1", "Value1");
+            ImmutableDictionary dict2 = dict1.Remove("Key1");
+            dict2.ShouldNotBeSameAs(dict1);
+        }
+
+        [Fact]
+        public void RemoveReturnsSameInstanceWhenItemDoesNotExist()
+        {
+            ImmutableDictionary dict1 = _emptyDict.SetItem("Key1", "Value1");
+            ImmutableDictionary dict2 = dict1.Remove("Key2");
+            dict2.ShouldBeSameAs(dict1);
+        }
+
+        [Fact]
+        public void ClearReturnsNewInstance()
+        {
+            ImmutableDictionary dict1 = _emptyDict.SetItem("Key1", "Value1");
+            ImmutableDictionary dict2 = dict1.Clear();
+            dict2.ShouldNotBeSameAs(dict1);
+        }
+
+        [Fact]
+        public void WithComparersCreatesNewInstanceWithSpecifiedKeyComparer()
+        {
+            ImmutableDictionary dict1 = _emptyDict.SetItem("Key1", "Value1");
+            ImmutableDictionary dict2 = dict1.WithComparers(StringComparer.OrdinalIgnoreCase);
+            dict2["KEY1"].ShouldBe("Value1");
+        }
+
+        [Fact]
+        public void AddRangeAddsAllItems()
+        {
+            ImmutableDictionary dict = _emptyDict.AddRange(new KeyValuePair<string, string>[]
+            {
+                new KeyValuePair<string, string>("Key1", "Value1"),
+                new KeyValuePair<string, string>("Key2", "Value2")
+            });
+            dict.Count.ShouldBe(2);
+            dict["Key1"].ShouldBe("Value1");
+            dict["Key2"].ShouldBe("Value2");
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
index 95ffcfdd9b9..655a31544a6 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
@@ -396,11 +396,11 @@ public void ForceSomeOutOfDate()
             }
             finally
             {
-                if (null != firstResx) File.Delete(firstResx);
-                if (null != secondResx) File.Delete(secondResx);
-                if (null != cache) File.Delete(cache);
-                if (null != firstResx) File.Delete(Path.ChangeExtension(firstResx, ".resources"));
-                if (null != secondResx) File.Delete(Path.ChangeExtension(secondResx, ".resources"));
+                if (firstResx != null) File.Delete(firstResx);
+                if (secondResx != null) File.Delete(secondResx);
+                if (cache != null) File.Delete(cache);
+                if (firstResx != null) File.Delete(Path.ChangeExtension(firstResx, ".resources"));
+                if (secondResx != null) File.Delete(Path.ChangeExtension(secondResx, ".resources"));
             }
         }
 
@@ -1272,10 +1272,10 @@ public void FailedResXReader()
             }
             finally
             {
-                if (null != resxFile1) File.Delete(resxFile1);
-                if (null != resxFile2) File.Delete(resxFile2);
-                if (null != resourcesFile1) File.Delete(resourcesFile1);
-                if (null != resourcesFile2) File.Delete(resourcesFile2);
+                if (resxFile1 != null) File.Delete(resxFile1);
+                if (resxFile2 != null) File.Delete(resxFile2);
+                if (resourcesFile1 != null) File.Delete(resourcesFile1);
+                if (resourcesFile2 != null) File.Delete(resourcesFile2);
             }
         }
 
@@ -1332,10 +1332,10 @@ public void FailedResXReaderWithAllOutputResourcesSpecified()
             }
             finally
             {
-                if (null != resxFile1) File.Delete(resxFile1);
-                if (null != resxFile2) File.Delete(resxFile2);
-                if (null != resourcesFile1) File.Delete(resourcesFile1);
-                if (null != resourcesFile2) File.Delete(resourcesFile2);
+                if (resxFile1 != null) File.Delete(resxFile1);
+                if (resxFile2 != null) File.Delete(resxFile2);
+                if (resourcesFile1 != null) File.Delete(resourcesFile1);
+                if (resourcesFile2 != null) File.Delete(resourcesFile2);
             }
         }
 
@@ -1417,8 +1417,8 @@ public void InvalidStateFile()
             }
             finally
             {
-                if (null != resxFile) File.Delete(resxFile);
-                if (null != resourcesFile) File.Delete(resourcesFile);
+                if (resxFile != null) File.Delete(resxFile);
+                if (resourcesFile != null) File.Delete(resourcesFile);
             }
         }
 
@@ -2118,10 +2118,10 @@ public void StronglyTypedResourceWithMoreThanOneInputResourceFile()
             }
             finally
             {
-                if (null != resxFile) File.Delete(resxFile);
-                if (null != resxFile2) File.Delete(resxFile2);
-                if (null != resxFile) File.Delete(Path.ChangeExtension(resxFile, ".resources"));
-                if (null != resxFile2) File.Delete(Path.ChangeExtension(resxFile2, ".resources"));
+                if (resxFile != null) File.Delete(resxFile);
+                if (resxFile2 != null) File.Delete(resxFile2);
+                if (resxFile != null) File.Delete(Path.ChangeExtension(resxFile, ".resources"));
+                if (resxFile2 != null) File.Delete(Path.ChangeExtension(resxFile2, ".resources"));
             }
         }
 
@@ -2266,7 +2266,7 @@ public void StronglyTypedResourceFilenameWithoutLanguage()
             }
             finally
             {
-                if (null != txtFile) File.Delete(txtFile);
+                if (txtFile != null) File.Delete(txtFile);
             }
         }
 
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index 4a6358c57a5..2beea1736da 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -1615,10 +1615,10 @@ public void FailedResXReader()
             }
             finally
             {
-                if (null != resxFile1) File.Delete(resxFile1);
-                if (null != resxFile2) File.Delete(resxFile2);
-                if (null != resourcesFile1) File.Delete(resourcesFile1);
-                if (null != resourcesFile2) File.Delete(resourcesFile2);
+                if (resxFile1 != null) File.Delete(resxFile1);
+                if (resxFile2 != null) File.Delete(resxFile2);
+                if (resourcesFile1 != null) File.Delete(resourcesFile1);
+                if (resourcesFile2 != null) File.Delete(resourcesFile2);
             }
         }
 
@@ -1672,10 +1672,10 @@ public void FailedResXReaderWithAllOutputResourcesSpecified()
             }
             finally
             {
-                if (null != resxFile1) File.Delete(resxFile1);
-                if (null != resxFile2) File.Delete(resxFile2);
-                if (null != resourcesFile1) File.Delete(resourcesFile1);
-                if (null != resourcesFile2) File.Delete(resourcesFile2);
+                if (resxFile1 != null) File.Delete(resxFile1);
+                if (resxFile2 != null) File.Delete(resxFile2);
+                if (resourcesFile1 != null) File.Delete(resourcesFile1);
+                if (resourcesFile2 != null) File.Delete(resourcesFile2);
             }
         }
 
@@ -1756,8 +1756,8 @@ public void InvalidStateFile()
             }
             finally
             {
-                if (null != resxFile) File.Delete(resxFile);
-                if (null != resourcesFile) File.Delete(resourcesFile);
+                if (resxFile != null) File.Delete(resxFile);
+                if (resourcesFile != null) File.Delete(resourcesFile);
             }
         }
 
@@ -2486,10 +2486,10 @@ public void StronglyTypedResourceWithMoreThanOneInputResourceFile()
             }
             finally
             {
-                if (null != resxFile) File.Delete(resxFile);
-                if (null != resxFile2) File.Delete(resxFile2);
-                if (null != resxFile) File.Delete(Path.ChangeExtension(resxFile, ".resources"));
-                if (null != resxFile2) File.Delete(Path.ChangeExtension(resxFile2, ".resources"));
+                if (resxFile != null) File.Delete(resxFile);
+                if (resxFile2 != null) File.Delete(resxFile2);
+                if (resxFile != null) File.Delete(Path.ChangeExtension(resxFile, ".resources"));
+                if (resxFile2 != null) File.Delete(Path.ChangeExtension(resxFile2, ".resources"));
             }
         }
 
@@ -2628,7 +2628,7 @@ public void StronglyTypedResourceFilenameWithoutLanguage()
             }
             finally
             {
-                if (null != txtFile) File.Delete(txtFile);
+                if (txtFile != null) File.Delete(txtFile);
             }
         }
 
diff --git a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
index 9e7f41c1eb8..635ccde3e29 100644
--- a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
+++ b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
@@ -619,7 +619,10 @@ public void OneAttributePositionalAndNamedParams()
             string content = File.ReadAllText(task.OutputFile.ItemSpec);
             Console.WriteLine(content);
 
-            CheckContentCSharp(content, @"[assembly: AssemblyTrademarkAttribute(""Microsoft"", Date=""2009"", Copyright=""(C)"")]");
+            // NOTE: order here is defined by dictionary traversal order and may change
+            // based on implementation details there, but named parameters can have different
+            // orders so that's ok.
+            CheckContentCSharp(content, @"[assembly: AssemblyTrademarkAttribute(""Microsoft"", Copyright=""(C)"", Date=""2009"")]");
 
             File.Delete(task.OutputFile.ItemSpec);
         }
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index ac6ff07484a..5bb329dc29d 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -2882,7 +2882,7 @@ private void PopulateSuggestedRedirects(List<DependentAssembly> idealAssemblyRem
                     List<AssemblyNameExtension> conflictVictims = reference.GetConflictVictims();
 
                     // Skip any remapping that has no conflict victims since a redirect will not help.
-                    if (null == conflictVictims || 0 == conflictVictims.Count)
+                    if (conflictVictims == null || 0 == conflictVictims.Count)
                     {
                         continue;
                     }
diff --git a/src/Tasks/AssignCulture.cs b/src/Tasks/AssignCulture.cs
index 096efe5a0b7..f424e70f516 100644
--- a/src/Tasks/AssignCulture.cs
+++ b/src/Tasks/AssignCulture.cs
@@ -169,7 +169,7 @@ public override bool Execute()
                 {
                     Debug.Assert(false, "Unexpected exception in AssignCulture.Execute. " + 
                         "Please log a MSBuild bug specifying the steps to reproduce the problem. " + 
-                        e.Message);
+                        e);
                     throw;
                 }
 #endif
diff --git a/src/Tasks/CreateItem.cs b/src/Tasks/CreateItem.cs
index 472f4e0c5a8..cb7bd833620 100644
--- a/src/Tasks/CreateItem.cs
+++ b/src/Tasks/CreateItem.cs
@@ -99,7 +99,7 @@ private List<ITaskItem> CreateOutputItems(Dictionary<string, string> metadataTab
                 )
                 {
                     ITaskItem newItem = i;
-                    if (null != metadataTable)
+                    if (metadataTable != null)
                     {
                         foreach (KeyValuePair<string, string> nameAndValue in metadataTable)
                         {
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index c9b2b8fd43b..5fc96169dcf 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -834,7 +834,7 @@ public override bool Execute()
                             this.StronglyTypedClassName = process.StronglyTypedClassName; // in case a default was chosen
                             this.StronglyTypedFileName = process.StronglyTypedFilename;   // in case a default was chosen
                             _stronglyTypedResourceSuccessfullyCreated = process.StronglyTypedResourceSuccessfullyCreated;
-                            if (null != process.UnsuccessfullyCreatedOutFiles)
+                            if (process.UnsuccessfullyCreatedOutFiles != null)
                             {
                                 foreach (string item in process.UnsuccessfullyCreatedOutFiles)
                                 {
@@ -1067,7 +1067,7 @@ private bool ComputePathToResGen()
             {
                 _resgenPath = ToolLocationHelper.GetPathToDotNetFrameworkSdkFile("resgen.exe", TargetDotNetFrameworkVersion.Version35);
 
-                if (null == _resgenPath && ExecuteAsTool)
+                if (_resgenPath == null && ExecuteAsTool)
                 {
                     Log.LogErrorWithCodeFromResources("General.PlatformSDKFileNotFound", "resgen.exe",
                         ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(TargetDotNetFrameworkVersion.Version35),
@@ -1085,7 +1085,7 @@ private bool ComputePathToResGen()
                     ExecuteAsTool);
             }
 
-            if (null == _resgenPath && !ExecuteAsTool)
+            if (_resgenPath == null && !ExecuteAsTool)
             {
                 // if Resgen.exe is not installed, just use the filename
                 _resgenPath = String.Empty;
@@ -2356,7 +2356,7 @@ internal ArrayList UnsuccessfullyCreatedOutFiles
         {
             get
             {
-                if (null == _unsuccessfullyCreatedOutFiles)
+                if (_unsuccessfullyCreatedOutFiles == null)
                 {
                     _unsuccessfullyCreatedOutFiles = new ArrayList();
                 }
diff --git a/src/Tasks/RCWForCurrentContext.cs b/src/Tasks/RCWForCurrentContext.cs
index c8944fa05b1..0511c385cb1 100644
--- a/src/Tasks/RCWForCurrentContext.cs
+++ b/src/Tasks/RCWForCurrentContext.cs
@@ -79,7 +79,7 @@ public T RCW
         {
             get
             {
-                if (null == _rcwForCurrentCtx)
+                if (_rcwForCurrentCtx == null)
                 {
                     throw new ObjectDisposedException("RCWForCurrentCtx");
                 }
@@ -108,7 +108,7 @@ private void CleanupComObject()
         {
             try
             {
-                if (null != _rcwForCurrentCtx &&
+                if (_rcwForCurrentCtx != null &&
                     _shouldReleaseRCW &&
                     Marshal.IsComObject(_rcwForCurrentCtx))
                 {
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index 89ed55d4c40..2fd1310d355 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -490,7 +490,7 @@ private bool ComputePathToTlbImp()
             {
                 _tlbimpPath = GetPathToSDKFileWithCurrentlyTargetedArchitecture("TlbImp.exe", TargetDotNetFrameworkVersion.Version35, VisualStudioVersion.VersionLatest);
 
-                if (null == _tlbimpPath && ExecuteAsTool)
+                if (_tlbimpPath == null && ExecuteAsTool)
                 {
                     Log.LogErrorWithCodeFromResources("General.PlatformSDKFileNotFound", "TlbImp.exe",
                         ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(TargetDotNetFrameworkVersion.Version35, VisualStudioVersion.VersionLatest),
@@ -502,7 +502,7 @@ private bool ComputePathToTlbImp()
                 _tlbimpPath = SdkToolsPathUtility.GeneratePathToTool(SdkToolsPathUtility.FileInfoExists, TargetProcessorArchitecture, SdkToolsPath, "TlbImp.exe", Log, ExecuteAsTool);
             }
 
-            if (null == _tlbimpPath && !ExecuteAsTool)
+            if (_tlbimpPath == null && !ExecuteAsTool)
             {
                 // if TlbImp.exe is not installed, just use the filename
                 _tlbimpPath = "TlbImp.exe";
@@ -539,7 +539,7 @@ private bool ComputePathToAxImp()
                 // We want to use the copy of AxImp corresponding to our targeted architecture if possible.  
                 _aximpPath = GetPathToSDKFileWithCurrentlyTargetedArchitecture("AxImp.exe", targetAxImpVersion, VisualStudioVersion.VersionLatest);
 
-                if (null == _aximpPath)
+                if (_aximpPath == null)
                 {
                     Log.LogErrorWithCodeFromResources("General.PlatformSDKFileNotFound", "AxImp.exe",
                         ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(targetAxImpVersion, VisualStudioVersion.VersionLatest),
diff --git a/src/Tasks/SdkToolsPathUtility.cs b/src/Tasks/SdkToolsPathUtility.cs
index bac55b5daee..c9efaf7cde9 100644
--- a/src/Tasks/SdkToolsPathUtility.cs
+++ b/src/Tasks/SdkToolsPathUtility.cs
@@ -110,7 +110,7 @@ internal static string GeneratePathToTool(FileExists fileExists, string currentA
             // Fall back and see if we can find it with the toolsLocation helper methods. This is not optimal because 
             // the location they are looking at is based on when the Microsoft.Build.Utilities.dll was compiled
             // but it is better than nothing.
-            if (null == pathToTool || !fileExists(pathToTool))
+            if (pathToTool == null || !fileExists(pathToTool))
             {
                 pathToTool = FindSDKToolUsingToolsLocationHelper(toolName);
 
diff --git a/src/Tasks/XamlTaskFactory/TaskParser.cs b/src/Tasks/XamlTaskFactory/TaskParser.cs
index cb0e46abcb3..ad7d411177f 100644
--- a/src/Tasks/XamlTaskFactory/TaskParser.cs
+++ b/src/Tasks/XamlTaskFactory/TaskParser.cs
@@ -177,7 +177,7 @@ internal bool ParseXamlDocument(TextReader reader, string desiredRule)
             ErrorUtilities.VerifyThrowArgumentLength(desiredRule, nameof(desiredRule));
 
             object rootObject = XamlServices.Load(reader);
-            if (null != rootObject)
+            if (rootObject != null)
             {
                 XamlTypes.ProjectSchemaDefinitions schemas = rootObject as XamlTypes.ProjectSchemaDefinitions;
                 if (schemas != null)
diff --git a/src/Utilities.UnitTests/TaskItem_Tests.cs b/src/Utilities.UnitTests/TaskItem_Tests.cs
index 49c97bdefbc..04e90914861 100644
--- a/src/Utilities.UnitTests/TaskItem_Tests.cs
+++ b/src/Utilities.UnitTests/TaskItem_Tests.cs
@@ -379,13 +379,22 @@ public void RemoteTaskItem()
                     itemsInThisAppDomain[i].ItemSpec.ShouldBe(creator.CreatedTaskItems[i].ItemSpec);
                     itemsInThisAppDomain[i].MetadataCount.ShouldBe(creator.CreatedTaskItems[i].MetadataCount + 1);
 
+                    Dictionary<string, string> creatorMetadata = new Dictionary<string, string>(creator.CreatedTaskItems[i].MetadataCount);
                     foreach (string metadatum in creator.CreatedTaskItems[i].MetadataNames)
+                    {
+                        creatorMetadata[metadatum] = creator.CreatedTaskItems[i].GetMetadata(metadatum);
+                    }
+
+                    Dictionary<string, string> metadataInThisAppDomain = new Dictionary<string, string>(itemsInThisAppDomain[i].MetadataCount);
+                    foreach (string metadatum in itemsInThisAppDomain[i].MetadataNames)
                     {
                         if (!string.Equals("OriginalItemSpec", metadatum))
                         {
-                            itemsInThisAppDomain[i].GetMetadata(metadatum).ShouldBe(creator.CreatedTaskItems[i].GetMetadata(metadatum));
+                            metadataInThisAppDomain[metadatum] = itemsInThisAppDomain[i].GetMetadata(metadatum);
                         }
                     }
+
+                    metadataInThisAppDomain.ShouldBe(creatorMetadata, ignoreOrder: true);
                 }
             }
             finally
diff --git a/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs b/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
index 9a2e54ae2bb..bf5eeb2a250 100644
--- a/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
+++ b/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
@@ -200,7 +200,7 @@ nor is this
             }
             finally
             {
-                if (null != file) File.Delete(file);
+                if (file != null) File.Delete(file);
             }
         }
 
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 78311278ac0..93ec1767db9 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -607,7 +607,7 @@ string responseFileSwitch
 
             // Generally we won't set a working directory, and it will use the current directory
             string workingDirectory = GetWorkingDirectory();
-            if (null != workingDirectory)
+            if (workingDirectory != null)
             {
                 startInfo.WorkingDirectory = workingDirectory;
             }
@@ -615,7 +615,7 @@ string responseFileSwitch
             // Old style environment overrides
 #pragma warning disable 0618 // obsolete
             Dictionary<string, string> envOverrides = EnvironmentOverride;
-            if (null != envOverrides)
+            if (envOverrides != null)
             {
                 foreach (KeyValuePair<string, string> entry in envOverrides)
                 {
@@ -1453,7 +1453,7 @@ public override bool Execute()
                 // Old style environment overrides
 #pragma warning disable 0618 // obsolete
                 Dictionary<string, string> envOverrides = EnvironmentOverride;
-                if (null != envOverrides)
+                if (envOverrides != null)
                 {
                     foreach (KeyValuePair<string, string> entry in envOverrides)
                     {
