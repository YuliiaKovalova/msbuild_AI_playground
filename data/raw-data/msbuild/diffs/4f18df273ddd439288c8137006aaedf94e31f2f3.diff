diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index 81b331862cc..2b80c13bf04 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -147,7 +147,7 @@ jobs:
 - job: CoreBootstrappedOnLinux
   displayName: "Linux Core"
   pool:
-    vmImage: 'ubuntu-16.04'
+    vmImage: 'ubuntu-latest'
   steps:
   - bash: . 'eng/cibuild_bootstrapped_msbuild.sh'
     displayName: CI Build
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 24aaf5ea389..19786f1ce94 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -5,9 +5,9 @@
       <Uri>https://github.com/dotnet/arcade</Uri>
       <Sha>cca78ffe3eefdc217e43c2421f2f23355f16da2d</Sha>
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="5.10.0-rc.7240">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.0.0-preview.1.66">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>dca1d060f38e1e02f6bfca41e25f081f19fd534b</Sha>
+      <Sha>e84a10e4b0e6bccce7421af020728d9bbc3e64e0</Sha>
     </Dependency>
     <Dependency Name="Microsoft.Extensions.DependencyModel" Version="6.0.0-preview.2.21154.6">
       <Uri>https://github.com/dotnet/runtime</Uri>
diff --git a/eng/Versions.props b/eng/Versions.props
index d95841adc65..23e6def3907 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -31,7 +31,7 @@
     <DotNetCliVersion>6.0.100-preview.2.21155.3</DotNetCliVersion>
     <MicrosoftExtensionsDependencyModelVersion>6.0.0-preview.2.21154.6</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftNetCompilersToolsetVersion>4.0.0-1.21277.15</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>5.10.0-rc.7240</NuGetBuildTasksVersion>
+    <NuGetBuildTasksVersion>6.0.0-preview.1.66</NuGetBuildTasksVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
index d8a78e04125..a75f66a8753 100644
--- a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
@@ -70,6 +70,7 @@ public BuildEventContext(int submissionId, int nodeId, int evaluationId, int pro
         public override int GetHashCode() { throw null; }
         public static bool operator ==(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) { throw null; }
         public static bool operator !=(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) { throw null; }
+        public override string ToString() { throw null; }
     }
     public partial class BuildFinishedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
     {
@@ -580,11 +581,21 @@ public TargetSkippedEventArgs(string message, params object[] messageArgs) { }
         public string Condition { get { throw null; } set { } }
         public string EvaluatedCondition { get { throw null; } set { } }
         public override string Message { get { throw null; } }
+        public Microsoft.Build.Framework.BuildEventContext OriginalBuildEventContext { get { throw null; } set { } }
         public bool OriginallySucceeded { get { throw null; } set { } }
         public string ParentTarget { get { throw null; } set { } }
+        public Microsoft.Build.Framework.TargetSkipReason SkipReason { get { throw null; } set { } }
         public string TargetFile { get { throw null; } set { } }
         public string TargetName { get { throw null; } set { } }
     }
+    public enum TargetSkipReason
+    {
+        None = 0,
+        PreviouslyBuiltSuccessfully = 1,
+        PreviouslyBuiltUnsuccessfully = 2,
+        OutputsUpToDate = 3,
+        ConditionWasFalse = 4,
+    }
     public partial class TargetStartedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
     {
         protected TargetStartedEventArgs() { }
@@ -652,6 +663,8 @@ public partial class TaskStartedEventArgs : Microsoft.Build.Framework.BuildStatu
         protected TaskStartedEventArgs() { }
         public TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName) { }
         public TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, System.DateTime eventTimestamp) { }
+        public int ColumnNumber { get { throw null; } }
+        public int LineNumber { get { throw null; } }
         public override string Message { get { throw null; } }
         public string ProjectFile { get { throw null; } }
         public string TaskFile { get { throw null; } }
diff --git a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
index 2fd1301abb1..b4eefc32fab 100644
--- a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
@@ -70,6 +70,7 @@ public BuildEventContext(int submissionId, int nodeId, int evaluationId, int pro
         public override int GetHashCode() { throw null; }
         public static bool operator ==(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) { throw null; }
         public static bool operator !=(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) { throw null; }
+        public override string ToString() { throw null; }
     }
     public partial class BuildFinishedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
     {
@@ -579,11 +580,21 @@ public TargetSkippedEventArgs(string message, params object[] messageArgs) { }
         public string Condition { get { throw null; } set { } }
         public string EvaluatedCondition { get { throw null; } set { } }
         public override string Message { get { throw null; } }
+        public Microsoft.Build.Framework.BuildEventContext OriginalBuildEventContext { get { throw null; } set { } }
         public bool OriginallySucceeded { get { throw null; } set { } }
         public string ParentTarget { get { throw null; } set { } }
+        public Microsoft.Build.Framework.TargetSkipReason SkipReason { get { throw null; } set { } }
         public string TargetFile { get { throw null; } set { } }
         public string TargetName { get { throw null; } set { } }
     }
+    public enum TargetSkipReason
+    {
+        None = 0,
+        PreviouslyBuiltSuccessfully = 1,
+        PreviouslyBuiltUnsuccessfully = 2,
+        OutputsUpToDate = 3,
+        ConditionWasFalse = 4,
+    }
     public partial class TargetStartedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
     {
         protected TargetStartedEventArgs() { }
@@ -651,6 +662,8 @@ public partial class TaskStartedEventArgs : Microsoft.Build.Framework.BuildStatu
         protected TaskStartedEventArgs() { }
         public TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName) { }
         public TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, System.DateTime eventTimestamp) { }
+        public int ColumnNumber { get { throw null; } }
+        public int LineNumber { get { throw null; } }
         public override string Message { get { throw null; } }
         public string ProjectFile { get { throw null; } }
         public string TaskFile { get { throw null; } }
diff --git a/scripts/Deploy-MSBuild.ps1 b/scripts/Deploy-MSBuild.ps1
index c9bc90217fe..ae7b4abd563 100644
--- a/scripts/Deploy-MSBuild.ps1
+++ b/scripts/Deploy-MSBuild.ps1
@@ -48,7 +48,7 @@ Write-Host "Existing MSBuild assemblies backed up to $BackupFolder"
 if ($runtime -eq "Desktop") {
     $targetFramework = "net472"
 } else {
-    $targetFramework = "net5.0"
+    $targetFramework = "net6.0"
 }
 
 $bootstrapBinDirectory = "artifacts\bin\MSBuild.Bootstrap\$configuration\$targetFramework"
@@ -60,6 +60,19 @@ $filesToCopyToBin = @(
     FileToCopy "$bootstrapBinDirectory\Microsoft.Build.Utilities.Core.dll"
     FileToCopy "$bootstrapBinDirectory\Microsoft.NET.StringTools.dll"
 
+    FileToCopy "$bootstrapBinDirectory\Microsoft.Bcl.AsyncInterfaces.dll"
+    FileToCopy "$bootstrapBinDirectory\System.Buffers.dll"
+    FileToCopy "$bootstrapBinDirectory\System.Collections.Immutable.dll"
+    FileToCopy "$bootstrapBinDirectory\System.Memory.dll"
+    FileToCopy "$bootstrapBinDirectory\System.Numerics.Vectors.dll"
+    FileToCopy "$bootstrapBinDirectory\System.Resources.Extensions.dll"
+    FileToCopy "$bootstrapBinDirectory\System.Runtime.CompilerServices.Unsafe.dll"
+    FileToCopy "$bootstrapBinDirectory\System.Text.Encodings.Web.dll"
+    FileToCopy "$bootstrapBinDirectory\System.Text.Json.dll"
+    FileToCopy "$bootstrapBinDirectory\System.Threading.Tasks.Dataflow.dll"
+    FileToCopy "$bootstrapBinDirectory\System.Threading.Tasks.Extensions.dll"
+    FileToCopy "$bootstrapBinDirectory\System.ValueTuple.dll"
+
     FileToCopy "$bootstrapBinDirectory\en\Microsoft.Build.resources.dll" "en"
     FileToCopy "$bootstrapBinDirectory\en\Microsoft.Build.Tasks.Core.resources.dll" "en"
     FileToCopy "$bootstrapBinDirectory\en\Microsoft.Build.Utilities.Core.resources.dll" "en"
@@ -87,6 +100,7 @@ $filesToCopyToBin = @(
 if ($runtime -eq "Desktop") {
     $runtimeSpecificFiles = @(
         FileToCopy "$bootstrapBinDirectory\MSBuild.exe"
+        FileToCopy "$bootstrapBinDirectory\MSBuild.exe.config"
         FileToCopy "artifacts\bin\Microsoft.Build.Conversion\$configuration\$targetFramework\Microsoft.Build.Conversion.Core.dll"
         FileToCopy "artifacts\bin\Microsoft.Build.Engine\$configuration\$targetFramework\Microsoft.Build.Engine.dll"
 
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index d428e3fdac6..ac9b733f8d2 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -553,7 +553,7 @@ public void LogTaskStarted(BuildEventContext targetBuildEventContext, string tas
         /// <param name="projectFile">The project file</param>
         /// <param name="projectFileOfTaskNode">The project file containing the task node.</param>
         /// <returns>The task logging context</returns>
-        public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode)
+        public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, int line, int column)
         {
             return new BuildEventContext(0, 0, 0, 0);
         }
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index a3137f5b399..78d73604056 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -52,6 +52,7 @@ public void VerifyEventType()
             BuildErrorEventArgs error = new BuildErrorEventArgs("SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender");
             TargetStartedEventArgs targetStarted = new TargetStartedEventArgs("message", "help", "targetName", "ProjectFile", "targetFile");
             TargetFinishedEventArgs targetFinished = new TargetFinishedEventArgs("message", "help", "targetName", "ProjectFile", "targetFile", true);
+            TargetSkippedEventArgs targetSkipped = CreateTargetSkipped();
             ProjectStartedEventArgs projectStarted = new ProjectStartedEventArgs(-1, "message", "help", "ProjectFile", "targetNames", null, null, null);
             ProjectFinishedEventArgs projectFinished = new ProjectFinishedEventArgs("message", "help", "ProjectFile", true);
             ExternalProjectStartedEventArgs externalStartedEvent = new ExternalProjectStartedEventArgs("message", "help", "senderName", "projectFile", "targetNames");
@@ -69,6 +70,7 @@ public void VerifyEventType()
             VerifyLoggingPacket(error, LoggingEventType.BuildErrorEvent);
             VerifyLoggingPacket(targetStarted, LoggingEventType.TargetStartedEvent);
             VerifyLoggingPacket(targetFinished, LoggingEventType.TargetFinishedEvent);
+            VerifyLoggingPacket(targetSkipped, LoggingEventType.TargetSkipped);
             VerifyLoggingPacket(projectStarted, LoggingEventType.ProjectStartedEvent);
             VerifyLoggingPacket(projectFinished, LoggingEventType.ProjectFinishedEvent);
             VerifyLoggingPacket(evaluationStarted, LoggingEventType.ProjectEvaluationStartedEvent);
@@ -158,6 +160,8 @@ private static TaskParameterEventArgs CreateTaskParameter()
                 items,
                 logItemMetadata: true,
                 DateTime.MinValue);
+            result.LineNumber = 30000;
+            result.ColumnNumber = 50;
 
             // normalize line endings as we can't rely on the line endings of NodePackets_Tests.cs
             Assert.Equal(@"Task Parameter:
@@ -174,6 +178,26 @@ private static TaskParameterEventArgs CreateTaskParameter()
             return result;
         }
 
+        private static TargetSkippedEventArgs CreateTargetSkipped()
+        {
+            var result = new TargetSkippedEventArgs(message: null)
+            {
+                BuildReason = TargetBuiltReason.DependsOn,
+                SkipReason = TargetSkipReason.PreviouslyBuiltSuccessfully,
+                BuildEventContext = CreateBuildEventContext(),
+                OriginalBuildEventContext = CreateBuildEventContext(),
+                Condition = "$(Condition) == 'true'",
+                EvaluatedCondition = "'true' == 'true'",
+                Importance = MessageImportance.Normal,
+                OriginallySucceeded = true,
+                ProjectFile = "1.proj",
+                TargetFile = "1.proj",
+                TargetName = "Build",
+                ParentTarget = "ParentTarget"
+            };
+            return result;
+        }
+
         /// <summary>
         /// Tests serialization of LogMessagePacket with each kind of event type.
         /// </summary>
@@ -195,7 +219,11 @@ public void TestTranslation()
                     new BuildFinishedEventArgs("Message", "Keyword", true),
                     new BuildStartedEventArgs("Message", "Help"),
                     new BuildMessageEventArgs("Message", "help", "sender", MessageImportance.Low),
-                    new TaskStartedEventArgs("message", "help", "projectFile", "taskFile", "taskName"),
+                    new TaskStartedEventArgs("message", "help", "projectFile", "taskFile", "taskName")
+                    {
+                        LineNumber = 345,
+                        ColumnNumber = 123
+                    },
                     new TaskFinishedEventArgs("message", "help", "projectFile", "taskFile", "taskName", true),
                     new TaskCommandLineEventArgs("commandLine", "taskName", MessageImportance.Low),
                     CreateTaskParameter(),
@@ -207,7 +235,8 @@ public void TestTranslation()
                     new ProjectFinishedEventArgs("message", "help", "ProjectFile", true),
                     new ExternalProjectStartedEventArgs("message", "help", "senderName", "projectFile", "targetNames"),
                     CreateProjectEvaluationStarted(),
-                    CreateProjectEvaluationFinished()
+                    CreateProjectEvaluationFinished(),
+                    CreateTargetSkipped()
                 };
 
                 foreach (BuildEventArgs arg in testArgs)
@@ -412,6 +441,23 @@ private void CompareLogMessagePackets(LogMessagePacket left, LogMessagePacket ri
                     Assert.Equal(leftTargetStarted.TargetName, rightTargetStarted.TargetName);
                     break;
 
+                case LoggingEventType.TargetSkipped:
+                    TargetSkippedEventArgs leftTargetSkipped = left.NodeBuildEvent.Value.Value as TargetSkippedEventArgs;
+                    TargetSkippedEventArgs rightTargetSkipped = right.NodeBuildEvent.Value.Value as TargetSkippedEventArgs;
+                    Assert.Equal(leftTargetSkipped.BuildReason, rightTargetSkipped.BuildReason);
+                    Assert.Equal(leftTargetSkipped.SkipReason, rightTargetSkipped.SkipReason);
+                    Assert.Equal(leftTargetSkipped.BuildEventContext, rightTargetSkipped.BuildEventContext);
+                    Assert.Equal(leftTargetSkipped.OriginalBuildEventContext, rightTargetSkipped.OriginalBuildEventContext);
+                    Assert.Equal(leftTargetSkipped.Condition, rightTargetSkipped.Condition);
+                    Assert.Equal(leftTargetSkipped.EvaluatedCondition, rightTargetSkipped.EvaluatedCondition);
+                    Assert.Equal(leftTargetSkipped.Importance, rightTargetSkipped.Importance);
+                    Assert.Equal(leftTargetSkipped.OriginallySucceeded, rightTargetSkipped.OriginallySucceeded);
+                    Assert.Equal(leftTargetSkipped.ProjectFile, rightTargetSkipped.ProjectFile);
+                    Assert.Equal(leftTargetSkipped.TargetFile, rightTargetSkipped.TargetFile);
+                    Assert.Equal(leftTargetSkipped.TargetName, rightTargetSkipped.TargetName);
+                    Assert.Equal(leftTargetSkipped.ParentTarget, rightTargetSkipped.ParentTarget);
+                    break;
+
                 case LoggingEventType.TaskCommandLineEvent:
                     TaskCommandLineEventArgs leftCommand = left.NodeBuildEvent.Value.Value as TaskCommandLineEventArgs;
                     TaskCommandLineEventArgs rightCommand = right.NodeBuildEvent.Value.Value as TaskCommandLineEventArgs;
@@ -433,6 +479,8 @@ private void CompareLogMessagePackets(LogMessagePacket left, LogMessagePacket ri
                     Assert.Equal(leftTaskParameter.Message, rightTaskParameter.Message);
                     Assert.Equal(leftTaskParameter.BuildEventContext, rightTaskParameter.BuildEventContext);
                     Assert.Equal(leftTaskParameter.Timestamp, rightTaskParameter.Timestamp);
+                    Assert.Equal(leftTaskParameter.LineNumber, rightTaskParameter.LineNumber);
+                    Assert.Equal(leftTaskParameter.ColumnNumber, rightTaskParameter.ColumnNumber);
                     break;
 
                 case LoggingEventType.TaskFinishedEvent:
@@ -454,6 +502,8 @@ private void CompareLogMessagePackets(LogMessagePacket left, LogMessagePacket ri
                     Assert.Equal(leftTaskStarted.ProjectFile, rightTaskStarted.ProjectFile);
                     Assert.Equal(leftTaskStarted.TaskFile, rightTaskStarted.TaskFile);
                     Assert.Equal(leftTaskStarted.TaskName, rightTaskStarted.TaskName);
+                    Assert.Equal(leftTaskStarted.LineNumber, rightTaskStarted.LineNumber);
+                    Assert.Equal(leftTaskStarted.ColumnNumber, rightTaskStarted.ColumnNumber);
                     break;
 
                 default:
diff --git a/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs b/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
index 346da6846b9..67950cf5716 100644
--- a/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
@@ -89,8 +89,12 @@ public void TestTranslationNoException()
         {
             TaskItem item = new TaskItem("foo", "bar.proj");
             item.SetMetadata("a", "b");
+            var buildEventContext = new Framework.BuildEventContext(1, 2, 3, 4, 5, 6, 7);
 
-            TargetResult result = new TargetResult(new TaskItem[] { item }, BuildResultUtilities.GetStopWithErrorResult());
+            TargetResult result = new TargetResult(
+                new TaskItem[] { item },
+                BuildResultUtilities.GetStopWithErrorResult(),
+                buildEventContext);
 
             ((ITranslatable)result).Translate(TranslationHelpers.GetWriteTranslator());
             TargetResult deserializedResult = TargetResult.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -98,6 +102,7 @@ public void TestTranslationNoException()
             Assert.Equal(result.ResultCode, deserializedResult.ResultCode);
             Assert.True(TranslationHelpers.CompareCollections(result.Items, deserializedResult.Items, TaskItemComparer.Instance));
             Assert.True(TranslationHelpers.CompareExceptions(result.Exception, deserializedResult.Exception));
+            Assert.Equal(result.OriginalBuildEventContext, deserializedResult.OriginalBuildEventContext);
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index f1b59b48e1f..e169cbfb8e2 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -160,11 +160,15 @@ public void RoundtripTaskStartedEventArgs()
                 projectFile: "C:\\project.proj",
                 taskFile: "C:\\common.targets",
                 taskName: "Csc");
+            args.LineNumber = 42;
+            args.ColumnNumber = 999;
 
             Roundtrip(args,
                 e => e.ProjectFile,
                 e => e.TaskFile,
-                e => e.TaskName);
+                e => e.TaskName,
+                e => e.LineNumber.ToString(),
+                e => e.ColumnNumber.ToString());
         }
 
         [Fact]
@@ -327,11 +331,15 @@ public void RoundtripTaskParameterEventArgs()
                 new TaskItemData("ItemSpec2", Enumerable.Range(1,3).ToDictionary(i => i.ToString(), i => i.ToString() + "value"))
             };
             var args = new TaskParameterEventArgs(TaskParameterMessageKind.TaskOutput, "ItemName", items, true, DateTime.MinValue);
+            args.LineNumber = 265;
+            args.ColumnNumber = 6;
 
             Roundtrip(args,
                 e => e.Kind.ToString(),
                 e => e.ItemType,
                 e => e.LogItemMetadata.ToString(),
+                e => e.LineNumber.ToString(),
+                e => e.ColumnNumber.ToString(),
                 e => TranslationHelpers.GetItemsString(e.Items));
         }
 
@@ -443,20 +451,31 @@ public void RoundtripTargetSkippedEventArgs()
                 ProjectFile = "foo.csproj",
                 TargetName = "target",
                 ParentTarget = "bar",
-                BuildReason = TargetBuiltReason.DependsOn
+                BuildReason = TargetBuiltReason.DependsOn,
+                SkipReason = TargetSkipReason.PreviouslyBuiltSuccessfully,
+                Condition = "$(condition) == true",
+                EvaluatedCondition = "true == true",
+                OriginalBuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6, 7),
+                OriginallySucceeded = false,
+                TargetFile = "foo.csproj"
             };
 
             Roundtrip(args,
+                e => e.BuildEventContext.ToString(),
                 e => e.ParentTarget,
                 e => e.Importance.ToString(),
                 e => e.LineNumber.ToString(),
                 e => e.ColumnNumber.ToString(),
-                e => e.LineNumber.ToString(),
                 e => e.Message,
                 e => e.ProjectFile,
                 e => e.TargetFile,
                 e => e.TargetName,
-                e => e.BuildReason.ToString());
+                e => e.BuildReason.ToString(),
+                e => e.SkipReason.ToString(),
+                e => e.Condition,
+                e => e.EvaluatedCondition,
+                e => e.OriginalBuildEventContext.ToString(),
+                e => e.OriginallySucceeded.ToString());
         }
 
         [Fact]
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index ef032ea7791..45341070715 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -410,6 +410,8 @@ public void BeginBuild(BuildParameters parameters)
         {
             lock (_syncLock)
             {
+                AttachDebugger();
+
                 // Check for build in progress.
                 RequireState(BuildManagerState.Idle, "BuildInProgress");
 
@@ -558,6 +560,37 @@ void InitializeCaches()
             }
         }
 
+        private void AttachDebugger()
+        {
+            if (Debugger.IsAttached)
+            {
+                return;
+            }
+
+            var processNameToBreakInto = Environment.GetEnvironmentVariable("MSBuildDebugBuildManagerOnStartProcessName");
+            var thisProcessMatchesName = string.IsNullOrWhiteSpace(processNameToBreakInto) || Process.GetCurrentProcess().ProcessName.Contains(processNameToBreakInto);
+
+            if (!thisProcessMatchesName)
+            {
+                return;
+            }
+
+            switch (Environment.GetEnvironmentVariable("MSBuildDebugBuildManagerOnStart"))
+            {
+#if FEATURE_DEBUG_LAUNCH
+                case "1":
+                    Debugger.Launch();
+                    break;
+#endif
+                case "2":
+                    // Sometimes easier to attach rather than deal with JIT prompt
+                    Process currentProcess = Process.GetCurrentProcess();
+                    Console.WriteLine($"Waiting for debugger to attach ({currentProcess.MainModule.FileName} PID {currentProcess.Id}).  Press enter to continue...");
+                    Console.ReadLine();
+                    break;
+            }
+        }
+
         private void InitializeProjectCacheService(
             ProjectCacheDescriptor pluginDescriptor,
             CancellationToken cancellationToken)
diff --git a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
index 4116039458a..f10fbf8dc50 100644
--- a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
+++ b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
@@ -4,10 +4,11 @@
 using System;
 using System.Collections.Concurrent;
 using System.Linq;
+using System.Reflection;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using System.Reflection;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -103,5 +104,17 @@ public static T FactoryForDeserializingTypeWithName<T>(this ITranslator translat
 
             return (T) targetInstanceChild;
         }
+
+        public static void TranslateOptionalBuildEventContext(this ITranslator translator, ref BuildEventContext buildEventContext)
+        {
+            if (translator.Mode == TranslationDirection.ReadFromStream)
+            {
+                buildEventContext = translator.Reader.ReadOptionalBuildEventContext();
+            }
+            else
+            {
+                translator.Writer.WriteOptionalBuildEventContext(buildEventContext);
+            }
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index 7d489ca8b21..86d4e070d33 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -525,8 +525,10 @@ void LogProjectEvaluationFinished(
         /// <param name="taskName">The name of the task</param>
         /// <param name="projectFile">The project file which is being built</param>
         /// <param name="projectFileOfTaskNode">The file in which the task is defined - typically a .targets file</param>
+        /// <param name="line">The line number in the file where the task invocation is located.</param>
+        /// <param name="column">The column number in the file where the task invocation is located.</param>
         /// <returns>The task build event context</returns>
-        BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode);
+        BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, int line, int column);
 
         /// <summary>
         /// Log that a task has just completed
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index 77de428ef63..13e70263473 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -754,9 +754,11 @@ public void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskN
         /// <param name="taskName">Task Name</param>
         /// <param name="projectFile">Project file being built</param>
         /// <param name="projectFileOfTaskNode">Project file which contains the task</param>
+        /// <param name="line">The line number in the file where the task invocation is located.</param>
+        /// <param name="column">The column number in the file where the task invocation is located.</param>
         /// <returns>The build event context for the task.</returns>
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
-        public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode)
+        public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, int line, int column)
         {
             lock (_lockObject)
             {
@@ -782,6 +784,8 @@ public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventConte
                             taskName
                         );
                     buildEvent.BuildEventContext = taskBuildEventContext;
+                    buildEvent.LineNumber = line;
+                    buildEvent.ColumnNumber = column;
                     ProcessLoggingEvent(buildEvent);
                 }
 
diff --git a/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs b/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
index 0b55b80359a..6852343e9be 100644
--- a/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
@@ -86,18 +86,26 @@ internal void LogRequestHandledFromCache(BuildRequest request, BuildRequestConfi
         {
             ProjectLoggingContext projectLoggingContext = LogProjectStarted(request, configuration);
 
-            // When pulling a request from the cache, we want to make sure we log a task skipped message for any targets which 
-            // were used to build the request including default and inital targets.
+            // When pulling a request from the cache, we want to make sure we log a target skipped event for any targets which
+            // were used to build the request including default and initial targets.
             foreach (string target in configuration.GetTargetsUsedToBuildRequest(request))
             {
-                projectLoggingContext.LogComment
-                    (
-                        MessageImportance.Low,
-                        result[target].ResultCode == TargetResultCode.Failure ? "TargetAlreadyCompleteFailure" : "TargetAlreadyCompleteSuccess",
-                        target
-                    );
-
-                if (result[target].ResultCode == TargetResultCode.Failure)
+                var targetResult = result[target];
+                bool isFailure = targetResult.ResultCode == TargetResultCode.Failure;
+
+                var skippedTargetEventArgs = new TargetSkippedEventArgs(message: null)
+                {
+                    BuildEventContext = projectLoggingContext.BuildEventContext,
+                    TargetName = target,
+                    BuildReason = TargetBuiltReason.None,
+                    SkipReason = isFailure ? TargetSkipReason.PreviouslyBuiltUnsuccessfully : TargetSkipReason.PreviouslyBuiltSuccessfully,
+                    OriginallySucceeded = !isFailure,
+                    OriginalBuildEventContext = (targetResult as TargetResult)?.OriginalBuildEventContext
+                };
+
+                projectLoggingContext.LogBuildEvent(skippedTargetEventArgs);
+
+                if (targetResult.ResultCode == TargetResultCode.Failure)
                 {
                     break;
                 }
diff --git a/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
index 6dc62c389ce..51c266e6485 100644
--- a/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
@@ -69,7 +69,9 @@ internal TaskLoggingContext(TargetLoggingContext targetLoggingContext, string pr
                 targetLoggingContext.BuildEventContext,
                 _taskName,
                 projectFullPath,
-                task.Location.File
+                task.Location.File,
+                task.Location.Line,
+                task.Location.Column
                 );
             this.IsValid = true;
         }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 66195775b22..109cb49b9bf 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -218,7 +218,8 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                     TaskParameterMessageKind.AddItem,
                     child.ItemType,
                     itemsToAdd,
-                    logItemMetadata: true);
+                    logItemMetadata: true,
+                    child.Location);
             }
 
             // Now add the items we created to the lookup.
@@ -261,7 +262,8 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
                         TaskParameterMessageKind.RemoveItem,
                         child.ItemType,
                         itemsToRemove,
-                        logItemMetadata: true);
+                        logItemMetadata: true,
+                        child.Location);
                 }
 
                 bucket.Lookup.RemoveItems(itemsToRemove);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
index 4f7440b61e3..b672732ee39 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
@@ -252,7 +252,8 @@ internal static void LogTaskParameter(
             TaskParameterMessageKind messageKind,
             string itemType,
             IList items,
-            bool logItemMetadata)
+            bool logItemMetadata,
+            IElementLocation location = null)
         {
             var args = CreateTaskParameterEventArgs(
                 loggingContext.BuildEventContext,
@@ -260,7 +261,10 @@ internal static void LogTaskParameter(
                 itemType,
                 items,
                 logItemMetadata,
-                DateTime.UtcNow);
+                DateTime.UtcNow,
+                location?.Line ?? 0,
+                location?.Column ?? 0);
+
             loggingContext.LogBuildEvent(args);
         }
 
@@ -270,7 +274,9 @@ internal static TaskParameterEventArgs CreateTaskParameterEventArgs(
             string itemType,
             IList items,
             bool logItemMetadata,
-            DateTime timestamp)
+            DateTime timestamp,
+            int line = 0,
+            int column = 0)
         {
             // Only create a snapshot of items if we use AppDomains
 #if FEATURE_APPDOMAIN
@@ -284,6 +290,8 @@ internal static TaskParameterEventArgs CreateTaskParameterEventArgs(
                 logItemMetadata,
                 timestamp);
             args.BuildEventContext = buildEventContext;
+            args.LineNumber = line;
+            args.ColumnNumber = column;
             return args;
         }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index 21bdf35cb01..6b4b24dfa81 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -555,6 +555,7 @@ private bool CheckSkipTarget(ref bool stopProcessingStack, TargetEntry currentTa
                 {
                     // If we've already dealt with this target and it didn't skip, let's log appropriately
                     // Otherwise we don't want anything more to do with it.
+                    bool success = targetResult.ResultCode == TargetResultCode.Success;
                     var skippedTargetEventArgs = new TargetSkippedEventArgs(message: null)
                     {
                         BuildEventContext = _projectLoggingContext.BuildEventContext,
@@ -562,7 +563,9 @@ private bool CheckSkipTarget(ref bool stopProcessingStack, TargetEntry currentTa
                         TargetFile = currentTargetEntry.Target.Location.File,
                         ParentTarget = currentTargetEntry.ParentEntry?.Target.Name,
                         BuildReason = currentTargetEntry.BuildReason,
-                        OriginallySucceeded = targetResult.ResultCode == TargetResultCode.Success
+                        OriginallySucceeded = success,
+                        SkipReason = success ? TargetSkipReason.PreviouslyBuiltSuccessfully : TargetSkipReason.PreviouslyBuiltUnsuccessfully,
+                        OriginalBuildEventContext = targetResult.OriginalBuildEventContext
                     };
 
                     _projectLoggingContext.LogBuildEvent(skippedTargetEventArgs);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index f7543d5d91d..1314a3c173a 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -354,7 +354,10 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
 
             if (!condition)
             {
-                _targetResult = new TargetResult(Array.Empty<TaskItem>(), new WorkUnitResult(WorkUnitResultCode.Skipped, WorkUnitActionCode.Continue, null));
+                _targetResult = new TargetResult(
+                    Array.Empty<TaskItem>(),
+                    new WorkUnitResult(WorkUnitResultCode.Skipped, WorkUnitActionCode.Continue, null),
+                    projectLoggingContext.BuildEventContext);
                 _state = TargetEntryState.Completed;
 
                 if (!projectLoggingContext.LoggingService.OnlyLogCriticalEvents)
@@ -375,6 +378,7 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
                         TargetFile = _target.Location.File,
                         ParentTarget = ParentEntry?.Target?.Name,
                         BuildReason = BuildReason,
+                        SkipReason = TargetSkipReason.ConditionWasFalse,
                         Condition = _target.Condition,
                         EvaluatedCondition = expanded
                     };
@@ -640,14 +644,11 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                 }
                 finally
                 {
-                       
-                    
-                        // log the last target finished since we now have the target outputs. 
-                        targetLoggingContext?.LogTargetBatchFinished(projectFullPath, targetSuccess, targetOutputItems?.Count > 0 ? targetOutputItems : null);
-                    
+                    // log the last target finished since we now have the target outputs. 
+                    targetLoggingContext?.LogTargetBatchFinished(projectFullPath, targetSuccess, targetOutputItems?.Count > 0 ? targetOutputItems : null);
                 }
 
-                _targetResult = new TargetResult(targetOutputItems.ToArray(), aggregateResult);
+                _targetResult = new TargetResult(targetOutputItems.ToArray(), aggregateResult, targetLoggingContext?.BuildEventContext);
 
                 if (aggregateResult.ResultCode == WorkUnitResultCode.Failed && aggregateResult.ActionCode == WorkUnitActionCode.Stop)
                 {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
index 335dcf77097..9013bc11272 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
@@ -233,9 +233,17 @@ out ItemDictionary<ProjectItemInstance> upToDateTargetInputs
 
                 if (result == DependencyAnalysisResult.SkipUpToDate)
                 {
-                    _loggingService.LogComment(_buildEventContext, MessageImportance.Normal,
-                        "SkipTargetBecauseOutputsUpToDate",
-                        TargetToAnalyze.Name);
+                    var skippedTargetEventArgs = new TargetSkippedEventArgs(message: null)
+                    {
+                        BuildEventContext = _buildEventContext,
+                        TargetName = TargetToAnalyze.Name,
+                        BuildReason = TargetBuiltReason.None,
+                        SkipReason = TargetSkipReason.OutputsUpToDate,
+                        OriginallySucceeded = true,
+                        Importance = MessageImportance.Normal
+                    };
+
+                    _loggingService.LogBuildEvent(skippedTargetEventArgs);
 
                     // Log the target inputs & outputs
                     if (!_loggingService.OnlyLogCriticalEvents)
@@ -337,7 +345,7 @@ private static string GetIncrementalBuildReason(DependencyAnalysisLogDetail logD
 
         /// <summary>
         /// Extract only the unique inputs and outputs from all the inputs and outputs gathered
-        /// during depedency analysis
+        /// during dependency analysis
         /// </summary>
         private void LogUniqueInputsAndOutputs()
         {
diff --git a/src/Build/BackEnd/Shared/TargetResult.cs b/src/Build/BackEnd/Shared/TargetResult.cs
index 3eb907062e7..4969cdb7664 100644
--- a/src/Build/BackEnd/Shared/TargetResult.cs
+++ b/src/Build/BackEnd/Shared/TargetResult.cs
@@ -44,17 +44,30 @@ public class TargetResult : ITargetResult, ITranslatable
         /// </summary>
         private CacheInfo _cacheInfo;
 
+        /// <summary>
+        /// The (possibly null) <see cref="BuildEventContext"/> from the original target build
+        /// </summary>
+        private BuildEventContext _originalBuildEventContext;
+
         /// <summary>
         /// Initializes the results with specified items and result.
         /// </summary>
         /// <param name="items">The items produced by the target.</param>
         /// <param name="result">The overall result for the target.</param>
-        internal TargetResult(TaskItem[] items, WorkUnitResult result)
+        /// <param name="originalBuildEventContext">The original build event context from when the target was first built, if available.
+        /// Non-null when creating a <see cref="TargetResult"/> after building the target initially (or skipping due to false condition).
+        /// Null when the <see cref="TargetResult"/> is being created in other scenarios:
+        ///  * Target that never ran because a dependency had an error
+        ///  * in <see cref="ITargetBuilderCallback.LegacyCallTarget"/> when Cancellation was requested
+        ///  * in ProjectCache.CacheResult.ConstructBuildResult
+        /// </param>
+        internal TargetResult(TaskItem[] items, WorkUnitResult result, BuildEventContext originalBuildEventContext = null)
         {
             ErrorUtilities.VerifyThrowArgumentNull(items, nameof(items));
             ErrorUtilities.VerifyThrowArgumentNull(result, nameof(result));
             _items = items;
             _result = result;
+            _originalBuildEventContext = originalBuildEventContext;
         }
 
         /// <summary>
@@ -130,6 +143,11 @@ internal WorkUnitResult WorkUnitResult
             get => _result;
         }
 
+        /// <summary>
+        /// The (possibly null) <see cref="BuildEventContext"/> from the original target build
+        /// </summary>
+        internal BuildEventContext OriginalBuildEventContext => _originalBuildEventContext;
+
         /// <summary>
         /// Sets or gets a flag indicating whether or not a failure results should cause the build to fail.
         /// </summary>
@@ -253,6 +271,7 @@ private void InternalTranslate(ITranslator translator)
             translator.Translate(ref _result, WorkUnitResult.FactoryForDeserialization);
             translator.Translate(ref _targetFailureDoesntCauseBuildFailure);
             translator.Translate(ref _afterTargetsHaveFailed);
+            translator.TranslateOptionalBuildEventContext(ref _originalBuildEventContext);
             TranslateItems(translator);
         }
 
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 1008f556b19..bbd383cfe9b 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -66,7 +66,11 @@ internal class SolutionProjectGenerator
             "Build",
             "Clean",
             "Rebuild",
-            "Publish"
+            "Publish",
+            "ValidateSolutionConfiguration",
+            "ValidateToolsVersions",
+            "ValidateProjects",
+            "GetSolutionConfigurationContents"
             );
 
 #if FEATURE_ASPNET_COMPILER
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 6bcd2951e2d..dac426db8b4 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -48,7 +48,10 @@ public sealed class BinaryLogger : ILogger
         // version 13:
         //   - don't log Message where it can be recovered
         //   - log arguments for LazyFormattedBuildEventArgs
-        internal const int FileFormatVersion = 13;
+        //   - TargetSkippedEventArgs: added OriginallySucceeded, Condition, EvaluatedCondition
+        // version 14:
+        //   - TargetSkippedEventArgs: added SkipReason, OriginalBuildEventContext
+        internal const int FileFormatVersion = 14;
 
         private Stream stream;
         private BinaryWriter binaryWriter;
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 47c1f6d8306..1d285b47c6b 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -297,6 +297,8 @@ private BuildEventArgs ReadTargetSkippedEventArgs()
             string condition = null;
             string evaluatedCondition = null;
             bool originallySucceeded = false;
+            TargetSkipReason skipReason = TargetSkipReason.None;
+            BuildEventContext originalBuildEventContext = null;
             if (fileFormatVersion >= 13)
             {
                 condition = ReadOptionalString();
@@ -306,6 +308,12 @@ private BuildEventArgs ReadTargetSkippedEventArgs()
 
             var buildReason = (TargetBuiltReason)ReadInt32();
 
+            if (fileFormatVersion >= 14)
+            {
+                skipReason = (TargetSkipReason)ReadInt32();
+                originalBuildEventContext = binaryReader.ReadOptionalBuildEventContext();
+            }
+
             var e = new TargetSkippedEventArgs(
                 fields.Message,
                 fields.Arguments);
@@ -320,6 +328,8 @@ private BuildEventArgs ReadTargetSkippedEventArgs()
             e.Condition = condition;
             e.EvaluatedCondition = evaluatedCondition;
             e.OriginallySucceeded = originallySucceeded;
+            e.SkipReason = skipReason;
+            e.OriginalBuildEventContext = originalBuildEventContext;
 
             return e;
         }
@@ -535,6 +545,8 @@ private BuildEventArgs ReadTaskStartedEventArgs()
                 taskFile,
                 taskName,
                 fields.Timestamp);
+            e.LineNumber = fields.LineNumber;
+            e.ColumnNumber = fields.ColumnNumber;
             SetCommonFields(e, fields);
             return e;
         }
@@ -658,7 +670,9 @@ private BuildEventArgs ReadTaskParameterEventArgs()
                 itemType,
                 items,
                 logItemMetadata: true,
-                fields.Timestamp);
+                fields.Timestamp,
+                fields.LineNumber,
+                fields.ColumnNumber);
             e.ProjectFile = fields.ProjectFile;
             return e;
         }
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 20cd4232cb2..f0de05860eb 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -370,7 +370,9 @@ private void Write(TargetFinishedEventArgs e)
         private void Write(TaskStartedEventArgs e)
         {
             Write(BinaryLogRecordKind.TaskStarted);
-            WriteBuildEventArgsFields(e, writeMessage: false);
+            WriteBuildEventArgsFields(e, writeMessage: false, writeLineAndColumn: true);
+            Write(e.LineNumber);
+            Write(e.ColumnNumber);
             WriteDeduplicatedString(e.TaskName);
             WriteDeduplicatedString(e.ProjectFile);
             WriteDeduplicatedString(e.TaskFile);
@@ -445,6 +447,8 @@ private void Write(ProjectImportedEventArgs e)
 
         private void Write(TargetSkippedEventArgs e)
         {
+            ErrorUtilities.VerifyThrow(e.SkipReason != TargetSkipReason.None, "TargetSkippedEventArgs.SkipReason needs to be set");
+
             Write(BinaryLogRecordKind.TargetSkipped);
             WriteMessageFields(e, writeMessage: false);
             WriteDeduplicatedString(e.TargetFile);
@@ -454,6 +458,8 @@ private void Write(TargetSkippedEventArgs e)
             WriteDeduplicatedString(e.EvaluatedCondition);
             Write(e.OriginallySucceeded);
             Write((int)e.BuildReason);
+            Write((int)e.SkipReason);
+            binaryWriter.WriteOptionalBuildEventContext(e.OriginalBuildEventContext);
         }
 
         private void Write(CriticalBuildMessageEventArgs e)
@@ -512,9 +518,14 @@ private void Write(TaskParameterEventArgs e)
             WriteTaskItemList(e.Items, e.LogItemMetadata);
         }
 
-        private void WriteBuildEventArgsFields(BuildEventArgs e, bool writeMessage = true)
+        private void WriteBuildEventArgsFields(BuildEventArgs e, bool writeMessage = true, bool writeLineAndColumn = false)
         {
             var flags = GetBuildEventArgsFieldFlags(e, writeMessage);
+            if (writeLineAndColumn)
+            {
+                flags |= BuildEventArgsFieldFlags.LineNumber | BuildEventArgsFieldFlags.ColumnNumber;
+            }
+
             Write((int)flags);
             WriteBaseFields(e, flags);
         }
diff --git a/src/Framework/BuildEventContext.cs b/src/Framework/BuildEventContext.cs
index edde77d5fbb..0cda93d76c6 100644
--- a/src/Framework/BuildEventContext.cs
+++ b/src/Framework/BuildEventContext.cs
@@ -306,5 +306,9 @@ private bool InternalEquals(BuildEventContext buildEventContext)
         }
         #endregion
 
+        public override string ToString()
+        {
+            return $"Node={NodeId} Submission={SubmissionId} ProjectContext={ProjectContextId} ProjectInstance={ProjectInstanceId} Eval={EvaluationId} Target={TargetId} Task={TaskId}";
+        }
     }
 }
diff --git a/src/Framework/BuildMessageEventArgs.cs b/src/Framework/BuildMessageEventArgs.cs
index 23282a1db87..e84c9ed6c02 100644
--- a/src/Framework/BuildMessageEventArgs.cs
+++ b/src/Framework/BuildMessageEventArgs.cs
@@ -302,7 +302,11 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         /// <summary>
         /// Importance of the message
         /// </summary>
-        public MessageImportance Importance => importance;
+        public MessageImportance Importance
+        {
+            get => importance;
+            internal set => importance = value;
+        }
 
         /// <summary>
         /// The custom sub-type of the event.
@@ -322,12 +326,20 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         /// <summary>
         /// Line number of interest in associated file. 
         /// </summary>
-        public int LineNumber => lineNumber;
+        public int LineNumber
+        {
+            get => lineNumber;
+            internal set => lineNumber = value;
+        }
 
         /// <summary>
         /// Column number of interest in associated file. 
         /// </summary>
-        public int ColumnNumber => columnNumber;
+        public int ColumnNumber
+        {
+            get => columnNumber;
+            internal set => columnNumber = value;
+        }
 
         /// <summary>
         /// Ending line number of interest in associated file. 
diff --git a/src/Framework/TargetSkippedEventArgs.cs b/src/Framework/TargetSkippedEventArgs.cs
index 5bad19a7251..d34e468ff32 100644
--- a/src/Framework/TargetSkippedEventArgs.cs
+++ b/src/Framework/TargetSkippedEventArgs.cs
@@ -7,6 +7,37 @@
 
 namespace Microsoft.Build.Framework
 {
+    /// <summary>
+    /// A reason why a target was skipped.
+    /// </summary>
+    public enum TargetSkipReason
+    {
+        /// <summary>
+        /// The target was not skipped or the skip reason was unknown.
+        /// </summary>
+        None,
+
+        /// <summary>
+        /// The target previously built successfully.
+        /// </summary>
+        PreviouslyBuiltSuccessfully,
+
+        /// <summary>
+        /// The target previously built unsuccessfully.
+        /// </summary>
+        PreviouslyBuiltUnsuccessfully,
+
+        /// <summary>
+        /// All the target outputs were up-to-date with respect to their inputs.
+        /// </summary>
+        OutputsUpToDate,
+
+        /// <summary>
+        /// The condition on the target was evaluated as false.
+        /// </summary>
+        ConditionWasFalse
+    }
+
     /// <summary>
     /// Arguments for the target skipped event.
     /// </summary>
@@ -45,6 +76,11 @@ params object[] messageArgs
         {
         }
 
+        /// <summary>
+        /// The reason why the target was skipped.
+        /// </summary>
+        public TargetSkipReason SkipReason { get; set; }
+
         /// <summary>
         /// Gets or sets the name of the target being skipped.
         /// </summary>
@@ -65,10 +101,24 @@ params object[] messageArgs
         /// </summary>
         public TargetBuiltReason BuildReason { get; set; }
 
+        /// <summary>
+        /// Whether the target succeeded originally.
+        /// </summary>
         public bool OriginallySucceeded { get; set; }
 
+        /// <summary>
+        /// <see cref="BuildEventContext"/> describing the original build of the target, or null if not available.
+        /// </summary>
+        public BuildEventContext OriginalBuildEventContext { get; set; }
+
+        /// <summary>
+        /// The condition expression on the target declaration.
+        /// </summary>
         public string Condition { get; set; }
 
+        /// <summary>
+        /// The value of the condition expression as it was evaluated.
+        /// </summary>
         public string EvaluatedCondition { get; set; }
 
         internal override void WriteToStream(BinaryWriter writer)
@@ -81,7 +131,9 @@ internal override void WriteToStream(BinaryWriter writer)
             writer.WriteOptionalString(Condition);
             writer.WriteOptionalString(EvaluatedCondition);
             writer.Write7BitEncodedInt((int)BuildReason);
+            writer.Write7BitEncodedInt((int)SkipReason);
             writer.Write(OriginallySucceeded);
+            writer.WriteOptionalBuildEventContext(OriginalBuildEventContext);
         }
 
         internal override void CreateFromStream(BinaryReader reader, int version)
@@ -94,7 +146,9 @@ internal override void CreateFromStream(BinaryReader reader, int version)
             Condition = reader.ReadOptionalString();
             EvaluatedCondition = reader.ReadOptionalString();
             BuildReason = (TargetBuiltReason)reader.Read7BitEncodedInt();
+            SkipReason = (TargetSkipReason)reader.Read7BitEncodedInt();
             OriginallySucceeded = reader.ReadBoolean();
+            OriginalBuildEventContext = reader.ReadOptionalBuildEventContext();
         }
 
         public override string Message
@@ -107,22 +161,29 @@ public override string Message
                     {
                         if (RawMessage == null)
                         {
-                            if (Condition != null)
-                            {
-                                RawMessage = FormatResourceStringIgnoreCodeAndKeyword(
-                                    "TargetSkippedFalseCondition",
-                                    TargetName,
-                                    Condition,
-                                    EvaluatedCondition);
-                            }
-                            else
+                            RawMessage = SkipReason switch
                             {
-                                RawMessage = FormatResourceStringIgnoreCodeAndKeyword(
-                                    OriginallySucceeded
-                                    ? "TargetAlreadyCompleteSuccess"
-                                    : "TargetAlreadyCompleteFailure",
-                                    TargetName);
-                            }
+                                TargetSkipReason.PreviouslyBuiltSuccessfully or TargetSkipReason.PreviouslyBuiltUnsuccessfully =>
+                                    FormatResourceStringIgnoreCodeAndKeyword(
+                                        OriginallySucceeded
+                                        ? "TargetAlreadyCompleteSuccess"
+                                        : "TargetAlreadyCompleteFailure",
+                                        TargetName),
+
+                                TargetSkipReason.ConditionWasFalse =>
+                                    FormatResourceStringIgnoreCodeAndKeyword(
+                                        "TargetSkippedFalseCondition",
+                                        TargetName,
+                                        Condition,
+                                        EvaluatedCondition),
+
+                                TargetSkipReason.OutputsUpToDate =>
+                                    FormatResourceStringIgnoreCodeAndKeyword(
+                                        "SkipTargetBecauseOutputsUpToDate",
+                                        TargetName),
+
+                                _ => SkipReason.ToString()
+                            };
                         }
                     }
                 }
diff --git a/src/Framework/TaskParameterEventArgs.cs b/src/Framework/TaskParameterEventArgs.cs
index b4efc953e84..1ca1a55f7ad 100644
--- a/src/Framework/TaskParameterEventArgs.cs
+++ b/src/Framework/TaskParameterEventArgs.cs
@@ -87,6 +87,8 @@ internal override void CreateFromStream(BinaryReader reader, int version)
             BuildEventContext = reader.ReadOptionalBuildEventContext();
             Kind = (TaskParameterMessageKind)reader.Read7BitEncodedInt();
             ItemType = reader.ReadOptionalString();
+            LineNumber = reader.Read7BitEncodedInt();
+            ColumnNumber = reader.Read7BitEncodedInt();
             Items = ReadItems(reader);
         }
 
@@ -134,6 +136,8 @@ internal override void WriteToStream(BinaryWriter writer)
             writer.WriteOptionalBuildEventContext(BuildEventContext);
             writer.Write7BitEncodedInt((int)Kind);
             writer.WriteOptionalString(ItemType);
+            writer.Write7BitEncodedInt(LineNumber);
+            writer.Write7BitEncodedInt(ColumnNumber);
             WriteItems(writer, Items);
         }
 
diff --git a/src/Framework/TaskStartedEventArgs.cs b/src/Framework/TaskStartedEventArgs.cs
index ce50a3b7723..207d20472d2 100644
--- a/src/Framework/TaskStartedEventArgs.cs
+++ b/src/Framework/TaskStartedEventArgs.cs
@@ -91,6 +91,8 @@ internal override void WriteToStream(BinaryWriter writer)
             writer.WriteOptionalString(taskName);
             writer.WriteOptionalString(projectFile);
             writer.WriteOptionalString(taskFile);
+            writer.Write7BitEncodedInt(LineNumber);
+            writer.Write7BitEncodedInt(ColumnNumber);
         }
 
         /// <summary>
@@ -105,6 +107,8 @@ internal override void CreateFromStream(BinaryReader reader, int version)
             taskName = reader.ReadByte() == 0 ? null : reader.ReadString();
             projectFile = reader.ReadByte() == 0 ? null : reader.ReadString();
             taskFile = reader.ReadByte() == 0 ? null : reader.ReadString();
+            LineNumber = reader.Read7BitEncodedInt();
+            ColumnNumber = reader.Read7BitEncodedInt();
         }
         #endregion
 
@@ -123,6 +127,16 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         /// </summary>
         public string TaskFile => taskFile;
 
+        /// <summary>
+        /// Line number of the task invocation in the project file
+        /// </summary>
+        public int LineNumber { get; internal set; }
+
+        /// <summary>
+        /// Column number of the task invocation in the project file
+        /// </summary>
+        public int ColumnNumber { get; internal set; }
+
         public override string Message
         {
             get
diff --git a/src/Shared/BinaryTranslator.cs b/src/Shared/BinaryTranslator.cs
index 6c2b6337393..74f46865a14 100644
--- a/src/Shared/BinaryTranslator.cs
+++ b/src/Shared/BinaryTranslator.cs
@@ -660,12 +660,31 @@ public void TranslateDictionary<D, T>(ref D dictionary, ObjectTranslator<T> obje
                 }
             }
 
-            /// <summary>
-            /// Reads in the boolean which says if this object is null or not.
-            /// </summary>
-            /// <typeparam name="T">The type of object to test.</typeparam>
-            /// <returns>True if the object should be read, false otherwise.</returns>
-            public bool TranslateNullable<T>(T value)
+            public void TranslateDictionary(ref Dictionary<string, DateTime> dictionary, StringComparer comparer)
+            {
+                if (!TranslateNullable(dictionary))
+                {
+                    return;
+                }
+
+                int count = _reader.ReadInt32();
+                dictionary = new(count, comparer);
+                string key = string.Empty;
+                DateTime val = DateTime.MinValue;
+                for (int i = 0; i < count; i++)
+                {
+                    Translate(ref key);
+                    Translate(ref val);
+                    dictionary.Add(key, val);
+                }
+            }
+
+        /// <summary>
+        /// Reads in the boolean which says if this object is null or not.
+        /// </summary>
+        /// <typeparam name="T">The type of object to test.</typeparam>
+        /// <returns>True if the object should be read, false otherwise.</returns>
+        public bool TranslateNullable<T>(T value)
             {
                 bool haveRef = _reader.ReadBoolean();
                 return haveRef;
@@ -1254,6 +1273,29 @@ public void TranslateDictionary<D, T>(ref D dictionary, ObjectTranslator<T> obje
                 }
             }
 
+            /// <summary>
+            /// Translates a dictionary of { string, DateTime }.
+            /// </summary>
+            /// <param name="dictionary">The dictionary to be translated.</param>
+            /// <param name="comparer">Key comparer</param>
+            public void TranslateDictionary(ref Dictionary<string, DateTime> dictionary, StringComparer comparer)
+            {
+                if (!TranslateNullable(dictionary))
+                {
+                    return;
+                }
+
+                int count = dictionary.Count;
+                _writer.Write(count);
+                foreach (KeyValuePair<string, DateTime> kvp in dictionary)
+                {
+                    string key = kvp.Key;
+                    DateTime val = kvp.Value;
+                    Translate(ref key);
+                    Translate(ref val);
+                }
+            }
+
             /// <summary>
             /// Writes out the boolean which says if this object is null or not.
             /// </summary>
diff --git a/src/Shared/ITranslator.cs b/src/Shared/ITranslator.cs
index b1acb85ec2f..97ea429de96 100644
--- a/src/Shared/ITranslator.cs
+++ b/src/Shared/ITranslator.cs
@@ -301,6 +301,8 @@ void TranslateArray<T>(ref T[] array)
 
         void TranslateDictionary(ref IDictionary<string, string> dictionary, NodePacketCollectionCreator<IDictionary<string, string>> collectionCreator);
 
+        void TranslateDictionary(ref Dictionary<string, DateTime> dictionary, StringComparer comparer);
+
         void TranslateDictionary<K, V>(ref IDictionary<K, V> dictionary, ObjectTranslator<K> keyTranslator, ObjectTranslator<V> valueTranslator, NodePacketCollectionCreator<IDictionary<K, V>> dictionaryCreator);
 
         /// <summary>
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs
index 77a9bf0452a..7f55c5bcbd1 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs
@@ -1,6 +1,9 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
 using System;
+using System.Collections.Generic;
 using System.IO;
-using System.Reflection;
 using System.Runtime.Versioning;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
@@ -12,10 +15,6 @@ namespace Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests
 {
     public class ResolveAssemblyReferenceCacheSerialization : IDisposable
     {
-        // Maintain this two in sync with the constant in SystemState
-        private static readonly byte[] TranslateContractSignature = { (byte)'M', (byte)'B', (byte)'R', (byte)'S', (byte)'C' }; // Microsoft Build RAR State Cache
-        private static readonly byte TranslateContractVersion = 0x01;
-
         private readonly string _rarCacheFile;
         private readonly TaskLoggingHelper _taskLoggingHelper;
 
@@ -42,178 +41,81 @@ public void RoundTripEmptyState()
         {
             SystemState systemState = new();
 
-            systemState.SerializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper);
 
-            var deserialized = SystemState.DeserializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+            var deserialized = SystemState.DeserializeCache(_rarCacheFile, _taskLoggingHelper, typeof(SystemState));
 
             deserialized.ShouldNotBeNull();
         }
 
         [Fact]
-        public void WrongFileSignature()
-        {
-            SystemState systemState = new();
-
-            for (int i = 0; i < TranslateContractSignature.Length; i++)
-            {
-                systemState.SerializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
-                using (var cacheStream = new FileStream(_rarCacheFile, FileMode.Open, FileAccess.ReadWrite))
-                {
-                    cacheStream.Seek(i, SeekOrigin.Begin);
-                    cacheStream.WriteByte(0);
-                    cacheStream.Close();
-                }
-
-                var deserialized = SystemState.DeserializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
-
-                deserialized.ShouldBeNull();
-            }
-        }
-
-        [Fact]
-        public void WrongFileVersion()
+        public void CorrectFileVersion()
         {
             SystemState systemState = new();
 
-            systemState.SerializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper);
             using (var cacheStream = new FileStream(_rarCacheFile, FileMode.Open, FileAccess.ReadWrite))
             {
-                cacheStream.Seek(TranslateContractSignature.Length, SeekOrigin.Begin);
-                cacheStream.WriteByte((byte) (TranslateContractVersion + 1));
+                cacheStream.Seek(0, SeekOrigin.Begin);
+                cacheStream.WriteByte(StateFileBase.CurrentSerializationVersion);
                 cacheStream.Close();
             }
 
-            var deserialized = SystemState.DeserializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
-
-            deserialized.ShouldBeNull();
-        }
-
-        [Fact]
-        public void CorrectFileSignature()
-        {
-            SystemState systemState = new();
-
-            for (int i = 0; i < TranslateContractSignature.Length; i++)
-            {
-                systemState.SerializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
-                using (var cacheStream = new FileStream(_rarCacheFile, FileMode.Open, FileAccess.ReadWrite))
-                {
-                    cacheStream.Seek(i, SeekOrigin.Begin);
-                    cacheStream.WriteByte(TranslateContractSignature[i]);
-                    cacheStream.Close();
-                }
-
-                var deserialized = SystemState.DeserializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+            var deserialized = SystemState.DeserializeCache(_rarCacheFile, _taskLoggingHelper, typeof(SystemState));
 
-                deserialized.ShouldNotBeNull();
-            }
+            deserialized.ShouldNotBeNull();
         }
 
         [Fact]
-        public void CorrectFileVersion()
+        public void WrongFileVersion()
         {
             SystemState systemState = new();
 
-            systemState.SerializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper);
             using (var cacheStream = new FileStream(_rarCacheFile, FileMode.Open, FileAccess.ReadWrite))
             {
-                cacheStream.Seek(TranslateContractSignature.Length, SeekOrigin.Begin);
-                cacheStream.WriteByte(TranslateContractVersion);
+                cacheStream.Seek(0, SeekOrigin.Begin);
+                cacheStream.WriteByte(StateFileBase.CurrentSerializationVersion - 1);
                 cacheStream.Close();
             }
 
-            var deserialized = SystemState.DeserializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+            var deserialized = SystemState.DeserializeCache(_rarCacheFile, _taskLoggingHelper, typeof(SystemState));
 
-            deserialized.ShouldNotBeNull();
+            deserialized.ShouldBeNull();
         }
 
         [Fact]
-        public void VerifySampleStateDeserialization()
+        public void ValidateSerializationAndDeserialization()
         {
-            // This test might also fail when binary format is modified.
-            // Any change in SystemState and child class ITranslatable implementation will most probably make this fail.
-            // To fix it, file referred by 'sampleName' needs to be recaptured and constant bellow modified to reflect
-            // the content of that cache.
-            // This sample was captured by compiling https://github.com/dotnet/roslyn/commit/f8107de2a94a01e96ac3d7c1f225acbb61e18830
-            const string sampleName = "Microsoft.VisualStudio.LanguageServices.Implementation.csprojAssemblyReference.cache";
-            const string expectedAssemblyPath = @"C:\Users\rokon\.nuget\packages\microsoft.visualstudio.codeanalysis.sdk.ui\15.8.27812-alpha\lib\net46\Microsoft.VisualStudio.CodeAnalysis.Sdk.UI.dll";
-            const long expectedAssemblyLastWriteTimeTicks = 636644382480000000;
-            const string expectedAssemblyName = "Microsoft.VisualStudio.CodeAnalysis.Sdk.UI, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
-            const string expectedFrameworkName = ".NETFramework,Version=v4.5";
-            var expectedDependencies = new[]
+            Dictionary<string, SystemState.FileState> cache = new() {
+                    { "path1", new SystemState.FileState(DateTime.Now) },
+                    { "path2", new SystemState.FileState(DateTime.Now) { Assembly = new AssemblyNameExtension("hi") } },
+                    { "dllName", new SystemState.FileState(DateTime.Now.AddSeconds(-10)) {
+                        Assembly = null,
+                        RuntimeVersion = "v4.0.30319",
+                        FrameworkNameAttribute = new FrameworkName(".NETFramework", Version.Parse("4.7.2"), "Profile"),
+                        scatterFiles = new string[] { "first", "second" } } } };
+            SystemState sysState = new();
+            sysState.instanceLocalFileStateCache = cache;
+            SystemState sysState2 = null;
+            using (TestEnvironment env = TestEnvironment.Create())
             {
-                "mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
-                "System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
-                "System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.CodeAnalysis, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.DeveloperTools, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
-                "Microsoft.VisualStudio.Shell.Interop, Version=7.1.40304.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "EnvDTE, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.CodeAnalysis.Sdk, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.Build.Framework, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.Text.Logic, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.Text.UI, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.Text.Data, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.Text.UI.Wpf, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.ComponentModelHost, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.VSHelp, Version=7.0.3300.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.Shell.Interop.11.0, Version=11.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.VCProjectEngine, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.Shell.15.0, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.OLE.Interop, Version=7.1.40304.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
-                "Microsoft.VisualStudio.TextManager.Interop, Version=7.1.40304.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "EnvDTE80, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
-                "Microsoft.VisualStudio.VirtualTreeGrid, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.Shell.Interop.8.0, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.Editor, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-            };
-
-
-            CopyResourceSampleFileIntoRarCacheFile($@"AssemblyDependency\CacheFileSamples\{sampleName}");
-
-            var deserializedByTranslator = SystemState.DeserializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
-            deserializedByTranslator.ShouldNotBeNull();
-
-            deserializedByTranslator.SetGetLastWriteTime(path =>
-            {
-                if (path != expectedAssemblyPath)
-                    throw new InvalidOperationException("Unexpected file name for this test case");
-
-                return new DateTime(expectedAssemblyLastWriteTimeTicks, DateTimeKind.Utc);
-            });
-
-            GetAssemblyName getAssemblyName = deserializedByTranslator.CacheDelegate((GetAssemblyName)null);
-            GetAssemblyMetadata getAssemblyMetadata = deserializedByTranslator.CacheDelegate((GetAssemblyMetadata)null);
-
-            var assemblyName = getAssemblyName(expectedAssemblyPath);
-            getAssemblyMetadata(expectedAssemblyPath, null,
-                out AssemblyNameExtension[] dependencies,
-                out string[] scatterFiles,
-                out FrameworkName frameworkNameAttribute);
-
-
-            assemblyName.ShouldNotBeNull();
-            assemblyName.ShouldBe(new AssemblyNameExtension(expectedAssemblyName, false));
-            scatterFiles.ShouldBeEmpty();
-            frameworkNameAttribute.ShouldBe(new FrameworkName(expectedFrameworkName));
-            dependencies.ShouldNotBeNull();
-            expectedDependencies.ShouldBe(expectedDependencies, ignoreOrder: true);
-        }
-
-        private void CopyResourceSampleFileIntoRarCacheFile(string name)
-        {
-            Assembly asm = this.GetType().Assembly;
-            var resource = string.Format($"{asm.GetName().Name}.{name.Replace("\\", ".")}");
-            using Stream resourceStream = asm.GetManifestResourceStream(resource);
-            if (resourceStream == null)
-                throw new InvalidOperationException($"Resource '{resource}' has not been found.");
-
-            using FileStream rarCacheFile = new FileStream(_rarCacheFile, FileMode.CreateNew);
+                TransientTestFile file = env.CreateFile();
+                sysState.SerializeCache(file.Path, null);
+                sysState2 = SystemState.DeserializeCache(file.Path, null, typeof(SystemState)) as SystemState;
+            }
 
-            resourceStream.CopyTo(rarCacheFile);
+            Dictionary<string, SystemState.FileState> cache2 = sysState2.instanceLocalFileStateCache;
+            cache2.Count.ShouldBe(cache.Count);
+            cache2["path2"].Assembly.Name.ShouldBe(cache["path2"].Assembly.Name);
+            SystemState.FileState dll = cache["dllName"];
+            SystemState.FileState dll2 = cache2["dllName"];
+            dll2.Assembly.ShouldBe(dll.Assembly);
+            dll2.FrameworkNameAttribute.FullName.ShouldBe(dll.FrameworkNameAttribute.FullName);
+            dll2.LastModified.ShouldBe(dll.LastModified);
+            dll2.RuntimeVersion.ShouldBe(dll.RuntimeVersion);
+            dll2.scatterFiles.Length.ShouldBe(dll.scatterFiles.Length);
+            dll2.scatterFiles[1].ShouldBe(dll.scatterFiles[1]);
         }
     }
 }
diff --git a/src/Tasks.UnitTests/AssemblyRegistrationCache_Tests.cs b/src/Tasks.UnitTests/AssemblyRegistrationCache_Tests.cs
index d496e33ecf1..fc94fbb510c 100644
--- a/src/Tasks.UnitTests/AssemblyRegistrationCache_Tests.cs
+++ b/src/Tasks.UnitTests/AssemblyRegistrationCache_Tests.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Tasks;
+using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
@@ -26,5 +27,24 @@ public void ExerciseCache()
             Assert.Equal("foo", assembly);
             Assert.Equal("bar", tlb);
         }
+
+        [Fact]
+        public void ExerciseCacheSerialization()
+        {
+            AssemblyRegistrationCache arc = new();
+            arc.AddEntry("foo", "bar");
+            AssemblyRegistrationCache arc2 = null;
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFile file = env.CreateFile();
+                arc.SerializeCache(file.Path, null);
+                arc2 = StateFileBase.DeserializeCache(file.Path, null, typeof(AssemblyRegistrationCache)) as AssemblyRegistrationCache;
+            }
+
+            arc2._assemblies.Count.ShouldBe(arc._assemblies.Count);
+            arc2._assemblies[0].ShouldBe(arc._assemblies[0]);
+            arc2._typeLibraries.Count.ShouldBe(arc._typeLibraries.Count);
+            arc2._typeLibraries[0].ShouldBe(arc._typeLibraries[0]);
+        }
     }
 }
diff --git a/src/Tasks.UnitTests/GetSDKReference_Tests.cs b/src/Tasks.UnitTests/GetSDKReference_Tests.cs
index 7af8f468716..6437663437c 100644
--- a/src/Tasks.UnitTests/GetSDKReference_Tests.cs
+++ b/src/Tasks.UnitTests/GetSDKReference_Tests.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
@@ -259,6 +260,38 @@ public void GetSDKReferenceFolders()
             VerifySDKFolders(getReferenceFolders, getReferenceFolders2, "References", _sdkDirectory);
         }
 
+        [Fact]
+        public void VerifyGetSdkReferenceTranslator()
+        {
+            Dictionary<string, GetSDKReferenceFiles.SdkReferenceInfo> pathToReferenceMetadata = new();
+            pathToReferenceMetadata.Add("first", new("dat", "dat2", true, false));
+            pathToReferenceMetadata.Add("second", new("inf", "inf2", false, false));
+            Dictionary<string, List<string>> directoryToFileList = new();
+            directoryToFileList.Add("third", new List<string>() { "a", "b", "c" });
+            directoryToFileList.Add("fourth", new List<string>() { "1", "2", "3" });
+            GetSDKReferenceFiles.SDKInfo writeInfo = new(pathToReferenceMetadata, directoryToFileList, 47);
+            GetSDKReferenceFiles.SaveContext contextWriter = new("d", "n", writeInfo);
+            GetSDKReferenceFiles.SDKInfo readInfo = null;
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = env.CreateFolder();
+                GetSDKReferenceFiles.SDKFilesCache cache = new(null, folder.Path, null, null, null);
+                cache.SaveAssemblyListToCacheFile(contextWriter);
+                GetSDKReferenceFiles.SDKFilesCache cache2 = new(null, folder.Path, null, null, null);
+                readInfo = cache2.LoadAssemblyListFromCacheFile("d", "n");
+            }
+            readInfo.DirectoryToFileList.Count.ShouldBe(2);
+            readInfo.DirectoryToFileList["fourth"].Count.ShouldBe(3);
+            readInfo.DirectoryToFileList["fourth"][1].ShouldBe("2");
+            readInfo.DirectoryToFileList["third"][0].ShouldBe("a");
+            readInfo.Hash.ShouldBe(47);
+            readInfo.PathToReferenceMetadata.Count.ShouldBe(2);
+            readInfo.PathToReferenceMetadata["first"].FusionName.ShouldBe("dat");
+            readInfo.PathToReferenceMetadata["first"].IsManagedWinmd.ShouldBeFalse();
+            readInfo.PathToReferenceMetadata["first"].IsWinMD.ShouldBeTrue();
+            readInfo.PathToReferenceMetadata["second"].ImageRuntime.ShouldBe("inf2");
+        }
+
         private static void VerifySDKFolders(GetSDKFolders singleParamDelegate, GetSDKFolders2 multiParamDelegate, string folderName, string sdkDirectory)
         {
             IList<string> sdkFolders = singleParamDelegate(sdkDirectory);
diff --git a/src/Tasks.UnitTests/ResolveComReference_Tests.cs b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
index f8c1c4855f7..4e695b86a73 100644
--- a/src/Tasks.UnitTests/ResolveComReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
@@ -14,6 +14,9 @@
 using Microsoft.Build.Tasks;
 using Xunit;
 using Microsoft.Build.Shared;
+using System.IO;
+using Microsoft.Build.BackEnd;
+using Shouldly;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -57,6 +60,29 @@ public void GetResolvedASsemblyReferenceSpecNotNull()
             Assert.NotNull(task.GetResolvedAssemblyReferenceItemSpecs());
         }
 
+        [Fact]
+        public void TestSerializationAndDeserialization()
+        {
+            ResolveComReferenceCache cache = new("path1", "path2");
+            cache.componentTimestamps = new()
+            {
+                { "first", DateTime.Now },
+                { "second", DateTime.FromBinary(10000) },
+            };
+            ResolveComReferenceCache cache2 = null;
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFile file = env.CreateFile();
+                cache.SerializeCache(file.Path, null);
+                cache2 = StateFileBase.DeserializeCache(file.Path, null, typeof(ResolveComReferenceCache)) as ResolveComReferenceCache;
+            }
+
+            cache2.tlbImpLocation.ShouldBe(cache.tlbImpLocation);
+            cache2.axImpLocation.ShouldBe(cache.axImpLocation);
+            cache2.componentTimestamps.Count.ShouldBe(cache.componentTimestamps.Count);
+            cache2.componentTimestamps["second"].ShouldBe(cache.componentTimestamps["second"]);
+        }
+
         /*
          * Method:  CheckComReferenceAttributeVerificationForNameItems
          * 
diff --git a/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
index a48675078f4..fa4c5af5675 100644
--- a/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
@@ -6,6 +6,8 @@
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Shared;
 using Xunit;
+using Shouldly;
+using System;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -16,35 +18,64 @@ sealed public class ResGenDependencies_Tests
 
         public void DirtyCleanScenario(bool useMSBuildResXReader)
         {
-            ResGenDependencies cache = new ResGenDependencies();
-
+            ResGenDependencies cache = new();
             string resx = CreateSampleResx();
             string stateFile = FileUtilities.GetTemporaryFile();
 
             try
             {
                 // A newly created cache is not dirty.
-                Assert.False(cache.IsDirty);
+                cache.IsDirty.ShouldBeFalse();
+
+                ResGenDependencies.PortableLibraryFile libFile = new("otherFileName");
+                libFile.outputFiles = new string[] { "first", "second" };
+                libFile.assemblySimpleName = "simpleName";
+                libFile.lastModified = DateTime.Now.Subtract(TimeSpan.FromSeconds(10));
+                cache.portableLibraries.Add("fileName", libFile);
+
+                // Writing the file to disk should make the cache clean.
+                cache.SerializeCache(stateFile, /* Log */ null);
+                cache.IsDirty.ShouldBeFalse();
 
                 // Getting a file that wasn't in the cache is a write operation.
                 cache.GetResXFileInfo(resx, useMSBuildResXReader);
-                Assert.True(cache.IsDirty);
+                cache.IsDirty.ShouldBeTrue();
 
-                // Writing the file to disk should make the cache clean.
+                // Add linkedFiles to further test serialization and deserialization.
+                cache.resXFiles.TryGetValue(resx, out ResGenDependencies.ResXFile file).ShouldBeTrue();
+                file.linkedFiles = new string[] { "third", "fourth" };
+
+                // Writing the file to disk should make the cache clean again.
                 cache.SerializeCache(stateFile, /* Log */ null);
-                Assert.False(cache.IsDirty);
+                cache.IsDirty.ShouldBeFalse();
 
                 // Deserialize from disk. Result should not be dirty.
-                cache = ResGenDependencies.DeserializeCache(stateFile, true, /* Log */ null);
-                Assert.False(cache.IsDirty);
+                ResGenDependencies cache2 = ResGenDependencies.DeserializeCache(stateFile, true, /* Log */ null);
+                cache2.IsDirty.ShouldBeFalse();
+
+                // Validate that serialization worked
+                cache.portableLibraries.TryGetValue("fileName", out ResGenDependencies.PortableLibraryFile portableLibrary);
+                cache2.portableLibraries.TryGetValue("fileName", out ResGenDependencies.PortableLibraryFile portableLibrary2);
+                portableLibrary2.filename.ShouldBe(portableLibrary.filename);
+                portableLibrary2.exists.ShouldBe(portableLibrary.exists);
+                portableLibrary2.assemblySimpleName.ShouldBe(portableLibrary.assemblySimpleName);
+                portableLibrary2.lastModified.ShouldBe(portableLibrary.lastModified);
+                portableLibrary2.outputFiles.Length.ShouldBe(portableLibrary.outputFiles.Length);
+                portableLibrary2.outputFiles[1].ShouldBe(portableLibrary.outputFiles[1]);
+                cache.resXFiles.TryGetValue(resx, out ResGenDependencies.ResXFile resX);
+                cache2.resXFiles.TryGetValue(resx, out ResGenDependencies.ResXFile resX2);
+                resX2.filename.ShouldBe(resX.filename);
+                resX2.lastModified.ShouldBe(resX.lastModified);
+                resX2.linkedFiles.Length.ShouldBe(resX.linkedFiles.Length);
+                resX2.linkedFiles[1].ShouldBe(resX.linkedFiles[1]);
 
                 // Asking for a file that's in the cache should not dirty the cache.
-                cache.GetResXFileInfo(resx, useMSBuildResXReader);
-                Assert.False(cache.IsDirty);
+                cache2.GetResXFileInfo(resx, useMSBuildResXReader);
+                cache2.IsDirty.ShouldBeFalse();
 
                 // Changing UseSourcePath to false should dirty the cache.
-                cache.UseSourcePath = false;
-                Assert.True(cache.IsDirty);
+                cache2.UseSourcePath = false;
+                cache2.IsDirty.ShouldBeTrue();
             }
             finally
             {
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 169eebec17a..ec3bf0b9d8b 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -2003,12 +2003,12 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l
         /// </summary>
         internal void ReadStateFile(FileExists fileExists)
         {
-            _cache = SystemState.DeserializeCacheByTranslator(_stateFile, Log);
+            _cache = SystemState.DeserializeCache(_stateFile, Log, typeof(SystemState)) as SystemState;
 
             // Construct the cache only if we can't find any caches.
             if (_cache == null && AssemblyInformationCachePaths != null && AssemblyInformationCachePaths.Length > 0)
             {
-                _cache = SystemState.DeserializePrecomputedCachesByTranslator(AssemblyInformationCachePaths, Log, fileExists);
+                _cache = SystemState.DeserializePrecomputedCaches(AssemblyInformationCachePaths, Log, fileExists);
             }
 
             if (_cache == null)
@@ -2024,11 +2024,11 @@ internal void WriteStateFile()
         {
             if (!String.IsNullOrEmpty(AssemblyInformationCacheOutputPath))
             {
-                _cache.SerializePrecomputedCacheByTranslator(AssemblyInformationCacheOutputPath, Log);
+                _cache.SerializePrecomputedCache(AssemblyInformationCacheOutputPath, Log);
             }
             else if (!String.IsNullOrEmpty(_stateFile) && _cache.IsDirty)
             {
-                _cache.SerializeCacheByTranslator(_stateFile, Log);
+                _cache.SerializeCache(_stateFile, Log);
             }
         }
         #endregion
@@ -2265,7 +2265,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     // Cache delegates.
                     getAssemblyName = _cache.CacheDelegate(getAssemblyName);
                     getAssemblyMetadata = _cache.CacheDelegate(getAssemblyMetadata);
-                    fileExists = _cache.CacheDelegate(fileExists);
+                    fileExists = _cache.CacheDelegate();
                     directoryExists = _cache.CacheDelegate(directoryExists);
                     getDirectories = _cache.CacheDelegate(getDirectories);
                     getRuntimeVersion = _cache.CacheDelegate(getRuntimeVersion);
diff --git a/src/Tasks/AssemblyRegistrationCache.cs b/src/Tasks/AssemblyRegistrationCache.cs
index 63ae6fdd833..3877f422450 100644
--- a/src/Tasks/AssemblyRegistrationCache.cs
+++ b/src/Tasks/AssemblyRegistrationCache.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -10,18 +11,19 @@ namespace Microsoft.Build.Tasks
     /// <remarks>
     /// This class is a caching mechanism for the Register/UnregisterAssembly task to keep track of registered assemblies to clean up
     /// </remarks>
-    [Serializable()]
-    internal sealed class AssemblyRegistrationCache : StateFileBase
+    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
+    [Serializable]
+    internal sealed class AssemblyRegistrationCache : StateFileBase, ITranslatable
     {
         /// <summary>
         /// The list of registered assembly files.
         /// </summary>
-        private readonly List<string> _assemblies = new List<string>();
+        internal List<string> _assemblies = new List<string>();
 
         /// <summary>
         /// The list of registered type library files.
         /// </summary>
-        private readonly List<string> _typeLibraries = new List<string>();
+        internal List<string> _typeLibraries = new List<string>();
 
         /// <summary>
         /// The number of entries in the state file
@@ -53,5 +55,19 @@ internal void GetEntry(int index, out string assemblyPath, out string typeLibrar
             assemblyPath = _assemblies[index];
             typeLibraryPath = _typeLibraries[index];
         }
+
+        public AssemblyRegistrationCache(ITranslator translator)
+        {
+            Translate(translator);
+        }
+
+        public AssemblyRegistrationCache() { }
+
+        public override void Translate(ITranslator translator)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(translator, nameof(translator));
+            translator.Translate(ref _assemblies);
+            translator.Translate(ref _typeLibraries);
+        }
     }
 }
diff --git a/src/Tasks/Dependencies.cs b/src/Tasks/Dependencies.cs
deleted file mode 100644
index 80761d7464f..00000000000
--- a/src/Tasks/Dependencies.cs
+++ /dev/null
@@ -1,56 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-using System.Collections;
-
-namespace Microsoft.Build.Tasks
-{
-    /// <summary>
-    /// Represents a cache of inputs to a compilation-style task.
-    /// </summary>
-    /// <remarks>On-disk serialization format, don't change field names or types or use readonly.</remarks>
-    [Serializable]
-    internal class Dependencies
-    {
-        /// <summary>
-        /// Hashtable of other dependency files.
-        /// Key is filename and value is DependencyFile.
-        /// </summary>
-        private Hashtable dependencies = new Hashtable();
-
-        /// <summary>
-        /// Look up a dependency file. Return null if its not there.
-        /// </summary>
-        /// <param name="filename"></param>
-        /// <returns></returns>
-        internal DependencyFile GetDependencyFile(string filename)
-        {
-            return (DependencyFile)dependencies[filename];
-        }
-
-        /// <summary>
-        /// Add a new dependency file.
-        /// </summary>
-        internal void AddDependencyFile(string filename, DependencyFile file)
-        {
-            dependencies[filename] = file;
-        }
-
-        /// <summary>
-        /// Remove new dependency file.
-        /// </summary>
-        internal void RemoveDependencyFile(string filename)
-        {
-            dependencies.Remove(filename);
-        }
-
-        /// <summary>
-        /// Remove all entries from the dependency table.
-        /// </summary>
-        internal void Clear()
-        {
-            dependencies.Clear();
-        }
-    }
-}
diff --git a/src/Tasks/DependencyFile.cs b/src/Tasks/DependencyFile.cs
index f8306894c3b..d517f39a296 100644
--- a/src/Tasks/DependencyFile.cs
+++ b/src/Tasks/DependencyFile.cs
@@ -12,20 +12,19 @@ namespace Microsoft.Build.Tasks
     /// <remarks>
     /// Represents a single input to a compilation-style task.
     /// Keeps track of timestamp for later comparison.
-    /// 
-    /// On-disk serialization format, don't change field names or types or use readonly.
     /// </remarks>
+    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
     [Serializable]
     internal class DependencyFile
     {
         // Filename
-        private string filename;
+        internal string filename;
 
         // Date and time the file was last modified           
-        private DateTime lastModified;
+        internal DateTime lastModified;
 
         // Whether the file exists or not.
-        private bool exists = false;
+        internal bool exists = false;
 
         /// <summary>
         /// The name of the file.
@@ -70,6 +69,10 @@ internal DependencyFile(string filename)
             }
         }
 
+        internal DependencyFile()
+        {
+        }
+
         /// <summary>
         /// Checks whether the file has changed since the last time a timestamp was recorded.
         /// </summary>
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index 43b7d8ffcd9..4468c610426 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -9,9 +9,9 @@
 using System.IO;
 using System.Linq;
 using System.Reflection;
-using System.Runtime.Serialization.Formatters.Binary;
 using System.Threading;
 using System.Threading.Tasks;
+using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
@@ -877,7 +877,7 @@ public bool Equals(ResolvedRedistFile other)
         /// <summary>
         /// Methods which are used to save and read the cache files per sdk from and to disk.
         /// </summary>
-        private class SDKFilesCache
+        internal class SDKFilesCache
         {
             /// <summary>
             ///  Thread-safe queue which contains exceptions throws during cache file reading and writing.
@@ -927,16 +927,15 @@ internal SDKInfo LoadAssemblyListFromCacheFile(string sdkIdentity, string sdkRoo
                 {
                     if (!string.IsNullOrEmpty(cacheFile))
                     {
-                        return SDKInfo.Deserialize(cacheFile);
+                        using FileStream fs = new FileStream(cacheFile, FileMode.Open);
+                        var translator = BinaryTranslator.GetReadTranslator(fs, buffer: null);
+                        SDKInfo sdkInfo = new SDKInfo();
+                        sdkInfo.Translate(translator);
+                        return sdkInfo;
                     }
                 }
-                catch (Exception e)
+                catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
                 {
-                    if (ExceptionHandling.IsCriticalException(e))
-                    {
-                        throw;
-                    }
-
                     // Queue up for later logging, does not matter if the file is deleted or not
                     _exceptionMessages.Enqueue(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("GetSDKReferenceFiles.ProblemReadingCacheFile", cacheFile, e.ToString()));
                 }
@@ -965,31 +964,21 @@ internal void SaveAssemblyListToCacheFile(object data)
                         {
                             File.Delete(existingCacheFile);
                         }
-                        catch (Exception e)
+                        catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
                         {
-                            if (ExceptionHandling.IsCriticalException(e))
-                            {
-                                throw;
-                            }
-
                             // Queue up for later logging, does not matter if the file is deleted or not
                             _exceptionMessages.Enqueue(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("GetSDKReferenceFiles.ProblemDeletingCacheFile", existingCacheFile, e.Message));
                         }
                     }
 
-                    var formatter = new BinaryFormatter();
                     using (var fs = new FileStream(referencesCacheFile, FileMode.Create))
                     {
-                        formatter.Serialize(fs, cacheFileInfo);
+                        var translator = BinaryTranslator.GetWriteTranslator(fs);
+                        cacheFileInfo.Translate(translator);
                     }
                 }
-                catch (Exception e)
+                catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
                 {
-                    if (ExceptionHandling.IsCriticalException(e))
-                    {
-                        throw;
-                    }
-
                     // Queue up for later logging, does not matter if the cache got written
                     _exceptionMessages.Enqueue(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("GetSDKReferenceFiles.ProblemWritingCacheFile", referencesCacheFile, e.Message));
                 }
@@ -1205,11 +1194,8 @@ private static IEnumerable<string> GetAllReferenceDirectories(string sdkRoot)
         /// </summary>
         /// <remarks>This is a serialization format. Do not change member naming.</remarks>
         [Serializable]
-        private class SdkReferenceInfo
+        internal class SdkReferenceInfo
         {
-            /// <summary>
-            /// Constructor
-            /// </summary>
             public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bool isManagedWinmd)
             {
                 FusionName = fusionName;
@@ -1219,25 +1205,11 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo
             }
 
             #region Properties
-            /// <summary>
-            /// The fusionName
-            /// </summary>
-            public string FusionName { get; }
 
-            /// <summary>
-            /// Is the file a winmd or not
-            /// </summary>
-            public bool IsWinMD { get; }
-
-            /// <summary>
-            /// Is the file a managed winmd or not
-            /// </summary>
-            public bool IsManagedWinmd { get; }
-
-            /// <summary>
-            /// What is the imageruntime information on it.
-            /// </summary>
-            public string ImageRuntime { get; }
+            public string FusionName { get; internal set; }
+            public bool IsWinMD { get; internal set; }
+            public bool IsManagedWinmd { get; internal set; }
+            public string ImageRuntime { get; internal set; }
 
             #endregion
         }
@@ -1245,64 +1217,75 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo
         /// <summary>
         /// Structure that contains the on disk representation of the SDK in memory.
         /// </summary>
-        /// <remarks>This is a serialization format. Do not change member naming.</remarks>
-        [Serializable]
-        private class SDKInfo
+        internal class SDKInfo : ITranslatable
         {
-            // Current version for serialization. This should be changed when breaking changes
-            // are made to this class.
-            private const byte CurrentSerializationVersion = 1;
+            private IDictionary<string, SdkReferenceInfo> _pathToReferenceMetadata;
+            private IDictionary<string, List<string>> _directoryToFileList;
+            private int _hash;
 
-            // Version this instance is serialized with.
-            private byte _serializedVersion = CurrentSerializationVersion;
+            internal SDKInfo()
+            {
+                _pathToReferenceMetadata = new Dictionary<string, SdkReferenceInfo>(StringComparer.OrdinalIgnoreCase);
+                _directoryToFileList = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
+                _hash = 0;
+            }
 
-            /// <summary>
-            /// Constructor
-            /// </summary>
-            public SDKInfo(ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, ConcurrentDictionary<string, List<string>> directoryToFileList, int cacheHash)
+            public SDKInfo(ITranslator translator) : this()
+            {
+                Translate(translator);
+            }
+
+            public SDKInfo(IDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, IDictionary<string, List<string>> directoryToFileList, int cacheHash)
             {
-                PathToReferenceMetadata = pathToReferenceMetadata;
-                DirectoryToFileList = directoryToFileList;
-                Hash = cacheHash;
+                this._pathToReferenceMetadata = pathToReferenceMetadata;
+                this._directoryToFileList = directoryToFileList;
+                this._hash = cacheHash;
             }
 
             /// <summary>
             /// A dictionary which maps a file path to a structure that contain some metadata information about that file.
             /// </summary>
-            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get; }
+            public IDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get { return _pathToReferenceMetadata; } }
 
-            /// <summary>
-            /// Dictionary which maps a directory to a list of file names within that directory. This is used to shortcut hitting the disk for the list of files inside of it.
-            /// </summary>
-            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get; }
+            public IDictionary<string, List<string>> DirectoryToFileList { get { return _directoryToFileList; } }
 
             /// <summary>
             /// Hashset
             /// </summary>
-            public int Hash { get; }
+            public int Hash { get { return _hash; } }
 
-            public static SDKInfo Deserialize(string cacheFile)
+            public void Translate(ITranslator translator)
             {
-                using (var fs = new FileStream(cacheFile, FileMode.Open))
+                translator.TranslateDictionary(ref _pathToReferenceMetadata, (ITranslator t, ref string s) => t.Translate(ref s), (ITranslator t, ref SdkReferenceInfo info) =>
                 {
-                    var formatter = new BinaryFormatter();
-                    var info = (SDKInfo)formatter.Deserialize(fs);
-
-                    // If the serialization versions don't match, don't use the cache
-                    if (info != null && info._serializedVersion != CurrentSerializationVersion)
-                    {
-                        return null;
-                    }
+                    info ??= new SdkReferenceInfo(null, null, false, false);
+                    string fusionName = info.FusionName;
+                    string imageRuntime = info.ImageRuntime;
+                    bool isManagedWinmd = info.IsManagedWinmd;
+                    bool isWinmd = info.IsWinMD;
+                    t.Translate(ref fusionName);
+                    t.Translate(ref imageRuntime);
+                    t.Translate(ref isManagedWinmd);
+                    t.Translate(ref isWinmd);
+                    info.FusionName = fusionName;
+                    info.ImageRuntime = imageRuntime;
+                    info.IsManagedWinmd = isManagedWinmd;
+                    info.IsWinMD = isWinmd;
+                }, count => new Dictionary<string, SdkReferenceInfo>(count, StringComparer.OrdinalIgnoreCase));
+
+                translator.TranslateDictionary(ref _directoryToFileList, (ITranslator t, ref string s) => t.Translate(ref s), (ITranslator t, ref List<string> fileList) =>
+                {
+                    t.Translate(ref fileList, (ITranslator t, ref string str) => { t.Translate(ref str); });
+                }, count => new Dictionary<string, List<string>>(count, StringComparer.OrdinalIgnoreCase));
 
-                    return info;
-                }
+                translator.Translate(ref _hash);
             }
         }
 
         /// <summary>
         /// This class represents the context information used by the background cache serialization thread.
         /// </summary>
-        private class SaveContext
+        internal class SaveContext
         {
             /// <summary>
             /// Constructor
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index d24a745ce88..59a0224820f 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -551,7 +551,6 @@
     <Compile Include="CodeTaskFactory.cs" />
     <Compile Include="XamlTaskFactory\XamlTaskFactory.cs" />
     <Compile Include="StateFileBase.cs" />
-    <Compile Include="Dependencies.cs" />
     <Compile Include="SystemState.cs" />
     <Compile Include="DependencyFile.cs" />
     <Compile Include="ZipDirectory.cs" />
diff --git a/src/Tasks/ResGenDependencies.cs b/src/Tasks/ResGenDependencies.cs
index 3632a916d83..35b26a5e72f 100644
--- a/src/Tasks/ResGenDependencies.cs
+++ b/src/Tasks/ResGenDependencies.cs
@@ -8,7 +8,7 @@
 using System.IO;
 using System.Resources;
 using System.Xml;
-
+using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.ResourceHandling;
@@ -22,18 +22,19 @@ namespace Microsoft.Build.Tasks
     /// 
     /// This is an on-disk serialization format, don't change field names or types or use readonly.
     /// </remarks>
+    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
     [Serializable]
-    internal sealed class ResGenDependencies : StateFileBase
+    internal sealed class ResGenDependencies : StateFileBase, ITranslatable
     {
         /// <summary>
         /// The list of resx files.
         /// </summary>
-        private Dependencies resXFiles = new Dependencies();
+        internal IDictionary<string, ResXFile> resXFiles = new Dictionary<string, ResXFile>();
 
         /// <summary>
         /// A list of portable libraries and the ResW files they can produce.
         /// </summary>
-        private Dependencies portableLibraries = new Dependencies();
+        internal IDictionary<string, PortableLibraryFile> portableLibraries = new Dictionary<string, PortableLibraryFile>();
 
         /// <summary>
         /// A newly-created ResGenDependencies is not dirty.
@@ -47,7 +48,7 @@ internal sealed class ResGenDependencies : StateFileBase
         ///  If this is NULL then we use the directory in which the .resx is in (that should always
         ///  be the default!)
         /// </summary>
-        private string baseLinkedFileDirectory;
+        internal string baseLinkedFileDirectory;
 
         internal string BaseLinkedFileDirectory
         {
@@ -90,11 +91,38 @@ internal bool UseSourcePath
             }
         }
 
+        public ResGenDependencies() { }
+
+        public ResGenDependencies(ITranslator translator)
+        {
+            Translate(translator);
+        }
+
+        public override void Translate(ITranslator translator)
+        {
+            translator.TranslateDictionary(ref resXFiles,
+                (ITranslator translator, ref string s) => translator.Translate(ref s),
+                (ITranslator translator, ref ResXFile resx) => {
+                    ResXFile temp = resx ?? new();
+                    temp.Translate(translator);
+                    resx = temp;
+                },
+                count => new Dictionary<string, ResXFile>(count));
+            translator.TranslateDictionary(ref portableLibraries,
+                (ITranslator translator, ref string s) => translator.Translate(ref s),
+                (ITranslator translator, ref PortableLibraryFile portableLibrary) => {
+                    PortableLibraryFile temp = portableLibrary ?? new();
+                    temp.Translate(translator);
+                    portableLibrary = temp;
+                },
+                count => new Dictionary<string, PortableLibraryFile>(count));
+            translator.Translate(ref baseLinkedFileDirectory);
+        }
+
         internal ResXFile GetResXFileInfo(string resxFile, bool useMSBuildResXReader)
         {
             // First, try to retrieve the resx information from our hashtable.
-            var retVal = (ResXFile)resXFiles.GetDependencyFile(resxFile);
-            if (retVal == null)
+            if (!resXFiles.TryGetValue(resxFile, out ResXFile retVal))
             {
                 // Ok, the file wasn't there.  Add it to our cache and return it to the caller.  
                 retVal = AddResxFile(resxFile, useMSBuildResXReader);
@@ -105,7 +133,7 @@ internal ResXFile GetResXFileInfo(string resxFile, bool useMSBuildResXReader)
                 // by removing it from the hashtable and readding it.
                 if (retVal.HasFileChanged())
                 {
-                    resXFiles.RemoveDependencyFile(resxFile);
+                    resXFiles.Remove(resxFile);
                     _isDirty = true;
                     retVal = AddResxFile(resxFile, useMSBuildResXReader);
                 }
@@ -120,7 +148,7 @@ private ResXFile AddResxFile(string file, bool useMSBuildResXReader)
             // to be cracked for contained files.
 
             var resxFile = new ResXFile(file, BaseLinkedFileDirectory, useMSBuildResXReader);
-            resXFiles.AddDependencyFile(file, resxFile);
+            resXFiles.Add(file, resxFile);
             _isDirty = true;
             return resxFile;
         }
@@ -128,13 +156,13 @@ private ResXFile AddResxFile(string file, bool useMSBuildResXReader)
         internal PortableLibraryFile TryGetPortableLibraryInfo(string libraryPath)
         {
             // First, try to retrieve the portable library information from our hashtable.  
-            var retVal = (PortableLibraryFile)portableLibraries.GetDependencyFile(libraryPath);
+            portableLibraries.TryGetValue(libraryPath, out PortableLibraryFile retVal);
 
             // The file is in our cache.  Make sure it's up to date.  If not, discard
             // this entry from the cache and rebuild all the state at a later point.
             if (retVal?.HasFileChanged() == true)
             {
-                portableLibraries.RemoveDependencyFile(libraryPath);
+                portableLibraries.Remove(libraryPath);
                 _isDirty = true;
                 retVal = null;
             }
@@ -144,11 +172,10 @@ internal PortableLibraryFile TryGetPortableLibraryInfo(string libraryPath)
 
         internal void UpdatePortableLibrary(PortableLibraryFile library)
         {
-            var cached = (PortableLibraryFile)portableLibraries.GetDependencyFile(library.FileName);
-            if (cached == null || !library.Equals(cached))
+            if (!portableLibraries.TryGetValue(library.FileName, out PortableLibraryFile cached) || !library.Equals(cached))
             {
                 // Add a new entry or replace the existing one.
-                portableLibraries.AddDependencyFile(library.FileName, library);
+                portableLibraries.Add(library.FileName, library);
                 _isDirty = true;
             }
         }
@@ -188,11 +215,12 @@ internal static ResGenDependencies DeserializeCache(string stateFile, bool useSo
         /// 
         /// This is an on-disk serialization format, don't change field names or types or use readonly.
         /// </remarks>
+        /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
         [Serializable]
-        internal sealed class ResXFile : DependencyFile
+        internal sealed class ResXFile : DependencyFile, ITranslatable
         {
             // Files contained within this resx file.
-            private string[] linkedFiles;
+            internal string[] linkedFiles;
 
             internal string[] LinkedFiles => linkedFiles;
 
@@ -209,6 +237,18 @@ internal ResXFile(string filename, string baseLinkedFileDirectory, bool useMSBui
                 }
             }
 
+            internal ResXFile()
+            {
+            }
+
+            public void Translate(ITranslator translator)
+            {
+                translator.Translate(ref linkedFiles);
+                translator.Translate(ref filename);
+                translator.Translate(ref lastModified);
+                translator.Translate(ref exists);
+            }
+
             /// <summary>
             /// Given a .RESX file, returns all the linked files that are referenced within that .RESX.
             /// </summary>
@@ -281,12 +321,27 @@ private static string[] GetLinkedFiles(string filename, string baseLinkedFileDir
         /// 
         /// This is an on-disk serialization format, don't change field names or types or use readonly.
         /// </remarks>
+        /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
         [Serializable]
-        internal sealed class PortableLibraryFile : DependencyFile
+        internal sealed class PortableLibraryFile : DependencyFile, ITranslatable
         {
-            private string[] outputFiles;
-            private string neutralResourceLanguage;
-            private string assemblySimpleName;
+            internal string[] outputFiles;
+            internal string neutralResourceLanguage;
+            internal string assemblySimpleName;
+
+            internal PortableLibraryFile()
+            {
+            }
+
+            public void Translate(ITranslator translator)
+            {
+                translator.Translate(ref assemblySimpleName);
+                translator.Translate(ref outputFiles);
+                translator.Translate(ref neutralResourceLanguage);
+                translator.Translate(ref filename);
+                translator.Translate(ref lastModified);
+                translator.Translate(ref exists);
+            }
 
             internal PortableLibraryFile(string filename)
                 : base(filename)
diff --git a/src/Tasks/ResolveComReferenceCache.cs b/src/Tasks/ResolveComReferenceCache.cs
index d0f80dca18f..133acb02f6f 100644
--- a/src/Tasks/ResolveComReferenceCache.cs
+++ b/src/Tasks/ResolveComReferenceCache.cs
@@ -2,7 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
+using System.Collections.Generic;
+using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -16,17 +17,18 @@ namespace Microsoft.Build.Tasks
     /// 
     /// This is an on-disk serialization format, don't change field names or types or use readonly.
     /// </remarks>
+    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
     [Serializable]
-    internal sealed class ResolveComReferenceCache : StateFileBase
+    internal sealed class ResolveComReferenceCache : StateFileBase, ITranslatable
     {
         /// <summary>
         /// Component timestamps. 
         /// Key: Component path on disk
         /// Value: DateTime struct
         /// </summary>
-        private Hashtable componentTimestamps;
-        private string tlbImpLocation;
-        private string axImpLocation;
+        internal Dictionary<string, DateTime> componentTimestamps;
+        internal string tlbImpLocation;
+        internal string axImpLocation;
 
         /// <summary>
         /// indicates whether the cache contents have changed since it's been created
@@ -46,7 +48,7 @@ internal ResolveComReferenceCache(string tlbImpPath, string axImpPath)
 
             tlbImpLocation = tlbImpPath;
             axImpLocation = axImpPath;
-            componentTimestamps = new Hashtable();
+            componentTimestamps = new();
         }
 
         /// <summary>
@@ -69,9 +71,9 @@ internal DateTime this[string componentPath]
         {
             get
             {
-                if (componentTimestamps.ContainsKey(componentPath))
+                if (componentTimestamps.TryGetValue(componentPath, out DateTime time))
                 {
-                    return (DateTime)componentTimestamps[componentPath];
+                    return time;
                 }
 
                 // If the entry is not present in the cache, return the current time. Since no component should be timestamped
@@ -81,12 +83,24 @@ internal DateTime this[string componentPath]
             set
             {
                 // only set the value and dirty the cache if the timestamp doesn't exist yet or is different than the current one
-                if (DateTime.Compare(this[componentPath], value) != 0)
+                if (!DateTime.Equals(this[componentPath], value))
                 {
                     componentTimestamps[componentPath] = value;
                     _dirty = true;
                 }
             }
         }
+
+        public ResolveComReferenceCache(ITranslator translator)
+        {
+            Translate(translator);
+        }
+
+        public override void Translate(ITranslator translator)
+        {
+            translator.Translate(ref axImpLocation);
+            translator.Translate(ref tlbImpLocation);
+            translator.TranslateDictionary(ref componentTimestamps, StringComparer.Ordinal);
+        }
     }
 }
diff --git a/src/Tasks/StateFileBase.cs b/src/Tasks/StateFileBase.cs
index b5b34a31b0b..760fc3e83ec 100644
--- a/src/Tasks/StateFileBase.cs
+++ b/src/Tasks/StateFileBase.cs
@@ -3,18 +3,19 @@
 
 using System;
 using System.IO;
-using System.Runtime.Serialization.Formatters.Binary;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.BackEnd;
 
 namespace Microsoft.Build.Tasks
 {
     /// <remarks>
     /// Base class for task state files.
     /// </remarks>
-    [Serializable()]
-    internal class StateFileBase
+    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
+    [Serializable]
+    internal abstract class StateFileBase
     {
         // Current version for serialization. This should be changed when breaking changes
         // are made to this class.
@@ -22,7 +23,7 @@ internal class StateFileBase
         // Version 4/5 - VS2017.7:
         //   Unify .NET Core + Full Framework. Custom serialization on some types that are no
         //   longer [Serializable].
-        private const byte CurrentSerializationVersion = 5;
+        internal const byte CurrentSerializationVersion = 6;
 
         // Version this instance is serialized with.
         private byte _serializedVersion = CurrentSerializationVersion;
@@ -43,24 +44,24 @@ internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log)
 
                     using (var s = new FileStream(stateFile, FileMode.CreateNew))
                     {
-                        var formatter = new BinaryFormatter();
-                        formatter.Serialize(s, this);
+                        var translator = BinaryTranslator.GetWriteTranslator(s);
+                        translator.Translate(ref _serializedVersion);
+                        Translate(translator);
                     }
                 }
             }
-            catch (Exception e)
+            // If there was a problem writing the file (like it's read-only or locked on disk, for
+            // example), then eat the exception and log a warning.  Otherwise, rethrow.
+            catch (Exception e) when (!ExceptionHandling.NotExpectedSerializationException(e))
             {
-                // If there was a problem writing the file (like it's read-only or locked on disk, for
-                // example), then eat the exception and log a warning.  Otherwise, rethrow.
-                if (ExceptionHandling.NotExpectedSerializationException(e))
-                    throw;
-
                 // Not being able to serialize the cache is not an error, but we let the user know anyway.
                 // Don't want to hold up processing just because we couldn't read the file.
                 log.LogWarningWithCodeFromResources("General.CouldNotWriteStateFile", stateFile, e.Message);
             }
         }
 
+        public abstract void Translate(ITranslator translator);
+
         /// <summary>
         /// Reads the specified file from disk into a StateFileBase derived object.
         /// </summary>
@@ -75,43 +76,40 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp
                 {
                     using (FileStream s = new FileStream(stateFile, FileMode.Open))
                     {
-                        var formatter = new BinaryFormatter();
-                        object deserializedObject = formatter.Deserialize(s);
-                        retVal = deserializedObject as StateFileBase;
+                        var translator = BinaryTranslator.GetReadTranslator(s, buffer: null);
+                        byte version = 0;
+                        translator.Translate(ref version);
+                        var constructors = requiredReturnType.GetConstructors();
+                        foreach (var constructor in constructors)
+                        {
+                            var parameters = constructor.GetParameters();
+                            if (parameters.Length == 1 && parameters[0].ParameterType == typeof(ITranslator))
+                            {
+                                retVal = constructor.Invoke(new object[] { translator }) as StateFileBase;
+                            }
+                        }
 
-                        // If the deserialized object is null then there would be no cast error but retVal would still be null
-                        // only log the message if there would have been a cast error
-                        if (retVal == null && deserializedObject != null)
+                        // If retVal is still null or the version is wrong, log a message not a warning. This could be a valid cache with the wrong version preventing correct deserialization.
+                        // For the latter case, internals may be unexpectedly null.
+                        if (retVal == null || version != CurrentSerializationVersion)
                         {
                             // When upgrading to Visual Studio 2008 and running the build for the first time the resource cache files are replaced which causes a cast error due
                             // to a new version number on the tasks class. "Unable to cast object of type 'Microsoft.Build.Tasks.SystemState' to type 'Microsoft.Build.Tasks.StateFileBase".
                             // If there is an invalid cast, a message rather than a warning should be emitted.
                             log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile, log.FormatResourceString("General.IncompatibleStateFileType"));
+                            return null;
                         }
-
-                        if ((retVal != null) && (!requiredReturnType.IsInstanceOfType(retVal)))
+                        else if (!requiredReturnType.IsInstanceOfType(retVal))
                         {
                             log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile,
                                 log.FormatResourceString("General.IncompatibleStateFileType"));
                             retVal = null;
                         }
-
-                        // If we get back a valid object and internals were changed, things are likely to be null. Check the version before we use it.
-                        if (retVal != null && retVal._serializedVersion != CurrentSerializationVersion)
-                        {
-                            log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile, log.FormatResourceString("General.IncompatibleStateFileType"));
-                            retVal = null;
-                        }
                     }
                 }
             }
-            catch (Exception e)
+            catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
             {
-                if (ExceptionHandling.IsCriticalException(e))
-                {
-                    throw;
-                }
-
                 // The deserialization process seems like it can throw just about 
                 // any exception imaginable.  Catch them all here.
                 // Not being able to deserialize the cache is not an error, but we let the user know anyway.
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index 3f5ea428b0c..2992e07bc73 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -12,7 +12,6 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.AssemblyDependency;
 using Microsoft.Build.Utilities;
 
@@ -21,12 +20,10 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Class is used to cache system state.
     /// </summary>
+    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
     [Serializable]
     internal sealed class SystemState : StateFileBase, ITranslatable
     {
-        private static readonly byte[] TranslateContractSignature = { (byte) 'M', (byte) 'B', (byte) 'R', (byte) 'S', (byte) 'C'}; // Microsoft Build RAR State Cache
-        private static readonly byte TranslateContractVersion = 0x01;
-
         /// <summary>
         /// Cache at the SystemState instance level. Has the same contents as <see cref="instanceLocalFileStateCache"/>.
         /// It acts as a flag to enforce that an entry has been checked for staleness only once.
@@ -89,11 +86,6 @@ internal sealed class SystemState : StateFileBase, ITranslatable
         /// </summary>
         private GetAssemblyMetadata getAssemblyMetadata;
 
-        /// <summary>
-        /// Cached delegate.
-        /// </summary>
-        private FileExists fileExists;
-
         /// <summary>
         /// Cached delegate.
         /// </summary>
@@ -221,8 +213,13 @@ internal FrameworkName FrameworkNameAttribute
         /// <summary>
         /// Construct.
         /// </summary>
-        internal SystemState()
+        public SystemState()
+        {
+        }
+
+        public SystemState(ITranslator translator)
         {
+            Translate(translator);
         }
 
         /// <summary>
@@ -239,88 +236,11 @@ AssemblyTableInfo[] installedAssemblyTableInfos
             redistList = RedistList.GetRedistList(installedAssemblyTableInfos);
         }
 
-        /// <summary>
-        /// Writes the contents of this object out to the specified file.
-        /// TODO: once all derived classes from StateFileBase adopt new serialization, we shall consider to mode this into base class
-        /// </summary>
-        internal void SerializeCacheByTranslator(string stateFile, TaskLoggingHelper log)
-        {
-            try
-            {
-                if (!string.IsNullOrEmpty(stateFile))
-                {
-                    if (FileSystems.Default.FileExists(stateFile))
-                    {
-                        File.Delete(stateFile);
-                    }
-
-                    using var s = new FileStream(stateFile, FileMode.CreateNew);
-                    var translator = BinaryTranslator.GetWriteTranslator(s);
-
-                    // write file signature
-                    translator.Writer.Write(TranslateContractSignature);
-                    translator.Writer.Write(TranslateContractVersion);
-
-                    Translate(translator);
-                    isDirty = false;
-                }
-            }
-            catch (Exception e) when (!ExceptionHandling.NotExpectedSerializationException(e))
-            {
-                // Not being able to serialize the cache is not an error, but we let the user know anyway.
-                // Don't want to hold up processing just because we couldn't read the file.
-                log.LogWarningWithCodeFromResources("General.CouldNotWriteStateFile", stateFile, e.Message);
-            }
-        }
-
-        /// <summary>
-        /// Read the contents of this object out to the specified file.
-        /// TODO: once all classes derived from StateFileBase adopt the new serialization, we should consider moving this into the base class
-        /// </summary>
-        internal static SystemState DeserializeCacheByTranslator(string stateFile, TaskLoggingHelper log)
-        {
-            // First, we read the cache from disk if one exists, or if one does not exist, we create one.
-            try
-            {
-                if (!string.IsNullOrEmpty(stateFile) && FileSystems.Default.FileExists(stateFile))
-                {
-                    using FileStream s = new FileStream(stateFile, FileMode.Open);
-                    var translator = BinaryTranslator.GetReadTranslator(s, buffer:null); // TODO: shared buffering?
-
-                    // verify file signature
-                    var contractSignature = translator.Reader.ReadBytes(TranslateContractSignature.Length);
-                    var contractVersion = translator.Reader.ReadByte();
-
-                    if (!contractSignature.SequenceEqual(TranslateContractSignature) || contractVersion != TranslateContractVersion)
-                    {
-                        log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile, log.FormatResourceString("General.IncompatibleStateFileType"));
-                        return null;
-                    }
-
-                    SystemState systemState = new SystemState();
-                    systemState.Translate(translator);
-                    systemState.isDirty = false;
-
-                    return systemState;
-                }
-            }
-            catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
-            {
-                // The deserialization process seems like it can throw just about 
-                // any exception imaginable.  Catch them all here.
-                // Not being able to deserialize the cache is not an error, but we let the user know anyway.
-                // Don't want to hold up processing just because we couldn't read the file.
-                log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile, e.Message);
-            }
-
-            return null;
-        }
-
         /// <summary>
         /// Reads/writes this class.
         /// Used for serialization and deserialization of this class persistent cache.
         /// </summary>
-        public void Translate(ITranslator translator)
+        public override void Translate(ITranslator translator)
         {
             if (instanceLocalFileStateCache is null)
                 throw new NullReferenceException(nameof(instanceLocalFileStateCache));
@@ -329,6 +249,10 @@ public void Translate(ITranslator translator)
                 ref instanceLocalFileStateCache,
                 StringComparer.OrdinalIgnoreCase,
                 (ITranslator t) => new FileState(t));
+
+            // IsDirty should be false for either direction. Either this cache was brought
+            // up-to-date with the on-disk cache or vice versa. Either way, they agree.
+            IsDirty = false;
         }
 
         /// <summary>
@@ -375,11 +299,9 @@ internal GetAssemblyMetadata CacheDelegate(GetAssemblyMetadata getAssemblyMetada
         /// <summary>
         /// Cache the results of a FileExists delegate. 
         /// </summary>
-        /// <param name="fileExistsValue">The delegate.</param>
         /// <returns>Cached version of the delegate.</returns>
-        internal FileExists CacheDelegate(FileExists fileExistsValue)
+        internal FileExists CacheDelegate()
         {
-            fileExists = fileExistsValue;
             return FileExists;
         }
 
@@ -605,7 +527,7 @@ out fileState.frameworkName
         /// <param name="log">How to log</param>
         /// <param name="fileExists">Whether a file exists</param>
         /// <returns>A cache representing key aspects of file states.</returns>
-        internal static SystemState DeserializePrecomputedCachesByTranslator(ITaskItem[] stateFiles, TaskLoggingHelper log, FileExists fileExists)
+        internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, FileExists fileExists)
         {
             SystemState retVal = new SystemState();
             retVal.isDirty = stateFiles.Length > 0;
@@ -614,7 +536,7 @@ internal static SystemState DeserializePrecomputedCachesByTranslator(ITaskItem[]
             foreach (ITaskItem stateFile in stateFiles)
             {
                 // Verify that it's a real stateFile. Log message but do not error if not.
-                SystemState sysState = DeserializeCacheByTranslator(stateFile.ToString(), log);
+                SystemState sysState = DeserializeCache(stateFile.ToString(), log, typeof(SystemState)) as SystemState;
                 if (sysState == null)
                 {
                     continue;
@@ -644,7 +566,7 @@ internal static SystemState DeserializePrecomputedCachesByTranslator(ITaskItem[]
         /// </summary>
         /// <param name="stateFile">Path to which to write the precomputed cache</param>
         /// <param name="log">How to log</param>
-        internal void SerializePrecomputedCacheByTranslator(string stateFile, TaskLoggingHelper log)
+        internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log)
         {
             // Save a copy of instanceLocalFileStateCache so we can restore it later. SerializeCacheByTranslator serializes
             // instanceLocalFileStateCache by default, so change that to the relativized form, then change it back.
@@ -657,7 +579,7 @@ internal void SerializePrecomputedCacheByTranslator(string stateFile, TaskLoggin
                 {
                     log.LogWarningWithCodeFromResources("General.StateFileAlreadyPresent", stateFile);
                 }
-                SerializeCacheByTranslator(stateFile, log);
+                SerializeCache(stateFile, log);
             }
             finally
             {
